#
# SOUND LOOM RELEASE mac version 17.0.4

#

#################
#	FAVORITES	#
#################

#------ Display ALL favourite processes

proc SeeAllFavorites {btns} {
	global favors favorites prg cdpmenu sl_real evv

	if {!$sl_real} {
		Inf "THE FAVORITE PROCESSES SHOWN IN THE LIST BELOW\nARE THOSE PROCESSES THAT WILL WORK\nWITH THE FILES YOU HAVE CHOSEN\n\nYOU CAN SEE ALL YOUR FAVOURITE PROCESSES\nBY PRESSING THIS BUTTON"
		return
	}
	if [info exists favorites] {
		$btns.use config -text "Remove" -command "RemoveFavorite"
		$btns.add config -text "" -state disabled
		$btns.all config -text "Current" -command "RestoreCurrentFavorites $btns"
		$favors delete 0 end
		foreach favor $favorites {
			set pno   [lindex $favor 0]
			set mno   [lindex $favor 1]
			set menno [lindex $favor 2]
			set pstr [lindex $cdpmenu($menno) $evv(MENUNAME_INDEX)]
			append pstr ": " 
			append pstr [string toupper [lindex $prg($pno) $evv(PROGNAME_INDEX)]]
			if {$mno > 0} {
				append pstr "...."
				incr mno $evv(MODECNT_INDEX)						
				set mstr [lindex $prg($pno) $mno]
				append pstr $mstr
			}
			$favors insert end $pstr
		}
	}
}

#------ Return to normal state of favorites display

proc RestoreCurrentFavorites {btns} {
	global favors
	$btns.use config -text "Use" -command RunFavorite
	$btns.add config -text "Add Last Process" -command AddFavorite -state normal
	$btns.all config -text "See All" -command "SeeAllFavorites $btns"
	$favors delete 0 end
	DisplayFavorites
}

#------ Remove item from favorites list

proc RemoveFavorite {} {
	global favors favorites
	set i [$favors curselection]
	if {([string length $i] > 0) && [AreYouSure]} {
		set favorites [lreplace $favorites $i $i]
		$favors delete $i
		SaveFavorites
	} else {
		Inf "No item selected"
	}
}

#------ Add current process to list of favorites

proc AddFavorite {} {
	global pmask pprg mmod favorites selected_menu sl_real

	if {!$sl_real} {
		Inf "FAVOURITE PROCESSES CAN BE REMEMBERED HERE, AND CALLED LATER WITH A SINGLE BUTTON CLICK"
		return
	}
	if {$pprg <= 0} {
		return
	}
	if [info exists favorites] {
		foreach favor $favorites {
			set fprg [lindex $favor 0]
			set fmod [lindex $favor 1]
			if {$fprg == $pprg && $fmod == $mmod} {
				Inf "This process is already a favorite"
				return
			}
		}
	}
	set thisfavor $pprg
	set thisfavor [concat $thisfavor $mmod $selected_menu]
	lappend favorites $thisfavor
	if [string index $pmask $pprg] {
		AddToCurrentFavorites $thisfavor	;#	If last process relevant to current files
	} else {
		Inf "Favourite process remembered.\n\nNot displayed now\nas not relevant to current infile choice."
	}
	SaveFavorites
}

#------ If the process is applicable to the current file(s), set it to run
 
proc RunFavorite {} {
	global pprg mmod selected_menu current_favorites favors pr2 sl_real

	if {!$sl_real} {
		Inf "FAVORITE PROCESSES CAN BE REMEMBERED AND LISTED HERE.\nA SINGLE CLICK ON AN ITEM IN THIS LIST WILL THEN LAUNCH THAT FAVOURITE PROCESS."
	 	return
	}
	set i [$favors curselection]					;#	Find selected item on fav listing
	if {[llength $i] > 0} {
		set thisfavor [lindex $current_favorites $i]	;#	Get corresponding item in current_favorites
		set pprg [lindex $thisfavor 0]				;#	Get progno and modeno from that item
		set mmod [lindex $thisfavor 1]
		set selected_menu [lindex $thisfavor 2]
		set pr2 1									;# automatically activates program
	} else {
		Inf "No favourite process selected"
	}
}

#------ Display users favorite processes

proc DisplayFavorites {} {
	global pmask favors favorites current_favorites
	catch {unset current_favorites}
	$favors delete 0 end
	if {![info exists pmask]} {
		return
	}
	foreach favor $favorites {
		set pno [lindex $favor 0]
		if [string index $pmask $pno] {	;#	Only add to current favorites if relevant to current files
			if [ProcessIsAvailable $pno] {
				AddToCurrentFavorites $favor
			}
		}
	}
}

#------ Add to Current Favorites display

proc AddToCurrentFavorites {favor} {
	global prg favors current_favorites cdpmenu evv

	set pno   [lindex $favor 0]
	set mno   [lindex $favor 1]
	set menno [lindex $favor 2]
	set pstr    [lindex $cdpmenu($menno) $evv(MENUNAME_INDEX)]
	append pstr ": "
	append pstr [string toupper [lindex $prg($pno) $evv(PROGNAME_INDEX)]]
	if {$mno > 0} {
		append pstr "...."
		incr mno $evv(MODECNT_INDEX)						
		set mstr [lindex $prg($pno) $mno]
		append pstr $mstr
	}
	$favors insert end $pstr
	lappend current_favorites $favor
}

#------ Read users favorite processes

proc ReadFavorites {fileId} {
	global favorites
	while {[gets $fileId line] >= 0} {
		set line [split $line]
		if {[llength $line] > 0} {
			lappend favorites $line
		}
	}
}

#------ Save User-defined Environment & resources to Files, if it has changed

proc SaveFavorites {} {
	global evv favorites

	set fnam [file join $evv(URES_DIR) $evv(FAVORITES)$evv(CDP_EXT)]
	if [catch {open $evv(DFLT_TMPFNAME) w} fileId] {
		Inf "Cannot open temporary file to save new list of favourite processes"
		return
	}				
	foreach favor $favorites {
		puts $fileId "$favor"
	}
	close $fileId
	if [file exists $fnam] {
		if [catch {file delete $fnam} zorg] {
			Inf "Cannot delete existing file of favourite settings: Cannot save new list"
			return
		}
	}
	file rename $evv(DFLT_TMPFNAME) $fnam
}

proc This {thispass} {
	global evv
	set crypt [string range $evv(PI) 2 end]
	set zz 3
	append zz $crypt
	set crypt $zz
	set cryptlen [string length $crypt]

	set thispass [string tolower $thispass]
	set len [string length $thispass]
	set i 0
	set j 0
	while {$i < $len} {
		set c [string index $thispass $i]
		set c [Alphindex $c]
		set k [string index $crypt $j]
		incr c $k
		while {$c > 25} {
			incr c -26
		}
		set c [Indexalph $c]
		if {$i == 0} {
			set newpass $c
		} else {
			append newpass $c
		}
		incr i
		incr j
		if {$j >= $cryptlen} {
			set j 0
		}
	}
	return $newpass
}	

#------ Is super-process an executable which is on the system??

proc ProcessIsAvailable {pno} {
	global cdpmenu execsflag evv

	set i 0
	while {$i < $evv(MAXMENUNO)} {
		if {![string index $execsflag $i]} {
			foreach p_no [lrange $cdpmenu($i) $evv(MENUPROGS_INDEX) end] {
				if [string match $p_no $pno] {
					return 0
				}
			}
		}
		incr i
	}
	return 1
}

##########################
##########################
#						##
#		VOICEBOX		##
#						##
##########################
##########################

#--------- Interface for processing sounds which can be divided into 'Head' and 'Tail' segments

proc SegmentSensitive {} {
	global chlist ch chcnt wl pa evv pr_gettrofs segment wstk total_wksp_cnt no_analplay sn_edit sn_windows released
	global prg_dun prg_abortd simple_program_messages CDPidrun

	catch {unset segment(recycle_savedfile)}

	;#	CONSTANTS FOR ARTICULATION
	set segment(maxrep) 20
	set segment(articons) [list "^" "H" "L" "U"	"D" "?" "!" ">" "<" "|" "'" "x" "X" "3" "m" "t" ")"] 
	set segment(articon_names) [list "^ = ACCENT"	"H = HIGHER" "L  = LOWER" "U = GO UP"	"D = GO DOWN" "?  = QUESTION" "!  = DENY" ]
	lappend segment(articon_names) "> = LONGER"	"< = SHORTER"	"|  = CLIP" "'   = HESITATE" "x  = OMIT" "X  = SILENT" "CntrlUp/Dn = REPEAT" "m  = UM,UR" "t   = TICK" ")    = TIE"
	set segment(rtc,acc)		3
	set segment(rtc,accacc)		5
	set segment(rtc,pshfbot)	[expr pow(2.0,(3.0/$evv(SEMITONES_PER_OCTAVE)))]	;#	minor 3
	set segment(rtc,pshftop)	1.414											;#	Tritone
	set segment(rtc,pshfbotdn)	[expr pow(2.0,(2.0/$evv(SEMITONES_PER_OCTAVE)))]	;#	tone
	set segment(rtc,pshftopdn)	[expr pow(2.0,(4.0/$evv(SEMITONES_PER_OCTAVE)))]	;#	major 3
	set segment(rtc,pshfshfbot)	[expr pow(2.0,(14.0/$evv(SEMITONES_PER_OCTAVE)))]	;#	major 9th	
	set segment(rtc,pshfshftop)	[expr pow(2.0,(9.0/$evv(SEMITONES_PER_OCTAVE)))]	;#	major 6th
	set segment(rtc,pshfshfmin) [expr pow(2.0,(1.0/$evv(SEMITONES_PER_OCTAVE)))]	;#	semitone (for repeat events only)
	set segment(rtc,tstrbot)	1.75											;#	tstretch around 2
	set segment(rtc,tstrtop)	2.25
	set segment(rtc,tstrstrbot)	3.35											;#	tstretch around 3
	set segment(rtc,tstrstrtop)	2.75
	set segment(rtc,tshrbot)	0.5												;#	tshrink around 5/8
	set segment(rtc,tshrtop)	0.75
	set segment(rtc,tshrshrbot)	0.25											;#	tshrink around 1/3
	set segment(rtc,tshrshrtop)	0.4
	set segment(rtc,clipbot)	0.08											;#	clipdur around 100 mS
	set segment(rtc,cliptop)	0.12
	set segment(rtc,hesbot)		0.17											;#	short hesit around 0.2 secs	
	set segment(rtc,hestop)		0.23
	set segment(rtc,heshesbot)	0.35											;#	long hesit around 0.4 secs
	set segment(rtc,heshestop)	0.45
	set segment(rtc,dflthdur)	0.1												;#	Presumed head duration of HT-joined seg if real Head dur not known
	set segment(rtc,dflatkfall)	0.02											;#	Time taken for attack level to fall to normal level
	set segment(rtc,ENV_FSECSIZE) 256											;#	Error check value to tally with CDP "env curtail" program
	set segment(rtc,fmntspan)	4												;#	No of channels to span when looking for vocal formants
	if {![info exists segment(rtc,ticsub)]} {
		set segment(rtc,ticsub)	0												;#	Lessen level of tics
		set segment(rtc,glosub)	0												;#	Lessen level of glossalalia
	}
	set segment(MIDDLE_C)		60.0

	;#	CONSTANTS FOR SHRINK RHYTHM
	set segment(scicons) [list "_" "." "~" "/"] 
	set segment(scicon_names) [list "_        = LONG  " ".      = SHORT  " "~    = LONG REST" "/ = SHORT REST"] 

	set segment(SHRHY_DFLTTEMPO) 200	;#	Default Tempo for Shrink/Rhythm
	set segment(STRSTEP) 0.001			;#	Where Head and Tail stretched differently, timestep between different stretch vals 
	set segment(HTDIV)	3.0				;#	When shrniking HT pairs, don't shrink Head if it's dur is less than 1/3 of the total required shrunk-duration of the HT-pair
	set segment(ONE_OVER_LN2) 1.442695	;#	Used for calculating log-to-base-2
	set segment(testing)  0				;#	Allows unprocessed, and ONLY processed segs to be played, to test effecy of processes
	set segment(noexpand) 0				;#	If set, overrides effect of "segment(expand)" flag
	set segment(multichan) 0			;#	Only "TEXTURE" (at present,Aug 2:2016) can output non-mono data
	set segment(nonewmarks) 0			;#	Flag prevents marks from being recycled
	set segment(timewarped) 0			;#	Flag that timewarping has happened or cannot now happed
	set segment(retimed) 0				;#	Flag that retiming has happened : processing must end

	;#	NB In ensuing listing : Tail processes occur BEFORE Head  processes to force the order TailprocTHENHeadproc in multiprocessing
	;#	BOUNCE is at end of tails because it (may) insert a new file into mix

	set segment(processes) [list TIMESTRETCH		ITERATE				ZIGZAG			SUPPRESS PLUCKED TUNED PITCH		TEXTURE ACCENT TWANG VERGES BOUNCE	RETIME]
	set segment(procnames) [list "SPECTRAL STRETCH"	"ITERATE STRETCH"  "ZIGZAG STRETCH"	SUPPRESS PLUCKED TUNED "PITCH LINE" TEXTURE ACCENT TWANG VERGES BOUNCE	RETIME]
	set segment(proccodes) [list STR				ITR					ZGZ				SUP		PLK		TUN    PCH			TEX		ATK	   TWG	  VRG	 BNC	RET]
	set segment(addsfile)  [list 0					0					0				0		0		0		0			1		0	   0	  0		 0		0]
	set segment(didaddfil) [list 0					0					0				0		0		0		0			0		0	   0	  0		 0		0]

	lappend segment(processes) PINCH	SQUASH	LIQUID		SQUEEZE			DEEPEN	ROUGHEN	RANDSTEP		DEEPREV			TUBEREV				SPIKE
	lappend segment(procnames) PINCH	SQUASH	LIQUIDISE	"HIGH SQUEEZE"	DEEPEN	ROUGHEN	"RANDSTEP IN"	"LOW RESONANCE" "TUBE RESONANCE"	SPIKE
	lappend segment(proccodes) PIN		SQA		LIQ			SQE				DPN		RUF		RSP				DPR				TBR					SPK
	lappend segment(addsfile)  0		0		0			0				0		0		0				0				0					0
	lappend segment(didaddfil) 0		0		0			0				0		0		0				0				0					0

	lappend segment(processes) DISTREP			DELRING			VIBRATO		TREMOLO		REVERB	LOOP	ZIGACCEL	SCAN	FORMOVE			VOCODE	EDOCOV			TRANSFER
	lappend segment(procnames) "WAVESET	REPEAT"	"DELAY RING"	VIBRATO		TREMOLO		REVERB	LOOP	"ZIG ACCEL"	SCAN	"MOVE FORMANTS"	VOCODE	"BE VOCODED"	TRANSFER
	lappend segment(proccodes) REP				RNG				VIB			TRM			REV		LOP		ZAC			SCN		FOM				VOC		EDO				TRF
	lappend segment(addsfile)  0				0				0			0			0		0		0			0		0				0		0				0
	lappend segment(didaddfil) 0				0				0			0			0		0		0			0		0				0		0				0

	set segment(headdellist) [list TUNED PITCH]	;#	Processes that potentially delete (merge into tail) Heads

	set segment(MAXTSTR)	200.0
	set segment(MINTSTR)	2.0
	set segment(DFLTTSTR)	1.0
	set segment(ZIGMIN)		0.031		;#	Min length of a zigzag segment
	set segment(ZIGSPLICE)	0.015		;#	length of a zigzag splice
	set segment(MAXPARAMS)	20			;#	Masimum number of parameter entry boxes
	set segment(ONSET)		0.03		;#	Time from END OF no-tstretch (head) segment to actual START OF abutting tstretch tail-segment
	set segment(SPLICE)		0.015		;#	Splice length for separating segments : MUST be 15mS for compatibility with CDP programs called
	set segment(TWOSPLICE)	[expr ($segment(SPLICE) * 2) + $evv(FLTERR)] 		;#	Min splice len of Tail segments : Dovetail will fail if shorter	
										;#	Also minimum length that can be safely resynthed in PVOC			
	set segment(accentslope) 3.0		;#	When accents added, non-accented shoulders are cresc or diminuendo, using this curvature
	set segment(MSPLICE)	15			;#	mS Splice length for separating segments
	set segment(LEVSHIFT)	1.2			;#	Max level change during iteration which is acceptable
	set segment(TUNECLARPOW) 0.3333		;#	TUNED Clarity, inputrange clarity = 0-1 changed to clarity^TUNECLARPOW
	set segment(envpoints)	16			;#	Number of points in expon envelopes
	set segment(normlev)	0.9			;#	Level for normalised files in ACCENT
	set segment(accentpow)	2.0			;#	Slope of fadedown of tail portion when Hwad accented
	set segment(maxstretch) 4.0			;#	Minimum timestretch when RETIME by spectral stretch (speech-artic plausibility!)
	set segment(brkminstep)	0.02		;#	For brkfiles where a value changes abruptly
	set segment(maxlev) 0.95			;#	Maximum level for wav files
	set segment(trimgate)	0.000305	;#	Topandtail gatelevel
	set segment(gainlimit)	2			;#	When envelopes are interpolated, avoid anomalous spikes in resulting envelope
	set segment(init) 1
	set segment(phrase) 0
	set segment(phraserefine) 0
	set segment(cnt) 0
	set segment(reordercnt) 0
	set segment(reordered)  0
	set segment(disordered) 0
	set segment(hti_init)   0
	set segment(dirname) [file join $evv(URES_DIR) segdir]
	set segment(recycfil) [file join $segment(dirname) recycle_segs$evv(TEXT_EXT)]		;#	Recycled segmentation info

	;#	dur_deviation = allowable deviation in duration of wav and anal file of same source
	;#	These are compared to check that the analfile is related to same-name wav file (and not some other file using same name)
	;#	To calculate this ....

	set segment(RETIME_INIT) 0
	set segment(NO_REMOTIF)	 1
	set segment(REMOTIF)	 2
	set segment(MTFLEVL)	 3
	set segment(NO_MTFLEVL)	 4

	set segment(DELAYED_SIG_IN_MIX)	0.99
	set segment(FEEDBACK)	0.9
	set segment(DELAY_TAIL)	0.2
	set segment(PRESCALE)	0.75	;#	Presecale level for Pitchline-type tuning
	set segment(voicetop)	79		;#	Highest likely MIDI pitch of speaking voice

	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		Inf "SELECT (AT LEAST ONE) SOUND OR ANALYSIS FILE ON CHOSEN FILES LIST"
		return
	}
	foreach fnam $chlist {
		if {!(($pa($fnam,$evv(FTYP)) == $evv(ANALFILE)) \
		      || (($pa($fnam,$evv(FTYP)) == $evv(SNDFILE)) && ($pa($fnam,$evv(CHANS)) == 1)))} {
			Inf "THIS PROCESS WORKS WITH ANALYSIS, OR MONO WAV FILES ONLY"
			return
		}
	}
	set segment(infilecnt) [llength $chlist]

	set fnam [lindex $chlist 0]
	set segment(infnam) $fnam

	;#	GET THE wav FILE WHICH IS ORIGIN OF ana FILE OR VICE VERSA

	if {$pa($fnam,$evv(FTYP)) == $evv(ANALFILE)} {
		set i_chans $pa($fnam,$evv(CHANS))						;#	i_prop = property of 1st analfile on the chosen-files list (1st input anal file)
		set i_origrate $pa($fnam,$evv(ORIGRATE))
		set i_frametime $pa($fnam,$evv(FRAMETIME))
		set i_winlen $pa($fnam,$evv(MLEN))
		set i_analfnam $fnam 
		set in_overlap [GetOverlap $i_chans $i_winlen]			;#	in_prop = value of parameter in CDP-pvoc to create the found props
	} else {
		set i_srate $pa($fnam,$evv(SRATE))
	}
	if {$segment(infilecnt) > 1} {
		foreach ffnam [lrange $chlist 1 end] {
			if {[string match [file rootname $ffnam] [file rootname $segment(infnam)]]} {
				Inf "THE FIRST INPUT FILE CANNOT BE DUPLICATED IN THE CHOSEN FILES LISTING"
				return
			}

			;#	Compare params of further files ON CHOSEN LIST, with known params of previous files on list

			if {$pa($ffnam,$evv(FTYP)) == $evv(ANALFILE)} {			;#	This is an analfile
				if {![info exists i_chans]} {						;#	i.e. This is 1st analfile encountered (hence 1st file must have been a wav file)
					if {$pa($ffnam,$evv(ORIGRATE)) != $i_srate} {
						Inf "INCOMPATIBLE SAMPLING RATE IN FILES $segment(src,0) AND $ffnam"
						return										;#	is it compatible with file 1
					}
					set i_chans		$pa($ffnam,$evv(CHANS))			;#	establish params to be shared by all anal files
					set i_origrate  $pa($ffnam,$evv(ORIGRATE))
					set i_frametime $pa($ffnam,$evv(FRAMETIME))
					set i_winlen $pa($ffnam,$evv(MLEN))
					set in_overlap [GetOverlap $i_chans $i_winlen]
					set i_analfnam $ffnam 
				} else {											;#	if NOT 1st anal file, check compatibility with previous anal files
					if {($i_chans != $pa($ffnam,$evv(CHANS))) || ($i_origrate != $pa($ffnam,$evv(ORIGRATE))) || ($i_winlen != $pa($ffnam,$evv(MLEN)))} {
						Inf "INCOMPATIBLE ANALYSIS PARAMETERS IN FILES $i_analfnam AND $ffnam"
						return
					}
				}
			} else {												;#	This is a wavfile
				if {![info exists i_srate]} {						;#	i.e. This is 1st wavfile encountered (hence 1st file must have been an analfile)
					if {$i_origrate != $pa($ffnam,$evv(SRATE))} {
						Inf "INCOMPATIBLE SAMPLING RATE IN FILES $segment(ana,0) AND $ffnam"
						return
					}
					set i_srate $pa($ffnam,$evv(SRATE))
				} else {											;#	if NOT 1st wav file, check compatibility with previous wav files
					if {$i_srate != $pa($ffnam,$evv(SRATE))} {
						Inf "INCOMPATIBLE SAMPLING RATE IN FILES $segment(src,0) AND $ffnam"
						return
					}
				}
			}
		}
	}
	if {$pa($fnam,$evv(FTYP)) == $evv(ANALFILE)} {
		set segment(ana,0) $segment(infnam)
		set segment(frametime) $pa($segment(infnam),$evv(FRAMETIME))
		set i_frametime $segment(frametime)
		set segment(src,0) [file rootname $segment(infnam)]
		append segment(src,0) $evv(SNDFILE_EXT)
		set iii -1
		if {[file exists $segment(src,0)]} {
			set iii [LstIndx $segment(src,0) $wl]
			if {$iii < 0} {
				if {[FileToWkspace $segment(src,0) 0 0 0 0 1] <= 0} {
					Inf "CANNOT LOAD THE .wav FILE ($segment(src,0)) FROM WHICH THIS ANALYSIS FILE ORIGINATES"
					return
				}
			}
		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd synth $fnam $segment(src,0)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			
			Block "PLEASE WAIT:        CREATING THE WAVEFORM OF THE (1st) INPUT FILE"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN THE WAVEFORM CREATION PROCESS"
				catch {unset CDPidrun}
				unset segment(src,0)
				unset segment(ana,0)
				UnBlock
				return
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE THE WAVEFORM FORMAT OF THE (1st) INPUT FILE"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				unset segment(src,0)
				unset segment(ana,0)
				UnBlock
				return
			}
			if {![file exists $segment(src,0)]} {
				Inf "NO WAVEFORM FORMAT OF THE (1st) INPUT FILE WAS CREATED"
				unset segment(src,0)
				unset segment(ana,0)
				UnBlock
				return
			}
			UnBlock
			if {[FileToWkspace $segment(src,0) 0 0 0 0 1] <= 0} {
				unset segment(src,0)
				unset segment(ana,0)
				return
			}
		}
	} else {
		set segment(src,0) $segment(infnam)
		set segment(ana,0) [file rootname $segment(infnam)]
		append segment(ana,0) $evv(ANALFILE_EXT)
		set jjj -1
		if {[file exists $segment(ana,0)]} {
			set jjj [LstIndx $segment(ana,0) $wl]
			if {$jjj < 0} {
				if {[FileToWkspace $segment(ana,0) 0 0 0 0 1] <= 0} {
;# 2023
					Inf "CANNOT LOAD THE ANALYSIS FILE ($segment(ana,0)) WHICH IS THE SPECTRUM OF THIS WAV FILE"
					return
				}
			}
			if {[info exists i_chans]} {
				if {($i_chans != $pa($segment(ana,0),$evv(CHANS))) || ($i_origrate != $pa($segment(ana,0),$evv(ORIGRATE))) \
				|| ($i_winlen != $pa($segment(ana,0),$evv(MLEN)))} {
					Inf "INCOMPATIBLE ANALYSIS PARAMETERS IN FILES $segment(ana,0) AND $i_analfnam"
					return
				}
			}
			set segment(infnam) $segment(ana,0)
			set segment(frametime) $pa($segment(infnam),$evv(FRAMETIME))
			set i_frametime $segment(frametime)

		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd anal 1 $segment(src,0) $segment(ana,0)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			
			Block "PLEASE WAIT:        CREATING THE SPECTRUM OF THE (1st) INPUT FILE"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN SPECTRUM CREATION PROCESS"
				catch {unset CDPidrun}
				RemovelFromWkspaceLoadedOrCreatedFiles
				UnBlock
				return
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SPECTRUM OF THE (1st) INPUT FILE"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				RemovelFromWkspaceLoadedOrCreatedFiles				
				UnBlock
				return
			}
			if {![file exists $segment(ana,0)]} {
;# 2023			
				Inf "NO SPECTRUM OF THE (1st) INPUT FILE WAS CREATED"
				RemovelFromWkspaceLoadedOrCreatedFiles				
				UnBlock
				return
			}
			UnBlock
			if {[FileToWkspace $segment(ana,0) 0 0 0 0 1] <= 0} {
				RemovelFromWkspaceLoadedOrCreatedFiles
				return
			}
		}
		set i_frametime $pa($segment(ana,0),$evv(FRAMETIME))
	}

	if {$segment(infilecnt) > 1} {
		set kjk 1
		set mjm 2
		foreach fnamz [lrange $chlist 1 end] {

			catch {unset segment(i,$kjk)}
			catch {unset segment(j,$kjk)}
			if {$pa($fnamz,$evv(FTYP)) == $evv(ANALFILE)} {
				if {![info exists i_frametime]} {
					set i_frametime $pa($fnamz,$evv(FRAMETIME))
				}
				set segment(ana,$kjk) $fnamz
				set segment(src,$kjk) [file rootname $fnamz]
				append segment(src,$kjk) $evv(SNDFILE_EXT)
				set segment(i,$kjk) -1
				if {[file exists $segment(src,$kjk)]} {
					set segment(i,$kjk) [LstIndx $segment(src,$kjk) $wl]
					if {$segment(i,$kjk) < 0} {
						if {[FileToWkspace $segment(src,$kjk) 0 0 0 0 1] <= 0} {
							Inf "CANNOT LOAD THE .wav FILE ($segment(src,$kjk)) FROM WHICH THIS ANALYSIS FILE ORIGINATES"
							return
						}
					}
				} else {
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd synth $fnamz $segment(src,$kjk)
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					
					Block "PLEASE WAIT:        CREATING THE WAVEFORM OF INPUT FILE $mjm"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN THE WAVEFORM CREATION PROCESS FOR FILE $mjm"
						catch {unset CDPidrun}
						RemovelFromWkspaceLoadedOrCreatedFiles
						UnBlock
						return
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE THE WAVEFORM FORMAT FOR FILE $mjm"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						RemovelFromWkspaceLoadedOrCreatedFiles
						UnBlock
						return
					}
					if {![file exists $segment(src,$kjk)]} {
						Inf "NO WAVEFORM FORMAT FILE FOR FILE $mjm WAS CREATED"
						UnBlock
						return
					}
					UnBlock
					if {[FileToWkspace $segment(src,$kjk) 0 0 0 0 1] <= 0} {
						RemovelFromWkspaceLoadedOrCreatedFiles
						return
					}
				}
			} else {
				set segment(src,$kjk) $fnamz
				set segment(ana,$kjk) [file rootname $fnamz]
				append segment(ana,$kjk) $evv(ANALFILE_EXT)
				set segment(j,$kjk) -1
				if {[file exists $segment(ana,$kjk)]} {
					set segment(j,$kjk) [LstIndx $segment(ana,$kjk) $wl]
					if {$segment(j,$kjk) < 0} {
						if {[FileToWkspace $segment(ana,$kjk) 0 0 0 0 1] <= 0} {
							Inf "CANNOT LOAD THE ANALYSIS FILE ($segment(ana,$kjk)) WHICH IS THE SPECTRUM OF THIS WAV FILE"
							return
						}
					}
					if {[info exists i_chans]} {
						if {($i_chans != $pa($segment(ana,$kjk),$evv(CHANS))) || ($i_origrate != $pa($segment(ana,$kjk),$evv(ORIGRATE))) \
						|| ($i_winlen != $pa($segment(ana,$kjk),$evv(MLEN)))} {
							Inf "INCOMPATIBLE ANALYSIS PARAMETERS IN FILES $i_analfnam AND $segment(ana,$kjk)"
							return
						}
					} else {
						set i_frametime $pa($segment(ana,$kjk),$evv(FRAMETIME))
					}
				} else {
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $fnamz $segment(ana,$kjk)
					if {[info exists i_chans]} {
						set in_chans $i_chans								;#	i_chans  = channels in file
						incr in_chans -2									;#	in_chans = channels parameter input to pvoc
						lappend cmd -c$in_chans -o$in_overlap
					}
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					
					Block "PLEASE WAIT:        CREATING THE SPECTRUM OF FILE $mjm"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN THE SPECTRUM CREATION PROCESS FOR FILE $mjm"
						catch {unset CDPidrun}
						RemovelFromWkspaceLoadedOrCreatedFiles
						UnBlock
						return
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE THE SPECTRUM OF FILE $mjm"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						RemovelFromWkspaceLoadedOrCreatedFiles
						UnBlock
						return
					}
					if {![file exists $segment(ana,$kjk)]} {
						Inf "NO SPECTRUM OF FILE $mjm WAS CREATED"
						RemovelFromWkspaceLoadedOrCreatedFiles
						UnBlock
						return
					}
					if {![info exists i_frametime]} {
						set i_frametime $pa($segment(ana,$kjk),$evv(FRAMETIME))
					}
					UnBlock
					if {[FileToWkspace $segment(ana,$kjk) 0 0 0 0 1] <= 0} {
						RemovelFromWkspaceLoadedOrCreatedFiles
						return
					}
				}
			}
			incr kjk
			incr mjm
		}
		set segment(vocdur) $pa($segment(src,1),$evv(DUR))		;#	Remember duration of 1st vocoding signal
	}

	;#	IF VODODING WITH 2 SOUND INPUTS IS SELECTED, IS IT POSSIBLE TO CUT UP THE 2nd SOURCE TO USE WITH THE 1ST

	set segment(vocodecut_possible) 0
	if {$segment(infilecnt) == 2} {
		if {$pa($segment(src,1),$evv(DUR)) >= $pa($segment(src,0),$evv(DUR))} {
			set segment(vocodecut_possible) 1
		}
	}

	set segment(chans)  $pa($segment(src,0),$evv(CHANS))
	set segment(insams) $pa($segment(src,0),$evv(INSAMS))
	set segment(srate)  $pa($segment(src,0),$evv(SRATE))
	set segment(dur)    $pa($segment(src,0),$evv(DUR))
	set segment(wavdur) $pa($segment(src,0),$evv(DUR))

	;#	CHECK THAT SAME-NAME wav AND ana FILES ACTUALLY MATCH UP

	set dur_deviation 0.027		;#	KLUDGE

	foreach fnamz [lrange $chlist 0 end] {
		set nam	 [file rootname $fnamz]
		set wnam $nam$evv(SNDFILE_EXT)
		set anam $nam$evv(ANALFILE_EXT)
		set wdur $pa($wnam,$evv(DUR))
		set adur $pa($anam,$evv(DUR))
		if {($adur <= $wdur) || ($adur > $wdur + $dur_deviation)} {
			Inf "FILES $wnam AND $anam DO NOT TALLY IN LENGTH"
			return 0
		}
	}

	set segment(ZIGMAX) [expr $segment(dur) - (2 * $segment(ZIGSPLICE))]

	set segment(dflt_fnam) [file rootname $segment(infnam)]
	append segment(dflt_fnam) "_segs"
	set segment(dflt_rfnam) [file rootname $segment(infnam)]
	append segment(dflt_rfnam) "_rsegs"
	set segment(dflt_cfnam) [file rootname $segment(infnam)]
	append segment(dflt_cfnam) "_csegs"

	;#	ESTABLISH TEMPORARY FILES FOR SEGMENT-DATA PROCESSING

	set segment(troflist)	     $evv(DFLT_OUTNAME)
	append segment(troflist)     0 $evv(TEXT_EXT)
	set segment(troflist_dflt)   $segment(troflist)
	set segment(nutroflist)	     $evv(DFLT_OUTNAME)
	append segment(nutroflist)   1 $evv(TEXT_EXT)
	set segment(nutroflist_dflt) $segment(nutroflist)
	set segment(prectrlfil)		 $evv(DFLT_OUTNAME)
	append segment(prectrlfil)	 2 $evv(TEXT_EXT)
	set segment(prectrlfil_dflt) $segment(prectrlfil)
	set segment(controlfil)		 $evv(DFLT_OUTNAME)
	append segment(controlfil)	 3 $evv(TEXT_EXT)
	set segment(controlfil_dflt) $segment(controlfil)
	set segment(outfnam)		 $evv(DFLT_OUTNAME)
	append segment(outfnam)		 0 $evv(ANALFILE_EXT)
	set segment(outfnam_dflt)	$segment(outfnam)
	set segment(outfnamplay)	 $evv(DFLT_OUTNAME)
	append segment(outfnamplay)	 0 $evv(SNDFILE_EXT)
	set segment(outfnamplay_dflt) $segment(outfnamplay)
	set segment(medianfil)		 $evv(DFLT_OUTNAME)
	append segment(medianfil)	 4 $evv(TEXT_EXT)
	set segment(mixfil)			 $evv(MACH_OUTFNAME)		;#	Stores the output mis from the segment process(es)
	append segment(mixfil)		 00 $evv(TEXT_EXT)
	set segment(envfil)			 $evv(MACH_OUTFNAME)
	append segment(envfil)		 000 $evv(TEXT_EXT)
	set segment(fadesnd)		 $evv(DFLT_OUTNAME)
	append segment(fadesnd)	     000 $evv(SNDFILE_EXT)
	set segment(fadesnd_dflt)	 $segment(fadesnd)
	set segment(othersnd)		 $evv(DFLT_OUTNAME)
	append segment(othersnd)	 0000 $evv(SNDFILE_EXT)
	set segment(othersnd_dflt)	 $segment(othersnd)
	set segment(specfnusnd)		 $evv(DFLT_OUTNAME)
	append segment(specfnusnd)	 00000 $evv(SNDFILE_EXT)

	set segment(controlfil,0)	 $evv(DFLT_OUTNAME)
	append segment(controlfil,0) 0000 $evv(TEXT_EXT)

	set segment(notedata)		 $evv(DFLT_OUTNAME)
	append segment(notedata)	 00000 $evv(TEXT_EXT)
	set segment(notedata2)		 $evv(DFLT_OUTNAME)
	append segment(notedata2)	 01010 $evv(TEXT_EXT)

	set segment(mixdata)		 $evv(DFLT_OUTNAME)
	append segment(mixdata)		 000000 $evv(TEXT_EXT)		;#	Stores any temporary mixdata

	set segment(bakup)			 $evv(DFLT_OUTNAME)
	append segment(bakup)		 0101 $evv(TEXT_EXT)

	set segment(bakupsnd)		 $evv(DFLT_OUTNAME)
	append segment(bakupsnd)	 0101 $evv(SNDFILE_EXT)

	set segment(premix)			 $evv(DFLT_OUTNAME)
	append segment(premix)		 XP $evv(SNDFILE_EXT)

	set segment(exclmix)		 $evv(DFLT_OUTNAME)
	append segment(exclmix)		 XX $evv(SNDFILE_EXT)

	set segment(multiproccnt)   0	;#	Total count of multiple processes for HEADS and TAILS

	set loaded [LoadSegmentationDirs]

	set f .gettrofs
	if [Dlg_Create $f "GET SEGMENTATION INFORMATION" "set pr_gettrofs 0" -width 80 -height 240 -borderwidth $evv(SBDR)] {

		frame $f.00
		frame $f.00.tit
		label $f.00.tit.tit -text "Input File : " -width 48 -fg $evv(SPECIAL) -font bigfnt
		pack $f.00.tit.tit -side left
		button $f.00.f -text "Return to Wkspace"	  -command "set pr_gettrofs 0"			  -width 20
		button $f.00.pl -text "Play Src"   -command "set pr_gettrofs PLAY_INPUT"	          -width 9 -bg $evv(SNCOLOR) -bd 4
		button $f.00.vw -text "View Src"   -command "set pr_gettrofs VIEW_INPUT"	          -width 9 -bg $evv(SNCOLOR) -bd 4
		button $f.00.cc -text "Continue as last call"   -command "set pr_gettrofs CONTINUE"				 -width 20
		button $f.00.rc -text "Recycle output file"     -command "set pr_gettrofs RECYCLE"				 -width 20

		button $f.00.ps -text "Purge Data"		-command "set pr_gettrofs PURGE" -width 10
		button $f.00.qq -text "End Session"		-command "set pr_gettrofs 0; DoWkspaceQuit 1 0" -width 10  -bg $evv(QUIT_COLOR)
		pack $f.00.f $f.00.pl $f.00.vw $f.00.cc $f.00.rc -side left -padx 2 
		pack $f.00.tit -side left -pady 4 -fill x -expand true
		pack $f.00.qq $f.00.ps -side right -padx 2
		pack $f.00 -side top -pady 4 -fill x -expand true
		frame $f.0
		button $f.0.s  -text "Restart"			  -command "set pr_gettrofs SEG_RESTART"       -width 20
		button $f.0.h  -text "Help"				  -command VboxHelp -bg $evv(HELP) -width 4
		button $f.0.p  -text "Load Refined Data"  -command "set segment(phrase) 0; set pr_gettrofs LOAD_REFINED_DATA" -width 20 -bg $evv(EMPH)
		button $f.0.r  -text "Further Refine"	  -command "set segment(phrase) 0; set pr_gettrofs REREFINE"		  -width 20
		button $f.0.ph -text "Load Phrase Data"	  -command "set segment(phrase) 1; set pr_gettrofs LOAD_REFINED_DATA" -width 20 -bg $evv(EMPH)
		button $f.0.pr -text "Refine Phrase Data" -command "set segment(phrase) 1; set pr_gettrofs REREFINE"		  -width 20
		button $f.0.c -text "Load Control Data"	-command "set pr_gettrofs LOAD_CONTROL"        -width 20
		radiobutton $f.0.rd -text "Load Again" -variable segment(again) -value 1 -command GettrofReload
		set segment(again) 0
		checkbutton $f.0.ch -variable segment(expand) -text Expand -command ExpandFix -width 14
		set segment(expand) 0
		pack $f.0.s $f.0.h $f.0.p $f.0.r $f.0.ph $f.0.pr $f.0.c $f.0.rd $f.0.ch -side left -padx 2
		pack $f.0 -side top

		label $f.000 -text ""
		pack $f.000 -side top
		frame $f.1
		radiobutton $f.1.sget -text "Load Existing Seg Data"  -variable segment(action) -value 2 -command "set pr_gettrofs LOAD_SEGMENTATION" -width 24
		radiobutton $f.1.seg  -text "Do Initial Segmentation" -variable segment(action) -value 1 -command "set pr_gettrofs DO_SEGMENTATION"   -width 24
		radiobutton $f.1.feg  -text "Do Phrase Segmentation"  -variable segment(action) -value 3 -command "set pr_gettrofs DO_PHRASE_SEGMENTATION"   -width 24
		pack $f.1.sget $f.1.seg $f.1.feg -side left -padx 4
		pack $f.1 -side top -pady 2

		frame $f.2
		label $f.2.ll -text "SEGMENTATION TYPE:  " -width 20
		radiobutton $f.2.t  -variable segment(type) -text "Mark Troughs" -value 1 -width 16
		radiobutton $f.2.p  -variable segment(type) -text "Mark Peaks"	 -value 2 -width 16
		radiobutton $f.2.pt -variable segment(type) -text "Mark Both"    -value 3 -width 16
		radiobutton $f.2.pc -variable segment(conv) -text "" -value 1 -width 20 -state disabled -disabledforeground [] -command {}
		set segment(type) 0
		set segment(conv) 0
		pack $f.2.ll $f.2.t $f.2.p $f.2.pt $f.2.pc -side left 
		pack $f.2 -side top -pady 2

		frame $f.3
		radiobutton $f.3.s  -variable segment(save) -text "SAVE TO FILE" -value 1 -width 16 -command "SaveTrofData 1" -selectcolor red
		radiobutton $f.3.n  -variable segment(save) -text "DON'T SAVE"   -value 2 -width 16 -command "SaveTrofData 0"
		pack $f.3.s $f.3.n -side left
		pack $f.3 -side top -pady 2

		frame $f.4
		button $f.4.sav	-text "Save Segmentation Data"   -command "set pr_gettrofs SAVE_SEGMENTATION" -width 22
		label $f.4.ll -text "Segmentation Filename  " -width 24
		entry $f.4.segfil -textvariable segment(xfnam) -width 32
		button $f.4.nam -text "Src Name" -command DisplayGettrofSrcfileName	  -width 13
		button $f.4.pnm -text "Previous Name" -command DisplayGettrofLastName -width 13
		pack $f.4.sav $f.4.ll $f.4.segfil $f.4.nam $f.4.pnm -side left -padx 4 
		pack $f.4 -side top -pady 2 -fill x -expand true

		frame $f.5
		button $f.5.edi	-text "Edit Segmentation"  -command "set pr_gettrofs REFINE_SEGMENTATION" -width 20
		pack $f.5.edi -side left
		pack $f.5 -side top -pady 4

		frame $f.6
		radiobutton $f.6.h -text "First Segment is HEAD" -variable segment(headfirst) -value 1 -width 24
		button $f.6.ex	 -text "Export"             -command "set pr_gettrofs EXPORT_HT_DATA"  -width 10 -height 2
		radiobutton $f.6.t -text "First Segment is TAIL" -variable segment(headfirst) -value 0 -width 24
		button $f.6.vw -text "See Segmentation"	 -command "set segment(exportsegs) 1; DisplaySegmentation" -width 18 -bg $evv(SNCOLOR)
		button $f.6.tx -text "Segmentation Text" -command "GettrofMultiInit_and_Mnemonics ENTERTEXT" -width 18
		pack $f.6.vw $f.6.h $f.6.ex $f.6.t $f.6.tx -side left -padx 4
		pack $f.6 -side top -pady 2

		frame $f.7
		button $f.7.tw	 -text "Time Warp"			-command "set pr_gettrofs WARP_PROCESSING" -width 21 -height 2
		button $f.7.tp	 -text "Tail Processing"	-command "set pr_gettrofs TAIL_PROCESSING" -width 21 -height 2
		button $f.7.hp   -text "Head Processing"	-command "set pr_gettrofs HEAD_PROCESSING" -width 21 -height 2
		button $f.7.sp	 -text "Segment Process"	-command "set pr_gettrofs SEGMENT_PROCESS" -width 21 -height 2
		button $f.7.rt	 -text "Retiming"			-command "set pr_gettrofs RETIME_PROCESS"  -width 21 -height 2
		button $f.7.bak	 -text "Backtrack"			-command "ResetGetSyllabTrofs RECHOOSE"    -width 10 -height 2 -bd 4
		pack $f.7.tw $f.7.tp $f.7.sp $f.7.hp $f.7.rt $f.7.bak -side left -padx 6
		pack $f.7 -side top -pady 2

		frame $f.9
		frame $f.9.w
		frame $f.9.h
		frame $f.9.t
		frame $f.9.s
		frame $f.9.r
		label $f.9.w.tit -text "TIMEWARP PROCESSES" -fg $evv(SPECIAL) -width 18
		button $f.9.w.tst -text "SPECTRAL STRETCH" -command "set pr_gettrofs TIMESTRETCH"     -width 18
		button $f.9.w.itr -text "ITERATE STRETCH"  -command "set pr_gettrofs ITERATE"	      -width 18
		button $f.9.w.ziz -text "ZIGZAG STRETCH"   -command "set pr_gettrofs ZIGZAG"		  -width 18
		button $f.9.w.rvl -text "TIME REVERSALS"   -command "set pr_gettrofs REVERSAL"		  -width 18
		pack $f.9.w.tit $f.9.w.tst $f.9.w.itr $f.9.w.ziz $f.9.w.rvl -side top -pady 2

		label $f.9.t.tit -text "TAIL PROCESSES" -fg $evv(SPECIAL) -width 18
		button $f.9.t.gra -text "SUPPRESS"		   -command "set pr_gettrofs SUPPRESS"	      -width 18
		button $f.9.t.plu -text "PLUCKED"		   -command "set pr_gettrofs PLUCKED"	      -width 18
		button $f.9.t.tun -text "TUNED"			   -command "set pr_gettrofs TUNED"			  -width 18
		button $f.9.t.pch -text "PITCH LINE"	   -command "set pr_gettrofs PITCH"			  -width 18
		button $f.9.t.drp -text "WAVESET REPEAT"   -command "set pr_gettrofs DISTREP"		  -width 18
		button $f.9.t.dng -text "DELAY RING"	   -command "set pr_gettrofs DELRING"		  -width 18
		button $f.9.t.vib -text "VIBRATO"		   -command "set pr_gettrofs VIBRATO"		  -width 18
		button $f.9.t.trm -text "TREMOLO"		   -command "set pr_gettrofs TREMOLO"		  -width 18
		button $f.9.t.rev -text "REVERB"		   -command "set pr_gettrofs REVERB"		  -width 18
		button $f.9.t.lop -text "LOOP"			   -command "set pr_gettrofs LOOP"			  -width 18
		button $f.9.t.scn -text "SCAN"			   -command "set pr_gettrofs SCAN"			  -width 18
		button $f.9.t.zac -text "ZIG ACCEL"		   -command "set pr_gettrofs ZIGACCEL"		  -width 18
		button $f.9.t.fom -text "MOVE FORMANTS"	   -command "set pr_gettrofs FORMOVE"		  -width 18
		button $f.9.t.spc -text "VOCODE"		   -command "set pr_gettrofs VOCODE"	      -width 18
		button $f.9.t.for -text "BE VOCODED"	   -command "set pr_gettrofs EDOCOV"		  -width 18
		if {[info exists released(integratetime)]} {
			button $f.9.t.trf -text "TRANSFER"		   -command "set pr_gettrofs TRANSFER"	  -width 18
		} else {
			button $f.9.t.trf -text "" -bd 0 -state disabled -command {}	  -width 18
		}
		button $f.9.t.mny -text "A COMBINATION"	   -command "StartCombinedProcesses"		  -width 18
		pack $f.9.t.tit $f.9.t.gra $f.9.t.plu $f.9.t.tun $f.9.t.pch $f.9.t.drp $f.9.t.dng $f.9.t.vib -side top
		pack $f.9.t.trm $f.9.t.rev $f.9.t.lop $f.9.t.scn $f.9.t.zac $f.9.t.fom $f.9.t.spc $f.9.t.for $f.9.t.trf $f.9.t.mny -side top
		label $f.9.s.tit -text "SEGMENT PROCESSES" -fg $evv(SPECIAL) -width 18
		button $f.9.s.dum -text ""				-command {} -state disabled -bd 0  -width 18
		button $f.9.s.mny -text "A COMBINATION" -command "StartCombinedProcesses"  -width 18
		button $f.9.s.reo -text "REORDER"		-command "set pr_gettrofs REORDER" -width 18
		button $f.9.s.rem -text "REMOTIF"		-command "set pr_gettrofs REMOTIF" -width 18
		button $f.9.s.rtc -text "ARTICULATE"	-command "set pr_gettrofs ARTICULATION"   -width 18
		button $f.9.s.pii -text "PINCH"			-command "set pr_gettrofs PINCH"   -width 18
		button $f.9.s.sqq -text "SQUASH"		-command "set pr_gettrofs SQUASH"  -width 18
		button $f.9.s.lqq -text "LIQUIDISE"		-command "set pr_gettrofs LIQUID"  -width 18
		button $f.9.s.hss -text "HIGH SQUEEZE"	-command "set pr_gettrofs SQUEEZE" -width 18
		button $f.9.s.dpp -text "DEEPEN"		-command "set pr_gettrofs DEEPEN"  -width 18
		button $f.9.s.dpr -text "LOW RESONANCE"	-command "set pr_gettrofs DEEPREV" -width 18
		button $f.9.s.tbr -text "TUBE RESONANCE" -command "set pr_gettrofs TUBEREV" -width 18
		button $f.9.s.rgg -text "ROUGHEN"		-command "set pr_gettrofs ROUGHEN" -width 18
		button $f.9.s.rss -text "RANDSTEP IN"	-command "set pr_gettrofs RANDSTEP" -width 18
		button $f.9.s.spk -text "SPIKE"			-command "set pr_gettrofs SPIKE"	-width 18
		button $f.9.s.sqb -text "SQUEEZEBOX"	-command "set pr_gettrofs SQZBOX"	-width 18
		button $f.9.s.str -text "TIME STRETCH"	-command "set pr_gettrofs TSTRETCH"	-width 18
		pack $f.9.s.tit $f.9.s.dum $f.9.s.mny $f.9.s.reo $f.9.s.rem $f.9.s.rtc $f.9.s.pii $f.9.s.sqq
		pack $f.9.s.lqq $f.9.s.hss $f.9.s.dpp $f.9.s.dpr $f.9.s.tbr $f.9.s.rgg $f.9.s.rss $f.9.s.spk $f.9.s.sqb $f.9.s.str -side top

		label $f.9.h.tit -text "HEAD PROCESSES" -fg $evv(SPECIAL) -width 18
		button $f.9.h.dum -text ""				-command {} -state disabled -bd 0  -width 18
		button $f.9.h.txt -text "TEXTURE" 		-command "set pr_gettrofs TEXTURE" -width 18
		button $f.9.h.bbb -text "BOUNCE"		-command "set pr_gettrofs BOUNCE"  -width 18
		button $f.9.h.stk -text "ACCENT"		-command "set pr_gettrofs ACCENT"  -width 18
		button $f.9.h.crm -text "TWANG"			-command "set pr_gettrofs TWANG"   -width 18
		button $f.9.h.ver -text "VERGES"		-command "set pr_gettrofs VERGES"  -width 18
		button $f.9.h.hep -text "PITCH"			-command "set pr_gettrofs HPITCH"  -width 18
		button $f.9.h.mny -text "A COMBINATION"	-command "StartCombinedProcesses"  -width 18
		pack $f.9.h.tit $f.9.h.dum $f.9.h.txt $f.9.h.bbb $f.9.h.stk $f.9.h.crm $f.9.h.ver $f.9.h.hep $f.9.h.mny -side top

		label $f.9.r.tit -text "RETIMING PROCESSES" -fg $evv(SPECIAL) -width 18
		button $f.9.r.ovr -text "OVERLAP & SPACE"   -command "set segment(retimestyle) OVERLAP; set pr_gettrofs RETIME" -width 18
		button $f.9.r.csp -text "CUT & SPACE"		-command "set segment(retimestyle) CUT;		set pr_gettrofs RETIME" -width 18
		button $f.9.r.shp -text "SHRINK & SPACE"    -command "set segment(retimestyle) SHRINK;	set pr_gettrofs RETIME" -width 18
		button $f.9.r.shr -text "SHRINK & STRETCH"  -command "set segment(retimestyle) STRETCH; set pr_gettrofs RETIME" -width 18
		button $f.9.r.srs -text "SHRINK RHYTHMS"    -command "set pr_gettrofs SHRHYTHM"		  -width 18
		pack $f.9.r.tit $f.9.r.ovr $f.9.r.csp $f.9.r.shp $f.9.r.shr $f.9.r.srs -side top -pady 2

		pack $f.9.w $f.9.t $f.9.s $f.9.h $f.9.r -side left -padx 20 -anchor n 
		pack $f.9 -side top -pady 2
		
		frame $f.9a
		label $f.9a.pnam -text "" -width 40 -foreground $evv(SPECIAL) -font bigfnt
		pack $f.9a.pnam -side left
		pack $f.9a -side top -pady 2

		frame $f.10
		radiobutton $f.10.fixd -text "Fixed Value"  -variable segment(haction) -value 1 -command "ResetGetSyllabTrofs SELECT_CONTROL_TYPE" -width 14
		radiobutton $f.10.tvar -text "Time Varying" -variable segment(haction) -value 2 -command "ResetGetSyllabTrofs SELECT_CONTROL_TYPE" -width 14
		pack $f.10.fixd $f.10.tvar -side left -padx 4
		pack $f.10 -side top -pady 2

		frame $f.11
		radiobutton $f.11.asis  -text "Change as is"	  -variable segment(shape) -value ASIS  -command "GotoControlDataEntry" -width 20
		radiobutton $f.11.flat  -text "Keep start val"    -variable segment(shape) -value FLAT  -command "GotoControlDataEntry" -width 20
		radiobutton $f.11.lin   -text "Move to end val"   -variable segment(shape) -value LIN   -command "GotoControlDataEntry" -width 20
		radiobutton $f.11.tf    -text "To & from mid val" -variable segment(shape) -value TF    -command "GotoControlDataEntry" -width 20
		pack $f.11.asis $f.11.flat $f.11.lin $f.11.tf -side left -padx 4
		pack $f.11 -side top -pady 2
		set segment(shape) 0

		frame $f.12
		button $f.12.vv -text "Variable" -command "ResetGetSyllabTrofs REVERT_DATA_ENTRY_STYLE" -width 8
		button $f.12.dd -text "Default" -command "GettrofVParamDefault"  -width 8
		button $f.12.cc -text "Clear"   -command {set segment(fixed) ""}  -width 8
		label $f.12.ll -text "Fixed value   " -width 16
		entry $f.12.fxv -textvariable segment(fixed) -width 8
		button $f.12.do -text "USE" -command "set pr_gettrofs MAKE_CONTROL_WITH_FIXED_VAL" -width 4
		button $f.12.hh -text "Help" -command "GettrofParamsHelp" -width 5 -bg $evv(HELP)
		pack $f.12.vv $f.12.dd $f.12.cc $f.12.ll $f.12.fxv $f.12.do $f.12.hh -side left -padx 4
		pack $f.12 -side top -pady 2
		set segment(fixed) ""

		frame $f.13
		set n 0
		set k 0
		frame $f.13.$k
		while {$n < $segment(MAXPARAMS)} {
			if {$n % 4 == 0} {
				if {$n > 0} {
					pack $f.13.$k -side top -fill x -expand true
				}
				incr k
				frame $f.13.$k
			}
			entry $f.13.$k.e$n  -textvariable segment(par$n) -width 6
			set segment(entry$n) $f.13.$k.e$n
			label $f.13.$k.ll$n -text "" -width 20 -anchor w
			set segment(label$n) $f.13.$k.ll$n
			pack $segment(entry$n) $segment(label$n) -side left
			incr n
		}
		pack $f.13.$k -side top -fill x -expand true
		incr k
		frame $f.13.$k
		checkbutton	$f.13.$k.1 -variable segment(doentry) -text "USE PARAMS" -command "set pr_gettrofs PARAM_ENTRY" -width 14
		checkbutton	$f.13.$k.2 -variable segment(dodflts) -text "Get Defaults" -command "GettrofParamDefaultsAndVariableParamRanges 0" -width 14
		checkbutton	$f.13.$k.3 -variable segment(doplast) -text "Get Previous" -command "GettrofPreviousParamVals" -width 14
		checkbutton	$f.13.$k.c -variable segment(doclear) -text "Clear" -command "GettrofClearParamVals" -width 14
		checkbutton	$f.13.$k.l -variable segment(dopload) -text "Load Patch" -command "GettrofsLoadParamPatch 0" -width 14
		button $f.13.$k.4 -text Help -command "GettrofParamsHelp" -width 5 -bg $evv(HELP)
		pack $f.13.$k.1 $f.13.$k.2 $f.13.$k.3 $f.13.$k.c $f.13.$k.4 $f.13.$k.l -side left -padx 4
		set segment(doentry) 0
		set segment(dodflts) 0
		set segment(doplast) 0
		set segment(doclear) 0
		set segment(dopload) 0
		set segment(doentrybox) $f.13.$k.1
		set segment(dodefaults) $f.13.$k.2
		set segment(doprevious) $f.13.$k.3
		set segment(doclearing) $f.13.$k.c
		set segment(paramshelp) $f.13.$k.4
		set segment(paramsload) $f.13.$k.l
		pack $f.13.$k -side top
		pack $f.13 -side top -pady 2

		frame $f.14
		button $f.14.pr -text "PROCESS THE SOUND" -command "set pr_gettrofs RUN_PROCESS"	-height 2 -width 20
		button $f.14.cy -text "RECYCLE OUTPUT"	  -command "set pr_gettrofs RECYCLE_OUTPUT"	-height 2 -width 20
		button $f.14.sp -text "Save Params"	      -command "GettrofsSaveParamPatch 0"		-height 2 -width 20
		frame $f.14.pp
		button $f.14.pp.ou -text "Output A Chosen\nSegment"       -command "OutputChosenSeg"			-height 2 -width 14 -bd 4
		button $f.14.pp.pp -text "Play Chosen Segs\nPreprocessed" -command "GettrofPlayProcessedOnly 1"	-height 2 -width 14 -bd 4
		button $f.14.pp.po -text "Play Processed\nSegments"		  -command "GettrofPlayProcessedOnly 0"	-height 2 -width 14 -bd 4
		checkbutton $f.14.pp.tt -variable segment(testing) -text "Test &\nSingle\nSegments" -width 8
		button $f.14.pp.p -text "PLAY" -command "set pr_gettrofs PLAY_OUTPUT"	-height 2 -width 9 -bd 4
		button $f.14.pp.v -text "VIEW" -command "set pr_gettrofs VIEW_OUTPUT"	-height 2 -width 9 -bg $evv(SNCOLOR) -bd 4
		pack $f.14.pp.ou $f.14.pp.pp $f.14.pp.po $f.14.pp.tt  -side left
		pack $f.14.pp.p $f.14.pp.v -side left

		pack $f.14.pp $f.14.pr $f.14.sp $f.14.cy -side left -padx 8
		pack $f.14 -side top -pady 2
		wm resizable $f 0 0
		bind $f <Escape> {set pr_gettrofs 0}
		bind $f <Return> "GetTrofsReturnKeyActions"
	}
	if {$loaded} {
		.gettrofs.00.cc config -text "Continue as last call" -bd 2 -command "set pr_gettrofs CONTINUE" -state normal
	} else {
		.gettrofs.00.cc config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
	}
	if {[info exists segment(recycle_savedfile)]} {
		.gettrofs.00.rc config -text "Recycle output file" -bd 2 -command "set pr_gettrofs RECYCLE" -state normal
	} else {
		.gettrofs.00.rc config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
	}
	.gettrofs.14.pp.tt config -text "\n\n" -state disabled  -disabledforeground []
	.gettrofs.0.ch config -state normal
	.gettrofs.00.tit.tit config -text "Input File : [string toupper [file rootname [file tail $segment(infnam)]]]"

	LoadGettrofParamData
	ResetGetSyllabTrofs INITIALISE
	set pr_gettrofs 0
	set segment(proctyp) ""
	set segment(process) 0
	set segment(cload) 0
	catch {unset segment(didparload)}
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_gettrofs
	while {!$finished} {
		tkwait variable pr_gettrofs
		switch -- $pr_gettrofs {

			DO_SEGMENTATION {					;#	DO SEGMENTATION --> DATAFILE

				set segment(testing) 0
				set segment(phrase) 0
				catch {unset segment(vp)}
				DeleteAllTemporaryFiles
				ResetDfltFilenames
				if {![DoSegmentation $segment(infnam)]} {
					set segment(action) 0
					Inf "CANNOT SEGMENT FILE $segment(infnam)"
					continue
				}
				set segment(returnkeystate) R_SEGSAVE
				ResetGetSyllabTrofs SEGMENTATION_DONE_GOTO_SAVE_DECISION
				set segment(conv) 0
				.gettrofs.2.pc config -text "" -state disabled -disabledforeground [] -command {}
			}

			SAVE_SEGMENTATION {					;#	SAVE DATAFILE

				catch {unset segment(vp)}
				if {![SaveUnrefinedData]} {
					continue
				}
				set segment(returnkeystate) R_SEGREFINE
				ResetGetSyllabTrofs GOTO_REFINE_SEGMENTATION
			}

			LOAD_SEGMENTATION {					;#	LOAD DATAFILE

				set segment(testing) 0
				set segment(timewarped) 0
				set segment(retimed) 0
				set segment(phrase) 0
				GettrofTextCancel
				GettrofMultiCancel
				catch {unset segment(vp)}
				DeleteAllTemporaryFiles
				ResetDfltFilenames
				HideFixedParamEntryBoxes
				ResetGetSyllabTrofs GOTO_LOAD_SEGMENTATION_DATA
				if {![LoadVboxFile RAW]} {
					ResetGetSyllabTrofs INITIALISE
					continue
				}
				set segment(xfnam) $segment(fnam)
				ForceVal .gettrofs.4.segfil $segment(xfnam)
				set segment(troflist) [file join $segment(dirname) $segment(fnam)$evv(TEXT_EXT)]
				set segment(type) 0
				set segment(action) 0
				set segment(returnkeystate) R_SEGREFINE
				ResetGetSyllabTrofs GOTO_REFINE_SEGMENTATION
			}

			DO_PHRASE_SEGMENTATION {					;#	DO SEGMENTATION AS WORDS OR PHRASES (NOT AS HEADS AND TAILS)
														;#	A SAVE TO FILE IS FORCED
				set segment(testing) 0
				catch {unset segment(vp)}
				DeleteAllTemporaryFiles
				ResetDfltFilenames
				set segment(phrase) 1
				ClearAllMnemonicDisplays 1
				if {![EditSegmentation]} {
					set segment(action) 0
					set segment(phrase) 0
					Inf "CANNOT SEGMENT FILE $segment(infnam)"
					continue
				}
				if {![PostRefinementEdit]} {
					ResetGetSyllabTrofs INITIALISE
					continue
				}
				set segment(cnt) [expr [llength $segment(marklist)] - 1]
				if {![SaveRefinedData]} {
					ResetGetSyllabTrofs INITIALISE
					continue
				} elseif {![SegmentSound 0]} {
					ResetGetSyllabTrofs INITIALISE
					continue
				}
				GettrofMakePhraseMixlines
				.gettrofs.6.h config -text "" -state disabled
				.gettrofs.6.t config -text "" -state disabled

				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
				set segment(conv) 0
				.gettrofs.2.pc config -text "" -state disabled -disabledforeground [] -command {}
			}

			REFINE_SEGMENTATION {

				set segment(testing) 0
				catch {unset segment(vp)}
				if {![EditSegmentation]} {
					continue
				}
				if {$segment(phrase)} {
					if {[info exists segment(nochange)]} {
						unset segment(nochange)
						ResetGetSyllabTrofs GOTO_REFINE_SEGMENTATION
						continue
					}
					if {![PostRefinementEdit]} {
						continue
					}
					if {![SaveRefinedData]} {
						continue
					} elseif {![SegmentSound 0]} {
						ResetGetSyllabTrofs INITIALISE
						continue
					}
					GettrofMakePhraseMixlines
					.gettrofs.6.h config -text "" -state disabled
					.gettrofs.6.t config -text "" -state disabled
					.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
					set segment(returnkeystate) R_INACTIVE
					ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
				} else {
					set segment(returnkeystate) R_REFPRESAVE
					ResetGetSyllabTrofs DATA_REFINED_GOTO_SAVE_DECISION	;#	ALLOW FILE TO BE SAVED
				}
			}

			SAVE_REFINED_DATA {			;#	SAVE REFINED DATA

				catch {unset segment(vp)}
				if {$segment(phrase)} {
					ResetGetSyllabTrofs UNSET_HEADFIRST_MESSAGE
				} elseif {$segment(headfirst) < 0} {
					Inf "PLEASE SET HEAD or TAIL FOR FIRST SEGMENT"
					continue
				}
				if {![PostRefinementEdit]} {
					ResetGetSyllabTrofs UNSET_HEADFIRST_MESSAGE
					continue
				}
				ResetGetSyllabTrofs RESET_HEADFIRST_MESSAGE
				if {![SaveRefinedData]} {
					continue
				}
				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
			}
			RECYCLE -
			CONTINUE -
			LOAD_REFINED_DATA {					;#	LOAD PRE-EDITED SEGFILE

				.gettrofs.00.ps config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
				set segment(testing) 0
				set segment(timewarped) 0
				set segment(retimed) 0
				GettrofTextCancel
				GettrofMultiCancel
				ClearAllMnemonicDisplays 0
				catch {unset segment(vp)}
				catch {unset segment(didparload)}
				DeleteAllTemporaryFiles
				catch {PurgeArray $segment(outfnamplay_dflt)}
				ResetDfltFilenames
				ResetProcessBlock 0
				HideFixedParamEntryBoxes
				set segment(returnkeystate) R_INACTIVE
				if {$pr_gettrofs == "CONTINUE"} {
					.gettrofs.00.cc config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					if {![info exists segment(rfnam)]} {
						Inf "NO INFORMATION ABOUT PREVIOUS SEGMENTATION FILE"	;#		Should be impossible
						ResetGetSyllabTrofs INITIALISE
						continue
					}
					if {[string first "_phrs" $segment(rfnam)] > 0} {
						set segment(phrase) 1
							set typ PHRASE
					} else { 
						set segment(phrase) 0
						set typ REFINED
					}
					if {![LoadPreviousVboxFile $segment(rfnam) $typ]} {
						ResetGetSyllabTrofs INITIALISE
						continue
					}
					.gettrofs.0.p   config -bg [option get . background {}]
					.gettrofs.0.ph  config -bg [option get . background {}]
				} elseif {$pr_gettrofs == "RECYCLE"} {
					.gettrofs.00.rc config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					.gettrofs.00.ps config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					if {![RecycleSavedSound]} {
						continue
					}
					if {$segment(ambiguous)} {									;#	IF no seg data OR multiple seg data for this sound
						if {$segment(ambiguous) > 1} {							;#	IF both phrase and segment data are possible
							set segment(phrase) 0								;#	choose which
							set msg "USE THE PHRASE SEGMENTATION ??"
							set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set segment(phrase) 1
							}
						}														;#	Else, two segment-data possibilities ... 
						unset segment(ambiguous)
						ResetGetSyllabTrofs SET_FOR_LOAD_REFINED_DATA			;#	Go to select seg data
						if {$segment(phrase)} {
							if {![LoadVboxFile PHRASE]} {
								ResetGetSyllabTrofs INITIALISE
								continue
							}
						} else {
							if {![LoadVboxFile REFINED]} {
								ResetGetSyllabTrofs INITIALISE
								continue
							}
						}
					} else {
						if {$segment(phrase)} {
							set typ PHRASE
						} else { 
							set typ REFINED
						}
						if {![LoadPreviousVboxFile $segment(rfnam) $typ]} {
							ResetGetSyllabTrofs INITIALISE
							continue
						}
					}
				} else {
					ResetGetSyllabTrofs SET_FOR_LOAD_REFINED_DATA
					if {$segment(phrase)} {
						if {![LoadVboxFile PHRASE]} {
							ResetGetSyllabTrofs INITIALISE
							continue
						}
					} else {
						if {![LoadVboxFile REFINED]} {
							ResetGetSyllabTrofs INITIALISE
							continue
						}
					}
				}
				set segment(xfnam) $segment(rfnam)
				ForceVal .gettrofs.4.segfil $segment(xfnam)
				set segment(nutroflist) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
				set segment(type) 0
				set segment(action) 0
				if {$segment(phrase)} {
					if {![SegmentSound 0]} {
						ResetGetSyllabTrofs INITIALISE
						continue
					}
					GettrofMakePhraseMixlines
					.gettrofs.6.h config -text "" -state disabled
					.gettrofs.6.t config -text "" -state disabled

				} else {
					set segment(headfirst) [GetHeadfirstData $segment(rfnam)]
					.gettrofs.6.h config -text "First Segment is HEAD" -state disabled
					.gettrofs.6.t config -text "First Segment is TAIL" -state disabled
				}
				.gettrofs.6.vw config -text "See Segmentation"  -state normal -bd 2 -command "set segment(exportsegs) 1; DisplaySegmentation" -bg $evv(SNCOLOR)
				.gettrofs.6.tx config -text "Segmentation Text" -state normal -bd 2 -command "GettrofMultiInit_and_Mnemonics ENTERTEXT"
				if {$segment(phrase)} {
					.gettrofs.0.p config -text "" -command {} -bd 0 -bg [option get . background {}]
					.gettrofs.0.r config -text "" -command {} -bd 0
					.gettrofs.0.c config -text "" -command {} -bd 0
					set segment(again) 0
					.gettrofs.0.rd config -text "" -command {} -state disabled -disabledforeground []
					set segment(conv) 0
					.gettrofs.2.pc config -text "" -state disabled -disabledforeground [] -command {}
				} else {
					switch -- $segment(headfirst) {
						0 {
							.gettrofs.6.t config -disabledforeground $evv(POINT) 
							.gettrofs.6.h config -text "" -disabledforeground [] 
						}
						1 { 
							.gettrofs.6.t config -text "" -disabledforeground [] 
							.gettrofs.6.h config -disabledforeground $evv(POINT) 
						}
					}
					.gettrofs.2.pc config -text "MERGE H+T->Phrase" -state normal -command ConvertHTDataToPhraseData
				}
				.gettrofs.0.p   config -bg [option get . background {}]
				.gettrofs.0.ph  config -bg [option get . background {}]
				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
			}

			REREFINE {					;#	LOAD PRE-EDITED SEGFILE TO EDIT FURTHER

				.gettrofs.00.ps config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
				set segment(testing) 0
				set segment(timewarped) 0
				set segment(retimed) 0
				GettrofTextCancel
				GettrofMultiCancel
				catch {unset segment(vp)}
				catch {unset segment(didparload)}
				DeleteAllTemporaryFiles
				catch {PurgeArray $segment(outfnamplay_dflt)}
				ResetDfltFilenames
				ResetProcessBlock 0
				HideFixedParamEntryBoxes
				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs SET_FOR_LOAD_REFINED_DATA
				if {$segment(phrase)} {
					if {![LoadVboxFile PHRASE]} {
						ResetGetSyllabTrofs INITIALISE
						continue
					}
					set testfnam [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
					if [catch {file copy $testfnam $segment(nutroflist)} zit] {
						Inf "CANNOT MAKE COPY TO TEMPORARY FILE $segment(nutroflist) : $zit"
						continue
					}
					.gettrofs.6.h config -text "" -state disabled
					.gettrofs.6.t config -text "" -state disabled
				} else {
					if {![LoadVboxFile REFINED]} {
						ResetGetSyllabTrofs INITIALISE
						continue
					}
				}
				set segment(xfnam) $segment(rfnam)
				ForceVal .gettrofs.4.segfil $segment(xfnam)
				set segment(troflist) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
				set segment(type) 0
				set segment(action) 0
				set segment(returnkeystate) R_SEGREFINE
				ResetGetSyllabTrofs GOTO_REFINE_SEGMENTATION
				set segment(conv) 0
				.gettrofs.2.pc config -text "" -state disabled -disabledforeground [] -command {}
			}

			SAVE_CONTROL_DATA {

				if {![SaveControlData]} {
						continue
				}
				set segment(returnkeystate) R_RUN
 				ResetGetSyllabTrofs CONTROL_DATA_SAVED_GOTO_RUN_PROCESS
			}

			LOAD_CONTROL {					;#	LOAD CONTROL DATA

				.gettrofs.00.ps config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
				GettrofTextCancel
				GettrofMultiCancel
				set segment(timewarped) 0
				set segment(retimed) 0
				catch {unset segment(vp)}
				catch {unset segment(didparload)}
				DeleteAllTemporaryFiles
				catch {PurgeArray $segment(outfnamplay_dflt)}
				ResetDfltFilenames
				HideFixedParamEntryBoxes
				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs SET_FOR_LOAD_CONTROL_DATA
				if {![LoadVboxFile CONTROL]} {
					ResetGetSyllabTrofs INITIALISE
					continue
				}
				set segment(xfnam) $segment(cfnam)
				ForceVal .gettrofs.4.segfil $segment(xfnam)
				set segment(controlfil) [file join $segment(dirname) $segment(cfnam)$evv(TEXT_EXT)]
				set segment(type) 0
				set segment(action) 0
				set segment(cload) 1
				.gettrofs.6.h config -text "" -state disabled -disabledforeground [] 
				.gettrofs.6.t config -text "" -state disabled -disabledforeground [] 
				.gettrofs.6.vw config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				.gettrofs.6.tx config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				set segment(returnkeystate) R_INACTIVE
				ResetProcessBlock TIMESTRETCH_ONLY
			}

			WARP_PROCESSING {

				set segment(proctyp) WARP
				set segment(returnkeystate) R_INACTIVE
 				ResetGetSyllabTrofs CHOOSE_PROCESS
			}

			HEAD_PROCESSING {

				set segment(proctyp) HEAD
				set segment(returnkeystate) R_INACTIVE
 				ResetGetSyllabTrofs CHOOSE_PROCESS
			}

			TAIL_PROCESSING {

				if {$segment(phrase)} {
					set segment(proctyp) PHRASE
				} else {
					set segment(proctyp) TAIL
				}
				set segment(returnkeystate) R_INACTIVE
 				ResetGetSyllabTrofs CHOOSE_PROCESS
			}

			SEGMENT_PROCESS {

				if {$segment(phrase)} {
					set segment(proctyp) PHRASE
				} else {
					set segment(proctyp) WHOLE
				}
				set segment(returnkeystate) R_INACTIVE
 				ResetGetSyllabTrofs CHOOSE_PROCESS
			}

			RETIME_PROCESS {

				set segment(proctyp) RETIME
				set segment(returnkeystate) R_INACTIVE
 				ResetGetSyllabTrofs CHOOSE_PROCESS
			}

			EXPORT_HT_DATA {
				set segment(proctyp) EXPORT
				set segment(returnkeystate) R_GOTO_SAVE_EXPORT_DATA
 				ResetGetSyllabTrofs GOTO_EXPORT_DECISION
			}

			EXPORT_SEGMENTATION {
				if {[ExportSegmentation 0]} {
					set segment(returnkeystate) R_INACTIVE
					ResetGetSyllabTrofs DONE_EXPORT_RETURN_TO_PROCESS_TYPE
				}
			}
			RETIME  {
				if {[NonCompatibleRetime]} {
					continue
				}
				set segment(process) $pr_gettrofs 
				GettrofParamDefaultsAndVariableParamRanges 1
				set OKtex 1
				while {$OKtex} {
					set test [GettrofPresets]					;#	Get chancnt OR load previous param-patch
					if {$test == 2} {							;#	Select to load patch
						if {![GettrofsLoadParamPatch 0]} {		;#	Abandon loading patch, so stay in TextureChancnt window
							continue
						}										;#	Got patch: Initialise parameter counts etc
	 					ResetProcessBlock $pr_gettrofs
						GettrofParamDefaultsAndVariableParamRanges 1
						ResetGetSyllabTrofs PARAMETERS_LOADED_GOTO_RUN_PROCESS
						set OKtex 0 
					} elseif {$test == 0} {						;#	Abandoned (BOTH) setting texture chans or loading a patch
						ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
						ResetProcessBlock 0						;#	Do setup to choose (any) diferent process
						set OKtex 0 
					}
					break
				}
				if {!$OKtex} {									;#	Abandon this process, or skip entering params
					.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					continue
				}
				GettrofParamDefaultsAndVariableParamRanges 1	;#	Initialise parameter values for functions
				ResetProcessBlock $pr_gettrofs
				set segment(returnkeystate) R_RUN
				ResetGetSyllabTrofs CONTROL_DATA_LOADED_GOTO_RUN_PROCESS
			}
			TWANG -
			TUNED -
			PITCH -
			BOUNCE -
			DELRING -
			DISTREP -
			LOOP -
			VERGES -
			TREMOLO -
			REVERB -
			FORMOVE -
			VOCODE	-
			EDOCOV	-
			TRANSFER -
			ZIGACCEL -
			HPITCH -
			TEXTURE {
				set segment(process) $pr_gettrofs 
				if {(($pr_gettrofs == "VOCODE") || ($pr_gettrofs == "EDOCOV") || ($pr_gettrofs == "TRANSFER")) && ($segment(infilecnt) < 2)} {
					Inf "VOCODING OR TRANSFER REQUIRES MORE THAN ONE FILE ON THE CHOSEN FILES LIST"
					continue
				}
				GettrofParamDefaultsAndVariableParamRanges 1 ;#	Sets up RANGES FOR LOAD PATCH
				set OKtex 1
				while {$OKtex} {
					set test [GettrofPresets]					;#	Get chancnt OR load previous param-patch
					if {$test == 2} {							;#	Select to load patch
						if {![GettrofsLoadParamPatch 0]} {		;#	Abandon loading patch, so stay in TextureChancnt window
							continue
						}										;#	Got patch: Initialise parameter counts etc
	 					ResetProcessBlock $pr_gettrofs
						GettrofParamDefaultsAndVariableParamRanges 1
						ResetGetSyllabTrofs PARAMETERS_LOADED_GOTO_RUN_PROCESS
						set OKtex 0 
					} elseif {$test == 0} {						;#	Abandoned (BOTH) setting texture chans or loading a patch
						if {[info exists segment(recycprocess)]} {
																;#	Stay with either HEADS or TAILS	
							ResetProcessBlock ONLY_HEADS_OR_ONLY_TAILS_OR_ONLY_SEGS
						} else {
							ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
							ResetProcessBlock 0					;#	Do setup to choose (any) diferent process
						}
						set OKtex 0 
					}
					break
				}
				if {!$OKtex} {									;#	Abandon this process, or skip entering params
					.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					continue
				}
				GettrofParamDefaultsAndVariableParamRanges 1	;#	Initialise parameter values for functions
				ResetProcessBlock $pr_gettrofs
				if {$segment(process) == "RETIME"} {
					set segment(returnkeystate) R_RUN
					ResetGetSyllabTrofs CONTROL_DATA_LOADED_GOTO_RUN_PROCESS
				} else {
					if {[info exists segment(vp)]} {				;#	If we've got to the time-variable params
						set segment(returnkeystate) R_INACTIVE		;#	We have to choose Fixed/Variable before return key active
					} else {
						set segment(returnkeystate) R_USE_PARAMS	;#	Otherwise we're still on the box-entered parameters, 
					}												;#	All of which we "USE" with one Return stroke
 					ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
				}
			}
			ACCENT -
			STUTTER  -
			SPLINTER {
				set segment(process) $pr_gettrofs 
				if {![GettrofParamDefaultsAndVariableParamRanges 1]} {	;#	Initialise parameter values for functions
					if {[info exists segment(recycprocess)]} {
															;#	Stay with either HEADS or TAILS	
						ResetProcessBlock ONLY_HEADS_OR_ONLY_TAILS_OR_ONLY_SEGS
					} else {
						ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
					}
					ResetProcessBlock 0
					continue
				}
 				ResetProcessBlock $pr_gettrofs
				if {[info exists segment(vp)]} {				;#	If we've got to the time-variable params
					set segment(returnkeystate) R_INACTIVE		;#	We have to choose Fixed/Variable before return key active
				} else {
					set segment(returnkeystate) R_USE_PARAMS	;#	Otherwise we're still on the box-entered parameters, 
				}												;#	All of which we "USE" with one Return stroke
 				ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
			}
			PLUCKED	-
			PITCH	-
			SUPPRESS -
			VIBRATO -
			ZIGACCEL -
			PINCH -
			SQUASH -
			LIQUID -
			SQUEEZE -
			DEEPEN -
			DEEPREV -
			ROUGHEN -
			RANDSTEP -
			SCAN {
				set segment(process) $pr_gettrofs 
				if {![GettrofParamDefaultsAndVariableParamRanges 1]} {	;#	Initialise parameter values for functions
					if {[info exists segment(recycprocess)]} {
						ResetProcessBlock ONLY_HEADS_OR_ONLY_TAILS_OR_ONLY_SEGS
					} else {
						ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
					}
					ResetProcessBlock 0
					continue
				}
 				ResetProcessBlock $pr_gettrofs
				if {($segment(process) == "SUPPRESS") || ($segment(process) == "RANDSTEP")} {
					set segment(returnkeystate) R_RUN
					ResetGetSyllabTrofs CONTROL_DATA_LOADED_GOTO_RUN_PROCESS
					.gettrofs.7.bak config -text "Backtrack" -command "ResetGetSyllabTrofs RECHOOSE" -state normal -bd 4
				} else {
					if {[info exists segment(vp)]} {
						set segment(returnkeystate) R_INACTIVE
					} else {
						set segment(returnkeystate) R_USE_PARAMS
					}
 					ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
				}
			}
			SHRHYTHM -
			ARTICULATION -
			TUBEREV -
			SPIKE -
			SQZBOX -
			TSTRETCH -
			REVERSAL {
				catch {unset segment(intrinsic_pitch)}
				set segment(process) $pr_gettrofs 
				if {![GettrofParamDefaultsAndVariableParamRanges 1]} {	;#	Initialise parameter values for functions
					ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
					ResetProcessBlock 0
					continue
				}
 				set OKtex 1
				while {$OKtex} {
					set test [GettrofPresets]					;#	Get chancnt OR load previous param-patch
					if {$test == 2} {							;#	Select to load patch
						if {![GettrofsLoadParamPatch 0]} {		;#	Abandon loading patch, so stay in ReversalStyle window
							continue
						}										;#	Got patch: Initialise parameter counts etc
	 					ResetProcessBlock $pr_gettrofs
						GettrofParamDefaultsAndVariableParamRanges 1
						ResetGetSyllabTrofs PARAMETERS_LOADED_GOTO_RUN_PROCESS
						set OKtex 0 
					} elseif {$test == 0} {						;#	Abandoned (BOTH) setting reversal style or loading a patch
						ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
						if {($segment(process) == "SHRHYTHM") || ($segment(process) == "ARTICULATION")} {
							set segment(testing) 0
							set segment(timewarped) 0			;#	Go direct to restart
							set segment(retimed) 0
							catch {unset segment(didparload)}
							.gettrofs.0.ch config -state normal
							ResetGetSyllabTrofs INITIALISE
						} else {
							ResetProcessBlock 0					;#	Do setup to choose (any) diferent process
						}
						set OKtex 0 
					}
					break
				}
				if {!$OKtex} {									;#	Abandon this process, or skip entering params
					.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					continue
				}
				ResetProcessBlock $pr_gettrofs
				if {[info exists segment(vp)]} {
					set segment(returnkeystate) R_INACTIVE
				} else {
					set segment(returnkeystate) R_USE_PARAMS
				}
 				ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
			}
			TIMESTRETCH	-
			ITERATE	-
			ZIGZAG {
				set segment(process) $pr_gettrofs 
				GettrofParamDefaultsAndVariableParamRanges 1	;#	Initialise parameter values for functions
 				ResetProcessBlock $pr_gettrofs
				if {$segment(cload)} {
					set segment(returnkeystate) R_RUN
					ResetGetSyllabTrofs CONTROL_DATA_LOADED_GOTO_RUN_PROCESS
				} else {
					if {[info exists segment(vp)] || ($segment(process) == "TIMESTRETCH")} {
						set segment(returnkeystate) R_INACTIVE
					} else {
						set segment(returnkeystate) R_USE_PARAMS
					}
	 				ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
				}
			}

			MAKE_CONTROL_WITH_FIXED_VAL {		;#	Create control file using a fixed entry value
				if {![EnterFixedValue]} {
					continue
				}
			}

			PARAM_ENTRY {
				if {![CheckSegParamsAndEstablishVparamNames]} {
					continue
				}
				.gettrofs.9a.pnam config -text ""
				RememberGettrofParams
				set segment(vp) 1
				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
			}

			RUN_PROCESS {
				.gettrofs.9a.pnam config -text ""
				switch -- $segment(process) {
					STUTTER  -
					SPLINTER {
						if {[NonImplementedProcess $segment(process)]} {
							continue
						}
					}
				}
				if {![RunSegProcess]} {
					if {$segment(multiproccnt)} {
						ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE
					}
					continue
				}
				set segment(timewarped) 1							;#	Once ANY process has been run, cannot return  to timewarp
				if {$segment(multiproccnt)} {
					if {$segment(docnt) < $segment(multiproccnt)} {
						.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
						.gettrofs.14.pr config -text "NEXT PROCESS" -command "set pr_gettrofs MANY_PROCESSES" -state normal -bd 2 -background $evv(EMPH)
					} else {
						.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
						.gettrofs.14.pr config -text "CONCLUDE" -command "set pr_gettrofs MANY_PROCESSES" -state normal -bd 2 -background $evv(EMPH)
					}
				}
			}
			SAVE_SOUND {

				catch {unset segment(vp)}
				if {![TrofsegsSaveSound]} {
					continue
				}
				PossiblySaveDataRelatedToOutputSound
			}

			PLAY_OUTPUT {

				if {![GettrofPlayOutputSound]} {
					continue
				}
			}

			PLAY_INPUT {
				PlaySndfile $segment(src,0) 0
			}

			VIEW_OUTPUT {

				if {![TrofSegOutputSndView]} {
					continue
				}
			}

			VIEW_INPUT {

				if {![TrofSegInputSndView]} {
					continue
				}
			}

			RECYCLE_OUTPUT {

				catch {unset segment(vp)}
				if {![RecycleGetTrofOutput]} {
					continue
				}
				set segment(recyclastprocess) $segment(process)
				ResetGetSyllabTrofs INITIALISE
			}

			PROCESS_HEADS_AFTER_TAILS {

				GettrofRetimeOff
				GettrofDeconvertMultichanFormat
				catch {unset segment(vp)}
				set segment(recycprocess) 1
				set segment(proctyp) HEAD
				ResetGetSyllabTrofs RECYCLE_TO_REPROCESS
			}

			PROCESS_TAILS_AFTER_HEADS {

				GettrofRetimeOff
				GettrofDeconvertMultichanFormat
				catch {unset segment(vp)}
				if {$segment(reordered)} {
					if {![GettrofReorderedRecycle]} {
						set segment(reordered)  0
						set segment(reordercnt) 0
						ResetGetSyllabTrofs INITIALISE
						continue
					}
				} else {
					set segment(recycprocess) 1
				}
				set segment(proctyp) TAIL
				ResetGetSyllabTrofs RECYCLE_TO_REPROCESS
			}
			MANY_PROCESSES {
				.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
				.gettrofs.14.pr config -text "PROCESS THE SOUND" -command "set pr_gettrofs RUN_PROCESS" -state normal -bd 2 -background $evv(EMPH)
				if {![RunProcessInAMultiProcess]} {
					ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE
					continue
				}
			}
			REORDER {
				set segment(process) $pr_gettrofs 
				if {![GettrofMultiInit_and_Mnemonics REORDER]} {
					ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE
					continue
				}
			}
			REMOTIF {
				Inf "NOT YET WRITTEN"
			}
			
			MODIFY_TRANSPOS {
				ModifyTranspositionSet
			}
			SEG_RESTART {	;#	RESTART
				.gettrofs.00.ps config -text "Purge Data" -bd 2 -command "set pr_gettrofs PURGE" -state normal
				set segment(testing) 0
				set segment(timewarped) 0
				set segment(retimed) 0
				catch {unset segment(didparload)}
				.gettrofs.0.ch config -state normal
				ResetGetSyllabTrofs INITIALISE
			}
			PURGE {
				LoadVboxFile PURGE
			}
			0 {
				SaveGettrofParamData
				catch {unset segment(didparload)}
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	SaveSegmentationDirs
	My_Release_to_Dialog $f
	Dlg_Dismiss $f

	;#	If original wav-src-of-analfile OR spectrum-of-wav-file had to be loaded to workspace, remove it now

	RemovelFromWkspaceLoadedOrCreatedFiles
}

################################
# RESET ACTION OF "RETURN" KEY #
################################

#--- Action of hitting "Return" Key

proc GetTrofsReturnKeyActions {} {
	global pr_gettrofs segment wstk

#TEST
#Inf "segment(returnkeystate) = $segment(returnkeystate)"

	switch -- $segment(returnkeystate) {
		R_INACTIVE {
			;#	NO EFFECT
		}
		R_DOSEGMENT {					;#	Segment the file
			set pr_gettrofs DO_SEGMENTATION
		}
		R_SEGSAVE {						;#	File segmented, go directly to save segmentation file
			set segment(xfnam) [.gettrofs.4.segfil get]
			SaveTrofData 1
			set pr_gettrofs SAVE_SEGMENTATION
		}
		R_SEGREFINE {					;#	seg file loaded	OR seg file saved, go directly to editing segmentation
			set pr_gettrofs REFINE_SEGMENTATION
		}
		R_REFPRESAVE {					;#	Go directly to save refined data, only if head/tail type set
			if {!$segment(phrase)} {
				if {$segment(headfirst) < 0} {
					set segment(save) 0
					Inf "PLEASE SET \"HEAD\" or \"TAIL\" FOR FIRST SEGMENT"
					return
				}
			}
			set segment(returnkeystate) R_REFSAVE
			ResetGetSyllabTrofs SAVE_REFINED_DATA_SETUP
		}
		R_REFSAVE {						;#	Save refined segdata
			if {![PostRefinementEdit]} {
				ResetGetSyllabTrofs UNSET_HEADFIRST_MESSAGE
				return
			}
			if {!$segment(phrase)} {
				ResetGetSyllabTrofs RESET_HEADFIRST_MESSAGE
			}
			if {![SaveRefinedData]} {
				return
			}
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE		;#	proceed to using edited data
		}
		R_USE_PARAMS {					;#	Select to use the entered parameters
			if {![CheckSegParamsAndEstablishVparamNames]} {
				catch {unset segment(vp)}
				return
			}
			RememberGettrofParams
			set segment(vp) 1
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
		}
		R_SAVE_CONTROL_DATA {
			set segment(returnkeystate) R_CTLSAVE
			ResetGetSyllabTrofs SAVE_CONTROL_DATA_SETUP
		}
		R_APPLY_FIXED_VAL {
			if {![EnterFixedValue]} {
				return
			}
			if {[IsTimestretchProcess $segment(process)]} {
				set segment(returnkeystate) R_CTLSAVE
			}
		}
		R_CTLSAVE {						;#	Save control data
			if {![SaveControlData]} {
				return
			}
			if {[IsTimestretchProcess $segment(process)]} {
				set segment(returnkeystate) R_RUN
				ResetGetSyllabTrofs TIMEVARIABLE_DATA_SAVED_GOTO_RUN_PROCESS
			}
		}
		R_RUN {							;#	Run process
			.gettrofs.9a.pnam config -text ""
			if {![RunSegProcess]} {
				if {$segment(multiproccnt)} {
					ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE
				}
				return
			}
			if {$segment(multiproccnt)} {
				set pr_gettrofs MANY_PROCESSES
			}
		}
		R_SAVESOUND {					;#	Save sound output
			if {![TrofsegsSaveSound]} {
				return
			}
			PossiblySaveDataRelatedToOutputSound
			set segment(returnkeystate) R_INACTIVE
		}
		R_PLAY {
			if {![TrofSegOutputSndView]} {
				return
			}
		}
		R_GOTO_SAVE_EXPORT_DATA {
			SaveTrofData 7
		}
		R_EXPORT {
			if {[ExportSegmentation 0]} {
				set segment(returnkeystate) R_INACTIVE
				ResetGetSyllabTrofs DONE_EXPORT_RETURN_TO_PROCESS_TYPE
			}
		}
	}
}

#########################
# RECONFIGURE INTERFACE #
#########################

#--- Reconfigure interface after various actions

proc ResetGetSyllabTrofs {val} {
	global segment evv
	switch -- $val {
		INITIALISE {	;#	INITIAL STATE
			if {[info exists segment(recyclastprocess)]} {
				set segment(lastprocess) $segment(recyclastprocess)]
				unset segment(recyclastprocess)
			} else {
				catch {unset segment(lastprocess)}
				set segment(untwang) 0
				set segment(suppress_used) 0
			}
			GettrofTextCancel
			GettrofMultiCancel
			DeleteAllTemporaryFiles
			catch {PurgeArray $segment(outfnamplay_dflt)}
			ResetDfltFilenames
			ClearAllMnemonicDisplays 0
			set segment(phrase) 0
			set segment(phraserefine) 0
			set segment(multiproccnt) 0
			catch {unset segment(segfiles)}
			catch {unset segment(rsegfiles)}
			catch {unset segment(csegfiles)}
			catch {unset segment(recycprocess)}
			catch {unset segment(previousmixchan)}
			set segment(multichan) 0
			catch {unset segment(recycline)}
			catch {unset segment(recycinsert)}
			catch {unset segment(ofnama)}
			catch {unset segment(ofnamw)}
			catch {unset segment(numarks)}
			catch {unset segment(vp)}
			catch {unset segment(mixlines)}
			set segment(csaved) 0
			ResetProcessBlock 0
			set segment(save) 0
			set segment(cload) 0
			catch {unset segment(first_unsaved_preedit)}
			.gettrofs.0.s  config -text "Restart"			 -command "set pr_gettrofs SEG_RESTART"		  -bd 2 -state normal
			.gettrofs.0.p  config -text "Load Refined Data"  -command "set segment(phrase) 0; set pr_gettrofs LOAD_REFINED_DATA" -bd 2 -state normal -bg $evv(EMPH)
			.gettrofs.0.r  config -text "Further Refine"	 -command "set segment(phrase) 0; set pr_gettrofs REREFINE"			 -bd 2 -state normal 
			.gettrofs.0.ph config -text "Load Phrase Data"   -command "set segment(phrase) 1; set pr_gettrofs LOAD_REFINED_DATA" -bd 2 -state normal -bg $evv(EMPH)
			.gettrofs.0.pr config -text "Refine Phrase Data" -command "set segment(phrase) 1; set pr_gettrofs REREFINE"			 -bd 2 -state normal
			.gettrofs.0.c  config -text "Load Control Data"  -command "set pr_gettrofs LOAD_CONTROL"	  -bd 2 -state normal
			.gettrofs.0.rd config -text "Load Again" -command GettrofReload -state normal
			.gettrofs.00.ps config -text "Purge Data" -bd 2 -command "set pr_gettrofs PURGE" -state normal
			set segment(again) 0
			.gettrofs.2.ll config -text "SEGMENTATION TYPE:  "
			.gettrofs.2.p  config -text "Mark Peaks"   -state normal
			.gettrofs.2.t  config -text "Mark Troughs" -state normal
			.gettrofs.2.pt config -text "Mark Both"    -state normal 
			set segment(action) 0
			set segment(headfirst) -1
			.gettrofs.9a.pnam config -text ""
			.gettrofs.6.h config -text "" -state disabled -disabledforeground []
			.gettrofs.6.t config -text "" -state disabled -disabledforeground []
			.gettrofs.6.vw config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.6.tx config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
			if {[info exists segment(oldtype)]} {
				set segment(type) $segment(oldtype)
				unset segment(oldtype)
			} else {
				set segment(type) 0
			}
			.gettrofs.1.seg  config -text "Do Initial Segmentation" -command "set pr_gettrofs DO_SEGMENTATION"   -state normal
			.gettrofs.1.feg  config -text "Do Phrase Segmentation" -command "set pr_gettrofs DO_PHRASE_SEGMENTATION"   -state normal
			.gettrofs.1.sget config -text "Load Existing Seg Data" -command "set pr_gettrofs LOAD_SEGMENTATION" -state normal
			GettrofHideSaveToFile 1
			set segment(xfnam) ""
			ForceVal .gettrofs.4.segfil $segment(xfnam)			;#	BELOW, RECONFIG SEGFIL TO TAKE NAME OF UNREFINED DATA
			.gettrofs.4.segfil config -text "" -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.5.edi config -text "" -command {} -state disabled -bd 0
			HideProcessTypeHeadings
			set segment(haction) 0
			set segment(shape) 0
			HideFixedParamEntryBoxes
			HideParamEntry 1
			HideOutputActions
			set segment(returnkeystate) R_DOSEGMENT
			wm title .gettrofs "GET SEGMENTATION INFORMATION"
		}
		SEGMENTATION_DONE_GOTO_SAVE_DECISION {							;#	IF SEGMENTATION DONE
			if {$segment(type) > 0} {									;#	MAKE INVISIBLE
				set segment(oldtype) $segment(type)						;#	segmentation typing, and do-segmentation
				set segment(type) 0										
			}
			.gettrofs.2.ll config -text ""										
			.gettrofs.2.t  config -text "" -command {} -state disabled
			.gettrofs.2.p  config -text "" -command {} -state disabled
			.gettrofs.2.pt config -text "" -command {} -state disabled
			.gettrofs.1.seg  config -text "" -command {} -state disabled
			.gettrofs.1.feg  config -text "" -command {} -state disabled
			.gettrofs.1.sget config -text "" -command {} -state disabled
			.gettrofs.3.s config -text "SAVE TO FILE" -state normal -command "SaveTrofData 1"
			.gettrofs.3.n config -text "DON'T SAVE"   -state normal -command "SaveTrofData 0" 
			set segment(save) 0
			wm title .gettrofs "KEEP SEGMENTATION INFORMATION ?"
		}
		SAVE_NEW_SEGMENTATION {	;#	SAVE A CREATED SEGFILE
			set segment(save) 0
			GettrofHideSaveToFile 0
			.gettrofs.4.segfil config -state normal -bd 2
			if {[string length $segment(xfnam)] <= 0} {
				set segment(xfnam) $segment(dflt_fnam)
			}
			.gettrofs.4.sav config -text "Save Segmentation Data" -command "set pr_gettrofs SAVE_SEGMENTATION" -state normal -bd 2 -bg $evv(EMPH)
			.gettrofs.4.ll config -text "Segmentation Filename  "
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			focus .gettrofs.4.segfil
			wm title .gettrofs "SAVE SEGMENTATION INFORMATION"
		}
		GOTO_LOAD_SEGMENTATION_DATA {	;#	LOAD AN EXISTING SEG FILE THEN GO 
			.gettrofs.2.ll  config -text ""										
			.gettrofs.2.t   config -text "" -command {} -state disabled
			.gettrofs.2.p   config -text "" -command {} -state disabled
			.gettrofs.2.pt  config -text "" -command {} -state disabled
			.gettrofs.1.seg  config -text "" -command {} -state disabled
			.gettrofs.1.feg  config -text "" -command {} -state disabled
			.gettrofs.1.sget config -text "" -command {} -state disabled
			set segment(save) 0
			GettrofHideSaveToFile 0
			.gettrofs.4.ll  config -text "Segmentation Filename  "
			.gettrofs.4.segfil config -state normal -bd 2
			HideOutputActions
			set segment(csaved) 0
			set segment(phraserefine) 0
			wm title .gettrofs "LOAD SEGMENTATION INFORMATION"
		}
		GOTO_REFINE_SEGMENTATION {	;#	UNREFINED FILE CREATED+SAVED OR LOADED, GO TO REFINE DATA
			set segment(save) 0
			GettrofHideSaveToFile 1
			.gettrofs.4.segfil config -state readonly -fg $evv(SPECIAL)
			if {$segment(phrase)} {
				set segment(phraserefine) 1
			} else {
				set segment(phraserefine) 0
			}
			.gettrofs.0.pr  config  -command "set segment(phrase) 1; set pr_gettrofs REREFINE"
			.gettrofs.5.edi config	-text "Edit Segmentation" -command "set pr_gettrofs REFINE_SEGMENTATION" -state normal -bd 2

			wm title .gettrofs "REFINE SEGMENTATION INFORMATION"
		}
		GOT_SEGDATA_UNSAVED_GOTO_REFINE  {	;#	UNREFINED FILE CREATED BUT NOT SAVED
			set segment(save) 0
			GettrofHideSaveToFile 1
			set segment(xfnam) ""
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.5.edi config	-text "Edit Segmentation" -command "set pr_gettrofs REFINE_SEGMENTATION" -state normal -bd 2
			wm title .gettrofs "REFINE SEGMENTATION INFORMATION"
		}
		SET_FOR_LOAD_REFINED_DATA - 
		SET_FOR_LOAD_CONTROL_DATA {	;#	SET INTERFACE FOR LOAD OF EXISTING DATA FILE (No buttons required)
			.gettrofs.2.ll  config -text ""										
			.gettrofs.2.t   config -text "" -command {} -state disabled
			.gettrofs.2.p   config -text "" -command {} -state disabled
			.gettrofs.2.pt  config -text "" -command {} -state disabled
			.gettrofs.1.seg  config -text "" -command {} -state disabled
			.gettrofs.1.feg  config -text "" -command {} -state disabled
			.gettrofs.1.sget config -text "" -command {} -state disabled
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			.gettrofs.9a.pnam config -text ""
			set segment(save) 0
			GettrofHideSaveToFile 1
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . backgound {}]
			HideProcessTypeHeadings
			HideParamEntry 1
			set segment(shape) 0
			HideOutputActions
			set segment(csaved) 0
			if { $val == "SET_FOR_LOAD_REFINED_DATA"} {
	 			wm title .gettrofs "LOAD REFINED SEGMENTATION INFO"
			} else {
	 			wm title .gettrofs "LOAD CONTROL DATA"
			}
			set segment(phraserefine) 0
		}
		DATA_REFINED_GOTO_SAVE_DECISION {
			.gettrofs.3.s config -text "SAVE TO FILE" -state normal -command "SaveTrofData 3"
			.gettrofs.3.n config -text "DON'T SAVE"   -state normal -command "SaveTrofData 2" 
			ForceVal .gettrofs.4.segfil ""
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.4.nam config	-text "" -command {} -state disabled -bd 0
			.gettrofs.4.pnm config	-text "" -command {} -state disabled -bd 0
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			.gettrofs.6.h config -text "First Segment is HEAD" -state normal
			.gettrofs.6.t config -text "First Segment is TAIL" -state normal
			.gettrofs.6.vw config -text "See Segmentation"  -state normal -bd 2 -command "set segment(exportsegs) 1; DisplaySegmentation" -bg $evv(SNCOLOR)
			.gettrofs.6.tx config -text "Segmentation Text" -state normal -bd 2 -command "GettrofMultiInit_and_Mnemonics ENTERTEXT"
			set segment(headfirst) -1
			set segment(save) 0
			set segment(phraserefine) 0
			wm title .gettrofs "SAVE REFINED SEGMENTATION INFO ???"
		}
		SAVE_REFINED_DATA_SETUP {	;#	SAVE A REFINED-SEGFILE
			set segment(save) 0
			GettrofHideSaveToFile 0
			.gettrofs.4.sav config -text "Save Refined Seg Data" -command "set pr_gettrofs SAVE_REFINED_DATA" -state normal -bd 2 -bg $evv(EMPH)
			.gettrofs.4.ll config -text "Refined Seg Filename  "
			.gettrofs.4.segfil config -state normal -bd 2
			set segment(xfnam) $segment(dflt_rfnam)
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			focus .gettrofs.4.segfil
			wm title .gettrofs "SAVE REFINED SEGMENTATION INFO"
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			.gettrofs.6.h config -state disabled
			.gettrofs.6.t config -state disabled
			switch -- $segment(headfirst) {
				0 { 
					.gettrofs.6.t config -disabledforeground $evv(POINT)
					.gettrofs.6.h config -text "" -disabledforeground []
				}
				1 { 
					.gettrofs.6.t config -text "" -disabledforeground []
					.gettrofs.6.h config -disabledforeground $evv(POINT) 
				}
			}
		}
		UNSET_HEADFIRST_MESSAGE {
			.gettrofs.6.h config -state disabled -text "" -disabledforeground []
			.gettrofs.6.t config -state disabled -text "" -disabledforeground []
		}
		RESET_HEADFIRST_MESSAGE {
			.gettrofs.6.h config -state disabled
			.gettrofs.6.t config -state disabled
			switch -- $segment(headfirst) {
				0 { 
					.gettrofs.6.t config -text "First Segment is TAIL" -disabledforeground $evv(POINT)
					.gettrofs.6.h config -disabledforeground []
				}
				1 { 
					.gettrofs.6.t config -disabledforeground []
					.gettrofs.6.h config -text "First Segment is HEAD" -disabledforeground $evv(POINT) 
				}
			}
		}
		GOT_REFINED_DATA_GOTO_PROCESS_TYPE {	;#	REFINED SEG DATA SAVED, PROCEED TO PROCESSING
			GettrofHideSaveToFile 1
			.gettrofs.4.segfil config -state readonly -fg $evv(SPECIAL)
			if {$segment(phrase)} {
				.gettrofs.6.vw   config -text "See Segmentation"  -command "set segment(exportsegs) 1; DisplaySegmentation" -bg $evv(SNCOLOR) -state normal -bd 2
				.gettrofs.6.tx   config -text "Segmentation Text" -command "GettrofMultiInit_and_Mnemonics ENTERTEXT" -state normal -bd 2
				.gettrofs.7.tw	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.tp	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.hp   config	-text "" -command {} -state disabled -bd 0
			} else {
				if {!$segment(timewarped)} {
					.gettrofs.7.tw	 config	-text "Time Warp"   -command "set pr_gettrofs WARP_PROCESSING" -bd 2 -state normal
				}
				.gettrofs.7.tp	 config	-text "Tail Processing" -command "set pr_gettrofs TAIL_PROCESSING" -bd 2 -state normal
				.gettrofs.7.hp   config	-text "Head Processing"	-command "set pr_gettrofs HEAD_PROCESSING" -bd 2 -state normal
			}
			.gettrofs.7.rt	 config	-text "Retiming"		-command "set pr_gettrofs RETIME_PROCESS"  -bd 2 -state normal
			.gettrofs.7.sp	 config	-text "Segment Process" -command "set pr_gettrofs SEGMENT_PROCESS" -bd 2 -state normal
			set segment(noexpand) 0
			.gettrofs.6.ex	 config	-text "Export"			-command "set pr_gettrofs EXPORT_HT_DATA"  -bd 2 -state normal
			.gettrofs.9.h.tit config -text ""
			.gettrofs.9.t.tit config -text ""
			.gettrofs.9.s.tit config -text ""
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"
		}
		REFINED_UNSAVED_GOTO_PROCESSING {	;#	REFINED SEG DATA NOT SAVED, PROCEED TO PROCESSING
			GettrofHideSaveToFile 1
			ForceVal .gettrofs.4.segfil ""
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}] -disabledforeground $evv(SPECIAL)
			.gettrofs.6.h config -state disabled
			.gettrofs.6.t config -state disabled
			switch -- $segment(headfirst) {
				0 { 
					.gettrofs.6.h config -text "" -disabledforeground []
					.gettrofs.6.t config -disabledforeground $evv(POINT)
				}
				1 { .gettrofs.6.h config -disabledforeground $evv(POINT) }
					.gettrofs.6.t config -text "" -disabledforeground []
			}
			if {$segment(phrase)} {
				.gettrofs.7.tw	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.tp	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.hp   config	-text "" -command {} -state disabled -bd 0
			} else {
				if {!$segment(timewarped)} {
					.gettrofs.7.tw	 config	-text "Time Warp"   -command "set pr_gettrofs WARP_PROCESSING" -bd 2 -state normal
				}
				.gettrofs.7.tp	 config	-text "Tail Processing" -command "set pr_gettrofs TAIL_PROCESSING" -bd 2 -state normal
				.gettrofs.7.hp   config	-text "Head Processing"	-command "set pr_gettrofs HEAD_PROCESSING" -bd 2 -state normal
			}
			set segment(noexpand) 0
			.gettrofs.7.rt	 config	-text "Retiming"		-command "set pr_gettrofs RETIME_PROCESS"  -bd 2 -state normal
			.gettrofs.7.sp	 config	-text "Segment Process"	-command "set pr_gettrofs SEGMENT_PROCESS" -bd 2 -state normal
			.gettrofs.6.ex	 config	-text "Export"			-command "set pr_gettrofs EXPORT_HT_DATA"  -bd 2 -state normal
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"
		}
		MADE_CONTROL_DATA_GOTO_SAVE_DECISION {
			.gettrofs.3.s config -text "SAVE TO FILE" -state normal -command "SaveTrofData 5"
			.gettrofs.3.n config -text "DON'T SAVE"   -state normal -command "SaveTrofData 4" 
			.gettrofs.10.fixd config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.10.tvar config -text "Time Varying" -command {} -state disabled -disabledforeground [option get . foreground {}]
			ForceVal .gettrofs.4.segfil ""
			set segment(xfnam_bakup) $segment(xfnam)
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			set segment(save) 0
			wm title .gettrofs "SAVE CONTROL DATA ???"
		}
		GOTO_EXPORT_DECISION {
			.gettrofs.3.s config -text "SAVE TO FILE" -state normal -command "SaveTrofData 7"
			.gettrofs.3.n config -text "DON'T SAVE"   -state normal -command "SaveTrofData 8" 
			HideProcessTypeHeadings
			ForceVal .gettrofs.4.segfil ""
			set segment(xfnam_bakup) $segment(xfnam)
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			set segment(save) 0
			wm title .gettrofs "EXPORT HEAD-TAIL DATA ???"
		}
		EXPORT_SETUP {	;#	SAVE SEGMENTS AND RELATED MIXFILE
			set segment(save) 0
			.gettrofs.3.n   config -text "" -command {} -state disabled -bd 0
			.gettrofs.3.s   config -text "" -command {} -state disabled -bd 0
			.gettrofs.4.segfil config -state normal -bd 2
			set segment(pre_export_fnam) $segment(xfnam)
			set segment(xfnam) ""
			.gettrofs.4.sav config -text "Save Segments & Mix" -command "set pr_gettrofs EXPORT_SEGMENTATION" -state normal -bd 2 -bg $evv(EMPH)
			.gettrofs.4.ll config -text "Generic Filename  "
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			.gettrofs.4.nam config -text "Src Name" -command DisplayGettrofSrcfileName	 -state normal -bd 2 
			.gettrofs.4.pnm config -text "Previous Name" -command DisplayGettrofLastName -state normal -bd 2 
			focus .gettrofs.4.segfil
			wm title .gettrofs "SAVE SEGMENTATION INFORMATION"
		}
		ABANDON_EXPORT_SETUP {	# ABANDON EXPORTING
			.gettrofs.3.s config   -text "" -command {} -state disabled -bd 0
			.gettrofs.3.n config   -text "" -command {} -state disabled -bd 0
			if {[info exists segment(pre_export_fnam)]} {
				set segment(xfnam) $segment(pre_export_fnam)
				unset segment(pre_export_fnam)
			}
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}] -disabledforeground $evv(SPECIAL)
			if {$segment(phrase)} {
				.gettrofs.7.tw	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.tp	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.hp   config	-text "" -command {} -state disabled -bd 0
			} else {
				if {!$segment(timewarped)} {
					.gettrofs.7.tw	 config	-text "Time Warp"   -command "set pr_gettrofs WARP_PROCESSING" -bd 2 -state normal
				}
				.gettrofs.7.tp	 config	-text "Tail Processing" -command "set pr_gettrofs TAIL_PROCESSING" -bd 2 -state normal
				.gettrofs.7.hp   config	-text "Head Processing" -command "set pr_gettrofs HEAD_PROCESSING" -bd 2 -state normal
			}
			set segment(noexpand) 0
			.gettrofs.7.rt	 config	-text "Retiming"		   -command "set pr_gettrofs RETIME_PROCESS"  -bd 2 -state normal
			.gettrofs.7.sp	 config	-text "Segment Process"	   -command "set pr_gettrofs SEGMENT_PROCESS" -bd 2 -state normal
			.gettrofs.6.ex	 config	-text "Export"			   -command "set pr_gettrofs EXPORT_HT_DATA"  -bd 2 -state normal
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"
		}
		DONE_EXPORT_RETURN_TO_PROCESS_TYPE {	;#	EXPORT SUCCEEDED OR FAILED, RETURN TO PROCESSING
			GettrofHideSaveToFile 1
			if {[info exists segment(pre_export_fnam)]} {
				set segment(xfnam) $segment(pre_export_fnam)
				ForceVal .gettrofs.4.segfil $segment(xfnam)
				unset segment(pre_export_fnam)
			}
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}] -disabledforeground $evv(SPECIAL)
			if {$segment(phrase)} {
				.gettrofs.7.tw	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.tp	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.hp   config	-text "" -command {} -state disabled -bd 0
			} else {
				if {!$segment(timewarped)} {
					.gettrofs.7.tw	 config	-text "Time Warp"   -command "set pr_gettrofs WARP_PROCESSING" -bd 2 -state normal
				}
				.gettrofs.7.tp	 config	-text "Tail Processing" -command "set pr_gettrofs TAIL_PROCESSING" -bd 2 -state normal
				.gettrofs.7.hp   config	-text "Head Processing" -command "set pr_gettrofs HEAD_PROCESSING" -bd 2 -state normal
			}
			set segment(noexpand) 0
			.gettrofs.7.rt	 config	-text "Retiming"		   -command "set pr_gettrofs RETIME_PROCESS"  -bd 2 -state normal
			.gettrofs.7.sp	 config	-text "Segment Process"	   -command "set pr_gettrofs SEGMENT_PROCESS" -bd 2 -state normal
			.gettrofs.6.ex	 config	-text "Export"			   -command "set pr_gettrofs EXPORT_HT_DATA"  -bd 2 -state normal
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"
		}
		SAVE_CONTROL_DATA_SETUP {	;#	SAVE A HEAD-PRESERVING CONTROL-DATA FILE
			set segment(save) 0
			GettrofHideSaveToFile 0
			.gettrofs.4.sav config -text "Save Control Data" -command "set pr_gettrofs SAVE_CONTROL_DATA" -state normal -bd 2 -bg $evv(EMPH)
			.gettrofs.4.ll config -text "ControlData Filename  "
			.gettrofs.4.segfil config -state normal -bd 2 -fg $evv(POINT)
			set segment(xfnam) $segment(dflt_cfnam)
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			focus .gettrofs.4.segfil
			.gettrofs.5.edi config -text "" -command {} -state disabled -bd 0
			HideProcessTypeHeadings
			switch -- $segment(shape) {
				"ASIS" {
					.gettrofs.11.asis  config -text "Change as is" -command {} -state disabled -disabledforeground [option get . foreground {}]
					.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
				}
				"FLAT" {
					.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.flat  config -text "Keep start val" -command {} -state disabled -disabledforeground [option get . foreground {}]
					.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
				}
				"LIN" {
					.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.lin   config -text "Move to end val" -command {} -state disabled -disabledforeground [option get . foreground {}]
					.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
				}
				"TF" {
					.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.11.tf    config -text "To & from mid val" -command {} -state disabled -disabledforeground [option get . foreground {}]
				}
			}
			wm title .gettrofs "SAVE CONTROL DATA"
		}
		SELECT_CONTROL_TYPE {	;#	PROCEED TO CONTROL TYPE
			GettrofHideSaveToFile 1
			.gettrofs.4.segfil config -state readonly -fg $evv(SPECIAL)
			HideProcessTypeHeadings
			switch -- $segment(haction) {
				1 {
					.gettrofs.10.fixd config -text "Fixed Value" -command {} -state disabled -disabledforeground $evv(POINT)
					.gettrofs.10.tvar config -text "" -command {} -state disabled -disabledforeground []
				}
				2 {
					.gettrofs.10.fixd config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.10.tvar config -text "Time Varying" -command {} -state disabled -disabledforeground $evv(POINT)
				}
			}
			.gettrofs.11.asis  config -text "Change as is"	    -command "GotoControlDataEntry" -state normal
			if {$segment(haction) == 2} {
				.gettrofs.11.flat  config -text "Keep start val"    -command "GotoControlDataEntry" -state normal
			} else {
				.gettrofs.11.flat  config -text ""    -command {} -state disabled -disabledforeground []
			}
			.gettrofs.11.lin   config -text "Move to end val"   -command "GotoControlDataEntry" -state normal
			.gettrofs.11.tf    config -text "To & from mid val" -command "GotoControlDataEntry" -state normal
			wm title .gettrofs "SELECT TYPE OF CONTROL"
		}
		TIMEVARIABLE_DATA_SAVED_GOTO_RUN_PROCESS -
		CONTROL_DATA_SAVED_GOTO_RUN_PROCESS {	;#	CONTROL DATA SAVED, PROCEED TO CONTROL TYPE
			GettrofHideSaveToFile 1
			.gettrofs.4.segfil config -state readonly -fg $evv(SPECIAL)
			HideProcessTypeHeadings
			switch -- $segment(haction) {
				1 {
					.gettrofs.10.fixd config -text "Fixed Value" -command {} -state disabled -disabledforeground [option get . foreground {}]
					.gettrofs.10.tvar config -text "" -command {} -state disabled -disabledforeground []
				}
				2 {
					.gettrofs.10.fixd config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.10.tvar config -text "Time Varying" -command {} -state disabled -disabledforeground [option get . foreground {}]
				}
			}
			.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
			.gettrofs.14.pr config -text "PROCESS THE SOUND" -command "set pr_gettrofs RUN_PROCESS" -state normal -bd 2 -background $evv(EMPH)
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"

		}
		CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS {	;#	CONTROL DATA NOT SAVED, PROCEED TO FURTHER PROCESSING
			catch {unset segment(vp)}
			ResetProcessBlock 1
			GettrofHideSaveToFile 1
			if {[info exists segment(xfnam_bakup)]} {
				set segment(xfnam) $segment(xfnam_bakup)
			}
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}] -disabledforeground $evv(SPECIAL)
			HideProcessTypeHeadings
			switch -- $segment(haction) {
				1 {
					.gettrofs.10.fixd config -text "Fixed Value" -command {} -state disabled -disabledforeground [option get . foreground {}]
					.gettrofs.10.tvar config -text "" -command {} -state disabled -disabledforeground []
				}
				2 {
					.gettrofs.10.fixd config -text "" -command {} -state disabled -disabledforeground []
					.gettrofs.10.tvar config -text "Time Varying" -command {} -state disabled -disabledforeground [option get . foreground {}]
				}
			}
			.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
			.gettrofs.14.pr config -text "PROCESS THE SOUND" -command "set pr_gettrofs RUN_PROCESS" -state normal -bd 2 -background $evv(EMPH)
			wm title .gettrofs "$segment(process) PROCESS, USING SEGMENTATION INFORMATION"
		}
		CHOOSE_PROCESS {
#TEST
#Inf "proctyp = $segment(proctyp)"
			switch -- $segment(proctyp) {
				"WARP" {
					catch {unset segment(vp)}
					GettrofRetimeOff
					GettrofWarpOn
					GettrofTailsOff
					GettrofHeadsOff
					GettrofSegmentsOff

				}
				"HEAD" {
					catch {unset segment(vp)}
					GettrofRetimeOff
					GettrofWarpOff
					GettrofTailsOff
					GettrofHeadsOn
					GettrofSegmentsOff

				}
				"TAIL" {
					catch {unset segment(vp)}
					GettrofRetimeOff
					GettrofWarpOff
					GettrofTailsOn
					GettrofHeadsOff
					GettrofSegmentsOff
				}
				"WHOLE" {
					catch {unset segment(vp)}
					GettrofRetimeOff
					GettrofWarpOff
					GettrofTailsOff
					GettrofHeadsOff
					GettrofSegmentsOn 0
				}
				"PHRASE" {
					catch {unset segment(vp)}
					GettrofRetimeOff
					GettrofWarpOff
					GettrofTailsOff
					GettrofHeadsOff
					GettrofSegmentsOn 1				
				}
				"RETIME" {
					catch {unset segment(vp)}
					GettrofRetimeOn
					GettrofWarpOff
					GettrofTailsOff
					GettrofHeadsOff
					GettrofSegmentsOff				
				}
			}
			HideProcessTypeHeadings
		}
		RECHOOSE {
			ResetProcessBlock 0
			DeleteAllTemporaryFiles
			if {![info exists segment(recycprocess)] || !$segment(recycprocess)} {
				DeleteGettrofTestMixes
				set segment(testing) 0
			}
			set segment(returnkeystate) R_INACTIVE
			catch {unset segment(vp)}
			HideParamEntry 1
			set segment(fixed) ""
			ForceVal .gettrofs.12.fxv $segment(fixed)
			HideFixedParamEntryBoxes
			if {[info exists segment(recycprocess)]} {
				if {$segment(proctyp) == "HEAD"} {
					.gettrofs.7.tw	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.tp	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.hp   config	-text "Head Processing"	   -command "set pr_gettrofs HEAD_PROCESSING"    -bd 2 -state normal
					.gettrofs.7.sp	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.rt	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.6.ex	 config	-text "" -command {} -bd 0 -state disabled
				} else {	
					.gettrofs.7.tw	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.tp	 config	-text "Tail Processing"	   -command "set pr_gettrofs TAIL_PROCESSING"    -bd 2 -state normal
					.gettrofs.7.hp   config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.sp	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.rt	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.6.ex	 config	-text "" -command {} -bd 0 -state disabled
				}
			} else {
				set segment(multiproccnt) 0
				if {$segment(phrase)} {
					.gettrofs.7.tw	 config	-text "" -command {} -bd 0 -state disabled
					.gettrofs.7.tp	 config	-text "" -command {} -state disabled -bd 0
					.gettrofs.7.hp   config	-text "" -command {} -state disabled -bd 0
				} else {
					if {!$segment(timewarped)} {
						.gettrofs.7.tw	 config	-text "Time Warp"   -command "set pr_gettrofs WARP_PROCESSING" -bd 2 -state normal
					}
					.gettrofs.7.tp	 config	-text "Tail Processing" -command "set pr_gettrofs TAIL_PROCESSING" -bd 2 -state normal
					.gettrofs.7.hp   config	-text "Head Processing" -command "set pr_gettrofs HEAD_PROCESSING" -bd 2 -state normal
				}
				.gettrofs.7.rt	 config	-text "Retiming"		   -command "set pr_gettrofs RETIME_PROCESS"  -bd 2 -state normal
				.gettrofs.7.sp	 config	-text "Segment Process"	   -command "set pr_gettrofs SEGMENT_PROCESS" -bd 2 -state normal
				.gettrofs.6.ex	 config	-text "Export"			   -command "set pr_gettrofs EXPORT_HT_DATA"  -bd 2 -state normal
			}
			.gettrofs.7.bak config -text "" -command {} -bd 0 -state disabled 
			set segment(noexpand) 0
		}
		CHOOSE_DATA_ENTRY_STYLE {			;#	Heads or Tails selected to process: decide how to process
			wm title .gettrofs "$segment(process) PROCESS, USING SEGMENTATION INFORMATION"
			HideProcessTypeHeadings
			HideFixedValueEntryDisplay
			switch -- $segment(process) {
				"TIMESTRETCH" {
					.gettrofs.10.fixd config	-text "Fixed Value"  -command "ResetGetSyllabTrofs SELECT_CONTROL_TYPE" -state normal
					.gettrofs.10.tvar config	-text "Time Varying" -command "ResetGetSyllabTrofs SELECT_CONTROL_TYPE" -state normal
					set segment(haction) 0
				}
				"REVERSAL" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Type"
						$segment(entry0) config -state disabled -bd 2
						focus $segment(entry0)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"SHRHYTHM" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Tempo"
						$segment(entry0) config -state disabled -bd 2
						$segment(label1) config -text "Rhythm Type"
						$segment(entry1) config -state disabled -bd 2
						$segment(label2) config -text "Shrinksize (mS)"
						$segment(entry2) config -state disabled -bd 2
						$segment(label3) config -text "Accentuation"
						$segment(entry3) config -state disabled -bd 2
						focus $segment(entry0)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"ARTICULATION" {
					if {![info exists segment(vp)]} {
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"PINCH"   {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Vibrato"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"SQUASH"  {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Squash"
						$segment(entry0) config -state normal -bd 2
						$segment(label1) config -text "Formant Number"
						$segment(entry1) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"LIQUID"  {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Rotation Rate"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"SQUEEZE" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Frq Shift"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"DEEPEN"  {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "MIDI Pivot"
						$segment(entry0) config -state normal -bd 2
						$segment(label1) config -text "Deepening"
						$segment(entry1) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"DEEPREV" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Downward semitone transposition (6 to 36)"
						$segment(entry0) config -state normal -bd 2
						$segment(label1) config -text "Stadium Mult(.1 to 3)"
						$segment(entry1) config -state normal -bd 2
						$segment(label2) config -text "Echo count (10 to 800)"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "HiFrq boost (1 to 4)"
						$segment(entry3) config -state normal -bd 2
						$segment(label4) config -text "LoFrq offset (0 to .5)"
						$segment(entry4) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"TUBEREV" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Midi Pitch"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Formant Shift"
						$segment(entry1) config -state normal -bd 2
						$segment(label2) config -text "LoFrq Reverb Stadsize"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "LoFrq Reverb Echo cnt"
						$segment(entry3) config -state normal -bd 2
						$segment(label4) config -text "Total Reverb Stadsize"
						$segment(entry4) config -state normal -bd 2
						$segment(label5) config -text "LoFrq Reverb Echo cnt"
						$segment(entry5) config -state normal -bd 2
						$segment(label6) config -text "Relative level HiFrq"
						$segment(entry6) config -state normal -bd 2
						$segment(label7) config -text "LoFrq Time Offset"
						$segment(entry7) config -state normal -bd 2
						focus $segment(entry1)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"SPIKE" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Type"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Normalised"
						$segment(entry1) config -state readonly -bd 2
						$segment(label2) config -text "Up Slope"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "Down Slope"
						$segment(entry3) config -state normal -bd 2
						$segment(label4) config -text "Up max duration"
						$segment(entry4) config -state normal -bd 2
						$segment(label5) config -text "Down max duration"
						$segment(entry5) config -state normal -bd 2
						focus $segment(entry1)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"ROUGHEN" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Roughness"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"RANDSTEP" {
					if {![info exists segment(vp)]} {
						set segment(shape) 0
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"ITERATE" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Density"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						$segment(label1) config -text "Pitch Spread"
						$segment(entry1) config -state normal -bd 2
						$segment(label2) config -text "Gain"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "Tail End Level"
						$segment(entry3) config -state normal -bd 2
						$segment(label4) config -text "Fade Steepness"
						$segment(entry4) config -state normal -bd 2
						$segment(label5) config -text "Random Seed"
						$segment(entry5) config -state normal -bd 2
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						.gettrofs.10.fixd config	-text "Fixed Value"  -command "GotoControlDataEntry" -state normal
						.gettrofs.10.tvar config	-text "Time Varying" -command "GotoControlDataEntry" -state normal
						set segment(haction) 0
					}
				}
				"ZIGZAG" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Random Seed"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						.gettrofs.10.fixd config	-text "Fixed Value"  -command "GotoControlDataEntry" -state normal
						.gettrofs.10.tvar config	-text "Time Varying" -command "GotoControlDataEntry" -state normal
						set segment(haction) 0
					}
				}
				"SQZBOX" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Squeezebox Type"
						$segment(entry0) config -state normal -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"TREMOLO" -
				"REVERB"  -
				"LOOP"    -
				"DISTREP" -
				"ZIGACCEL" -
				"VERGES" {
					if {![info exists segment(vp)]} {
						switch -- $segment(process) {
							"TREMOLO" { 
								$segment(label0) config -text "Crossfade into"
								$segment(entry0) config -state readonly -bd 2
							}
							"REVERB"  { 
								$segment(label0) config -text "Crossfade into"
								$segment(entry0) config -state readonly -bd 2
							}
							"LOOP"	  { 
								$segment(label0) config -text "Scattered"
								$segment(entry0) config -state readonly -bd 2
							}
							"DISTREP" { 
								$segment(label0) config -text "Telescope Output"
								$segment(entry0) config -state readonly -bd 2
							}
							"ZIGACCEL" { 
								$segment(label0) config -text "Minlen (mS)"
								$segment(entry0) config -state readonly -bd 2
								$segment(label1) config -text "Log Shrink"
								$segment(entry1) config -state readonly -bd 2
							}
							"VERGES"  { 
								$segment(label0) config -text "Boost Verge Level"
								$segment(entry0) config -state readonly -bd 2
							}
						}
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes				;#	Fixed val param(s) are presets, not enterable in window, but are displayed (so saved by "Save Patch")
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"SCAN" -
				"VIBRATO" -
				"TSTRETCH" -
				"HPITCH" {
					if {![info exists segment(vp)]} {
						CheckSegParamsAndEstablishVparamNames		;#	No fixed or preset params, needs to establish vparam names
						set segment(vp) 1							;#	and start counting vparams	
						set segment(shape) 0
						SetupFixvarParam
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"DELRING" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Tune Head"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Crossfade into"
						$segment(entry1) config -state readonly -bd 2
						SetupGettrofParamEntryBoxes
					} else {									;#	Delring has no variable params: go directly to run process
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"PLUCKED" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Antiplucks"
						$segment(entry0) config -state readonly -bd 2
						focus $segment(entry0)
						$segment(label1) config -text "Gain"
						$segment(entry1) config -state normal -bd 2
						$segment(label2) config -text "Tail End Level"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "Fade Steepness"
						$segment(entry3) config -state normal -bd 2
						$segment(label4) config -text "Crossfade"
						$segment(entry4) config -state normal -bd 2
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"TUNED" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Tune Heads also"
						$segment(entry0) config -state readonly -bd 2
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"PITCH" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Tune Heads also"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Weighted median"
						$segment(entry1) config -state readonly -bd 2
						$segment(label2) config -text "Articulated"
						$segment(entry2) config -state readonly -bd 2
						SetupGettrofParamEntryBoxes

					} else {		;#	PITCH HAS NO VARIABLE PARAMS ENTERED AS VPARAMS (1 ENTERED AT PRESET)
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"TEXTURE" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Output chans"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Min Event Gain"
						$segment(entry1) config -state normal -bd 2
						focus $segment(entry1)
						$segment(label2) config -text "Max Event Gain"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "Random Seed"
						$segment(entry3) config -state normal -bd 2
						$segment(label4) config -text "End Level"
						$segment(entry4) config -state normal -bd 2
						$segment(label5) config -text "Fade Steepness"
						$segment(entry5) config -state normal -bd 2
						$segment(label6) config -text "Force Level"
						$segment(entry6) config -state normal -bd 2
						if {!$segment(phrase)} {
							$segment(label7) config -text "Fadeup Tail from"
							$segment(entry7) config -state normal -bd 2
							$segment(label8) config -text "Tfade Steepness"
							$segment(entry8) config -state normal -bd 2
						}
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"BOUNCE" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Trim"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Shrink"
						$segment(entry1) config -state readonly -bd 2
						$segment(label2) config -text "Keep End"
						$segment(entry2) config -state readonly -bd 2
						$segment(label3) config -text "Overlay"
						$segment(entry3) config -state readonly -bd 2
						$segment(label4) config -text "Tail Fadeup from"
						$segment(label5) config -text "Fade Warp"
						if {$segment(PAR3)} {							;#	Bounce lies over Tail; entry of tail fade-up params possible
							$segment(entry4) config -state normal -bd 2
							$segment(entry5) config -state normal -bd 2
						} else {										;#	Bounce does not lie over tail, No fadeup; fadeup params inaccessible
							$segment(entry4) config -state readonly -bd 2
							$segment(entry5) config -state readonly -bd 2
						}
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"ACCENT" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Quieten"
						$segment(entry0) config -state normal -bd 2
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"TWANG" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Untwang"			;#	Decay-tail or Anacrusis?
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Normalise"		;#	Normalise before processing?
						$segment(entry1) config -state readonly -bd 2
						$segment(label2) config -text "Tail Fadeup from"
						$segment(entry2) config -state normal -bd 2
						$segment(label3) config -text "Fade Warp"
						$segment(entry3) config -state normal -bd 2
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam
					}
				}
				"VOCODE" -
				"EDOCOV" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Vocode Style"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Vocode Head Also"
						$segment(entry1) config -state readonly -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam

					}
				}
				"TRANSFER" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Transfer Type"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Gate Level"
						$segment(entry1) config -state readonly -bd 2
						$segment(label2) config -text "Remove Silences"
						$segment(entry2) config -state readonly -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						unset segment(vp)
						set segment(returnkeystate) R_RUN				;#	Go directly to RUN PROCESS (No variable params to enter)
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS

					}
				}
				"FORMOVE" {
					if {![info exists segment(vp)]} {
						$segment(label0) config -text "Use Head Also"
						$segment(entry0) config -state readonly -bd 2
						$segment(label1) config -text "Crossfade to/from"
						$segment(entry1) config -state readonly -bd 2
						focus $segment(entry0)
						SetupGettrofParamEntryBoxes
					} else {
						set segment(shape) 0
						SetupFixvarParam

					}
				}
				"RETIME" -
				"SUPPRESS" {
					set segment(shape) 0
					set segment(haction) 0
				}
				default {
					.gettrofs.10.fixd config	-text "Fixed Value"  -command "ResetGetSyllabTrofs SELECT_CONTROL_TYPE" -state normal
					.gettrofs.10.tvar config	-text "Time Varying" -command "ResetGetSyllabTrofs SELECT_CONTROL_TYPE" -state normal
					set segment(haction) 0
				}
			}
		}
		REVERT_DATA_ENTRY_STYLE {		;#	Change to variable param entry from fixed
			switch -- $segment(process) {
				"TIMESTRETCH" {
					set segment(haction) 2
					.gettrofs.10.fixd config	-text ""  -command {} -state disabled  -disabledforeground []
					.gettrofs.10.tvar config	-text "Time Varying" -command {} -state disabled  -disabledforeground []
					ResetGetSyllabTrofs SELECT_CONTROL_TYPE
				}
				default {
					set segment(haction) 2
					.gettrofs.10.fixd config	-text ""  -command {} -state disabled  -disabledforeground []
					.gettrofs.10.tvar config	-text "Time Varying" -command {} -state disabled  -disabledforeground []
					GotoControlDataEntry
				}
			}
		}
		SHOW_FIXEDVAL_ENTRY {

			.gettrofs.10.fixd config -command {} -state disabled -disabledforeground $evv(POINT)
			.gettrofs.10.tvar config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.12.fxv config -state normal -bd 2
			.gettrofs.12.do  config -text "USE" -command "set pr_gettrofs MAKE_CONTROL_WITH_FIXED_VAL" -state normal -bd 2
			focus .gettrofs.12.fxv
			if {[IsTimestretchProcess $segment(process)]} {
				.gettrofs.12.ll  config -text "Timestretch  "
			} else {
				.gettrofs.12.ll  config -text "Fixed value   "
				.gettrofs.12.hh  config -text "Help" -command "GettrofParamsHelp" -state normal -bd 2 -bg $evv(HELP)
				.gettrofs.12.dd  config -text "Default" -command "GettrofVParamDefault" -state normal -bd 2
				.gettrofs.12.cc  config -text "Clear"   -command {set segment(fixed) ""}  -state normal -bd 2
				.gettrofs.12.vv  config -text "Variable" -command "ResetGetSyllabTrofs REVERT_DATA_ENTRY_STYLE" -state normal -bd 2
			}
			PresetGettrofFixedValBox
			ForceVal .gettrofs.12.fxv $segment(fixed)
			focus .gettrofs.12.fxv
		}
		HIDE_FIXEDVAL_ENTRY {
			set segment(shape) 0
			HideParamUseStyle
			HideFixedValueEntryDisplay
			set segment(fixed) ""
			ForceVal .gettrofs.12.fxv $segment(fixed)
		}
		CONTROL_DATA_LOADED_GOTO_RUN_PROCESS {
			set segment(haction) 0
			HideParamEntry 0
			.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
			.gettrofs.14.pr config -text "PROCESS THE SOUND" -command "set pr_gettrofs RUN_PROCESS" -state normal -bd 2 -background $evv(EMPH)
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"
		}
		PARAMETERS_LOADED_GOTO_RUN_PROCESS {	;#	NO NEED TO ENTER PARAMS
			catch {unset segment(vp)}
			ResetProcessBlock 1
			GettrofHideSaveToFile 1
			if {[info exists segment(xfnam_bakup)]} {
				set segment(xfnam) $segment(xfnam_bakup)
			}
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}] -disabledforeground $evv(SPECIAL)
			HideProcessTypeHeadings
			set segment(haction) 0
			HideParamEntry 0
			.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
			.gettrofs.14.pr config -text "PROCESS THE SOUND" -command "set pr_gettrofs RUN_PROCESS" -state normal -bd 2 -background $evv(EMPH)
			wm title .gettrofs "$segment(process) PROCESS, USING SEGMENTATION INFORMATION"
		}
		OUTPUT_CREATED {
			.gettrofs.14.pr config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.tt config -text "Test &\nSingle\nSegments" -state normal -command GettrofTesting -highlightthickness 2
			bind .gettrofs <Key-space> {GettrofPlayOutputSound}
			
			.gettrofs.14.pp.p config  -text "PLAY" -command "set pr_gettrofs PLAY_OUTPUT"  -state normal -bd 4
			.gettrofs.14.pp.v config  -text "VIEW" -command "set pr_gettrofs VIEW_OUTPUT"  -state normal -bd 4 -bg $evv(SNCOLOR)
			if {!$segment(retimed) && ($segment(process) != "ARTICULATION")} {
				GettrofRetimeOn
			} else {
				set segment(retimed) 0
			}
			if {$segment(reordered)} {
				if {$segment(disordered)} {
					.gettrofs.14.cy config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				} else {
					.gettrofs.14.cy config  -text "PROCESS TAILS?" -command "set pr_gettrofs PROCESS_TAILS_AFTER_HEADS" -state normal -bd 2
				}
			} elseif {[info exists segment(recycprocess)]} {
				if {($segment(recycprocess) == 0) && ($segment(process) != "REVERSAL") && ($segment(process) != "SHRHYTHM") && ($segment(process) != "ARTICULATION") && ($segment(process) != "HPITCH")} {
					.gettrofs.14.cy config  -text "PROCESS HEADS?" -command "set pr_gettrofs PROCESS_HEADS_AFTER_TAILS" -state normal -bd 2
					incr segment(recycprocess)
				} else {
					.gettrofs.14.cy config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				}
			} elseif {[IsTimestretchProcess $segment(process)]} {
				if {$segment(phrase)} {
					.gettrofs.14.cy config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				} else {	
					.gettrofs.14.cy config  -text "RECYCLE OUTPUT" -command "set pr_gettrofs RECYCLE_OUTPUT" -state normal -bd 2
				}
			} elseif {[IsTailProcess $segment(process)]} {
				if {$segment(process) == "TRANSFER"} {
					if {[expr $segment(PAR0) & 4] || [expr $segment(PAR0) & 16]} {

					;#	allow non-satis transpositions to be altered	

						.gettrofs.14.cy config  -text "MODIFY TRANSPOSE?" -command "set pr_gettrofs MODIFY_TRANSPOS" -state normal -bd 2
					}

				} elseif {![info exists segment(crospar)] || ($segment(PAR$segment(crospar)) <= 0.0)} {

					;#	Heads modified by crossfading when tail processed, not available for post-processing
				
					.gettrofs.14.cy config  -text "PROCESS HEADS?" -command "set pr_gettrofs PROCESS_HEADS_AFTER_TAILS" -state normal -bd 2
				}
			} elseif {!$segment(multiproccnt)} {		;#	Previous process was HEAD process
				if {($segment(process) != "VERGES") && ($segment(process) != "REVERSAL") && ($segment(process) != "SHRHYTHM") && ($segment(process) != "ARTICULATION") && ($segment(process) != "HPITCH")} {
					.gettrofs.14.cy config  -text "PROCESS TAILS?" -command "set pr_gettrofs PROCESS_TAILS_AFTER_HEADS" -state normal -bd 2
				}
			}
			.gettrofs.0.p   config -bg [option get . background {}]
			.gettrofs.0.ph  config -bg [option get . background {}]
			if {[info exists segment(didparload)] || $segment(reordered) || ($segment(process) == "ARTICULATION")} {
				.gettrofs.14.sp config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			} else {
				.gettrofs.14.sp config -text "Save Params" -command "GettrofsSaveParamPatch 0" -state normal -bd 2
			}
			.gettrofs.3.s config -text "SAVE TO FILE" -state normal -command "SaveTrofData 6"
			ForceVal .gettrofs.4.segfil ""
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.4.nam config	-text "" -command {} -state disabled -bd 0
			.gettrofs.4.pnm config	-text "" -command {} -state disabled -bd 0
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			set segment(save) 0
			GettrofSegmentsOff
			.gettrofs.7.bak config -text "" -command {} -bd 0 -state disabled 
			wm title .gettrofs "SAVE SOUND OUTPUT ???"
		}
		SAVE_SOUND_SETUP {	;#	SAVE A PROCESSED SOUND
			set segment(save) 0
			.gettrofs.3.s   config -text "" -command {} -state disabled -bd 0
			.gettrofs.3.n   config -text "" -command {} -state disabled -bd 0
			.gettrofs.4.sav config -text "Save Processed Sound" -command "set pr_gettrofs SAVE_SOUND" -state normal -bd 2 -bg $evv(EMPH)
			.gettrofs.4.ll config -text "Sound Filename  "
			.gettrofs.4.segfil config -state normal -bd 2 -fg $evv(POINT)
			set segment(xfnam) ""
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			.gettrofs.4.nam config -text "Src Name"		 -command DisplayGettrofSrcfileName -state normal -bd 2 
			.gettrofs.4.pnm config -text "Previous Name" -command DisplayGettrofLastName    -state normal -bd 2 
			focus .gettrofs.4.segfil
			wm title .gettrofs "SAVE PROCESSED SOUND"
		}
		SOUND_IS_SAVED {		
			.gettrofs.4.sav config -text "" -command {} -state disabled -bd 0 -bg [option get . background {}]
			.gettrofs.4.ll config -text ""
			set segment(xfnam) ""
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			.gettrofs.4.segfil config -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.4.nam config	-text "" -command {} -state disabled -bd 0
			.gettrofs.4.pnm config	-text "" -command {} -state disabled -bd 0
		}
		RECYCLE_TO_REPROCESS {
			catch {file delete $segment(outfnamplay_dflt)} 
			catch {PurgeArray $segment(outfnamplay_dflt)}
			catch {unset segment(vp)}
			set segment(csaved) 0
			set segment(save) 0
			set segment(cload) 0
			catch {unset segment(first_unsaved_preedit)}
			.gettrofs.0.p   config -text ""	-command {} -state disabled -bd 0 -bg [option get . background {}]
			.gettrofs.0.r   config -text ""	-command {} -state disabled -bd 0
			.gettrofs.0.ph  config -text ""	-command {} -state disabled -bd 0 -bg [option get . background {}]
			.gettrofs.0.pr  config -text ""	-command {} -state disabled -bd 0
			.gettrofs.0.c   config -text ""	-command {} -state disabled -bd 0
			set segment(again) 0
			.gettrofs.0.rd config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.1.seg  config -text "" -command {} -state disabled
			.gettrofs.1.feg  config -text "" -command {} -state disabled
			.gettrofs.1.sget config -text "" -command {} -state disabled
			.gettrofs.2.ll config -text ""										
			.gettrofs.2.t  config -text "" -command {} -state disabled
			.gettrofs.2.p  config -text "" -command {} -state disabled
			.gettrofs.2.pt config -text "" -command {} -state disabled
			set segment(action) 0
			GettrofHideSaveToFile 1
			.gettrofs.4.segfil config -text "" -state disabled -bd 0 -disabledbackground [option get . background {}]
			.gettrofs.5.edi config	-text "" -command {} -state disabled -bd 0
			.gettrofs.6.h config -text "" -state disabled -disabledforeground []
			.gettrofs.6.t config -text "" -state disabled -disabledforeground []
			.gettrofs.6.vw config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.6.tx config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			set segment(type) 0
			HideProcessTypeHeadings
			set segment(shape) 0
			HideParamEntry 1
			.gettrofs.14.pp.ou config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.pp config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.po config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.tt config -text "\n\n" -state disabled  -disabledforeground []
			bind .gettrofs <Key-space> {}
			.gettrofs.14.pp.p config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.v config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pr config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.cy config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.sp config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			ResetProcessBlock ONLY_HEADS_OR_ONLY_TAILS_OR_ONLY_SEGS
			.gettrofs.7.bak config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			wm title .gettrofs "NOW PROCESS $segment(proctyp)S"
			set segment(returnkeystate) R_INACTIVE
		}
		RESTORE_AFTER_RECYCLE {
			set segment(multiproccnt) 0
			DeleteAllTemporaryFiles
			catch {file delete $segment(outfnamplay_dflt)} 
			catch {PurgeArray $segment(outfnamplay_dflt)}
			catch {unset segment(vp)}
			set segment(csaved) 0
			set segment(save) 0
			set segment(cload) 0
			GettrofMultiCancel
			catch {unset segment(recycprocess)}
			.gettrofs.0.s  config -text "Restart"			 -command "set pr_gettrofs SEG_RESTART"	-bd 2 -state normal
			.gettrofs.0.p  config -text "Load Refined Data"  -command "set segment(phrase) 0; set pr_gettrofs LOAD_REFINED_DATA" -bd 2 -state normal -bg $evv(EMPH)
			.gettrofs.0.r  config -text "Further Refine"	 -command "set segment(phrase) 0; set pr_gettrofs REREFINE"			 -bd 2 -state normal
			.gettrofs.0.ph config -text "Load Phrase Data"   -command "set segment(phrase) 1; set pr_gettrofs LOAD_REFINED_DATA" -bd 2 -state normal -bg $evv(EMPH)
			.gettrofs.0.pr config -text "Refine Phrase Data" -command "set segment(phrase) 1; set pr_gettrofs REREFINE"			 -bd 2 -state normal
			.gettrofs.0.c  config -text "Load Control Data"  -command "set pr_gettrofs LOAD_CONTROL" -bd 2 -state normal
			.gettrofs.0.rd config -text "Load Again" -command GettrofReload -state normal
			set segment(again) 0
			if {$segment(phrase)} {
				.gettrofs.7.tw	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.tp	 config	-text "" -command {} -state disabled -bd 0
				.gettrofs.7.hp   config	-text "" -command {} -state disabled -bd 0
			} else {
				if {!$segment(timewarped)} {
					.gettrofs.7.tw	 config	-text "Time Warp"   -command "set pr_gettrofs WARP_PROCESSING" -bd 2 -state normal
				}
				.gettrofs.7.tp	 config	-text "Tail Processing" -command "set pr_gettrofs TAIL_PROCESSING" -bd 2 -state normal
				.gettrofs.7.hp   config	-text "Head Processing" -command "set pr_gettrofs HEAD_PROCESSING" -bd 2 -state normal
			}
			set segment(noexpand) 0
			.gettrofs.7.rt	 config	-text "Retiming"		   -command "set pr_gettrofs RETIME_PROCESS"  -bd 2 -state normal
			.gettrofs.7.sp	 config	-text "Segment Process"	   -command "set pr_gettrofs SEGMENT_PROCESS" -bd 2 -state normal
			.gettrofs.6.ex	 config	-text "Export"			   -command "set pr_gettrofs EXPORT_HT_DATA"  -bd 2 -state normal
			.gettrofs.7.bak config -text "" -command {} -bd 0 -state disabled -bg [option get . background {}]
			HideParamEntry 1
			HideFixedParamEntryBoxes
			.gettrofs.14.pp.ou config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.pp config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.po config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.tt config -text "\n\n" -state disabled  -disabledforeground []
			bind .gettrofs <Key-space> {}
			.gettrofs.14.pp.p config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pp.v config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.pr config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.cy config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.14.sp config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			ResetProcessBlock 0
			wm title .gettrofs "PROCESS, USING SEGMENTATION INFORMATION"
			set segment(returnkeystate) R_INACTIVE
		}
	}
}

#--- Reconfigure interface (and, after refined segmentation, do postedit) after saving or not-saving a datafile (raw, refined or control)

proc SaveTrofData {dosave} {
	global segment
	switch -- $dosave {
		0 {
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs GOT_SEGDATA_UNSAVED_GOTO_REFINE 	;#	segfilename is left blank, proceed to editing data
		}
		1 {
			ResetGetSyllabTrofs SAVE_NEW_SEGMENTATION				;#	Allow initial segfile to be saved
		} 
		2 {
			if {![info exists segment(first_unsaved_preedit)]} {
				Inf "UNSAVED DATA WILL BE USED: MAY STILL NEED PRE-EDITING"
				set segment(first_unsaved_preedit) 1
			}
			if {!$segment(phrase)} {
				if {$segment(headfirst) < 0} {
					set segment(save) 0
					Inf "PLEASE SET \"HEAD\" or \"TAIL\" FOR FIRST SEGMENT"
					return
				}
			}
			if {![PostRefinementEdit]} {
				return
			}
			if {[info exists segment(first_unsaved_preedit)]} {
				Inf "PRE-EDITING COMPLETE"
				unset segment(first_unsaved_preedit)
			}
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs REFINED_UNSAVED_GOTO_PROCESSING		;#	segfilename is left blank, proceed to using edited data
		} 
		3 {
			if {!$segment(phrase)} {
				if {$segment(headfirst) < 0} {
					set segment(save) 0
					Inf "PLEASE SET \"HEAD\" or \"TAIL\" FOR FIRST SEGMENT"
					return
				}
			}
			catch {unset segment(first_unsaved_preedit)}
			set segment(returnkeystate) R_REFSAVE
			ResetGetSyllabTrofs SAVE_REFINED_DATA_SETUP				 ;#	Allow refined segfile to be saved
		} 
		4 {
			set segment(returnkeystate) R_RUN
			ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS	;#	controlfile not saved, proceed to processing sound
		}
		5 {
			set segment(returnkeystate) R_CTLSAVE
			ResetGetSyllabTrofs SAVE_CONTROL_DATA_SETUP 			 ;#	Allow control data to be saved
		} 
		6 {
			set segment(savetype) sound
			set segment(returnkeystate) R_SAVESOUND
			ResetGetSyllabTrofs SAVE_SOUND_SETUP		 			 ;#	Allow processed sound output to be saved
		} 
		7 {
			if {$segment(phrase)} {
				set segment(savetype) phrasexport
			} else {
				set segment(savetype) export
			}
			set segment(returnkeystate) R_EXPORT
			ResetGetSyllabTrofs EXPORT_SETUP		 				;#	Allow segments amd mixfile to be named and saved
		} 
		8 {																		
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs ABANDON_EXPORT_SETUP				;#	Forget export
		}
	}
}

#--- Reset access to Processes on Interface

proc ResetProcessBlock {val} {
	global segment evv
	if {$val != 1} {
		set segment(haction) 0			
	}
	.gettrofs.10.fixd config -text "" -command {} -state disabled -disabledforeground []
	.gettrofs.10.tvar config -text "" -command {} -state disabled -disabledforeground []
	GettrofRetimeOff
	GettrofWarpOff
	GettrofTailsOff
	GettrofHeadsOff
	GettrofSegmentsOff
	HideOutputActions

	switch -- $val {
		ONLY_HEADS_OR_ONLY_TAILS_OR_ONLY_SEGS {
			switch -- $segment(proctyp) {
				HEAD {
					GettrofHeadsOn
					HideParamUseStyle
				}
				TAIL {
					GettrofTailsOn
					HideParamUseStyle
				}
				WHOLE {
					GettrofSegmentsOn 0
				}
			}
			set segment(returnkeystate) R_INACTIVE
		}
		BOTH {
			GettrofHeadsOn
			GettrofTailsOn
			GettrofSegmentsOn 0
		}
		TIMESTRETCH_ONLY {
			.gettrofs.9.w.tit config -text "TIMEWARP PROCESSES" -fg $evv(SPECIAL)
			.gettrofs.9.w.tst config -text "SPECTRAL STRETCH" -command "set pr_gettrofs TIMESTRETCH" -state normal -bd 2
			.gettrofs.9.w.itr config -text "ITERATE STRETCH"  -command "set pr_gettrofs ITERATE"	 -state normal -bd 2
			.gettrofs.9.w.ziz config -text "ZIGZAG STRETCH"	  -command "set pr_gettrofs ZIGZAG"		 -state normal -bd 2
			.gettrofs.9.w.rvl config -text "TIME REVERSALS"   -command "set pr_gettrofs REVERSAL"	 -state normal -bd 2
			HideParamUseStyle
			set segment(returnkeystate) R_INACTIVE
		}
		TIMESTRETCH {
			.gettrofs.9.w.tit config -text "TIMEWARP PROCESSES"
			.gettrofs.9.w.tst config -text "SPECTRAL STRETCH" -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack"	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		ITERATE {
			.gettrofs.9.w.tit config -text "TIMEWARP PROCESSES"
			.gettrofs.9.w.itr config -text "ITERATE STRETCH"  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		ZIGZAG		{
			.gettrofs.9.w.tit config -text "TIMEWARP PROCESSES"
			.gettrofs.9.w.ziz config -text "ZIGZAG STRETCH"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		REVERSAL	{
			.gettrofs.9.w.tit config -text "TIMEWARP PROCESSES"
			.gettrofs.9.w.rvl config -text "TIME REVERSAL"    -bd 2 -disabledforeground $evv(SPECIAL)
			.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
		}
		SHRHYTHM	{
			.gettrofs.9.r.tit config -text "RETIMING PROCESSES"
			.gettrofs.9.r.srs config -text "SHRINK RHYTHMS"   -bd 2 -disabledforeground $evv(SPECIAL)
			.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
		}
		SUPPRESS {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.gra config -text "SUPPRESS"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		RETIME {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			switch -- $segment(retimestyle) {
				OVERLAP {
					.gettrofs.9.r.ovr config -text "OVERLAP & SPACE"  -bd 2 -disabledforeground $evv(SPECIAL)				
				}
				CUT {
					.gettrofs.9.r.csp config -text "CUT & SPACE"	  -bd 2 -disabledforeground $evv(SPECIAL)
				}
				SHRINK {
					.gettrofs.9.r.shp config -text "SHRINK & SPACE"	  -bd 2 -disabledforeground $evv(SPECIAL)
				}
				STRETCH {
					.gettrofs.9.r.shr config -text "SHRINK & STRETCH" -bd 2 -disabledforeground $evv(SPECIAL)
				}
			}
		}
		PLUCKED {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.plu config -text "PLUCKED"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		DISTREP {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.drp config -text "WAVESET REPEAT"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		DELRING {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.dng config -text "DELAY RING"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		VIBRATO {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.vib config -text "VIBRATO"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TREMOLO {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.trm config -text "TREMOLO"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		REVERB {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.rev config -text "REVERB"			  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		LOOP {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.lop config -text "LOOP"			  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		SCAN {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.scn config -text "SCAN"			  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		ZIGACCEL {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.zac config -text "ZIGACCEL"		 -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		FORMOVE {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.fom config -text "MOVE FORMANTS"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TUNED {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.tun config -text "TUNED"			-bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		PITCH {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.pch config -text "PITCH LINE"		-bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		VOCODE		{
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.spc config -text "VOCODE"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		EDOCOV {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.for config -text "BE VOCODED"  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TRANSFER {
			.gettrofs.9.t.tit config -text "TAIL PROCESSES"
			.gettrofs.9.t.trf config -text "TRANSFER"  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TEXTURE {
			.gettrofs.9.h.tit config -text "HEAD PROCESSES"
			.gettrofs.9.h.txt config -text "TEXTURE"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		BOUNCE {
			.gettrofs.9.h.tit config -text "HEAD PROCESSES"
			.gettrofs.9.h.bbb config -text "BOUNCE"			  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		ACCENT {
			.gettrofs.9.h.tit config -text "HEAD PROCESSES"
			.gettrofs.9.h.stk config -text "ACCENT"			  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TWANG {
			.gettrofs.9.h.tit config -text "HEAD PROCESSES"
			.gettrofs.9.h.crm config -text "TWANG"		  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 	  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		VERGES {
			.gettrofs.9.h.tit config -text "HEAD PROCESSES"
			.gettrofs.9.h.ver config -text "VERGES"			  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		HPITCH {
			.gettrofs.9.h.tit config -text "HEAD PROCESSES"
			.gettrofs.9.h.hep config -text "PITCH"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		PINCH {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.pii config -text "PINCH"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		SQUASH {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.sqq config -text "SQUASH"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		LIQUID {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.lqq config -text "LIQUIDISE"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		SQUEEZE {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.hss config -text "SQUEEZE"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		DEEPEN {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.dpp config -text "DEEPEN"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		DEEPREV {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.dpr config -text "LOW RESONANCE"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TUBEREV {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.tbr config -text "TUBE RESONANCE"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		ROUGHEN {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.rgg config -text "ROUGHEN"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		RANDSTEP {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.rss config -text "RANDSTEP IN"	  -bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		SPIKE {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.spk config -text "SPIKE"			-bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		SQZBOX {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.sqb config -text "SQUEEZEBOX"		-bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		TSTRETCH {
			.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
			.gettrofs.9.s.str config -text "TIME STRETCH"		-bd 2 -disabledforeground $evv(SPECIAL)
			if {!$segment(multiproccnt)} {
				.gettrofs.7.bak config -text "Backtrack" 		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
			}
		}
		MANY_PROCESSES {
			.gettrofs.9.h.tit config -text "MANY PROCESSES"
			.gettrofs.9.t.tit config -text "MANY PROCESSES"
		}
	}
}

#-- Reset interface to enter appropriate kind of control data

proc GotoControlDataEntry {} {
	global segment go
 
	set go 0
	switch -- $segment(shape) {
		"ASIS" {
			.gettrofs.11.asis  config -text "Change as is" -command {} -state disabled -disabledforeground [option get . foreground {}]
			.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
			set go 1
		}
		"FLAT" {
			.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.flat  config -text "Keep start val" -command {} -state disabled -disabledforeground [option get . foreground {}]
			.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
			set go 1
		}
		"LIN"  {
			.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.lin   config -text "Move to end val" -command {} -state disabled -disabledforeground [option get . foreground {}]
			.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
			set go 1
		}
		"TF"   {
			.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.tf    config -text "To & from mid val" -command {} -state disabled -disabledforeground [option get . foreground {}]
			set go 1
		}
		0 {
			.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
			.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
		}
	}

	switch -- $segment(haction) {

		1 {
			switch -- $segment(process) {
				"TIMESTRETCH" {
					if {$go} {
						set segment(returnkeystate) R_APPLY_FIXED_VAL
					} else {
						set segment(returnkeystate) R_INACTIVE
					}
					set segment(vp) 1
				}
				default {				 
					set segment(returnkeystate) R_APPLY_FIXED_VAL
				}
			}
			ResetGetSyllabTrofs SHOW_FIXEDVAL_ENTRY
		}
		2 {
			switch -- $segment(process) {
				"TIMESTRETCH" -
				"ITERATE" -
				"ZIGZAG" {
					if {![MakeControlfile]} {
						.gettrofs.3.n   config -text "" -command {} -state disabled -bd 0
						.gettrofs.3.s   config -text "" -command {} -state disabled -bd 0
						set segment(returnkeystate) R_INACTIVE
						ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
						return
					}
					set segment(returnkeystate) R_SAVE_CONTROL_DATA
 					ResetGetSyllabTrofs MADE_CONTROL_DATA_GOTO_SAVE_DECISION
				}
				"ACCENT" -
				"TWANG" -
				"BOUNCE" -
				"TEXTURE" -
				"TUNED" -
				"DISTREP" -
				"DELRING" -
				"VIBRATO" -
				"TREMOLO" -
				"REVERB" -
				"LOOP" -
				"SCAN" -
				"VERGES" -
				"FORMOVE" -
				"VOCODE" -
				"EDOCOV" -
				"ZIGACCEL" -
				"HPITCH" -
				"PINCH"   -
				"SQUASH"  -
				"LIQUID"  -
				"SQUEEZE" -
				"DEEPEN"  -
				"DEEPREV"  -
				"TUBEREV"  -
				"SPIKE"  -
				"SQZBOX"  -
				"TSTRETCH" -
				"ROUGHEN" -
				"RANDSTEP" -
				"PLUCKED" {
					if {![MakeControlfile]} {
						.gettrofs.3.n   config -text "" -command {} -state disabled -bd 0
						.gettrofs.3.s   config -text "" -command {} -state disabled -bd 0
						set segment(returnkeystate) R_INACTIVE
						ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
						return
					}
					if {$segment(vp) < $segment(vparams_cnt,$segment(process)) } {
						incr segment(vp)
						set segment(returnkeystate) R_INACTIVE
 						ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
					} else { 
						unset segment(vp)
						set segment(returnkeystate) R_RUN
						ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					}
				}
				"TRANSFER" -
				"RETIME" -
				"REVERSAL" -
				"SHRHYTHM" -
				"ARTICULATION" -
				"SUPPRESS" {
					catch {unset segment(vp)}
					set segment(returnkeystate) R_RUN
					ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
				}
				default {
# --> TO DELETE, once code in place
					Inf "NOT WRITTEN THIS PROCESS YET (1)"
					if {$segment(cload)} {
						ResetProcessBlock TIMESTRETCH_ONLY
					} else {
						ResetProcessBlock ONLY_HEADS_OR_ONLY_TAILS_OR_ONLY_SEGS
					}
					return
# <-- TO DELETE, once code in place
				}
			}
		}
	}
}

#####################################################################
# SEGMENTING DATA, DISPLAYING AND DRAWING DATA CURVES IN SOUND VIEW #
#####################################################################

#------ Locate trofs (&/or peaks) in Analysis file

proc DoSegmentation {fnam} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun wstk

	set basfnam [file rootname [file tail $fnam]]
	switch -- $segment(type) {
		1 {
			set msg2 "TROUGHS"
		}
		2 {
			set msg2 "PEAKS"
		}
		3 {
			set msg2 "TROUGHS & PEAKS"
		}
		0 {
			Inf "SEGMENTATION TYPE NOT SET"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) specfnu]
	lappend cmd specfnu 22 $fnam $segment(troflist)
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	Block "PLEASE WAIT:        LOCATING $msg2 IN FILE $basfnam"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO FIND $msg2"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE $msg2 TEXTFILE"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $segment(troflist)]} {
		Inf "NO OUTFILE WITH $msg2 CREATED"
		UnBlock
		return 0
	}
	UnBlock
	return 1
}

#--- Display the segmentation data

proc DisplaySegmentation {} {
	global segment evv
	set segment(displaysegs) 1
	SnackDisplay $evv(SN_TIMESLIST) troflist $segment(src,0) 0
	unset segment(displaysegs)
}

#---- Draw Controlfile in Sound View

proc MakeControlfile {} {
	global segment src evv
	catch {file delete $segment(prectrlfil)} 
	SnackDisplay $evv(SN_BRKPNTPAIRS) troflist $segment(src,0) 0

	if {![file exists $segment(prectrlfil)]} {
		Inf "NO CONTROL DATA GENERATED"
		return 0
	}
	if {![DoControlWarp 1]} {
		return 0
	}
	return 1
}

#--- Refine the segmentation data

proc EditSegmentation {} {
	global segment evv

	SnackDisplay $evv(SN_TIMESLIST) troflist $segment(src,0) 0
	if {![file exists $segment(nutroflist)]} {
		return 0
	} 
	return 1
}

#--- Check the refined segmentation data, before saving it

proc PostRefinementEdit {} {
	global segment evv wstk

	if [catch {open $segment(nutroflist) "r"} zit] {
		Inf "CANNOT OPEN THE REFINED SEGMENTATION FILE"
		return 0
	}

	;#	READ EXISTING REFINED DATA

	catch {unset segment(marklist)}
	while {[gets $zit line] >= 0} {
		lappend segment(marklist) $line
	}
	close $zit

	if {$segment(phrase)} {
		if {[lindex $segment(marklist) end] < $segment(dur)} {
			lappend segment(marklist) [expr $segment(dur) + 10]
		}
		set changed 1
	} else {
		set changed 0
	}

	;#	DEAL WITH SINGLE-TIMEMARK DATA

	if {[llength $segment(marklist)] < 2} {
		if {[lindex $segment(marklist) 0] <= $segment(frametime)} {
			if {$segment(phrase)} {
				Inf "SINGLE MARKER AT TIME ZERO: NO PHRASES"
			} else {
				Inf "SINGLE MARKER AT TIME ZERO: NO HEAD"
			}
			return 0
		} elseif {[lindex $segment(marklist) 0] >= [expr $segment(dur) - $segment(frametime)]} {
			if {$segment(phrase)} {
				Inf "SINGLE MARKER AT END OF FILE: NO PHRASES"
			} else {
				Inf "SINGLE MARKER AT END OF FILE: NO TAIL"
			}
			return 0
		}
		Inf "LESS THAN TWO MARKED POINTS: ASSUMING HEAD AT START"
		set segment(marklist) [linsert $segment(marklist) 0 0.0]									;#	Force segment at start of file to marked point
		set segment(marklist) [linsert $segment(marklist) end [expr $segment(dur) + 10.0]]			;#	Force segment from marked point to beyond end of file
		set changed 1
	}

	;#	DEAL WITH FIRST TIME-MARK EXCEPTIONS

	if {[lindex $segment(marklist) 0] > 0.0} {								;#	If 1st marked seg does not begin at zero
		if {$segment(headfirst) || $segment(phrase)} {						;#	if it's a HEAD, or a PHRASE
			if {[lindex $segment(marklist) 0]  <= $segment(TWOSPLICE)} {	;#	if it's very close to start
				set segment(marklist) [lreplace $segment(marklist) 0 0 0.0]	;#	Move segstart to time 0.0
				if {$segment(phrase)} {
					set msg "FIRST PHRASE CLOSE TO, BUT NOT AT ZERO.\n"
					append msg "MOVING START OF FIRST \"PHRASE\" TO TIME ZERO"
				} else {
					set msg "FIRST SEGMENT (A \"HEAD\") CLOSE TO, BUT NOT AT ZERO.\n"
					append msg "MOVING START OF FIRST \"HEAD\" TO TIME ZERO"
				}
				Inf $msg
				set changed 1
			} elseif {!$segment(phrase)} {										;#	but if not very close, mark seg from 0 to HEAD as a tail					
				set msg "FIRST SEGMENT (A \"HEAD\") NOT NEAR ZERO.\n"
				append msg "IS THE MATERIAL BEFORE THIS HEAD TO BE PROCESSABLE ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					set segment(marklist) [lreplace $segment(marklist) 0 0 0.0]	;#	Force HEAD to start at time zero
					set changed 1											
				} else {
					set segment(marklist) [linsert $segment(marklist) 0 0.0]	;#	Insert TAIL segment at time 0.0
					set segment(headfirst) 0
					set changed 1											
				}
			}
		} else {															;#	Otherwise, it's a TAIL start
			if {[lindex $segment(marklist) 0]  > 0.0} {						;#	If it's not marked as starting at zero, move 1st mark to zero 
				set segment(marklist) [lreplace $segment(marklist) 0 0 0.0]	;#	Move segstart to time 0.0
				set changed 1
			}
			if {[lindex $segment(marklist) 1] <= $segment(TWOSPLICE)} {
				set msg "FIRST SEGMENT (A \"TAIL\") TOO SHORT TO ALLOW TRANSITION TO HEAD.\n"	;#		T h t h t h t h
				append msg "INCORPORATING IT IN INITIAL \"HEAD\""								;#	Delete initial tail
				Inf $msg
				set segment(marklist) [lreplace $segment(marklist) 1 1]							;#	-->	H   t h t h t h
				set segment(headfirst) 1
				set changed 1
			}
		}
	}
	set len [llength $segment(marklist)]
	if {[IsEven $len]} {		;#	If len = 4 marks | | | |
		set segment(even) 0		;#	segcnt is odd     - - -
	} else {					;#	If len = 5 marks | | | | |
		set segment(even) 1		;#	segcnt is even    - - - -
	}

	;#	DEAL WITH END TIME-MARK EXCEPTIONS

	set endmark [lindex $segment(marklist) end]
	set endgap [expr $segment(dur) - $endmark] 

	if {$endgap >= 0} {
		if {$segment(phrase) || (($segment(even) && $segment(headfirst)) || (!$segment(even) && !$segment(headfirst)))} {	;#	Last seg is a TAIL, or a PHRASE
			set penultmark [lindex $segment(marklist) [expr $len - 2]]
			set lasttaillen [expr $segment(dur) - $penultmark]
			if {$lasttaillen < $segment(TWOSPLICE)} {						;#	If it's too short, remove it
				set segment(marklist) [lreplace $segment(marklist) end end]
				incr len -1
				set changed 1
			}																;#	Force a final seg to end beyond file-end
			set segment(marklist) [lreplace $segment(marklist) end end [expr $segment(dur) + 10.0]]
			set changed 1								
		} else {															;#	Last seg is a HEAD
			if {$endgap < $segment(TWOSPLICE)} {
				set segment(marklist) [lreplace $segment(marklist) end end [expr $segment(dur) + 10.0]]
				set changed 1												;#	If very close to, or at, file-end, force it to beyond file-end
			} else {														;#	But if not close to end, insert tail after it
				set msg "FINAL SEGMENT (A \"HEAD\") NOT CLOSE TO END OF SOUND.\n"
				append msg "IS THE MATERIAL AFTER THIS HEAD TO BE TIME-STRETCHABLE ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					catch {unset segment(marklist)}
					return 0
				} 
				lappend segment(marklist) [expr $segment(dur) + 10.0]		;#	Insert TAIL segment at end of sound
				incr len
				set changed 1
			}
		}
	}	

	;#	DEAL WITH INTERNAL "TAIL" SEGMENTS WHICH ARE TOO SHORT

	if {$segment(headfirst) || $segment(phrase)} {
		set n 1			;#	Start checking TAIL or PHRASE durs at Time 1	0 1 2 3 4 5 6 7
	} else {			;#													h T h t h t h t
		set n 2			;#	Start checking rest of tails from time 2		t h T h t h t h
	}
	set penult [expr $len - 1]
	set m $n
	incr m
	while {$m < $penult} {
		set tstt [lindex $segment(marklist) $n]	
		set tend [lindex $segment(marklist) $m]
		set taillen	[expr $tend - $tstt]
		if {$taillen <= $segment(TWOSPLICE)} {
			if {$segment(phrase)} {
				Inf "\"PHRASE\" SEGMENT AT TIME $tstt TOO SHORT FOR SPLICING"
				incr penult -1
			} else {
				Inf "\"TAIL\" SEGMENT AT TIME $tstt TOO SHORT ($taillen secs)TO ALLOW TRANSITION TO AND FROM HEADS (min $segment(TWOSPLICE))"
				incr penult -2
			}
			set	segment(marklist) [lreplace $segment(marklist) $n $m]
			set changed 1
		} else {		
			if {$segment(phrase)} {
				incr n
				incr m
			} else {
				incr n 2
				incr m 2
			}
		}
	}

	;#	IF DATA HAS BEEN ALTERED, SAVE IT TO FILE

	if {$changed} {
		if [catch {open $segment(nutroflist) "w"} zit] {
			if {$segment(phrase)} {
				Inf "CANNOT OPEN PHRASE-SEGMENTATION FILE, TO MODIFY DATA"
			} else {
				Inf "CANNOT OPEN REFINED-SEGMENTATION FILE, TO MODIFY DATA"
			}
		}
		foreach mark $segment(marklist) {
			puts $zit $mark
		}
		close $zit
	}
	return 1
}

########
# HELP #
########

proc VboxHelp {} {
	global pr_vboxhelp evv
	set f .vboxhelp
	if [Dlg_Create $f "VOICEBOX HELP" "set pr_vboxhelp 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.o -text "Overview"		 -command "VboxOverview"  -width 16
		button $f.0.p -text "Processes"		 -command "VboxProcesses" -width 16
		button $f.0.s -text "Process List"	 -command "VboxSpecific"  -width 16
		button $f.0.t -text "Timewarp"		 -command "VboxTimewarp"  -width 16
		button $f.0.c -text "Combinations"	 -command "VboxCombo"	  -width 16
		button $f.0.r -text "Retime Options" -command "VboxRetime" 	  -width 16
		button $f.0.v -text "Vocode & Other" -command "VboxVocode"	  -width 16
		button $f.0.dum -text ""			 -command {} -width 8 -bd 0 -state disabled
		button $f.0.q -text "Quit"			 -command "set pr_vboxhelp 0" -width 8
		pack $f.0.o $f.0.p $f.0.s $f.0.t $f.0.c $f.0.r $f.0.v $f.0.dum -side left -padx 2 
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true -pady 4
		wm resizable $f 0 0
		bind $f <Escape> {set pr_vboxhelp 0}
	}
	set pr_vboxhelp 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_vboxhelp
	tkwait variable pr_vboxhelp
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc VboxOverview {} {
	global wstk pr_vboxhelp
	set msg "VOICEBOX : AN OVERVIEW.\n"
	append msg "\n"
	append msg "This module allows you to process sounds with sonically distinct segments\n"
	append msg "e.g. the syllables or phonemes of speech, in a way which preserves or respects that segmentation.\n"
	append msg "\n"
	append msg "The input to this module is (at least) 1 Analysis File, or 1 Mono Soundfile.\n"
	append msg "The corresponding Soundfile/Analysis File MUST ALSO EXIST,\n"
	append msg "and must have the SAME NAME (apart from the filename extension).\n"
	append msg "\n"
	append msg "The source is to be divided into segments, by timemarks, and these segments processed independently.\n"
	append msg "\n"
	append msg "Timemarks are added by mouse-clicking over a display of the source (which can be magnified for greater accuracy).\n"
	append msg "\n"
	append msg "Usually the segmentation is as alternate \"Head\" and \"Tail\" segments\n"
	append msg "(e.g. consonants-onsets & vowel-continuations) which alternate throughout the source.\n"
	append msg "In this case \"Do Initial Segmentation\" detects the Troughs between syllables (or etc)\n"
	append msg "(or the syllable-peaks, or both)  in the source.\n"
	append msg "\n"
	append msg "Care must be taken when dealing with \"silent\" portions of the source (assign to Head or Tail?).\n"
	append msg "\n"
	append msg "You can Load existing data about this inital segmentation with \"Load Existing Seg Data\".\n"
	append msg "\n"
	append msg "The \"Edit Segmentation\" button will then appear and allow you to refine this data by graphical editing.\n"
	append msg "\n"
	append msg "You can also Load already-Refined data, with \"Load Refined Data\" or further refine such data with \"Further Refine\".\n"
	append msg "\n"
	append msg "Alternatively you can simply divide the source into equivalent segments (e.g. words or phrases)\n"
	append msg "called \"phrase data\" with \"Do Phrase Segmentation\".\n"
	append msg "You can LOAD existing phrase data with \"Load Phrase Data\" or ammend it with \"Refine Phrase Data\".\n"
	append msg "\n"
	append msg "Once a segmentation has been established, you can.\n"
	append msg "\n"
	append msg "(1) Display the sound, together with its segmentation, from the \"See Segmentation\" button.\n"
	append msg "           (there is always a time-mark at the end of the data, but this will not be visible on the display).\n"
	append msg "    NB The F4 key will lock the PlayBox to the segment divisions.\n"
	append msg "\n"
	append msg "(2) Assign (or revise) short identifying syllables to the segmented items, from the \"Segmentation Text\" button.\n"
	append msg "           Once a Segmentation-Text has been assigned it will ALSO be displayed in \"See Segmentation\".\n"
	append msg "\n"
	append msg "You can also CONVERT Loaded Refined Data to Phrase Data (& save it, and an abridged version of any associated Text).\n"
	append msg "\n"
	append msg "\n"
	append msg "THIS SEGMENTATION INFORMATION IS THEN USED DURING THE SUBSEQUENT PROCESSING OF THE SOURCE.\n"
	append msg "\n"
	append msg "\n"
	append msg "EXPORT\n"
	append msg "\n"
	append msg "Either BEFORE or AFTER you have processed the segmented sound, you can export the individual segments of the source\n"
	append msg "as separate soundfiles, using a a generic filename.\n"
	append msg "The mixfile, enabling you to recombine these segments into the whole sound, is also exported.\n"
	append msg "\n"
	append msg "This may be useful if you want to apply processes to the segments that are not available directly in the Voicebox.\n"
	append msg "\n"
	append msg "You can also EXPORT A SINGLE PROCESSED SEGMENT : Tick \"Single Segment\" Box at foot of display (AFTER processing).\n"
	append msg "\n"
	append msg "(MORE INFORMATION - PROCESSES : TIMEWARPING : COMBINATIONS : RETIME OPTIONS : ARTICULATION & VOCODE OPTIONS ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		VboxProcesses
	} else {
		set pr_vboxhelp 0
	}
}

proc VboxProcesses {} {
	global wstk pr_vboxhelp
	set msg "VOICEBOX : PROCESSES.\n"
	append msg "\n"
	append msg "Once the segmentation data for the sound has been establised you can proceed to process the sound.\n"
	append msg "\n"
	append msg "There are 5 types of processes.\n"
	append msg "\n"
	append msg "(1) Time Warping Processes.\n"
	append msg "(2) Tail Processes -  Processes affect only the TAIL segments.\n"
	append msg "(3) Head Processes -  Processes affect only the HEAD segments.\n"
	append msg "(4) Segment Processes - Processes affect ALL the segments.\n"
	append msg "(5) Retiming Processes.\n"
	append msg "\n"
	append msg "Time Warping Processes must always be done FIRST.\n"
	append msg "\n"
	append msg "These extend the source in time. If the source is segmented into HEADs and TAILs,\n"
	append msg "the time-extension will NOT AFFECT THE HEADS e.g. the consonantal attacks of speech will be preserved.\n"
	append msg "\n"
	append msg "Retiming Processes must always be done LAST.\n"
	append msg "These rearrange the processed segments output by previous processes (or the unprocessed original segments).\n"
	append msg "\n"
	append msg "After applying a (single) TAIL process, you may then apply another process to all the HEADs, and vice versa.\n"
	append msg "\n"
	append msg "You can also select \"A COMBINATION\", applying different processes to different segments.\n"
	append msg "Time-variable parameters pick values from your control-curve at the times relevant to the individual segments.\n"
	append msg "\n"
	append msg "If you are using \"Phrase Segmentation\", \"A Combination\" & \"Remotif\" are the only options.\n"
	append msg "\n"
	append msg "With both Head-Tail and Phrase segmentation you can \"REORDER\" the segments (reposition, duplicate, randomise)\n"
	append msg "to produce a new sound.\n"
	append msg "\n"
	append msg "PARAMETER ENTRY FOR THE PROCESSES\n"
	append msg "\n"
	append msg "(1)  PRESETS\n"
	append msg "\n"
	append msg "Some parameter need to be preset before any other parameters are entered (e.g. the number of channels in a TEXTURE).\n"
	append msg "For these, a presets window will appear where boxes can be ticked or button-options selected.\n"
	append msg "(A black and while KEYBOARD ICON allows you to enter data from a MIDI Keyboard.\n"
	append msg "A large TIME TAP style button allows timing data to be tapped in with the mouse).\n"
	append msg "\n"
	append msg "Some of these preset parameters may then appear among the parameter entry-boxes (see below)\n"
	append msg "but will not be alterable.\n"
	append msg "\n"
	append msg "(2)  FIXED VALUE PARAMETERS\n"
	append msg "\n"
	append msg "Some parameters can only take a fixed value.\n"
	append msg "Parameter entry boxes (with names attached) for ALL of these are displayed in a single array.\n"
	append msg "A \"Help\" button provides information about parameter ranges.\n"
	append msg "\n"
	append msg "Default values for fixed-value-entry can be obtained by pressing the \"Default\" button.\n"
	append msg "\n"
	append msg "(3)  PARAMETERS WHICH MAY VARY IN TIME\n"
	append msg "\n"
	append msg "Other parameters can take a fixed value OR a time-varying value.\n"
	append msg "These parameters are offered one at a time, with a choice of entering a \"Fixed\" value in a box\n"
	append msg "or drawing a time-changing \"Variable\" parameter value over a waveform display of the sound.\n"
	append msg "\n"
	append msg "Default values for fixed-value-entry can be obtained by pressing the \"Default\" button.\n"
	append msg "\n"
	append msg "SAVING AND LOADING PARAMETER PATCHES\n"
	append msg "\n"
	append msg "The \"VBOX\" remembers the Fixed parameters (for each process) from one run to the next\n"
	append msg "and, if you re-run any process, the remembered values will be displayed (but you can change them).\n"
	append msg "\n"
	append msg "You can also save the (complete set of) Parameters, from a process you have run, as a (named) \"Patch\"\n"
	append msg "using the \"Save Parameters\" button appearing at the foot of the window once the process has run.\n"
	append msg "\n"
	append msg "Such Patches can also be loaded, from the \"Load Patch\" buttons that are displayed\n"
	append msg "when you reach the stage of entering parameters for a process.\n"
	append msg "\n"
	append msg "(MORE INFORMATION - SPECIFIC PROCESSES : TIMEWARPING : COMBINATIONS : RETIME OPTIONS : ARTICULATION & VOCODE OPTIONS ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		VboxSpecific
	} else {
		set pr_vboxhelp 0
	}
}	

proc VboxSpecific {} {
	global wstk pr_vboxhelp
	set msg "HEAD AND TAIL PROCESSES IN THE VOICEBOX\n"
	append msg "\n"
	append msg "TAIL PROCESSES\n"
	append msg "\n"
	append msg "SUPPRESS:      Replace tail by Silence.\n"
	append msg "PLUCKED:        Tails converted to sequence of sharp-attacked grains.\n"
	append msg "TUNED:            Tails played as specified harmony(s).\n"
	append msg "PITCH LINE:     Tails tuned to specified pitches.\n"
	append msg "WAVESET REPEAT:Tails divided into wavesets which are then repeated.\n"
	append msg "                         The output may (or may not) be telescoped into the original duration.\n"
	append msg "DELAY RING:    Tails generate ringing tones at specified pitches.\n"
	append msg "VIBRATO:         (pitch) Vibrato added to Tails.\n"
	append msg "TREMOLO:        (loudness) Tremolo added to Tails.\n"
	append msg "REVERB:            Reverberation added to Tails.\n"
	append msg "LOOP:               Tails looped in various ways.\n"
	append msg "SCAN:               Tails extended by zigzagged reading:\n"
	append msg "                                   resulting sounds overlap one another in output.\n"
	append msg "ZIG ACCEL:        Tails extended by zigzagged reading, possibly gradually contracting ziglen.\n"
	append msg "                                   resulting sounds do NOT overlap one another in output.\n"
	append msg "                                   Not available among multiprocessing options but, if used, \n"
	append msg "                                   the output (and new segmentation) can be saved & recycled for further processing.\n"
	append msg "MOVE FORMANTS: Tail Formants are transposed and their formats also move.\n"
	append msg "VOCODE:          Tails are Vocoded by one, or many, (extra) input sound(s).\n"
	append msg "BE VOCODED:    One or many input sound(s) are Vocoded by the first input sound's Tails.\n"
	append msg "TRANSFER:       Transfer characteristics (Pitch, Loudness, Duration, Formants etc)\n"
	append msg "                          of 2nd input sound to 1st input.\n"
	append msg "\n"
	append msg "HEAD PROCESSES\n"
	append msg "\n"
	append msg "TEXTURE:  Create a (stereo) texture from the Head, extending (and possibly overlapping) the Tail.\n"
	append msg "BOUNCE:   Create repetitions of the Head, accelerating and diminuendoing,\n"
	append msg "                  either over or before the ensuing Tail.\n"
	append msg "ACCENT:   Accent the specified Heads.\n"
	append msg "TWANG:    Produced \"Twanged\" attack on Head.\n"
	append msg "VERGES:    Pitch-slide into Head.\n"
	append msg "PITCH:    Head is pitched by delay-repetition, and time-extended.\n"
	append msg "\n"
	append msg "A COMBINATION: A combination of (some of) the Head or Tail processes.\n"
	append msg "\n"
	append msg "SEGMENT PROCESSES\n"
	append msg "\n"
	append msg "REORDER:  Change the order of the segments (and any associated text mnemonics).\n"
	append msg "                   Segments may also be repeated or omitted.\n"
	append msg "\n"
	append msg "PINCH, SQUASH, LIQUIDISE, HIGH SQUEEZE, DEEPEN, LOW RESONANCE, ROUGHEN and RANDSTEP IN all alter the quality of the source.\n"
	append msg "(See \"Help\" at Parameter entry)\n"
	append msg "\n"
	append msg "These cannot be used with the \"TEXTURE\" process.\n"
	append msg "\n"
	append msg "(MORE INFORMATION - TIMEWARPING : COMBINATIONS : RETIME OPTIONS : ARTICULATION & VOCODE OPTIONS ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		VboxTimewarp
	} else {
		set pr_vboxhelp 0
	}
}	

proc VboxTimewarp {} {
	global wstk pr_vboxhelp
	set msg "VOICEBOX : TIMEWARPING\n"
	append msg "\n"
	append msg "SPECTRAL TIMESTRETCH, ITERATION & ZIGZAG can be used to lengthen ONLY THE TAILS of the sound.\n"
	append msg "\n"
	append msg "In this case Voicebox uses the segmentation information to time-expand the sound TAILs\n"
	append msg " without timestretching the HEADS (so that e.g. the consonant attacks of syllables can be preserved).\n"
	append msg "\n"
	append msg "Once a sound has been timestretched thus, it can be recycled back into the Voicebox for further processing.\n"
	append msg "You can also recycle the (now timestretched) segmentation information.\n"
	append msg "This will appear in the list of available segmentations as \"recycle_seg\" and may be further refined.\n"
	append msg "\n"
	append msg "\"TIMESTRETCH\" :     uses spectral time extension.\n"
	append msg "\n"
	append msg "If time-variable parameters are used, the time-stretching will be truly time-varying.\n"
	append msg "\n"
	append msg "The recycled segmentation information is not very accurate and will need to be refined.\n"
	append msg "\n"
	append msg "\"ITERATION\" :     is computing-intensive and may take some time.\n"
	append msg "\n"
	append msg "If time-variable parameters are used, the time-stretching of each segment will be a constant value\n"
	append msg "but the value for a particular segment is read from the time-varying data at the segment's timing in the source.\n"
	append msg "\n"
	append msg "The recycled segmentation information is not completely accurate and will need to be refined.\n"
	append msg "\n"
	append msg "\"ZIGZAG\" :     introduces randomised variations in the timestretched sound.\n"
	append msg "\n"
	append msg "If time-variable parameters are used, the time-stretching of each segment will be a constant value\n"
	append msg "but the value for a particular segment is read from the time-varying data at the segment's timing in the source.\n"
	append msg "The recycled segmentation information is accurate.\n"
	append msg "\n"
	append msg "                           ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\n"
	append msg "\n"
	append msg "\"TIME REVERSALS\" :     Selected groupings of Heads and Tails are time-reversed.\n"
	append msg "\n"
	append msg "The outputs, from various grouping types, may be mixed, post-Vbox,  e.g. in mono or multichannel format.\n"
	append msg "The recycled segmentation information is accurate.\n"
	append msg "\n"
	append msg "\n"
	append msg "(ALSO SEE \"RETIME OPTIONS\")\n"
	append msg "\n"
	append msg "(MORE INFORMATION - COMBINATIONS : RETIME OPTIONS : ARTICULATION & VOCODE OPTIONS ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		VboxCombo
	} else {
		set pr_vboxhelp 0
	}
}

proc VboxCombo {} {
	global wstk segment pr_vboxhelp
	set msg "VOICEBOX : COMBINING PROCESSES\n"
	append msg "\n"
	append msg "With Head/Tail segmentation, if you choose to process all the TAILS, when processing is complete\n"
	append msg "you will be offered the option to then process all the HEADS, and vice versa.\n"
	append msg "\n"
	append msg "Some HEAD processes will modify (e.g. fade up or down) the Tail segments,\n"
	append msg "and some TAIL processes may be set to modify the HEADs (e.g.\"TUNED\").\n"
	append msg "\n"
	append msg "\n"
	append msg "You may also select \"A COMBINATION\" of processes, applying different processes to different segments.\n"
	append msg "\n"
	append msg "(Phrase segmentations are always treated in this way, apart from the \"Remotif\" option).\n"
	append msg "\n"
	append msg "You do not need to process every segment (if a process is not specified for a segment, no processing takes place).\n"
	append msg "\n"
	append msg "If you use time-varying parameters, when you process a particular segment, its time in the source sound\n"
	append msg "will be used to select the value of the parameter from the time-varing control-data.\n"
	append msg "\n"
	append msg "\n"
	append msg " \"TWANG\", using the \"Untwang\" setting, is NOT compatible with the \"RETIME\" options. \n"
	append msg "\n"
	append msg "(MORE INFORMATION - RETIME OPTIONS : ARTICULATION & VOCODE OPTIONS ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		VboxRetime
	} else {
		set pr_vboxhelp 0
	}
}

proc VboxRetime {} {
	global pr_vboxhelp wstk
	set msg "VOICEBOX : RETIMING OPTIONS\n"
	append msg "\n"
	append msg "Either before or after the segmented sound has been processed, you may reposition the segments in time.\n"
	append msg "\n"
	append msg "Retiming will not affect the ORDER of the segments (you can change this with \"REORDER\").\n"
	append msg "\n"
	append msg "(1) OVERLAP & SPACE\n"
	append msg "\n"
	append msg "This will move the segments (or, if specified, the HEAD-TAIL pairs) to new start-times.\n"
	append msg "If the time is stretched, silence will appear between the segments (or one Head-Tail pair and the next).\n"
	append msg "If the time is shrunk,the segments (or Head-Tail pairs) will overlay one another.\n"
	append msg "\n"
	append msg "(1) CUT & SPACE\n"
	append msg "\n"
	append msg "This will move the segments (or, if specified, the HEAD-TAIL pairs) to new start-times.\n"
	append msg "If the time is stretched, silence will appear between the segments (or one Head-Tail pair and the next).\n"
	append msg "If the time is shrunk,the segments (or the Tails of Head-Tail pairs) will be cut, to avoid any overlap.\n"
	append msg "\n"
	append msg "(1) SHRINK & SPACE\n"
	append msg "\n"
	append msg "This will move the segments (or, if specified, the HEAD-TAIL pairs) to new start-times.\n"
	append msg "If the time is stretched, silence will appear between the segments (or one Head-Tail pair and the next).\n"
	append msg "If the time is shrunk,the segments (or the Tails of Head-Tail pairs) will be timeshrunk, to avoid any overlap,\n"
	append msg "If a Head-Tail pair is shrunk and the Head portion is not mono it will be collapsed to mono.\n"
	append msg "\n"
	append msg "(1) SHRINK & STRETCH\n"
	append msg "\n"
	append msg "This will move the segments (or, if specified, the HEAD-TAIL pairs) to new start-times.\n"
	append msg "If the time is stretched, the segments (or the Tails of Head-Tail pairs) will be stretched\n"
	append msg "to reach the starttime of the next segment BUT the maximum stretch is by 4 (aiming to retain speech-realism).\n"
	append msg "If the time is shrunk,the segments (or the Tails of Head-Tail pairs) will be timeshrunk, to avoid any overlap.\n"
	append msg "If a Head-Tail pair is shrunk and the Head portion is not mono it will be collapsed to mono.\n"
	append msg "\n"
	append msg "\n"
	append msg "Once the sound has been Retimed, no further processing is possible.\n"
	append msg "\n"
	append msg "~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~  ~\n"
	append msg "\n"
	append msg "\"SHRINK RHYTHMS\" :     All marked items are shrunk in size, and arranged on a predefined rhythmic grid.\n"
	append msg "\n"
	append msg "\"Shrink Rhythms\" remembers the Tempo of its output.\n"
	append msg "\n"
	append msg "The output cannot be recycled here BUT the individual shrunk items and the mixfile which generates the output.\n"
	append msg "can be exported (after sound output is saved) and the mix modified in the \"QikEdit\" option of the MIX page. \n"
	append msg "e.g. Another process can be run, and one or more individual processed segments exported (go to \"Test\" option).\n"
	append msg "These can then be inserted in the mixfile, stretching it, if required, by the appropriate number of beats,\n"
	append msg "with the \"REPLACE/RETIME\" option.\n"
	append msg "\n"
	append msg "Phrases generated with the SAME TEMPO in \"Shrink Rhythms\" can be combined AT TEMPO with \"QikEdit\"\n"
	append msg "using the Time-in-Beats option in \"MOVE TIME(S) TO\".\n"
	append msg "\n"
	append msg "(MORE INFORMATION - ARTICULATION & VOCODE OPTIONS ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		VboxVocode
	} else {
		set pr_vboxhelp 0
	}
}

proc VboxVocode {} {
	global pr_vboxhelp wstk
	set msg "VOICEBOX : ARTICULATION, TRANSFER AND VOCODE OPTIONS : GENERAL ISSUES\n"
	append msg "\n"
	append msg "ARTICULATION\n"
	append msg "\n"
	append msg "Tailored articulation of the segments of speech.\n"
	append msg "\n"
	append msg "\n"
	append msg "VOCODE, BE VOCODED and TRANSFER\n"
	append msg "\n"
	append msg "Take two or more input files. One sound alters the form of the other(s) ....\n"
	append msg "\n"
	append msg "\"VOCODE\" imposes the spectral characteristics of the 1st sound onto the 2nd.\n"
	append msg "\n"
	append msg "\"BE VOCODED\" imposes the spectral characteristics of the 2nd sound onto the 1st.\n"
	append msg "\n"
	append msg "\"TRANSFER\" imposes various other characteristics of the 2nd sound onto the 1st.\n"
	append msg "\n"
	append msg "with VOCODE and BE VOCODED the new characteristics may be imposed on (OR derived from) ....."
	append msg "\n"
	append msg "     (a) A set of segments cut from a single 2nd sound, at times which match the segment timings in the 1st.\n"
	append msg "            (The 2nd sound must be at least as long as the 1st).\n"
	append msg "\n"
	append msg "     (b) A set of segments specified in a single 2nd sound, (at least) equal in number to the segments in the 1st.\n"
	append msg "\n"
	append msg "     (c) A set of sounds, (at least) equal in number to the number of segments in the 1st.\n"
	append msg "\n"
	append msg "with TRANSFER  the new characteristics are derived from the corresponding segments of the 2nd sound.\n"
	append msg "and the following changes (or any combination of them) may be specified.....\n"
	append msg "\n"
	append msg "     (a) Force the TIMINGS of the 1st sound's segments to match those of the 2nd.\n"
	append msg "\n"
	append msg "     (b) Force the DURATIONS of the 1st sound's segments to match those of the 2nd.\n"
	append msg "\n"
	append msg "     (c) Force the PITCHES or pitch contours of the 1st sound's segments to match those of the 2nd.\n"
	append msg "\n"
	append msg "     (d) Force the LOUDNESSES or loudness contours of the 1st sound's segments to match those of the 1st.\n"
	append msg "\n"
	append msg "\n"
	append msg "NB: The 1st sound is assumed to be joined-up (there are no silences in it).\n"
	append msg "so that the \"durations\" of segments are determined by the steps between them.\n"
	append msg "The 2nd sound, however, may contain silences.\n"
	append msg "So if the 2nd source consists of a series of widely separate staccato events,\n"
	append msg "In case (a), this will force the events in the source to be widely separated (leaving silences between).\n"
	append msg "In case (b), this will force the events in the source to be very short (but remain at their original times).\n"
	append msg "In case (a+b), this will force the events in the source to be both very short, and widely spaced.\n"
	append msg "\n"
	append msg "GENERAL ISSUES\n"
	append msg "\n"
	append msg "THE \"RETURN\" KEY may be used to pass quickly through parameters entry, and processing,\n"
	append msg "(calling default parameters, except where a preset MUST be set by you)\n"
	append msg "\n"
	append msg "WHERE PROCESS FAILS for a particular segment, (usually) the Voicebox will continue to run, but without processing that segment.\n"
	append msg "(The process \"VERGES\", as it time-contracts the source, may fail on very short segments, with the message \"INVALID DATA\")\n"
	append msg "\n"
	append msg "(MORE INFORMATION ??)\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		set pr_vboxhelp 0
	}
}

##################
# PARAMETER HELP #
##################

#---- Help info relating to parameters, for each process

proc GettrofParamsHelp {} {
	global segment
	set msg    "PARAMETER INFORMATION.\n"
	append msg "\n"
	append msg "Existing parameter-patches may be loaded from the \"Load\" button\n"
	append msg "in either the main window, or the \"Preset Parameters\" window.\n"
	append msg "\n"
	append msg "After running a process, a parameter-patch may be saved from the \"Save Params\" button\n"
	append msg "at the foot of the main window.\n"
	append msg "\n"
	switch -- $segment(process) {
		"ITERATE" {
			append msg    "(1) DENSITY: Density of delayed events in the iterated \"reverb\".\n"
			append msg "                e.g. Value 3 converts to 10 to power minus 3 = 0.001\n"
			append msg "                and iterations occur (on average) every 0.001 seconds.\n"
			append msg "\n"
			append msg "(2) PITCH SPREAD: Delayed events are randomly scatterd in pitch \n"
			append msg "                over the semitone range specified here.\n"
			append msg "\n"
			append msg "(3) GAIN: Level of iterated tails. 1.0 = same level as input event.\n"
			append msg "\n"
			append msg "(4) TAIL END LEVEL : If less than 1.0, iterated segment fades\n"
			append msg "                to this proportion of its initial level, through the segment.\n"
			append msg "\n"
			append msg "(5) FADE STEEPNESS : If the \"Tail End Level\" is not 1.0\n"
			append msg "                this parameter governs the steepness of the level fade.\n"
			append msg "                1.0 gives a linear fade.\n"
			append msg "                Higher values fade more quickly initially, & slower later.\n"
			append msg "\n"
			append msg "(6) RANDOM SEED : This parameter value initialises the random generator\n"
			append msg "                The same seed value gives identical (randomised) output\n"
		}
		"ZIGZAG" {
			append msg "(6) RANDOM SEED : This parameter value initialises the random generator\n"
			append msg "                The same seed value should give identical (randomised) output.\n"
		}
		"PLUCKED" {
			append msg "(1) ANTIPLUCKS: Set to 1 to make event levels rise (rather than fall).\n"
			append msg "\n"
			append msg "(2) GAIN: Level of plucked tails. 1.0 = same level as input event.\n"
			append msg "\n"
			append msg "(3) TAIL END LEVEL : If less than 1.0, plucked segment fades\n"
			append msg "                to this proportion of its initial level, through the segment.\n"
			append msg "\n"
			append msg "(4) FADE STEEPNESS : If the \"Tail End Level\" is not 1.0\n"
			append msg "                this parameter governs the steepness of the level fade.\n"
			append msg "                1.0 gives a linear fade.\n"
			append msg "                Higher values fade more quickly initially, & slower later.\n"
			append msg "\n"
			append msg "(5) CROSSFADE : This parameter governs the crossfade length\n"
			append msg "                if the processed tail emerges from the unprocessed tail.\n"
			append msg "                0 is no crossfade; 1 is a crossfade over entire tail length.\n"
			append msg "\n"
			append msg "... and the following parameters, which may VARY IN TIME ....\n"
			append msg "\n"
			append msg "(6) AVERAGE DURATION: Time-separation of individual plucks (on average).\n"
			append msg "\n"
			append msg "(7) SLOPE: Larger value gives more rapid decay (more marked pluck).\n"
			append msg "                Values below 1 give softer attacks.\n"
			append msg "\n"
			append msg "(8) TROUGHING AT: Level which pluck-events reach before next pluck begins.\n"
			append msg "                Value 0 reaches (instantaneous) silence.\n"
			append msg "                Value 1 gives no pluck at all.\n"
			append msg "\n"
		}
		"FORMOVE" {
			append msg "(1) USE HEAD ALSO: Tranpose the Head, as well as the Tail, of the segment.\n"
			append msg "\n"
			append msg "(2) TRANSPOSE TO/FROM: Transpose whole segment, OR transpose at start but move to untransposed,\n"
			append msg "                                     OR don't transpose at start but move to transposed at end.\n"
			append msg "\n"
			append msg "(3) TRANSPOSITION: Semitone transposition of pitch and formants (+- 24 semitones = 2 8vas max).\n"
			append msg "\n"
		}
		"VOCODE" -
		"EDOCOV" {
			append msg "(1) VOCODE STYLE: How the vocoding signal(s) and the source segments are to be treated during Vocoding.\n"
			append msg "\n"
			append msg "          (a) Cut the Vocoding signal into chunks whose lengths correspond to the source segments' lengths.\n"
			append msg "\n"
			append msg "          (b) Stretch or Shrink the (single) Vocoding signal to correspond to the source segments' lengths.\n"
			append msg "\n"
			append msg "          (c) Use a predefined segmentation of the (single) Vocoding signal to cut it into chunks\n"
			append msg "                  and stretch or shrink these chunks to correspond to the source segments' lengths.\n"
			append msg "\n"
			append msg "          (d) Stretch or Shrink the Source signal to correspond to the Vocoding signal's length(s).\n"
			append msg "\n"
			append msg "(2) VOCODE HEAD ALSO: Vocode the Head, as well as the Tail, of the segment.\n"
			append msg "\n"
			append msg "(3) DEPTH AT START: How much of vocoded signal in mix with source, at Start of segment (0 to 1)\n"
			append msg "\n"
			append msg "(4) DEPTH AT END: How much of vocoded signal in mix with source, at End of segment (0 to 1)\n"
			append msg "\n"
			append msg "(5) SLOPE OF DEPTH: Way in which depth changes through segment (0.1 to 10).\n"
			append msg "                Values below 1 increase depth rapidly at start, values greater than 1, rapidly at end.\n"
			append msg "\n"
		}
		"TRANSFER" {
			append msg "(1) A SEGMENTATION OF THE 2ND SOUND must have been made, with at least as many segments as the 1st sound.\n"
			append msg "\n"
			append msg "\n"
			append msg "(2) TRANSFER STYLE: How the source is modified by the 2nd sound's properties : any combination of .....\n"
			append msg "\n"
			append msg "          (a) Retime the segments to entry times of 2nd sound's segments (shrinking them if necessary).\n"
			append msg "\n"
			append msg "          (b) Change durations to durations of 2nd sound's segments (retiming them if necessary).\n"
			append msg "\n"
			append msg "          (c) Change pitches, or pitch contours, to those of 2nd sound's segments.\n"
			append msg "\n"
			append msg "          (d) Change loudness, or loudness envelope, to those of 2nd sound's segments.\n"
			append msg "\n"
			append msg "(3) GATE LEVEL: (only) if Duration is selected, set a level below which 2nd sound's input will be regarded as silence.\n"
			append msg "\n"
			append msg "          (This allows the duration of silence-separated events to be determined).\n"
			append msg "\n"
			append msg "(4) REMOVE SILENCES: Removes silences from a silence-gapped output, so all segments abutt.\n"
		}
		"VERGES" {
			append msg "(1) BOOST: Boost level of verges relative to rest of sound.\n"
			append msg "\n"
			append msg "(2) TRANSPOSITION: Semitone transposition of verges.\n"
			append msg "\n"
			append msg "(3) SLOPE: Slope of the glissando glide to original pitch.\n"
			append msg "\n"
			append msg "(4) DURATION: Duration of gliss in mS .\n"
			append msg "\n"
			append msg "(NB Large transposition & long Duration, may cause \"VERGES\" to fail for shorter segments.\n"
			append msg "        sending the error message \"INVALID DATA\".)\n"
		}
		"DISTREP" {
			append msg "(1) WAVESET GROUPSIZE: Number of wavesets in the group which is repeated.\n"
			append msg "                If segment does not contain this many segments, process will fail for that segment.\n"
			append msg "\n"
			append msg "(2) WAVESET REPEATS: Number of times to repeat each waveset (2 - 16).\n"
			append msg "\n"
			append msg "(3) RELATIVE DURATION: Maximum output duration as a multiple of segment duration (1 - 100).\n"
			append msg "\n"
		}
		"DELRING" {
			append msg "(1) MIDI PITCH: Pitch of ringing of the delayline feedback.\n"
			append msg "\n"
			append msg "(2) TUNE HEAD: Also processes segment Head.\n"
			append msg "\n"
			append msg "(3) CROSSFADE: Crossfade from original to Delay Ringing.\n"
			append msg "\n"
		}
		"VIBRATO" {
			append msg "(1) FREQUENCY: Rate of pitch variation (Hz).\n"
			append msg "\n"
			append msg "(2) DEPTH: Depth of pitch variation in (possibly fractional) semitones.\n"
			append msg "\n"
		}
		"TREMOLO" {
			append msg "(1) CROSSFADE: Crossfade from original to tremolo .\n"
			append msg "\n"
			append msg "(2) FREQUENCY: Rate of loudness variation (Hz).\n"
			append msg "\n"
			append msg "(3) DEPTH: Depth of loudness variation.\n"
			append msg "\n"
			append msg "(4) PEAK NARROWING: Sharpness of loudness peaks (1- 100).\n"
			append msg "\n"
		}
		"ZIGACCEL" {
			append msg "(1) SHRINK TO: Minimum size of zigs (mS) (>= [expr ($segment(SPLICE) * 2) + 1] mS). OR ZERO (NO shrinkage).\n"
			append msg "\n"
			append msg "(2) LOG SHRINK: Shrink zigzags logarithmically (Default: Linear Shrink).\n"
			append msg "\n"
			append msg "(3) REPEATS: Number of zigzags. (Timevariable 1 to 64)\n"
			append msg "\n"
			append msg "(4) FRACTION OF TAIL: Fraction of Tail (from its start) to zigzag across (0.2 to 1).\n"
			append msg "                   If tail-fraction length is <= minsize of zigs, no shrinkage of that tail occurs.\n"
			append msg "\n"
		}
		"REVERB" {
			append msg "(1) CROSSFADE: Crossfade from original to reverb.\n"
			append msg "\n"
			append msg "(2) STADIUM SIZE: Determines average step between "echos".\n"
			append msg "\n"
			append msg "(2) ECHO COUNT: Number of "echos".\n"
			append msg "\n"
			append msg "(4) RELATIVE DURATION: Output duration as a multiple of segment duration (1 - 100).\n"
			append msg "\n"
		}
		"LOOP" {
			append msg "(1) SCATTERED: The output does not have a regular pulse, and is scattered over small pitch range.\n"
			append msg "\n"
			append msg "(2) LENGTH: Length of looped element as proportion of length of segment (tail) (0 to 1).\n"
			append msg "\n"
			append msg "(3) RELATIVE DURATION: (Maximum) output duration as a multiple of segment duration (1 - 100).\n"
			append msg "\n"
			append msg "(4) ADVANCE BY: Advance Looped-element starttime in source by this fraction of looped-element length (0 to 1).\n"
			append msg "\n"
		}
		"SCAN" {
			append msg "(1) START SCAN: Start time in segment (tail) of sound to scan, as proportion of total length (0-1).\n"
			append msg "\n"
			append msg "(2) END SCAN: End time in segment (tail) of sound to scan, as proportion of total length (0-1).\n"
			append msg "\n"
			append msg "(3) RELATIVE DURATION: (Maximum) output duration as a multiple of segment duration (1 - 100).\n"
			append msg "\n"
		}
		"TUNED" {
			append msg "(1) CHORDS: Chords may be entered from a MIDI Keyboard via the MIDI icon (miniature keyboard).\n"
			append msg "                OR by entering MIDI values as text.\n"
			append msg "                For text entry, MIDI values in the same chord must be enclosed in CURLY BRACKETS.\n"
			append msg "\n"
			append msg "(2) TUNE HEADS: Both Head and Tail are tuned (Default: only Tail is tuned).\n"
			append msg "                (Note that in this case, the output file will not have segmentation marks)\n"
			append msg "\n"
			append msg "(3) CLARITY: Proportion of tuned sound in mix with original sound.\n"
			append msg "\n"
		}
		"PITCH" {
			append msg "(1) PITCHLINE: The pitchline may be entered from a MIDI Keyboard via the MIDI icon (miniature keyboard).\n"
			append msg "                OR by entering MIDI values as text.\n"
			append msg "\n"
			append msg "(2) TUNE HEADS: Both Head and Tail are tuned (Default: only Tail is tuned).\n"
			append msg "                (Note that in this case, the output file will not have segmentation marks)\n"
			append msg "\n"
			append msg "(3) WEIGHTED PITCH: Calculation of median pitch of original segment\n"
			append msg "                 takes into account relative levels of any pitches found.\n"
			append msg "\n"
			append msg "(4) ARTICULATION RETAINED: The pitch motion of the original is to be retained.\n"
			append msg "                 (If NOT set, the output pitch is entirely level).\n"
		}
		TEXTURE {
			append msg "NB \"TEXTURE\" will always EXPAND the output file to accomodate the texturing\n"
			append msg "                 EXCEPT when used with other processes in \"A COMBINATION\", where \"Expand\" checkbox must be set.\n"
			append msg "\n"
			append msg "                 Texturing does not work as expected with Tail processes set to also affect Heads (e.g. \"TUNING\").\n"
			append msg "                 Use texturing (MONO only), ALONE, in \"A COMBINATION\",to affect specific segments,\n"
			append msg "                 then recycle the output, and apply Tails-affecting-Heads processes in a 2nd pass.\n"
			append msg "\n"
			append msg "\n"
			append msg "(1) OUTPUT CHANS: Number of output channels across which texture is spread.\n"
			append msg "\n"
			append msg "(2) MIN EVENT GAIN: Minimum gain of elements in texture.\n"
			append msg "\n"
			append msg "(3) MAX EVENT GAIN: Maximum gain of elements in texture.\n"
			append msg "\n"
			append msg "(4) RANDOM SEED : This parameter value initialises the random generator\n"
			append msg "                The same seed value should give identical (randomised) output.\n"
			append msg "(5) END LEVEL : If less than 1.0, texture fades\n"
			append msg "                to this proportion of its initial level, through the texture.\n"
			append msg "\n"
			append msg "(6) FADE STEEPNESS : If the \"End Level\" is not 1.0\n"
			append msg "                this parameter governs the steepness of the level fade.\n"
			append msg "                1.0 gives a linear fade.\n"
			append msg "                Higher values fade more quickly initially, & slower later.\n"
			append msg "\n"
			append msg "(7) FORCE LEVEL : Head is normalised before texture is made.\n"
			append msg "\n"
			append msg "(8) FADE UP TAIL : Value below 1 : tail portions of original are faded from this level.\n"
			append msg "                   Value 1 : tail portions remain at original level.\n"
			append msg "\n"
			append msg "(9) TFADE STEEPNESS : as \"FADE STEEPNESS\" applied to tail segments, but fading up.\n"
			append msg "\n"
			append msg "(When using Phrase-Segmentation, \"FADE TAIL\" and \"TFADE STEEPNESS\" values are ignored.)\n"
			append msg "\n"
			append msg "... and the following parameters, which may VARY IN TIME ....\n"
			append msg "\n"
			append msg "(10) LEVEL: Level of texture, relative to level of HEAD from which it's derived.\n"
			append msg "\n"
			append msg "(11) PERSISTENCE: Duration of texture as a proportion of tail duration. (>0 to 1).\n"
			append msg "\n"
			append msg "(12) DENSITY: (average) Time between texture events.\n"
			append msg "\n"
			append msg "(13) SCATTER: Randomisation of event timings (0 - 4).\n"
			append msg "\n"
			append msg "(14) DN TRANS MAX: Maximum downward transposition of texture events, in semitones.\n"
			append msg "\n"
			append msg "(15) UP TRANS MAX: Maximum upward transposition of texture events, in semitones.\n"
			append msg "\n"
			append msg "(16) SPACE SPREAD: Final outward spatial-spread of texture events (which start in channel 1).\n"
			append msg "\n"
			append msg "(17) SPREAD BY: 0 = texture immediately reaches max spread : 1 = max spread only by end.\n"
			append msg "\n"
		}
		BOUNCE {
			append msg "(1) TRIM: If bounced segments overlap, cut them short to avoid this.\n"
			append msg "\n"
			append msg "(2) SHRINK: Cut short bounced segments in proportion to speed-up of bounces.\n"
			append msg "\n"
			append msg "(3) KEEP END: If bounced segments are shortened, trim off the start (default, trim end).\n"
			append msg "\n"
			append msg "(4) BOUNCE OVER : Bouncing will overlay the following Tail or Phrase. (overrides global overlay flag).\n"
			append msg "\n"
			append msg "(5) TAIL FADEUP FROM : Force the associated tail-segment to fadeup from some value. (0 to 1) (1 has no effect).\n"
			append msg "\n"
			append msg "(6) TAIL FADE WARP : > 1 Fades faster at end : < 1 faster at start (Range .1 to 10).\n"
			append msg "\n"
			append msg "(When using Phrase-Segmentation, \"BOUNCE OVER\", \"TAIL FADEUP FROM\" and \"TAIL FADE WARP\" values are ignored.)\n"
			append msg "\n"
			append msg "(7) COUNT : Number of bounced-repeats (1 to 100).\n"
			append msg "\n"
			append msg "(8) EXTENT : Time to first bounced event, as a multiple of the src duration (1 to 100).\n"
			append msg "\n"
			append msg "(9) ACCEL : Ratio of distance to Nth bounce to distance to (N-1)th bounce (0.1 to 1).\n"
			append msg "\n"
			append msg "(10) ENDLEVEL: Level of final bounce, relative to src level (0 to 1).\n"
			append msg "\n"
			append msg "(11) LEVEL WARP: Warp of level fade. >1 Fades faster at start : < 1 Faster at end. (0.1 to 10).\n"
			append msg "\n"
		}
		ACCENT {
			append msg "(1) QUIETEN : Any segments with 0dB accentuation are reduced in level by \"Quieten\" dBs  (Range >0 to 60).\n"
			append msg "\n"
			append msg "(2) ACCENTUATION : Minimum level difference between Head and Tail, in dB (Range 0 to 60).\n"
			append msg "\n"
			append msg "(3) TAIL SUPPRESSED BY : Point in tail when it reaches its dis-accented level, as a proportion of Tail's length (Range 0 to 1).\n"
			append msg "\n"
		}
		TWANG {
			append msg "(1) UNTWANG : Long \"metallic\" anacrusis to the Head segment. (default, long \"metallic\" tail to Head segment.\n"
			append msg "\n"
			append msg "(2) NORMALISE : Normalise (make louder, usually) the segment before processing it.\n"
			append msg "\n"
			append msg "(3) TAIL FADEUP FROM : Force the associated tail-segment to fadeup from some value. (0 to 1) (1 has no effect).\n"
			append msg "\n"
			append msg "(4) TAIL FADE WARP : > 1 Fades faster at end : < 1 faster at start (Range .1 to 10).\n"
			append msg "\n"
			append msg "(When using Phrase-Segmentation, \"TAIL FADEUP FROM\" and \"TAIL FADE WARP\" values are ignored.)\n"
			append msg "\n"
			append msg "(5) TIMESTRETCH : Spectral Timestretch producing the \"Twang\" (Range 16 to 512).\n"
			append msg "\n"
			append msg "(6) TWANG DURATION : Duration of twang (Range 0.02 to 16 secs).\n"
			append msg "\n"
			append msg "(7) TWANG DECAY POWER : Rate of decay of twang (Range 2 to 10).\n"
		}
		RETIME {
			append msg "NEW TIMINGS can be entered by TAPPING ON A BUTTON, OR from a MIDI Keyboard.\n"
			append msg "\n"
			append msg "\"Load Patch\" loads RETIME parameters for this run.\n"
			append msg "\n"
			append msg "You can also \"Export\" or \"Import\" the timings to/from a named external textfile.\n"
			append msg "\n"
		}
		REVERSAL {
			append msg "SELECT THE GROUPING OF SEGMENTS TO BE TIME REVERSED.\n"
			append msg "\n"
			append msg "You can reverse just the TAILS, just the HEADS,\n"
			append msg "OR reverse all groups of (2,4,6 or 8) Heads & Tails.\n"
			append msg "OR retain a Head as is, before reversing a group of (3,5 or 7) Tails & Heads.\n"
			append msg "\n"
		}
		HPITCH {
			append msg "PITCH HEAD.\n"
			append msg "\n"
			append msg "Head is pitched by delayed-repetition, also thereby making the Head longer.\n"
			append msg "\n"
			append msg "(1)  MIDI PITCH. You may use ....\n"
			append msg "\n"
			append msg "(a)  The INTRINSIC PITCH of the heads themselves.\n"
			append msg "(b)  The TEMPERED version of the intrinsic pitch of the heads themselves.\n"
			append msg "(c)  Any sequence of IMPOSED PITCHES.\n"
			append msg "\n"
			append msg "(2)  HEAD EXPANSION: The factor by which the Head is extended in length (1.1 to 128).\n"
			append msg "\n"
			append msg "(3)  RANDOMISATION of the delay times: Greater randomisation makes the pitching gritty or unclear.\n"
			append msg "\n"
			append msg "(4)  DIP LEVEL of the extended Head: Maximum dip in level within the extended Head. A factor: 1 = no dip, 3 = 1/3 level.\n"
			append msg "\n"
			append msg "(5)  DIP POSITION is the position of the maximum dip within the extended Head: A fraction between 0.1 and 0.9.\n"
			append msg "\n"
			append msg "\"INCORPORATE TAIL\" forces most of Tail to be treated as part of the Head-extension.\n"
		}
		SHRHYTHM { 
			append msg "SELECT THE TEMPO AND RHYTHM PATTERN (OR TAP IN A RHYTHM) FOR THE INPUT SEGMENTS.\n"
			append msg "THE SEGMENTS WILL BE PRE-SHRUNK BEFORE BEING ARRANGED IN THE DESIRED PATTERN.\n"
			append msg "\n"
			append msg "All parameters are entered at the \"SET STYLE\" window.\n"
			append msg "\n"
			append msg "ENTER TIMES by one of the following methods...\n"
			append msg "            (1)  TAP TIMES with mouse on Button. Tap in every event, OR just a pattern (perhaps twice) to repeat.\n"
			append msg "            (2)  PLAY TIMES on a connected MIDI keyboard. Every note, or a pattern (perhaps twice) to repeat.\n"
			append msg "            (3)  CHOOSE A PATTERN which will be repeated, possibly using random omissions from the pattern.\n"
			append msg "                                        The beat pattern may be edited before it is saved and used.\n"
			append msg "            (4)  Enter SCANSION, defining quantisation steps (for sounds and rests) and then add a TEMPO value.\n"
			append msg "                                        You can also LOAD an existing scansion.\n"
			append msg "\n"
			append msg "RHYTHMIC STYLE can be :\n"
			append msg "            (1)  \"Daadi-\" : \"Da\" (long step) events sustained longer than \"di\" (short step) events.\n"
			append msg "            (2)  \"di-di\"  : All events equally short, but the STEPS BETWEEN events are still long and short.\n"
			append msg "      \"Rhythmic Style\" need not be defined for the \"Scansion\" option, as the scansion will create it.\n"
			append msg "\n"
			append msg "ACCENTUATION (Acc):\n"
			append msg "            (1)  Acc <= 1: NO CHANGE to ORIGINAL level of components.\n"
			append msg "            (2)  Acc  > 1: Accented syllables are \"Acc\" times louder than unaccented syllables.\n"
			append msg "      Accented syllables are ...\n"
			append msg "            (a)  With \"TAP TIMES\" or \"USE KBD\" :\n"
			append msg "                                         If a repeating pattern, accent is on 1st event of the pattern.\n"
			append msg "                                         Else, accents on (first of any group of) double-length events.\n"
			append msg "            (b)  With \"CHOOSE PATTERN\" :\n"
			append msg "                                         Accent on 1st event of pattern (determined by OFFSET parameter).\n"
			append msg "            (c)  With \"SCANSION\" :\n"
			append msg "                                         Accent on all Stressed syllables (marked with \"_\").\n"
			append msg "\n"
			append msg "SHRINK SIZE (in mS) determines the duration of the (shortest) output events.\n"
			append msg "             A ZERO value will only shrink syllables where they might overlay one another in the output sound.\n"
			append msg "\n"
			append msg "If parameters are saved as a PATCH, and the patch later Loaded, all these parameters will be set.\n"
			append msg "\n"
			append msg "Alternatively, you can save the SCANSION you have created, then, for a new pass, LOAD JUST THIS\n"
			append msg "(within the \"Scansion\" option) and adjust the other parameters independently.\n"
			append msg "\n"
		}
		PINCH   {
			append msg "Formants are inverted, squeezing the spectal range.\n"
			append msg "\n"
			append msg "VIBRATO. Time-variable, and can be zero (0 - 50).\n"
			append msg "\n"
		}
		SQUASH  {
			append msg "Spectrum is squashed around the specified formant.\n"
			append msg "\n"
			append msg "SQUASH : How much to squash the spectrum (Range 2 to 8).\n"
			append msg "\n"
			append msg "FORMANT NUMBER around which the spectrum is squashed (An integer between 1 & 4).\n"
			append msg "\n"
		}
		LIQUID {
			append msg "Formants move (once they reach an upper limit they rotate back to the lower limit).\n"
			append msg "\n"
			append msg "ROTATION RATE : Cycles per second (Range 0 to 16).\n"
			append msg "\n"
		}
		SQUEEZE {
			append msg "Formants shifted upwards, linearly. Sound becones squeezed into a high-frequency band.\n"
			append msg "\n"
			append msg "FREQUENCY SHIFT in Hz (0 - 4000).\n"
			append msg "\n"
		}
		DEEPEN {
			append msg "Pitch contour is expanded, causing the voice to deepen (or rise).\n"
			append msg "\n"
			append msg "MIDI PIVOT: From 50 upwards, the voice gets lower: below 50, it gets higher.\n"
			append msg "\n"
			append msg "DEEPENING (Range 1.5 to 2.5)\n"
			append msg "\n"
		}
		DEEPREV {
			append msg "Bottom of spectrum is transposed down and reverb added to it (only).\n"
			append msg "\n"
			append msg "DOWNWARD TRANSPOSITION: Transposition downward of lower part of spectrum (Range 6 to 36 semitones)"
			append msg "\n"
			append msg "STADIUM MULTIPLIER: stadium size multiplier for CDP reverb (Range 0.1 to 3)"
			append msg "\n"
			append msg "ECHO COUNT: echo count for CDP reverb (Range 10 to 800)"
			append msg "\n"
			append msg "HIGH FRQ BALANCE: Boost to high frequency in final mix (Range 1 to 4)"
			append msg "\n"
			append msg "LOW FRQ TIME OFFSET: delay of low frqs in final mix (Range 0 to 0.5)"
			append msg "\n"
		}
		TUBEREV {
			append msg "Bottom of spectrum resonates at a specified pitch, with frq upshifted spectrum superimposed.\n"
			append msg "\n"
			append msg "RESONANT PITCH: Midi pitch of low resonance. (Range 10 - 40)"
			append msg "\n"
			append msg "UPWARD FRQ SHIFT: Transposition upwards of formants (Range 2000 to 4000)"
			append msg "\n"
			append msg "LOW FREQ REVERB STADIUM MULTIPLIER: stadium size multiplier for CDP reverb (Range 0.1 to 3)"
			append msg "\n"
			append msg "LOW FREQ REVERB ECHO COUNT: echo count for CDP reverb (Range 10 to 800)"
			append msg "\n"
			append msg "OVERALL REVERB STADIUM MULTIPLIER: stadium size multiplier for CDP reverb (Range 0.1 to 3)"
			append msg "\n"
			append msg "OVERALL REVERB ECHO COUNT: echo count for CDP reverb (Range 10 to 800)"
			append msg "\n"
			append msg "HIGH FRQ BALANCE: High frequency attenuation in final mix (0.01 to 1)"
			append msg "\n"
			append msg "LOW FRQ TIME OFFSET: delay of low frqs in final mix (Range 0 to 0.5)"
			append msg "\n"
		}
		SPIKE {
			append msg "Segment spikes at specified time.\n"
			append msg "\n"
			append msg "(0)  SPIKE TIMES: Defaults, or entered specifically (e.g. plosive consonants locations)."
			append msg "\n"
			append msg "(1)  TYPE: \"AS IS\", or \"STACKED\", or \"PITCHED\" by delay feedback."
			append msg "\n"
			append msg "                  For STACKED: Enter the stacking MIDI pitches as if you were stacking from Middle C (60)"
			append msg "\n"
			append msg "                  For PITCHED : Either use the INTRINSIC pitch of the segment, or enter specific pitches."
			append msg "\n"
			append msg "                  TRANSPOSITIONS OR PITCHES: entered for types \"PITCHED\" (NOT intrinsic) and \"STACKED\"."
			append msg "\n"
			append msg "(2)  NORMALISED: IF set, all output spikes are raised to maximum level of input file.\n"
			append msg "\n"
			append msg "(3)  UP SLOPE: The steepness of the rising edge of the spike.\n"
			append msg "\n"
			append msg "(4)  DOWN SLOPE: The steepness of the faling edge of the spike.\n"
			append msg "\n"
			append msg "(5)  UP MAX DURATION: The maximum duration of the rising edge of the spike (prior to this, the segment is zeroed).\n"
			append msg "\n"
			append msg "(6)  DOWN MAX DURATION: The maximum duration of the falling edge of the spike (after this, the segment is zeroed).\n"
			append msg "\n"
		}
		SQZBOX {
			append msg "Alternately squeeze and stretch time of source, around specified segments.\n"
			append msg "\n"
			append msg "(0)  STRETCH TIMES: Indicated segments are stretched, others are squeezed."
			append msg "\n"
			append msg "(1)  SQUEEZEBOX TYPE :"
			append msg "\n"
			append msg "           (1)  Specify STRETCH and SQUEEZE VALUES (possibly timevarying).\n"
			append msg "\n"
			append msg "           (2)  Specify RATIO OF DURATIONS of stretched segments to squeezed-segment-blocks, and the TEMPO (MM).\n"
			append msg "\n"
		}
		TSTRETCH {
			append msg "Stretch time of source at specified segments.\n"
			append msg "\n"
			append msg "(0)  STRETCH TIMES: Indicated segments ONLY are stretched."
			append msg "\n"
			append msg "(1)  STRETCH VALUES (possibly timevarying).\n"
			append msg "\n"
		}
		ROUGHEN {
			append msg "Spectrum is randomsied, under the existing formants.\n"
			append msg "\n"
			append msg "ROUGHENING (Range 0.5 to 1)\n"
			append msg "\n"
		}
		RANDSTEP {
			append msg "No parameters are required.\n"
			append msg "\n"
		}
		SUPPRESS {
			append msg "No parameters are required.\n"
			append msg "\n"
			append msg "If \"SUPPRESS\" is used, the \"Phrase Expand\" option will be disabled.\n"
			append msg "\n"
		}
		default {
			set msg "NO INFO AVAILABLE YET"
		}
	}
	Inf $msg
}

##########################################################
# LOADING/SAVING & READING SEGMENTATION AND CONTROL DATA #
##########################################################

#--- Save a newly generated data file for segmentation, refined-segmentation or control-data

proc SaveSegmentationFile {testfnam type} {
	global segment wstk evv

	if {![file exists $segment(dirname)]} {
		if [catch {file mkdir $segment(dirname)} zit] {
			Inf "PROBLEM CREATING SEGMENTATION-DATA DIRECTORY $dirnam"
			return 0
		}
	}
	switch -- $type {
		RAW {	;# raw segmentation data
			if {![file exists $segment(troflist)]} {
				Inf "CANNOT FIND SEGMENTATION-FILE"
				return 0
			}
		}
		REFINED {	;#	refined segmentation data 
			if {![file exists $segment(nutroflist)]} {
				if {$segment(phrase)} {
					Inf "CANNOT FIND PHRASE-SEGMENTATION FILE"
				} else {
					Inf "CANNOT FIND REFINED-SEGMENTATION FILE"
				}
				return 0
			}
			set segment(cnt) [expr [llength $segment(marklist)] - 1]
			if [info exists segment(intext)] {
				set oldlen [llength $segment(intext)]
				set k [expr $segment(cnt) - $oldlen]
				if {$k} {
					if {$k < 0} {
						set segment(intext) [lrange $segment(intext) 0 [expr $segment(cnt) - 1]]
						set k $segment(cnt) 
						while {$k < $oldlen} {
							set segment(mtext$k) ""
							incr k
						}
					} else {
						set kk 0
						set j $oldlen
						while {$kk < $k} {
							lappend segment(intext) ""
							set segment(mtext$j) ""
							incr kk
							incr j
						}
					}
					set mnemonics_fnam [file rootname [file tail $segment(rfnam)]]
					set llen [string length $mnemonics_fnam]
					incr llen -6
					set mnemonics_fnam [string range $mnemonics_fnam 0 $llen]
					if {$segment(phrase)} {
						append mnemonics_fnam "phrs"
					} else {
						append mnemonics_fnam "text"
					}
					set mnemonics_fnam [file join $segment(dirname) $mnemonics_fnam$evv(TEXT_EXT)]
					if [catch {open $mnemonics_fnam "w"} zit] {
						Inf "CANNOT OPEN FILE $mnemonics_fnam TO SAVE RESIZED TEXT-MNEMONICS DATA"
					} else {
						puts $zit $segment(intext)
						close $zit
					}
				}
				if {$segment(cnt) > $oldlen} {
					Inf "YOU WILL NEED TO MODIFY THE TEXT MNEMONICS ASSOCIATED WITH THIS SOUND"
				} else {
					Inf "YOU MAY NEED TO MODIFY THE TEXT MNEMONICS ASSOCIATED WITH THIS SOUND"
				}
			}
		}
		CONTROL {	;#	head-preserving time-stretch data 
			if {![file exists $segment(controlfil)]} {
				Inf "CANNOT FIND HEAD-PRESERVING CONTROL FILE"
				return 0
			}
		}
	}
	switch -- $type {
		RAW {
			if [catch {file copy $segment(troflist) $testfnam} zit] {
				Inf "CANNOT COPY THE SEGMENTATION-FILE, TO SAVE IT"
				return 0
			}
		}
		REFINED {
			if [catch {file copy $segment(nutroflist) $testfnam} zit] {
				if {$segment(phrase)} {
					Inf "CANNOT COPY THE PHRASE-SEGMENTATION-FILE, TO SAVE IT"
				} else {
					Inf "CANNOT COPY THE REFINED-SEGMENTATION-FILE, TO SAVE IT"
				}
				return 0
			}
		} 
		CONTROL {
			if [catch {file copy $segment(controlfil) $testfnam} zit] {
				Inf "CANNOT COPY THE CONTROL-DATA-FILE, TO SAVE IT"
				return 0
			}
			set segment(csaved) 1
		} 
	}
	return 1
}

#--- Load previously generated data for raw segmentation, refined segmentation or control

proc LoadVboxFile {type} {
	global segment wstk evv pr_segload

	switch -- $type {
		RAW {
			catch {unset segment(segfiles)}
			if {![file exists $segment(dirname)]} {
				Inf "THERE ARE NO EXISTING RAW SEGMENTATION-FILES"
				return 0
			}
			foreach fnam [glob -nocomplain [file join $segment(dirname) *]] {
				set basfnam [file rootname [file tail $fnam]]
				if {[string first "_segs" $basfnam] == [expr [string length $basfnam] - 5]} {	;#	If file has pre-refined extension
					lappend segment(segfiles) [file rootname [file tail $fnam]]					;#	List it
				}
			}
			if {![info exists segment(segfiles)]} {
				Inf "THERE ARE NO EXISTING RAW SEGMENTATION FILES"
				return 0
			}
			set segment(segfiles) [Segsort $segment(segfiles) segs]
			set origsegfilescnt [llength $segment(segfiles)]
			set seglisting $segment(segfiles)
		}
		REFINED {
			catch {unset segment(rsegfiles)}
			if {![file exists $segment(dirname)]} {
				Inf "THERE ARE NO EXISTING REFINED-SEGMENTATION FILES"
				return 0
			}
			foreach fnam [glob -nocomplain [file join $segment(dirname) *]] {
				set basfnam [file rootname [file tail $fnam]]
				if {[string first "_rsegs" $basfnam] == [expr [string length $basfnam] - 6]} {	;#	If file has refined extension
					lappend segment(rsegfiles) [file rootname [file tail $fnam]]				;#	List it
				}
			}
			if {![info exists segment(rsegfiles)]} {
				Inf "THERE ARE NO EXISTING REFINED-SEGMENTATION FILES"
				return 0
			}
			set segment(rsegfiles) [Segsort $segment(rsegfiles) rsegs]
			set origsegfilescnt [llength $segment(rsegfiles)]
			set seglisting $segment(rsegfiles)
		}
		PHRASE {
			if {![file exists $segment(dirname)]} {
				Inf "THERE ARE NO EXISTING PHRASE-SEGMENTATION FILES"
				return 0
			}
			set f_nam [file rootname [file tail $segment(src,0)]]
			append f_nam "_phrs"
			set testfnam [file join $segment(dirname) $f_nam$evv(TEXT_EXT)]
			if {![file exists $testfnam]} {
				Inf "PHRASE-SEGMENTATION FILE DOES NOT EXIST"
				return 0
			}
			if [catch {open $testfnam "r"} zit] {
				Inf "CANNOT OPEN FILE $testfnam TO READ PHRASE SEGMENTATION DATA"
				return 0
			}
			catch {unset segment(marklist)}
			while {[gets $zit line] >= 0} {
				lappend segment(marklist) $line
			}
			close $zit
			set segment(rfnam) $f_nam
			set segment(cnt) [expr [llength $segment(marklist)] - 1]
			GettrofLoadAssociatedText
			set segment(lastload) [list $type $f_nam]
			return 1
		}
		CONTROL {
			catch {unset segment(csegfiles)}
			if {![file exists $segment(dirname)]} {
				Inf "THERE ARE NO EXISTING HEAD-PRESERVING CONTROL-DATA FILES"
				return 0
			}
			foreach fnam [glob -nocomplain [file join $segment(dirname) *]] {
				set basfnam [file rootname [file tail $fnam]]
				if {[string first "_csegs" $basfnam] == [expr [string length $basfnam] - 6]} {	;#	If file has control extension
					lappend segment(csegfiles) [file rootname [file tail $fnam]]				;#	List it
				}
			}
			if {![info exists segment(csegfiles)]} {
				Inf "THERE ARE NO EXISTING HEAD-PRESERVING CONTROL-DATA FILES"
				return 0
			}
			set segment(csegfiles) [Segsort $segment(csegfiles) csegs]
			set origsegfilescnt [llength $segment(csegfiles)]
			set seglisting $segment(csegfiles)
		}
		PURGE {
			catch {unset segment(psegfiles)} 
			if {![file exists $segment(dirname)]} {
				Inf "THERE ARE NO EXISTING SEGMENTATION DATA FILES"
				return 0
			}
			foreach fnam [glob -nocomplain [file join $segment(dirname) *]] {
				set basfnam [file rootname [file tail $fnam]]
				lappend segment(psegfiles) [file rootname [file tail $fnam]]				;#	List all
			}
			set segment(psegfiles) [lsort $segment(psegfiles)]
			set seglisting $segment(psegfiles)
		}
	}
	set f .segload
	if [Dlg_Create $f "LOAD SEGMENTATION FILE" "set pr_segload 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Load"    -command "set pr_segload 1" -width 8
		button $f.0.p -text "Previous" -command "set pr_segload 3" -width 8
		button $f.0.d -text "Delete"  -command "set pr_segload 2" -width 8
		button $f.0.q -text "Abandon" -command "set pr_segload 0" -width 8
		pack $f.0.s $f.0.p -side left
		pack $f.0.q $f.0.d -side right -padx 14
		pack $f.0 -side top -fill x -expand true

		frame $f.1
		label $f.1.tit -text "SEGMENTATION FILES" -fg $evv(SPECIAL)
		Scrolled_Listbox $f.1.ll -width 80 -height 24 -selectmode single
		pack $f.1.tit $f.1.ll -side top
		pack $f.1 -side top -fill both -expand true
		wm resizable $f 0 0
		bind $f <Return> {set pr_segload 1}
		bind $f <Escape> {set pr_segload 0}
	}

	switch -- $type {
		RAW {
			$f.0.s config -text "Load"     -command "set pr_segload 1" -bd 2 -state normal
			$f.0.p config -text "Previous" -command "set pr_segload 3" -bd 2 -state normal
			wm title .segload "LOAD RAW SEGMENTATION FILE"
			$f.0.p config -text "" -command {} -bd 0 -state disabled -bg [option get . background {}]
		}
		REFINED {
			$f.0.s config -text "Load"     -command "set pr_segload 1" -bd 2 -state normal
			$f.0.p config -text "Previous" -command "set pr_segload 3" -bd 2 -state normal
			wm title .segload "LOAD REFINED SEGMENTATION FILE"
			$f.0.p config -text "Previous" -command "set pr_segload 3" -bd 2 -state normal
		} 
		CONTROL {
			$f.0.s config -text "Load"     -command "set pr_segload 1" -bd 2 -state normal
			$f.0.p config -text "Previous" -command "set pr_segload 3" -bd 2 -state normal
			wm title .segload "LOAD HEAD-PRESERVING CONTROL-DATA FILE"
			$f.0.p config -text "" -command {} -bd 0 -state disabled -bg [option get . background {}]
		} 
		PURGE {
			$f.0.s config -text "" -command {} -bd 0 -state disabled -bg [option get . background {}]
			$f.0.p config -text "" -command {} -bd 0 -state disabled -bg [option get . background {}]
			wm title .segload "PURGE SEGMENTATION DATA FILES"
			$f.0.p config -text "" -command {} -bd 0 -state disabled -bg [option get . background {}]
		} 
	}
	$f.1.ll.list delete 0 end
	foreach fnam $seglisting {
		$f.1.ll.list insert end $fnam
	}
	$f.1.ll.list selection clear 0 end

	switch -- $type {
		RAW {
			set segment(fnam) ""
			set segflen [llength $segment(segfiles)]
		}
		REFINED {
			set segment(rfnam) ""
			set segflen [llength $segment(rsegfiles)]
		}
		CONTROL {
			set segment(cfnam) ""
			set segflen [llength $segment(csegfiles)]
		}
		PURGE {
			set segflen [llength $segment(psegfiles)]
		}
	}
	set pr_segload 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_segload  $f.1.ll.list
	while {!$finished} {
		tkwait variable pr_segload
		switch -- $pr_segload {
			3 -
			1 {
				if {$pr_segload == 3} {
					if {![info exists segment(iload)]} {
						Inf "NO PREVIOUS SELECTION MADE"
						continue
					}
					set i $segment(iload)
				} else {
					set i [$f.1.ll.list curselection]
					if {![info exists i] || ($i < 0)} {
						if {$segflen == 1} {
							set i 0
						} else {	
							Inf "NO FILE SELECTED"
							continue
						}
					}
				}
				set f_nam [$f.1.ll.list get $i]
				switch -- $type {
					RAW {
						set segment(fnam) $f_nam
						set segment(lastload) [list $type $f_nam]
					}
					REFINED {
						set testfnam [file join $segment(dirname) $f_nam$evv(TEXT_EXT)]
						if [catch {open $testfnam "r"} zit] {
							Inf "CANNOT OPEN FILE $f_nam TO READ $type SEGMENTATION DATA"
							continue
						}
						catch {unset segment(marklist)}
						while {[gets $zit line] >= 0} {
							lappend segment(marklist) $line
						}
						close $zit
						set segment(rfnam) $f_nam
						set segment(cnt) [expr [llength $segment(marklist)] - 1]
						GettrofLoadAssociatedText
						set segment(lastload) [list $type $f_nam]
						set segment(iload) $i
					} 
					CONTROL {
						set testfnam [file join $segment(dirname) $f_nam$evv(TEXT_EXT)]
						if [catch {open $testfnam "r"} zit] {
							Inf "CANNOT OPEN FILE $f_nam TO READ CONTROL DATA"
							continue
						}
						catch {unset segment(nucontrol)}
						while {[gets $zit line] >= 0} {
							lappend segment(nucontrol) $line
						}
						close $zit
						set segment(cfnam) $f_nam
						set segment(lastload) [list $type $f_nam]
					} 
				}
				set finished 1
			}
			2 {
				set i [$f.1.ll.list curselection]
				if {![info exists i] || ($i < 0)} {
					Inf "NO FILE SELECTED"
					continue
				}
				set f_nam [$f.1.ll.list get $i]
				switch -- $type {
					RAW {
						set msg2 "RAW SEGMENTATION DATA"
					}
					REFINED {
						set msg2 "REFINED SEGMENTATION DATA"
					}
					CONTROL {
						set msg2 "HEAD-PRESERVING CONTROL-DATA"
					}
					PURGE {
						set msg2 "SEGMENTATION"
					}
				}
				set msg "ARE YOU SURE YOU WANT TO DELETE $msg2 FILE $f_nam ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set f_nam_fullname [file join $segment(dirname) $f_nam$evv(TEXT_EXT)]
				if [catch {file delete $f_nam_fullname} zit] {
					Inf "CANNOT DELETE FILE $f_nam : $zit"
					continue
				}
				switch -- $type {
					RAW {
						set k [lsearch $segment(segfiles) $f_nam]
						if {$k >= 0} {
							set segment(segfiles) [lreplace $segment(segfiles) $k $k]
						}
						set fulnam [file join $segment(dirname) $segment(fnam)$evv(TEXT_EXT)]
						if [string match $segment(troflist) $fulnam] {		;#	If listing file is being used as troflist
							set segment(troflist)	 $evv(DFLT_OUTNAME)
							append segment(troflist) 0 $evv(TEXT_EXT)
						}
					}
					REFINED {
						set k [lsearch $segment(rsegfiles) $f_nam]
						if {$k >= 0} {
							set segment(rsegfiles) [lreplace $segment(rsegfiles) $k $k]
						}
						set fulnam [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
						if [string match $segment(nutroflist) $fulnam] {	;#	If listing file is being used as nutroflist
							set segment(nutroflist)	   $evv(DFLT_OUTNAME)	;#	revert to tempname for nutroflist
							append segment(nutroflist) 1 $evv(TEXT_EXT)
						}
					}
					CONTROL {
						set k [lsearch $segment(csegfiles) $f_nam]
						if {$k >= 0} {
							set segment(csegfiles) [lreplace $segment(csegfiles) $k $k]
						}
						set fulnam [file join $segment(dirname) $segment(cfnam)$evv(TEXT_EXT)]
						if [string match $segment(controlfil) $fulnam] {	;#	If nucontrol file is being used as nucontrol-list
							set segment(controlfil) $evv(DFLT_OUTNAME)	;#	revert to tempname for nutroflist
							append segment(controlfil) 3 $evv(TEXT_EXT)
						}
					}
					PURGE {
						set k [lsearch $segment(psegfiles) $f_nam]
						if {$k >= 0} {
							set segment(psegfiles) [lreplace $segment(psegfiles) $k $k]
						}
					}
				}
				$f.1.ll.list delete $i
				$f.1.ll.list selection clear 0 end
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	catch {unset segment(psegfiles)}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#--- Read "headfirst" data from segmentationfile name

proc GetHeadfirstData {fnam} {
	global segment
	set k [expr [string length $fnam] - 7]
	set segment(headfirst) [string index $fnam $k]
}

#--- Save newly generated refined-segmentation data

proc SaveRefinedData {} {
	global segment evv wstk

	if {$segment(phrase)} {
		if {$segment(phraserefine)} {
			set testfnam [file rootname $segment(xfnam)]
		} else {
			set testfnam [file rootname [file tail $segment(src,0)]]
		}
	} else {
		set segment(xfnam) [.gettrofs.4.segfil get]
		if {[string length $segment(xfnam)] <= 0} {
			if {$segment(phrase)} {
				Inf "NO PHRASE-SEGMENTATION FILENAME ENTERED"
			} else {
				Inf "NO REFINED-SEGMENTATION FILENAME ENTERED"
			}
			return 0
		}
		if {![ValidCDPRootname $segment(xfnam)]} {
			return 0
		}
		set testfnam [string tolower $segment(xfnam)]
	}
	if {$segment(phrase)} {
		set k [string first "_phrs" $testfnam]						;#	k at Kphrs
		if {$k != [expr [string length $testfnam] - 6]} {
			append testfnam "_phrs"
		}
	} else {
		set k [string first "_rsegs" $testfnam]						;#	k at Krsegs
		if {$k != [expr [string length $testfnam] - 6]} {
			append testfnam "_" $segment(headfirst)
			append testfnam "_rsegs"
		} else {
			set addhf 0
			incr k -1												;#	k at K_resgs
			set val [string index $segment(xfnam) $k]				;#	must be "0_rsegs" or "1_rsegs"
			if {($val != "1") && ($val != "0")} {
				set addhf 1
			} else {
				incr k -1											;#	k at K0_rsegs OR K1_rsegs		
				if {[string index $segment(xfnam) $k] != "_"} {		;#	must be "_0_rsegs" OR "_1_rsegs"
					set addhf 1
				}
				incr k												;#	k at K_rsegs
			}
			if {$addhf} {
				set testfnam0 [string range $testfnam 0 $k]			;#	"aaaaaaa"
				incr k
				set testfnam1 [string range $testfnam $k end]		;#	"_rsegs"
				set testfnam $testfnam0								;#	"aaaaaaa"
				append testfnam "_" $segment(headfirst) $testfnam1	;#	"aaaaaaa_0_rsegs" OR "aaaaaaa_1_rsegs"
			}
		}
	}	
	set testfnam [file join $segment(dirname) $testfnam$evv(TEXT_EXT)]
	if {[file exists $testfnam]} {
		if {!$segment(phrase)} {
			set msg "FILE $segment(xfnam) ALREADY EXISTS: OVERWRITE IT ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				.gettrofs.4.segfil config -state normal -fg $evv(POINT)
				return 0
			} 
		}
		if [catch {file delete $testfnam} zit] {

			Inf "CANNOT DELETE EXISTING FILE $testfnam: $zit: SUGGEST RESTART LOOM"
			return 0
		}
	}
	if {![SaveSegmentationFile $testfnam REFINED]} {
		Inf "CANNOT SAVE SEGMENTATION FILE $testfnam"
		return 0
	}
	set segment(rfnam) [file rootname [file tail $testfnam]]
	ForceVal .gettrofs.4.segfil $segment(rfnam)
	return 1
}

#--- Save newly generated unrefined segmentation data

proc SaveUnrefinedData {} {
	global segment evv wstk
	set segment(xfnam) [.gettrofs.4.segfil get]
	if {[string length $segment(xfnam)] <= 0} {
		Inf "NO SEGMENTATION-FILE NAME ENTERED"
		return 0
	}
	if {[string match [string tolower $segment(xfnam)] "recycle"]} {
		Inf "\"$segment(xfnam)\" IS A RESERVED NAME : PLEASE CHOOSE A DIFFERENT NAME"
		return 0
	}
	if {![ValidCDPRootname $segment(xfnam)]} {
		return 0
	}
	set testfnam [string tolower $segment(xfnam)]
	set k [string first "_segs" $testfnam]
	if {$k != [expr [string length $testfnam] - 5]} {
		append testfnam "_segs"
	}
	set testfnam [file join $segment(dirname) $testfnam$evv(TEXT_EXT)]
	if {[file exists $testfnam]} {
		set msg "FILE $segment(xfnam) ALREADY EXISTS: OVERWRITE IT ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return 0
		} else {
			if {[catch {file delete $testfnam} zit]} {
				Inf "CANNOT DELETE EXISTING FILE $segment(xfnam)"
				return 0
			}
		}
	}
	if {![SaveSegmentationFile $testfnam RAW]} {
		Inf "CANNOT SAVE SEGMENTATION FILE $segment(xfnam)"
		return 0
	}
	set segment(fnam) [file rootname [file tail $testfnam]]
	ForceVal .gettrofs.4.segfil $segment(fnam)
	return 1
}

#--- Sort segmentation & control files

proc Segsort {fnams tail} {

	set len [llength $fnams]
	set len_less_one [expr $len - 1]
	set lentail [string length $tail]	;#	Start of "segs"
	switch -- $tail {
		"rsegs" {
			incr lentail 4				;#	1 before "_0_rsegs" OR "_1_rsegs"
		}
		default {
			incr lentail 2				;#	1 before "_csegs" OR "_segs"
		}
	}
	foreach fnam $fnams {
		set k [expr [string length $fnam] - $lentail]
		set fnamb [string range $fnam 0 $k]
		lappend fnambs $fnamb
	}
	set n 0
	while {$n < $len_less_one} {
		set fnamb_n [lindex $fnambs $n]
		set fnam_n  [lindex $fnams  $n]
		set m $n
		incr m
		while {$m < $len} {
			set fnamb_m [lindex $fnambs $m]
			set fnam_m  [lindex $fnams  $m]

			if {[string compare $fnamb_m $fnamb_n] < 0} {
				set fnambs [lreplace $fnambs $m $m $fnamb_n]
				set fnambs [lreplace $fnambs $n $n $fnamb_m]
				set fnams [lreplace $fnams $m $m $fnam_n]
				set fnams [lreplace $fnams $n $n $fnam_m]
				set fnamb_n $fnamb_m
				set fnam_n  $fnam_m
			}
			incr m
		}
		incr n
	}
	return $fnams
}

########################################################
# WARPING SEGMENTATION FILES TO AVOID STRETCHING HEADS #
########################################################

#---- Take a normal brkpnt controlfile and warp it to avoid altering head data

proc DoControlWarp {fromfile} {
	global segment
	if {$fromfile} {
		if [catch {open $segment(prectrlfil) "r"} zit] {
			Inf "CANNOT OPEN THE CONTROL DATA FILE"
			return 0
		}
		catch {unset nulines}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			if {[string match [string index $line 0] ";"]} {
				continue
			}
			set line [split $line]
			set nuline {}
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend nuline $item
			}
			if {[llength $nuline] != 2} {
				Inf "INVALID DATA IN CONTROL FILE"
				close $zit
				return 0
			}
			lappend nulines $nuline
		}
		close $zit
		if {![info exists nulines]} {
			Inf "NO DATA IN CONTROL FILE"
			return 0
		}
		if {[llength $nulines] < 2} {
			lappend nulines [lindex $nulines 0]		;#	Single time-val pair to a 2 point straight line
		}
	}
	if {[IsTimestretchProcess $segment(process)]} {
		if {$fromfile} {
			set segment(control1,$segment(process)) $nulines
		}
		switch -- $segment(process) {
			"TIMESTRETCH" {
				if {![DoControlWarp_Timestretch]} {
					return 0
				}
			}
			"ITERATE" {
				if {![DoControlWarp_Iterate]} {
					return 0
				}
			}
			"ZIGZAG" {
				if {![DoControlWarp_ZigZag]} {
					return 0
				}
			}
		}
	} else {
		set segment(control$segment(vp),$segment(process)) $nulines	;#	Non-timestretch processes always arrive here "fromfile"
	}
	return 1
}

proc DoControlWarp_Timestretch {} {
	global segment

	if {$segment(phrase)} {
		set segment(nucontrol) $segment(control1,$segment(process))		;#	With phrases, no warping of control-data as no Head/Tail distinction
	} else {
		set clen [llength $segment(control1,$segment(process))]
		set mlen [llength $segment(marklist)]
		catch {unset segment(nucontrol)}

		;#	WHERE IS FIRST MARKED HEAD

		if {$segment(headfirst)} {
			set nextheadstt [lindex $segment(marklist) 0]
			set nextheadend [lindex $segment(marklist) 1]
			set nextmliststt 2
			set nextmlistend 3
		} else {
			set nextheadstt [lindex $segment(marklist) 1]
			set nextheadend [lindex $segment(marklist) 2]
			set nextmliststt 3
			set nextmlistend 4
		}
		set nextheadsttlim [expr $nextheadstt - $segment(ONSET)]
		if {$nextheadsttlim < 0.0} {
			set nextheadsttlim 0.0
		}
		set nextheadendlim [expr $nextheadend + $segment(ONSET)]
		set lastheadend 0	;#	Default
		
		set lastctim [lindex [lindex $segment(control1,$segment(process)) 0] 0]
		set lastcval [lindex [lindex $segment(control1,$segment(process)) 0] 1]				;#	First controlfile-time must be at time zero 

		switch -- $segment(shape) {

			"ASIS" -
			"FLAT" -
			"LIN" {

				;#	WHAT HAPPENS AT START

				set cn 1
				if {$segment(headfirst)} {
					lappend segment(nucontrol) [list $nextheadstt 1.0]					;#	Put in non-stretched HEAD
					lappend segment(nucontrol) [list $nextheadend 1.0]
					set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
					set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
					set timcdiff [expr $thisctim - $lastctim]
					set valcdiff [expr $thiscval - $lastcval]

					while {$thisctim < $nextheadendlim} {								;#	If next controlfile-time falls BEFORE the END of the HEAD
						set lastctim $thisctim											;#	advance along control file values
						set lastcval $thiscval
						incr cn
						set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
						set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
						set timcdiff [expr $thisctim - $lastctim]
						set valcdiff [expr $thiscval - $lastcval]
					}
					switch -- $segment(shape) {
						"ASIS" -
						"FLAT" {
							set timefrac [expr ($nextheadendlim - $lastctim)/$timcdiff]	
							set val [expr $lastcval + ($valcdiff * $timefrac)]			;#	Now Interp a value for control file at final boundary of HEAD
							lappend segment(nucontrol) [list $nextheadendlim $val]
						}
						"LIN" {
							;#	Value rises from 1 to next headstart, no val needed at the END of the HEAD
						}
					} 
					if {$nextmlistend < $mlen} {										;#	And find where next HEAD block is
						set nextheadstt [lindex $segment(marklist) $nextmliststt]
						set nextheadsttlim [expr $nextheadstt - $segment(ONSET)]
						incr nextmliststt 2
						set nextheadend [lindex $segment(marklist) $nextmlistend]
						set nextheadendlim [expr $nextheadend + $segment(ONSET)]
						incr nextmlistend 2
					} else {
						set nextheadsttlim 100000										;#	If there are no more head markers, set next head way beyond end-of-file
					}
				} else {
					switch -- $segment(shape) {
						"ASIS" -
						"FLAT" {
							lappend segment(nucontrol) [list $lastctim $lastcval]
							set val $lastcval
						}
						"LIN" {
							lappend segment(nucontrol) [list $lastctim 1.0]
						}
					}
				}

				;#	MODIFY THE CONTROL FILE TO ACCOMODATE THE PRESERVED HEADS

				while {$cn < $clen} {
					set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
					set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
					set timcdiff [expr $thisctim - $lastctim]
					set valcdiff [expr $thiscval - $lastcval]
					while {$thisctim >= $nextheadsttlim}  {								;#	If controlfile-time reached beyond next HEAD start
						switch -- $segment(shape) {
							"ASIS" -
							"LIN" {
								set timefrac [expr ($nextheadsttlim - $lastctim)/$timcdiff]		
								set val [expr $lastcval + ($valcdiff * $timefrac)]		;#	so interp a val for control, and place at initial boundary of HEAD
							}
							"FLAT" {
								;#	 retains val used for start of tail
							}
						}
						lappend segment(nucontrol) [list $nextheadsttlim $val]
						lappend segment(nucontrol) [list $nextheadstt 1.0]				;#	Put in (no-stretch) values for HEAD segment
						lappend segment(nucontrol) [list $nextheadend 1.0]
						if {$nextheadend > $segment(dur)} {							;#	If run off end of file, quit	
							set cn $clen
							break
						}
						while {($thisctim < $nextheadendlim) && ($nextheadendlim < $segment(dur))} { ;#	If controlfile-time falls BEFORE the END of the HEAD
							set lastctim $thisctim										;#	advance along control file values
							set lastcval $thiscval
							incr cn
							set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
							set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
							set timcdiff [expr $thisctim - $lastctim]
							set valcdiff [expr $thiscval - $lastcval]
						}
						switch -- $segment(shape) {
							"ASIS" -
							"FLAT" {
								set timefrac [expr ($nextheadendlim - $lastctim)/$timcdiff]
								set val [expr $lastcval + ($valcdiff * $timefrac)]		;#	Now Interp a value for control file at end-boundary of HEAD
								lappend segment(nucontrol) [list $nextheadendlim $val]
							}
							"LIN" {
								;#	Value rises from 1 to next headstart, no val needed at the END of the HEAD
							}
						}
						if {$nextmlistend < $mlen} {									;#	Advance along HEAD markers
							set nextheadstt [lindex $segment(marklist) $nextmliststt]
							set nextheadsttlim [expr $nextheadstt - $segment(ONSET)]
							incr nextmliststt 2
							set nextheadend [lindex $segment(marklist) $nextmlistend]
							set nextheadendlim [expr $nextheadend + $segment(ONSET)]
							incr nextmlistend 2
						} else {
							set nextheadsttlim 100000									;#	If there are no more head markers, set next head way beyond end-of-file
						}
					}
					if {$thisctim < $nextheadsttlim}  {									;#	If controlfile-time not reached next HEAD
						if {$thisctim >= $segment(dur)} {								;#	If we've reached beyond end of file,
							switch -- $segment(shape) {
								"ASIS" -
								"LIN" {
									set timefrac [expr ($segment(dur) - $lastctim)/$timcdiff]
									set val [expr $lastcval + ($valcdiff * $timefrac)]	;#	put in an end of file val	
								}
								"FLAT" {
									;#	retains val used for start of tail
								}
							}
							lappend segment(nucontrol) [list $segment(dur) $val]
							break
						} else {
							switch -- $segment(shape) {
								"ASIS" {												;#	Use the control time&val
									lappend segment(nucontrol) [list $thisctim $thiscval]
								}														;# Else, IGNORE the control val
							}
											
						}
					}		
					set lastctim $thisctim
					set lastcval $thiscval
					incr cn
				}
	#			if {[lindex [lindex $segment(nucontrol) end] 0] < $segment(dur)} {
	#				set penult [llength $segment(nucontrol)]
	#				incr penult -2
	#				if {$penult >= 0} {
	#					set val [lindex [lindex $segment(nucontrol) $penult] 1]
	#					lappend segment(nucontrol) [list $segment(dur) $val]
	#				}
	#			}
			}
			"TF" {
				;#	WHAT HAPPENS AT START

				set cn 1
				set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
				set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
				set timcdiff [expr $thisctim - $lastctim]
				set valcdiff [expr $thiscval - $lastcval]
				if {$segment(headfirst)} {
					lappend segment(nucontrol) [list $nextheadstt 1.0]				;#	Put in non-stretched HEAD
					lappend segment(nucontrol) [list $nextheadend 1.0]

					if {$nextmlistend < $mlen} {									;#	And find where next HEAD block is
						set fwdheadstt [lindex $segment(marklist) $nextmliststt]
						set tstep [expr $fwdheadstt - $nextheadend]					;#	And midtime between heads
						set midtime [expr ($nextheadend + $fwdheadstt)/2.0]
					} else {
						set midtime [expr ($nextheadend + $segment(dur))/2.0]
					}
					if {$nextmlistend < $mlen} {									;#	And find where next HEAD block is
						set nextheadstt [lindex $segment(marklist) $nextmliststt]
						incr nextmliststt 2
						set lastheadend $nextheadend
						set nextheadend [lindex $segment(marklist) $nextmlistend]
						incr nextmlistend 2
					} else {
						set nextheadstt 100000										;#	If there are no more head markers, set next head way beyond end-of-file
					}
				} else {
					lappend segment(nucontrol) [list $lastctim 1.0]					;#	Otherwise start with no-stretch
					set tstep [expr $nextheadstt - $lastctim]
					set midtime [expr ($lastctim + $nextheadstt)/2.0]
				}

				while {$thisctim < $midtime} {										;#	If next controlfile-time falls BEFORE the MIDPOINT between HEADS
					set lastctim $thisctim											;#	advance along control file values
					set lastcval $thiscval
					incr cn
					set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
					set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
					set timcdiff [expr $thisctim - $lastctim]
					set valcdiff [expr $thiscval - $lastcval]
				}
				set timefrac [expr ($midtime - $lastctim)/$timcdiff]	
				set val [expr $lastcval + ($valcdiff * $timefrac)]					;#	Now Interp a value for control file at MIDPOINT between HEADS
				lappend segment(nucontrol) [list $midtime $val]

				while {$thisctim < $nextheadendlim} {								;#	If next controlfile-time falls BEFORE the END of the HEAD
					set lastctim $thisctim											;#	advance along control file values
					set lastcval $thiscval
					incr cn
					set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
					set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
					set timcdiff [expr $thisctim - $lastctim]
					set valcdiff [expr $thiscval - $lastcval]
				}

				;#	MODIFY THE CONTROL FILE TO ACCOMODATE THE PRESERVED HEADS

				while {$cn < $clen} {
					set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
					set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
					set timcdiff [expr $thisctim - $lastctim]
					set valcdiff [expr $thiscval - $lastcval]
					while {$thisctim >= $nextheadstt}  {								;#	If controlfile-time reached beyond next HEAD start
						lappend segment(nucontrol) [list $nextheadstt 1.0]				;#	Put in (no-stretch) values for HEAD segment
						lappend segment(nucontrol) [list $nextheadend 1.0]
						if {$nextmlistend < $mlen} {									;#	And find where next HEAD block is
							set fwdheadstt [lindex $segment(marklist) $nextmliststt]
							set tstep [expr $fwdheadstt - $nextheadstt]					;#	And midtime between heads
							set midtime [expr ($nextheadend + $fwdheadstt)/2.0]
						} else {
							set midtime [expr ($nextheadend + $segment(dur))/2.0]
						}
						while {$thisctim < $midtime} {									;#	If next controlfile-time falls BEFORE the MIDPOINT between HEADS
							set lastctim $thisctim										;#	advance along control file values
							set lastcval $thiscval
							incr cn
							set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
							set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
							set timcdiff [expr $thisctim - $lastctim]
							set valcdiff [expr $thiscval - $lastcval]
						}
						set timefrac [expr ($midtime - $lastctim)/$timcdiff]	
						set val [expr $lastcval + ($valcdiff * $timefrac)]				;#	Now Interp a value for control file at MIDPOINT between HEAD
						lappend segment(nucontrol) [list $midtime $val]
						while {$thisctim < $nextheadend} {								;#	If controlfile-time falls BEFORE the END of the HEAD
							set lastctim $thisctim										;#	advance along control file values
							set lastcval $thiscval
							incr cn
							set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
							set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
							set timcdiff [expr $thisctim - $lastctim]
							set valcdiff [expr $thiscval - $lastcval]
						}
						if {$nextmlistend < $mlen} {									;#	Advance along HEAD markers
							set nextheadstt [lindex $segment(marklist) $nextmliststt]
							incr nextmliststt 2
							set lastheadend $nextheadend
							set nextheadend [lindex $segment(marklist) $nextmlistend]
							incr nextmlistend 2
						} else {
							set nextheadstt 100000										;#	If there are no more head markers, set next head way beyond end-of-file
						}

						while {$thisctim < $nextheadend} {								;#	If controlfile-time falls BEFORE the END of the HEAD
							set lastctim $thisctim										;#	advance along control file values
							set lastcval $thiscval
							incr cn
							set thisctim [lindex [lindex $segment(control1,$segment(process)) $cn] 0]
							set thiscval [lindex [lindex $segment(control1,$segment(process)) $cn] 1]
							set timcdiff [expr $thisctim - $lastctim]
							set valcdiff [expr $thiscval - $lastcval]
						}
					}
					if {$thisctim < $nextheadstt}  {									;#	If controlfile-time not reached next HEAD
						if {$thisctim >= $segment(dur)} {								;#	If we've reached beyond end of file,

							set midtime [expr ($lastheadend + $segment(dur))/2.0] 
							lappend segment(nucontrol) [list $segment(dur) 1.0]
						break
						}
					}		
					set lastctim $thisctim
					set lastcval $thiscval
					incr cn
				}
			}	
		}
	}
	if [catch {open $segment(controlfil) "w"} zit] {
		Inf "CANNOT OPEN FILE $segment(controlfil) TO WRITE THE MODIFIED CONTROL DATA"
		return 0
	}
	foreach line $segment(nucontrol) {
		puts $zit $line
	}
	close $zit
	return 1
}

#--- Save newly-generated control data

proc SaveControlData {} {
	global segment evv wstk

	set segment(xfnam) [.gettrofs.4.segfil get]
	if {[string length $segment(xfnam)] <= 0} {
		Inf "AT THIS STAGE YOU MUST SAVE THE CONTROL-DATA TO A NAMED FILE\n\nNO CONTROL-DATA FILENAME ENTERED"
		return 0
	}
	if {![ValidCDPRootname $segment(xfnam)]} {
		return 0
	}
	set testfnam [string tolower $segment(xfnam)]
	set k [string first "_csegs" $testfnam]						;#	k at Krsegs
	if {$k != [expr [string length $testfnam] - 6]} {
		append testfnam "_csegs"
	}	
	set testfnam [file join $segment(dirname) $testfnam$evv(TEXT_EXT)]
	if {[file exists $testfnam]} {
		set msg "FILE $segment(xfnam) ALREADY EXISTS: OVERWRITE IT ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			.gettrofs.4.segfil config -state normal -fg $evv(POINT)
			return 0
		} else {
			if [catch {file delete $testfnam} zit] {
				Inf "CANNOT DELETE EXISTING FILE $segment(xfnam)"
				return 0
			}
		}
	}
	if {![SaveSegmentationFile $testfnam CONTROL]} {
		Inf "CANNOT SAVE CONTROL FILE $segment(xfnam)"
		return 0
	}
	set segment(cfnam) [file rootname [file tail $testfnam]]
	ForceVal .gettrofs.4.segfil $segment(cfnam)
	return 1
}

#################
# RUN PROCESSES #
#################

#--- Run sound-processing, and convert output to wav format

proc RunSegProcess {} {
	global segment wstk evv
													;#	segment(outfnamplay_dflt) remembers name of temp outfile segment(outfnamplay) used initally as name for process outfile.
	catch {file delete $segment(outfnamplay_dflt)}	;#	Later the outfile may be renamed and becomes the playable file, so segment(outfnamplay) takes on name of saved file.
	catch {file delete $segment(outfnam_dflt)}		;#	Deleting segment(outfnamplay_dflt) will delete segment(outfnamplay) IF it still has its temporary filename.
													;#	But will not delete it if it has been renamed/saved (in which case there is no temporary file to delete).

	if {$segment(process) == "RETIME"} {			;#	Avoid previous saved file being deleted, if retimed version is saved
		set segment(outfnamplay) $segment(outfnamplay_dflt)
	}
	if {![SegProcess]} {
		if {$segment(cload)} {
			ResetProcessBlock TIMESTRETCH_ONLY
		} else {
			if {$segment(multiproccnt)} {											;#	If multiprocess, delete any transformed files
				set segment(proctyp) ""												;#	Start again
				ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE							;#	Deletes all temporary files

			} elseif {[info exists segment(recycprocess)]} {						;#	IF in a recycled process	
				set msg "CONTINUE WITH REPROCESSING ??"								;#	and decide to continue with it, despite process failure
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {												;#	If in a recycle process for Tails (or for All segs)
					if {($segment(proctyp) == "TAIL") || ($segment(proctyp) == "WHOLE")} {
						if {[file exists $evv(MACH_OUTFNAME)PT1$evv(SNDFILE_EXT)]} {	;#	Delete any processed tails
							foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)PT*] {
								if [catch {file delete $fnam} zit] {
									Inf "CANNOT DELETE PREVIOUSLY PROCESSED SEGMENT $fnam"
									break
								}
							}	
						}															;#	If in a recycle process for Heads (or for All segs)
					} elseif {($segment(proctyp) == "HEAD") || ($segment(proctyp) == "WHOLE")} {
						if {[file exists $evv(MACH_OUTFNAME)PH1$evv(SNDFILE_EXT)] \
						||  [file exists $evv(MACH_OUTFNAME)PHF1$evv(SNDFILE_EXT)]} {;#	Delete any processed Heads
							foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)PH*] {
								if [catch {file delete $fnam} zit] {
									Inf "CANNOT DELETE PREVIOUSLY PROCESSED SEGMENT $fnam"
									break
								}
							}	
						}
					}
					ResetGetSyllabTrofs RECYCLE_TO_REPROCESS						;#	Go back and choose a different process
				} else {
					set segment(proctyp) ""											;#	IF not continuing
					if {$segment(reordered)} {
						set segment(reordered) 0									;#	If a reordered file, the previous mixlines will be destroyed
						ResetGetSyllabTrofs INITIALISE								;#	But tails are dovetailed, and files renumbered, so abandon!!

					} else {														;#	Else start processing again
						ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE					;#	Deleting all temporary files
					}
				}
			} else {																;#	If a single process
				set segment(proctyp) ""												;#	Start again
				if {$segment(reordered) || ($segment(process) == "ARTICULATION")} {
					set segment(reordered) 0										;#	If a reordered file, the previous mixlines will be destroyed
					ResetGetSyllabTrofs INITIALISE									;#	But tails are dovetailed, and files renumbered, so abandon!!

				} else {															;#	Else start processing again
					ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE						;#	Deleting all temporary files
				}
			}
		}
		return 0
	} else {
		if {$segment(multiproccnt)} {		;#	For multiprocessing, continue until all procs completed
			RememberGettrofVORFParams
			return 1
		}
		if {![ConvertTrofSndOutputToOtherFormat]} {
			if {![file exists $segment(outfnamplay_dflt)]} {
				return 0					;#	If no playable outfile exists, exit here
			}
		}
		set segment(returnkeystate) R_PLAY
		RememberGettrofVORFParams
		ResetGetSyllabTrofs OUTPUT_CREATED
	}
	return 1
}

#--- Gateway to all Processes

proc SegProcess {} {
	global segment
	if {$segment(phrase)} {
		set segment(headfirst) 1
	}
	switch -- $segment(process) {
		TIMESTRETCH	-
		ZIGZAG	 {
			if {![file exists $segment(controlfil)]} {
				Inf "CANNOT FIND CONTROL DATA"
				return 0
			}
			if {[SegTimestretch]} {
				return 1
			}
		}
		ITERATE {
			if {![file exists $segment(controlfil)]} {
				Inf "CANNOT FIND CONTROL DATA"
				return 0
			}
			if {[DoIterationTimestretch]} {
				return 1
			}
		}
		PLUCKED {
			if {[DoPlucked]} {
				return 1
			}
		}
		REVERSAL {
			if {[DoReversal]} {
				return 1
			}
		}
		VOCODE -
		EDOCOV {
			if {[DoVocode]} {
				return 1
			}
		}
		TRANSFER {
			if {[DoTransfer]} {
				return 1
			}
		}
		FORMOVE -
		DISTREP -
		DELRING -
		VIBRATO -
		TREMOLO -
		REVERB -
		LOOP -
		SCAN - 
		ZIGACCEL -
		VERGES {
			if {[DoOther]} {
				return 1
			}
		}
		SHRHYTHM {
			if {[DoShrhythm]} {
				return 1
			}
		}
		ARTICULATION {
			if {[DoArticulation]} {
				return 1
			}
		}
		TUNED {
			if {[DoTuned]} {
				return 1
			}
		}
		PITCH {
			if {[DoPitch]} {
				return 1
			}
		}
		TEXTURE  {
			if {[DoTexture]} {
				return 1
			}
		}
		BOUNCE {
			if {[DoBounce]} {
				return 1
			}
		}
		ACCENT {
			if {[DoAccent]} {
				return 1
			}
		}
		TWANG {
			if {[DoTwang]} {
				return 1
			}
		}
		SUPPRESS {
			if {[DoSuppress]} {
				return 1
			}
		}
		RETIME {
			if {[DoRetime]} {
				return 1
			}
		}
		HPITCH {
			if {[DoHeadPitch]} {
				return 1
			}
		}
		PINCH   -
		SQUASH  -
		LIQUID  -
		SQUEEZE -
		DEEPEN  - 
		ROUGHEN -
		RANDSTEP {
			if {[DoSpecfnu $segment(process)]} {
				return 1
			}
		}
		DEEPREV {
			if {[DoDeepRev]} {
				return 1
			}
		}
		TUBEREV {
			if {[DoTubeRev]} {
				return 1
			}
		}
		SPIKE {
			if {[DoSpike]} {
				return 1
			}
		}
		TSTRETCH -
		SQZBOX {
			if {[DoSqueezeBox]} {
				return 1
			}
		}
		STUTTER  -
		SPLINTER {
			Inf "NOT WRITTEN THIS PROCESS YET (4XX)"
		}
	}
	return 0
}

#######################
# SAVING SOUND OUTPUT #
#######################

#-- Convert anal output to wav

proc ConvertTrofSndOutputToOtherFormat {} {
	global segment prg_dun prg_abortd simple_program_messages CDPidrun evv

	if {[MultipleProcessing]} {
		set ochans [GettrofMixChancnt]
		if {$ochans > 1} {			;#	OUTPUT NOT MONO
			return 1
		} elseif {[file exists $segment(outfnam)]} {
			if [catch {file delete $segment(outfnam)} zit] {
				Inf "CANNOT DELETE TEMPORARY SOUNDFILE $segment(outfnam)\nSO CANNOT CREATE COMPLEMENTARY ANALYSIS FILE"
				return 1
			}
		}
	}
	switch -- $segment(process) {
		"TIMESTRETCH" {
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd synth $segment(outfnam) $segment(outfnamplay)
			set outfile $segment(outfnamplay)
		}
		"PLUCKED" -
		"DISTREP" -
		"DELRING" -
		"VIBRATO" -
		"TREMOLO" -
		"REVERB" -
		"LOOP" -
		"SCAN" -
		"VERGES" -
		"TUNED" -
		"PITCH" -
		"SUPPRESS" -
		"RETIME" -
		"ITERATE" -
		"REORDER" -
		"BOUNCE" -
		"ACCENT" -
		"TWANG" -
		"FORMOVE" -
		"VOCODE" -
		"EDOCOV" -
		"TRANSFER" -
		"REVERSAL" -
		"SHRHYTHM" -
		"ARTICULATION" -
		"ZIGACCEL" -
		"HPITCH" -
		"PINCH"  -
		"SQUASH" -
		"LIQUID" -
		"SQUEEZE" -
		"DEEPEN"  - 
		"ROUGHEN" -
		"RANDSTEP" -
		"SPIKE" -
		"SQZBOX" -
		"TSTRETCH" -
		"ZIGZAG" {
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd anal 1 $segment(outfnamplay) $segment(outfnam)
			set outfile $segment(outfnam)
		}
		"TEXTURE" {
			if {$segment(PAR0) == 1} {
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd anal 1 $segment(outfnamplay) $segment(outfnam)
				set outfile $segment(outfnam)
			} else {
				return 1			;#	Stereo or multichannel output will not convert to a PVOC file
			}
		}
		"TUBEREV" -
		"DEEPREV" {
			return 1				;#	Stereo will not convert to a PVOC file
		}
		default {
			Inf "PROCESS $segment(process) TRYING TO USE ConvertTrofSndOutputToOtherFormat"
			return 0
		}
	}
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	
	Block "PLEASE WAIT:        CONVERTING OUTPUT SOUND TO OTHER FORMAT"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN CONVERSION PROCESS"
		catch {unset CDPidrun}
		UnBlock
		return 1
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE OTHER FORMAT FILE"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 1
	}
	if {![file exists $outfile]} {
		Inf "NO COMPLEMENTARY FORMAT FILE WAS CREATED"
		UnBlock
		return 1
	}
	UnBlock
	return 1
}

#--- Save sound output from trofsegs

proc TrofsegsSaveSound {} {
	global segment evv
	set segment(xfnam)	[.gettrofs.4.segfil get]
	if {[string length $segment(xfnam)] <= 0} {
		Inf "NO OUTPUT FILENAME ENTERED"
		return 0
	}
	if {![ValidCDPRootname $segment(xfnam)]} {
		return 0
	}
	set segment(ofnama) [string tolower $segment(xfnam)]

	append segment(ofnama) $evv(ANALFILE_EXT)
	if {[file exists $segment(ofnama)]} {
		Inf "ANALYSIS FILE $segment(xfnam) ALREADY EXISTS: PLEASE CHOOSE A DIFFERENT NAME"
		unset segment(ofnama)
		return 0
	}
	set segment(ofnamw) [string tolower $segment(xfnam)]
	append segment(ofnamw) $evv(SNDFILE_EXT)
	if {[file exists $segment(ofnamw)]} {
		Inf "WAV FILE $segment(xfnam) ALREADY EXISTS: PLEASE CHOOSE A DIFFERENT NAME"
		unset segment(ofnamw)
		return 0
	}
	set segment(lastnam,sound) [file rootname [file tail $segment(ofnamw)]]
	switch -- $segment(process) {
		"TIMESTRETCH" {
			if [catch {file rename $segment(outfnam) $segment(ofnama)} zit] {
				Inf "CANNOT RENAME THE OUTPUT ANALYSIS FILE, TO SAVE IT"
				unset segment(ofnama)
				unset segment(ofnamw)
				return 0
			}
			FileToWkspace $segment(ofnama) 0 0 0 0 1
			if {[file exists $segment(outfnamplay)]} {
				if [catch {file rename $segment(outfnamplay) $segment(ofnamw)} zit] {
					Inf "CANNOT RENAME THE OUTPUT SOUNDFILE, TO SAVE IT"
					unset segment(ofnamw)
				}
				set segment(outfnamplay) $segment(ofnamw)
				FileToWkspace $segment(ofnamw) 0 0 0 0 1
			}
		}
		"PLUCKED" -
		"DISTREP" -
		"DELRING" -
		"VIBRATO" -
		"TREMOLO" -
		"REVERB" -
		"LOOP" -
		"SCAN" -
		"VERGES" -
		"TUNED" -
		"PITCH" -
		"SUPPRESS" -
		"RETIME" -
		"ITERATE" -
		"ZIGZAG"  -
		"BOUNCE"  -
		"ACCENT"  -
		"TWANG"  -
		"FORMOVE"  -
		"VOCODE"  -
		"EDOCOV"  -
		"TRANSFER" -
		"REVERSAL" -
		"SHRHYTHM" -
		"ARTICULATION" -
		"ZIGACCEL" -
		"HPITCH" -
		"PINCH"  -
		"SQUASH" -
		"LIQUID" -
		"SQUEEZE" -
		"DEEPEN"  - 
		"DEEPREV"  - 
		"TUBEREV"  - 
		"SPIKE"  - 
		"SQZBOX" -
		"TSTRETCH" -
		"ROUGHEN" -
		"RANDSTEP" -
		"TEXTURE" {
			if [catch {file rename $segment(outfnamplay) $segment(ofnamw)} zit] {
				Inf "CANNOT RENAME THE OUTPUT WAV FILE, TO SAVE IT"
				unset segment(ofnama)
				unset segment(ofnamw)
				return 0
			}
			set segment(outfnamplay) $segment(ofnamw)
			FileToWkspace $segment(ofnamw) 0 0 0 0 1
			if {[file exists $segment(outfnam)]} {
				if [catch {file rename $segment(outfnam) $segment(ofnama)} zit] {
					Inf "CANNOT RENAME THE OUTPUT ANALYSIS FILE, TO SAVE IT"
					unset segment(ofnamw)
				}
				set segment(outfnam) $segment(ofnama)
				FileToWkspace $segment(ofnama) 0 0 0 0 1
			}
		}
		"REORDER" {
			if [catch {file rename $segment(outfnamplay) $segment(ofnamw)} zit] {
				Inf "CANNOT RENAME THE OUTPUT WAV FILE, TO SAVE IT"
				unset segment(ofnama)
				unset segment(ofnamw)
				return 0
			}
			set segment(outfnamplay) $segment(ofnamw)
			FileToWkspace $segment(ofnamw) 0 0 0 0 1
			if {[file exists $segment(outfnam)]} {
				if [catch {file rename $segment(outfnam) $segment(ofnama)} zit] {
					Inf "CANNOT RENAME THE OUTPUT ANALYSIS FILE, TO SAVE IT"
					unset segment(ofnamw)
				}
				set segment(outfnam) $segment(ofnama)
				FileToWkspace $segment(ofnama) 0 0 0 0 1
			}
			if {!$segment(disordered)} {
				set mnemonics_fnam [file rootname [file tail $segment(ofnamw)]]
				if {$segment(phrase)} {
					append mnemonics_fnam "_phrs"
				} else {
					append mnemonics_fnam "_text"
				}
				set mnemonics_fnam [file join $segment(dirname) $mnemonics_fnam$evv(TEXT_EXT)]
				if [catch {open $mnemonics_fnam "w"} zit] {
					Inf "CANNOT OPEN FILE $mnemonics_fnam TO SAVE REORDERED TEXT-MNEMONICS DATA"
				} else {
					set n 0
					while {$n < $segment(reordercnt)} {
						puts $zit $segment(rtext$n)
						incr n
					}
					close $zit
				}
				if {![DoSegmentDurParse $segment(outfnamplay)]} {
					Inf "FAILED TO FIND DURATION OF REORDERED OUTPUT SOUND : CANNOT SAVE NEW SEGMENT_TIMING DATA"
				} else {
					set wavdur $segment(itemdur)						;#is_head					OR	is_head
					set time 0.0										;#	   0	   1   0		OR			1	0		1	0
					lappend times $time									;#							OR
					set is_head 1										;#|	_H_|	   |_H_|		OR	| __T__	|	| __T__ |   | __T__
					if {$segment(headfirst)} {							;#|/   |\__T__/|   |\__ETC	OR	|/	   \|_H_|/     \|_H_|/	   
						set is_head 0									;#|	   |/	  \|   |/	  	OR	|	   /|	|\     /|   |\
					}													;#|	   |	   |   |		OR	|	   	|   |       |   |	
					foreach line [lrange $segment(mixlines) 1 end] {	;#0   Tail	   |  Tail		OR	0		|  Tail		|  Tail
						set time [lindex $line 1]						;#|	  start	   |  start		OR	|		|  start	|   ETC
						if {$is_head} {									;#|	  in mix   |  in mix	OR	|		|  in mix	|
							set time [expr $time + $segment(SPLICE)]	;#|	   |	   |   |		OR	|		|	|		|
						}												;#|	   |	   |   |		OR	|		|	|		|
						set is_head [expr !$is_head]					;#			 Head			OR		   Head  	   Head
						lappend times $time								;#		 start-in-mix		OR	   start-in-mix start-in-mix
					}													;#		  +splicelen		OR	    +splicelen	 +splicelen
					lappend times [expr $wavdur + 10.0]
					set rsegs_fnam [file rootname [file tail $segment(ofnamw)]]
					append rsegs_fnam "_rsegs"
					set rsegs_fnam [file join $segment(dirname) $rsegs_fnam$evv(TEXT_EXT)]
					if [catch {open $rsegs_fnam "w"} zit] {
						Inf "CANNOT OPEN FILE $rsegs_fnam TO SAVE SEGMENT_TIMING DATA FOR REORDERED FILE"
					} else {
						foreach time $times {
							puts $zit $time
						}
						close $zit
					}
				}
			}
		}
		default {
			Inf "SOUNDS FROM PROCESS \"$segment(process)\" NOT YET INCLUDED IN TrofsegsSaveSound"
		}
	}
	set segment(returnkeystate) R_INACTIVE
	ResetGetSyllabTrofs SOUND_IS_SAVED
	set segment(recycle_savedfile) [file rootname $segment(ofnamw)]
	.gettrofs.00.rc config -text "Recycle output file" -bd 2 -command "set pr_gettrofs RECYCLE" -state normal
	.gettrofs.00.ps config -text "Purge Data" -bd 2 -command "set pr_gettrofs PURGE" -state normal
	return 1
}

########################################
# FUNCTIONS RELATED TO TIME STRETCHING #
########################################

#--- Run Timestretch process

proc SegTimestretch {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	if {$segment(phrase)} {
		foreach dud $segment(multido) {
			if {[lindex $dud 0] == $segment(process)} {
				set actionlist [lindex $dud 1]
				break
			}
		}
	}
	if {$segment(phrase) && ($segment(process) != "ZIGZAG")} {
		set n 1
		while {$n <= $segment(cnt)} {
			if {[lindex $actionlist $n]} {
				lappend infnams $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
				lappend intrfs1 $evv(DFLT_OUTNAME)HH$n$evv(ANALFILE_EXT)
				lappend intrfs2 $evv(MACH_OUTFNAME)PH$n$evv(ANALFILE_EXT)
				lappend outfnams $evv(MACH_OUTFNAME)PH$n$evv(SNDFILE_EXT)
				lappend ns $n
			}
			incr n
		}
		set OK 1
		Block "PLEASE WAIT:        TIME-STRETCHING SEGMENT $n"
		foreach infnam $infnams intrf1 $intrfs1 intrf2 $intrfs2 outfnam $outfnams n $ns {
			switch -- $segment(process) {
				"TIMESTRETCH" {
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $infnam $intrf1
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        EXTRACTING SPECTRUM OF SEGMENT $n"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO EXTRACT SPECTRUM OF SEGMENT $n"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE SPECTRUM OF SEGMENT $n"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $intrf1]} {
						Inf "NO SPECTRUM OF SEGMENT $n CREATED"
						set OK 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) stretch]
					lappend cmd time 1 $intrf1 $intrf2 $segment(controlfil)
					set zoutfnam $intrf2
				}
				"ZIGZAG" {
					set cmd [file join $evv(CDPROGRAM_DIR) extend]
					lappend cmd zigzag 2 $infnam $outfnam $segment(controlfil)
					set zoutfnam $outfnam
				}
				default {
					Inf "PROCESS $segment(process) TRYING TO RUN SegTimestretch"
					return 0
				}
			}
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        TIME-STRETCHING SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN TIME-STRETCHING PROCESS"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE TIMESTRETCHED SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $zoutfnam]} {
				Inf "NO TIMESTRETCHED SEGMENT $n CREATED"
				set OK 0
				break
			}
			if {$segment(process) == "TIMESTRETCH"} {
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd synth $intrf2 $outfnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CONVERTING TIMESTRETCHED SPECTRUM OF SEGMENT $n TO SOUND"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO CONVERT TIMESTRETCHED SPECTRUM OF SEGMENT $n TO SOUND"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE SOUND FROM TIMESTRETCHED SPECTRUM OF SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $outfnam]} {
					Inf "NO TIMESTRETCHED SOUND FROM SEGMENT $n CREATED"
					set OK 0
					break
				}
			}
			PhraseLineReinsert $n $outfnam 0

		}
		if {!$OK} {
			UnBlock
			return 0
		}
	} else {
		switch -- $segment(process) {
			"TIMESTRETCH" {
				set cmd [file join $evv(CDPROGRAM_DIR) stretch]
				lappend cmd time 1 $segment(infnam) $segment(outfnam) $segment(controlfil)
				set outfile $segment(outfnam)
			}
			"ZIGZAG" {
				set cmd [file join $evv(CDPROGRAM_DIR) extend]
				if {$segment(phrase)} {
					if {[file exists $segment(othersnd)]} {
						if [catch {file delete $segment(othersnd)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd)"
							UnBlock
							return 0
						}
					}
					lappend cmd zigzag 2 $segment(src,0) $segment(othersnd) $segment(controlfil)
					set outfile $segment(othersnd)
				} else {
					lappend cmd zigzag 2 $segment(src,0) $segment(outfnamplay) $segment(controlfil)
					set outfile $segment(outfnamplay)
				}
			}
			default {
				Inf "PROCESS $segment(process) TRYING TO RUN SegTimestretch"
				return 0
			}
		}
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		Block "PLEASE WAIT:        TIME-STRETCHING [file rootname [file tail $segment(infnam)]]"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN TIME-STRETCHING PROCESS"
			catch {unset CDPidrun}
			UnBlock
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE TIMESTRETCHED FILE"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			UnBlock
			return 0
		}
		if {![file exists $outfile]} {
			Inf "NO TIMESTRETCHED FILE CREATED"
			UnBlock
			return 0
		}
		if {$segment(phrase) && ($segment(process) == "ZIGZAG")} {		;#	In this case we have zigzagged the srcfile -> otherfile
			if {![SegmentOutsound_andRewriteMix $actionlist 1]} {		;#	Block is already on, flagged by 1
				UnBlock
				return 0
			}
		}
	}
	UnBlock
	return 1
}

#--- Recycle output file (and the control-data which made it, if a timestretching process)

proc RecycleGetTrofOutput {} {
	global segment wstk ch chcnt evv pa
	if {![info exists segment(ofnama)] || ![file exists $segment(ofnama)]} {
		Inf "OUPUT FILE MUST BE SAVED (WITH A NAME) BEFORE IT CAN BE RECYCLED"
		return 0
	}
	if {![info exists segment(ofnamw)] || ![file exists $segment(ofnamw)]} {
		Inf "OUPUT FILE MUST BE SAVED (WITH A NAME) BEFORE IT CAN BE RECYCLED"
		return 0
	}
	set controlrecycle 0
	switch -- $segment(process) {
		TIMESTRETCH -
		ITERATE -
		ZIGZAG {
			set controlrecycle 1
		}
		default {
			set controlrecycle 0
		}
	}
	if {$controlrecycle} {
		if {!$segment(csaved)} {
			set msg "CONTROL DATA NOT SAVED: CANNOT RECYCLE IT: CONTINUE RECYCLING SOUND ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return 0
			} else {
				catch {file delete $segment(recycfil)}
			}
		} elseif {![GenerateTrofSegNucontrol]} {
			set msg "CONTINUE RECYCLING SOUND ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return 0
			}
		}
	}
	DoChoiceBak
	RemoveFromChosenlist $segment(infnam)
	lappend chlist $segment(ofnama)
	$ch insert end $segment(ofnama)
	incr chcnt

	set segment(infnam) $segment(ofnama)
	set segment(frametime) $pa($segment(infnam),$evv(FRAMETIME))

	set segment(src,0) $segment(ofnamw)

	set segment(chans)  $pa($segment(src,0),$evv(CHANS))
	set segment(insams) $pa($segment(src,0),$evv(INSAMS))
	set segment(srate)  $pa($segment(src,0),$evv(SRATE))
	set segment(dur)    $pa($segment(src,0),$evv(DUR))

	set segment(dflt_fnam) [file rootname $segment(infnam)]
	append segment(dflt_fnam) "_segs"
	set segment(dflt_rfnam) [file rootname $segment(infnam)]
	append segment(dflt_rfnam) "_rsegs"
	set segment(dflt_cfnam) [file rootname $segment(infnam)]
	append segment(dflt_cfnam) "_csegs"
	.gettrofs.00.tit.tit config -text "Input File : [string toupper [file rootname [file tail $segment(infnam)]]]"
	return 1
}

#--- Generate a segmentation file for the recycled soundfile, from time-stretching controlfile

proc GenerateTrofSegNucontrol {} {
	global segment
	switch -- $segment(process) {
		"TIMESTRETCH" {
			if {![GenerateTrofSegNucontrolTimestretch]} {
				return 0
			}
		}
		"ITERATE" -
		"ZIGZAG" {
			if {![RecycleTimestretchedMarks]} {
				return 0
			}
		}
		default {
			Inf "Recycling not available for control-files from process $segment(process)"
			return 0
		}
	}
	return 1
}

#--- Generate a segmentation file for the recycled soundfile, from TIMESTRETCH controlfile

proc GenerateTrofSegNucontrolTimestretch {} {
	global segment evv 

	Inf "WARNING: THE STRETCHED CONTROLFILE DATA FROM THIS PROCESS IS NOT EVEN ROUGHLY ACCURATE!!"

	if {[file exists $segment(recycfil)]} {
		if [catch {file delete $segment(recycfil)} zit] {
			Inf "CANNOT DELETE EXISTING FILE $segment(recycfil): $zit"
			return 0
		}
	}
	set len [llength $segment(nucontrol)]
	set nutime 0.0
	catch {unset nutimes}
	lappend nutimes $nutime
	set total_nustep 0.0
	set lasttim [lindex [lindex $segment(nucontrol) 0] 0]
	set lastval [lindex [lindex $segment(nucontrol) 0] 1]
	set n 1
	while {$n < $len} {
		set thistim [lindex [lindex $segment(nucontrol) $n] 0]
		set thisval [lindex [lindex $segment(nucontrol) $n] 1]
		set timstep [expr $thistim - $lasttim]
		set valstep	[expr $thisval - $lastval]
		set valavrg [expr $lastval + ($valstep/2.0)]
		set nustep  [expr $valavrg * $timstep]
		set total_nustep [expr $total_nustep + $nustep]
		set savenutime 0
		switch -- $segment(shape) {
			"ASIS" -
			"FLAT" {
				set k [expr $n % 4]								;#  __H__			  __H__
				if {$segment(headfirst)} {						;#	0   1\		     /4	  5\ 			Heads at (0),1  4,5 etc
					if {($k == 0) || ($k == 1)} {				;#		  \%	   %/	    \%
						set savenutime 1						;#		   \2__T__3/		 \6__T__
					}											;#.........................................
				} else {										;#		    __H__		      __H__
					if {($k == 2) || ($k == 3)} {				;#		   /2   3\		     /6   7\	Heads at 2,3  6,7 etc
						set savenutime 1						;#		 %/	      \%	   %/		\%
					}											;# 0__T__1	       \4__T__5/		 \8__T__
				}												;#	"%" marks a transition between tail value and head val(1)
			}
			"LIN" -
			"TF" {												;#	"LIN"		
				set k [expr $n % 3]								;#
				if {$segment(headfirst)} {						;#  __H__		  __H__		   __H__
					if {($k == 0) || ($k == 1)} {				;#	0   1		 /3   4		  /6   7	Heads at (0),1  3,4 etc
						set savenutime 1						;#		|	   %/	  |		%/	   |
					}											;#		|__T__2/	  |__T__5	   |__T__
				} else {										;#.........................................
					if {($k == 2) || ($k == 0)} {				;#		    __H__	      __H__		   
						set savenutime 1						;#		   /2   3	     /5   6		  /	Heads at 2,3  5,6 etc
					}											;#		 %/	    |      %/	  |		%/
				}												;# 0__T__1	    |__T__4/	  |__T__7
			}
		}														;#	"TF"
		if {$savenutime} {										;#
			set nutime [expr $nutime + $total_nustep]			;#  __H__	M	__H__	M	__H__
			lappend nutimes $nutime								;#	0   1  /2\	3	4  /5\	6   7		Heads at (0),1  3,4 etc
			set total_nustep 0.0								;#		| /	  \ |	| /	  \	|	| /
		}														;#		|/	   \|	|/     \|	|/
		set lasttim $thistim 									;#.........................................
		set lastval $thisval 									;#     M   __H__   M   __H__
		incr n													;#	0 /1\  2   3  /4\  5   6			Heads at 2,3  5,6 etc
	}															;#   /   \ |   | /	 \ |   | /
	if {![info exists nutimes] || ([llength $nutimes] <= 0)} {	;#	/     \|   |/     \|   |/
		Inf "NO NEW SEGMENTATION DATA GENERATED"
		return 0
	}
	if [catch {open $segment(recycfil) "w"} zit] {
		Inf "CANNOT OPEN FILE $segment(recycfil) TO WRITE NEW SEGMENTATION DATA"
		return 0
	}
	foreach nutime $nutimes {
		puts $zit $nutime
	}
	close $zit
	return 1
}

#---- Warp control data for a zigzagged output

proc DoControlWarp_ZigZag {} {
	global segment
	catch {unset segment(nucontrol)}
	catch {unset segment(numarks)}
	set junk [expr srand($segment(PAR0))]
	set segment(zccnt) 0
	set segment(zlim) [expr [llength $segment(control1,$segment(process))] - 1]
	set len [llength $segment(marklist)]
	set ziglimit $segment(wavdur)
	set zag 0.0											;#	List of zigzags always starts at time zero
	lappend segment(nucontrol) $zag						;#	Count splices: 1st zig is not reduced by a splice
	set splicecnt 0										;#	but all subsequent zigs & zags reduced in len by a splice

	if {$segment(phrase)} {
		foreach dud $segment(multido) {
			if {[lindex $dud 0] == "ZIGZAG"} {			;#	Find the call to zigzag
				set actionlist [lindex $dud 1]			;#	Get the list of segments (counted from 1) which it is to be applied to
				break
			}
		}
		set k 1											;#	Search actionlist for first seg being zigzagged (segs are numbered from 1) 
		while {![lindex $actionlist $k]} {				;#	1st entry in actionlist is a dummy zero, so j = 1 = 1st segno in actionlist
			incr k										;#	Exits when "iterate" is active on segment
		}
		set j $k										;#	Marklist is searched from index 0, so incr j -1
		incr j -1
	} elseif {$segment(headfirst)} {
		set j 1											;#	Start zigging in tail,which is after start head, at mark 1
		set k 2
	} else {
		set j 0											;#	Start zigging in tail at start, at mark 0
		set k 1
	}
	while {$k < $len} {
														;#	0	1		  2   3			4
		set leftbase [lindex $segment(marklist) $j]		;#	|-H-|		  |-H-|			|
		set ritebase [lindex $segment(marklist) $k]		;#		|___T_____|	  |___T_____|
														;#		L		  R	
		if {$leftbase >= $ziglimit} {					;#									] |___T___]
			break										;#									]
		}												;#								  EOF
														;#
		if {$ritebase > $ziglimit} {					;#								 |__]_T__|
			set ritebase $ziglimit						;#									]
		}												;#								  EOF
														;#
		set zag 0.0										;#		L		  R	
		set bigspan [expr $ritebase - $leftbase]		;#		|-bigspan-| 
		set tstr [GetTstrFromControl $leftbase]			;#	   zag
		set outlengoal [expr $bigspan * $tstr]	
		set span $bigspan
		set outlen  0.0
		set remnant 0.0
		while {$outlen + $remnant < $outlengoal} {		;#	DO ZIG   Z = next zig		
														;#		L  zag		  |
														;#		|	|...span..|
			set zig [expr (rand() * $span) + $zag]		;#		|	|....Z    |	Zig created in space between last zag
			set ziglen [expr $zig - $zag]				;#		|	|         |	and right boundary
			while {($ziglen <= $segment(ZIGMIN))} {		;#		|	|-MIN--   |	If zig too short,
				set unspan [expr $bigspan - $zig]		;#		|	|	 unspan
				set offset [expr $zag + $ziglen]		;#		|-ofset--|	  |
				set zig    [expr (rand() * $unspan) + $offset]
														;#		|	z--zlen-Z |
				set ziglen [expr $zig - $zag]			;#		|	z-MIN--   | 
			}
			lappend segment(nucontrol) [expr $zig + $leftbase]	
			set outlen [expr $outlen + $ziglen]			;#						Add point to list of zigzags, and totalpup length of this expanded-tail
			if {$splicecnt} {							;#						allowing for len reduction cased by splice
				set outlen [expr $outlen - $segment(ZIGSPLICE)]
			}
			incr splicecnt								
			set remnant [expr $bigspan - $zig]			;#		|    -rem-|		If goallen achieved in this zig, we can proceed across next head
			if {$outlen + $remnant >= $outlengoal} {	;#		L----z	  |		so we'll overwite last zig point & go to next tail area 
				set segment(nucontrol) [lreplace $segment(nucontrol) end end]  ;# writing zig anew beyond end of next head	
				break
			}
			set span $zig								;#		|-zig--|  |
			set zag [expr rand() * $span]				;#		|   Z  z  |
			set zaglen [expr $zig - $zag]				;#		|   Z--z  |
			while {$zaglen <= $segment(ZIGMIN)} {		;#		|   -MIN--|		If zag too short,
				set zag    [expr (rand() * $zag)]		;#		| Z....z  |		force zagpoint left
				set zaglen [expr $zig - $zag]			;#		| -MIN--  |		
			}
			if {($leftbase == 0) && ([string first "e" $zag] >= 0)} {	;#	If too close to zero. make it zero
				set zag 0
			}
			lappend segment(nucontrol) [expr $zag + $leftbase]
			set outlen [expr $outlen + $zaglen]			;#						If goallen exceeded here, we'll automatically exit while-loop
			if {$splicecnt} {
				set outlen [expr $outlen - $segment(ZIGSPLICE)]
			}
			incr splicecnt													
			set span [expr $bigspan - $zag]					;#	|    |span|	remainder, area available for locating next zig
			set remnant [expr $span - $segment(ZIGSPLICE)]	;#	|-zag|	  |	THIS (-splicelen) is also what's available
															;#  |    |rem | in next zig to add to total outlen :
		}													;#				(used to test if next zig will automatically breach required outlen)
		if {$segment(phrase)} {
			incr j
			incr k
			if {$k >= $len} {
				break
			}
			while {![lindex $actionlist $k]} {				;#	Find next segment to zigzag
				incr k
				if {$k >= $len} {
					break
				}
				incr j
			}
		} else {
			incr j 2
			incr k 2
		}
	}
	set lasttime [lindex $segment(nucontrol) end]
	while {$lasttime >= $segment(dur)} {				;#	Remove any times at or beyond duration of src
		set segment(nucontrol) [lreplace $segment(nucontrol) end end]
		set lasttime [lindex $segment(nucontrol) end]
	}													;#	Then add a time beyond end of source	
	lappend segment(nucontrol) [expr $segment(dur) + 10.0]

	if [catch {open $segment(controlfil) "w"} zit] {
		Inf "CANNOT OPEN FILE $segment(controlfil) TO WRITE THE MODIFIED CONTROL DATA"
		return 0
	}
	foreach val $segment(nucontrol) {
		puts $zit $val
	}
	close $zit

	;#	CALCULATE POSITION OF MARKS IN OUTPUT FILE

	if {$segment(phrase) || $segment(headfirst)} {
		set j 0
		set k 1
	} else {
		set j 1
		set k 2
	}
	set marks $segment(marklist)
	set segment(numarks) 0.0
	set lasthead [lindex $marks $j]										;#	Note start times of current and next segments in original marks
	set nexthead [lindex $marks $k]
	set len [llength $marks]
	set lastval 0
	set totallen 0.0
	set cnt 1
	foreach val [lrange $segment(nucontrol) 1 end] {					;#	Looking through the zigzag times
		set thislen [expr $val - $lastval]								;#	Get length of next zigzag
		if {$thislen < 0.0} {											;#	(If it's a zag, it will move bkwds in time, so take -ve to get duration)
			set thislen [expr -$thislen]
		}
		if {$cnt > 1} {													;#	After 1st zig, zigs and zags overlap by splicelen
			set thislen [expr $thislen - $segment(ZIGSPLICE)]			;#	so ammount to add to total zigging duration (totallen) is reduced by splicelen
		}
		set totallen [expr $totallen + $thislen]
		if {$val > $nexthead} {											;#	If the zig time oversteps the next head, we have finished zigging in current segment.
			set headstt [expr $val - $nexthead]							;#	Chech how far the last zig has stepped beyond the surent segment end.
			set headstt [expr $totallen - $headstt]						;#	The new position of the next-segment is the totallen so far MINUS this overstep.
			lappend segment(numarks) $headstt							;#	Add this new time to the new marks.
			if {$segment(phrase)} {										
				incr j
				incr k													;#	Proceed to next phrase (phrases).
			} else {
				incr j 2												;#	OR proceed to next tail (Head/Tail procedure).
				incr k 2
			}
			if {$k >= $len} {
				break
			}
			set lasthead $nexthead
			set nexthead [lindex $marks $k]
		}
		set lastval $val
		incr cnt
	}
	set penult [expr $len - 2]											;#	Add the after-end-of-sound mark to end of new marklist
	set endval [expr [lindex $marks end] - [lindex $marks $penult]]
	set endval [expr [lindex $segment(numarks) end] + $endval]
	lappend segment(numarks) $endval
	return 1
}
	
#--- Interp in original brkpnt control file to find required tstretch

proc GetTstrFromControl {tim} {
	global segment
	if {[IsTimestretchProcess $segment(process)]} {
		set vnam segment(control1,$segment(process))
	} else {
		Inf "ERROR: GetTstrFromControl SHOULD NOT BE CALLED"
	}
	upvar $vnam control
	if {$segment(zccnt) >= $segment(zlim)} {
		set val [lindex [lindex $control end] 1]
		return $val
	}
	set k $segment(zccnt)
	set lasttim [lindex [lindex $control $k] 0]
	set lastval [lindex [lindex $control $k] 1]
	incr k
	set thistim [lindex [lindex $control $k] 0]
	set thisval [lindex [lindex $control $k] 1]

	while {$tim > $thistim} {
		incr segment(zccnt)
		if {$segment(zccnt) >= $segment(zlim)} {
			set val [lindex [lindex $control end] 1]
			return $val
		}
		set k $segment(zccnt)
		set lasttim [lindex [lindex $control $k] 0]
		set lastval [lindex [lindex $control $k] 1]
		incr k
		set thistim [lindex [lindex $control $k] 0]
		set thisval [lindex [lindex $control $k] 1]
	}

	set timdiff [expr $thistim - $lasttim]
	set valdiff [expr $thisval - $lastval]
	
	set timefrac [expr ($tim - $lasttim)/$timdiff]
	set val [expr ($valdiff * $timefrac) + $lastval]
	return $val
}

#--- Interp in original brkpnt control file to find required tstretch

proc GetParamValueFromControl {tim paramno} {
	global segment
	if {$segment(zccnt,$paramno) >= $segment(zlim,$paramno)} {
		set val [lindex [lindex $segment(control$paramno,$segment(process)) end] 1]
		return $val
	}
	set k $segment(zccnt,$paramno)
	set lasttim [lindex [lindex $segment(control$paramno,$segment(process)) $k] 0]
	set lastval [lindex [lindex $segment(control$paramno,$segment(process)) $k] 1]
	incr k
	set thistim [lindex [lindex $segment(control$paramno,$segment(process)) $k] 0]
	set thisval [lindex [lindex $segment(control$paramno,$segment(process)) $k] 1]

	while {$tim > $thistim} {
		incr segment(zccnt,$paramno)
		if {$segment(zccnt,$paramno) >= $segment(zlim,$paramno)} {
			set val [lindex [lindex $segment(control$paramno,$segment(process)) end] 1]
			return $val
		}
		set k $segment(zccnt,$paramno)
		set lasttim [lindex [lindex $segment(control$paramno,$segment(process)) $k] 0]
		set lastval [lindex [lindex $segment(control$paramno,$segment(process)) $k] 1]
		incr k
		set thistim [lindex [lindex $segment(control$paramno,$segment(process)) $k] 0]
		set thisval [lindex [lindex $segment(control$paramno,$segment(process)) $k] 1]
	}

	set timdiff [expr $thistim - $lasttim]
	set valdiff [expr $thisval - $lastval]
	
	set timefrac [expr ($tim - $lasttim)/$timdiff]
	set val [expr ($valdiff * $timefrac) + $lastval]
	return $val
}

#--- Recycle new markers for a time-extended by Zigzag sound

proc RecycleTimestretchedMarks {} {
	global segment
	if {![info exists segment(numarks)]} {
		Inf "NO NEW SEGMENTATION DATA EXISTS"
		return 0
	}
	if {[file exists $segment(recycfil)]} {
		if [catch {file delete $segment(recycfil)} zit] {
			Inf "CANNOT DELETE EXISTING FILE $segment(recycfil): $zit"
			return 0
		}
	}
	if [catch {open $segment(recycfil) "w"} zit] {
		Inf "CANNOT OPEN FILE $segment(recycfil) TO WRITE NEW SEGMENTATION DATA"
		return 0
	}
	foreach nutime $segment(numarks) {
		puts $zit $nutime
	}
	close $zit
	return 1
}

###########
# ITERATE #
###########

#--- Timestretch a sound by iterating tail segments

proc IterateTimestretch {} {

	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	set density [expr -$segment(PAR0)]		;#	convert density from d -> -d
	set density [expr pow(10.0,$density)]	;#	-> 10^-d

	set atten   $segment(PAR2)
	set endgain [expr $segment(PAR3) * $atten]
	set fadexp  $segment(PAR4)

	set cn 0								;#	Index in nucontrol, a list of time-stretches to apply
	set mm 0								;#	Index in new marks (gives times in mixfile)
	if {$segment(phrase)} {
		set n 1								;#	PHRASE First
		set j 0
		set k 1
		set hcnt 1
		set tcnt 1
	} elseif {$segment(headfirst)} {
		set n 2								;#	Index for first segment to stretch is 2 (segments count from 1)
		set j 1								;#	Indices for start and end times of segment, in marklist
		set k 2
		set hfnam [file join $evv(DFLT_OUTNAME)HH1$evv(SNDFILE_EXT)]
		set line [list $hfnam [lindex $segment(numarks) $mm] 1 1.0]
		lappend mixlines $line				;#	Start mix with the unaltered HEAD segment = 1st segment
		incr mm								;#	Index for mixfile time, in numarks
		set hcnt 2							;#	Count of HEAD files
		set tcnt 1							;#	Count of TAIL files
	} else {
		set n 1								;#	TAIL First, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
		set hcnt 1
		set tcnt 1
	}
											;#	Extended final val in marklist, replaced by true end of file
	
	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	if {![MultipleProcessing]} {
		ClearNoexpands
	}
	;#	ITERATING tails (ALTERNATE SEGMENTS)

	set OK 1
	Block "PLEASE WAIT:        ITERATING TAIL-SEGMENTS"
	while {$n <= $segment(cnt)} {
		if {$segment(phrase)} {
			set doit 0
			foreach dud $segment(multido) {
				if {[lindex $dud 0] == "ITERATE"} {
					set actionlist [lindex $dud 1]
					if {[lindex $actionlist $n]} {
						set doit 1
						set ifnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
						set ofnam $evv(MACH_OUTFNAME)PH$hcnt$evv(SNDFILE_EXT)
						break
					}
				}
			}
			if {!$doit} {
				incr n
				incr j
				incr k
				incr hcnt
				incr cn
				continue
			}
		} else {
			if {$segment(reordered)} {
				set ifnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
				set ofnam $evv(MACH_OUTFNAME)PT$tcnt$evv(SNDFILE_EXT)
			} else {
				set ifnam $evv(MACH_OUTFNAME)TT$tcnt$evv(SNDFILE_EXT)
				set ofnam $evv(MACH_OUTFNAME)PT$tcnt$evv(SNDFILE_EXT)
			}
		}
		incr tcnt
		set dur [expr [lindex $marks $k] - [lindex $marks $j]]	;#	Original segment duration
		set dur [expr $dur * [lindex $segment(nucontrol) $cn]]	;#	Stretched duration

		wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SEGMENT $n"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $ifnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR SEGMENT $n"
			set OK 0 
			break
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF SEGMENT $n"
			set OK 0
			break
		}
		set prelevel [lindex $maxsamp_line 0]
		if {$prelevel <= 0} {
			Inf "SEGMENT $n HAS ZERO LEVEL"
			set OK 0
			break
		}

		;#	ITERATE THE TAIL TO (AT LEAST) REQUIRED LENGTH

		set cmd [file join $evv(CDPROGRAM_DIR) extend]												;#	Density (determines delay), pspread & seed from interface
		lappend cmd iterate 1 $ifnam $ofnam $dur -d$density -p$segment(PAR1) -s$segment(PAR5) -r1	;#	Randomisation of delay defaults to 1
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        ITERATING SEGMENT $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN ITERATION PROCESS FOR SEGMENT $n"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE ITERATED SEGMENT $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "NO ITERATED SEGMENT $n CREATED"
			set OK 0
			break
		}

		if [catch {file delete $ifnam} zit] {
			Inf "CANNOT DELETE INTERMEDIATE INPUT FILE $ifnam"
			set OK 0
			break
		}
	
		;#	DO LOPASS FILTER

		set cmd [file join $evv(CDPROGRAM_DIR) filter]
		lappend cmd lohi 1 $ofnam $ifnam -96 80 50 -t0 -s1
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        LOPASS FILTERING SEGMENT $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO LOPASS FILTER SEGMENT $n"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE LOPASS FILTERED SEGMENT $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ifnam]} {
			Inf "NO LOPASS FILTERED SEGMENT $n CREATED"
			set OK 0
			break
		}
		if [catch {file delete $ofnam} zit] {
			Inf "CANNOT DELETE INTERMEDIATE INPUT FILE $ofnam"
			set OK 0
			break
		}
	
		if [catch {file rename $ifnam $ofnam} zit] {
			Inf "CANNOT RENAME INTERMEDIATE INPUT FILE $ifnam"
			set OK 0
			break
		}

		;#	CUT TO EXACT SIZE
		
		set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
		lappend cmd cut 1 $ofnam $ifnam 0.0 $dur -w0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CUTTING SEGMENT $n TO EXACT SIZE"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN EXACT-SIZE-CUT PROCESS FOR SEGMENT $n"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE EXACT SIZED SEGMENT $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ifnam]} {
			Inf "NO EXACT SIZED SEGMENT $n CREATED"
			set OK 0
			break
		}
		if [catch {file delete $ofnam} zit] {
			Inf "CANNOT DELETE INTERMEDIATE OUTPUT FILE $ofnam"
			set OK 0
			break
		}

		;#	DOVETAIL TAIL SEGMENT

		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd dovetail 1 $ifnam $ofnam $segment(SPLICE) $segment(SPLICE) 0 0 -t0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        DOVETAILING SEGMENT $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO DOVETAIL SEGMENT $n"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE DOVETAILED SEGMENT $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "NO EXACT DOVETAILED SEGMENT $n CREATED"
			set OK 0
			break
		}

		;#	DO FADE

		if {$atten < 1.0} {	
			catch {unset env}
			if {$fadexp > 1.0} {							;#				1.0  0.3   		raised	
				set line [list 0.0 1.0]						;#				  0.6  0.0		to pow		*diff		+endgain
				lappend env $line							;# _____ 1		 _______		______					______
				set diff [expr 1.0 - $endgain]				;#  |			 x				x			______		x
				set val [expr pow(0.6666,$fadexp)]			;#	|			 x  		    x			x
				set val [expr $val * $diff]					;#	|			   x  			  	  
				set val [expr $val + $endgain]				;# diff			   x              x			 			 x    
				set line [list [expr $dur * 0.3333] $val]	;#	|				 x			  x			 x
				lappend env $line							;#	|				 x				x					   x  
				set val [expr pow(0.3333,$fadexp)]			;# _|___endgain		   x			x x		   x 		_____x
				set val [expr $val * $diff]					;# _____ 0		_______x		______x		_____x		______
				set val [expr $val + $endgain]				;#
				set line [list [expr $dur * 0.6666] $val]
				lappend env $line
				set line [list $dur $endgain]
				lappend env $line
			} else {
				set line [list 0.0 1.0]
				lappend env $line
				set line [list $dur $endgain]
				lappend env $line
			}
			if [catch {open $segment(envfil) "w"} zit] {
				Inf "CANNOT OPEN ENVELOPE FILE TO CREATE FADE"
				set OK 0
				break
			}
			foreach line $env {
				puts $zit $line
			}
			close $zit

			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $ofnam $segment(fadesnd) $segment(envfil) 

			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        FADING SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN FADE OF SEGMENT $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE FADING SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $segment(fadesnd)]} {
				Inf "NO FADING SEGMENT $n CREATED"
				set OK 0
				break
			}
			if [catch {file delete $ofnam} zit] {
				Inf "CANNOT DELETE PRE-FADED SEGMENT $n"
				set OK 0
				break
			}
			if [catch {file rename $segment(fadesnd) $ofnam} zit] {
				Inf "CANNOT RENAME FADED SEGMENT $n"
				set OK 0
				break
			}
		}

		;#	FIND LEVEL, TO NORMALISE  IT BY SETTING APPROPRIATE LEVEL IN MIXFILE

		wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF ITERATED-SEGMENT $n"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $ofnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR ITERATED-SEGMENT $n"
			set OK 0 
			break
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF ITERATED-SEGMENT $n"
			set OK 0
			break
		}
		set postlevel [lindex $maxsamp_line 0]
		if {$postlevel <= 0.0} {
			Inf "ITERATED-SEGMENT $n HAS ZERO LEVEL"
			set OK 0
			break
		}

		if {$postlevel > $prelevel} {
			set levratio [expr $postlevel/$prelevel]
		} else {
			set levratio [expr $prelevel/$postlevel]
		}
		if {$levratio > $segment(LEVSHIFT)} {
			set gain [expr $prelevel/$postlevel]
		} else {
			set gain 1.0
		}
		set gain [expr $gain * $atten]
		set line [list $ofnam [lindex $segment(numarks) $mm] 1 $gain]

		if {$segment(phrase)} {
			PhraseLineReinsert $n $line 1
			incr n 1									;#	Skip to next (iterable) tail
			incr j 1									;#	and next strt and end markers (times) of segments	
			incr k 1
			incr hcnt									;#	Phrases are all numbered as heads
			incr cn	 									;#	and next value of iteration-output-stretch
			continue
		}
		lappend mixlines $line
		incr mm
		set hfnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
		incr hcnt		
		if {[file exists $hfnam]} {					;#	;#	If there's a following HEAD
			set mixtime [expr [lindex $segment(numarks) $mm] - $segment(SPLICE)]
			set line [list $hfnam $mixtime 1 1.0]	;#	Add it to mix
			lappend mixlines $line
			incr mm
		}
		incr n 2									;#	Skip to next (iterable) tail
		incr j 2									;#	and next strt and end markers (times) of segments	
		incr k 2
		incr cn										;#	and next value of iteration-output-stretch
	}
	if {!$OK} {
		UnBlock
		return 0
	}
## UNREACHABLE
#	if {$segment(reordered)} {
#		set len [llength $segment(mixlines)]
#		set n 0
#		while {$n < $len} {
#			set inline [lindex $segment(mixlines) $n]
#			set nuline [lindex $mixlines $n]
#			set retime [lindex $inline 1]
#			set nuline [lreplace $nuline 1 1 $retime]
#			set segment(mixlines) [lreplace $segment(mixlines) $n $n $nuline]
#			incr n
#		}
#		set mixlines $segment(mixlines)
#	}
	if {!$segment(phrase)} {		
		set segment(mixlines) $mixlines
		if {$segment(expand) && !$segment(noexpand)} {
			if {![ExpandPhraseMix 1]} {
				Inf "CANNOT EXPAND THE SEGMENT STRING IN LINE WITH THE TIMESTRETCHING"
			}
		}
		DoMultichanCorrection
		if [catch {open $segment(mixfil) "w"} zit] {
			Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
			UnBlock
			return 0
		}
		foreach line $segment(mixlines) {
			puts $zit $line
		}
		close $zit
		if {![GettrofMixdown 1]} {
			UnBlock
			return 0
		}
		set segment(reordered) 0
	}
	UnBlock
	return 1
}

#--- Generate a list of tstretch values from input info
#--- Also calculate output positions of head markers, which is ALSO info for final MIX file!!!

proc DoControlWarp_Iterate {} {
	global segment
	catch {unset segment(nucontrol)}
	catch {unset segment(numarks)}
	set junk [expr srand($segment(PAR5))]				;#	Seed random variable
	set len [llength $segment(marklist)]
	set segment(zccnt) 0
	set segment(zlim) [expr [llength $segment(control1,$segment(process))] - 1]
	set ziglimit $segment(wavdur)

	if {$segment(phrase)} {
		set j 0											;#	Start iteration 1st segment(phrase) at mark 0
		set k 1
	} elseif {$segment(headfirst)} {
		set j 1											;#	Start iteration in tail,which is after start head, at mark 1
		set k 2
	} else {
		set j 0											;#	Start iteration in tail at start, at mark 0
		set k 1
	}
	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	while {$k < $len} {		
		set leftbase [lindex $marks $j]
		set ritebase [lindex $marks $k]
		if {$leftbase >= $ziglimit} {
			break
		}
		if {$ritebase > $ziglimit} {
			set ritebase $ziglimit
		}
		set tstr [GetTstrFromControl $leftbase]
		lappend segment(nucontrol) $tstr				;#	segment(nucotrol) is a list of the time-stretches to be used
		if {$segment(phrase)} {
			incr j 1
			incr k 1
		} else {
			incr j 2
			incr k 2
		}
	}

	if [catch {open $segment(controlfil) "w"} zit] {
		Inf "CANNOT OPEN FILE $segment(controlfil) TO WRITE THE MODIFIED CONTROL DATA"
		return 0
	}
	foreach val $segment(nucontrol) {
		puts $zit $val
	}
	close $zit

	set nc 0	;#	Count in nucontrol data, which are succesive vals of timestretch of tails (or phrases)
	set j 0		;#	Counts in original segment markers
	set k 1
	set istail 1
	if {$segment(headfirst)} {
		set istail 0
	}
	set totallen 0.0
	set oldmarks [lreplace $marks end end]	;#	Ensure final mark is at end of file
	set oldmarks [linsert $oldmarks end $segment(wavdur)]

	lappend segment(numarks) 0.0
	while {$k < $len} {
		set seglen [expr [lindex $oldmarks $k] - [lindex $oldmarks $j]]
		if {$segment(phrase) || $istail} {
			set seglen [expr $seglen * [lindex $segment(nucontrol) $nc]]
			incr nc							;#	Control values exist for ALL segments-as-phrases
		}									;#	but only Tails of segments as Heads+Tails.
		set totallen [expr $totallen + $seglen]
		lappend segment(numarks) $totallen
		set istail [expr !($istail)]
		incr j
		incr k
	}
	return 1
}

#####################
# HANDLE PARAMETERS #
#####################

#--- Enter a fixed value for a parameter (which could have been time-variable)

proc EnterFixedValue {} {
	global segment wstk
	set segment(fixed) [.gettrofs.12.fxv get]
	if {[IsTimestretchProcess $segment(process)]} {
		set segment(fixed) [string trim $segment(fixed)]
		if {([string length $segment(fixed)] <= 0) || ![IsNumeric $segment(fixed)] || ($segment(fixed) < $segment(MINTSTR)) || ($segment(fixed) >  $segment(MAXTSTR))} {
			Inf "INVALID FIXED VALUE (Range $segment(MINTSTR) to $segment(MAXTSTR))"
			return 0
		}
	} else {
		if {[NonImplementedProcess $segment(process)]} {
			set msg "NB NB **** CODE FOR \"EnterFixedValue\" FOR PROCESS $segment(process) NOT WRITTEN YET\n"
			append msg "\nDOES PROCESS HAVE MORE THAN 1 POSSIBLY-VARIABLE PARAM????\n"
			append msg "\nIF NOT, USE THE \"IsTimestretchProcess\" STYLE ABOVE, AND NOT the \"!IsTimestretchProcess\""
			Inf $msg
			return 0
		}
		set segment(fixed) [string trim $segment(fixed)]
		if {([string length $segment(fixed)] <= 0) || ![IsNumeric $segment(fixed)]} {
			Inf "INVALID FIXED VALUE"
			return 0
		}
		if {($segment(fixed) < $segment(lo$segment(vp))) || ($segment(fixed) >  $segment(hi$segment(vp)))} {
			Inf "INVALID FIXED VALUE (Range $segment(lo$segment(vp)) to $segment(hi$segment(vp)))"
			return 0
		}
	}
	if {[IsTimestretchProcess $segment(process)]} {
		set segment(control1,$segment(process)) {}
		set line [list 0.0 $segment(fixed)]
		lappend segment(control1,$segment(process)) $line
		set line [list $segment(dur) $segment(fixed)]
		lappend segment(control1,$segment(process)) $line
		DoControlWarp 0
		ResetGetSyllabTrofs HIDE_FIXEDVAL_ENTRY
		set segment(returnkeystate) R_SAVE_CONTROL_DATA
 		ResetGetSyllabTrofs MADE_CONTROL_DATA_GOTO_SAVE_DECISION
	} else {
		set segment(control$segment(vp),$segment(process)) {}
		set line [list 0.0 $segment(fixed)]
		lappend segment(control$segment(vp),$segment(process)) $line
		set line [list $segment(dur) $segment(fixed)]
		lappend segment(control$segment(vp),$segment(process)) $line
		ResetGetSyllabTrofs HIDE_FIXEDVAL_ENTRY
		if {$segment(vp) < $segment(vparams_cnt,$segment(process))} {
			incr segment(vp)
			while {[ExcludedParameter]} {
				incr segment(vp)
				if {$segment(vp) > $segment(vparams_cnt,$segment(process))} {
					set segment(returnkeystate) R_RUN
					ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
					return 1
				}
			}
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
		} else {
			set segment(returnkeystate) R_RUN
			ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
		}
	}
	return 1
}

#--- Parameters which are NOT used, or have fixed values, not alterable by user, are skipped over, or preset, here

proc ExcludedParameter {} {
	global segment

	if {$segment(vp) > $segment(vparams_cnt,$segment(process))} {		;#	No more params
		return 0
	}
	switch -- $segment(process) {
		TEXTURE {
			if {($segment(vp) == 7) || ($segment(vp) == 8)} {		;#	IF spatial position or spread params
				if {$segment(PAR0) == 1} {							;#	and MONO texture
					set segment(control$segment(vp),TEXTURE) {}
					set line [list 0.0 0]							;#	Spatial position is fixed at 0 (left chan only)	
					lappend segment(control$segment(vp),TEXTURE) $line
					set line [list $segment(dur) 0]					;#	Spatial spread is fixed at 0
					lappend segment(control$segment(vp),TEXTURE) $line
					return 1
				}
			}
		}
	}
	return 0
}

#--- Hide parameter entry boxes on interface

proc HideFixedParamEntryBoxes {} { 
	global segment
	set n 0
	while {$n < $segment(MAXPARAMS)} {
		if {$segment(init)} {
			set segment(init) 0
		} else {
			if {[string length [$segment(label$n) cget -text]] > 0} {
				set segment(PAR$n) $segment(par$n)
			}
		}
		set segment(par$n) ""
		$segment(label$n) config -text ""
		$segment(entry$n) config -state disabled -bd 0 -disabledbackground [option get . background {}]
		incr n
	}
	set segment(doentry) 0
	set segment(dodflts) 0
	set segment(doplast) 0
	set segment(doclear) 0
	set segment(dopload) 0
	$segment(doentrybox) config -text "" -command {} -state disabled -disabledforeground []
	$segment(dodefaults) config -text "" -command {} -state disabled -disabledforeground []
	$segment(doprevious) config -text "" -command {} -state disabled -disabledforeground []
	$segment(doclearing) config -text "" -command {} -state disabled -disabledforeground []
	$segment(paramshelp) config -text "" -command {} -state disabled -bd 0 -bg [option get . background {}]
	$segment(paramsload) config -text "" -command {} -state disabled -disabledforeground []
}

#--- Check validity of entered params

proc CheckSegParamsAndEstablishVparamNames {} {
	global segment
	catch {set segment(par0) [string trim $segment(par0)]}
	catch {set segment(par1) [string trim $segment(par1)]}
	catch {set segment(par2) [string trim $segment(par2)]}
	catch {set segment(par3) [string trim $segment(par3)]}
	catch {set segment(par4) [string trim $segment(par4)]}
	catch {set segment(par5) [string trim $segment(par5)]}
	catch {set segment(par6) [string trim $segment(par6)]}
	catch {set segment(par7) [string trim $segment(par7)]}
	catch {set segment(par8) [string trim $segment(par8)]}
	switch -- $segment(process) {
		"ITERATE" {
			if {[string length $segment(par0)] <= 0} {		;#	DENSITY
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {$segment(phrase)} {
				if {![IsNumeric $segment(par0)] || ($segment(par0) < 1) || ($segment(par0) > 2)} {
					Inf "Invalid value for [$segment(label0) cget -text] : Range 1 to 2 (can be fractional)"
					set segment(doentry) 0
					return 0
				}	
			} else {
				if {![IsNumeric $segment(par0)] || ($segment(par0) < 2) || ($segment(par0) > 4)} {
					Inf "Invalid value for [$segment(label0) cget -text] : Range 2 to 4 (can be fractional)"
					set segment(doentry) 0
					return 0
				}	
			}
			if {[string length $segment(par1)] <= 0} {		;#	PSCAT
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ($segment(par1) < 0) || ($segment(par1) > 3)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Semitone Range 0 to 3"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 0} {		;#	GAIN
				Inf "No value entered for [$segment(label2) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] || ($segment(par2) < 0) || ($segment(par2) > 1.0)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Range 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	TAIL END LEVEL
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)] || ($segment(par3) < 0) || ($segment(par3) > 1.0)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Range 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par4)] <= 0} {		;#	FADE POWER
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0.25) || ($segment(par4) > 4)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0.25 to 4"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par5)] <= 0} {		;#	SEED
				Inf "No value entered for [$segment(label5) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par5)] || ![regexp {^[0-9]+$} $segment(par5)] \
			|| ($segment(par5) < 0) || ($segment(par5) > 256)} {
				Inf "Invalid value for [$segment(label5) cget -text] : Integer: Range 0 to 256 (integer)"
				set segment(doentry) 0
				return 0
			}	
		}
		"ZIGZAG" {
			if {[string length $segment(par0)] <= 0} {		;#	SEED
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ![regexp {^[0-9]+$} $segment(par0)] \
			|| ($segment(par0) < 0) || ($segment(par0) > 256)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Integer: Range 0 to 256 (integer)"
				set segment(doentry) 0
				return 0
			}	
		}
		"PLUCKED" {
			set segment(par0) [string trim $segment(par0)]
			if {[string length $segment(par0)] <= 0} {		;#	UP
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![string match $segment(par0) "0"] && ![string match $segment(par0) "1"]} {
				Inf "Invalid value for [$segment(label0) cget -text] : Either 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	GAIN
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ($segment(par1) < 0) || ($segment(par1) > 1.0)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 0} {		;#	TAIL END LEVEL
				Inf "No value entered for [$segment(label2) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] || ($segment(par2) < 0) || ($segment(par2) > 1.0)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	FADE POWER
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)] || ($segment(par3) < 0.25) || ($segment(par3) > 4)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Range 0.25 to 4"
				set segment(doentry) 0
				return 0
			}
			if {[string length $segment(par4)] <= 0} {		;#	CROSSFADE
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0) || ($segment(par4) > 1)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}
			set segment(vlabel1) "Average Duration"
			set segment(vlabel2) "Slope"
			set segment(vlabel3) "Troughing at"
		}
		"VERGES" {
			;#	par0 = BOOST is entered independently, and then fixed as readonly

			set segment(vlabel1) "Transposition (semitones)"
			set segment(vlabel2) "Slope (1 to 8)"
			set segment(vlabel3) "Duration (mS)"
		}
		"PINCH"   {
			if {[string length $segment(par0)] <= 0} {		;#	VIBRATO RATE
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < 0.0) || ($segment(par0) > 50.0)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 0 to 50.0"
				set segment(doentry) 0
				return 0
			}	
		}
		"SQUASH"  {
			if {[string length $segment(par0)] <= 0} {		;#	SQUASH
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] ||($segment(par0) < 2) || ($segment(par0) > 8)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 2 to 8"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	FORMANT NUMBER
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ![regexp {^[0-9]+$} $segment(par1)] \
			||($segment(par1) < 1) || ($segment(par1) > 4)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Integer in Range 1 to 4"
				set segment(doentry) 0
				return 0
			}	
		}
		"LIQUID"  {
			if {[string length $segment(par0)] <= 0} {		;#	ROTATION RATE
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < -16.0) || ($segment(par0) > 16.0)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range -16.0 to 16.0"
				set segment(doentry) 0
				return 0
			}	
		}
		"SQUEEZE" {
			if {[string length $segment(par0)] <= 0} {		;#	FRQ SHIFT
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < 0.0) || ($segment(par0) > 4000.0)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 0.0 to 4000.0"
				set segment(doentry) 0
				return 0
			}	
		}
		"DEEPEN"  {
			if {[string length $segment(par0)] <= 0} {		;#	MIDI PIVOT
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < 30.) || ($segment(par0) > 84)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 30 to 84"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	DEEPENING (Pitch exag under formants)
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ($segment(par1) < 1.5) || ($segment(par1) > 2.5)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Range 1.5 to 2.5"
				set segment(doentry) 0
				return 0
			}	
		}
		"DEEPREV"  {
			if {[string length $segment(par0)] <= 0} {		;#	Transposition
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < 6) || ($segment(par0) > 36)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 6 to 36"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	Stadium size multiplier
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ($segment(par1) < 0.1) || ($segment(par1) > 800)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Range 0.1 to 800"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 0} {		;#	Echo count
				Inf "No value entered for [$segment(label2) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] ||  ![regexp {^[0-9]+$} $segment(par2)] \
			|| ($segment(par2) < 10) || ($segment(par2) > 800)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Integer range 10 to 800"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	High freq balance
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)] || ($segment(par3) < 1) || ($segment(par3) > 4)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Range 1 to 4"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par4)] <= 0} {		;#	Low frq time offset
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0) || ($segment(par4) > 0.5)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0 to 0.5"
				set segment(doentry) 0
				return 0
			}	
		}
		"TUBEREV"  {
			if {[string length $segment(par0)] <= 0} {		;#	MIDI pitch
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < 4) || ($segment(par0) > 40)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 4 to 40"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	FRQ shift of formants
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ($segment(par1) < 2000) || ($segment(par1) > 4000)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Range 2000 to 4000"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 0} {		;#	Stadium size multiplier, low frqs
				Inf "No value entered for [$segment(label2) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] || ($segment(par2) < 0.1) || ($segment(par2) > 800)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Range 0.1 to 800"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	Echo count, low frqs
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)] || ![regexp {^[0-9]+$} $segment(par3)] \
			|| ($segment(par3) < 10) || ($segment(par3) > 800)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Integer range 10 to 800"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par4)] <= 0} {		;#	Stadium size multiplier, overall
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0.1) || ($segment(par4) > 800)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0.1 to 800"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par5)] <= 0} {		;#	Echo count, overall
				Inf "No value entered for [$segment(label5) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par5)] || ![regexp {^[0-9]+$} $segment(par5)] \
			|| ($segment(par5) < 10) || ($segment(par5) > 800)} {
				Inf "Invalid value for [$segment(label5) cget -text] : Integer range 10 to 800"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par6)] <= 0 } {		;#	Balance
				Inf "No value entered for [$segment(label6) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par6)] || ($segment(par6) < 0.01) || ($segment(par6) > 1)} {
				Inf "Invalid value for [$segment(label6) cget -text] Range 0.01 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par7)] <= 0} {		;#	Low frq time offset
				Inf "No value entered for [$segment(label7) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par7)] || ($segment(par7) < 0) || ($segment(par7) > 0.5)} {
				Inf "Invalid value for [$segment(label7) cget -text] : Range 0 to 0.5"
				set segment(doentry) 0
				return 0
			}	
		}
		"SPIKE"  {
			if {[string length $segment(par0)] <= 0} {		;#	TYPE
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ![regexp {^[0-9]+$} $segment(par0)] \
			 || ($segment(par0) < 0) || ($segment(par0) > 2)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Integer range 0 to 2"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	NORMALISE
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ![regexp {^[0-9]+$} $segment(par1)] \
			 || ($segment(par1) < 0) || ($segment(par1) > 1)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Integer range 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 1} {		;#	UP slope
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] || ($segment(par2) < 1) || ($segment(par2) > 100)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Range 1 to 100"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	DOWN slope
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)] || ($segment(par3) < 1) || ($segment(par3) > 100)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Range 1 to 100"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par4)] <= 0} {		;#	UP durlim
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0) || ($segment(par4) > 1)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par5)] <= 0} {		;#	DOWN durlim
				Inf "No value entered for [$segment(label5) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par5)] || ($segment(par5) < 0) || ($segment(par5) > 1)} {
				Inf "Invalid value for [$segment(label5) cget -text] : Range 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			set segment(vlabel1) "Pitches"
			set segment(vlabel2) "Spike Times"
		}
		"SQZBOX"  {
			if {[string length $segment(par0)] <= 0} {		;#	TYPE
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ![regexp {^[0-9]+$} $segment(par0)] \
			 || ($segment(par0) < 0) || ($segment(par0) > 1)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Integer range 0 to 1"
				set segment(doentry) 0
				return 0
			}
			set segment(vlabel1) "Stretched Segments"
			if {$segment(sqztempo)} {
				set segment(vlabel2) "Tempo"
				set segment(vlabel3) "Stretch-Sqz Ratio"
				set segment(pv2) 60
				set segment(pv3) 2
			} else {
				set segment(vlabel2) "Squeeze"
				set segment(vlabel3) "Stretch"
				set segment(pv2) 0.25
				set segment(pv3) 4

			}
		}	
		"TSTRETCH"  {
			set segment(vlabel1) "Stretched Segments"
			set segment(vlabel2) "Stretch Ratio"
		}	
		"ROUGHEN" {
			if {[string length $segment(par0)] <= 0} {		;#	ROUGHENING (Spectral randomisation, under formants)
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) < 0.5) || ($segment(par0) > 1.0)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 0.5 to 1.0"
				set segment(doentry) 0
				return 0
			}	
		}
		"RANDSTEP" {
			;#	No params
		}
		"DISTREP" {
			set segment(par0) [string trim $segment(par0)]
			if {[string length $segment(par0)] <= 0} {		;#	TELESCOPED?
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![string match $segment(par0) "0"] && ![string match $segment(par0) "1"]} {
				Inf "Invalid value for [$segment(label0) cget -text] : Either 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			set segment(vlabel1) "Waveset Groupsize"
			set segment(vlabel2) "Group Repetitions"
			set segment(vlabel3) "Relative Duration"
		}
		"DELRING" {
			set segment(vlabel1) "Midi Pitch"	;#	NOT USED
		}
		"VIBRATO" {
			set segment(vlabel1) "Frequency (Hz)"
			set segment(vlabel2) "Depth (semitones)"
		}
		"HPITCH" {
			set segment(vlabel2) "Head Extend (factor)"
			set segment(vlabel3) "Delay Randomisation"
			set segment(vlabel4) "Dip-by factor"
			set segment(vlabel5) "Dip-position fraction"
		}
		"TREMOLO" {
			set segment(vlabel1) "Frequency (Hz)"
			set segment(vlabel2) "Depth (>0 to 1)"
			set segment(vlabel3) "Peak Narrowing (1 to 100)"
		}
		"ZIGACCEL" {
			set segment(vlabel1) "Number of zigzags"
			set segment(vlabel2) "Fraction of tail to zigzag"
		}
		"REVERB" {
			;#	par0 = CROSSFADE is entered independently, and then fixed as readonly

			set segment(vlabel1) "Stadium size"
			set segment(vlabel2) "Echo count"
			set segment(vlabel3) "Relative Duration (1 to 100)"
		}
		"LOOP" {
			;#	par0 = SCATTER is entered independently, and then fixed as readonly

			set segment(vlabel1) "Length (0 to 1)"
			set segment(vlabel2) "Relative Duration"
			if {!$segment(PAR0)} {								;#	If not acattered (uses Iterate algo)
				set segment(vlabel3) "Advance By (0 to 1)"	;#	can advance looped element (ses Loop algo)
			}
		}
		"SCAN" {
			set segment(vlabel1) "Start Scan (0 to 1)"
			set segment(vlabel2) "End Scan (0 to 1)"
			set segment(vlabel3) "Relative Duration"
		}
		"FORMOVE" {
			set segment(vlabel1) "Transposition (semitones)"
		}
		"VOCODE" -
		"EDOCOV" {
			set segment(vlabel1) "Depth at Start (0 to 1)"
			set segment(vlabel2) "Depth at End (0 to 1)"
			set segment(vlabel3) "Slope of Depth (0.1 to 10)"
		}
		"PITCH" {
			set segment(vlabel1) "Midi Pitch"		;#	NOT USED
		}
		"TUNED" {
			set segment(vlabel1) "Chords"			;#	NOT USED
			set segment(vlabel2) "Clarity"
		}
		"TEXTURE" {
			;#	par0 = OUT CHANS is entered independently, and then fixed as readonly

			if {[string length $segment(par1)] <= 0} {		;#	MIN EVENT GAIN
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par1)] || ($segment(par1) < 0.0) || ($segment(par1) > 1.0)} {
				Inf "Invalid value for [$segment(label1) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 0} {		;#	MAX EVENT GAIN
				Inf "No value entered for [$segment(label2) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] || ($segment(par2) < 0.0) || ($segment(par2) > 1.0)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	RANDOM SEED
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)]  || ![regexp {^[0-9]+$} $segment(par3)] \
			|| ($segment(par3) < 0) || ($segment(par3) > 256)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Range 0 to 256 (integer)"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par4)] <= 0} {		;#	TAIL END LEVEL
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0) || ($segment(par4) > 1.0)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}
			if {[string length $segment(par5)] <= 0} {		;#	FADE POWER
				Inf "No value entered for [$segment(label5) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par5)] || ($segment(par5) < 0.25) || ($segment(par5) > 4)} {
				Inf "Invalid value for [$segment(label5) cget -text] : Range 0.25 to 4"
				set segment(doentry) 0
				return 0
			}
			if {[string length $segment(par6)] <= 0} {		;#	FORCE LEVEL
				Inf "No value entered for [$segment(label6) cget -text]"
				set segment(doentry) 0
				return 0
			}
			set segment(par6) [string trim $segment(par6)]
			if {![string match $segment(par6) "0"] && ![string match $segment(par6) "1"]} {
				Inf "Invalid value for [$segment(label6) cget -text] : 0 or 1 only"
				set segment(doentry) 0
				return 0
			}
			if {!$segment(phrase)} {	
				if {[string length $segment(par7)] <= 0} {		;#	FADEUP TAIL
					Inf "No value entered for [$segment(label7) cget -text]"
					set segment(doentry) 0
					return 0
				}
				set segment(par7) [string trim $segment(par7)]
				if {![IsNumeric $segment(par7)] || ($segment(par7) < 0.0) || ($segment(par7) > 1.0)} {
					Inf "Invalid value for [$segment(label7) cget -text] : Range 0 to 1"
					set segment(doentry) 0
					return 0
				}
				if {[string length $segment(par8)] <= 0} {		;#	FADE POWER
					Inf "No value entered for [$segment(label8) cget -text]"
					set segment(doentry) 0
					return 0
				}
				if {![IsNumeric $segment(par8)] || ($segment(par8) < 0.25) || ($segment(par8) > 4)} {
					Inf "Invalid value for [$segment(label8) cget -text] : Range 0.25 to 4"
					set segment(doentry) 0
					return 0
				}
			}
			set segment(vlabel1) "Level"
			set segment(vlabel2) "Persistence"
			set segment(vlabel3) "Density"
			set segment(vlabel4) "Scatter"
			set segment(vlabel5) "Dn Trans Max"
			set segment(vlabel6) "Up Trans Max"
			set segment(vlabel7) "Space Spread"
			set segment(vlabel8) "Spread By"
		}
		"BOUNCE" {
			if {[string length $segment(par4)] <= 0} {		;#	TAIL FADEUP
				Inf "No value entered for [$segment(label4) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par4)] || ($segment(par4) < 0) || ($segment(par4) > 1)} {
				Inf "Invalid value for [$segment(label4) cget -text] : Range 0 to 1"
				set segment(doentry) 0
				return 0
			}
			if {[string length $segment(par5)] <= 0} {		;#	TAIL FADEUP
				Inf "No value entered for [$segment(label5) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par5)] || ($segment(par5) < 0.1) || ($segment(par5) > 10)} {
				Inf "Invalid value for [$segment(label5) cget -text] : Range 0.1 to 10"
				set segment(doentry) 0
				return 0
			}
			set segment(vlabel1) "Bounce Count"
			set segment(vlabel2) "First Bounce Extent"
			set segment(vlabel3) "Bounce Accel"
			set segment(vlabel4) "Last Bounce Level"
			set segment(vlabel5) "Level Change Warp"
		}
		"ACCENT" {
			if {[string length $segment(par0)] <= 0} {		;#	QUIETEN
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par0)] || ($segment(par0) <= 0) || ($segment(par0) > 60.0)} {
				Inf "Invalid value for [$segment(label0) cget -text] : Range 0.0 to 60.0"
				set segment(doentry) 0
				return 0
			}	
			set segment(vlabel1) "Accentuation (dB)"
			set segment(vlabel2) "Tail suppressed by"
		}
		"TWANG" {
			set segment(par0) [string trim $segment(par0)]
			if {[string length $segment(par0)] <= 0} {		;#	TWANG/UNTWANG
				Inf "No value entered for [$segment(label0) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![string match $segment(par0) "0"] && ![string match $segment(par0) "1"]} {
				Inf "Invalid value for [$segment(label0) cget -text] : Either 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par1)] <= 0} {		;#	NORMALISE
				Inf "No value entered for [$segment(label1) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![string match $segment(par1) "0"] && ![string match $segment(par1) "1"]} {
				Inf "Invalid value for [$segment(label1) cget -text] : Either 0 to 1"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par2)] <= 0} {		;#	TAIL START LEVEL
				Inf "No value entered for [$segment(label2) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par2)] || ($segment(par2) < 0) || ($segment(par2) > 1.0)} {
				Inf "Invalid value for [$segment(label2) cget -text] : Range 0 to 1.0"
				set segment(doentry) 0
				return 0
			}	
			if {[string length $segment(par3)] <= 0} {		;#	FADE POWER
				Inf "No value entered for [$segment(label3) cget -text]"
				set segment(doentry) 0
				return 0
			}
			if {![IsNumeric $segment(par3)] || ($segment(par3) < 0.1) || ($segment(par3) > 10)} {
				Inf "Invalid value for [$segment(label3) cget -text] : Range 0.1 to 10"
				set segment(doentry) 0
				return 0
			}
			set segment(vlabel1) "Timestretch"
			set segment(vlabel2) "Twang duration"
			set segment(vlabel3) "Twang decay power"
		}
		TRANSFER -
		RETIME -
		REVERSAL -
		SHRHYTHM -
		ARTICULATION -
		SUPPRESS {
			;#	No params, or no params to display
		}
		default {
			Inf "NO PARAMETER CHECKING WRITTEN FOR $segment(process)"
			return 0
		}
	}
	HideFixedParamEntryBoxes
	return 1
}

#-- Set up param defaults (and ranges for possible-time-variable params)

proc GettrofParamDefaultsAndVariableParamRanges {init} {
	global segment

	if {$init} {	;#	Set up param values with their defaults 
		catch {unset segment(crospar)}
		set	segment(vparams_cnt,$segment(process)) 0	;#	default
		
		switch -- $segment(process) {
			"ITERATE" {
				set segment(paramcnt,ITERATE) 6
				set segment(paramstt,ITERATE) 0
				if {$segment(phrase)} {
					set segment(dflt0,ITERATE) 1.5		;#	Density -> 10^(-1.5) = > 0.01
				} else {
					set segment(dflt0,ITERATE) 3		;#	Density -> 10^-3 = 0.001
				}
				set segment(dflt1,ITERATE) 0.3		;#	Pitchscat
				set segment(dflt2,ITERATE) 1.0		;#	Gain
				set segment(dflt3,ITERATE) 1.0		;#	Tail end level
				set segment(dflt4,ITERATE) 1.0		;#	Fade Power
				set segment(dflt5,ITERATE) 1		;#	Seed

			}
			"ZIGZAG" {
				set segment(paramcnt,ZIGZAG) 1
				set segment(paramstt,ZIGZAG) 0
				set segment(dflt0,ZIGZAG) 1			;#	Seed

			}
			"PLUCKED" {
				set segment(paramcnt,PLUCKED) 5
				set segment(paramstt,PLUCKED) 0
				set segment(dflt0,PLUCKED) 0  		;#	Rising, rather than falling
				set segment(dflt1,PLUCKED) 1.0		;#	Gain
				set segment(dflt2,PLUCKED) 1.0		;#	Tail end level
				set segment(dflt3,PLUCKED) 1.0		;#	Fade Power
				set segment(dflt4,PLUCKED) 0.0		;#	Crossfade

				set segment(crospar) 4	;#	Param number of the crossfade parameter (where it exists)

				;#	Setup any possibly-time-variable params: Ranges and defaults

				set	segment(vparams_cnt,PLUCKED) 3
				set segment(lo1) 0.01
				set segment(hi1) 1.0
				set segment(pv1) 0.05	;#	Pluck events dur 0.01 to 1
				set segment(lo2) 0.25
				set segment(hi2) 4.0
				set segment(pv2) 2.0	;#	Slope 0.25 to 4
				set segment(lo3) 0.0
				set segment(hi3) 1.0
				set segment(pv3) 0.0	;#	Troffing
			}
			"FORMOVE" {
				set segment(paramcnt,$segment(process)) 2
				set segment(paramstt,$segment(process)) 2
				set segment(dflt0,$segment(process)) 0  		;#	Head NOT also processed
				set segment(dflt1,$segment(process)) 0  		;#	No transit to/from transpos

				;#	Setup any possibly-time-variable params: Ranges and defaults

				set	segment(vparams_cnt,$segment(process)) 1
				set segment(lo1) -24.0
				set segment(hi1) 24.0
				set segment(pv1) 6.0	;#	Transposition
			}
			"VOCODE" -
			"EDOCOV" {
				set segment(paramcnt,$segment(process)) 2
				set segment(paramstt,$segment(process)) 2
				set segment(dflt0,$segment(process)) 1  		;#	Stretch/shrink vocoding signal
				set segment(dflt1,$segment(process)) 0  		;#	Head NOT also processed

				;#	Setup any possibly-time-variable params: Ranges and defaults

				set	segment(vparams_cnt,$segment(process)) 3
				set segment(lo1) 0.0
				set segment(hi1) 1.0
				set segment(pv1) 0.0	;#	Vocode depth at start
				set segment(lo2) 0.0
				set segment(hi2) 1.0
				set segment(pv2) 1.0	;#	Vocode depth at end
				set segment(lo3) 0.1
				set segment(hi3) 10.0
				set segment(pv3) 0.5	;#	Curve of depth change
			}
			"TRANSFER" {
				set segment(paramcnt,$segment(process)) 3
				set segment(paramstt,$segment(process)) 3
				set segment(dflt0,$segment(process)) 39  		;#	Transfer all properties
				set segment(dflt1,$segment(process)) 0.01		;#	Gate val for Transfer-Duration
				set segment(dflt2,$segment(process)) 0			;#	Don't remove silent-gaps (if there are any)

				;#	Setup any possibly-time-variable params: Ranges and defaults

				set	segment(vparams_cnt,$segment(process)) 0
			}
			"VERGES" {
				set segment(paramcnt,VERGES) 1
				set segment(paramstt,VERGES) 1
				set segment(dflt0,VERGES) 1  		;#	Boost verge level relative to rest of sound
				set	segment(vparams_cnt,VERGES) 3
				set segment(lo1) -24
				set segment(hi1) 24
				set segment(pv1) 5		;#	Transposition
				set segment(lo2) 1
				set segment(hi2) 8
				set segment(pv2) 1		;#	Slope
				set segment(lo3) 20
				set segment(hi3) 1000
				set segment(pv3) 100	;#	Duration (mS)
			}
			"DISTREP" {
				set segment(paramcnt,DISTREP) 1	;#	Telescope (or not)
				set segment(paramstt,DISTREP) 1
				set	segment(vparams_cnt,DISTREP) 3
				set segment(lo1) 2
				set segment(hi1) 256
				set segment(pv1) 2		;#	Number of repeats of wavecycle
				set segment(lo2) 2
				set segment(hi2) 16
				set segment(pv2) 2		;#	Number of repeats of each group
				set segment(lo3) 1
				set segment(hi3) 100
				set segment(pv3) 1		;#	Output duration as multiple of segment duration
			}
			"DELRING" {
				set segment(paramcnt,DELRING) 2	;#	Tune Head (or not) Crossfade (or not)
				set segment(paramstt,DELRING) 2
				set	segment(vparams_cnt,DELRING)  1	;#	vparam1 is preset MIDI pitch
			}
			"VIBRATO" {
				set segment(paramcnt,VIBRATO) 0
				set segment(paramstt,VIBRATO) 0
				set	segment(vparams_cnt,VIBRATO) 2
				set segment(lo1) 6
				set segment(hi1) 30
				set segment(pv1) 12		;#	Frequency of vibrato
				set segment(lo2) 0
				set segment(hi2) 12
				set segment(pv2) 0.6	;#	Semitone depth of vibrato
			}
			"TREMOLO" {
				set segment(paramcnt,TREMOLO) 0
				set segment(paramstt,TREMOLO) 0
				set	segment(vparams_cnt,TREMOLO) 3
				set segment(lo1) 6
				set segment(hi1) 30
				set segment(pv1) 12		;#	Frquency of vibrato
				set segment(lo2) 0
				set segment(hi2) 1
				set segment(pv2) 0.5	;#	depth of vibrato
				set segment(lo3) 1
				set segment(hi3) 100
				set segment(pv3) 1		;#	Narrowing of peaks
			}
			"ZIGACCEL" {
				set segment(paramcnt,ZIGACCEL) 2
				set segment(paramstt,ZIGACCEL) 2
				set	segment(vparams_cnt,ZIGACCEL) 2
				set segment(lo1) 1
				set segment(hi1) 64
				set segment(pv1) 2		;#	Count of zigzags
				set segment(lo2) 0.2
				set segment(hi2) 1
				set segment(pv2) 1		;#	Fraction of tail to use
			}
			"REVERB" {
				set segment(paramcnt,REVERB) 1
				set segment(paramstt,REVERB) 1
				set	segment(vparams_cnt,REVERB) 3
				set segment(lo1) 0.01
				set segment(hi1) 100.0
				set segment(pv1) 0.3	;#	Stadium Size
				set segment(lo2) 2
				set segment(hi2) 1000
				set segment(pv2) 23		;#	Echo Count
				set segment(lo3) 1
				set segment(hi3) 100
				set segment(pv3) 1		;#	Output duration as multiple of segment duration
			}
			"LOOP" {
				set segment(paramcnt,LOOP) 1
				set segment(paramstt,LOOP) 1
				if {$segment(PAR0)} {
					set	segment(vparams_cnt,LOOP) 2
				} else {
					set	segment(vparams_cnt,LOOP) 3
				}
				set segment(lo1) 0
				set segment(hi1) 1
				set segment(pv1) 0.1	;#	Length of looped element as fraction of segment duration
				set segment(lo2) 1
				set segment(hi2) 100
				set segment(pv2) 1		;#	Output duration as multiple of segment duration
				set segment(lo3) 0
				set segment(hi3) 1
				set segment(pv3) 0		;#	Advance loop-element read location by this fraction of looped-element duration
			}
			"SCAN" {
				set segment(paramcnt,SCAN) 0
				set segment(paramstt,SCAN) 0
				set	segment(vparams_cnt,SCAN) 3
				set segment(lo1) 0
				set segment(hi1) 1.0
				set segment(pv1) 0		;#	Start of zigzagged element as proportion of segment duration
				set segment(lo2) 0.0
				set segment(hi2) 1.0
				set segment(pv2) 1		;#	End of zigzagged element as proportion of segment duration
				set segment(lo3) 1
				set segment(hi3) 100
				set segment(pv3) 1		;#	Output duration as multiple of segment duration
			}
			"PITCH" {
				set segment(paramcnt,PITCH) 3
				set segment(paramstt,PITCH) 3
				if {$segment(phrase)} {
					set segment(dflt0,PITCH) 0
				} else {
					set segment(dflt0,PITCH) 1  	;#	Head also tuned, rather than just tail
				}
				set	segment(vparams_cnt,PITCH)  1		;#	Entered at preset
				set segment(dflt1,PITCH) 1			;#	Median calc takes into account amplitudes of pitches found
				set segment(dflt2,PITCH) 1			;#	The original pitch-motion is to be retained
			}
			"TUNED" {
				set segment(paramcnt,TUNED) 1
				set segment(paramstt,TUNED) 1
				if {$segment(phrase)} {
					set segment(dflt0,TUNED) 0
				} else {
					set segment(dflt0,TUNED) 1  	;#	Head also tuned, rather than just tail
				}

				;#	Setup any possibly-time-variable params: Ranges and defaults

				set	segment(vparams_cnt,TUNED) 2
				set segment(lo2) 0.0				;#	First vparam is list of chords, entered at Preset, or Load Params
				set segment(hi2) 1.0
				set segment(pv2) 1.00	;#	Tuning Clarity
			}
			"TEXTURE" {
				if {$segment(phrase)} {
					set segment(paramcnt,TEXTURE) 7
				} else {
					set segment(paramcnt,TEXTURE) 9
				}
				set segment(paramstt,TEXTURE) 1
				;# set segment(dflt0) ""  			;#	Output Chans
				set segment(dflt1,TEXTURE) 0.3		;#	Min Event Gain
				set segment(dflt2,TEXTURE) 1.0		;#	Max Event Gain
				set segment(dflt3,TEXTURE) 1		;#	Random Seed
				set segment(dflt4,TEXTURE) 0.0		;#	Head end level
				set segment(dflt5,TEXTURE) 1.0		;#	Fade Power
				set segment(dflt6,TEXTURE) 1		;#	Force Level
				if {!$segment(phrase)} {
					set segment(dflt7,TEXTURE) 0.1	;#	Fade Tail
					set segment(dflt8,TEXTURE) 2	;#	Tailfade Power
				}
				
				;#	Setup any possibly-time-variable params: Ranges and defaults

				set	segment(vparams_cnt,TEXTURE) 8
				set segment(lo1) 0.01
				set segment(hi1) 1.0
				set segment(pv1) 1.0	;#	Level
				set segment(lo2) 0.1
				set segment(hi2) 100.0
				set segment(pv2) 1.0	;#	Persistence (duration as proportion of tail length)
				set segment(lo3) 0.02
				set segment(hi3) 1.0
				set segment(pv3) 0.06	;#	Density
				set segment(lo4) 0.0
				set segment(hi4) 4.0
				set segment(pv4) 1.0	;#	Scatter
				set segment(lo5) 0
				set segment(hi5) 6
				set segment(pv5) 1.0	;#	Down Transp Max
				set segment(lo6) 0
				set segment(hi6) 6
				set segment(pv6) 1.0	;#	Up Transp Max
				if {[info exists segment(PAR0)]} {
					if {$segment(PAR0) <= 2} {
						set segment(lo7) 0
						set segment(hi7) 1
						set segment(pv7) 1.0	;#	Spatial Spread
					} else {
						set segment(lo7) 1
						set segment(hi7) $segment(PAR0)
						set segment(pv7) $segment(PAR0)
					}							;#	Spatial Spread for multichan
				}
				set segment(lo8) 0
				set segment(hi8) 1
				set segment(pv8) 1.0	;#	Spatial Spread Rate
			}
			"TIMESTRETCH" {
				set segment(paramcnt,TIMESTRETCH) 0
				set segment(paramstt,TIMESTRETCH) 0
			}
			"BOUNCE" {
				set segment(paramcnt,BOUNCE) 6
				;# set segment(paramstt,BOUNCE) 4	;#	Start of non-readonly paramboxes : set from pre-set window
				;# set segment(dflt4,BOUNCE) 0  	;#	Tail fade-up from : set from pre-set window
				;# set segment(dflt5,BOUNCE) 2  	;#	Tail fade-up exponent : set from pre-set window
				set	segment(vparams_cnt,BOUNCE) 5
				set segment(lo1) 1.0
				set segment(hi1) 100.0
				set segment(pv1) 8.0  	;#	Number of bounces
				set segment(lo2) 0.04
				set segment(hi2) 10.0
				set segment(pv2) 0.2  	;#	1st bounce extent
				set segment(lo3) 0.1
				set segment(hi3) 1.0
				set segment(pv3) 0.92	;#	Bounce accel ratio
				set segment(lo4) 0.0
				set segment(hi4) 1.0
				set segment(pv4) 0.0	;#	Final Level
				set segment(lo5) 0.1
				set segment(hi5) 10.0
				set segment(pv5) 2.5	;#	Decay Slope
			}
			"HPITCH" {
				set segment(paramcnt,HPITCH) 0
				set segment(paramstt,HPITCH) 0	;#	Start of non-readonly paramboxes : set from pre-set window
				set	segment(vparams_cnt,HPITCH) 5
				set segment(lo2) 1.1
				set segment(hi2) 128.0
				set segment(pv2) 2  	;#	Head time-extension
				set segment(lo3) 0.0
				set segment(hi3) 1.0
				set segment(pv3) 0.02  	;#	Delay Randomisation
				set segment(lo4) 1
				set segment(hi4) 16
				set segment(pv4) 2		;#	Dip level as fraction of normal level
				set segment(lo5) 0.1
				set segment(hi5) 0.9
				set segment(pv5) 0.25	;#	Dip position in extended Head (fraction of its length)
			}
			"PINCH"  {
				set segment(paramcnt,PINCH) 1
				set segment(paramstt,PINCH) 0
				set segment(dflt0,PINCH) 0.0	;#	Vibrato rate
			}
			"SQUASH" {
				set segment(paramcnt,SQUASH) 2
				set segment(paramstt,SQUASH) 0
				set segment(dflt0,SQUASH) 2		;#	Squash
				set segment(dflt1,SQUASH) 1		;#	Formant number	
			}
			"LIQUID" {
				set segment(paramcnt,LIQUID) 1
				set segment(paramstt,LIQUID) 0
				set segment(dflt0,LIQUID) 0.5	;#	Rotation rate
			}
			"SQUEEZE" {
				set segment(paramcnt,SQUEEZE) 1
				set segment(paramstt,SQUEEZE) 0
				set segment(dflt0,SQUEEZE) 2000	;#	Hz shift of all formants
			}
			"DEEPEN"  {
				set segment(paramcnt,DEEPEN) 2
				set segment(paramstt,DEEPEN) 0
				set segment(dflt0,DEEPEN) 60	;#	MIDI pivot
				set segment(dflt1,DEEPEN) 2.0	;#	Deepen (pitch exagg)
			}
			"DEEPREV"  {
				set segment(paramcnt,DEEPREV) 5
				set segment(paramstt,DEEPREV) 0
				set segment(dflt0,DEEPREV) 12	;#	Down transpos
				set segment(dflt1,DEEPREV) 0.1	;#	Stadium size
				set segment(dflt2,DEEPREV) 300	;#	Echo count
				set segment(dflt3,DEEPREV) 2.0	;#	Hfreq balance
				set segment(dflt4,DEEPREV) 0.0	;#	LoFrq time offset
			}
			"TUBEREV"  {
				set segment(paramcnt,TUBEREV) 8
				set segment(paramstt,TUBEREV) 1
				set segment(dflt1,TUBEREV) 2000	;#	Formants frequncy shift
				set segment(dflt2,TUBEREV) 0.3	;#	Stadium size, lofrqs
				set segment(dflt3,TUBEREV) 100	;#	Echo count, lofrqs
				set segment(dflt4,TUBEREV) 0.1	;#	Stadium size, overall
				set segment(dflt5,TUBEREV) 300	;#	Echo count, overall
				set segment(dflt6,TUBEREV) 1.0	;#	Hfreq balance
				set segment(dflt7,TUBEREV) 0.0	;#	LoFrq time offset
			}
			"SPIKE"  {
				set segment(paramcnt,SPIKE) 6
				set segment(paramstt,SPIKE) 2
				set segment(dflt0,SPIKE) 0		;#	Spike type
				set segment(dflt1,SPIKE) 0		;#	Normalise
				set segment(dflt2,SPIKE) 10		;#	Upslope
				set segment(dflt3,SPIKE) 2.5	;#	Downslope
				set segment(dflt4,SPIKE) .05	;#	Up Maxdur
				set segment(dflt5,SPIKE) 0.3	;#	Down Maxdur
				set	segment(vparams_cnt,SPIKE) 2
				set segment(lo1) -127			;#	Spike pitches or transpositions (hidden)
				set segment(hi1) 127
				set segment(pv1) 60
				set segment(lo2) 0.0			;#	Spike times (hidden)
				set segment(hi2) $segment(dur)
				set segment(pv2) 0.01
			}
			"SQZBOX"  {
				set segment(paramcnt,SQZBOX) 1
				set segment(paramstt,SQZBOX) 1
				set segment(dflt0,SQZBOX) 1		;#	Sqzbox type
				set	segment(vparams_cnt,SQZBOX) 3
				set segment(lo2) 0				;#	Sqzbox squeeze, or Tempo
				set segment(hi2) 600
				set segment(pv2) 0
				set segment(lo3) 0 				;#	Sqzbox stretch or rhythm-ratio
				set segment(hi3) 100
				set segment(pv3) 0
			}
			"TSTRETCH"  {
				set segment(paramcnt,TSTRETCH) 0
				set segment(paramstt,TSTRETCH) 0
				set	segment(vparams_cnt,TSTRETCH) 2
				set segment(lo2) 1 				;#	Tstretch
				set segment(hi2) 100
				set segment(pv2) 2
			}
			"ROUGHEN" {
				set segment(paramcnt,ROUGHEN) 1
				set segment(paramstt,ROUGHEN) 0
				set segment(dflt0,ROUGHEN) 1.0	;#	Roughen (randomisation of pitch under formants)
			}
			"RANDSTEP" {
				set segment(paramcnt,RANDSTEP) 0
				set segment(paramstt,RANDSTEP) 0	;#	No params
			}
			"ACCENT" {
				set segment(paramcnt,ACCENT) 1
				set segment(paramstt,ACCENT) 0
				set segment(dflt0,ACCENT) 6  	;#	Quieten
				set	segment(vparams_cnt,ACCENT) 2
				set segment(lo1) 0.0
				set segment(hi1) 60.0
				set segment(pv1) 6.0  	;#	dB level of accented Head against Tail
				set segment(lo2) 0.0
				set segment(hi2) 1.0
				set segment(pv2) 0.33  	;#	Proportion of tail-len where Tail reaches de-accented level (0-1)
			}
			"TWANG" {
				set segment(paramcnt,TWANG) 4
				set segment(paramstt,TWANG) 2		;#	Start of non-readonly paramboxes : set from pre-set window
				;# set segment(dflt0,TWANG) 0  		;#	Untwang or not : set from pre-set window
				;# set segment(dflt1,TWANG) 0  		;#	Normalise or not : set from pre-set window
				set segment(dflt2,TWANG) 0.25		;#	Fade up tail start level
				set segment(dflt3,TWANG) 2			;#	Power func for fadeup
				set	segment(vparams_cnt,TWANG) 3
				set segment(lo1) 16
				set segment(hi1) 512
				set segment(pv1) 32  	;#	Timestretch
				set segment(lo2) 0.02
				set segment(hi2) 16.0
				set segment(pv2) 1.0  	;#	Duration of twanged tail-of-head
				set segment(lo3) 2
				set segment(hi3) 100.0
				set segment(pv3) 3.0	;#	Pow of decay of twanged tail-of-head
			}
			"RETIME" {
				set segment(paramcnt,RETIME) 4
				set segment(paramstt,RETIME) 4
				set	segment(vparams_cnt,RETIME)  1
			}
			"SUPPRESS" {
				set segment(paramcnt,SUPPRESS) 0
				set segment(paramstt,SUPPRESS) 0
				set	segment(vparams_cnt,SUPPRESS) 0
				;#	No params
			}
			"REVERSAL" {
				set segment(paramcnt,REVERSAL) 1
				set segment(paramstt,REVERSAL) 1
				set	segment(vparams_cnt,REVERSAL) 0
				;#	One param = mode, set in Presets
			}
			"SHRHYTHM" {
				set segment(paramcnt,SHRHYTHM) 4
				set segment(paramstt,SHRHYTHM) 4
				set	segment(vparams_cnt,SHRHYTHM) 0
				;#	3 param set in Presets, vparam is inaccesible
			}
			"ARTICULATION" {
				set segment(paramcnt,ARTICULATION) 0
				set segment(paramstt,ARTICULATION) 0
				set	segment(vparams_cnt,ARTICULATION) 0
				;#	All params set in Style
			}
			default {
				Inf "$segment(process) NOT YET WRITTEN\nGettrofParamDefaultsAndVariableParamRanges CALLED IN ERROR"
				set not_written_yet 1
			}
		}
		if {[info exists not_written_yet]} {
			if {$segment(multiproccnt)} {
				ResetGetSyllabTrofs RESTORE_AFTER_RECYCLE
			}
			return 0
		}
		if {$segment(process) != "BOUNCE"} {
			set n	$segment(paramstt,$segment(process))
			set len $segment(paramcnt,$segment(process))
			while {$n < $len} {
				if {[info exists segment(lastpar$n,$segment(process))]} {
					set segment(PAR$n) $segment(lastpar$n,$segment(process))	;#	Put last known values into entry boxes
				} else {
					set segment(PAR$n) $segment(dflt$n,$segment(process))		;#	Or (if none exist) the default values
				}
				set segment(par$n) $segment(PAR$n)
				incr n
			}
		}
	} else {	;#	Put default values in interface display
		set n	$segment(paramstt,$segment(process))
		set len $segment(paramcnt,$segment(process))

		while {$n < $len} {
			if {[string length $segment(par$n)] > 0} {
				set segment(lastpar$n,$segment(process)) $segment(par$n)
			}
			set segment(par$n) $segment(dflt$n,$segment(process))
			incr n
		}
		set segment(dodflts) 0
	}
	return 1
}

#---- Put all previous value for (non-timevariable) params into entry boxes

proc GettrofPreviousParamVals {} {
	global segment
	set n 0
	set n   $segment(paramstt,$segment(process))
	set len $segment(paramcnt,$segment(process))
	while {$n < $len} {
		if {![info exists segment(lastpar$n,$segment(process))]} {
			set segment(par$n) ""
		} else {
			set segment(par$n) $segment(lastpar$n,$segment(process))
		}
		ForceVal $segment(entry$n) $segment(par$n)
		incr n
	}
	set segment(doplast) 0
}

#---- Clear all param entry boxes

proc GettrofClearParamVals {} {
	global segment
	set n 0
	set n   $segment(paramstt,$segment(process))
	set len $segment(paramcnt,$segment(process))
	set k $n
	while {$n < $len} {
		if {[string length $segment(par$n)] > 0} {
			set segment(lastpar$n,$segment(process)) $segment(par$n)
		}
		set segment(par$n) ""
		incr n
	}
	set segment(doclear) 0
}

#######################################
# SEGMENTATION AND PROCESS PRECURSORS #
#######################################

#--- Segment a sound & timestretch by Iteration

proc DoIterationTimestretch {} {
	global segment

	if {!$segment(phrase)} {
		if {![info exists segment(recycprocess)]} {
			if {![SegmentSound 0]} {
				return 0
			}
		}
	}
	if {![IterateTimestretch]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose plucked waveset-envelopes on sound tails

proc DoPlucked {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 0]} {
			return 0
		}
	}
	if {![Gettrof_TailPluck]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose plucked waveset-envelopes on sound tails

proc DoVocode {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {
			return 0
		}
	}
	if {![Gettrof_TailVocode]} {
		return 0
	}
	return 1
}

#--- Segment a sound & process the sound tails (or process phrases)

proc DoOther {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {
			return 0
		}
	}
	if {![Gettrof_Other]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose tunings on sound tails

proc DoTuned {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {			;#	Tails must be dovetailed before anal for pitch-change
			return 0
		}
	}
	if {![Gettrof_TailTune 0]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose pitchline on sound tails

proc DoPitch {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {			;#	Tails must be dovetailed before anal for pitch-change
			return 0
		}
	}
	if {![Gettrof_TailTune 1]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose pitchline on sound tails

proc DoRetime {} {
	global segment

	if {![MultipleProcessing] && ![info exists segment(mixlines)]} {	;#	i.e. nothing has happened previously!!
		if {![SegmentSound 1]} {			;#	Tails must be dovetailed
			return 0
		}
	}
	if {![Gettrof_Retime]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose plucked waveset-envelopes on sound tails

proc DoSuppress {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 0]} {
			return 0
		}
	}
	if {![Gettrof_TailSuppress]} {
		return 0
	}
	return 1
}

#--- Segment a sound & impose plucked wavset-envelopes of sound tails

proc DoTexture {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {
			return 0
		}
	}
	if {![Gettrof_HeadTexture]} {
		return 0
	}
	return 1
}

#--- "Bounce"-repeat a sound

proc DoBounce {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {
			return 0
		}
	}
	if {![Gettrof_HeadBounce]} {
		return 0
	}
	return 1
}

#--- Stack a sound

proc DoAccent {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {
			return 0
		}
	}
	if {![Gettrof_Accent]} {
		return 0
	}
	return 1
}

#--- Twang a sound

proc DoTwang {} {
	global segment

	if {![MultipleProcessing]} {
		if {![SegmentSound 1]} {
			return 0
		}
	}
	if {![Gettrof_HeadTwang]} {
		return 0
	}
	return 1
}

############################################
# RUNING ONE PROCESS OF A MULTIPLE PROCESS #
############################################

#--- Do multiple processes

proc DoMulti {} {
	global segment evv
	catch {unset segment(intrinsic_pitch)}
	set action [lindex $segment(multido) $segment(docnt)]
	incr segment(docnt)
	catch {unset segment(vp)}
	set segment(process)	[lindex $action 0]

	;#	DO NOT REPEAT WHOLE-FILE PROCESSES

	if {[WholefileProcessFileAlreadyExists $segment(process)]} {
		return 1
	}
	if {[info exists segment(mixlines)]} {
		if {![DestroyAllProcessedFilesNotInMix]} {
			return 0
		}
	}
	set segment(actionlist) [lindex $action 1]
	if {[GettrofProcessHasPresets]} {
		set OKtex 1
		while {$OKtex} {									;#	BOUNCE Set cut and overlay flags OR load previous param-patch
			set test [GettrofPresets]						;#	TEXTURE Get chancnt OR load previous param-patch
			switch -- $test {								
				0 {											;#	Abandoned BOTH: quit
					.gettrofs.7.bak config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
					return 0
				}
				2 {											;#	Select to load patch
					if {[GettrofsLoadParamPatch 0]} {		;#	Go to load path window
						GettrofParamDefaultsAndVariableParamRanges 1
						ResetProcessBlock $segment(process)	;#	Got patch: Go directly to run process
						ResetGetSyllabTrofs PARAMETERS_LOADED_GOTO_RUN_PROCESS
						return 1							;#	(ELSE stay in OKtext loop)
					}
				}
				default {									;#	Texture chans set, go to rest-of-params entry
					break
				}
			}
		}
	}
	if {![GettrofParamDefaultsAndVariableParamRanges 1]} {	;#	Initialise parameter values for functions
		return 0
	}
	ResetProcessBlock $segment(process)
	if {$segment(process) == "SUPPRESS"} {
		set segment(returnkeystate) R_RUN
		ResetGetSyllabTrofs CONTROL_DATA_LOADED_GOTO_RUN_PROCESS
		return 1
	}
	set segment(returnkeystate) R_USE_PARAMS		;#	Se start on the box-entered parameters, 
													;#	All of which we "USE" with one Return stroke
	ResetGetSyllabTrofs CHOOSE_DATA_ENTRY_STYLE
	return 1
}

#--- In order to make File search and accounting on multiple processing work, delete all intermediate files not used in existing mixfile

proc DestroyAllProcessedFilesNotInMix {} {
	global segment evv

	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)HX*] {
		lappend fnams $fnam
	}
	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)HF*] {
		lappend fnams $fnam
	}
	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)PH*] {
		lappend fnams $fnam
	}
	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)TF*] {
		lappend fnams $fnam
	}
	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)PT*] {
		lappend fnams $fnam
	}
	if {![info exists fnams]} {
		return 1
	}
	foreach line $segment(mixlines) {
		if {[llength $line] > 2} {
			lappend mixfnams [lindex $line 0]
		}
	}
	foreach fnam $fnams {
		if {[lsearch $mixfnams $fnam] < 0} {
			lappend delfnams $fnam
		}
	}
	if {![info exists delfnams]} {
		return 1
	}
	foreach fnam $delfnams {
		if [catch {file delete $fnam} zit] {
			Inf "CANNOT DELETE INTERMEDIATE FILE $fnam : $zit"
			return 0
		}
	}
	return 1
}

###########
# SEGMENT #
###########

#-- Divide sound into segments
#-- Heads are extended outwards by splicelen, then splice-cut
#-- Tails are cut at exact time, with ZERO splices (dovetailed after processing)

proc SegmentSound {trimtail} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	DeleteAllOtherFormatTemporaryFiles		;#	Deletes all evv(MACH_OUTFNAME)
	catch {unset cutlist}

	catch {unset segment(crossfades)}
	if {$segment(phrase)} {
		catch {unset segment(crospar)}
	}
	if {[info exists segment(crospar)] && ($segment(PAR$segment(crospar)) > 0.0)} {
		set crossfade 1						;#	If there's a crossfade parameter, and it's not zero, flag it
	} else {
		set crossfade 0
	}
	if {$segment(phrase) || $segment(headfirst)} {
		set ishead 1
	} else {
		set ishead 0
	}
	set len [llength $segment(marklist)]
	set lastcut [lindex $segment(marklist) [expr $len - 2]]

	if {$segment(dur) < $lastcut} {
		set msg "SELECTED SEGMENTATION (last cut at [TwoSigFig $lastcut] secs) DOES NOT TALLY WITH SOURCE (dur [TwoSigFig $segment(dur)] secs)\n\n"
		append msg "AND LOAD (OR CREATE) A DIFFERENT SEGMENTATION BEFORE PROCEEDING"
		Inf $msg
		set pr_gettrofs SEG_RESTART

		return 0
	}
	set j 0
	set k 1
	set z 2
	while {$k < $len} {
		set segstt [lindex $segment(marklist) $j]
		set segend [lindex $segment(marklist) $k]
		if {$segment(phrase) || $ishead} {
			set segstt [expr $segstt - $segment(SPLICE)]	;#	HEADS and PHRASES extended at start
			if {$segstt < 0.0} {							;#	 |______|
				set segstt 0.0								;#	/|		|
			}												;# / |		|
			if {$crossfade && ($z < $len)} {
				set cross [GetCrossFadeLength $segend $z]
				lappend segment(crossfades) $cross
				set segend [expr $segend + $cross]
			} elseif {!$segment(phrase)} {					;#	HEADS extended at end, but not PHRASES
				set segend [expr $segend + $segment(SPLICE)];#	 |______|					  |____	 |
			}												;#	/|	    |\					 /|	   \ |
			set line [list $segstt $segend]					;# / |	    | \					/ |	    \|
			lappend headcutlist $line
		} else {											;#	TAILS cut in situ
			set line [list $segstt $segend]					;#   |	___	 |
			lappend tailcutlist $line						;#   | /   \ |
		}													;#   |/     \|
		set ishead [expr !$ishead]
		incr j
		incr k
		incr z
	}
	set line [lindex $headcutlist end]
	if {[lindex $line 1] > $segment(wavdur)} {
		set line [lreplace $line end end $segment(wavdur)]
		set headcutlist [lreplace $headcutlist end end $line]
	}
	if {$crossfade} {
		set line [lindex $segment(crossfades) end]
		if {[lindex $line 1] > $segment(wavdur)} {
			set line [lreplace $line end end $segment(wavdur)]
			set segment(crossfades) [lreplace $segment(crossfades) end end $line]
		}
	}
	set headcnt [llength $headcutlist]

	;#	CUT HEADS (or PHRASES) WITH SPLICES

	set OK 1
	set hcnt 1
	set croscnt 0

	set msg_typ "HEAD"
	if {$segment(phrase)} {
		set msg_typ "PHRASE"
	}

	Block "PLEASE WAIT:        CUTTING $msg_typ SEGMENTS FROM SOURCE"

	foreach line $headcutlist {
		set t1 [lindex $line 0]
		set t2 [lindex $line 1]
		if {$crossfade} {
			set ofnam $evv(MACH_OUTFNAME)HX$hcnt$evv(SNDFILE_EXT)		;#	If crossfade involved, output to intermediate temp file
		} else {
			set ofnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
		}
		set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
		lappend cmd cut 1 $segment(src,0) $ofnam $t1 $t2
		if {$crossfade} {
			lappend cmd -w0												;#	IF crossfade involved, cut with zero splices (and post dovetail)
		} else {
			lappend cmd -w$segment(MSPLICE)
		} 
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}

		wm title .blocker "PLEASE WAIT:        CUTTING $msg_typ SEGMENT $hcnt FROM SOURCE"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN PROCESS TO CUT $msg_typ SEGMENT $hcnt"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CUT $msg_typ SEGMENT $hcnt"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "FAILED TO CREATE $msg_typ SEGMENT $hcnt"
			set OK 0
			break
		}
		if {$crossfade} {												;#	If crossfade, dovetail the 2 ends of the head asymetrically
																		;#	(No dovetailing if these are "phrases")
			set ifnam $evv(MACH_OUTFNAME)HX$hcnt$evv(SNDFILE_EXT)
			set ofnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
			set endsplice [lindex $segment(crossfades) $croscnt]
			incr croscnt
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd dovetail 1 $ifnam $ofnam $segment(SPLICE) $endsplice 0 0 -t0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        DOVETAILING HEAD SEGMENT $hcnt"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO DOVETAIL HEAD SEGMENT $hcnt"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE DOVETAILED HEAD SEGMENT $hcnt"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO EXACT DOVETAILED HEAD SEGMENT $hcnt CREATED"
				set OK 0
				break
			}
		}
		incr hcnt
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	if {$segment(phrase) || ([info exists segment(intrinsic_pitch)] && $segment(intrinsic_pitch))} {
		set segment(cnt) [expr $hcnt - 1]							;#	Segment count is one less than count of marks
		UnBlock
		return 1
	}
	set line [lindex $tailcutlist end]
	if {[lindex $line 1] > $segment(wavdur)} {
		set line [lreplace $line end end $segment(wavdur)]
		set tailcutlist [lreplace $tailcutlist end end $line]
	}
	set tailcnt [llength $tailcutlist]

	;#	CUT TAILS WITH NO SPLICES

	set tcnt 1
	foreach line $tailcutlist {
		set t1 [lindex $line 0]
		set t2 [lindex $line 1]
		set ofnam $evv(MACH_OUTFNAME)TT$tcnt$evv(SNDFILE_EXT)

		set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
		lappend cmd cut 1 $segment(src,0) $ofnam $t1 $t2 -w0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CUTTING TAIL SEGMENT $tcnt FROM SOURCE"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN PROCESS TO CUT TAIL SEGMENT $tcnt"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO RUN TAIL SEGMENTATION PROCESS FOR TAIL $tcnt"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "FAILED TO CREATE TAIL SEGMENT $tcnt"
			set OK 0
			break
		}
		incr tcnt
	}
	while {$trimtail} {
		if {![DeleteExistingTemporaryDovetailedFiles]} {
			set OK 0
			break
		}
		set tcnt 1
		foreach line $tailcutlist {
			set ifnam $evv(MACH_OUTFNAME)TT$tcnt$evv(SNDFILE_EXT)
			set ofnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd dovetail 1 $ifnam $ofnam $segment(SPLICE) $segment(SPLICE) 0 0 -t0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        DOVETAILING TAIL SEGMENT $tcnt"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO DOVETAIL TAIL SEGMENT $tcnt"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO RUN DOVETAILING PROCESS FOR TAIL $tcnt"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "FAILED TO CREATE DOVETAILED TAIL SEGMENT $tcnt"
				set OK 0
				break
			}
			incr tcnt
		}
		break
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	set segment(cnt) [expr $headcnt + $tailcnt]
	return 1
}

#-- Get rid of any pre-existing dovetail files

proc DeleteExistingTemporaryDovetailedFiles {} {
	global evv
	if {[file exists $evv(MACH_OUTFNAME)TD1$evv(SNDFILE_EXT)]} {
		foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)TD*] {
			if [catch {file delete $fnam} zit] {
				Inf "CANNOT DELETE TEMPORARY FILE $fnam"
				return 0
			}
		}
	}
	return 1
}

#--- Distort envel applied to tails in segmented sound, or phrases

proc Gettrof_TailPluck {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	if {$segment(PAR0)} {
		set up 1			;#	Rising events mode
	} else {
		set up 2			;#	Falling (plucked) events mode
	}
	set atten   $segment(PAR1)
	set endgain [expr $segment(PAR2) * $atten]
	set fadexp  $segment(PAR3)

	set mm 0								;#	Index in original marklist
	if {$segment(phrase)} {
		set n 1								;#	TAIL First, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
		set segment(headfirst) 1
	} elseif {$segment(headfirst)} {
		set n 2								;#	Index for first segment to pluck is 2 (segments count from 1)
		set j 1								;#	Indices for start and end times of segment, in marklist
		set k 2
		if {![MultipleProcessing]} {
			set hfnam $evv(DFLT_OUTNAME)HH1$evv(SNDFILE_EXT)
			set line [list $hfnam [lindex $segment(marklist) $mm] 1 1.0]
			lappend mixlines $line			;#	Start mix with the unaltered HEAD segment = 1st segment
		}
		incr mm
		set nexthno 2						;#	Index of next HEAD File to use ( from 1)
		set tcnt 1							;#	Index of TAIL files (counted from 1)
	} else {
		set n 1								;#	TAIL First, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
		set nexthno 1
		set tcnt 1
	}
											;#	Extended final val in marklist, replaced by true end of file

	if {![MultipleProcessing]} {
		ClearNoexpands
	}

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	;#	PLUCKING tails (ALTERNATE SEGMENTS) or phrases

	if {[info exists segment(recycprocess)]} {
		set segment(origmixlines) $segment(mixlines)
	}

	set nn 1
	while {$nn <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$nn) [expr [llength $segment(control$nn,PLUCKED)] - 1]
		set segment(zccnt,$nn) 0
		incr nn
	}
	if {$segment(phrase)} {
		set msg_type "PHRASE"
	} else {
		set msg_type "TAIL SEGMENT"
	}

	Block "PLEASE WAIT:        PLUCKING $msg_type"

	set OK 1
	set ecnt 0
	set failed_msg ""
	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]
		set plkdur [GetParamValueFromControl $leftbase 1]
		set slope  [GetParamValueFromControl $leftbase 2]
		set trof   [GetParamValueFromControl $leftbase 3]

		;#	ALWAYS A TAIL

		if {$segment(multiproccnt) && ([lindex $segment(actionlist) $n] == 0)} {
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
			} else {
				incr mm 2									;#	If no tail processing required
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
				incr tcnt
			}
			continue
		}
		if {[MultipleProcessing]} {
			if {$segment(phrase)} {
				if {![GetRecycledSegment $n HEAD]} {
					append failed_msg "CANNOT FIND RECYCLED HEAD SEGMENT $n\n"
					if {$segment(phrase)} {
						incr mm
						incr n
						incr j
						incr k
					} else {
						incr mm 2									;#	If no tail processing required
						incr n 2									;#	Skip to next (iterable) tail
						incr j 2									;#	and next strt and end markers (times) of segments	
						incr k 2
						incr tcnt
					}
					continue
				}
			} else {
				if {![GetRecycledSegment $tcnt TAIL]} {
					append failed_msg "CANNOT FIND RECYCLED TAIL SEGMENT $tcnt\n"
					if {$segment(phrase)} {
						incr mm
						incr n
						incr j
						incr k
					} else {
						incr mm 2									;#	If no tail processing required
						incr n 2									;#	Skip to next (iterable) tail
						incr j 2									;#	and next strt and end markers (times) of segments	
						incr k 2
						incr tcnt
					}
					continue
				}
			}
			set ifnam $segment(iifnam)
		} else {
			set ifnam $evv(MACH_OUTFNAME)TT$tcnt$evv(SNDFILE_EXT)
		}
		if {$segment(phrase)} {
			set ofnam $evv(MACH_OUTFNAME)PH$n$evv(SNDFILE_EXT)
		} else {
			set ofnam $evv(MACH_OUTFNAME)PT$tcnt$evv(SNDFILE_EXT)
			incr tcnt
		}
		if {$segment(reordered)} {
			set dur [lindex $segment(retimedurs) [expr $n - 1]]		;#	Tail duration
		} else {
			set dur [expr [lindex $marks $k] - [lindex $marks $j]]	;#	Tail duration
		}

		set cmd [file join $evv(CDPROGRAM_DIR) wavmedian]
		lappend cmd wavmedian $ifnam $plkdur
		catch {unset maxsamp_line}
		set done_maxsamp 0
		wm title .blocker "PLEASE WAIT:        FINDING BEST WAVESET GROUPING FOR $msg_type $n"
		if [catch {open "|$cmd"} CDPmaxId] {
			append failed_msg "FAILED TO RUN PROCESS TO FIND BEST WAVESET GROUPING FOR $msg_type $n\n"
			catch {unset CDPidrun}
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
			} else {
				incr mm 2									;#	If no tail processing required
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
			}
			continue
		} else {
			fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
		vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			append failed_msg "CANNOT RETRIEVE BEST WAVESET GROUPING FOR $msg_type $n\n"
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
			} else {
				incr mm 2									;#	If no tail processing required
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
			}
			continue
		}
		set wvgp $maxsamp_line

		if {$wvgp <= 0} {
			append failed_msg "SEGMENT $n TOO SHORT FOR PLUCK DURATION SPECIFIED\n"
		} else {
			;#	PLUCK THE TAIL
			set cmd [file join $evv(CDPROGRAM_DIR) distort]
			lappend cmd envel $up $ifnam $ofnam $wvgp -t$trof -e$slope
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        PLUCKING SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				append failed_msg "FAILED TO RUN PLUCKING PROCESS FOR SEGMENT $n\n"
				catch {unset CDPidrun}
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE PLUCKED SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				append failed_msg "$msg\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
			if {![file exists $ofnam]} {
				append failed_msg "NO PLUCKED SEGMENT $n CREATED\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}

			if {[file exists $segment(othersnd)]} {
				if [catch {file delete $segment(othersnd)} zit] {
					append failed_msg "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd)\n"
					if {$segment(phrase)} {
						incr mm
						incr n
						incr j
						incr k
					} else {
						incr mm 2									;#	If no tail processing required
						incr n 2									;#	Skip to next (iterable) tail
						incr j 2									;#	and next strt and end markers (times) of segments	
						incr k 2
					}
					continue
				}
			}

			if [catch {file rename $ofnam $segment(othersnd)} zit] {
				append failed_msg "CANNOT RENAME TEMPORARY FILE $ofnam\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
		}

		;#	DOVETAIL TAIL SEGMENT

		if {[info exists segment(crossfades)] && ($segment(headfirst) || ($n > 1))} {	;#	if there are crossfades, and tail is after a head
			set startdove [lindex $segment(crossfades) $ecnt]							;#	get crossfade splicelen	
			incr ecnt
		} else {
			set startdove $segment(SPLICE)
		}
		if {$n == $segment(cnt)} {
			set enddove 0
		} else {
			set enddove $segment(SPLICE)
		}
		if {![MultipleProcessing]} {
			set cmd [file join $evv(CDPROGRAM_DIR) envel]								;#	dovetail raw tail 
			lappend cmd dovetail 1 $segment(othersnd) $ofnam $startdove $enddove 0 0 -t0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        DOVETAILING SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				append failed_msg "FAILED TO DOVETAIL SEGMENT $n\n"
				catch {unset CDPidrun}
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE DOVETAILED SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				append failed_msg "$msg\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
			if {![file exists $ofnam]} {
				append failed_msg "NO EXACT DOVETAILED SEGMENT $n CREATED\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
		} else {																		;#	If tail recycled, no dovetailing needed as already dovetailed
			if [catch {file rename $segment(othersnd) $ofnam} zit] {
				append failed_msg "CANNOT RENAME INTERMEDIATE FILE $segment(othersnd) (8)\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}				
		}

		;#	DO FADE

		if {$atten < 1.0} {	
			catch {unset env}
			if {$fadexp != 1.0} {							;#				1.0  0.3   		raised	
				set line [list 0.0 1.0]						;#				  0.6  0.0		to pow		*diff		+endgain
				lappend env $line							;# _____ 1		 _______		______					______
				set diff [expr 1.0 - $endgain]				;#  |			 x				x			______		x
				set val [expr pow(0.6666,$fadexp)]			;#	|			 x  		    x			x
				set val [expr $val * $diff]					;#	|			   x  			  	  
				set val [expr $val + $endgain]				;# diff			   x              x			 			 x    
				set line [list [expr $dur * 0.3333] $val]	;#	|				 x			  x			 x
				lappend env $line							;#	|				 x				x					   x  
				set val [expr pow(0.3333,$fadexp)]			;# _|___endgain		   x			x x		   x 		_____x
				set val [expr $val * $diff]					;# _____ 0		_______x		______x		_____x		______
				set val [expr $val + $endgain]				;#
				set line [list [expr $dur * 0.6666] $val]
				lappend env $line
				set line [list $dur $endgain]
				lappend env $line
			} else {
				set line [list 0.0 1.0]
				lappend env $line
				set line [list $dur $endgain]
				lappend env $line
			}
			if [catch {open $segment(envfil) "w"} zit] {
				append failed_msg "CANNOT OPEN ENVELOPE FILE TO CREATE FADE\n"
				set OK 0
				break
			}
			foreach line $env {
				puts $zit $line
			}
			close $zit

			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $ofnam $segment(fadesnd) $segment(envfil) 
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        FADING SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				append failed_msg "FAILED TO RUN FADE OF SEGMENT $n\n"
				catch {unset CDPidrun}
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE FADING SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				append failed_msg "$msg\n\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
			if {![file exists $segment(fadesnd)]} {
				append failed_msg "NO FADING SEGMENT $n CREATED\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
			if [catch {file delete $ofnam} zit] {
				append failed_msg "CANNOT DELETE PRE-FADED SEGMENT $n\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
			if [catch {file rename $segment(fadesnd) $ofnam} zit] {
				append failed_msg "CANNOT RENAME FADED SEGMENT $n\n"
				if {$segment(phrase)} {
					incr mm
					incr n
					incr j
					incr k
				} else {
					incr mm 2									;#	If no tail processing required
					incr n 2									;#	Skip to next (iterable) tail
					incr j 2									;#	and next strt and end markers (times) of segments	
					incr k 2
				}
				continue
			}
		}

		if {[MultipleProcessing]} {
				PhraseLineReinsert [expr $segment(recycline) + 1] $ofnam 0		;#	mixlines numbered from 0 , segments (used here) from 1
		} else {
			set line [list $ofnam [lindex $marks $mm] 1 1.0]
			lappend mixlines $line
		}
		if {$segment(phrase)} {
			incr mm
			incr n
			incr j									;#	1 segment at a time, if phrases
			incr k
			continue
		}
		set hfnam $evv(DFLT_OUTNAME)HH$nexthno$evv(SNDFILE_EXT)
		incr mm
		incr nexthno		
		if {![MultipleProcessing]} {	;#	If not recycling a file with already processed heada
			if {[file exists $hfnam]} {											;#	If there's a following HEAD
				set mixtime [expr [lindex $marks $mm] - $segment(SPLICE)]
				set line [list $hfnam $mixtime 1 1.0]							;#	Add it to mix
				lappend mixlines $line
			}
		}
		incr mm
		incr n 2									;#	Skip to next (iterable) tail
		incr j 2									;#	and next strt and end markers (times) of segments	
		incr k 2
	}
	if {[string length $failed_msg] > 0} {
		Inf $failed_msg
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	} elseif {$segment(multiproccnt)} {				;#	With a multiprocess, we don't mix until we reach end
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)				;#	If a 2nd process, get the reconfigureed mixlines
	} else {
		set segment(mixlines) $mixlines				;#	If a 1st process, keep the original mixlines (for possible later reconfiguring)
	}
	if {$segment(expand) && !$segment(noexpand)} {
		if {![ExpandPhraseMix 1]} {
			Inf "CANNOT EXPAND THE SEGMENT STRING AS REQUESTED"
		} else {
			set mixlines $segment(mixlines)
		}
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	if {[info exists segment(recycprocess)]} {		;#	OUTPUT MIX MAY OVERLOAD + MAY BE MULTICHANNEL
		if {![GettrofPossiblyMultichanMixdown 1]} {
			set segment(mixlines) $segment(origmixlines)
			set OK 0
		}
	} else {										;#	STANDARD MONO MIX FOR PLUCK PROCESS
		if {![GettrofMixdown 1]} {
			set OK 0
		}
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	set segment(reordered) 0
	return 1
}

#--- Distort envel applied to tails in segmented sound, or phrases

proc Gettrof_TailSuppress {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	set mm 0								;#	Index in original marklist
	if {$segment(phrase)} {
		set n 1								;#	TAIL First, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
	} elseif {$segment(headfirst)} {
		set n 2								;#	Index for first segment to pluck is 2 (segments count from 1)
		set j 1								;#	Indices for start and end times of segment, in marklist
		set k 2
		if {![MultipleProcessing]} {
			set hfnam $evv(DFLT_OUTNAME)HH1$evv(SNDFILE_EXT)
			set line [list $hfnam [lindex $segment(marklist) $mm] 1 1.0]
			lappend mixlines $line			;#	Start mix with the unaltered HEAD segment = 1st segment
		}
		incr mm
		set nexthno 2						;#	Index of next HEAD File to use ( from 1)
	} else {
		set n 1								;#	TAIL First, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
		set nexthno 1
	}
	set tcnt 1								;#	Index of TAIL files (counted from 1)

	if {![MultipleProcessing]} {
		ClearNoexpands
	}

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	;#	SUPPRESSING tails (ALTERNATE SEGMENTS) or phrases

	if {[info exists segment(recycprocess)]} {
		set segment(origmixlines) $segment(mixlines)
	}

	if {$segment(phrase)} {
		set msg_type "PHRASE"
	} else {
		set msg_type "TAIL SEGMENT"
	}

	Block "PLEASE WAIT:        SUPPRESSING $msg_type"

	set OK 1
	set ecnt 0

	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]

		;#	ALWAYS A TAIL

		if {$segment(multiproccnt) && ([lindex $segment(actionlist) $n] == 0)} {
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
				continue
			} else {
				incr mm 2									;#	If no tail processing required
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
				incr tcnt
				continue
			}
		}
		if {[MultipleProcessing]} {
			if {$segment(phrase)} {
				if {![GetRecycledSegment $n HEAD]} {
					set OK 0
					break
				}
			} else {
				if {![GetRecycledSegment $tcnt TAIL]} {
					set OK 0
					break
				}
			}
			GettrofSuppressMixline
		} else {
			set ofnam $evv(MACH_OUTFNAME)TT$tcnt$evv(SNDFILE_EXT)
			set line [list $ofnam [lindex $marks $mm] 1 0.0]
			lappend mixlines $line
		}
		incr tcnt

		if {$segment(phrase)} {
			incr mm
			incr n
			incr j									;#	1 segment at a time, if phrases
			incr k
			continue
		}
		set hfnam $evv(DFLT_OUTNAME)HH$nexthno$evv(SNDFILE_EXT)
		incr nexthno		
		incr mm
		if {![MultipleProcessing]} {
			if {[file exists $hfnam]} {											;#	If there's a following HEAD
				set mixtime [expr [lindex $marks $mm] - $segment(SPLICE)]
				set line [list $hfnam $mixtime 1 1.0]							;#	Add it to mix
				lappend mixlines $line
			}
		}
		incr mm
		incr n 2									;#	Skip to next (iterable) tail
		incr j 2									;#	and next strt and end markers (times) of segments	
		incr k 2
	}

	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	} elseif {$segment(multiproccnt)} {				;#	With a multiprocess, we don't mix until we reach end
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)				;#	If a 2nd process, get the reconfigureed mixlines
	} else {
		set segment(mixlines) $mixlines				;#	If a 1st process, keep the original mixlines (for possible later reconfiguring)
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	foreach line $mixlines {
		puts $zit $line
	}
	close $zit
	if {[info exists segment(recycprocess)]} {		;#	OUTPUT MIX MAY OVERLOAD + MAY BE MULTICHANNEL
		if {![GettrofPossiblyMultichanMixdown 1]} {
			set segment(mixlines) $segment(origmixlines)
			set OK 0
		}
	} else {										;#	STANDARD MONO MIX FOR PLUCK PROCESS
		if {![GettrofMixdown 1]} {
			set OK 0
		}
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	set segment(reordered) 0
	return 1
}

#--- Zero level of a gettrof mix line

proc GettrofSuppressMixline {} {
	global segment
	set line [lindex $segment(mixlines) $segment(recycline)]
	set line [lreplace $line 3 3 0.0]
	set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
}

#--- Is the process a time-stretch process ?

proc IsTimestretchProcess {process} {
	global segment
	if {($process == "TIMESTRETCH") || ($process == "ITERATE") || ($process == "ZIGZAG")} {
		return 1
	} 
	return 0
}

#--- Is the process usable in multiprcoess situation ?

proc CannotBeUsedInAMultiProcess {process} {
	if {[IsTimestretchProcess $process] || ($process == "ZIGACCEL") || ($process == "HPITCH")} {
		return 1
	}
	return 0
}

#--- Is the process a Tail process ?

proc IsTailProcess {process} {
	global segment
	switch -- $process {
		FORMOVE -
		VOCODE -
		EDOCOV -
		TRANSFER -
		SUPPRESS -
		PLUCKED -
		DISTREP -
		DELRING -
		VIBRATO -
		TREMOLO -
		REVERB -
		LOOP -
		SCAN -
		TUNED -
		ZIGACCEL -
		PITCH {
			return 1
		}
		RETIME -
		TEXTURE -
		BOUNCE -
		ACCENT -
		TWANG -
		REORDER -
		REVERSAL -
		SHRHYTHM -
		ARTICULATION -
		HPITCH -
		PINCH -
		SQUASH -
		LIQUID -
		SQUEEZE -
		DEEPEN -
		DEEPREV  - 
		TUBEREV  - 
		SPIKE  - 
		SQZBOX  - 
		TSTRETCH - 
		ROUGHEN -
		RANDSTEP -
		VERGES {
			return 0
		}
		default {		;#	Timestretch processes
			if {$segment(phrase)} {
				return 1
			} else {
				Inf "PROCESS $process NOT UNDERSTOOD BY IsTailProcess"
			}
		}
	} 
	return 0
}

#--- Is the process a Tail AND a Head process ?

proc IsCutableWholefileTransformationProcess {process} {
	global segment
	switch -- $process {
		PINCH -
		SQUASH -
		LIQUID -
		SQUEEZE -
		DEEPEN -
		ROUGHEN -
		SPIKE -
		RANDSTEP {
			return 1
		}
	} 
	return 0
}

#---- Is process HEAD-process, and if so does it retain orig Head, adding processed-head AFTER true Head

proc IsPostHeadProcess {} {
	global segment
	switch -- $segment(process) {
		FORMOVE -
		VOCODE -
		EDOCOV -
		TRANSFER -
		SUPPRESS -
		RETIME -
		PLUCKED -
		DISTREP -
		DELRING -
		VIBRATO -
		TREMOLO -
		REVERB -
		LOOP -
		SCAN -
		VERGES -
		TUNED -
		ZIGZAG -
		ITERATE -
		TIMESTRETCH -
		ZIGACCEL -
		PINCH -
		SQUASH -
		LIQUID -
		SQUEEZE -
		DEEPEN -
		DEEPREV -
		TUBEREV -
		SPIKE -
		SQZBOX -
		TSTRETCH -
		ROUGHEN -
		RANDSTEP -
		PITCH {
			return 0		;#	Tail processes
		}
		TEXTURE {
			return 1		;#	Processed Head inserted AFTER actual Head
		}
		TWANG -
		ACCENT -
		HPITCH -
		BOUNCE  {
			return 0		;#	Head processes
		}
		default {
			Inf "PROCESS $segment(process) NOT UNDERSTOOD BY IsPostHeadProcess"
		}
	} 
	return 0
}

#--- Display the sound ouptut from Vbox processing

proc TrofSegOutputSndView {} {
	global segment pa evv
	if {![file exists $segment(outfnamplay)]} {
		Inf "NO OUTPUT FILE TO PLAY"
		return 0
	}
	if {[DoParse $segment(outfnamplay) 0 0 0] <= 0} {
		Inf "CANNOT PARSE THE OUTPUT WAV FILE"
		return 0
	}
	set insamz $pa($segment(outfnamplay),$evv(INSAMS))
	set zrate  $pa($segment(outfnamplay),$evv(SRATE))
	set chanz  $pa($segment(outfnamplay),$evv(CHANS))
	set durz   $pa($segment(outfnamplay),$evv(DUR))
	set sn_edit 0
	set sn_windows 0
	set segment(outdisplay) 1
	if {[info exists segment(displaytransfer)]} {
		if {![DoTransferDisplay]} {
			SnackCreate 0 $evv(SN_SINGLETIME) $segment(outfnamplay) $insamz [expr $zrate * $chanz] $chanz troflist2 0 0 $durz 1
		}
	} else {
		SnackCreate 0 $evv(SN_SINGLETIME) $segment(outfnamplay) $insamz [expr $zrate * $chanz] $chanz troflist2 0 0 $durz 1
	}
	unset segment(outdisplay)
	return 1
}

proc TrofSegInputSndView {} {
	global segment evv
	set insamz $segment(insams)
	set zrate  $segment(srate)
	set chanz  $segment(chans)
	set durz   $segment(dur)
	set sn_edit 0
	set sn_windows 0
	set segment(outdisplay) 1
	SnackCreate 0 $evv(SN_SINGLETIME) $segment(src,0) $insamz [expr $zrate * $chanz] $chanz troflist2 0 0 $durz 1
	unset segment(outdisplay)
	return 1
}

#--- Calculate length of crossfade from head end to full-processing of tail

proc GetCrossFadeLength {segend z} {
	global segment evv
	set tailend [lindex $segment(marklist) $z]			;#	Endtime of tail
	set tailend [expr $tailend - $segment(SPLICE)]		;#	End before final downsplice
	if {$tailend > $segment(wavdur)} {
		set tailend $segment(wavdur)
	}
	set taillen [expr $tailend - $segend]
	set taillen [expr $taillen - $segment(SPLICE)]
	if {$taillen < 0.0} {
		set taillen 0.0
	}
	set crossfade [expr $taillen * $segment(PAR$segment(crospar))]
	set crossfade [expr $taillen + $segment(SPLICE)]
	set crossfade [expr $crossfade - $evv(FLTERR)]		;#	Avoid case where 2 splices add up EXACTLY to duration (in which case dovetail fails)
	return $crossfade
}

#--- Display the default value in Fixed Val box of Possibly-variable-param entry

proc GettrofVParamDefault {} {
	global segment 
	if {(($segment(process) == "SQZBOX") || ($segment(process) == "TSTRETCH")) && ($segment(vp) == 0)} {
		return
	}
	set segment(fixed) $segment(pv$segment(vp))
}

#--- Rename the existing temporary Head and (dovetailed) Tail files, make a mixfile, and send to workspace

proc ExportSegmentation {after} {
	global segment evv wstk

	set NEED_NEW_NAME 0						;#	If export fails because name used is invalid or already in use, we stay in "Export" mode	
	set FAILED 1							;#	If an export fails for any other reason, we quit export mode, (same as if it succeeds)

	if {$segment(phrase) || $after} {
		set segment(multichan) [GettrofMixFormat]
		if {$segment(multichan) < 0} {
			Inf "CANNOT FIND MIXFILE INFORMATION"
			return FAILED
		}
	}
	if {$after} {
		set genfnam [file rootname [file tail $segment(ofnamw)]]
		append genfnam _mix
		set n 0
		set OK 0
		while {!$OK} {
			set exportnam $genfnam 
			append exportnam $n
			set files_exist 0
			foreach fnam [glob -nocomplain $exportnam*] {
				set files_exist 1
				break
			}
			if {$files_exist} {
				incr n
				continue
			}
			set OK 1
		}
		set mixfnam $exportnam
		if {$segment(multichan)} {
			append mixfnam [GetTextfileExtension mmx]
		} else {
			append mixfnam [GetTextfileExtension mix]
		}
		if {[file exists $mixfnam]} {
			Inf "ERROR IN NAME-CHECKING LOGIC: MIXFILE $mixfnam ALREADY EXISTS"
			return 0
		}
		set n 0		;#	counts mix lines
		set m 1		;#	segs numbered from 0, counted from 0, numbers files in mix: NB m != n+1 if a multichan file (extra mixfile-line at n == 0: so n=m)
		foreach line $segment(mixlines) {
			if {($n == 0) && $segment(multichan)} {		;#	Skip channel-count line of a multichannel mix
				incr n
				continue
			}
			set oldphrasename [lindex $line 0]
			lappend oldphrasnames $oldphrasename
			set fnam $exportnam
			append fnam _$m $evv(SNDFILE_EXT)
			if {[file exists $fnam]} {
				Inf "ERROR IN NAME-CHECKING LOGIC: SNDFILE $fnam ALREADY EXISTS"
				return 0
			}
			lappend nuphrasnames $fnam
			incr n
			incr m
		}
	} else {
		set segment(xfnam) [.gettrofs.4.segfil get]
		if {[string length $segment(xfnam)] <= 0} {
			Inf "NO GENERIC SEGMENTATION FILENAME ENTERED"
			return $NEED_NEW_NAME
		}
		if {![ValidCDPRootname $segment(xfnam)]} {
			return $NEED_NEW_NAME
		}
		set exportnam [string tolower $segment(xfnam)]
		if {![SegmentSound 1]} {
			return $FAILED
		}

		;# FIND MIXFILE TIMINGS

		if {$segment(phrase)} {
			catch {unset nuheadnames}
			set n 1
			while {$n <= $segment(cnt)} {
				set oldphrasname $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
				set nuphrasname $exportnam
				append nuphrasname "_phr" $n $evv(SNDFILE_EXT)
				if {[file exists $nuphrasname]} {
					Inf "FILE $nuphrasname ALREADY EXISTS : PLEASE CHOOSE A DIFFERENT GENERIC NAME"
					return $NEED_NEW_NAME
				}
				lappend oldphrasnames $oldphrasname
				lappend nuphrasnames  $nuphrasname
				incr n
			}
		} else {
			set mm 0
			if {$segment(headfirst)} {
				set n 2								;#	Index for first TAIL segment is 2 (segments count from 1)
				set mixtime [lindex $segment(marklist) $mm]
				incr mm
				lappend mixtimes $mixtime			;#	(This is hno 1)
				set nexthno 2						;#	(This will be next head we encounter)
			} else {
				set n 1								;#	TAIL First, segment 1 (segs count from 1)
				set nexthno 1						;#	(This will be first head we encounter)
			}

			;#	FINDING TIMINGS OF SEGMENTS IN FINAL MIX

			set OK 1

			while {$n <= $segment(cnt)} {			;#	Get time of next tail
				set mixtime [lindex $segment(marklist) $mm]
				lappend mixtimes $mixtime
				incr mm
				set hfnam $evv(DFLT_OUTNAME)HH$nexthno$evv(SNDFILE_EXT)
				incr nexthno		
				if {[file exists $hfnam]} {			;#	If there's a following HEAD
					set mixtime [expr [lindex $segment(marklist) $mm] - $segment(SPLICE)]
					lappend mixtimes $mixtime		;#	get time of head
					incr mm
				}
				incr n 2							;#	Skip to next tail
			}
		
			catch {unset oldtailnames}
			catch {unset nutailnames}
			catch {unset nums}
			set cnt 0
			foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)TD*] {
				lappend oldtailnames $fnam
				incr cnt
			}
			if {$cnt == 0} {
				Inf "NO TAIL FILES FOUND"
				return $FAILED
			}
			set prelen [string length $evv(MACH_OUTFNAME)]
			incr prelen 2

			;#	GET NUMBERS EMBEDDED IN TEMPORARY FILENAMES

			foreach fnam $oldtailnames {					;#	XXXXTT17.wav
				set fnam [file rootname $fnam]				;#	XXXXTT17
				set num [string range $fnam $prelen end]	;#		  17
				lappend nums $num
			}

			;#	SORT TEMPORARY FILENAMES INTO NUMERIC ORDER

			set len [llength $oldtailnames]
			set len_less_one [expr $len - 1]
			set n 0
			while {$n < $len_less_one} {
				set name_n [lindex $oldtailnames $n]
				set num_n  [lindex $nums $n]
				set m $n
				incr m
				while {$m < $len} {
					set name_m [lindex $oldtailnames $m]
					set num_m  [lindex $nums $m]
					if {$num_m < $num_n} {
						set oldtailnames [lreplace $oldtailnames $n $n $name_m]
						set oldtailnames [lreplace $oldtailnames $m $m $name_n]
						set name_n $name_m
						set nums [lreplace $nums $n $n $num_m]
						set nums [lreplace $nums $m $m $num_n]
						set num_n $num_m
					}
					incr m
				}
				incr n
			}

			;#	GENERATE NEW TAIL NAMES, AND CHECK IF FILES WITH THESE NAMES ALREADY EXIST

			foreach num $nums {
				set nutailname $exportnam
				append nutailname "_tt" $num $evv(SNDFILE_EXT)
				if {[file exists $nutailname]} {
					Inf "FILE $nutailname ALREADY EXISTS : PLEASE CHOOSE A DIFFERENT GENERIC NAME"
					return $NEED_NEW_NAME
				}
				lappend nutailnames $nutailname
			}

			;#	SAME WITH HEADS

			catch {unset oldheadnames}
			catch {unset nuheadnames}
			catch {unset nums}

			foreach fnam [glob -nocomplain $evv(DFLT_OUTNAME)HH*] {
				lappend oldheadnames $fnam
				incr cnt
			}
			if {$cnt == 0} {
				Inf "NO HEAD FILES FOUND"
				return $FAILED
			}

			set prelen [string length $evv(DFLT_OUTNAME)]
			incr prelen 2

			foreach fnam $oldheadnames {					;#	XXXXHH17.wav
				set fnam [file rootname $fnam]				;#	XXXXHH17
				set num [string range $fnam $prelen end]	;#		  17
				lappend nums $num
			}

			set len [llength $oldheadnames]
			set len_less_one [expr $len - 1]
			set n 0
			while {$n < $len_less_one} {
				set name_n [lindex $oldheadnames $n]
				set num_n  [lindex $nums $n]
				set m $n
				incr m
				while {$m < $len} {
					set name_m [lindex $oldheadnames $m]
					set num_m  [lindex $nums $m]
					if {$num_m < $num_n} {
						set oldheadnames [lreplace $oldheadnames $n $n $name_m]
						set oldheadnames [lreplace $oldheadnames $m $m $name_n]
						set name_n $name_m
						set nums [lreplace $nums $n $n $num_m]
						set nums [lreplace $nums $m $m $num_n]
						set num_n $num_m
					}
					incr m
				}
				incr n
			}

			catch {unset nuheadnames}
			foreach num $nums {
				set nuheadname $exportnam
				append nuheadname "_hh" $num $evv(SNDFILE_EXT)
				if {[file exists $nuheadname]} {
					Inf "FILE $nuheadname ALREADY EXISTS : PLEASE CHOOSE A DIFFERENT GENERIC NAME"
					return $NEED_NEW_NAME
				}
				lappend nuheadnames $nuheadname
			}
		}

		;#	CREATE NEW MIXFILE NAME AND CHECK IF FILE WITH THAT NAME ALREADY EXISTS

		set mixfnam $exportnam 
		append mixfnam [GetTextfileExtension mix]
		if {[file exists $mixfnam]} {
			Inf "FILE $mixfnam ALREADY EXISTS : PLEASE CHOOSE A DIFFERENT GENERIC NAME"
			return $NEED_NEW_NAME
		}
	}	
	set completely_finished 0
	set finished 0
	set cnt 0

	if {$segment(phrase) || $after} {
		if {![info exists segment(mixlines)]} {
			Inf "NO OUTPUT MIX INFORMATION CURRENTLY EXISTS"
			return $FAILED
		}
		catch {unset newmixlines}
		set n 0
		set m 0
		if {$after} {
			set len  [llength $segment(mixlines)]
		} else {
			set len  $segment(cnt)
		}
		while {$n < $len} {
			if {($n == 0) && $after && $segment(multichan)} {
				lappend newmixlines [lindex $segment(mixlines) 0]
				incr n									;#	In multichan case (only possible AFTER) copy chancnt line unaltered
				continue
			}
			set line [lindex $segment(mixlines) $n]		;#	Restructure the existing mixlines, to use the output names				
			set nuphrasname [lindex $nuphrasnames $m]	;#	In standard case m reads from name 0 and writes to line 0 (etc)
			set line [lreplace $line 0 0 $nuphrasname]	;#	If multichan, m reads from name 0 and writes to line 1 (etc)
			lappend newmixlines $line
			incr n
			incr m
		}
		if {$after} {									;#	Possible that the mixfile will be recycled to process heads
														;#	so MAKE COPIES.
			foreach oldphrasname $oldphrasnames nuphrasname $nuphrasnames {
				if [catch {file copy $oldphrasname $nuphrasname} zit] {
					set msg "CANNOT COPY OUTPUT SEGMENT FILE $oldphrasname TO $nuphrasname"
					if {$cnt > 0} {
						if {!$finished} {
							append msg "\n\nONE OUTPUT SEGMENT OR MORE HAS BEEN COPIED"
							Inf $msg
						}								;#	On first occurence of failure to copy, inform user
						set finished 1
					} else {							;#	No files were renamed, Fail
						Inf $msg
						return $FAILED
					}
				}
				incr cnt
			}
		} else {										;#	in PRE-export, segments are specially made for exporting	
														;#	so can be RENAMED. (Processes afterwards will make there own segments)
			foreach oldphrasname $oldphrasnames nuphrasname $nuphrasnames {
				if [catch {file rename $oldphrasname $nuphrasname} zit] {
					set msg "CANNOT RENAME PHRASE FILE $oldphrasname TO $nuphrasname"
					if {$cnt > 0} {
						if {!$finished} {
							append msg "\n\nSOME PHRASES HAVE BEEN RENAMED"
							Inf $msg
						}									;#	On first occurence of failure to rename, inform user
						set finished 1
					} else {								;#	No files were renamed, Fail
						Inf $msg
						return $FAILED
					}
				}
				incr cnt
			}
		}
		;#	PUT OUTPUT FILES ON WORKSPACE

		if {$finished} {								;#	If not all of files have been renamed, could possibly save the onrs that have (but not the mixfile)
			set msg "DO YOU WANT TO KEEP THE EXISTING RENAMED FILES ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				set msg2 ""
				foreach nuphrasname $nuphrasnames {
					if {[file exists $nuphrasname]} {
						if [catch {file delete $nuphrasname} zit] {
							append msg2 "$nuphrasname  "
						}
					} else {
						break
					}
				}
				if {[string length $msg2] > 0} {		;#	Still files remaining, which will be put onto the workspace
					set msg "THESE FILES COULD NOT BE DELETED\n"
					append msg $msg2
					Inf $msg
				} else {
					return $FAILED						;#	No files remaining, nothing to put on workspace, so quit
				}
			}
		}
		set nuphrasnames [ReverseList $nuphrasnames]
		foreach nuphrasname $nuphrasnames {				;#	Put all, or some, of phrase-files on workspace
			if {[file exists $nuphrasname]} {
				FileToWkspace $nuphrasname 0 0 0 0 1
			}
		}
		if {!$finished} {								;#	If all the files were renamed successfully
			if [catch {open $mixfnam "w"} zit] {		;#	Write mixfilelines to output mixfile
				Inf "CANNOT OPEN FILE $mixfnam TO WRITE MIXDATA"
			} else {
				foreach line $newmixlines {
					puts $zit $line
				}
				close $zit
				FileToWkspace $mixfnam 0 0 0 0 1
			}
		}
		if {!$after} {
			set segment(lastnam,phrasexport) $exportnam
		}
	} else {

	#	RENAME TAILS AND HEADS

		foreach oldtailname $oldtailnames nutailname $nutailnames {
			if [catch {file rename $oldtailname $nutailname} zit] {
				set msg "CANNOT RENAME TAIL FILE $oldtailname TO $nutailname"
				if {$cnt > 0} {
					append msg "\n\nSOME TAILS HAVE BEEN RENAMED"
					Inf $msg
					set finished 1
					break
				} else {
					Inf $msg
					return $FAILED
				}
			}
			incr cnt
		}

		if {!$finished} {
			set cnt 0
			foreach oldheadname $oldheadnames nuheadname $nuheadnames {
				if [catch {file rename $oldheadname $nuheadname} zit] {
					set msg "CANNOT RENAME HEAD FILE $oldheadname TO $nuheadname\n\nALL THE TAILS "
					if {$cnt > 0} {
						append msg "AND SOME HEADS "
					}
					append msg "HAVE BEEN RENAMED"
					Inf $msg
					set finished 1
					break
				}
				incr cnt
			}
		}

		;#	CREATE MIXFILE LINES

		while {!$finished} {
			set hcnt [llength $nuheadnames]
			set tcnt [llength $nutailnames]
			set h 0
			set t 0
			set segcnt 0
			set mm 0
			if {$segment(headfirst)} {
				if {$h < $hcnt} {
					set line [lindex $nuheadnames $h]
					incr h
					set mixtime [lindex $mixtimes $mm]
					incr mm
					lappend line $mixtime 1 1.0
					lappend mixlines $line
					incr segcnt
				}
			}
			while {$segcnt < $segment(cnt)} {
				if {$t < $tcnt} {
					set line [lindex $nutailnames $t]
					incr t
					set mixtime [lindex $mixtimes $mm]
					incr mm
					lappend line $mixtime 1 1.0
					lappend mixlines $line
					incr segcnt
				}
				if {$segcnt >= $segment(cnt)} {
					break
				}
				if {$h < $hcnt} {
					set line [lindex $nuheadnames $h]
					incr h
					set mixtime [lindex $mixtimes $mm]
					incr mm
					lappend line $mixtime 1 1.0
					lappend mixlines $line
					incr segcnt
				}
			}

		;#	CREATE MIXFILE

			if [catch {open $mixfnam "w"} zit] {
				set msg "CANNOT OPEN MIXFILE $mixfnam TO WRITE MIX OF HEADS AND TAILS"
				append msg "\n\nALL THE HEADS AND TAILS HAVE BEEN RENAMED"
				Inf $msg
				set finished 1
				break
			}
			set segment(mixlines) $mixlines
			foreach line $mixlines {
				puts $zit $line
			}
			close $zit
			set finished 1
			set completely_finished 1
		}

		;#	DEAL WITH ONLY-PARTIAL SUCCESS

		if {!$completely_finished} {
			if {[file exists $evv(MACH_OUTFNAME)TD1$evv(SNDFILE_EXT)]} {
				foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)TD*] {	;#	Clear intermediate (dovetailed) tails
					catch {file delete $fnam}
				}
			}
			set msg "DO YOU WANT TO KEEP THE EXISTING RENAMED FILES ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				set msg2 ""
				set finished 0
				while {!$finished} {
					foreach nutailname $nutailnames {
						if {[file exists $nutailname]} {
							if [catch {file delete $nutailname} zit] {
								append msg2 "$nutailname  "
							}
						} else {
							set finished 1
							break
						}
					}
					if {$finished} {
						break
					}
					foreach nuheadname $nuheadnames {
						if {[file exists $nuheadname]} {
							if [catch {file delete $nuheadname} zit] {
								append msg2 "$nuheadname  "
							}
						} else {
							break
						}
					}
					break
				}
				if {[string length $msg2] > 0} {
					set msg "THESE FILES COULD NOT BE DELETED\n"
					append msg $msg2
					Inf $msg						;#	Still files remaining, which will be put onto the workspace
				} else {
					return $FAILED					;#	No files remaining, so quit
				}
			}
		}

		;#	PUT OUTPUT FILES ON WORKSPACE

		set nutailnames [ReverseList $nutailnames]
		foreach nutailname $nutailnames {
			if {[file exists $nutailname]} {
				FileToWkspace $nutailname 0 0 0 0 1
			}
		}
		set nuheadnames [ReverseList $nuheadnames]
		foreach nuheadname $nuheadnames {
			if {[file exists $nuheadname]} {
				FileToWkspace $nuheadname 0 0 0 0 1
			}
		}
		if {[file exists $mixfnam]} {
			FileToWkspace $mixfnam 0 0 0 0 1
		}
		set segment(lastnam,export) $exportnam
	}
	Inf "EXPORTED FILES \"$exportnam\" ARE ON THE WORKSPACE"
	return 1
}

###########
# TEXTURE #
###########

#--- Texturing Head in Gettrof
#
#		NB Chancnt of output needs to be input FIRST (pre-selection!!)
#
#	For MONO output: cmd = 
#		texture simple 5	INF OUTF NOTEDATA dur pack scat 0 1 1 mingain maxgain 2 2 minp maxp 0		-a1		-p0  -s0	-rseed -w
#										X		F	V	V	X X X	F		F	  X X	V	V	X		  X		 X    X			F	X	
#		Check level																									spread
#		Normalise (to orig sound level)																			must happen		
#		THEN extract Ch 1																					 at each head event		
#		
#	For STEREO output: cmd = 
#		texture simple 5    INF OUTF NOTEDATA dur pack scat 0 1 1 mingain maxgain 2 2 minp maxp 0		-a1		-p.5 -ssprd -rseed -w
#										X					X X X				  X X			X		  X		 X   				X
#										X		F	V	V	X X X	F		F	  X X	V	V	X		  X		 X    V			F	X	
#		Check level
#		Normalise (to orig sound level)
#		Modify mixfile so HEADS are placed at centre of stereo spread
#		
#	For 8-chan ETC output: cmd = 
#		texmchan texmchan 5 INF OUTF NOTEDATA dur pack scat 0 1 1 mingain maxgain 2 2 minp maxp outchans -a1	-p1  -ssprd -rseed -w
#										X					X X X				  X X					  X		 X   				X
#										X		F	V	V	X X X	F		F	  X X	V	V	~F~		  X		 X    X			F	X	
#		Check level
#		Normalise (to orig sound level)
#		Mixfile is ".mmx" format
#
#	In all cases, output neets to be (1) Generated slightyl too long (2) CUT to duration specified
#																											
#	Params X are prefixed
#	NOTEDATA must be a standard file, for TEXTURE, with "60" in it : segment(notedata)
#
#	We also need the UBERparams
#
#	Level (V?) : Fade	: ETC
#
#	and the PREparams
#
#	rdur - duration relative to tail --> dur	V
#	ming (0-1) -->MIDIrange --> mingain			F
#	maxg (0-1) -->MIDIrange --> maxgain			F
#   mint (transposition in semitones) --> minp	V
#   maxt (transposition in semitones) --> maxp	V
#

proc Gettrof_HeadTexture {} {
	global segment evv mu prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId overload_line

	if {![CreateNotedataFile]} {
		return 0
	}
	set junk [expr srand($segment(PAR3))]				;#	Seed random variable

	set ochans  $segment(PAR0)
	set ming	$segment(PAR1)
	set ming	[expr $ming * $mu(MIDIMAX)]
	set maxg	$segment(PAR2)
	set maxg	[expr $maxg * $mu(MIDIMAX)]
	set seed	$segment(PAR3)
	set atten	$segment(PAR4)							;#	Relative level of texture end versus texture start
	set fadexp	$segment(PAR5)
	set force	$segment(PAR6)
	if {!$segment(phrase)} {
		set fdtail	$segment(PAR7)
		set tadexp	$segment(PAR8)
	}

	set n 1
	while {$n <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$n) [expr [llength $segment(control$n,TEXTURE)] - 1]
		set segment(zccnt,$n) 0
		incr n
	}

	if {$segment(phrase) || $segment(headfirst)} {
		set ishead 1
	} else {
		set ishead 0
	}
	set mm 0	;#	Index in original marklist
	set n 1		;#	Index for first head segment to texture is 1 (segments count from 1)
	set noex 1	;#	Index of mixlines output (applies to single process case)
	set j 0		;#	Indices for start and end times of segment, in marklist
	set k 1
	set z 2		;#	and end of any following tail
	set hno 1	;#	Index of 1st HEAD file (headfile names are indexed from 1)
	set tno 1	;#	Index of 1st TAIL file (tailfile names are indexed from 1)

				;#	Extended final val in marklist, replaced by true end of file

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	if {$segment(phrase)} {
		Block "TEXTURING PHRASES"
	} else {
		Block "TEXTURING HEAD SEGMENTS"
	}
	if {![MultipleProcessing]} {
		ClearNoexpands
	}

	if {[MultipleProcessing]} {
		set segment(origmixlines) $segment(mixlines)					;#	Store existing mixlines, in case we need to baktrak
	}
	set OK 1
	catch {unset segment(recycline)}
	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]
		if {$segment(phrase)} {
			set hfnam [GetFilenameInMixlineCorrespondingToCurrentSegment $n]
			if {![DoSegmentDurParse $hfnam]} {
				UnBlock
				return 0
			}
			set taildur $segment(itemdur)						;#	segment(itemdur) = output of "DoSegmentDurParse"
		} else {
			set ritebase [lindex $marks $k]						;#	Tail start (used to cals "taildur" later
		}

		if {$ishead} {

			if {$segment(multiproccnt) && ([lindex $segment(actionlist) $n] == 0)} {
				incr n											;#	IF no action required								
				incr j											;#	Skip to next segment
				incr k
				incr z
				incr hno
				incr mm
				if {!$segment(phrase)} {						;#	Phrases always flagged as heads
					set ishead [expr !$ishead]
				}
				continue
			}

			if {[MultipleProcessing]} {
			;#	FIND HEAD TO BE USED (ifnam) AND FIND ITS TIME IN EXISTING MIXFILE (mixtime)

				if {![GetRecycledSegment $hno HEAD]} {			;#	This also sets the POSITION to insert the new line  = segment(recycline)
					set OK 0
					break
				}
				set ifnam $segment(iifnam)						;#	GetRecycledSegment returns "segment(iifnam)"
				set kkk $segment(recycline)						;#	The insert line is AFTER the Head line
				if {[IsPostHeadProcess]} {						;#	so, to calculate which segment has the noexpand marker
					incr kkk -1									;#	Go to the actual line of the Head
				}
				set mixtime [lindex [lindex $segment(mixlines) $kkk] 1]
				set lexlen [llength $segment(mixlines)]
				if {[GettrofIsMultiChanMix $segment(mixlines)]} {
					incr lexlen -1
				}

			} else {

			;#	PUT ORIGINAL HEAD (hfnam) INTO MIXFILE AND SPECIFY IT AS HEAD TO BE USED (ifnam)

				set hfnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
				set mixtime [lindex $marks $mm]
				if {$hno > 1}  {
					set mixtime [expr $mixtime  - $segment(SPLICE)]
				}
				set line [list $hfnam $mixtime 1 1.0]
				lappend mixlines $line							;#	In single process (not multiprocess) case
				incr noex										;#	Increase the noex index relative to the segment index (as we now have an extra line in mix)
				set ifnam $hfnam
			} 
			incr mm

			#	PARAMETER CONVERSION

			set levl	[GetParamValueFromControl $leftbase 1]
			set endgain [expr $levl * $atten]					;#	Level at end of texture-block
			set dens	[GetParamValueFromControl $leftbase 3]
			set scat	[GetParamValueFromControl $leftbase 4]
			set dntr	[GetParamValueFromControl $leftbase 5]
			set dntr	[expr 60 - $dntr]						;#	Convert from semitones to MIDI value base on 60
			set uptr	[GetParamValueFromControl $leftbase 6]
			set uptr	[expr 60 + $uptr]						;#	Convert from semitones to MIDI value base on 60
			set sprd	[GetParamValueFromControl $leftbase 7]
			set sprrate [GetParamValueFromControl $leftbase 8]


			;#	USE INFO ABOUT FOLLOWING TAIL TO DERIVE DURATION OF HEAD-TEXTURE, AND ANY SPATIAL SPREAD

			set persist [GetParamValueFromControl $leftbase 2]
			if {!$segment(phrase)} {
				if {$z <= $segment(cnt)} {							;#	If tail after final head, use info about it thus ....
					set tailend [lindex $marks $z]					;#	Tail end
					set taildur [expr $tailend - $ritebase]			;#	Tail duration
				} elseif {![info exists taildur]} {					;#	But if No tail after AND No data from previous tails, finished
					incr n
					break
				}
			}
			set texdur [expr $taildur * $persist]				;#	Duration of head texture depends on tail duration
			set texdur_ex [expr $texdur + $dens + $evv(FLTERR)]	;#	Allow for texture output finishing early

			;#	IF SPATIAL SPREAD DOES NOT BEGIN IMMEDIATELY, LOCATE WHERE IT REACHES MAX, AND CREATE BRKPNT FILE APPROPRIATELY

			if {($sprd > 0) && ($sprrate > 0)} {				;#	If spatial spreading, and it it is not immediate
				set sprend [expr $texdur * $sprrate]			;#	End of spatial spreading depends on head-texture duration
				if {![CreateSpatialSprdBrkfile $sprd $sprend $n]} {
					set OK 0									;#	USe this info to create spatial spread brkpnt datafaile	
					break
				}
				set sprd $segment(controlfil,0)					;#	and subsitute brkpntfile for fixed-value
			}

			;#	PROCEED TO GENERATE TEXTURE

			set ofnam $evv(MACH_OUTFNAME)PHF$hno$evv(SNDFILE_EXT)
			set ffnam $evv(MACH_OUTFNAME)PH$hno$evv(SNDFILE_EXT)

			;#	FIND LEVEL OF HEAD SEGMENT

			wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF HEAD SEGMENT $n"

			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			catch {unset maxsamp_line}
			set done_maxsamp 0
			lappend cmd $ifnam
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR HEAD SEGMENT $n"
				set OK 0 
				break
	   		} else {
	   			fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF HEAD SEGMENT $n"
				set OK 0
				break
			}
			set prelevel [lindex $maxsamp_line 0]	;#	Level of HEAD
			if {$prelevel <= 0.0} {
				Inf "HEAD SEGMENT $n HAS ZERO LEVEL"
				set OK 0
				break
			}
			set rqdlevel [expr $levl * $prelevel]	;#	Level we expect texture to be

			if {$force && ($prelevel < $segment(maxlev))} {
				if {[file exists $segment(othersnd)]} {
					if [catch {file delete $segment(othersnd)} zit] {
						Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd) (0)"
						set OK 0
						break
					}
				}

				;#	NORMALISE HEAD BEFORE TEXTURING

				set gain [expr $segment(maxlev)/$prelevel]
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $ifnam $segment(othersnd) $gain
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "CANNOT NORMALISE LEVEL OF HEAD SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "CANNOT RUN PROCESS TO NORMALISE HEAD SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $segment(othersnd)]} {
					Inf "NO NORMALISED HEAD SEGMENT $n CREATED"
					set OK 0
					break
				}	
				set ifnam $segment(othersnd)	

			}

			;#	SELECT APPROPRIATE TEXTURE PROGRAM, AND RUN

			switch -- $ochans {
				1 {
					set cmd [file join $evv(CDPROGRAM_DIR) texture]
					lappend cmd simple 5 $ifnam $ofnam $segment(notedata) $texdur_ex $dens $scat 0 1 1 $ming $maxg 2 2 $dntr $uptr 0 -a1 -p0 -s0 -r$seed -w
				}
				2 {
					set cmd [file join $evv(CDPROGRAM_DIR) texture]
					lappend cmd simple 5 $ifnam $ofnam $segment(notedata) $texdur_ex $dens $scat 0 1 1 $ming $maxg 2 2 $dntr $uptr 0 -a1 -p.5 -s$sprd -r$seed -w
				}
				default {
					set cmd [file join $evv(CDPROGRAM_DIR) texmchan]
					lappend cmd texmchan 5 $ifnam $ofnam $segment(notedata) $texdur_ex $dens $scat 0 1 1 $ming $maxg 2 2 $dntr $uptr $ochans -a1 -p1 -s$sprd -r$seed -w
				}
			}
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			catch {unset overload_line}

			wm title .blocker "PLEASE WAIT:        TEXTURING HEAD SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN TEXTURING PROCESS FOR HEAD SEGMENT $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "GetOverloadLine"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE TEXTURED HEAD SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO TEXTURED HEAD SEGMENT $n CREATED"
				set OK 0
				break
			}

			if {[DoSegmentDurParse $ofnam]} {
				if {$segment(itemdur) < $texdur} {
					Inf "TEXTURED HEAD SEGMENT $n TOO SHORT"
					set OK 0
					break
				}
			}

			;#	ADJUST TEXTURE LEVEL TO REQUIRED OUTLEVEL

			set attenuation 0
			if {[info exists overload_line]} {

				set attenuation [ReadTextureAttenuationInfo]

				if {$attenuation > 0} {							;#	If attenuation required
					set attenuation [expr $attenuation * $levl]		;#	Reduce level to 1, then to desired level "levl"

				;#	RERUN TEXTURE WITH BETTER LEVEL VALUE	

					if [catch {file delete $ofnam} zit] {
						Inf "CANNOT DELETE PREVIOUS TEXTURED SEGMENT $n"
						set OK 0
						break
					}
					switch -- $ochans {
						1 {
							set cmd [file join $evv(CDPROGRAM_DIR) texture]
							lappend cmd simple 5 $ifnam $ofnam $segment(notedata) $texdur_ex $dens $scat 0 1 1 $ming $maxg 2 2 $dntr $uptr 0 -a$attenuation -p0 -s0 -r$seed -w
						}
						2 {
							set cmd [file join $evv(CDPROGRAM_DIR) texture]
							lappend cmd simple 5 $ifnam $ofnam $segment(notedata) $texdur_ex $dens $scat 0 1 1 $ming $maxg 2 2 $dntr $uptr 0 -a$attenuation -p.5 -s$sprd -r$seed -w
						}
						default {
							set cmd [file join $evv(CDPROGRAM_DIR) texmchan]
							lappend cmd texmchan 5 $ifnam $ofnam $segment(notedata) $texdur_ex $dens $scat 0 1 1 $ming $maxg 2 2 $dntr $uptr $ochans -a$attenuation -p1 -s$sprd -r$seed -w
						}
					}
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					catch {unset overload_line}

					wm title .blocker "PLEASE WAIT:        RETEXTURING HEAD SEGMENT $n"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN RETEXTURING PROCESS FOR HEAD SEGMENT $n"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE RETEXTURED HEAD SEGMENT $n"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO RETEXTURED HEAD SEGMENT $n CREATED"
						set OK 0
						break
					}	
				}
			} 

			wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF TEXTURED SEGMENT $n"
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			catch {unset maxsamp_line}
			set done_maxsamp 0
			lappend cmd $ofnam
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR TEXTURED SEGMENT $n"
				set OK 0 
				break
	   		} else {
	   			fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF TEXTURED SEGMENT $n"
				set OK 0
				break
			}
			set postlevel [lindex $maxsamp_line 0]
			if {$postlevel <= 0.0} {
				Inf "TEXTURED SEGMENT $n HAS ZERO LEVEL"
				set OK 0
				break
			}
			set normalise [expr $rqdlevel/$postlevel]

			if {[file exists $segment(othersnd)]} {
				if [catch {file delete $segment(othersnd)} zit] {
					Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd) (1)"
					set OK 0
					break
				}
			}
			if [catch {file rename $ofnam $segment(othersnd)} zit] {
				Inf "CANNOT RENAME INTERMEDIATE FILE $ofnam (1)"
				set OK 0
				break
			}
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $segment(othersnd) $ofnam $normalise
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "CANNOT ADJUST LEVEL OF TEXTURED HEAD SEGMENT $n"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "CANNOT RUN PROCESS TO ALTER LEVEL OF TEXTURED HEAD SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			if {![file exists $ofnam]} {
				Inf "NO ALTERED-LEVEL HEAD SEGMENT $n CREATED"
				set OK 0
				break
			}	

			;#	FOR MONO TEXTURE, EXTRACT CHANNEL 1 FROM OUTPUT (ALL SIGNAL IS ON CHAN 1)

			if {$ochans == 1} {

				if [catch {file delete $segment(othersnd)} zit] {
					Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd) (2)"
					set OK 0
					break
				}

				if [catch {file rename $ofnam $segment(othersnd)} zit] {
					Inf "CANNOT RENAME INTERMEDIATE FILE $ofnam (2)"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 1 $segment(othersnd) 1 
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING CHANNEL 1 OF TEXTURED SEGMENT $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO EXTRACT CHANNEL 1 OF TEXTURED SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE MONO OUTPUT OF TEXTURED SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				set thisofnam [file rootname $segment(othersnd)]
				append thisofnam "_c1" $evv(SNDFILE_EXT)
				if {![file exists $thisofnam]} {
					Inf "NO MONO TEXTURED SEGMENT $n CREATED"
					set OK 0
					break
				}
				if [catch {file rename $thisofnam $ofnam} zit] {
					Inf "CANNOT RENAME INTERMEDIATE FILE $ofnam (3)"
					set OK 0
					break
				}
			}

			if [catch {file delete $segment(othersnd)} zit] {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd) (3)"
				set OK 0
				break
			}

			if [catch {file rename $ofnam $segment(othersnd)} zit] {
				Inf "CANNOT RENAME INTERMEDIATE FILE $ofnam (4)"
				set OK 0
				break
			}

			;#	CURTAIL TO EXACT SIZE
			
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			set startcurt [expr $texdur - $segment(SPLICE)]
			if {$startcurt < 0.0} {
				set startcurt 0.0
			}
			lappend cmd curtail 1 $segment(othersnd) $ofnam $startcurt $texdur 0 -t0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CURTAILING SEGMENT $n TO EXACT SIZE"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN CURTAILING PROCESS FOR SEGMENT $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE CURTAILED SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO CURTAILED SEGMENT $n CREATED"
				set OK 0
				break
			}

			;#	DO FADE IF REQUIRED

			if {$atten < 1.0} {
				catch {unset env}
				if {$fadexp != 1.0} {								;#				1.0  0.3   		raised	
					set line [list 0.0 1.0]							;#				  0.6  0.0		to pow		*diff		+endgain
					lappend env $line								;# _____ 1		 _______		______					______
					set diff [expr 1.0 - $endgain]					;#  |			 x				x			______		x
					set val [expr pow(0.6666,$fadexp)]				;#	|			 x  		    x			x
					set val [expr $val * $diff]						;#	|			   x  			  	  
					set val [expr $val + $endgain]					;# diff			   x              x			 			 x    
					set line [list [expr $texdur * 0.3333] $val]	;#	|				 x			  x			 x
					lappend env $line								;#	|				 x				x					   x  
					set val [expr pow(0.3333,$fadexp)]				;# _|___endgain		   x			x x		   x 		_____x
					set val [expr $val * $diff]						;# _____ 0		_______x		______x		_____x		______
					set val [expr $val + $endgain]					;#
					set line [list [expr $texdur * 0.6666] $val]
					lappend env $line
					set line [list $texdur $endgain]
					lappend env $line
				} else {
					set line [list 0.0 1.0]
					lappend env $line
					set line [list $texdur $endgain]
					lappend env $line
				}
				if [catch {open $segment(envfil) "w"} zit] {
					Inf "CANNOT OPEN ENVELOPE FILE TO CREATE FADE"
					set OK 0
					break
				}
				foreach line $env {
					puts $zit $line
				}
				close $zit

				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $ofnam $ffnam $segment(envfil) 
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        FADING SEGMENT $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN FADE OF SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE FADING SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ffnam]} {
					Inf "NO FADING SEGMENT $n CREATED"
					set OK 0
					break
				}

			} else {

				;#		IF NO FADE ON TEXTURE, RENAME NON-FADED TEXTURE

				if [catch {file rename $ofnam $ffnam} zit] {
					Inf "CANNOT RENAME TEXTURED SEGMENT $n FILE"
					set OK 0
					break
				}
			}

			;#		PUT TEXTURE INTO MIXFILE

			set mixtime [lindex $marks $mm]
			set line [list $ffnam $mixtime $ochans 1.0]
			if {[MultipleProcessing]} {
				set segment(mixlines) [linsert $segment(mixlines) $segment(recycline) $line]
			} else {
				lappend mixlines $line
			}
			incr hno


		} else {	;#	A TAIL

			if {$segment(multiproccnt) && ([lindex $segment(actionlist) [expr $n - 1]] == 0)} {
				incr n											;#	IF no action (on preceding head seg) required								
				incr j											;#	Skip to next segment
				incr k
				incr z
				incr tno
				incr mm
				if {!$segment(phrase)} {						;#	Phrases always flagged as heads
					set ishead [expr !$ishead]
				}
				continue
			}
			if {[info exists segment(recycprocess)]} {				;#	If recycle, Tail has been previously processed, so get the processed tail to further process.
				set tfnam $evv(MACH_OUTFNAME)PT$tno$evv(SNDFILE_EXT)	;#
			} elseif {$segment(multiproccnt)} {						;#	Whereas. if a multiprocess
				if {$fdtail >= 1.0} {								;#	IF this tail is not to be faded (by the Head-process!!)
					incr n											;#	Skip to next segment
					incr j
					incr k
					incr z
					incr tno
					incr mm
					set ishead [expr !$ishead]
					continue

				} else {											;#	ELSE tail MAY be altered by this HEAD process (via "fdtail").
																	;#	Tail COULD have been previously processed, so look for any processed-tail
					if {[file exists $evv(MACH_OUTFNAME)PT$tno$evv(SNDFILE_EXT)]} {
						set tfnam $evv(MACH_OUTFNAME)PT$tno$evv(SNDFILE_EXT)
					} else {										;#	but if not, just get dovetailed Tail
						set tfnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
					}
				}
			} else {												;#	In normal case (not recyc or multiproc) tail has only been previously dovetailed
				set tfnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
			}
			if {$fdtail < 1.0} {

			;#	DO TAIL FADE IF REQUIRED

				set zfnam $evv(MACH_OUTFNAME)TF$tno$evv(SNDFILE_EXT)
				set tendgain .1
				set taildur [expr $ritebase - $leftbase]

				catch {unset env}
				if {$tadexp != 1.0} {
					set line [list 0.0 $fdtail]						;#				  0.3  1.0		to pow		*diff	+fadestart
					lappend env $line								;# _____ 1		 _______		______		______		______
					set diff 0.9									;#  |			       x			x						x
					set val [expr pow(0.333,$fadexp)]				;#	|			       x 		    x		   x		   xx
					set val [expr $val * $diff]						;#	|			     x  		   x	  	  xx		   x	
					set val [expr $val + $fdtail]					;# diff			     x             x		  x			  x 
					set line [list [expr $taildur * 0.3333] $val]	;#	|			   x			  x			 x			  x
					lappend env $line								;#	|			   x			  x		   	 x			x
					set val [expr pow(0.666,$fadexp)]				;# _|__0.1       x			   x		   x			x
					set val [expr $val * $diff]						;# _____ 0		_x________	   x______	   x______		______
					set val [expr $val + $fdtail]
					set line [list [expr $taildur * 0.6666] $val]
					lappend env $line
					set line [list $taildur 1.0]
					lappend env $line
				} else {
					set line [list 0.0 $fdtail]
					lappend env $line
					set line [list $taildur 1.0]
					lappend env $line
				}
				if [catch {open $segment(envfil) "w"} zit] {
					Inf "CANNOT OPEN ENVELOPE FILE TO CREATE FADE"
					set OK 0
					break
				}
				foreach line $env {
					puts $zit $line
				}
				close $zit

				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $tfnam $zfnam $segment(envfil) 

				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        FADING SEGMENT $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN FADE OF SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE FADING SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $zfnam]} {
					Inf "NO FADING SEGMENT $n CREATED"
					set OK 0
					break
				}

			} else {

				set zfnam $tfnam
			}

			incr tno
			set mixtime [lindex $marks $mm]

			;#	ADD UNALTERED OR FADED TAIL TO MIX (if not recycled, always MONO)

			set line [list $zfnam $mixtime 1 1.0]
			if {[MultipleProcessing]} {
				if {[info exists segment(recycline)]} {
					incr segment(recycline)							;#	INSERTED IMMEDIATELY AFTER PROCESSED HEAD
					set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
				}
			} else {
				lappend mixlines $line
			}
			incr mm
		}
		incr n
		incr noex
		incr j
		incr k
		incr z
		if {!$segment(phrase)} {
			set ishead [expr !$ishead]
		}
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	}
	if {![DeleteAllPHFfiles]} {
		UnBlock
		return 0
	}

	if {$segment(multiproccnt)} {				;#	With multiprocess, don't mix until all processes done
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)
	} else {
		set segment(mixlines) $mixlines
	}
	if {![ExpandPhraseMix 1]} {
		Inf "CANNOT EXPAND THE SEGMENT STRING IN LINE WITH THE TIMESTRETCHING"
	} else {
		set mixlines $segment(mixlines)
	}

	;#	GENERATE NEW MARKS

	catch {unset segment(numarks)}
	catch {unset mtimes}
	foreach line $segment(mixlines) {
		lappend mtimes [lindex $line 1]
	}
	set marks [lreplace $segment(marklist) end end $segment(wavdur)]
	if {!$segment(headfirst)} {
		lappend segment(numarks) 0.0
		set marks [lrange $marks 1 end]
		set mtimes [lrange $mtimes 1 end]
	}
	foreach {h1 h2 t} $mtimes {m1 m2} $marks {				;#	M(ix)times are h1 = ORIG HEAD h2 = TEXTURED HEAD t = TAIL
		if {$h1 > 0.0} {
			set h1 [expr $h1 + $segment(SPLICE)]
		}
		if {$h2 > 0.0} {
			set h2 [expr $h2 + $segment(SPLICE)]
		}
		set headlen [expr $m2 - $m1]						;#	Original Head length	
		set h2 [expr $h1 + $headlen]						;#	Reposition 2nd mark at end of original head, and discard tail time
		lappend segment(numarks) $h1 $h2					;#	now texturedhead and tail are subsumed into tail	
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}

	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	;#	LEVEL ADJUSTING MIX

	if {![GettrofPossiblyMultichanMixdown 1]} {
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		set OK 0
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	return 1
}

#--- Get rid of intermediate PHF Files

proc DeleteAllPHFfiles {} {
	global evv	
	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)PHF*] {
		if [catch {file delete $fnam} zit] {
			Inf "FAILED TO DELETE INTERMEDIATE FILE $fnam : $zit"
			return 0
		}
	}
	return 1
}

#--- Read the attenuation info sent by "Texture" program

proc ReadTextureAttenuationInfo {} {
	global overload_line
	set attenuation 0
	set k [string first "OVERLOAD" $overload_line]
	set overload_line [string range $overload_line $k end]
	set attenuation [string range $overload_line 35 end]	;#	"0.765432"
	set attenuation [string trim $attenuation]
	set k [string first "." $attenuation]								
	incr k
	set attenuation [string range $attenuation 0 $k]		;#	"0.7"
	return $attenuation
}

#--- Create spatial spread brkpnt controlfile for texture-creation

proc CreateSpatialSprdBrkfile {spread sprend n} {
	global segment
	catch {unset lines}
	set line [list 0.0 0.0]
	lappend lines $line
	set line [list $sprend $spread]
	lappend lines $line
	if [catch {open $segment(controlfil,0) "w"} zit] {
		Inf "CANNOT OPEN BRKPOINT FILE FOR SPATIAL SPREAD FOR HEAD SEGMENT $n"
		return 0
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	return 1
}

#--- Create notedata file for texture-creation

proc CreateNotedataFile {} {
	global segment
	if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
		Inf "CANNOT DELETE PREVIOUS NOTEDATA FILE $segment(notedata)"
		return 0
	} 
	set line 60
	if [catch {open $segment(notedata) "w"} zit] {
		Inf "CANNOT OPEN NOTEDATA FILE FOR TEXTURE CREATION"
		return 0
	}
	puts $zit $line
	close $zit
	return 1
}

#--- Enter output channel count for texture

proc TextureChancnt {} {
	global segment pr_texchcnt texchcnt evv 
	set f .texchcnt
	if [Dlg_Create $f "SET TEXTURE CHANNEL COUNT OR LOAD PARAMETER PATCH" "set pr_texchcnt 0" -height 20 -borderwidth $evv(SBDR)] {

		frame $f.0
		button $f.0.s -text "Select Chancnt" -command "set pr_texchcnt 1" -width 16
		button $f.0.l -text "Load Patch"	 -command "set pr_texchcnt 2" -width 16
		button $f.0.q -text "Abandon"		 -command "set pr_texchcnt 0" -width 8
		button $f.0.h -text "Help"			 -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		label $f.00 -text "Select Number of Channels for texture OR Load parameter patch" -width 84 -fg $evv(SPECIAL)
		pack $f.00 -side top -pady 4
		frame $f.1
		radiobutton $f.1.1  -text "Mono"    -variable texchcnt -value 1  -width 8
		radiobutton $f.1.2  -text "Stereo"  -variable texchcnt -value 2  -width 8
		radiobutton $f.1.4  -text "Quad"    -variable texchcnt -value 4  -width 8
		radiobutton $f.1.5  -text "5.1"     -variable texchcnt -value 5  -width 8
		radiobutton $f.1.7  -text "7.1"     -variable texchcnt -value 7  -width 8
		radiobutton $f.1.8  -text "8 chan"  -variable texchcnt -value 8  -width 8
		radiobutton $f.1.16 -text "16 chan" -variable texchcnt -value 16 -width 8
		radiobutton $f.1.0  -text "Reset"   -variable texchcnt -value -1 -width 8 -command "set texchcnt 0"
		pack $f.1.1 $f.1.2 $f.1.4 $f.1.5 $f.1.7 $f.1.8 $f.1.16 $f.1.0 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_texchcnt 1}
		bind $f <Escape> {set pr_texchcnt 0}
	}
	set texchcnt 0
	set pr_texchcnt 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_texchcnt
	while {!$finished} {
		tkwait variable pr_texchcnt
		switch -- $pr_texchcnt {
			1 {
				if {$texchcnt <= 0} {
					Inf "NO CHANNEL COUNT SELECTED"
					continue
				}
				set segment(PAR0) $texchcnt
				set segment(par0) $texchcnt
																						;#	Number of ooutchans for texture changes
				if {[info exists segment(lasttexchans)] && ($texchcnt != $segment(lasttexchans))} {
					if {($segment(PAR0) <= 2) && ($segment(lasttexchans) > 2)} {		;#	If texture outchans changes from multichan to not
						if [info exists segment(lastcontrol7,TEXTURE)] {				;#	If last (saved) val of SPREAD
							if {[llength $segment(lastcontrol7,TEXTURE)] == 2} {		;#	 was a fixed value
								set pair1 [lindex $segment(lastcontrol7,TEXTURE) 0]		
								set val [lindex $pair1 1]					
								if {$val > 1.0} {										;#	If value now out of range
									set pair1 [lreplace $pair1 1 1 1.0]					;#	Change values to default
									set pair2 [lindex $segment(lastcontrol7,TEXTURE) 1]
									set pair2 [lreplace $pair2 1 1 1.0]
									set segment(lastcontrol7,TEXTURE) [list $pair1 $pair2]
								}
							}
						}
					} elseif {($segment(PAR0) > 2) && ($segment(lasttexchans) <= 2)} {	;#	If texture outchans changes from not-multichan to multichan
						if [info exists segment(lastcontrol7,TEXTURE)] {				;#	If last (saved) val of SPREAD
							if {[llength $segment(lastcontrol7,TEXTURE)] == 2} {		;#	 was a fixed value
								set pair1 [lindex $segment(lastcontrol7,TEXTURE) 0]		
								set val [lindex $pair1 1]					
								if {$val < 1.0} {										;#	If value now out of range
									set pair1 [lreplace $pair1 1 1 $segment(PAR0)]		;#	Change values to default
									set pair2 [lindex $segment(lastcontrol7,TEXTURE) 1]
									set pair2 [lreplace $pair2 1 1 $segment(PAR0)]
									set segment(lastcontrol7,TEXTURE) [list $pair1 $pair2]
								}
							}
						}
					}
				}
				set segment(lasttexchans) $texchcnt
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				set segment(PAR0) ""
				set segment(par0) ""
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#--- Read any "OVERLOAD" info sent by "Texture" program

proc GetOverloadLine {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages overload_line

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif {[string first OVERLOAD $line] >= 0} {
			set overload_line $line
			return
		} elseif [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		}
	}
	update idletasks
}

##########
# BOUNCE #
##########

proc Gettrof_HeadBounce {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId overload_line
 
	set dotrim	  $segment(PAR0)
	set doshrink  $segment(PAR1)
	set cutstart  $segment(PAR2)
	set overlay	  $segment(PAR3)
	set fadestart $segment(PAR4)
	set fadexp	  $segment(PAR5)

	set bouncemin 0.02			;#	Minimum size of bounced-segments, to allow for splice

	;#	PARAMS FOR READING CONTROL FILES


	set n 1
	while {$n <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$n) [expr [llength $segment(control$n,BOUNCE)] - 1]
		set segment(zccnt,$n) 0
		incr n
	}

	if {$segment(phrase) || $segment(headfirst)} {
		set ishead 1
	} else {
		set ishead 0
	}
	set n 1		;#	Index for first head segment to bounce is 1 (segments count from 1)
	set noex 1
	set j 0		;#	Indices for start and end times of segment, in marklist
	set k 1
	set hno 1	;#	Index of 1st HEAD file (headfile names are indexed from 1)
	set tno 1	;#	Index of 1st TAIL file (tailfile names are indexed from 1)

				;#	Extended final val in marklist, replaced by true end of file

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	if {$segment(phrase)} {
		Block "BOUNCING PHRASES"
	} else {
		Block "BOUNCING HEAD SEGMENTS"
	}

	if {![MultipleProcessing]} {
		ClearNoexpands											;#	Clear all flags relating to mixfile lines being immovable
	}
	if {[MultipleProcessing]} {
		set segment(origmixlines) $segment(mixlines)			;#	Store existing mixlines, in case we need to baktrak
		set multidotail 0
	}
	set OK 1
	catch {unset segment(recycline)}
	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]							;#	Head start
		if {$ishead} {

			if {$segment(multiproccnt)} {
				if {[lindex $segment(actionlist) $n] == 0} {
					incr n										;#	IF no action required								
					incr j										;#	Skip to next segment
					incr k
					incr hno
					if {!$segment(phrase)} {					;#	Phrases always flagged as heads
						set ishead [expr !$ishead]
					}
					set multidotail 0
					continue
				} else {
					set multidotail 1
				}
			}

			#	PARAMETER CONVERSION

			set bouncecnt [GetParamValueFromControl $leftbase 1]
			set step0	  [GetParamValueFromControl $leftbase 2]
			set shorten	  [GetParamValueFromControl $leftbase 3]
			set endlev	  [GetParamValueFromControl $leftbase 4]
			set levwarp	  [GetParamValueFromControl $leftbase 5]

			;#	PROCEED TO DO BOUNCE

			if {[MultipleProcessing]} {
				if {![GetRecycledSegment $hno HEAD]} {
					set OK 0
					break
				}
				set ifnam $segment(iifnam)
			} else {
				set ifnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
			}
			set ofnam $evv(MACH_OUTFNAME)PH$hno$evv(SNDFILE_EXT)

			set cmd [file join $evv(CDPROGRAM_DIR) bounce]
			lappend cmd bounce $ifnam $ofnam $bouncecnt $step0 $shorten $endlev $levwarp
			if {$doshrink} {
				lappend cmd -s$bouncemin
			} else {
				lappend cmd -s0
			}
			if {$dotrim} {
				lappend cmd -c
			}
			if {$cutstart} {
				lappend cmd -e
			}
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			catch {unset overload_line}

			if {$segment(phrase)} {
				set msg_typ	PHRASE
			} else {
				set msg_typ	"HEAD SEGMENT"
			}
			wm title .blocker "PLEASE WAIT:        BOUNCING $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN BOUNCING PROCESS FOR $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "GetOverloadLine"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE BOUNCING $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO BOUNCING $msg_typ $n CREATED"
				set OK 0
				break
			}

			;#		PUT BOUNCED-HEAD INTO MIXFILE

			set mixtime $leftbase
			set line [list $ofnam $mixtime 1 1.0]
			if {[MultipleProcessing]} {
				set line [lindex $segment(mixlines) $segment(recycline)]
				set mixtime [lindex $line 1]
				set line [lreplace $line 0 0 $ofnam]
				set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
			} else {
				set mixtime $leftbase
				set line [list $ofnam $mixtime 1 1.0]
				lappend mixlines $line
			}
			if {$overlay} {
				if {[MultipleProcessing]} {
					set no_ex [expr $segment(recycline) + 1]		;#	corresponding line found from existing mixfile : lines numbd from 0, segs from 1
					set segment(noexpand$no_ex) 1					;#	The current file will not be moved (relatively) by any "ExpandPhraseMix"
																	;#	But we're NOT adding a line
				} else {
					set segment(noexpand$noex) 1					;#	The current file will not be moved (relatively) by any "ExpandPhraseMix"
				}
			} else {

			;#	IF BOUNCED-HEAD NOT OVERLAID ON TAIL, MOVE UP LINE BY INCREASE IN DURATION CASED BY BOUNCING HEAD

				if {![DoSegmentDurParse $ofnam]} {
					Inf "FAILED TO FIND DURATION OF BOUNCED HEAD $hcnt: CANNOT REINSERT $msg_typ AFTER BOUNCING"
				} else {											;#	segment(itemdur) = duration of ofnam
					set offset [expr $segment(itemdur) - $segment(SPLICE)]
					if {![DoSegmentDurParse $ifnam]} {
						Inf "FAILED TO FIND DURATION OF ORIGINAL HEAD $hcnt: CANNOT REINSERT $msg_typ AFTER BOUNCING"
					} else {
						set offset [expr $offset - $segment(itemdur)]
						if {[MultipleProcessing]} {
							set line [lindex $segment(mixlines) $segment(recycline)]
							set line [lreplace $line 0 0 $ofnam]
							set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline)]
						} 
						set fadestart 1.0								;#	If NO overlay of tail, then no fade-up of tail
						if {[MultipleProcessing]} {						;#	Shuffle-up times of all existing data above the bounced head
							set kk [expr $segment(recycline) + 1]
							set len [llength $segment(mixlines)]		;#	If multiprocess, TEXTURE could have inserted new lines into mix (so mixfile-len > orig segment(cnt))
							while {$kk < $len} {						
								set line [lindex $segment(mixlines) $kk]
								set stttime [lindex $line 1]
								set nustttime [expr $stttime + $offset]
								set line [lreplace $line 1 1 $nustttime]
								set segment(mixlines) [lreplace $segment(mixlines) $kk $kk $line]
								incr kk
							}
						}
						set kk $k										;#	The marks refer to the original segments
						while {$kk <= $segment(cnt)} {					;#	Move all those above the bounced head up by length of xs caused by bounce unit
							set mark [lindex $marks $kk]				;#	i.e.	A		B		C		D
							set mark [expr $mark + $offset]				;#			A		bbbbB		C		D
							set marks [lreplace $marks $kk $kk $mark]
							incr kk
						}
						if {[MultipleProcessing]} {
							set thistime [lindex [lindex $segment(mixlines) $segment(recycline)] 1]
						} else {
							set thistime $leftbase
						}
					}
				}
			}
			incr hno

		} else {		;#	A TAIL

			;#	IF TAIL IS TO BE FADED-UP

			if {$segment(multiproccnt) && !$multidotail} {
				incr n												;#	IF no action required								
				incr j												;#	Skip to next segment
				incr k
				incr tno
				if {!$segment(phrase)} {							;#	Phrases always flagged as heads
					set ishead [expr !$ishead]
				}
				continue
			}

			if {$fadestart != 1.0} {
				if {[MultipleProcessing]} {
					if {![GetRecycledSegment $tno TAIL]} {
						set OK 0
						break
					}
					set ifnam $segment(iifnam)
				} else {
					set ifnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
				}
				set ofnam $evv(MACH_OUTFNAME)TF$tno$evv(SNDFILE_EXT)

				set OK2 1

				while {$OK2} {
					if {![DoSegmentDurParse $ifnam]} {
						Inf "FAILED TO FIND DURATION OF TAIL $tcnt: CANNOT DO TAIL FADE"
						set OK2 0
						break
					}
					set taildur $segment(itemdur)
					catch {unset env}
					if {$fadexp != 1.0} {								;#				0.0  0.6   		raised	
						set line [list 0.0 $fadestart]					;#				  0.3  1.0		to pow		*diff	+fadestart
						lappend env $line								;# _____ 1		 _______		______		______		______
						set diff [expr 1.0 - $fadestart]				;#  |			       x			x						x
						set val [expr pow(0.333,$fadexp)]				;#	|			       x 		    x		   x		   xx
						set val [expr $val * $diff]						;#	|			     x  		   x	  	  xx		   x	
						set val [expr $val + $fadestart]				;# diff			     x             x		  x			  x 
						set line [list [expr $taildur * 0.3333] $val]	;#	|			   x			  x			 x			  x
						lappend env $line								;#	|			   x			  x		   	 x			x
						set val [expr pow(0.666,$fadexp)]				;# _|__fadestart x			   x		   x			x
						set val [expr $val * $diff]						;# _____ 0		_x________	   x______	   x______		______
						set val [expr $val + $fadestart]
						set line [list [expr $taildur * 0.6666] $val]
						lappend env $line
						set line [list $taildur 1.0]
						lappend env $line
					} else {
						set line [list 0.0 $fadestart]
						lappend env $line
						set line [list $taildur 1.0]
						lappend env $line
					}
					if {[catch {open $segment(envfil) "w"} zit]} {
						Inf "CANNOT OPEN ENVELOPE FILE TO CREATE UPFADE"
						set OK2 0
						break
					} else {
						foreach line $env {
							puts $zit $line
						}
						close $zit
					}
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $ifnam $ofnam $segment(envfil) 

					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        UPFADING SEGMENT $n"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN UPFADE OF SEGMENT $n"
						catch {unset CDPidrun}
						set OK2 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE UPFADING SEGMENT $n"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK2 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO UPFADING SEGMENT $n CREATED"
						set OK2 0
						break
					}
					break
				}
				if {!$OK2} {
					set ofnam $ifnam		;#	Use the non-upfaded tail
				}
				if {[MultipleProcessing]} {
					PhraseLineReinsert [expr $segment(recycline) + 1] $ofnam 0			;#	lines count from 0, segs from 1
				} else {
					set mixtime $leftbase
					set line [list $ofnam $mixtime 1 1.0]
					lappend mixlines $line
				}
			;#	NO UPFADE: WITH MULTIPROC (MIXFILE ALREADY EXISTS) NO ACTION REQUIRED: 
			;#	BUT WITH SINGLE PROCESS INSERT THE TAIL IN THE MIXFILE,

			} else {
				if {![MultipleProcessing]} {
					set ofnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
					set mixtime $leftbase
					set line [list $ofnam $mixtime 1 1.0]
					lappend mixlines $line
				}
			}
			incr tno
		}
		incr n
		incr noex
		incr j
		incr k
		if {!$segment(phrase)} {
			set ishead [expr !$ishead]
		}
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	}
	if {$segment(multiproccnt)} {				;#	With multiprocess, don't mix until all processes done
		if {!$overlay} {
			UpdateFilesAddedInfo				;#	New file has been added to mixlisting. Update list of added files
		}
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)
	} else {
		set segment(mixlines) $mixlines
	}
	if {$segment(expand) && !$segment(noexpand)} {
		if {![ExpandPhraseMix 1]} {
			Inf "CANNOT EXPAND THE SEGMENT STRING IN LINE WITH THE TIMESTRETCHING"
		} else {
			set mixlines $segment(mixlines)
		}
	}	
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	;#	LEVEL ADJUSTING MIX

	if {![GettrofPossiblyMultichanMixdown 1]} {
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		set OK 0
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	return 1
}

#--- Enter bounced-element cut style for Bounce

proc BounceCutstyle {} {
	global segment pr_bnccut bnccut evv 
	set f .bnccut
	if [Dlg_Create $f "SET CUT-OR-TRIM STYLE FOR BOUNCE" "set pr_bnccut 0" -height 20 -borderwidth $evv(SBDR)] {

		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_bnccut 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_bnccut 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_bnccut 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		checkbutton $f.1.1  -text "Trim elements"   -variable segment(par0) -width 16
		checkbutton $f.1.2  -text "Shrink Elements" -variable segment(par1) -width 16
		checkbutton $f.1.3  -text "Keep End"		-variable segment(par2) -width 16
		checkbutton $f.1.4  -text "Bounce Over"		-variable segment(par3) -width 16
		checkbutton $f.1.0  -text "Reset"			-variable bnccut -width 16 -command "set pr_bnccut 3"
		pack $f.1.1 $f.1.2 $f.1.3 $f.1.4 $f.1.0 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_bnccut 1}
		bind $f <Escape> {set pr_bnccut 0}
	}
	InitBounceFlags
	set pr_bnccut 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_bnccut
	while {!$finished} {
		tkwait variable pr_bnccut
		switch -- $pr_bnccut {
			1 {
				if {$segment(par3)} {				;#	Bouncing head overlays the following tail
					set segment(pv1)  8.0  			;#	Larger Number of bounces
					set segment(pv3)  0.92			;#	Bounce accel ratio slower
					set segment(pv4)  0.0			;#	Final Level to zero
					set segment(par4) 0.0			;#	Tail starts at zero
					set segment(par5) 2.0			;#	and fades up
					set segment(dflt4,BOUNCE) 0  	;#	Tail fade-up from
					set segment(dflt5,BOUNCE) 2  	;#	Tail fade-up exponent
					set segment(paramstt,BOUNCE) 4	;#	Tail fade params can be varied
				} else {
					set segment(pv1) 5.0  			;#	Small Number of bounces
					set segment(pv3) 0.8			;#	Accel ratio, faster
					set segment(pv4) 0.15			;#	Final Level not all way to zero
					set segment(par4) 1.0			;#	Tail starts at normal level
					set segment(par5) 1.0
					set segment(dflt4,BOUNCE) 1 	;#	Tail fade-up from
					set segment(dflt5,BOUNCE) 1 	;#	Tail fade-up exponent
					set segment(paramstt,BOUNCE) 6	;#	Tail fade params are fixed (readonly)
				}
				set segment(PAR3) $segment(par3)	;#	This PARam must be set here, as not set later
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			3 {
				set bnccut 0
				InitBounceFlags
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#########################################################
# INTERNAL MANAGEMENT AND PROCESSING OF SEGMENT MIXFILE #
#########################################################

#------ Parse the file (using cdparse) merely to find the Duration

proc DoSegmentDurParse {fnam} {
	global CDPid parse_error infile_rejected propslist props_got is_input_parse evv segment
	set parse_error 0
	set props_got 0
	set infile_rejected 0
	set is_input_parse 0

	set CDPid 0
	set cmd [file join $evv(CDPROGRAM_DIR) cdparse]
	set zzfnam [OmitSpaces $fnam]
	lappend cmd $zzfnam 0
	if [catch {open "|$cmd"} CDPid] {
		catch {unset CDPid}
		return 0
	} else {
		set propslist ""
		fileevent $CDPid readable AccumulateFileProps
	}
	vwait props_got
	if {$parse_error || $infile_rejected || ![info exists propslist] || ([llength $propslist] < 1)} {
		return 0
	}
	set segment(itemdur) [lindex $propslist 11]
	return 1
}

#--- Find the head or tail segment required for reprocessing when segment-processed file is recycled

proc GetRecycledSegment {cnt typ} {
	global segment evv
	set msg $typ
	set segment(doublehead) 0
	switch -- $typ {
		HEAD {
			set iifnam $evv(MACH_OUTFNAME)HF$cnt$evv(SNDFILE_EXT)			;#	Look first for Head affected by accenting
			if {[file exists $iifnam]} {
				set k 0
				foreach origline $segment(mixlines) {
					set mix_snd [lindex $origline 0]
					if {[string match $mix_snd $iifnam]} {
						set iichan [lindex $origline 2]
						break
					}
					incr k
				}
			} else {
				set iifnam $evv(DFLT_OUTNAME)HH$cnt$evv(SNDFILE_EXT)		;#	Then look for original Head
				if {[GetTrofSrcfileIsInMixlist $iifnam] < 0} {
					set iifnam $evv(MACH_OUTFNAME)PH$cnt$evv(SNDFILE_EXT)	;#	If Original Head no longer in mixlines, Look for PROCESSED head from any previous HEAD PROCESS
					foreach origline $segment(mixlines) {					;#	Head may have already been modified and become stereo or multichannel, so search for channelcnt
						set k 0
						set mix_snd [lindex $origline 0]
						if {[string match $mix_snd $iifnam]} {
							set iichan [lindex $origline 2]
							break
						}
						incr k
					}
				} else {													;#	Original Head IS in mixlines: but is there ALSO a processed head ??
					if {[TailProcessMayMergeHeadToTail $segment(process)]} {;#	This is a TAIL process (like TUNED) but it is ALSO looking for a HEAD
						set gotlines {}										
						set k 0
						foreach origline $segment(mixlines) {
							set mix_snd [lindex $origline 0]
							if {[string match $mix_snd $iifnam]} {			;#	Get chancnt of orig head (should always be mono)
								set chan_cnt [lindex $origline 2]
								set found [list $k $iifnam $chan_cnt]
								lappend gotlines $found 
								break
							}
							incr k
						}
						set iifnam $evv(MACH_OUTFNAME)PH$cnt$evv(SNDFILE_EXT)	;#	Look also for head PROCESSED from any previous HEAD PROCESS
						set k 0													;#	Head may have already been modified and become stereo or multichannel, so search for details!!
						foreach origline $segment(mixlines) {
							set mix_snd [lindex $origline 0]
							if {[string match $mix_snd $iifnam]} {
								set chan_cnt [lindex $origline 2]
								set found [list $k $iifnam $chan_cnt]
								lappend gotlines $found 
								break
							}
							incr k
						}
						if {[llength $gotlines] > 1} {							;#	If more than one HEAD line associated with tail
							set segment(doublehead) 1							;#	Flag this
							set got_line [lindex $gotlines 0]
							set k0		 [lindex $got_line 0]
							set iifnam0  [lindex $got_line 1]
							set iichan0  [lindex $got_line 2]
							set got_line [lindex $gotlines 1]
							set	k1		 [lindex $got_line 0]
							set iifnam1  [lindex $got_line 1]
							set iichan1  [lindex $got_line 2]
							if {$k1 < $k0} {									;#	iifnam name of file in the line earlier in the mix
								set iifnam  $iifnam1							;#	iifnam name of the later file
								set iichan	$iichan1
								set iifnam2 $iifnam0
								set iichan2 $iichan0
							} else {
								set iifnam  $iifnam0
								set iichan	$iichan0
								set iifnam2 $iifnam1
								set iichan2 $iichan1
							}
						} else {
							set iifnam [lindex [lindex $gotlines 0] 1]
							set iichan [lindex [lindex $gotlines 0] 2]
						}
					} else {
						set iichan 1		;#	HEAD process looking for a HEAD, which is always, initially MONO
					}
				}
			} 
		}
		TAIL {
			set iifnam $evv(MACH_OUTFNAME)PT$cnt$evv(SNDFILE_EXT)		;#	Look for tail PROCESSED from any previous TAIL PROCESS (Head process affecting a following TAIL)
			set iichan 1	;#	TAILS ARE ALWAYS MONO!!!!!
			if {![file exists $iifnam]} {
				set iifnam $evv(MACH_OUTFNAME)TF$cnt$evv(SNDFILE_EXT)	;#	Look for tail WITH FADE from any previous HEAD PROCESS (Tail process)
			}
			if {![file exists $iifnam]} {
				set iifnam $evv(MACH_OUTFNAME)TD$cnt$evv(SNDFILE_EXT)	;#	Otherwise, use original (Dovetailed) tail
			}
		}
	}
	if {![file exists $iifnam]} {
		Inf "CANNOT FIND $msg SEGMENT $cnt ($iifnam) TO REPROCESS"
		return 0
	}
	if {![info exists segment(mixlines)]} {
		Inf "CANNOT FIND ORIGINAL MIX LINES TO MODIFY"
		return 0
	}
	set k 0
	set gotline -1														;#	Having selected, file, now get its lineno in mixfile, as "segment(recycline)"
	foreach origline $segment(mixlines) {
		set mix_snd [lindex $origline 0]
		if {[string match $mix_snd $iifnam]} {
			set gotline $k
			break
		}
		incr k
	}
	if {$gotline < 0} {
		set msg "$msg SEGMENT $cnt NOT PRESENT IN ORIGINAL MIX LINES (LOOKING FOR $iifnam)\nMIXLINES\n"
		foreach line $segment(mixlines) {
			append msg "$line\n"
		}
		Inf $msg
		return 0
	}
	set segment(iifnam)	$iifnam
	set segment(iichan)	$iichan
	if {$segment(doublehead)} {
		set segment(iifnam2) $iifnam2
		set segment(iichan2) $iichan2
	}
	if {[IsPostHeadProcess]} {
		incr gotline										;#	Processed Head inserted AFTER actual Head
		set segment(recycline) $gotline						;#	Processed Head/Tail REPLACES original Head/Tail
		set segment(recycinsert) 1
	} else {
		set segment(recycline) $gotline						;#	Processed Head/Tail REPLACES original Head/Tail
		set segment(recycinsert) 0
	}
	return 1
}

#--- Has 2nd process run to completion

proc RecycleProcessCompleted {} {
	global segment
	if {![info exists segment(origmixlines)] || ![info exists segment(mixlines)]} {
		return 0
	}
	foreach origline $segment(origmixlines) line $segment(mixlines) {
		foreach origitem $origline item $line {
			if {![string match $origitem $item]} {
				return 0
			}
		}
	}
	return 1
}

#--- Did last process output a multichannel mix

proc GettrofsMixChans {} {
	global segment
	if {![info exists segment(mixlines)]} {
		Inf "PROGRAMMING PROBLEM 2"
	}
	set line [lindex $segment(mixlines) 1]
	set k [string first ":" $line]
	if {$k < 0} {										;#	 NOT multichan
		set chancnt 1
		foreach line $segment(mixlines) {				;#	Get channel outcnt (MONO or STEREO) by looking at all lines
			set chans [lindex $line 2]
			if {$chans > $chancnt} {
				set chancnt $chans
			}
			if {$chans == 1} {							;#	A mono line NOT panned to hard left, assumes a stereo output
				if {[llength $line] > 4} {
					set pos [string trim [lindex $line 4]]
					if {[IsNumeric $pos]} {
						if {$pos != -1} {
							set chancnt 2
						}
					} elseif {![string match $pos "L"]} {
						set chancnt 2
					}
				}
			}
		}
		return $chancnt	
	}
	set line [lindex $segment(mixlines) 0]				;#	Get channel outcnt from 1st line
	return [lindex $line 0]
}

;#--- Insert a line from a 2nd process into an existing mixfile from previous process

proc InsertReprocessedGetTrofLineIntoMixfile {line} {
	global segment

	if {$segment(recycinsert)} {						;#	Either INSERT a line (where head is NOT replaced, in head-processing process)		
		set segment(mixlines) [linsert $segment(mixlines) $segment(recycline) $line]
	} else {											;#	or REPLACE existing line (where Head or Tail is replaced by processed version)
		set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
	}
}

##############################################################
# REMEMBER PARAMETER VALUES; SAVE AND LOAD PARAMETER PATCHES #
##############################################################

#--- On entering params, remember them

proc RememberGettrofParams {} {
	global segment
	set n 0
	set forget 0
	set len $segment(paramcnt,$segment(process))
	while {$n < $len} {
		if {$segment(process) == "BOUNCE"} {
			if {($n == 3) && !$segment(PAR3)} {			;#	If the bounce overlay flag is NOT set, the bounce does NOT overlay the following tail
				set forget 1							;#	and params4+5 (for tail fade params) are pre-fixed (not user accessible)
			}											;#	so we DON'T want to remember these!!!	
			if {(($n == 4) || ($n == 5)) && $forget} {
				incr n
				continue
			}
		}
		set segment(lastpar$n,$segment(process)) $segment(PAR$n)
		incr n
	}
}

#--- After successfully running process, remember possibly-tvariable param

proc RememberGettrofVORFParams {} {
	global segment
	if {[IsTimestretchProcess $segment(process)]} {
		set segment(lastcontrol1,$segment(process)) $segment(control1,$segment(process))
	} else {
		set len $segment(vparams_cnt,$segment(process))
		if {$len > 0} {
			set n 1 
			while {$n <= $len} {
				set nam "lastcontrol$n,$segment(process)"
				if {[info exists segment(control$n,$segment(process))]} {
					set segment($nam) $segment(control$n,$segment(process))
				}
				incr n
			}
		}
	}
}

#--- On leaving window (with "conclude") Save values of any params

proc SaveGettrofParamData {} {
	global segment wstk evv

	set savelist {}
	set lines {}
	foreach segment(process) $segment(processes) {
		catch {unset nulines}
		set line "#$segment(process)"
		lappend nulines $line
		if {[IsTimestretchProcess $segment(process)]} {
			set len 1
		} else {
			if {![info exists segment(vparams_cnt,$segment(process))]} {
				continue
			}
			set len $segment(vparams_cnt,$segment(process))
		}
		if {$len == 0} {
			lappend nulines 0
		} else {
			if {![info exists segment(lastcontrol1,$segment(process))]} {
				continue
			}
			lappend nulines $len
			set n 1
			while {$n <= $len} {
				set nam "lastcontrol$n,$segment(process)"
				lappend nulines $segment($nam)
				incr n
			}
		}
		if {![info exists segment(paramcnt,$segment(process))]} {
			lappend nulines 0
		} else {
			set len $segment(paramcnt,$segment(process))
			if {$len == 0} {
				lappend nulines 0
			} else {
				lappend nulines $len
				set n 0
				if {![info exists segment(lastpar0,$segment(process))]} {
					continue
				}
				while {$n < $len} {
					set nam "lastpar$n,$segment(process)"
					if {![info exists segment($nam)]} {
						lappend nulines ""
					} else {
						lappend nulines $segment($nam)
					}
					incr n
				}
			}
		}
		set lines [concat $lines $nulines]
		lappend savelist $segment(process)
	}
	if {[llength $savelist] <= 0} {
		return
	}
	set fnam [file join $evv(URES_DIR) segmentpars$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {file copy $fnam $segment(bakup)} zit] {
			set msg "CANNOT BACKUP PRE-EXISTING SEGMENTATION DATA FILE $fnam: OVERWRITE IT ???"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return
			}
		}
	}
	if [catch {open $fnam "w"} zit] {
		Inf "CANNOT OPEN FILE $fnam TO SAVE SEGMENTATION PARAMETER DATA"
		if {[file exists $segment(bakup)]} {
			if [catch {file rename $segment(bakup) $fnam} zit] {
				set msg "CANNOT RESTORE EXISTING SEGMENTATION PARAM DATA !!!\n\n"
				append msg "THIS IS IN THE TEMPORARY FILE $SEGMENT(bakup)\n\n"
				append msg "TO SAVE THIS DATA, DO ~~NOT~~ CLOSE THE LOOM\n\n"
				append msg "BUT PROCEED (OUTSIDE THE LOOM) TO RENAME THE FILE (TO [file tail $fnam])\n"
				append msg "AND PLACE IT IN YOUR $evv(URES_DIR) DIRECTORY"
				Inf $msg
			}
			return
		}
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	catch {file delete $segment(bakup)}
}

#--- On opening window Load values written from last run

proc LoadGettrofParamData {} {
	global segment evv
	set fnam [file join $evv(URES_DIR) segmentpars$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "CANNOT OPEN FILE $fnam TO READ SEGMENTATION PARAMETER DATA FROM LAST SESSION"
		return
	}
	set cnt 0
	set controls 0
	set params 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string match [string index $line 0] "#"]} {
			set process [string range $line 1 end]
			catch {unset controlcnt}
			catch {unset paramcnt}
			set controlstt 100000
			set controlend -1
			set paramstt   100000
			set paramend   -1
		} elseif {![info exists controlcnt]} {							;#	Control data counts from 1
			set controlcnt $line
			if {$controlcnt} {
				set controlstt [expr $cnt + 1]
				set controlend [expr $cnt + $controlcnt]
				set n 1
			}
		} elseif {($cnt >= $controlstt) && ($cnt <= $controlend)} {
			set segment(lastcontrol$n,$process) $line
			incr n
		} elseif {![info exists paramcnt]} {							;#	Fixed-param data counts from 0
			set paramcnt $line
			if {$paramcnt} {
				set paramstt [expr $cnt + 1]
				set paramend [expr $cnt + $paramcnt]
				set n 0
			}
		} elseif {($cnt >= $paramstt) && ($cnt <= $paramend)} {
			if {[llength $line] > 0} {
				set segment(lastpar$n,$process) $line
			}
			incr n
		}
		incr cnt
	}
	close $zit
}

#--- Load a parameter patch

proc GettrofsLoadParamPatch {seq} {
	global segment wstk evv pr_getropload shrhy
	set segment(dopload) 0
	set patchdir [file join $evv(URES_DIR) "segpatches"]
	if {![file exists $patchdir]} {
		if {$seq} {
			Inf "NO PROCESS SEQUENCE INFORMATION TO LOAD"
		} else {
			Inf "NO PARAMETER INFORMATION TO LOAD"
		}
		return 0
	}
	catch {unset patchlist}
	if {$seq} {
		set seqlen [llength $segment(marklist)]		;#	== number of segments + 1
		incr seqlen -1
		foreach fnam [glob -nocomplain [file join $patchdir *]] {				;#	Patches are named e.g. "SEQn_mypatch.cdp"
			set pnam [file rootname [file tail $fnam]]							;#	Find patchfile name "SEQn_mypatch"
			if {[string first "SEQ" $pnam] == 0} {								;#	Find patches which are sequences "SEQn"
				lappend patchlist $pnam
			}
		}
	} else {
		foreach fnam [glob -nocomplain [file join $patchdir *]] {				;#	Patches are named e.g. "TEXTURE_mypatch.cdp"
			set pnam [file rootname [file tail $fnam]]							;#	Find patchfile name "TEXTURE_mypatch"
			set k [string first "_" $pnam]										;#	Find process patch relates to "TEXTURE"
			incr k -1
			set pproc [string range $pnam 0 $k]									
			if {[string match $pproc $segment(process)]} {						;#	IF this is same as current process
				incr k 2														;#	Get patchname "mypatch"
				set pnam [string range $pnam $k end]							;#	And list it
				lappend patchlist $pnam
			}
		}
	}
	if {![info exists patchlist]} {
		if {$seq} {
			Inf "NO SEQUENCE PATCHES EXIST"
		} else {
			Inf "NO \"$segment(process)\" PARAMETER PATCHES EXIST"
		}
		return 0
	}
	set f .getropload
	if [Dlg_Create $f "LOAD PARAMETER PATCH" "set pr_getropload 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Patch"		-command "set pr_getropload 1" -width 10
		button $f.0.d -text "Delete Patch"  -command "set pr_getropload 2" -width 10
		button $f.0.q -text "Abandon"		-command "set pr_getropload 0" -width 10
		pack $f.0.s -side left 
		pack $f.0.q $f.0.d -side right -padx 12
		pack $f.0 -side top -fill x -expand true
		frame $f.2
		label $f.2.tit -text "Existing Patches for $segment(process)" -fg $evv(SPECIAL)
		Scrolled_Listbox $f.2.ll -width 40 -height 24 -selectmode single
		pack $f.2.tit $f.2.ll -side top
		pack $f.2 -side top -fill both -expand true
		wm resizable $f 0 0
		bind $f <Return> {set pr_getropload 1}
		bind $f <Escape> {set pr_getropload 0}
	}
	if {$seq} {
		wm title . "LOAD PROCESS SEQUENCE PATCH"
		$f.2.tit config -text "Existing Process Sequences"
	} else {
		wm title . "LOAD PARAMETER PATCH"
		$f.2.tit config -text "Existing Patches for $segment(process)"
	}
	$f.2.ll.list delete 0 end
	foreach pnam $patchlist {
		$f.2.ll.list insert end $pnam
	}
	if {$seq} {
		set msg2 "SEQUENCE"
	} else {
		set msg2 "PATCH"
	}
	set pr_getropload 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_getropload
	while {!$finished} {
		tkwait variable pr_getropload
		switch -- $pr_getropload {
			1 {
				if {[.getropload.2.ll.list index end] == 1} {
					set i 0
				} else {
					set i [.getropload.2.ll.list curselection]
					if {![info exists i] || ($i < 0)} {
						Inf "NO $msg2 SELECTED"
						continue
					}
				}
				set patchname [.getropload.2.ll.list get $i]
				if {$seq} {
					set pfnam [file join $patchdir $patchname$evv(CDP_EXT)]
				} else {
					set pfnam $segment(process)
					append pfnam "_" $patchname
					set pfnam [file join $patchdir $pfnam$evv(CDP_EXT)]
				}
				if [catch {open $pfnam "r"} zit] {
					Inf "CANNOT OPEN $msg2 FILE $pfnam TO READ $msg2 DATA"
					continue
				}
				if {$seq} {
					while {[gets $zit line] >= 0} {
						set segment(actionlist) $line
						break
					}
					close $zit
					set k [string first "_" $patchname]					;#	"SEQn_myname"
					incr k -1											;#	"SEQn_"
					set j 3												;#	"SEQn"
					set thisseqlen [string range $patchname $j $k]		;#	   "n"

					if {$thisseqlen > $seqlen} {

						set msg "THIS PROCESS-SEQUENCE IS LONGER THAN THE NUMBER OF MARKED SEGMENTS IN THE SOUND.\n\n"
						append msg "PROCEED ANYWAY ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
						incr thisseqlen -1
						set segment(actionlist) [lrange $segment(actionlist) 0 $thisseqlen]

					} elseif {$thisseqlen < $seqlen} {

						set msg "THIS PROCESS-SEQUENCE IS SHORTER THAN THE NUMBER OF MARKED SEGMENTS IN THE SOUND.\n\n"
						append msg "PROCEED ANYWAY ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
						while {$thisseqlen < $seqlen} {
							lappend segment(actionlist) 0					;#	If loaded sequence shorter than no. of segs to process
							incr thisseqlen									;#	pad actionlist with zeros (no-actions)	
						}
					}
				} else {
					set cnt 0
					while {[gets $zit line] >= 0} {
						switch -- $cnt {
							0	{
								;#	Skip process name
							}
							1 {
								set pcnt $line
								set n 1
								while {$n <= $pcnt} {
									gets $zit line
									set segment(control$n,$segment(process)) $line
									incr n
								}
								switch -- $segment(process) {
									"HPITCH" -
									"PITCH" {
										set segment(pitches) $segment(control1,PITCH)
									}
									"DELRING" {
										set segment(pitches) $segment(control1,DELRING)
									}
									"TUNED" {
										set segment(chords) $segment(control1,TUNED)
									}
								}
							}
							default {
								set pcnt $line
								set n 0
								while {$n < $pcnt} {
									gets $zit line
									set segment(PAR$n) $line
									incr n
								}
								if {$segment(process) == "RETIME"} {		;#	The retimestyle was saved as PAR1 when patch was saved
									set segment(PAR0) $segment(retimestyle)	;#	But we have SET retimestyle already
									set segment(par0) $segment(PAR0)		;#	so reset it after patch loaded
								}
								break
							}
						}
						incr cnt
					}
					if {$segment(process) == "SHRHYTHM"} {					;#	For shrhythm get the additional info, "MM" and "scansion"
						set shrhy(MM) $segment(PAR0)	
						set shrhy(accentuation) $segment(PAR3)	
						gets $zit line
						set shrhy(scansion) $line
						gets $zit line
						set shrhy(accents) $line
						close $zit
						set lastval ""
						set minvalstep 1000000
						set lastval [lindex $segment(control1,$segment(process)) 0] 
						foreach val	[lrange $segment(control1,$segment(process)) 1 end] {
							set valstep [expr $val - $lastval]
							if {$valstep < $minvalstep} {
								set minvalstep $valstep
							}
							set lastval $val
						}
						catch {unset shrhy(qsteps)}
						set lastval [lindex $segment(control1,$segment(process)) 0] 
						foreach val	[lrange $segment(control1,$segment(process)) 1 end] {
							set qstep [expr int(round(($val - $lastval)/$minvalstep))]
							lappend shrhy(qsteps) $qstep
							set lastval $val
						}
						set segment(numarks) $segment(control1,$segment(process))
						set lastval [lindex $segment(numarks) end]
						set lastval [expr $lastval + 10.0]
						set segment(numarks) [lreplace $segment(numarks) end end $lastval]
					}
					catch {close $zit}
					if {$segment(process) == "TEXTURE"} {
						if {$segment(phrase)} {
							set segment(paramcnt,TEXTURE) 7
						} else {
							set segment(paramcnt,TEXTURE) 9
						}
					}
					RememberGettrofParams
					HideFixedParamEntryBoxes
					set segment(didparload) 1
					ResetGetSyllabTrofs CONTROL_DATA_SAVED_GOTO_RUN_PROCESS
					set segment(returnkeystate) R_RUN
				}
				set finished 1
			}
			2 {
				set i [.getropload.2.ll.list curselection]
				if {![info exists i] || ($i < 0)} {
					Inf "NO PATCH SELECTED FOR DELETION"
					continue
				}
				set patchname [.getropload.2.ll.list get $i]
				set msg "ARE YOU SURE YOU WANT TO DELETE PATCH $patchname ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if {$seq} {
					set pfnam [file join $patchdir $patchname$evv(CDP_EXT)]
				} else {
					set pfnam $segment(process)
					append pfnam "_" $patchname
					set pfnam [file join $patchdir $pfnam$evv(CDP_EXT)]
				}
				if [catch {file delete $pfnam} zit] {
					Inf "CANNOT DELETE PATCH $patchname"
					continue
				}
				.getropload.2.ll.list delete $i
			}
			0 {
				set finished 1
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#--- Save a parameter patch

proc GettrofsSaveParamPatch {seq} {
	global segment wstk evv pr_getropsave shrhy

	if {$seq} {
		set seqlen [llength $segment(multiflag)]								;#	Number of process-actions = number of segments
	} else {
		if {!([info exists segment(lastcontrol1,$segment(process))] || [info exists segment(lastpar0,$segment(process))] || [info exists segment(lastpar1,$segment(process))])} {
			Inf "NO PARAMETER INFORMATION TO SAVE"
			return
		}
	}
	set patchdir [file join $evv(URES_DIR) "segpatches"]

	if {![file exists $patchdir]} {
		if [catch {file mkdir $patchdir} zit] {
			Inf "PROBLEM CREATING SEGMENTATION-PATCH DIRECTORY $patchdir"
			return 0
		}
	}
	set f .getropsave
	if [Dlg_Create $f "SAVE PARAMETER PATCH" "set pr_getropsave 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Name"		-command "set pr_getropsave 1" -width 10
		button $f.0.d -text "Delete Patch"  -command "set pr_getropsave 2" -width 10
		button $f.0.q -text "Abandon"		-command "set pr_getropsave 0" -width 10
		pack $f.0.s -side left 
		pack $f.0.q $f.0.d -side right -padx 12
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Patch Name  "
		entry $f.1.e -textvariable segment(patchname) -width 40
		pack $f.1.ll $f.1.e -side left -padx 2
		pack $f.1 -side top -fill x -pady 2
		frame $f.2
		label $f.2.tit -text "Existing Patches for $segment(process)" -fg $evv(SPECIAL)
		Scrolled_Listbox $f.2.ll -width 40 -height 24 -selectmode single
		pack $f.2.tit $f.2.ll -side top
		pack $f.2 -side top -fill both -expand true
		wm resizable $f 0 0
		bind $f <Return> {set pr_getropsave 1}
		bind $f <Escape> {set pr_getropsave 0}
	}
	if {$seq} {
		wm title . "SAVE SEQUENCE OF PROCESSES"
		$f.2.tit config -text "Existing Process Sequences"
		$f.2.ll.list delete 0 end
		foreach fnam [glob -nocomplain [file join $patchdir *]] {				;#	Patches are named e.g. "SEQn_mypatch.cdp"
			set pnam [file rootname [file tail $fnam]]							;#	Find patchfile name "SEQn_mypatch"
			if {[string first "SEQ" $pnam] == 0} {								;#	IF this is a SEQUENCE-patch, list its full (root)name
				$f.2.ll.list insert end $pnam
			}
		}
	} else {
		wm title . "SAVE PARAMETER PATCH"
		$f.2.tit config -text "Existing Patches for $segment(process)"
		$f.2.ll.list delete 0 end
		foreach fnam [glob -nocomplain [file join $patchdir *]] {				;#	Patches are named e.g. "TEXTURE_mypatch.cdp"
			set pnam [file rootname [file tail $fnam]]							;#	Find patchfile name "TEXTURE_mypatch"
			set k [string first "_" $pnam]										;#	Find process patch relates to "TEXTURE"
			incr k -1
			set pproc [string range $pnam 0 $k]									
			if {[string match $pproc $segment(process)]} {						;#	IF this is same as current process	
				incr k 2														;#	Get patchname "mypatch"
				set pnam [string range $pnam $k end]							;#	And list it
				$f.2.ll.list insert end $pnam
			}
		}
	}
	set pr_getropsave 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_getropsave
	while {!$finished} {
		tkwait variable pr_getropsave
		switch -- $pr_getropsave {
			1 {
				if {[string length $segment(patchname)] <= 0} {
					Inf "NO PATCH NAME ENTERED"
					continue
				}
				if {![ValidCDPRootname $segment(patchname)]} {
					Inf " "INVALID PATCH NAME"
					continue
				}
				set patchname [string tolower $segment(patchname)]
				if {$seq} {
					set pnam "SEQ"
					append pnam $seqlen "_" $patchname
					set listed_patchname $pnam
				} else {
					set pnam $segment(process)
					append pnam "_" $patchname
					set listed_patchname $patchname
				}
				set fnam [file join $patchdir $pnam$evv(CDP_EXT)]
				if {[file exists $fnam]} {
					set msg "A PATCH WITH THE NAME $listed_patchname ALREADY EXISTS: OVERWRITE IT ???"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					if [catch {file delete $fnam} zit] {
						Inf "CANNOT DELETE THE EXISTING PATCH $listed_patchname"
						continue
					}
					set i [LstIndx $listed_patchname .getropsave.2.ll.list]
					if {$i > 0} {
						.getropsave.2.ll.list delete $i
					}
				}
				catch {unset lines}
				if {$seq} {
					set msg2 "SEQUENCE"
					set line $segment(multiflag)
					lappend lines $line
				} else {
					set msg2 "PARAMETER"
					set line "#$segment(process)"
					lappend lines $line
					if {[IsTimestretchProcess $segment(process)]} {
						set len 1
					} elseif {$segment(process) == "SHRHYTHM"} {
						set len 1
					} else {
						set len $segment(vparams_cnt,$segment(process))
					}
					if {$len == 0} {
						lappend lines 0
					} else {
						lappend lines $len
						set n 1
						while {$n <= $len} {
							set nam "lastcontrol$n,$segment(process)"
							lappend lines $segment($nam)
							incr n
						}
					}
					set len $segment(paramcnt,$segment(process))
					if {$len == 0} {
						lappend lines 0
					} else {
						lappend lines $len
						set n 0
						while {$n < $len} {
							set nam "lastpar$n,$segment(process)"
							lappend lines $segment($nam)
							incr n
						}
					}
					if {$segment(process) == "SHRHYTHM"} {	;#	For shrhythm save the additional info, "scansion" and "accents"
						lappend lines $shrhy(scansion)
						lappend lines $shrhy(accents)
					}
				}
				if [catch {open $fnam "w"} zit] {
					Inf "CANNOT OPEN FILE $fnam TO SAVE $msg2 DATA"
					continue
				}
				foreach line $lines {
					puts $zit $line
				}
				close $zit
				if {$seq} {
					Inf "SAVED PROCESS SEQUENCE $patchname"
				} else {
					Inf "SAVED PATCH $patchname FOR PROCESS $segment(process)"
				}
				set finished 1
			}
			2 {
				set i [.getropsave.2.ll.list curselection]
				if {![info exists i] || ($i < 0)} {
					Inf "NO PATCH SELECTED FOR DELETION"
					continue
				}
				set patchname [.getropsave.2.ll.list get $i]
				set msg "ARE YOU SURE YOU WANT TO DELETE PATCH $patchname ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if {$seq} {
					set pfnam [file join $patchdir $patchname$evv(CDP_EXT)]
				} else {
					set pfnam $segment(process)
					append pfnam "_" $patchname
					set pfnam [file join $patchdir $pfnam$evv(CDP_EXT)]
				}
				if [catch {file delete $pfnam} zit] {
					Inf "CANNOT DELETE PATCH $patchname"
					continue
				}
				.getropsave.2.ll.list delete $i
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-- Put Either last val used, or default val, in fixedval box

proc PresetGettrofFixedValBox {} {
	global segment
	if {$segment(process) == "SQZBOX"} {
		set segment(fixed) $segment(pv$segment(vp))
		return
	}
	if {[info exists segment(lastcontrol$segment(vp),$segment(process))] && ([llength $segment(lastcontrol$segment(vp),$segment(process))] == 2)} {
		set segment(fixed) [lindex [lindex $segment(lastcontrol$segment(vp),$segment(process)) 0] 1]
	} elseif {[info exists segment(pv$segment(vp))]} {
		set segment(fixed) $segment(pv$segment(vp))
	}
}

proc SetupGettrofParamEntryBoxes {} {
	global segment evv
	$segment(doentrybox) config -text "USE PARAMS"   -state normal -command "set pr_gettrofs PARAM_ENTRY"
	$segment(dodefaults) config -text "Get Defaults" -state normal -command "GettrofParamDefaultsAndVariableParamRanges 0"
	$segment(doprevious) config -text "Get Previous" -state normal -command "GettrofPreviousParamVals"
	$segment(doclearing) config -text "Clear"		 -state normal -command "GettrofClearParamVals"
	$segment(paramshelp) config -text "Help"		 -state normal -command "GettrofParamsHelp" -bg $evv(HELP) -bd 2
	$segment(paramsload) config -text "Load Patch"	 -state normal -command "GettrofsLoadParamPatch 0"
	set segment(doentry) 0
	set segment(dodflts) 0
	set segment(doplast) 0
	set segment(doclear) 0
	set segment(dopload) 0
}

#--- Delete variables associated with multiprocess

proc GettrofMultiCancel {} {
	global segment
	set segment(multiproccnt)   0	;#	Total count of mltiple processes for HEADS and TAILS
	catch {unset segment(docnt)}
	catch {unset segment(mixlines)}
	catch {unset segment(recycline)}
	catch {unset segment(recycinsert)}
	catch {unset segment(multiflag)}
	catch {unset segment(multiaction)}
	catch {unset segment(previousmixchan)}
	set segment(multichan) 0
	catch {unset segment(recycprocess)}
	catch {unset segment(multiproclist)}
	catch {unset segment(multido)}
}

#--- Delete variables associated with multiprocess

proc GettrofTextCancel {} {
	global segment
	catch {unset segment(intext)}
	catch {unset segment(outext)}
}

#--- Final mixdown of segments, in case where this might be multichannel

proc GettrofPossiblyMultichanMixdown {inbloksegment} {
	global segment evv prg_dun set prg_abortd simple_program_messages CDPidrun maxsamp_line done_maxsamp CDPmaxId

	set ochans [GettrofsMixChans]
	set gain 1.0
	set OK 1
	set OK2 0
	set OK3 0
	set mixcnt 1

	# NB ASSUMES Block ALREADY IN PLACE !!

	if {!$inbloksegment} {
		Block "PLEASE WAIT:        RECOMBINING (MODIFIED) SEGMENTS"
	}
	while {!$OK2} {
		if {[file exists $segment(outfnamplay)]} {
			if [catch {file delete $segment(outfnamplay)} zit] {
				Inf "CANNOT DELETE PREVIOUS MIX OUTPUT (pass $mixcnt)"
				set OK 0
				break
			}
		}
		if {$ochans <= 2} {
			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd mix $segment(mixfil) $segment(outfnamplay) -g$gain
		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $segment(mixfil) $segment(outfnamplay) -g$gain
		}
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        RECOMBINING (MODIFIED) SEGMENTS (pass $mixcnt)"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN SEGMENT RECOMBINATION MIX (pass $mixcnt)"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SOUND BY RECOMBINING SEGMENTS (pass $mixcnt)"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $segment(outfnamplay)]} {
			Inf "NO FILE OF RECOMBINED SEGMENTS CREATED (pass $mixcnt)"
			set OK 0
			break
		}
		if {$OK3} {
			break
		}
		wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF OUTPUT MIX (pass $mixcnt)"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $segment(outfnamplay)
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' (pass $mixcnt)"
			set OK 0
			break
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF OUTPUT MIX (pass $mixcnt)"
			set OK 0
			break
		}
		set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
		if {$maxoutsamp <= 0.0} {
			Inf "OUTPUT MIX (pass $mixcnt) HAS ZERO LEVEL"
			set OK 0
			break
		}
		if {$maxoutsamp > 0.98} {										;#	Gain close to 1.0 indicates output has probably overloadad
			set gain [expr $gain * 0.1]									;#	Reduce gain by factor of ten and re-run

		} elseif {($maxoutsamp < $segment(maxlev)) && ($gain < 1.0)} {	;#	If gain has been adjusted, but maxsamp now below max
			set gain [expr ($segment(maxlev)/$maxoutsamp) * $gain]		;#	reset gain to give a maximal non-distorted output
			set OK3 1													;#	and force loop-exit after next pass
		} else {
			set OK2 1													;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
		}
		incr mixcnt
	}
	if {!$inbloksegment} {
		UnBlock
	}
	if {!$OK} {
		return 0
	}
	return 1
}

#--- Final mixdown of segments, in MONO case

proc GettrofMixdown {blocked} {
	global segment evv prg_dun set prg_abortd simple_program_messages CDPidrun

	;#	NB ASSUMES A Block ALREADY IN PLACE !!

	if {!$blocked} {
		Block "PLEASE WAIT:        RECOMBINING (MODIFIED) SEGMENTS"
	}
	set OK 1
	while {$OK} {
		set cmd [file join $evv(CDPROGRAM_DIR) submix]
		lappend cmd mix $segment(mixfil) $segment(outfnamplay)
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        RECOMBINING (MODIFIED) SEGMENTS"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN SEGMENT RECOMBINATION MIX"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SOUND BY RECOMBINING SEGMENTS"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $segment(outfnamplay)]} {
			Inf "NO FILE OF RECOMBINED SEGMENTS CREATED"
			set OK 0
			break
		}
		break
	}
	if {!$OK} {
		return 0
	}
	return 1
}

#--- Convert format of existing Trofseg mixfile from mix to mmx

proc ConvertGettrofMixToMultichanMix {ochans} {
	global segment
	set n 0
	foreach line $segment(mixlines) {
		set chans [lindex $line 2]			;#	Find channel count of each line
		set gain  [lindex $line 3]			;#	Find gain of orig line
		set line  [lrange $line 0 2]
		switch -- $chans {	
			1 {								;#	Force mono material to multichan format
				set linend [list "1:1" $gain]
				set line [concat $line $linend]
			}
			2 {								;#	Force stereo material to multichan format : e.g. 8chan  L R  goes to - - - 8 - 2 - - -
				set linend  [list "1:$ochans" $gain 2:2 $gain]
				set line [concat $line $linend]
			}
		}
		set segment(mixlines) [lreplace $segment(mixlines) $n $n $line]
		incr n
	}
	set line [list $ochans]
	set segment(mixlines) [concat $line $segment(mixlines)]
}

#--- Convert format of existing Trofseg mixfile from mono to stereo

proc ConvertGettrofMonoMixToStereo {} {
	global segment
	set n 0
	foreach line $segment(mixlines) {		;#	Force all existing mono lines into centre of stereo spread
		lappend line "C"
		set segment(mixlines) [lreplace $segment(mixlines) $n $n $line]	
		incr n
	}
}

#--- Set up to run each process of a multiprocess, and to do the final mix

proc RunProcessInAMultiProcess {} {
	global segment pr_gettrofs evv

	if {$segment(phrase)} {
		set segment(headfirst) 1
	}
	if {![info exists segment(docnt)] || ($segment(docnt) <= 0)} {
	;#	INITIALISE THE MULTIPROCESS THEN RUN THE 1ST PROCESS
 		ResetProcessBlock $pr_gettrofs
		if {!$segment(phrase)} {
			if {![SegmentSound 1]} {			;#	Automatically dovetails Tail segments
				return 0
			}
		}
		if {$segment(phrase)} {
			if {![info exists segment(mixlines)]} {
				Inf "Initial Phrase Mix no longer exists"
				return 0
			}
		} elseif {![ConstructSegtrofMultiPremix]} {
			return 0
		}
		if {![GettrofMultiInit_and_Mnemonics MULTIPROC]} {			;#	Establish listing of processes to run, plus segments they process
			return 0
		}
		set suprcnt 0
		foreach dud $segment(multido) {			;#	Phrase "expansion" is overridden if tails or phrases suppressed
			if {[lindex $dud 0] == "SUPPRESS"} {
				incr suprcnt
				set segment(noexpand) 1
				if {!$segment(phrase)} {
					break
				}
			}
		}
		if {$segment(phrase) && ($suprcnt == [llength $segment(multido)])} {
			Inf "ALL SEGMENTS SUPPRESSED  : SILENT OUTPUT!!"
			return 0
		}
		if {![DoMulti]} {
			return 0
		}
		return 1
	}
	if {$segment(docnt) < $segment(multiproccnt)} {

	;#	RUN THE OTHER PROCESSES

		if {![DoMulti]} {
			return 0
		}
		return 1

	} else {

	;#	DO THE FINAL MIXDOWN

		DoWholeFileTransformCutsAndSubstituteInMixfile

		if {($segment(multiproccnt) == 1) && ($segment(process) == "TEXTURE")} {		;#	If only texture run, expand it
			if {![ExpandPhraseMix 1]} {
				Inf "CANNOT EXPAND THE TEXTURE SEGMENT(S)"
			}
		} elseif {$segment(expand) && !$segment(noexpand)} {
			if {![ExpandPhraseMix 0]} {
				Inf "CANNOT EXPAND THE SEGMENT STRING IN LINE WITH ANY TIMESTRETCHING"
			}
		}
		DoMultichanCorrection
		if [catch {open $segment(mixfil) "w"} zit] {
			Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
			return 0
		}
		foreach line $segment(mixlines) {
			puts $zit $line
		}
		close $zit

		if {![GettrofPossiblyMultichanMixdown 0]} {
			return 0
		}
		if {![ConvertTrofSndOutputToOtherFormat]} {
			return 0
		}
		set segment(returnkeystate) R_PLAY
		RememberGettrofVORFParams
		unset segment(docnt)
		ResetGetSyllabTrofs OUTPUT_CREATED
		return 1
	}
	return 0
}

#-- For a combination of processes, construct a prior mix from unprocessed HEADs and TAILs.

proc ConstructSegtrofMultiPremix {} {
	global segment evv
	catch {unset segment(mixlines)}
	if {$segment(headfirst)} {
		set ishead 1
	} else {
		set ishead 0
	}
	set mm 0	;#	Index in original marklist
	set n 1		;#	Index for first head segment to texture is 1 (segments count from 1)
	set hno 1	;#	Index of next HEAD file (headfile names are indexed from 1))
	set tno 1	;#	Index of next TAIL file (tailfile names are indexed from 1)

				;#	Extended final val in marklist, replaced by true end of file

	while {$n <= $segment(cnt)} {
		if {$ishead} {
			set fnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
			incr hno
			if {![file exists $fnam]} {
				Inf "HEAD FILE $fnam DOES NOT EXIST"
				return 0
			}
			set mixtime [lindex $segment(marklist) $mm]
			incr mm
			if {$n > 1}  {
				set mixtime [expr $mixtime - $segment(SPLICE)]		;#	All HEADs, except a HEAD at file start, have a pre-splice-in, so enter mix a splicetime ealier
			}
		} else {
			set fnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
			incr tno
			if {![file exists $fnam]} {
				Inf "DOVETAILED TAIL FILE $fnam DOES NOT EXIST"
				return 0
			}
			set mixtime [lindex $segment(marklist) $mm]
			incr mm
		}
		set mixline [list $fnam $mixtime 1 1.0]
		lappend segment(mixlines) $mixline
		set ishead [expr !$ishead]
		incr n
	}
	set segment(previousmixchan) 1		;#	Intial mix is mono
	return 1
}

#---- (1) Set up the processes to be used for each segment, for a multiprocess procedure:
#---- (2) Display and edit mnemonics associated with segments in segmented-sound
#---- (3) Create new sounds by reordering segments

proc GettrofMultiInit_and_Mnemonics {typ} {
	global segment pr_gtmulti wstk evv readonlybg shrhy
	set segment(multiflag) {}											;#	Set up a selected-processes-list of length segment(cnt)
	set segment(reordercnt) 0
	switch -- $typ {
		ENTERTEXT -
		ENTERSCAN -
		ARTICULATION {
			if {![info exists segment(cnt)]} {
				set segment(cnt) [expr [llength $segment(marklist)] - 1]
			}
		} 
		REORDER {
			if {$segment(cnt) == 0} {
				set segment(cnt) [expr [llength $segment(marklist)] - 1]
			}
			ReorderedSegsInvisible
		} 
		MULTIPROC {
			set n 0
			while {$n < $segment(cnt)} {								;#	For a multiprocess
				lappend segment(multiflag) -1							;#	Initially each segment is NOT processed: (flag with "-1")
				incr n
			}
		}
	}
	set f .gtmulti
	if [Dlg_Create $f "SPECIFY TAIL PROCESSES" "set pr_gtmulti 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Tails Done" -command "set pr_gtmulti SPECIFY_TAIL_PROCESSES" -width 12 -bg $evv(EMPH)
		button $f.0.ld -text "Load Seq"  -command "set pr_gtmulti LOAD_PROCESS_SEQUENCE" -width 12
		button $f.0.sv -text "Save Seq"  -command "set pr_gtmulti SAVE_PROCESS_SEQUENCE" -width 10
		button $f.0.cc -text "Clear"	 -command "set pr_gtmulti CLEAR_PROCESS_DISPLAY" -width 10
		button $f.0.h  -text "Help" -bd 2 -command {} -bg $evv(HELP)
		button $f.0.p  -text "View"  -state normal -bd 2 -command "set segment(exportsegs) 2; DisplaySegmentation" -bg $evv(SNCOLOR)
		checkbutton $f.0.ch  -variable segment(htj) -text "" -width 30 -state disabled -command {}
		checkbutton $f.0.xx  -variable segment(htp) -text "" -width 30 -state disabled -command {}
		set segment(htj) 0
		set segment(htp) 0
		button $f.0.q -text "Abandon"    -command "set pr_gtmulti 0" -width 10
		pack $f.0.s $f.0.ld $f.0.sv $f.0.cc $f.0.h $f.0.p $f.0.ch $f.0.xx -side left -padx 2
		pack $f.0.q -side right
		frame $f.1
		frame $f.1.1
		frame $f.1.2
		set framecnt 1
		set n 0
		while {$n < $segment(cnt)} {									;#	Set up an array of entry boxes to enter process mnemonic for each segment
			if {[expr $n % 24] == 0} {
				if {$n > 0} {
					pack $ff  -side top -fill x -expand true
				}
				set ff [frame $f.1.1.$framecnt]
				incr framecnt											;#	In disabled state, entry boxes are black
			}															;#	(with white foreground to display any previously selected process mnemonic)
			set fff [frame $ff.$n]										;#	While segment-associated-text entry boxes are readonly (not editable)			
			set segment(sn$n) [label $fff.ll$n -text "" -width 5]
			set segment(me$n) [entry $fff.e$n -textvariable segment(mproc$n) -width 5 -state disabled -disabledbackground [option get . background {}] -disabledforeground white -bd 0]
			set segment(tx$n) [entry $fff.t$n -textvariable segment(mtext$n) -width 5 -state readonly -readonlybackground [option get . background {}]] 
			pack $segment(sn$n) $segment(me$n) $segment(tx$n) -side top
			ForceVal $segment(me$n) ""
			pack $fff -side left
			incr n
		}
		pack $ff -side top -fill x -expand true

		set n 0															;#	Setup the process-entry buttons (initally TAIL processes only)
		foreach process $segment(processes) nam $segment(procnames) {
			if {[CannotBeUsedInAMultiProcess $process]} {					;#	NO Timestretch processes visible/available
				set segment(mp$n) [button $f.1.2.$n -text "" -command {} -state disabled -bd 0 -width 18]
			} else {
				set segment(mp$n) [button $f.1.2.$n -text "" -command {} -bd 0 -width 18]
			}
			pack $segment(mp$n) -side top 
			incr n
		}
		set segment(prentrycnt) $n
		pack $f.1.2 $f.1.1 -side left
		frame $f.2

		set framecnt 1
		set n 0
		while {$n < $evv(MAX_REORDERED_SEGS)} {							;#	Set up an array of (invisible) entry boxes 
			if {[expr $n % 24] == 0} {									;#	to accept reordered segment-mnemonics, if reordering is called.
				if {$n > 0} {
					button $ff.dum -width 20 -bd 0 -command {} -state disabled	;#	KLUDGE to get window wide enough!!!!
					pack $ff.dum -side left
					pack $ff  -side top -fill x -expand true
				}
				set ff [frame $f.2.$framecnt]
				incr framecnt
			}
			set segment(re$n) [entry $ff.r$n -textvariable segment(rtext$n) -width 5 -state readonly -readonlybackground [option get . background {}] -bd 0]
			bind $segment(re$n) <ButtonRelease-1> {}
			ForceVal $segment(re$n) ""
			pack $segment(re$n) -side left
			incr n
		}
		pack $ff  -side top -fill x -expand true
		incr framecnt													;#	KLUDGE to get window high enough!!!!
		set ff [frame $f.2.$framecnt -height 100]
		pack $ff  -side top -fill x -expand true
		pack $f.0 $f.1 $f.2 -side top -fill x -expand true
		wm resizable $f 0 0
		bind $f <Escape> {set pr_gtmulti 0}
	}
	set segment(reordercnt) 0
	switch -- $typ {
		ENTERTEXT {
			if {[info exists segment(intext)]} {
				wm title .gtmulti "EDIT THE TEXT MNEMONICS"
				.gtmulti.0.s config -text "Edit Text" -command "set pr_gtmulti EDIT_TEXT_MNEMONICS"
				bind $f <Return> {set pr_gtmulti EDIT_TEXT_MNEMONICS}
			} else {
				wm title .gtmulti "ENTER TEXT MNEMONICS FOR SEGMENTS"
				.gtmulti.0.s config -text "Enter Text" -command "set pr_gtmulti ENTER_TEXT_MNEMONICS"
				bind $f <Return> {set pr_gtmulti ENTER_TEXT_MNEMONICS}
			}
			.gtmulti.0.ld config -text "Sound View"  -command "set segment(exportsegs) 2; DisplaySegmentation" -state normal -bd 2 -bg $evv(SNCOLOR)
			.gtmulti.0.sv config -text "Restore"	 -command "set pr_gtmulti RESTORE_TEXT_MNEMONICS"
			.gtmulti.0.cc config		   -command "set pr_gtmulti CLEAR_TEXT_MNEMONICS"
			.gtmulti.0.h  config -command "GettrofReorderHelp ENTERTEXT"
			set segment(htj) 0
			set segment(htp) 0
			.gtmulti.0.ch  config -text "" -state disabled -command {}
			.gtmulti.0.xx  config -text "" -state disabled -command {}
			set n 0 
			while {$n < $segment(cnt)} {
				$segment(sn$n) config -text "[expr $n+1]"					;#	Show numbering of segments
				set segment(mproc$n) ""										;#	Hide process-mnemonic entryboxes		
				$segment(me$n) config -state disabled -bd 0 -disabledbackground [option get . background {}]
				$segment(tx$n) config -bd 2 -state normal					;#	Display text entry boxes
				if {[info exists segment(intext)]} {						;#	with associated text-mnemonics, if they exist
					set segment(mtext$n) [lindex $segment(intext) $n]
				} else { 
					set segment(mtext$n) ""
				}
				ForceVal $segment(tx$n) $segment(mtext$n)					;#	Allow focus, and focus change, on text-entry boxes
				bind $segment(tx$n) <ButtonRelease-1> "focus $segment(tx$n)"
				bind $segment(tx$n) <Down>  {}
				bind $segment(tx$n) <Up> {}
				bind $segment(tx$n) <Down>	"MoveGettrofFocus $n 0 1 0"
				bind $segment(tx$n) <Up> "MoveGettrofFocus $n 1 1 0"
				bind $segment(me$n) <ButtonRelease-1> {}					;#	(only)
				bind $segment(me$n) <Down>  {}
				bind $segment(me$n) <Up> {}
				bind $segment(me$n) <Delete> {}
				bind $segment(tx$n) <Delete> {}
				incr n
			}			
			set n 0
			foreach process $segment(processes) nam $segment(procnames) {
				if {![CannotBeUsedInAMultiProcess $process]} {	;#	NO Process-buttons visible/available
					set segment(mproc$n) ""
					$segment(mp$n) config -text "" -state disabled -bd 0 -command {}
				}
				incr n
			}
			focus $segment(tx0)
			MultiBinds $f 0
		}
		ENTERSCAN {
			wm title .gtmulti "ENTER TEXT SCANSION"
			.gtmulti.0.s config -text "Save Scansion" -command "set pr_gtmulti ENTER_TEXT_SCANSION"
			bind $f <Return> {set pr_gtmulti ENTER_TEXT_SCANSION}
			.gtmulti.0.ld config -text "Load Scansion"  -command {set pr_gtmulti [LoadScansion]} -bd 2 -state normal
			.gtmulti.0.sv config -text ""  -command {} -state disabled -bd 0 -background [option get . background {}]
			.gtmulti.0.cc config -text "Clear All" -command "set pr_gtmulti CLEAR_PROCESS_DISPLAY" -bd 2 -state normal
			.gtmulti.0.h  config -command "GettrofReorderHelp ENTERSCAN"
			set segment(htj) 0
			set segment(htp) 0
			.gtmulti.0.ch  config -text "" -state disabled -command {} -bd 0
			.gtmulti.0.xx  config -text "" -state disabled -command {} -bd 0
			set n 0 
			while {$n < $segment(cnt)} {
				$segment(sn$n) config -text "[expr $n+1]"					;#	Show numbering of segments
				set segment(mproc$n) ""										;#	Hide scansion-mnemonic values
				$segment(me$n) config -bd 2 -state normal					;#	Display scansion entry boxes
				$segment(tx$n) config -bd 2 -state readonly					;#	Display text entry boxes
				if {[info exists segment(intext)]} {						;#	with associated text-mnemonics, if they exist
					set segment(mtext$n) [lindex $segment(intext) $n]
				} else { 
					set segment(mtext$n) ""
				}
				ForceVal $segment(tx$n) $segment(mtext$n)					;#	Allow focus, and focus change, on text-entry boxes
				bind $segment(tx$n) <ButtonRelease-1> "focus $segment(tx$n)"
				bind $segment(tx$n) <Down>  {}
				bind $segment(tx$n) <Up> {}
				bind $segment(me$n) <ButtonRelease-1> {}					;#	(only)
				bind $segment(me$n) <Down>	"MoveGettrofFocus $n 0 0 1"
				bind $segment(me$n) <Up> "MoveGettrofFocus $n 1 0 1"
				bind $segment(me$n) <Delete> {}
				bind $segment(tx$n) <Delete> {}
				incr n
			}			
			set n 0
			foreach sciconam $segment(scicon_names)  {
				$segment(mp$n) config -text "$sciconam" -command "SetScanEntryInFocus $n" -state normal -bd 2
				incr n
			}
			$segment(mp$n) config -text "CLEAR" -command "SetScanEntryInFocus -1" -state normal -bd 2
			incr n
			while {$n < $segment(prentrycnt)} {
				$segment(mp$n) config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				incr n
			}
			focus $segment(me0)
			MultiBinds $f 0
		}
		ARTICULATION {
			wm title .gtmulti "ENTER TEXT ARTICUATION"
			.gtmulti.0.s config -text "Use Artic" -command "set pr_gtmulti ENTER_TEXT_ARTIC"
			bind $f <Return> {set pr_gtmulti ENTER_TEXT_ARTIC}
			.gtmulti.0.ld config -text "Load Artic"  -command LoadArticulation -bd 2 -state normal
			.gtmulti.0.sv config -text ""  -command {} -state disabled -bd 0 -background [option get . background {}]
			.gtmulti.0.cc config -text "Clear All" -command "set pr_gtmulti CLEAR_PROCESS_DISPLAY" -bd 2 -state normal
			.gtmulti.0.h  config -command "GettrofReorderHelp ARTICULATION"
			set segment(htj) 0
			set segment(htp) 0
			.gtmulti.0.ch  config -text "subdue tics"   -variable segment(rtc,ticsub) -state normal -command {} -bd 2
			.gtmulti.0.xx  config -text "subdue glossi" -variable segment(rtc,glosub) -state normal -command {} -bd 2
			set n 0 
			while {$n < $segment(cnt)} {
				$segment(sn$n) config -text "[expr $n+1]"					;#	Show numbering of segments
				set segment(mproc$n) ""										;#	Hide articulation-mnemonic values
				$segment(me$n) config -bd 2 -state normal					;#	Display articulation entry boxes
				$segment(tx$n) config -bd 2 -state readonly					;#	Display text entry boxes
				if {[info exists segment(intext)]} {						;#	with associated text-mnemonics, if they exist
					set segment(mtext$n) [lindex $segment(intext) $n]
				} else { 
					set segment(mtext$n) ""
				}
				ForceVal $segment(tx$n) $segment(mtext$n)					;#	Allow focus, and focus change, on text-entry boxes
				bind $segment(tx$n) <ButtonRelease-1> "focus $segment(tx$n)"
				bind $segment(tx$n) <Down>  {}
				bind $segment(tx$n) <Up> {}
				bind $segment(me$n) <ButtonRelease-1> {}					;#	(only)
				bind $segment(me$n) <Down>	"MoveGettrofFocus $n 0 0 1"
				bind $segment(me$n) <Up> "MoveGettrofFocus $n 1 0 1"
				bind $segment(me$n) <Delete> {}
				bind $segment(tx$n) <Delete> {}
				bind $segment(me$n) <Control-Down>	"ArticulationNumberIncr $n 0"
				bind $segment(me$n) <Control-Up> "ArticulationNumberIncr $n 1"
				incr n
			}			
			set n 0
			foreach articnam $segment(articon_names)  {
				if {[string first "Cntrl" $articnam] == 0} {
					$segment(mp$n) config -text "$articnam" -command "SetArticEntryInFocus -1" -state normal -bd 2	;#	NUMERIC ENTRY (tied to CntrlUp/Dn)
					set jj $n
				} else {
					$segment(mp$n) config -text "$articnam" -command "SetArticEntryInFocus $n" -state normal -bd 2
				}
				incr n
			}
			$segment(mp$n) config -text "CLEAR" -command "SetScanEntryInFocus -1" -state normal -bd 2
			incr n
			while {$n < $segment(prentrycnt)} {
				$segment(mp$n) config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
				incr n
			}
			focus $segment(me0)
			MultiBinds $f 0
		}
		MULTIPROC {
			if {$segment(phrase)} {
				wm title .gtmulti "SPECIFY THE PHRASE PROCESSES"
				.gtmulti.0.s config -text "Done" -command "set pr_gtmulti SPECIFY_PHRASE_PROCESSES" -state normal -bd 2
				.gtmulti.0.ld config -text "Load Seq"  -command "set pr_gtmulti LOAD_PROCESS_SEQUENCE"  -state normal -bd 2 -bg [option get . background {}]
				.gtmulti.0.sv config -text "Save Seq"  -command "set pr_gtmulti SAVE_PROCESS_SEQUENCE" -state normal -bd 2
				.gtmulti.0.cc config				   -command "set pr_gtmulti CLEAR_PROCESS_DISPLAY"
				.gtmulti.0.h  config -command "GettrofReorderHelp MULTIPROC"
				set segment(htj) 0
				set segment(htp) 0
				.gtmulti.0.ch  config -text "" -state disabled -command {}
				.gtmulti.0.xx  config -text "" -state disabled -command {}
				bind $f <Return> {set pr_gtmulti SPECIFY_PHRASE_PROCESSES}

				set n 0																;#	Prime the process-mnemonic entry boxes:
				while {$n < $segment(cnt)} {										;#	All boxes are active
					$segment(sn$n) config -text $n								;#	Number the boxes
					$segment(me$n) config -state normal -bd 2 -disabledbackground black
																				;#	Enable ALL entry-boxes,
					set segment(mproc$n) ""										;#	Clear process-entry box,		
					bind $segment(me$n) <ButtonRelease-1> "focus $segment(me$n)"
					bind $segment(me$n) <Down>  "MoveGettrofFocus $n 0 0 1"
					bind $segment(me$n) <Up> "MoveGettrofFocus $n 1 0 1"
					bind $segment(tx$n) <ButtonRelease-1> "focus $segment(me$n)"
					bind $segment(me$n) <Delete> "$segment(me$n) delete 0 end"
					bind $segment(tx$n) <Delete> "$segment(me$n) delete 0 end"
					incr n
				}
				set n 0 
				while {$n < $segment(cnt)} {
					$segment(tx$n) config -state readonly -readonlybackground  [option get . background {}]
					if {[info exists segment(intext)]} {							;#	Display any associated text, if it exists
						$segment(tx$n) config -bd 2 -state readonly
						set segment(mtext$n) [lindex $segment(intext) $n]
					} else {
						$segment(tx$n) config -bd 0 -state readonly
						set segment(mtext$n) ""
					}
					ForceVal $segment(tx$n) $segment(mtext$n)
					incr n
				}
				set n 0
				set thisstate normal												;#	Initially in TAIL processes: set normal
				foreach process $segment(processes) nam $segment(procnames) {
					if {![CannotBeUsedInAMultiProcess $process] && ![string match $process RETIME] && ![string match $process TRANSFER]} {	;#	NO Timestretch processes visible/available NOR "Retime"
						$segment(mp$n) config -text $nam -state normal -bd 2 -command "SetEntryInFocus $n"
					}
					incr n
				}
				focus $segment(me0)
				MultiBinds $f 0
			} else {
				wm title .gtmulti "SPECIFY THE TAIL PROCESSES"
				.gtmulti.0.s config -text "Tails Done" -command "set pr_gtmulti SPECIFY_TAIL_PROCESSES" -state normal -bd 2
				.gtmulti.0.ld config -text "Load Seq"  -command "set pr_gtmulti LOAD_PROCESS_SEQUENCE"  -state normal -bd 2 -bg [option get . background {}]
				.gtmulti.0.sv config -text "Save Seq"  -command "set pr_gtmulti SAVE_PROCESS_SEQUENCE" -state normal -bd 2
				.gtmulti.0.cc config				   -command "set pr_gtmulti CLEAR_PROCESS_DISPLAY"
				.gtmulti.0.h  config -command "GettrofReorderHelp MULTIPROC"
				set segment(htj) 0
				set segment(htp) 0
				.gtmulti.0.ch  config -text "" -state disabled -command {}
				.gtmulti.0.xx  config -text "" -state disabled -command {}
				bind $f <Return> {set pr_gtmulti SPECIFY_TAIL_PROCESSES}

				set n 0 
				set tcnt 1
				set m 1
				if {$segment(headfirst)} {
					set m 0	
				}																	;#	Prime the process-mnemonic entry boxes:
				while {$n < $segment(cnt)} {										;#	Only Tail boxes are active (initially)
					if {[IsEven $m]} {
						$segment(sn$n) config -text ""								;#	Clear numbering of Head boxes,
						set segment(mproc$n) ""										;#	Clear Head-segment process-entry box,
						$segment(me$n) config -state disabled -bd 2 -disabledbackground black
																					;#	Disable (and therefore Black out) the head boxes,
						bind $segment(me$n) <ButtonRelease-1> {}					;#	and don't allow head boxes to be focused on.
						bind $segment(me$n) <Down>  {}
						bind $segment(me$n) <Up> {}
						bind $segment(tx$n) <ButtonRelease-1> {}
						bind $segment(me$n) <Delete> {}
						bind $segment(tx$n) <Delete> {}
					} else {
						$segment(sn$n) config -text $tcnt							;#	Number the tail boxes
						$segment(me$n) config -state normal -bd 2 -disabledbackground black
																					;#	Enable the tail entry-boxes,
						set segment(mproc$n) ""										;#	Clear Tail-segment process-entry box,		
						incr tcnt													;#	and allow focus on them.
						bind $segment(me$n) <ButtonRelease-1> "focus $segment(me$n)"
						bind $segment(me$n) <Down>  "MoveGettrofFocus $n 0 0 0"
						bind $segment(me$n) <Up> "MoveGettrofFocus $n 1 0 0"
						bind $segment(tx$n) <ButtonRelease-1> "focus $segment(me$n)"
						bind $segment(me$n) <Delete> "$segment(me$n) delete 0 end"
						bind $segment(tx$n) <Delete> "$segment(me$n) delete 0 end"
					}
					incr n
					incr m 
				}
				set n 0 
				while {$n < $segment(cnt)} {
					$segment(tx$n) config -state readonly -readonlybackground [option get . background {}]
					if {[info exists segment(intext)]} {							;#	Display any associated text, if it exists
						$segment(tx$n) config -bd 2 -state readonly
						set segment(mtext$n) [lindex $segment(intext) $n]
					} else {
						$segment(tx$n) config -bd 0 -state readonly
						set segment(mtext$n) ""
					}
					ForceVal $segment(tx$n) $segment(mtext$n)
					incr n
				}
				set n 0
				set thisstate normal												;#	Initially in TAIL processes: set normal
				foreach process $segment(processes) nam $segment(procnames) {
					if {![CannotBeUsedInAMultiProcess $process] && ![string match $process RETIME] && ![string match $process TRANSFER]} {	;#	NO Timestretch processes visible/available
						if {[IsTailProcess $process] || [IsCutableWholefileTransformationProcess $process]} {;#	Initially TAIL processes available: set normal
							set thisstate normal
						} else {													;#	and HEAD processes not available. set disabled
							set thisstate disabled
						}
						$segment(mp$n) config -text $nam -state $thisstate -bd 2 -command "SetEntryInFocus $n"
					}
					incr n
				}
				if {$segment(headfirst)} {											;#	Set initial focus to first tail-process entrybox
					focus $segment(me1)
				} else {
					focus $segment(me0)
				}
				MultiBinds $f 0
			}
		}
		REORDER {

			if {![info exists segment(intext)]} {
				Inf "NO SEGMENT TEXT-MNEMONICS EXIST: CANNOT REORDER THE SEGMENTS"
				Dlg_Dismiss $f
				destroy $f
				return 0
			}

			;#	SEGMENT THE SOUND, WITH TAILS DOVETAILED

			if {![SegmentSound 1]} {
				Dlg_Dismiss $f
				destroy $f
				return 0
			}
			set hcnt 1
			set tcnt 1
			set fnams {}
			set durs  {}
			set n 0
			set m 1
			catch {unset fnams}
			catch {unset durs}

			;#	LIST THE SOUNDS AND THEIR DURATIONS

			set marks [lreplace $segment(marklist) end end $segment(wavdur)]	;#	Truncate segment time-markings to length of infile
			if {$segment(phrase)} {
				lappend fnams $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
				lappend durs [lindex $marks $m]
				incr hcnt
				incr n															;#	Initial head has a splicelen added to its end
				incr m
				while {$n < $segment(cnt)} {
					lappend fnams $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
					lappend durs [expr [lindex $marks $m] - [lindex $marks $n] + $segment(SPLICE)]
					incr hcnt
					incr n															;#	Initial head has a splicelen added to its end
					incr m
				}
			} else {
				if {$segment(headfirst)} {
					lappend fnams $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
					lappend durs [expr [lindex $marks $m] + $segment(SPLICE)]
					incr hcnt
					incr n															;#	Initial head has a splicelen added to its end
					incr m
				}
				while {$n < $segment(cnt)} {
					lappend fnams $evv(MACH_OUTFNAME)TD$hcnt$evv(SNDFILE_EXT)
					lappend durs [expr [lindex $marks $m] - [lindex $marks $n]]
					incr tcnt
					incr n															;#	Tails are cut to given marklist len (splices are WITHIN length)
					incr m
					if {$n >= $segment(cnt)} {
						break
					}
					lappend fnams $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
					lappend durs [expr [lindex $marks $m] - [lindex $marks $n] + (2 * $segment(SPLICE))]
					incr hcnt
					incr n															;#	Other heads have presplice and postsplice added
					incr m
				}
			}
			wm title .gtmulti "REORDER THE SEGMENTS"
			.gtmulti.0.s config -text "Save" -command "set pr_gtmulti REORDER_TEXT_MNEMONICS"
			bind $f <Return> {set pr_gtmulti REORDER_TEXT_MNEMONICS}
			.gtmulti.0.ld config -text "Sound View" -command "set segment(exportsegs) 2; DisplaySegmentation" -state normal -bd 2 -bg $evv(SNCOLOR)
			.gtmulti.0.sv config -text "Rand Order"	-command "ReorderedSegsRand"
			.gtmulti.0.cc config -command ReorderedSegsInvisible
			.gtmulti.0.h  config -text "Help" -bd 2 -command "GettrofReorderHelp REORDER" -bg $evv(HELP)
			.gtmulti.0.ch config -text "Preserve Head/Tail structure" -state normal -command HtiStructure
			.gtmulti.0.xx config -text "Preserve Head/Tail pairings" -state normal  -command HtpCommand
			set segment(hti_init) 0
			if {[info exists segment(hti)] && ($segment(hti) == 2)} {
				set segment(htj) 1
				set segment(htp) 1
			} else {
				set segment(hti) 1
				set segment(htj) 1
				set segment(htp) 0
			}
			set segment(hti_init) 1

			set n 0 
			while {$n < $segment(cnt)} {
				$segment(sn$n) config -text "[expr $n+1]"					;#	Show numbering of segments
				set segment(mproc$n) ""										;#	Hide process-mnemonic entryboxes		
				$segment(me$n) config -state disabled -bd 0 -disabledbackground [option get . background {}]
				$segment(tx$n) config -bd 2 -state readonly					;#	Display text entry boxes
				if {[info exists segment(intext)]} {						;#	with associated text-mnemonics, if they exist
					set segment(mtext$n) [lindex $segment(intext) $n]
				} else { 
					set segment(mtext$n) ""
				}
				ForceVal $segment(tx$n) $segment(mtext$n)					;#	Allow selection, and focus change, on text-entry boxes
				bind $segment(tx$n) <ButtonRelease-1> "AddSegmentToGettrofReorderedSequence $n"
				bind $segment(tx$n) <Down>  {}
				bind $segment(tx$n) <Up> {}
				bind $segment(tx$n) <Down>	"MoveGettrofFocus $n 0 1 0"
				bind $segment(tx$n) <Up> "MoveGettrofFocus $n 1 1 0"
				bind $segment(me$n) <ButtonRelease-1> {}					;#	(only)
				bind $segment(me$n) <Down>  {}
				bind $segment(me$n) <Up> {}
				bind $segment(me$n) <Delete> {}
				bind $segment(tx$n) <Delete> {}
				incr n
			}
			if {$segment(phrase)} {
				if {[info exists segment(hti)]} {
					set segment(oldhti) $segment(hti)
				}
				set segment(hti) 0
				set segment(htj) 0
				set segment(htp) 0
				.gtmulti.0.ch config -text "" -state disabled -disabledforeground []
				.gtmulti.0.xx config -text "" -state disabled -disabledforeground []
			} else {
				if {[info exists segment(oldhti)]} {
					set segment(hti) $segment(oldhti)
					set segment(htj) 1
					if {$segment(hti) == 2} {
						set segment(htp) 1
					} 
				}
				.gtmulti.0.ch config -text "Preserve Head/Tail structure" -state normal -command HtiStructure
				.gtmulti.0.xx config -text "Preserve Head/Tail pairings" -state normal  -command HtpCommand
			}
			set segment(htselect) 0			
			MultiBinds $f 1
			set n 0
			foreach process $segment(processes) nam $segment(procnames) {
				if {![CannotBeUsedInAMultiProcess $process]} {			;#	NO Process-buttons visible/available
					set segment(mproc$n) ""
					$segment(mp$n) config -text "" -state disabled -bd 0 -command {}
				}
				incr n
			}
			focus $segment(tx0)
		}
	}
	set pr_gtmulti 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_gtmulti
	while {!$finished} {
		tkwait variable pr_gtmulti
		switch -- $pr_gtmulti {
			SPECIFY_TAIL_PROCESSES {

				;#	GET TAIL CODES ENTERED

				if {[PatchNeedsMultipleFiles] && ($segment(infilecnt) < 2)}  {
					Inf "INSUFFICIENT INPUT FILES FOR SOME OF THE SELECTED PROCESSES"
					continue
				}
				set msg "ARE YOU SURE THESE ARE (ALL) THE TAIL PROCESSES YOU WANT TO ENTER ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set n 0
				set headdeleter -1
				set OK 1
				while {$n < $segment(cnt)} {											;#	For every entrybox
					set code [$segment(me$n) get]										;#	Get the code entered, if any
					if {[string length $code] <= 0} {
						incr n
						continue
					}
					set k [lsearch $segment(proccodes) $code]
					set procc [lindex $segment(processes) $k]							;#	Find the associated process
					incr n
				}
				if {!$OK} {
					continue
				}
				set n 0
				while {$n < $segment(cnt)} {											;#	For every entrybox
					if {[string match [$segment(me$n) cget -state] normal]} {			;#	if it is active
						set code [$segment(me$n) get]									;#	Get the code entered, if any
						set k [lsearch $segment(proccodes) $code]						;#	If a code has been entered
						if {$k >= 0} {													;#	Set related (n) multiflag value, to the code index (k)
							set segment(multiflag) [lreplace $segment(multiflag) $n $n $k]
						}
					}
					incr n
				}
				;#	CHANGE FUNCTION OF INTERFACE, TO ENTER HEAD PROCESSES

				;#	ALTER THE AVAILABLE PROCESSES (ALTER PROCESS ENTRY BUTTONS)

				.gtmulti.0.s config -text "Heads Done" -command "set pr_gtmulti SPECIFY_HEAD_PROCESSES"
				bind $f <Return> {set pr_gtmulti SPECIFY_HEAD_PROCESSES}
				set n 0
				foreach process $segment(processes) nam $segment(procnames) {
					if {![CannotBeUsedInAMultiProcess $process]} {						;#	Timestretch processes still not visible/available
						if {[IsTailProcess $process]} {									;#	Then in HEAD processes: set TAIL processes disabled
							set thisstate disabled
						} else {														;#	and HEAD processes. set normal
							set thisstate normal
						}
						$segment(mp$n) config -state $thisstate
					}
					incr n
				}

				;#	ALTER THE AVAILABLE ENTRY BOXES (FROM TAILS TO HEADS)

				set n 0
				set m 1
				set hcnt 1
				if {$segment(headfirst)} {
					set m 0
				}
				while {$n < $segment(cnt)} {
					if {[IsEven $m]} {								
						$segment(sn$n) config -text $hcnt								;#	Number the head boxes,
						incr hcnt														;#	make them available for entry of selected process
						$segment(me$n) config -state normal			
						bind $segment(me$n) <ButtonRelease-1> "focus $segment(me$n)"	;#	and enable focus on them.
						bind $segment(me$n) <Down>  "MoveGettrofFocus $n 0 0 0"
						bind $segment(me$n) <Up> "MoveGettrofFocus $n 1 0 0"
						bind $segment(tx$n) <ButtonRelease-1> "focus $segment(me$n)"
						bind $segment(me$n) <Delete> "$segment(me$n) delete 0 end"
						bind $segment(tx$n) <Delete> "$segment(me$n) delete 0 end"
					} else {
						$segment(sn$n) config -text ""									;#	Hide numbering of Tail boxes.
						$segment(me$n) config -state disabled							;#	and disable them (and therefore Black them out, retaining entered process name)
						bind $segment(me$n) <ButtonRelease-1> {}						;#	and disable focus on them.
						bind $segment(me$n) <Down>  {}
						bind $segment(me$n) <Up> {}
						bind $segment(tx$n) <ButtonRelease-1> {}
						bind $segment(me$n) <Delete> {}
						bind $segment(tx$n) <Delete> {}
					}
					incr n
					incr m
				}
				if {$segment(headfirst)} {												;#	switch focus to first head box
					focus $segment(me0)
				} else {
					focus $segment(me1)
				}
				wm title .gtmulti "SPECIFY THE HEAD PROCESSES"
			}
			SPECIFY_HEAD_PROCESSES {

				;#	GET HEAD CODES ENTERED

				if {[PatchNeedsMultipleFiles] && ($segment(infilecnt) < 2)}  {
					Inf "INSUFFICIENT INPUT FILES FOR SOME OF THE SELECTED PROCESSES"
					continue
				}

				set msg "ARE YOU SURE THESE ARE (ALL) THE HEAD PROCESSES YOU WANT TO ENTER ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set n 0
				while {$n < $segment(cnt)} {											;#	For every entrybox
					if {[string match [$segment(me$n) cget -state] normal]} {			;#	if it is active
						set code [$segment(me$n) get]									;#	Get the code entered, if any
						set k [lsearch $segment(proccodes) $code]
						if {$k >= 0} {													;#	Set related (n) multiflag value, to the code index (k)
							set segment(multiflag) [lreplace $segment(multiflag) $n $n $k]
						}
					}
					incr n
				}
		
				;#	FIND AND LIST THE PROCESSES INVOKED	

				if {![SetupGettrofSequenceDolist]} {
					Inf "NO PROCESSES SELECTED"
					My_Release_to_Dialog $f
					Dlg_Dismiss $f
					return 0
				}
				set finished 1
			}
			SPECIFY_PHRASE_PROCESSES {

				;#	GET PHRASE CODES ENTERED

				set msg "ARE YOU SURE THESE ARE (ALL) THE PROCESSES YOU WANT TO ENTER ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set n 0
				while {$n < $segment(cnt)} {											;#	For every entrybox
					if {[string match [$segment(me$n) cget -state] normal]} {			;#	if it is active
						set code [$segment(me$n) get]									;#	Get the code entered, if any
						set k [lsearch $segment(proccodes) $code]						;#	If a code has been entered
						if {$k >= 0} {													;#	Set related (n) multiflag value, to the code index (k)
							set segment(multiflag) [lreplace $segment(multiflag) $n $n $k]
						}
					}
					incr n
				}
		
				;#	FIND AND LIST THE PROCESSES INVOKED	

				if {![SetupGettrofSequenceDolist]} {
					Inf "NO PROCESSES SELECTED"
					My_Release_to_Dialog $f
					Dlg_Dismiss $f
					return 0
				}
				set finished 1
			}
			LOAD_PROCESS_SEQUENCE {
				if {![GettrofsLoadParamPatch 1]} {
					continue
				}
				set n 0
				foreach k $segment(actionlist) {
					if {$k >= 0} {
						set code [lindex $segment(proccodes) $k]
					} else {
						set code ""
					}
					set segment(mproc$n) $code
					incr n
				}
				continue
			}
			SAVE_PROCESS_SEQUENCE {
				set n 0
				while {$n < $segment(cnt)} {										;#	For every entrybox
					set code [$segment(me$n) get]									;#	Get the code entered, if any
					set k [lsearch $segment(proccodes) $code]						;#	If a code has been entered
					if {$k >= 0} {													;#	Set related (n) multiflag value, to the code index (k)
						set segment(multiflag) [lreplace $segment(multiflag) $n $n $k]
					}
					incr n
				}
				set heads 0
				set tails 0

				foreach val $segment(multiflag) {
					if {$val >= 0} {
						set process [lindex $segment(processes) $val]
						if [IsTailProcess $process] {
							incr tails
						} else {
							incr heads
						}
					}
				}
				if {!($tails || $heads)} {
					Inf "NO PROCESSES HAVE BEEN SELECTED"
					continue
				} elseif {!$segment(phrase)} {
					if {!$tails} {
						set msg "NO TAIL PROCESSES ENTERED : IS THIS OK ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
					} elseif {!$heads} {
						set msg "NO HEAD PROCESSES ENTERED : IS THIS OK ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
					}
				}
				GettrofsSaveParamPatch 1
			}
			CLEAR_PROCESS_DISPLAY {
				set n 0
				while {$n < $segment(cnt)} {											;#	Clear every entrybox
					set segment(mproc$n) ""
					incr n
				}
			}
			EDIT_TEXT_MNEMONICS -
			ENTER_TEXT_MNEMONICS {
				if {$pr_gtmulti == "EDIT_TEXT_MNEMONICS"} {
					if {![info exists segment(rfnam)]} {
						Inf "NO ASSOCIATED REFINED SEGMENTATION DATA FILE EXISTS"
						continue
					}
					if {[info exists segment(intext)]} {
						set n 0
						set OK 0
						while {$n < $segment(cnt)} {
							if {![string match $segment(mtext$n) [lindex $segment(intext) $n]]} {
								set OK 1
								break
							}
							incr n
						}
						if {!$OK} {
							Inf "NO CHANGE TO EXISTING MNEMONICS"
							continue
						}
					}
				}
				set OK 1
				catch {unset outext}
				set n 0
				while {$n < $segment(cnt)} {
					set len [string length $segment(mtext$n)]
					if {$len <= 0} {
						Inf "NO TEXT ENTERED FOR SEGMENT [expr $n+1]"
						set OK 0
						break
					}
					if {$len > 5} {
						Inf "TEXT ENTERED FOR SEGMENT [expr $n+1] IS TOO LONG (MAX 5 CHARACTERS)"
						set OK 0
						break
					}
					if {[regexp { } $segment(mtext$n)]} {
						Inf "INVALID SPACE CHARACTER IN SEGMENT [expr $n+1] (\"$segment(mtext$n)\")"
						set OK 0
						break
					}
					lappend outext $segment(mtext$n)
					incr n
				}
				if {!$OK} {
					catch {unset outext}
					continue
				}
				set len [expr [string length $segment(rfnam)] - 6]		;#	Create name of mnemonics file, from name of refined-segmentation-data file
				set txtfnam [string range $segment(rfnam) 0 $len]
				if {$segment(phrase)} {
					append txtfnam "phrs"
				} else {
					append txtfnam "text"
				}
				set txtfnam [file join $segment(dirname) $txtfnam$evv(TEXT_EXT)]
				if {[file exists $txtfnam]} {
					if {!$segment(phrase)} {
						set msg "SEGMENT MNEMONICS FILE $txtfnam ALREADY EXISTS: OVERWRITE IT ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
					}
					if [catch {file delete $txtfnam} zit] {
						Inf "CANNOT DELETE EXISTING SEGMENT MNEMONICS FILE $txtfnam : $zit"
						continue
					}
				}
				if {[GettrofSaveAssociatedText $txtfnam $outext]} {
					set segment(intext) $outext
					My_Release_to_Dialog $f
					Dlg_Dismiss $f
					destroy $f
					return 1
				}
			}
			ENTER_TEXT_SCANSION {
				set OK 1
				catch {unset outscans}
				set n 0
				while {$n < $segment(cnt)} {
					set segment(mproc$n) [string trim $segment(mproc$n)]
					set len [string length $segment(mproc$n)]
					if {$len <= 0} {
						Inf "NO SCANSION ENTERED FOR SEGMENT [expr $n+1]"
						set OK 0
						break
					}
					if {[regexp { \t\n} $segment(mproc$n)]} {
						Inf "INVALID SPACE CHARACTER(s) IN SCANSION STRING [expr $n+1] (\"$segment(mproc$n)\")"
						set OK 0
						break
					}
					set outscan [DecodeSegmentScansion $segment(mproc$n) $n]
					if {[llength $outscan] <= 0} {
						set OK 0
						break
					}
					lappend outscans $outscan
					incr n
				}
				if {!$OK} {
					catch {unset outscans}
					continue
				}
				catch {unset shrhy(qsteps)}
				catch {unset shrhy(accents)}
				catch {unset shrhy(scansion)}
				foreach outscan $outscans {
					set qstep [lindex $outscan 0]
					lappend shrhy(qsteps) $qstep
					if {$qstep == 2} {
						lappend shrhy(accents) 1
					} else {
						lappend shrhy(accents) 0
					}
					lappend shrhy(scansion) [lindex $outscan 1]
				}
				.shrhy.1a.tt config -text "Tempo MM: "
				.shrhy.1a.et config -state readonly -bd 2
				.shrhy.1a.tempohlp config -text "Use LEFT & RIGHT Arrows (With \"Control\" for Fast change)"
				if {[info exists shrhy(lasttempo)]} {	
					set shrhy(tempo) $shrhy(lasttempo)
				} else {
					set shrhy(tempo) $segment(SHRHY_DFLTTEMPO)
				}
				ForceVal .shrhy.1a.et $shrhy(tempo)
				bind .shrhy <Right> {IncrShrhyTempo 0 1}
				bind .shrhy <Left> {IncrShrhyTempo 1 1}
				bind .shrhy <Control-Left> {IncrShrhyTempo 1 10}
				bind .shrhy <Control-Right> {IncrShrhyTempo 0 10}
				set shrhy(done) 2
				Inf "NOW SET TEMPO"
				set finished 1	
			}
			ENTER_TEXT_ARTIC {
				set OK 1
				set gotartic 0
				catch {unset segment(artics)}
				set n 0
				while {$n < $segment(cnt)} {
					set segment(mproc$n) [string trim $segment(mproc$n)]
					set len [string length $segment(mproc$n)]
					if {$len <= 0} {
						lappend segment(artics) "."
						incr n
						continue
					} elseif {[regexp { \t\n} $segment(mproc$n)]} {
						Inf "INVALID SPACE CHARACTER(s) IN ARTICULATION STRING [expr $n+1] (\"$segment(mproc$n)\")"
						set OK 0
						break
					}
					set outartic [DecodeSegmentArticulation $segment(mproc$n) $n]
					if {[llength $outartic] <= 0} {
						set OK 0
						break
					}
					if {$outartic == ")"} {
						if {![info exists segment(artics)]} {
							Inf "TIE (\")\") IN SEGMENT 1 DOES NOT REFERENCE ANY PREVIOUS ARTICULATION SETTING"
							set OK 0
							break
						} else {
							set lastartic [lindex $segment(artics) end]
							if {![regexp {[HL?!UD><)]} $lastartic]} {
								Inf "TIE (\")\") IN SEGMENT [expr $n + 1] HAS NO EFFECT"
								set OK 0
								break
							}
						}
					}
					lappend segment(artics) $outartic
					SaveSegmentationDirs
					set gotartic 1
					incr n
				}
				if {!$gotartic} {
					Inf "NO ARTICULATION DATA ENTERED"
					set OK 0
				}
				if {!$OK} {
					catch {unset segment(artics)}
					continue
				}
				set savetofile 1
				if {[info exists segment(articloaded)]} {
					set savetofile 0
					foreach iloaded $segment(articloaded) isaved $segment(artics) {
						if {![string match $iloaded $isaved]} {
							set savetofile 1
							break
						}
					}
				}
				catch {unset segment(articloaded)}
				if {$savetofile} {
					set arfnam [file join $segment(dirname) $segment(src,0)]
					append arfnam "_artic"
					set OK 0
					set cccnt 0
					while {!$OK} {
						set artfnam $arfnam
						append artfnam $cccnt $evv(TEXT_EXT)
						if {![file exists $artfnam]} {
							set OK 1
						}
						incr cccnt
					}
					if [catch {open $artfnam "w"} zit] {
						Inf "CANNOT SAVE ARTICULATIONS TO A FILE"
					} else {
						foreach item $segment(artics) {
							puts $zit $item
						}
						close $zit
						set gotit 0										;#	SET LAST USED FILE TO SAVED FILE WHERE FILE IS NEWLY MADE
						set cccnt 0
						while {!$gotit} {
							set artfnamk $arfnam
							append artfnamk $cccnt $evv(TEXT_EXT)
							if {[string match $artfnam $artfnamk]} {
								set segment(rtc,i) $cccnt
								set gotit 1
							} elseif {[file exists $artfnamk]} {
								incr cccnt
							} else {
								break
							}
						}
					}
				}
				set finished 1	
			}
			LOAD_TEXT_SCANSION {
				.shrhy.1a.tt config -text "Tempo MM: "
				.shrhy.1a.et config -state readonly -bd 2
				.shrhy.1a.tempohlp config -text "Use LEFT & RIGHT Arrows (With \"Control\" for Fast change)"
				if {[info exists shrhy(lasttempo)]} {	
					set shrhy(tempo) $shrhy(lasttempo)
				} else {
					set shrhy(tempo) $segment(SHRHY_DFLTTEMPO)
				}
				ForceVal .shrhy.1a.et $shrhy(tempo)
				bind .shrhy <Right> {IncrShrhyTempo 0 1}
				bind .shrhy <Left> {IncrShrhyTempo 1 1}
				bind .shrhy <Control-Left> {IncrShrhyTempo 1 10}
				bind .shrhy <Control-Right> {IncrShrhyTempo 0 10}
				set shrhy(done) 2
				set finished 1
			}
			LOAD_TEXT_SCANSION_FAILED {
				continue
			}
			CLEAR_TEXT_MNEMONICS {
				set n 0
				while {$n < $segment(cnt)} {
					set segment(mtext$n) ""
					incr n
				}
			}	
			RESTORE_TEXT_MNEMONICS {
				if {![info exists segment(intext)]} {
					Inf "NO MNEMONIC DATA EXISTS"
					continue
				}
				set n 0
				while {$n < $segment(cnt)} {
					set segment(mtext$n) [lindex $segment(intext) $n]
					incr n
				}
			}
			REORDER_TEXT_MNEMONICS {
				set segment(reordered) 0
				if {$segment(reordercnt) <= 0} {
					Inf "NO REORDERED SEGMENTATION TO SAVE"
					continue
				}
				set n 0
				set ttim 0.0
				catch {unset segment(mixlines)}
				catch {unset segment(retimedurs)}
				if {$segment(phrase)} {
					set is_head 1				;#	ALL elements are heads
					set is_a_head 1
				} else {
					if {$segment(headfirst)} {	;#	i.e. (in case where elements H/T ordering preserved)
						set is_head 0			;#	2nd element is NOT a head
					} else {
						set is_head 1			;#	2nd element IS a head
					}
					set is_a_head 0
				}
				if {$segment(phrase)} {
					while {$n < $segment(reordercnt)} {
						set k [lsearch $segment(intext) $segment(rtext$n)]
						set fnam [lindex $fnams $k]								
						set dur  [lindex $durs $k]
						lappend segment(retimedurs) $dur
						set mixline [list $fnam $ttim 1 1.0]
						lappend segment(mixlines) $mixline
						set ttim [expr $ttim + $dur]
						set ttim [expr $ttim - $segment(SPLICE)]
						incr n
					}
				} else {
					while {$n < $segment(reordercnt)} {
						set k [lsearch $segment(intext) $segment(rtext$n)]
						if {$segment(disordered)} {
							if {[IsEven [expr $k + $segment(headfirst)]]} {
								set is_a_head 0								;#											SUM								
							} else {										;#	IF headfirst(1) 0 2 4 6 are heads --> 1 3 5 7 = ODD  = head
								set is_a_head 1								;#	IF headfirst(1) 1 3 5 7 are tails --> 2 4 6 8 = EVEN = tail									
							}												;#	IF NOT		(0)	1 3 5 7 are heads --> 1 3 5 7 = ODD  = head
						}													;#	IF NOT		(0)	0 2 4 6 are tails --> 0 2 4 6 = EVEN = tail
						set fnam [lindex $fnams $k]								
						set dur  [lindex $durs $k]
						lappend segment(retimedurs) $dur
						set mixline [list $fnam $ttim 1 1.0]
						lappend segment(mixlines) $mixline
						set ttim [expr $ttim + $dur]
						if {$is_head || $is_a_head} {
							set ttim [expr $ttim - $segment(SPLICE)]
						}
						set is_head [expr !$is_head]
						incr n
					}
				}
				if [catch {open $segment(mixfil) "w"} zit] {
					Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixfil) TO MAKE REORDERED SEGMENT SOUND"
					continue
				}
				foreach line $segment(mixlines) {
					puts $zit $line
				}
				close $zit
				if {![GettrofPossiblyMultichanMixdown 0]} {
					continue
				}
				set segment(reordered) 1
				ConvertTrofSndOutputToOtherFormat
				set segment(returnkeystate) R_PLAY
				ResetGetSyllabTrofs OUTPUT_CREATED
				ReorderedSegsInvisible
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				destroy $f
				return 1
			}	
			0 {
				if {[string match [.gtmulti.0.cc cget -command] "ReorderedSegsInvisible"]} {
					ReorderedSegsInvisible
				}
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				destroy $f
				if {$typ == "MULTIPROC"} {
					catch {unset segment(vp)}
					set segment(docnt) 0
				}
				return 0
			}
			
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	catch {unset segment(vp)}
	set segment(docnt) 0
	return 1
}

#----	Find and list the processes requested, and set up action flags for each invoked process
#		indicating which segments the process acts on

proc SetupGettrofSequenceDolist {} {

	global segment wstk
	set segment(multiproclist) {}
	foreach item $segment(multiflag) {
		if {$item >= 0} {
			if {[lsearch $segment(multiproclist) $item] < 0} {				;#	If process not already listed, list it
				lappend segment(multiproclist) $item
			}
		}
	}
	if {[llength $segment(multiproclist)] <= 0} {
		return 0
	}

	set havetex   0
	set havewhole 0
	foreach k $segment(multiproclist) {
		set pr_oc [lindex $segment(processes) $k]
		if {$pr_oc == "TEXTURE"} {
			if {![string match $havewhole "0"]} {
				Inf "CANNOT USE \"TEXTURE\" WITH \"$havewhole\""
				return 0
			}
			set havetex 1
		} elseif {[IsCutableWholefileTransformationProcess $pr_oc]} {
			if {$havetex} {
				Inf "CANNOT USE \"TEXTURE\" WITH \"$pr_oc\""
				return 0
			} else {
				set havewhole $pr_oc
			}
		}
	}

	;#	SORT MULTIPROC LIST, SO PROCESSES ARE IN THE ORDER IN segment(processes)

	set len [llength $segment(multiproclist)]
	if {$len > 1} {
		set len_less_one [expr $len - 1]
		set n 0
		while {$n < $len_less_one} {
			set valn [lindex $segment(multiproclist) $n]
			set m $n
			incr m
			while {$m < $len} {
				set valm [lindex $segment(multiproclist) $m]
				if {$valm < $valn} {
					set segment(multiproclist) [lreplace $segment(multiproclist) $n $n $valm]
					set segment(multiproclist) [lreplace $segment(multiproclist) $m $m $valn]
					set valn $valm
				}
				incr m
			}
			incr n
		}
	}

	;#	FOR EVERY PROCESS, SET UP AN ACTIONLIST OF FLAGS FOR ALL SEGMENTS SHOWING WHICH ARE TO BE PROCESSED BY THIS PROCESS

	set actionlists {}
	foreach prc $segment(multiproclist) {		;#	For every process invoked
		set actionlist 0						;#	NB DUMMY ENTRY because the segments IN THE PROCESSES are COUNTED FROM 1
		foreach item $segment(multiflag) {		;#	Look at list of all processes invoked
			if {$item == $prc} {
				lappend actionlist 1			;#	and if the process is THIS process, set action ON
			} else {
				lappend actionlist 0			;#	else OFF
			}
		}
		lappend actionlists $actionlist			;#	Accumulate a list of ALL actionlists
	}

	;#	SET UP A LIST OF Process/Actionlist PAIRS

	set segment(multido) {}
	foreach prc $segment(multiproclist) actionlist $actionlists {
		set segment(process) [lindex $segment(processes) $prc]
		lappend segment(multido) [list $segment(process) $actionlist]
	}

	;#	FORCE (POSSIBLY HEAD DELETING) VERGES, "TUNED" & "PITCH" TO END
	;#	THEN SEGMENT-DELETING "SUPPRESS" TO END

	VergesProcessToEnd $len
	HeadDeletersToEnd $len
	SuppressProcessToEnd $len

	set segment(multiproccnt) [llength $segment(multido)]
	return 1
}

#--- Change Focus on entry boxes in process-list entry window

proc MoveGettrofFocus {n up istxt isphras} {
	global segment
	if {$istxt} {
		if {$up} {
			set thisinc 1
		} else {
			set thisinc -1
		}
		incr n $thisinc
		set n [expr $n % $segment(cnt)]
		focus $segment(tx$n)
	} else {
		if {$isphras} {
			set thisinc 1
		} else {
			set thisinc 2
		}
		if {!$up} {
			set thisinc [expr -$thisinc]
		}
		incr n $thisinc
		if {$n >= $segment(cnt)} {
			if {$isphras} {
				set n 0
			} elseif [string match [$segment(me0) cget -state] normal] {
				set n 0
			} else {
				set n 1
			}
		} elseif {$n < 0} {
			set segend [expr $segment(cnt) - 1]
			if {$isphras} {
				set n $segend
			} elseif [string match [$segment(me$segend) cget -state] normal] {
				set n $segend
			} else {
				set n [expr $segend - 1]
			}
		}
		set n [expr $n % $segment(cnt)]
		focus $segment(me$n)
	}
}

#-- Srite process code aelected into entry-box in focus

proc SetEntryInFocus {k} {
	global segment
	set ebox [focus]												;#	Find the entrybox which has focus
	set n 0
	while {$n < $segment(cnt)} {									;#	Match this with the entry-box numbering	
		if {[string match $segment(me$n) $ebox]} {
			set segment(mproc$n) [lindex $segment(proccodes) $k]
			break
		}
		incr n
	}
}

#--- Load list of text-mnemonics associated with a segmentation, IF it exists

proc GettrofLoadAssociatedText {} {
	global segment evv
	catch {unset segment(intext)}
	set len [expr [string length $segment(rfnam)] - 6]		;#	Load any asssociated "text"
	set fnam [string range $segment(rfnam) 0 $len]
	if {$segment(phrase)} {
		append fnam "phrs"
	} else {
		append fnam "text"
	}
	set fnam [file join $segment(dirname) $fnam$evv(TEXT_EXT)]
	if {[file exists $fnam]} {
		if [catch {open $fnam "r"} zit] {
			Inf "CANNOT OPEN FILE $fnam TO READ TEXT-MNEMONICS ASSOCIATED WITH SEGMENTATION DATA $segment(rfnam)"
			return
		} else {
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					set item [StripCurlies $item]
					lappend segment(intext) $item
				}
			}
			close $zit
		}
	}
}

#--- Save (new) list of text-mnemonics associated with a segmentation

proc GettrofSaveAssociatedText {fnam args} {
	global segment evv
	if [catch {open $fnam "w"} zit]  {
		Inf "CANNOT OPEN FILE $fnam TO WRITE TEXT MNEMONICS : $zit"
		return 0
	}
	foreach item $args {
		puts $zit $item
	}
	close $zit
	Inf "MNEMONICS SAVED"
	return 1
}

#--- Hide reordered-segs boxes

proc ReorderedSegsInvisible {} {
	global segment
	if {$segment(reordercnt) > 0} {
		set n 0								
		while {$n < $segment(reordercnt)} {
			catch {unset segment(rtext$n)}
			ForceVal $segment(re$n) ""
			$segment(re$n) config -bd 0
			incr n
		}
	}
	set segment(disordered) 0
	set segment(reordercnt) 0
}

#--- Randomly reorder the segments in a segmented file

proc ReorderedSegsRand {} {
	global segment evv wstk hopperm pr_rsegsrand
	set f .rsegsrand
	if [Dlg_Create $f "RANDOM REORDER SEGMENTS" "set pr_rsegsrand 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "All Segments (dflt)" -command "set pr_rsegsrand 1" -width 20
		button $f.0.d -text "Give Number of Segs" -command "set pr_rsegsrand 2" -width 20
		button $f.0.q -text "Abandon"			  -command "set pr_rsegsrand 0" -width 10
		pack $f.0.s $f.0.d -side left -padx 12
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Length (Range 2 to $evv(MAX_REORDERED_SEGS))"
		entry $f.1.e  -textvariable segment(nureordercnt) -width 6
		pack $f.1.e $f.1.ll -side left -padx 2
		pack $f.1 -side top -fill x -pady 2
		bind $f <Return> {set pr_rsegsrand 1}
		bind $f <Escape> {set pr_rsegsrand 0}
	}
	$f.1.ll config -text ""
	set segment(nureordercnt) ""
	$f.1.e  config -bd 0 -state disabled -disabledbackground [option get . background {}]
	set pr_rsegsrand 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_rsegsrand
	while {!$finished} {
		tkwait variable pr_rsegsrand
		switch -- $pr_rsegsrand {
			1 {
				set segment(nureordercnt) $segment(cnt)
				set finished 1
			}
			2 {
				bind $f <Return> {set pr_rsegsrand 3}
				$f.1.ll config -text "Length (Range 2 to $evv(MAX_REORDERED_SEGS))"
				$f.1.e  config -bd 2 -state normal
				$f.0.d  config -text "Do Reorder" -command "set pr_rsegsrand 3"
				focus $f.1.e
			}
			3 {
				if {[string length $segment(nureordercnt)] <= 0} {
					Inf "NUMBER OF SEGMENTS NOT SPECIFIED"
					continue
				}
				if {![IsNumeric $segment(nureordercnt)] || ![regexp {^[0-9]+$} $segment(nureordercnt)] \
				|| ($segment(nureordercnt) < 2) || ($segment(nureordercnt) > $evv(MAX_REORDERED_SEGS))} {
					Inf "INVALID SEGMENT COUNT ENTERED (Range 2 - $evv(MAX_REORDERED_SEGS))"
					continue
				}
				if {($segment(hti) == 2) && ![IsEven $segment(nureordercnt)]} {
					set msg "PRESERVING HEAD-TAIL PAIRINGS WILL PRODUCE AN EVEN NUMBER OF SEGMENTS: reducing $segment(nureordercnt) "
					incr segment(nureordercnt) -1
					append msg "TO $segment(nureordercnt)"
					Inf $msg
				}
				set finished 1
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				destroy $f
				return
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	set reorder_origset 1
	if {[info exists segment(reordercnt)] && ($segment(reordercnt) > 0)} {		;#	If a reordered set already exists
		if {$segment(reordercnt) != $segment(nureordercnt)} {					;#	IF it's not same length as original		
			set msg "DO YOU WANT TO REORDER THE ORIGINAL MNEMONIC SET: OVERWRITING THE EXISTING REORDERED SEQUENCE ??\n\n(OTHERWISE NEW SEQUENCE WILL BE RANDOMISED)"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				set reorder_origset 0
			}
		} else {																;#	else it is same length as orig: re-reorder NEW set
			set reorder_origset 0
		}
	}
	set n 0
	if {$reorder_origset} {	
		ReorderedSegsInvisible								;#	Clear any existing reordered set
		if {$segment(hti) == 2} {							;#	If heads and tails to be randomised as pairs
			set htotal [expr $segment(cnt)/2]				;#	Total number of headtail pairs = segcnt/2 ...
			if {!$segment(headfirst)} {						;#	thththt 7->3 hththth 7->3 hththt 6->3 BUT ththth 6 -> 2
				incr htotal -1
				set hoffset 1
			} else {
				set hoffset 0
			}
			set hcount 0										
			set n 0											;#	Start head creation at start
			while {$n < $segment(nureordercnt)} {
				set k [expr $hcount % $htotal] 
				if {$k == 0} {								;#	perms of original set OF HEADS
					randperm $htotal
				}
				set m [lindex $hopperm $k]					;#	Get headtail pair no "m"
				incr m $m									;#	Heads are alternate, so this is at seg 2m
				incr m $hoffset								;#	and if Heads are not first, this is offset by 1 segment
				set segment(rtext$n) $segment(mtext$m)
				$segment(re$n) config -bd 2
				bind $segment(re$n) <ButtonRelease-1> "GettrofRemoveReorderedSeg $n"
				incr n										;#	Move to following tail			
				incr m
				set segment(rtext$n) $segment(mtext$m)
				$segment(re$n) config -bd 2
				bind $segment(re$n) <ButtonRelease-1> "GettrofRemoveReorderedSeg $n"
				incr hcount
				incr n										;#	Move to next head position in output
			}

		} elseif {$segment(hti)} {							;#	If heads and tails to be randomised separately i.e. retaining H/T structure
			set htotal [expr $segment(cnt)/2]				;#	Total number of heads = segcnt/2 ... 16->8  17->8
			set ttotal $htotal								;#	Total number of tails = Total number of heads 
			if {$segment(headfirst)} {
				set hoffset 0
				set toffset 1								;#	If headfirst
				if {![IsEven $segment(cnt)]} {				;#	If not even no of segs (e.g. 17)
					incr htotal								;#	htotal -> 9 (ttotal remains 8)
				}
			} else {												
				set hoffset 1
				set toffset 0								;#	If NOT headfirst			
				if {![IsEven $segment(cnt)]} {				;#	If not even no of segs (e.g. 17)
					incr ttotal								;#	ttotal -> 9 (htotal remains 8)
				}
			}
			set hcount 0										
			set n $hoffset									;#	Start head creation where heads start (at either 0 or 1)
			while {$n < $segment(nureordercnt)} {
				set k [expr $hcount % $htotal] 
				if {$k == 0} {								;#	perms of original set OF HEADS
					randperm $htotal
				}
				set m [lindex $hopperm $k]					;#	Get head no "m"
				incr m $m									;#	Heads are alternate, so this is at seg 2m
				incr m $hoffset								;#	and if Heads are not first, this is offset by 1 segment
				set segment(rtext$n) $segment(mtext$m)
				$segment(re$n) config -bd 2
				bind $segment(re$n) <ButtonRelease-1> "GettrofRemoveReorderedSeg $n"
				incr hcount
				incr n 2									;#	Move to next head position in output
			}
			set tcount 0										
			set n $toffset
			while {$n < $segment(nureordercnt)} {
				set k [expr $tcount % $ttotal] 
				if {$k == 0} {								;#	perms of original set OF TAILS
					randperm $ttotal
				}
				set m [lindex $hopperm $k]
				incr m $m									;#	Tails are alternate, so this is at seg 2m
				incr m $toffset								;#	and if Tails are not first, this is offset by 1 segment
				set segment(rtext$n) $segment(mtext$m)
				$segment(re$n) config -bd 2
				bind $segment(re$n) <ButtonRelease-1> "GettrofRemoveReorderedSeg $n"
				incr tcount
				incr n 2
			}
		} else {
			while {$n < $segment(nureordercnt)} {
				set k [expr $n % $segment(cnt)] 
				if {$k == 0} {								;#	perms of original set
					randperm $segment(cnt)
				}
				set m [lindex $hopperm $k]
				set segment(rtext$n) $segment(mtext$m)
				$segment(re$n) config -bd 2
				bind $segment(re$n) <ButtonRelease-1> "GettrofRemoveReorderedSeg $n"
				incr n
			}
		}
	} else {
		catch {unset newperm}
		if {$segment(hti) == 2} {
			set n 0
			while {$n < $segment(nureordercnt)} {			;#	Create dummy newperm
				lappend newperm ""
				incr n
			}
			set htotal [expr $segment(reordercnt)/2]		;#	Total number of heads = segcnt/2 ... 16->8  17->8
			if {!$segment(headfirst)} {						;#	thththt 7->3 hththth 7->3 hththt 6->3 BUT ththth 6 -> 2
				incr httotal -1
				set hoffset 1
			} else {
				set hoffset 0
			}
			set hcount 0										
			set n $hoffset									;#	Start head creation where heads start (at either 0 or 1)
			while {$n < $segment(nureordercnt)} {
				set k [expr $hcount % $htotal] 
				if {$k == 0} {								;#	perms of original set OF HEADS
					randperm $htotal
				}
				set m [lindex $hopperm $k]					;#	Get head no "m"
				incr m $m									;#	Heads are alternate, so this is at seg 2m
				incr m $hoffset								;#	and if Heads are not first, this is offset by 1 segment
															;#	SUBSTITUTE this value into newperm
				set newperm [lreplace $newperm $n $n $segment(rtext$m)]
				incr n
				incr m										;#	Move to next tail	
				set newperm [lreplace $newperm $n $n $segment(rtext$m)]
				incr hcount
				incr n										;#	Move to next head position in output
			}
		} elseif {$segment(hti)} {
			set n 0
			while {$n < $segment(nureordercnt)} {			;#	Create dummy newperm
				lappend newperm ""
				incr n
			}
			set htotal [expr $segment(reordercnt)/2]		;#	Total number of heads = segcnt/2 ... 16->8  17->8
			set ttotal $htotal								;#	Total number of tails = Total number of heads 
			if {$segment(headfirst)} {
				set hoffset 0
				set toffset 1								;#	If headfirst
				if {![IsEven $segment(reordercnt)]} {		;#	If not even no of segs (e.g. 17)
					incr htotal								;#	htotal -> 9 (ttotal remains 8)
				}
			} else {												
				set hoffset 1
				set toffset 0								;#	If NOT headfirst			
				if {![IsEven $segment(reordercnt)]} {		;#	If not even no of segs (e.g. 17)
					incr ttotal								;#	ttotal -> 9 (htotal remains 8)
				}
			}
			set hcount 0										
			set n $hoffset									;#	Start head creation where heads start (at either 0 or 1)
			while {$n < $segment(nureordercnt)} {
				set k [expr $hcount % $htotal] 
				if {$k == 0} {								;#	perms of original set OF HEADS
					randperm $htotal
				}
				set m [lindex $hopperm $k]					;#	Get head no "m"
				incr m $m									;#	Heads are alternate, so this is at seg 2m
				incr m $hoffset								;#	and if Heads are not first, this is offset by 1 segment
															;#	SUBSTITUTE this value into newperm
				set newperm [lreplace $newperm $n $n $segment(rtext$m)]
				incr hcount
				incr n 2									;#	Move to next head position in output
			}
			set tcount 0										
			set n $toffset
			while {$n < $segment(nureordercnt)} {
				set k [expr $tcount % $ttotal] 
				if {$k == 0} {								;#	perms of original set OF TAILS
					randperm $ttotal
				}
				set m [lindex $hopperm $k]
				incr m $m									;#	Tails are alternate, so this is at seg 2m
				incr m $toffset								;#	and if Tails are not first, this is offset by 1 segment

				set newperm [lreplace $newperm $n $n $segment(rtext$m)]
				incr tcount
				incr n 2
			}
		} else {
			while {$n < $segment(nureordercnt)} {
				set k [expr $n % $segment(reordercnt)] 
				if {$k == 0} {
					randperm $segment(reordercnt)			;#	perms of existing reordered set
				}
				set m [lindex $hopperm $k]
				lappend newperm $segment(rtext$m)
				incr n
			}
		}
		ReorderedSegsInvisible								;#	Now clear existing reordered set
		set n 0
		set m 0
		while {$n < $segment(nureordercnt)} {
			set segment(rtext$n) [lindex $newperm $n]
			$segment(re$n) config -bd 2
			bind $segment(re$n) <ButtonRelease-1> "GettrofRemoveReorderedSeg $n"
			incr n
		}
	}
	if {!$segment(hti)} {											;#	If head/tail order not preserved, flag new set as disordered					
		set segment(disordered) 1
	}
	set segment(reordercnt) $segment(nureordercnt)
}

#--- When a box in reordered segments is clicked on, it is deleted from reordered-sequence

proc GettrofRemoveReorderedSeg {n} {
	global segment
	set k $n
	set shuffldown 0
														;#
	if {$segment(hti) == 2} {							;#	HEAD-TAIL PAIRS are to be preserved	
														;#
		if {[IsTailSeg $k 1 1]} {						;#	TAIL SELECTED FOR DELETION
														;#		   n
			if {$n == [expr $segment(reordercnt) - 1]} {;#		   k
				incr n -1								;#	hthththt
														;#		  n		delete endpair only
			} else {									;#
														;#		 n
				incr k									;#		 k
				incr n -1								;#	  hthththt
				set shuffldown 1						;#		n k
			}											;#	copy down from k-> to n-> (and delete endpair)
														;#
		} else {										;#	HEAD SELECTED FOR DELETION
														;#		  n									  n
			if {$n < [expr $segment(reordercnt) - 2]} {	;#        k							OR		  k
				incr k 2								;#	  hthththt							hthththt	
				set shuffldown 1						;#		  n k								  n
			}											;#	copy down from k-> to n->			delete endpair only	
		}												;#	 (and delete endpair)				
		
	} elseif {$segment(hti)} {							;#	HEAD/TAIL STRUCTURE PRESERVED
														;#			 n			 n
		if {$n == [expr $segment(reordercnt) - 1]} {	;#			 k			 k
			incr n -1									;#	  hthththt	OR	hththth		delete endpair only : ht OR th deleted
														;#			n			 n
		}												;#
		if {$n < [expr $segment(reordercnt) - 2]} {		;#		   n		    n
			incr k 2									;#		   k	OR	    k
			set shuffldown 1							;#	  hthththt		hthththt
		}												;#		   n k		    n k		copy down from k-> to n-> (and delete end 2)
														;#								deletes either ht OR th

	} else {											;#	HEAD/TAIL STRUCTURE IGNORED: any element can be singly deleted
														;#		n							   n
		if {$n != [expr $segment(reordercnt) - 1]} {	;#		k					OR		   k
														;#	  hthththt					hthththt
														;#		nk						(delete end 1 only)			
			incr k										;#	copy down from k-> to n->
			set shuffldown 1							;# 	deletes either h OR t
		}												;#	(and deletes end 1)

	}
	if {$shuffldown} {
		while {$k < $segment(reordercnt)} {				;#	Shuffle down all segment mnemonics
			set segment(rtext$n) $segment(rtext$k)
			incr n
			incr k
		}
	}
	set segment(rtext$n) ""								;#	Make last entry blank
	$segment(re$n) config -bd 0							;#	Hide last entrybox
	bind $segment(re$n) <ButtonRelease-1> {}
	incr segment(reordercnt) -1							;#	Reduce count of reordered-segments
	if {$segment(hti)} {						
		incr n											;#	If Head/Tail structure or pairing preserved, remove a 2nd item
		set segment(rtext$n) ""
		$segment(re$n) config -bd 0
		bind $segment(re$n) <ButtonRelease-1> {}
		incr segment(reordercnt) -1
	}
}

#--- NB k (segment) counts from 1!!!!

proc IsTailSeg {k fromnewseq htpaired} {
	global segment
	if {$fromnewseq && !$htpaired} {
		Inf "IsTailSeg FUNCTION DOES NOT WORK IF DELETING FROM NEW SEQ AND HEADS-TAILS NOT PAIRED"
		return 0
	}
	if {$fromnewseq && $htpaired} {
		set headfirst 1												
	} else {
		set headfirst $segment(headfirst)												
	}															;#	012345678
	if {[IsEven $k] && !$headfirst} {							;#	ththththt
		return 1												;#	012345678
	} elseif {![IsEven $k] && $headfirst} {						;#	hthththth
		return 1
	}
	return 0
}

#--- When a box in original segments is clicked on, it creates a new box in reordered-sequence

proc AddSegmentToGettrofReorderedSequence {n} {
	global segment evv
	if {$segment(reordercnt) >= $evv(MAX_REORDERED_SEGS)} {
		Inf "TOO MANY SEGMENTS (MAX $evv(MAX_REORDERED_SEGS))"
		return
	}
	if {$segment(hti) == 2} {
		if {[IsTailSeg $n 0 1]} {
			if {$n == 0} {
				Inf "CANNOT SELECT AN ISOLATED TAIL-SEGMENT IF HEAD-TAIL PAIRINGS TO BE PRESERVED"
				return
			}
		} else {
			if {$n == [expr $segment(cnt) - 1]} {
				Inf "CANNOT SELECT AN ISOLATED HEAD-SEGMENT IF HEAD-TAIL PAIRINGS TO BE PRESERVED"
				return
			}
		}
	} elseif {$segment(hti)} {
		if {![IsEven [expr $segment(htselect) + $n]]} {
			if {[expr $segment(htselect) + $segment(headfirst)] == 1} {	;#	if Head/Tail alternation is to be preserved....
				if {$segment(headfirst)} {								;#	If selection is set for EVEN numbered items (segment(htselect) = 0)
					Inf "SELECT A HEAD (Odd numbered)"					;#	If Even number 0 2 4 6 Sum = 0 2 4 6 = Even : OK to choose
				} else {												;#	If Odd  number 1 3 5 7 Sum = 1 3 5 7 = Odd  : NOT OK to choose
					Inf "SELECT A HEAD (Even numbered)"
				}
			} else {
				if {$segment(headfirst)} {
					Inf "SELECT A TAIL (Even numbered)"
				} else {
					Inf "SELECT A TAIL (Odd numbered)"
				}
			}
			return														;#	If selection is set for ODD numbered items (segment(htselect) = 1)
		}																;#	If Even number 0 2 4 6 Sum = 1 3 5 7 = Odd  : NOT OK to choose
																		;#	If Odd  number 1 3 5 7 Sum = 2 4 6 8 = Even : OK to choose
	}
	set segment(rtext$segment(reordercnt)) $segment(mtext$n)
	$segment(re$segment(reordercnt)) config -bd 2
	bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
	incr segment(reordercnt)
	if {($segment(hti) == 2) && ![info exists segment(multicopy)] && ![info exists segment(grpcopy)]} {
		incr n
		set segment(rtext$segment(reordercnt)) $segment(mtext$n)
		$segment(re$segment(reordercnt)) config -bd 2
		bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
		incr segment(reordercnt)
	}
	if {[info exists segment(multicopy)]} {
		if {$segment(hti)} {											;#	if Head/Tail alternation is to be preserved....
			if {$n == [expr $segment(cnt) - 1]} {						;#	Have to make multiple copies as H/T (or T/H) pairs
				Inf "NO PAIR OF SEGMENTS TO COPY"
				return													;#	So if pointing to last segment, no pair to copy
			}
			incr n
			set segment(rtext$segment(reordercnt)) $segment(mtext$n)	;#	Copy 2nd element of TH (HT) pair
			$segment(re$segment(reordercnt)) config -bd 2
			bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
			incr segment(reordercnt)
			incr n -1													;#	Then skip back to first

			incr segment(multicopy) -1
			set k 0
			while {$k < $segment(multicopy)} {							;#	Make multicopy copies of the pair
				set segment(rtext$segment(reordercnt)) $segment(mtext$n)
				$segment(re$segment(reordercnt)) config -bd 2
				bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
				incr segment(reordercnt)
				incr n
				set segment(rtext$segment(reordercnt)) $segment(mtext$n)
				$segment(re$segment(reordercnt)) config -bd 2
				bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
				incr segment(reordercnt)
				incr n -1
				incr k
			}
		} else {
			incr segment(multicopy) -1
			set k 0
			while {$k < $segment(multicopy)} {
				if {$segment(reordercnt) >= $evv(MAX_REORDERED_SEGS)} {
					Inf "TOO MANY SEGMENTS (MAX $evv(MAX_REORDERED_SEGS))"
					unset segment(multicopy)
					return
				}
				set segment(rtext$segment(reordercnt)) $segment(mtext$n)
				$segment(re$segment(reordercnt)) config -bd 2
				bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
				incr segment(reordercnt)
				incr k
			}
		}
	} 
	if {[info exists segment(grpcopy)]} {
		incr segment(grpcopy) -1
		set k 0
		incr n
		set n [expr $n % $segment(cnt)]
		if {($n == 0) && $segment(hti) && ![IsEven $segment(cnt)]} {	;#	If we've returned to start of original sequence (n == 0)
			incr n														;#	and orig sequence has ODD number so e.g. THTHT or HTHTH
		}																;#	the sequence will go e.g. (end)T(start)T
		while {$k < $segment(grpcopy)} {								;#	so we skip to next H so sequence goes (end)T(start)H
			if {$segment(reordercnt) >= $evv(MAX_REORDERED_SEGS)} {
				Inf "TOO MANY SEGMENTS (MAX $evv(MAX_REORDERED_SEGS))"
				unset segment(grpcopy)
				return
			}
			set segment(rtext$segment(reordercnt)) $segment(mtext$n)
			$segment(re$segment(reordercnt)) config -bd 2
			bind $segment(re$segment(reordercnt)) <ButtonRelease-1> "GettrofRemoveReorderedSeg $segment(reordercnt)"
			incr segment(reordercnt)
			incr k
			incr n
			set n [expr $n % $segment(cnt)]
		}
		if {$segment(hti) == 1} {										;#	e.g. Originally set to "T" : if grpcopy is ODD (say 3)
			if {[IsEven $segment(grpcopy)]} {							;#  we copy THT and must flip to slect "H" next time
				set segment(htselect) [expr !$segment(htselect)]		;#	but grpcpy has been decremented, so EVEN means flip to "H"
			}															;#	But if grpcopy is even (say 4)
		}																;#  we copy THTH so next selection is still "T"
	}														
	if {[info exists segment(multicopy)] || [info exists segment(grpcopy)]} {
		catch {unset segment(multicopy)}								;#	In Head/Tail preserving state, these always use HT (TH) pairs
		catch {unset segment(grpcopy)}									;#	so no need to now flip from using "H" to using "T" (or vice versa)
	} elseif {$segment(hti) == 1} {
		set segment(htselect) [expr !$segment(htselect)]				;#	Flip from chosing "H" to "T" or vice versa
	}
}

#-- Setup "flags" for multiple copying of segments in REORDER

proc MultiBinds {where on} {
	if {$on} {
		bind $where <Key-2> {GettrofMulticopy 2}
		bind $where <Key-3> {GettrofMulticopy 3}
		bind $where <Key-4> {GettrofMulticopy 4}
		bind $where <Key-5> {GettrofMulticopy 5}
		bind $where <Key-6> {GettrofMulticopy 6}
		bind $where <Key-7> {GettrofMulticopy 7}
		bind $where <Key-8> {GettrofMulticopy 8}
		bind $where <Control-Key-2> {GettrofGroupcopy 2}
		bind $where <Control-Key-3> {GettrofGroupcopy 3}
		bind $where <Control-Key-4> {GettrofGroupcopy 4}
		bind $where <Control-Key-5> {GettrofGroupcopy 5}
		bind $where <Control-Key-6> {GettrofGroupcopy 6}
		bind $where <Control-Key-7> {GettrofGroupcopy 7}
		bind $where <Control-Key-8> {GettrofGroupcopy 8}
	} else {
		bind $where <Key-2> {}
		bind $where <Key-3> {}
		bind $where <Key-4> {}
		bind $where <Key-5> {}
		bind $where <Key-6> {}
		bind $where <Key-7> {}
		bind $where <Key-8> {}
		bind $where <Control-Key-2> {}
		bind $where <Control-Key-3> {}
		bind $where <Control-Key-4> {}
		bind $where <Control-Key-5> {}
		bind $where <Control-Key-6> {}
		bind $where <Control-Key-7> {}
		bind $where <Control-Key-8> {}
	}
}

#--- Set flag to copy N instances of selected segment

proc GettrofMulticopy {n} {
	global segment
	catch {unset segment(grpcopy)}
	set segment(multicopy) $n
}

#--- Set flag to copy a sequence of N segments starting at the selected segment

proc GettrofGroupcopy {n} {
	global segment
	catch {unset segment(multicopy)}
	set segment(grpcopy) $n
}

proc GettrofReorderHelp {typ} {
	global segment
	switch -- $typ {
		MULTIPROC {
			set msg "MULTIPROCESSING\n"
			append msg "\n"
			append msg "Click in a box to select it.\n"
			append msg "(Move focus from box to box with \"Up\" or \"Down\" Keys).\n"
			append msg "\n"
			append msg "Then select the process to place in the selected box\n"
			append msg "by pressing the appropriate button for the process.\n"
			append msg "\n"
			append msg "Empty a box using \"Delete\"\n"
			append msg "\n"
			if {!$segment(phrase)} {
				append msg "Once all Tail processes have been chosen, press \"Tails Done\"\n"
				append msg "and proceed to enter Head processes.\n"
				append msg "\n"
			}
			append msg "Not all segments need to be processed.\n"
			append msg "\n"
		}
		ENTERTEXT {
			set msg "MNEMONIC TEXT ENTRY OR EDITING\n"
			append msg "\n"
			append msg "Click in a box to select it.\n"
			append msg "(Move focus from box to box with \"Up\" or \"Down\" Keys).\n"
			append msg "\n"
			append msg "Then enter or edit the text in the box.\n"
			append msg "\n"
			append msg "All boxes must contain some text.\n"
			append msg "No spaces are allowed in entered texts.\n"
			append msg "\n"
			if {[info exists segment(intext)]} {
				append msg "Then press \"Edit Text\" to save the new text.\n"
			} else {
				append msg "Then press \"Enter Text\" to save the new text.\n"
			}
			append msg "\n"
		}
		ENTERSCAN {
			set msg "SCANSION OVER MNEMONIC TEXT\n"
			append msg "\n"
			append msg "Click in a box to select it.\n"
			append msg "(Move focus from box to box with \"Up\" or \"Down\" Keys).\n"
			append msg "\n"
			append msg "Then enter Scansion in the box using Entry buttons.\n"
			append msg "\n"
			append msg "All boxes must contain some scansion.\n"
			append msg "No spaces are allowed in entered scans.\n"
			append msg "\n"
		}
		ARTICULATION {
			set msg "ARTICULATION OVER MNEMONIC TEXT\n"
			append msg "\n"
			append msg "Click in a box to select it. (Move focus from box to box with \"Up\" or \"Down\" Keys).\n"
			append msg "Enter Articulation in the box using Entry buttons.\n"
			append msg "NB\n"
			append msg "(1)  NO SPACES are allowed in entered Articulations, BUT ENTRY MAY BE EMPTY (no effect).\n"
			append msg "(2)  Character CAN'T BE ENTERED MORE THAN TWICE (and some only once) in any single box.\n"
			append msg "         Double entries must be CONTIGUOUS (e.g. \"HH^\", and not \"H^H\").\n"
			append msg "\n"
			append msg "\"^\" .... ACCENT (\"^^\" Stronger accent.)\n"
			append msg "\n"
			append msg "\"H\" .... HIGHER pitch.\n"
			append msg "\"L\" .... LOWER pitch.\n"
			append msg "\"U\" ..... MOVE UP IN PITCH from given pitch  : varies on each application.\n"
			append msg "\"D\" ..... MOVE DOWN PITCH from given pitch   : varies on each application.\n"
			append msg "\"?\" .... QUESTIONING (or SURPRISED) intonation, rising from below given pitch to above given pitch.\n"
			append msg "                        (\"??\", Even more surprised etc.).\n"
			append msg "\"!\" .... DENIAL (or EMPHASIS or DISGUST) intonation, falling from above given pitch to below given pitch.\n"
			append msg "                 \"H\", \"L\", \"U\", \"D\", \"?\", and \"!\" cannot be used together on the same segment,\n"
			append msg "                 and they all vary on each application.\n"
			append msg "\n"
			append msg "\">\" .... TIMESTRETCH And stretch gap between segments. (\">>\" Timestretch more) : varies on each application.\n"
			append msg "\"<\" .... TIMESHRINK And shrink gap between segments. (\"<<\" Timeshrink more) : varies on each application.\n"
			append msg "\"|\" ..... CLIP: Shorten event but NOT gap between segments.\n"
			append msg "                        \">\", \"<\" and \"|\" cannot be used together on the same segment.\n"
			append msg "\n"
			append msg "\" ' \" .... HESITATE ('  ' =  Longer hesitation) : varies on each application.\n"
			append msg "\n"
			append msg "\"x\" .... OMIT (and join up gap to next segment).\n"
			append msg "\"X\" .... SILENCE (time of next segment is unchanged).\n"
			append msg "                        These can only be used on their own.\n"
			append msg "\n"
			append msg "\"3\" .... (ANY NUMBER,N > 1) REPEAT, SO THE EVENT OCCURS N TIMES with randomised hesitations between repeats.\n"
			append msg "                        (Enter using Control Up/Down Keys) \n"
			append msg "\"m\" .... UM,UR Glossalalia (relies on a bank of glossolalia, FOR THIS VOICE, being available.\n"
			append msg "                        The names of these files must end in \"_um\" and be stored in a specific directory).\n"
			append msg "                        Um,Ur varies on each call if more than one sound (in the chosen directory) is available.\n"
			append msg "\"t\" .... TIC (relies on a bank of \"tics\", FOR THIS VOICE, being available.\n"
			append msg "                        The names of these files must end in \"_tic\" and be stored in a specific directory).\n"
			append msg "                        Tics are recurring phrases like \"you know\" \"init\" etc.\n"
			append msg "                        Tic varies on each call if more than one (in the chosen directory) is available.\n"
			append msg "\n"
			append msg "\")\" .... TIE (must occur on its own): Do previous articulation\n"
			append msg "                        across original and (all) tied segments AS A GROUPED WHOLE.\n"
			append msg "                TIES only work after a prior pitch-changing (HLUD?!) or time-stretching (<>) articulation.\n"
			append msg "\n"
		}
		REORDER {
			set msg "REORDERING MNEMONICS\n"
			append msg "\n"
			append msg "Click in one of the original-text boxes to select its contents.\n"
			append msg "(Move focus from box to box with \"Up\" or \"Down\" Keys).\n"
			append msg "\n"
			append msg "Normally, the alternating Head/Tail structure of the original segments\n"
			append msg "will be maintained in any new permutation generated.\n"
			append msg "This means that a PAIR (HT or TH) of segments (the clicked-on box and the next)\n"
			append msg "will be selected when you click on a box.\n"
			append msg "\n"
			append msg "The selected texts will appear in new boxes at the foot of the display.\n"
			append msg "Any further texts selected will appear in further boxes, abutted to the others.\n"
			append msg "And so on.\n"
			append msg "\n"
			append msg "To REMOVE a box from the new reordered-text, click on the box.\n"
			append msg "Normally a PAIR of boxes (the selected box and the next box) will be removed.\n"
			append msg "\n"
			append msg "You can override this pairing by deselecting \"Preserve Head/Tail Structure\".\n"
			append msg "Note that, once this is done, the output cannot be recycled for further processing.\n"
			append msg "\n"
			append msg "You can make multiple copies of any box.\n"
			append msg "Click on the window background then hit a number (2-8)\n"
			append msg "before selecting the required-text box.\n"
			append msg "If Head/Tail Structure is preserved, Box-PAIRS will be duplicated.\n"
			append msg "\n"
			append msg "To copy a sequence of N of the original-boxes,\n"
			append msg "Click on the window background then hit number (2-8) with \"Control\" key depressed\n"
			append msg "before selecting the start box of the required sequence.\n"
			append msg "Again, if Head/Tail structure is preserved, N pairs of boxes will be selected.\n"
			append msg "\n"
			append msg "If the sequence reaches the end of the original set\n"
			append msg "it will wrap around to the start of the originals.\n"
			append msg "Where Head/Tail structure is preserved, but there are an ODD number of segments\n"
			append msg "(so the 1st and last segments are both Heads, or both Tails), the wrap-around will\n"
			append msg "SKIP the first item in the sequence to avoid 2 adjacent Heads (or Tails).\n"
			append msg "\n"
			append msg "\"Rand Order\" will make a Random permutation of the original segments\n"
			append msg "If Head/Tail Structure is set to be preserved, the permutation will preserve it,\n"
			append msg "but if NOT, the new permutation will most probably mix up Heads and Tails.\n"
			append msg "\n"
			append msg "The reordered set can be the same length as the original, or a different length.\n"
			append msg "If a random permutation has already been made, of a different length to the original,\n"
			append msg "if \"Rand Order\" is called a 2nd time, with a specified length,\n"
			append msg "you can choose to permute the original or the new segment-sequence.\n"
		}
	}
	Inf $msg
}

#--- Actions on recycling a RETIMED file

proc GettrofReorderedRecycle {} {
	global segment evv

	;#	FIND NEW TOTAL SOUND DURATION

	if {![DoSegmentDurParse $segment(outfnamplay)]} {
		Inf "FAILED TO FIND DURATION OF PREVIOUS OUTPUT SOUND"
		return 0
	}
	set segment(wavdur) $segment(itemdur)

	;#	ESTABLISH NEW MARKLIST

	set fnam [lindex [lindex $segment(mixlines) 0] 0]
	lappend fnams $fnam
	set time 0.0
	lappend times $time
	set is_head 1										;# with HEAD first				with TAIL first				
	if {$segment(headfirst)} { 							;#
		set is_head 0		;#	ie. 2nd event is Head	;#| _H_|	   |_H_|			| __T__	|   | __T__ |   | __
	}													;#|/   |\__T__/|   |\__T__		|/     \|_H_|/     \|_H_|/
	foreach line [lrange $segment(mixlines) 1 end] {	;#|	   |/	  \|   |/	  \		|	   /|	|\     /|   |\
		set fnam [lindex $line 0]						;#|	   |	   |   |			|	   	|   |       |   |	
		set time [lindex $line 1]						;#0   Tail	   |  Tail			0		|  Tail		|  Tail
		if {$is_head} {									;#|	  start	   |  start			|		|  start	|   ETC
			set time [expr $time + $segment(SPLICE)]	;#|	  in mix   |  in mix		|		|  in mix	|
		}												;#|	   |	   |   |			|		|	|		|
		set is_head [expr !$is_head]					;#|	   |	   |   |	ETC		|		|	|		|
		lappend fnams $fnam								;#			 Head					   Head  	   Head
		lappend times $time								;#		  start-in-mix				start-in-mix   s-i-m
	}													;#		   +splicelen				 +splicelen		+s
	lappend times [expr $segment(wavdur) + 10]
	set segment(marklist) $times
	set segment(cnt) [llength $segment(mixlines)]

	;#	SYSTEMATICALLY RENUMBER FILES (AS HEADS AND TAILS, IN ORDER)
	
	set n 1
	foreach fnam $fnams {
		set nunam $evv(DFLT_OUTNAME)X
		append nunam $n $evv(SNDFILE_EXT)
		if [catch {file copy $fnam $nunam} zit] {
			Inf "FAILED TO COPY SEGMENT $n OF REORDERED SOUND, TO SYSTEMATICALLY RENAME IT"
			return 0
		}
		incr n
	}
	set n 1 
	foreach fnam [glob -nocomplain $evv(DFLT_OUTNAME)HH*] {
		if [catch {file delete $fnam} zit] {
			Inf "FAILED TO DELETE HEAD SEGMENT $n OF PREVIOUS SOUND"
			return 0
		}
		incr n
	}
	set n 1 
	foreach fnam [glob -nocomplain $evv(MACH_OUTFNAME)TD*] {
		if [catch {file delete $fnam} zit] {
			Inf "FAILED TO DELETE TAIL SEGMENT $n OF PREVIOUS SOUND"
			return 0
		}
		incr n
	}
	set ishead 0
	if {$segment(headfirst)} {
		set ishead 1
	}
	set m 0
	set n 1
	set hcnt 1
	set tcnt 1
	foreach fnam $fnams {
		set oldnam $evv(DFLT_OUTNAME)X
		append oldnam $n $evv(SNDFILE_EXT)
		if {$ishead} {
			set nunam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
			incr hcnt
		} else {
			set nunam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
			incr tcnt
		}
		if [catch {file rename $oldnam $nunam} zit] {
			Inf "FAILED TO SYSTEMATICALLY RENAME SEGMENT $n"
			return 0
		}
		set ishead [expr !$ishead]
		set mixline [lindex $segment(mixlines) $m]
		set mixline [lreplace $mixline 0 0 $nunam]
		set segment(mixlines) [lreplace $segment(mixlines) $m $m $mixline]		 
		incr n
		incr m
	}

	;#	WRITE MODIFIED MIXLINES TO MIXFILE

	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixfil) TO MAKE PROCESSED SOUND"
		continue
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	set segment(recycprocess) 0
	.gettrofs.0.s  config -text "" -command {} -bd 0 -state disabled	;#	CANNOT RESTART DURING REORDERED RECYCLE
	return 1															;#	as marklist and segment(cnt) may have been altered
}

#--- Head/Tail Structuring cannot be turned BACK ON unless the reordered segset is cleared

proc HtiStructure {} {
	global segment
	if {$segment(hti_init)} {
		if {$segment(hti) && ($segment(reordercnt) > 0)} {
			set segment(hti) 0
			set segment(htj) 0
			set segment(htp) 0
			Inf "CANNOT RESET HEAD/TAIL STRUCTURE UNTIL REORDERED SET IS CLEARED"
		}
	}
	if {!$segment(htj)} {
		set segment(htp) 0
		set segment(hti) 0
	}
}

#--- Link Head-Tail presrved p[airing to Head/Tail Structuring

proc HtpCommand {} {
	global segment
	if {$segment(htp)} {
		set segment(htj) 1
		set segment(hti) 2
	} else {
		set segment(hti) 1
	}
	HtiStructure
}

#--- Clear displayed values of all mnemonics, and hide any existing mnemonic boxes
#--- On repartitioning a sound into phrases (option "phrase"), query if existing phrase-segmentation-file for sound is to be discarded

proc ClearAllMnemonicDisplays {phrase} {
	global segment evv wstk
	set n 0
	while {$n < $segment(cnt)} {
		set segment(mtext$n) ""
		catch {$segment(tx$n) config -bd 0}
		incr n
	}
	if {[info exists segment(mtext$n)]} {
		set segment(mtext$n) ""
		catch {$segment(tx$n) config -bd 0}
		incr n
	}
			
	set n 0
	while {$n < $segment(reordercnt)} {
		set segment(rtext$n) ""
		$segment(re$n) config -bd 0
		bind $segment(re$n) <ButtonRelease-1> {}
		incr n
	}
	if {$phrase} {
		set fnam [file rootname [file tail $segment(src,0)]]
		append fnam "_phrs" $evv(TEXT_EXT)
		set fnam [file join $segment(dirname) $fnam]
		if {[file exists $fnam]} {
			set msg "REMOVE EXISTING PHRASE-MNEMONICS FILE ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				if [catch {file delete $fnam} zit] {
					Inf "CANNOT DELETE PHRASE-MNEMONICS FILE $fnam"
				}
			}
		}
	}
}

#--- Make initialise mixfile-lines from PHRASE components, before processing begins

proc GettrofMakePhraseMixlines {} {
	global segment evv
	set n 1
	set time 0
	while {$n <= $segment(cnt)} {
		set fnam $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
		set line [list $fnam $time 1 1.0]
		lappend lines $line
		set time [expr [lindex $segment(marklist) $n] - $segment(SPLICE)]
		incr n
	}
	set segment(mixlines) $lines
}

#--- Replace line in phrases mixfile, with new line (or name in line with new filename)

proc PhraseLineReinsert {n nu isline} {
	global segment
	set kk [expr $n - 1]							;#	segs numbered from 1, lines from 0
	if {$isline} {
		set nuline $nu								;#	nu = line: replaces entire line	
		set segment(mixlines) [lreplace $segment(mixlines) $kk $kk $nuline]
	} else {
		set nuname $nu								;#	nu = name : Replaces name in existing  line
		set line [lindex $segment(mixlines) $kk]
		set line [lreplace $line 0 0 $nuname]
		set segment(mixlines) [lreplace $segment(mixlines) $kk $kk $line]
	}
}

#--- Check if adjacent files in output mix have SAME indexing number

proc SameFileIndexingNumber {n} {
	global segment

	set fnam_1 [lindex [lindex $segment(mixlines) $n] 0]		;#	fnameXYW12.wav
	set findex1 [file rootname [file tail $fnam_1]]				;#	fnameXYW12
	set typ1 TAIL
	if {[string first "H" $findex1] > 0} {
		set typ1 HEAD
	} 
	set findex1 [ReverseString $findex1]						;#	21WYXemanf
	set len [string length $findex1]
	set k 0
	while {$k < $len} {													
		if {![regexp {^[0-9]+$} [string index $findex1 $k]]} {	;#	21W
			break												;#k=012
		}
		incr k
	}
	if {$k == 0} {
		Inf "ERROR: NO NUMBER FOUND AT END OF TEMPORARY FILENAME $fnam_1"
		return 0
	}
	incr k -1													;#	k = 1
	set findex1 [string range $findex1 0 $k]					;#	21
	set findex1 [ReverseString $findex1]						;#	12

	incr n -1

	set fnam_2 [lindex [lindex $segment(mixlines) $n] 0]		;#	fnameXYW12.wav
	set findex2 [file rootname [file tail $fnam_2]]				;#	fnameXYW12
	set typ2 TAIL
	if {[string first "H" $findex2] > 0} {
		set typ2 HEAD
	} 
	if {$typ1 != $typ2} {										;#	Head and processed Head (in texture) can be compared
		return 0												;#	But don't compare Head and Tail with same index number!!
	}

	set findex2 [ReverseString $findex2]						;#	21WYXemanf
	set len [string length $findex2]
	set k 0
	while {$k < $len} {													
		if {![regexp {^[0-9]+$} [string index $findex2 $k]]} {	;#	21W
			break												;#k=012
		}
		incr k
	}
	if {$k == 0} {
		Inf "ERROR: NO NUMBER FOUND AT END OF TEMPORARY FILENAME $fnam_2"
		return 0
	}
	incr k -1													;#	k = 1
	set findex2 [string range $findex2 0 $k]					;#	21
	set findex2 [ReverseString $findex2]						;#	12
	if {$findex1 == $findex2} {
		return 1
	}
	return 0
}

#--- Forces "Expand" button to be fixed until a "Restart" happens

proc ExpandFix {} {
	.gettrofs.0.ch config -state disabled
	Inf "TO RESET THE EXPAND FUNCTION : HIT RESTART"
}

#--- After a zigzag extension of source, for zigzagged phrases, cut the phrases out of the zigzagged source
#--- and use these in the (already existing) output mixlines

proc SegmentOutsound_andRewriteMix {actionlist blocked_at_start} {
	global segment prg_dun prg_abortd simple_program_messages CDPidrun evv
	set j 0
	set k 1
	if {$segment(process) == "ZIGZAG"} {
		set ifnam $segment(othersnd)
	} else {
		Inf "UNKNOWN PROCESS CALLING SegmentOutsound_andRewriteMix"
		return 0
	}
	if {!$blocked_at_start} {
		Block "PLEASE WAIT:        CUTTING ZIGZAGGED PHRASES FROM OUTPUT SOUND"
	}
	set OK 1
	while {$j < $segment(cnt)} {
		set do [lindex $actionlist $k]			;#	Actionlist counts from 1 (0 entry is a dummy)
		if {$do} {								;#	Marks count from 0
			set stt [expr [lindex $segment(numarks) $j] - $segment(SPLICE)]
			if {$stt < 0.0} {
				set stt 0.0
			}
			set endd [lindex $segment(numarks) $k]
			set ofnam $evv(MACH_OUTFNAME)HX$k$evv(SNDFILE_EXT)

			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			lappend cmd cut 1 $ifnam $ofnam $stt $endd -w$segment(SPLICE)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CUTTING ZIGZAGGED PHRASE $k FROM OUTPUT SOUND"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN EXACT-SIZE-CUT PROCESS FOR ZIGZAGGED PHRASE $k"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE CUT ZIGZAGGED PHRASE $k FROM OUTPUT SOUND"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO ZIGZAGGED PHRASE $k CUT FROM OUTPUT SOUND"
				set OK 0
				break
			}
			lappend linenos $j
			lappend outfiles $ofnam
		}
		incr j
		incr k
	}
	if {!$OK} {
		if {!$blocked_at_start} {
			UnBlock
		}
		return 0
	}
	foreach lineno $linenos ofnam $outfiles {
		set line [lindex $segment(mixlines) $lineno]
		set line [lreplace $line 0 0 $ofnam]
		set segment(mixlines) [lreplace $segment(mixlines) $lineno $lineno $line]
	}
	if {!$blocked_at_start} {
		UnBlock
	}
	if {!$OK} {
		return 0
	}
	return 1
}

#--- (re)Initialise all flags for the BOUNCE process

proc InitBounceFlags {} {
	global segment
	set segment(dflt0,BOUNCE) 1	  		;#	Shrink	
	set segment(dflt1,BOUNCE) 0  		;#	Cut
	set segment(dflt2,BOUNCE) 0  		;#	Cut Start
	set segment(dflt3,BOUNCE) 0  	    ;#	Overlay following tail (default NOT overlayed)
	if {[info exists segment(lastpar0,BOUNCE)]} {
		set segment(par0) $segment(lastpar0,BOUNCE)
	} else {
		set segment(par0) $segment(dflt0,BOUNCE)
	}
	if {[info exists segment(lastpar1,BOUNCE)]} {
		set segment(par1) $segment(lastpar1,BOUNCE)
	} else {
		set segment(par1) $segment(dflt1,BOUNCE)
	}
	if {[info exists segment(lastpar2,BOUNCE)]} {
		set segment(par2) $segment(lastpar2,BOUNCE)
	} else {
		set segment(par2) $segment(dflt2,BOUNCE)
	}
	if {[info exists segment(lastpar3,BOUNCE)]} {
		set segment(par3) $segment(lastpar3,BOUNCE)
	} else {
		set segment(par3) $segment(dflt3,BOUNCE)
	}
}


#--- Get any paramvals that are preset before main body of parameter entry

proc GettrofPresets {} {
	global segment wstk
	switch -- $segment(process) {
		"TEXTURE" {
			set test [TextureChancnt]
		}
		"BOUNCE" {
			set test [BounceCutstyle]
		}
		"HPITCH" {
			set test [HeadPitchStyle]
		}
		"TWANG" {
			set test [TwangStyle]
		}
		"PITCH" {
			set test [TuningStyle 0]
		}
		"TUNED" {
			set test [TuningStyle 1]
		}
		"RETIME" {
			set test [RetimeStyle]
		}
		"DELRING" {
			set test [DelRingStyle]
		}
		"FORMOVE" {
			set test [FormoveStyle]
		}
		"LOOP"    -
		"REVERB"  -
		"TREMOLO" -
		"DISTREP" -
		"VERGES" {
			set test [VergesStyle]
		}
		"TRANSFER" {
			set test [TransferStyle]
		}
		"REVERSAL" {
			set test [ReversalStyle]
		}
		"SHRHYTHM" {
			set test [ShrhythmStyle]
		}
		"ARTICULATION" {
			set test [ArticulationStyle]
		}
		"ZIGACCEL" {
			set test [ZigAccelStyle]
		}
		"TUBEREV" {
			set test [TuberevStyle]
		}
		"SPIKE" {
			set test [SpikeStyle]
		}
		"SQZBOX" {
			set test [SqzboxStyle]
		}
		"TSTRETCH" {
			set test [TstretchStyle]
		}
		"VOCODE" -
		"EDOCOV" {
			if {[MultipleProcessing]} {
				foreach dud $segment(multido) {
					if {[string match [lindex $dud 0] $segment(process)]} {
						set actionlist [lindex $dud 1]
						set actcnt 0
						foreach action $actionlist {
							incr actcnt $action
						}
						break
					}
				}
			} else {
				set actcnt [expr $segment(cnt)/2]
				if {!$segment(headfirst)} {
					incr actcnt
				}
			}
			if {$segment(infilecnt) != 2} {
				set vocfcnt [expr $segment(infilecnt) - 1]
				set query 0
				if {$actcnt > $vocfcnt} {
					if {$segment(phrase)} {
						set msg "INSUFFICIENT VOCODING FILES ($vocfcnt) TO MATCH ALL SOURCE SEGMENTS TO BE PROCESSED ($actcnt)\n"
					} else {
						set msg "INSUFFICIENT VOCODING FILES ($vocfcnt) TO MATCH ALL SOURCE TAILS TO BE PROCESSED ($actcnt)\n"
					}
					append msg "\nPROCEED WITH VOCODOING USING FILE 2 ($segment(src,2)) ONLY ??"
					set effective_files 2
					set query 1
				} elseif {$actcnt < $vocfcnt} {
					if {[MultipleProcessing]} {
						set msg "INSUFFICIENT SOURCE SEGMENTS CHOSEN FOR VOCODING ($actcnt) TO MATCH ALL VOCODING SIGNALS ($vocfcnt).\n"
					} else {
						set msg "INSUFFICIENT SOURCE TAIL SEGMENTS ($actcnt) TO MATCH ALL VOCODING SIGNALS ($vocfcnt).\n"
					}
					append msg "\nPROCEED WITH VOCODOING USING $actcnt VOCODING SOURCES ONLY ??"
					set query 1
					set effective_files [expr $acntcnt + 1]
				}
				if {$query} {
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						return 0
					} else {
						set segment(infilecnt) $effective_files
					}
				}
			}
			set test [VocodeStyle]
		}
	}
	return $test
}

#############################
#	EXPAND AND NO_EXPAND	#
#############################

#--- Expand the rejoined segments to take into account any tstretching of segments, so segments are abutted and not overlayed,

proc ExpandPhraseMix {writemix} {
	global segment
	set n 0
	set j 0
	set k 1
	set lasttime 0.0
	set this_seg 1											;#	segment-index, noexpand index
	set this_lin 0											;#	line index
	set next_lin 1											;#	nextline index
	set len [llength $segment(mixlines)]
	set thisline [lindex $segment(mixlines) $this_lin]
	set thistime [lindex $thisline 1]
	while {$next_lin < $len} {											;#	IF durations are		A	B	C	D
		set fnam [lindex $thisline 0]									;#	and steps in mixfile	a	b	c	d
		set nextline [lindex $segment(mixlines) $next_lin]
		set nexttime [lindex $nextline 1]
		set step [expr $nexttime - $thistime]
		if {[GettrofNoExpand $this_seg]} {								;#	e.g. at seg 3 we get
			lappend durs $step											;#	A	B	c	D
		} else {
			if {![DoSegmentDurParse $fnam]} {
				Inf "FAILED TO FIND DURATION OF SEGMENT [expr $this_lin + 1] ($fnam)"
				return 0
			}															;#	e.g. at seg 3 we get
			lappend durs [expr $segment(itemdur)  - $segment(SPLICE)]	;#	A	B	C	D
		}
		set thistime $nexttime
		set thisline $nextline
		incr this_lin
		incr next_lin
		incr this_seg
	}
	set len_less_one [expr $len - 1]
	set n 0
	set m 0
	set time 0.0
	while {$n < $len} {
		set line [lindex $segment(mixlines) $n]
		set line [lreplace $line 1 1 $time]
		set segment(mixlines) [lreplace $segment(mixlines) $n $n $line]
		if {$n < $len_less_one} {
			set dur [lindex $durs $m]
			set time [expr $time + $dur]
		}
		incr n
		incr m
	}
	return 1
}

#--- "noexpand" markers mark a mixfile line that is not to be moved relative to the preceding line
#--- even if the global "segment(expand)" flag has been set

proc ClearNoexpands {} {
	global segment
	foreach nam [array names segment] {
		if {[string first "noexpand" $nam] == 0} {
			if {![string match $nam noexpand]} {			;#	deletes all (noexpandN) but NOT (noexpand)
				unset segment($nam)
			}
		}
	}
}

#--- Find if a phrase is marked not to expand

proc GettrofNoExpand {n} {
	global segment
	if {[info exists segment(noexpand$n)]} {
		return 1
	}
	return 0
}

#--- Shuffle up no-expand flags, if a file is INSERTED (not just replacing an existing file) in the mixfile
#--- k must equal the segment number AFTER the inserted file

proc AdvanceNoexpand {k lexlen} {
	global segment
	set n $lexlen					;#	mixlines count from 0, segments count from 1: length of mixlines = index of final segment
	set m [expr $n + 1]
	while {$n >= $k} {
		if {[info exists segment(noexpand$n)]} {
			set segment(noexpand$m) 1
			unset segment(noexpand$n)
		}
		incr m -1
		incr n -1
	}
}

#--- Shuffle dn no-expand flags, if a file is DELETED from the mixfile
#--- k must equal the segment number AFTER the inserted file

proc ContractNoexpand {k lexlen cnt} {	;#	Only used in multiproc : lexlen = length of mixfile
	global segment						;#	mixlines count from 0, segments count from 1: length of mixlines = index of final segment
	if {$cnt == 1} {
		if {$k == $lexlen} {
			catch {unset segment(noexpand$k)}
			return
		}
	} elseif {$cnt == 2} {
		 if {$k == [expr $lexlen - 1]} {
			catch {unset segment(noexpand$k)}
			incr k
			catch {unset segment(noexpand$k)}
			return
		}	
	} else {
		Inf "UNKNOWN OPTION IN \"ContractNoexpand\": QUIT AND UPDATE PROGRAM!!"
		return
	}
	set m [expr $k + $cnt]
	while {$m <= $lexlen} {
		if {[info exists segment(noexpand$m)]} {
			set segment(noexpand$k) 1
			unset segment(noexpand$m)
		} else {
			catch {unset segment(noexpand$k)}
		}
		incr m
		incr k
	}
	if {$cnt == 2} {
		catch {unset segment(noexpand$k)}
	}
}

#--- Multiple processing, implies a mixfile already exists

proc MultipleProcessing {} {
	global segment
	if {[info exists segment(recycprocess)] || $segment(multiproccnt)} {
		return 1
	}
	return 0
}

#--- Find the mixline which corresponds to a segment number

proc GetFilenameInMixlineCorrespondingToCurrentSegment {n} {
	global segment							
											;#	n = segment number, segments numbered from 1
	incr n -1								;#	Mixlines numbered from 0

	if {$segment(multiproccnt)} {
		set m $n							;#	segment(multiflag) = List of process-flags associated with segments (counted from 0)
		incr m -1							;#	last entry of flaglist BEFORE current process n-1 --> m
		set subflag [lrange $segment(multiflag)	0 $m]
		foreach k $subflag {				;#	Test for any prior processes which ADD an extra line to mixfiles list
			if [lindex $segment(didaddfil) $k] {
				incr n
			}
		}
	}
	set hfnam [lindex [lindex $segment(mixlines) $n] 0]
	return $hfnam
}

#--- Where a process has forced content to be multichannel : change normal mixfile lines to multichan format
#
#	Apart from RETIME, all processes uses MONO/STEREO (old) format of mixfile, even if they produce e.g. 8-chan output files
#	At this final stage, such anomalies are spotted, and the mixfile converted to MULTICHANNEL (new) format
#
#	RETIME runs AFTER all this has happened, so the input mixfile may be old OR new style.
#	RETIME may also reduce multichan files to mono
#	In this case we look for the mixfile being in multichan format (look for ":")
#		and if the channel cnt <= 2, convert it back to old-style format.
#

proc DoMultichanCorrection {} {
	global segment
	set chans 0
	set multichanformat 0
	foreach line $segment(mixlines) {
		if {!$multichanformat && ([string first ":" $line] > 0)} {
			set multichanformat 1
		}
		if {[llength $line] > 1} {
			set chan [lindex $line 2]

			if {$chan > $chans} {
				set chans $chan
			}
		}
	}
	if {$chans <= 2} {
		if {$multichanformat} {
			foreach line [lrange $segment(mixlines) 1 end] {	;#	Multichan format file, with chancnt <= 2
				set nuline [lrange $line 0 2]
				lappend nuline [lindex $line 4]
				lappend nulines $nuline
			}
			set segment(mixlines) $nulines
		}
		return
	}
	if {!$multichanformat} {									;#	Non-multichan format file, with chancnt > 2
		set nuline $chans
		lappend nulines $nuline
		set len [llength $segment(mixlines)]
		set n 0
		while {$n < $len} {
			set line [lindex $segment(mixlines) $n]
			set chan [lindex $line 2]
			set gain [lindex $line 3]
			set nuline [lrange $line 0 2]
			set kk 1
			while {$kk <= $chan} {
				lappend nuline "$kk:$kk" $gain
				incr kk
			}
			lappend nulines $nuline
			incr n
		}
		set segment(mixlines) $nulines
	}
}

#--- Start a several-process combo

proc StartCombinedProcesses {} {
	global segment pr_gettrofs
	set segment(testting) 0
	DeleteGettrofTestMixes
	ClearNoexpands									;#	Clear all noexpand flags
	set segment(didaddfil) $segment(addsfile)		;#	Note which processes ALWAYS add files to the mixfile list
	set pr_gettrofs MANY_PROCESSES					;#	Go to MAny processes option
}

#---- If a process that MAY add a file to mixfile, DOES add a file to mixlist, add that info to "didaddfil" flags

proc UpdateFilesAddedInfo {} {
	global segment
	set k [lsearch $segment(processes) $segment(process)]				;#	Find process number
	set segment(didaddfil) [lreplace $segment(didaddfil) $k $k 1]		;#	Add inserted files to list of added files
}

#---- When saving a file, or exporting segments, button will display name of source file in file entry box

proc DisplayGettrofSrcfileName {} {
	global segment
	set segment(xfnam) [file rootname [file tail $segment(infnam)]]
	ForceVal .gettrofs.4.segfil $segment(xfnam)
}

#----- Generate segmentation marks for the output file
#
#	Sort out the lines we want to use as segmentation marks for the OUTPUT file
#
#	TEXTURE generates a new file AFTER the original head     : Keep time of original head only (Before processed file)
#	BOUNCE MAY generates a new file BEFORE the original head : Keep time of processed head only (Before original file)
#	So in both cases, discard the time of the 2nd file.
#

proc SaveNewMarks {asphrase oldmarks} {
	global segment pr_gtnewmarks evv wstk

	set OK 1
	if {[MultipleProcessing]} {
		if {$segment(multiproccnt) > 1} {
			Inf "CANNOT SAVE NEW MARKS IF MORE THAN ONE PROCESS USED"
			return
		}
		foreach dud $segment(multido) {
			set procc [lindex $dud 0]
			if {[NonImplementedProcess $procc]} { 
				set OK 0
				break
			}
		}
	} elseif {[NonImplementedProcess $segment(process)]} {
		set procc $segment(process)
		set OK 0
	}
	if {!$OK} {
		Inf "\"SaveNewMarks\" MAY NOT WORK CORRECTLY for $procc : MODIFY THE CODE AND ALTER THIS MESSAGE !!"
		return
	}

	if {$oldmarks} {
		set marks $segment(marklist)
	} else {
		if {$segment(process) == "REVERSAL"} {
			set marks [lrange $segment(numarks) 1 end]
		} elseif {($segment(process) == "SQZBOX") || ($segment(process) == "TSTRETCH") || (![MultipleProcessing] && ($segment(process) == "TEXTURE"))} {
			set marks $segment(numarks)
		} else {
			if {![info exists segment(mixlines)]} {
				Inf "CANNOT FIND THE EXISTING MIX DATA"
				return
			}
			if {[GettrofProcessMayInsertExtraFile]} {
				set len [llength $segment(mixlines)]							;#	Sort out the lines we want to mark
				set k 0
				if {[GettrofIsMultiChanMix $segment(mixlines)]} {
					set k 1
				}
				set lastline [lindex $segment(mixlines) $k]						;#	TEXTURE generates a new file AFTER the original head
				set fnam [lindex $lastline 0]									;#	Keep time of original head only (Before processed file)
				set finfo  [GettrofFindMixFileInfo $fnam]						;#	BOUNCE MAY generates a new file BEFORE the original head
				set HTtyp1 [lindex $finfo 0]									;#	Keep time of processed head only (Before original file)
				set findx1 [lindex $finfo 1]									;#	So in both cases, discard the time of the 2nd file
				set done 0
				set n [expr $k + 1]
				while {$n < $len} {
					set thisline [lindex $segment(mixlines) $n]
					set fnam [lindex $thisline 0]
					set finfo [GettrofFindMixFileInfo $fnam]
					set HTtyp2 [lindex $finfo 0]
					set findx2 [lindex $finfo 1]								;#	Both HEADS or BOTH TAILS from same source
					if {[string match $HTtyp1 $HTtyp2] && ($findx1 == $findx2)} {
						if {$segment(process) == "BOUNCE"} {
							lappend lines $lastline								;#	Keep the first	
							incr n
						} else {  ;# TEXTURE
							lappend lines $lastline								;#	Keep both but skip the next	
							lappend lines $thisline
							incr n 2
						}
						if {$n >= $len} {										;#	"lastline" must be the very last line.
							set done 1											;#	BUT "lastline" is the line we're discarding
							break												;#	so set a flag to ensure we don't keep it
						}
						set thisline [lindex $segment(mixlines) $n]				;#	Skip the discarded line
						set fnam [lindex $thisline 0]
						set finfo  [GettrofFindMixFileInfo $fnam]
						set HTtyp2 [lindex $finfo 0]
						set findx2 [lindex $finfo 1]
					} else {
						lappend lines $lastline									;#	Lines not from same source; keep lastline
					}
					set lastline $thisline
					set HTtyp1 $HTtyp2
					set findx1 $findx2
					incr n
				}
				if {!$done} {
					lappend lines $lastline
				}
			} else {
				set lines $segment(mixlines)
			}
			set marks 0.0													;#	First file begins at 0
			set ishead 1		
			if {$segment(headfirst)} {										;#	IF first file is HEAD, then next file is NOT head: ishead starts at 0
				set ishead 0
			}
			set m 1
			foreach line [lrange $lines 1 end] {							;#	Get mix entries of other files
				set mark [lindex $line 1]									;#	If they are tails, these are the segmentation-mark times
				if {$ishead} {												;#	Head Files (after 1st) begin (with upslice) BEFORE the mark	
					set mark [expr $mark + $segment(SPLICE)]				;#	so mark must be set SPLICE later
				}															
				lappend marks $mark
				set ishead [expr !$ishead]
				incr m
			}
		}
		if {![DoSegmentDurParse $segment(ofnamw)]} {
			Inf "FAILED TO FIND DURATION OF OUTPUT FILE"
			return
		}
		set mark [expr $segment(itemdur) + 10.0]
		lappend marks $mark
	}
	set f .gtnewmarks
	if [Dlg_Create $f "SAVE NEW SEGMENTATION DATA" "set pr_gtnewmarks 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Save Data"  -command "set pr_gtnewmarks 1" -width 11 -bg $evv(EMPH)
		button $f.0.n -text "Sound Name" -command "set pr_gtnewmarks 2" -width 11
		button $f.0.q -text "Abandon"	 -command "set pr_gtnewmarks 0" -width 11
		pack $f.0.s $f.0.n -side left -padx 12
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Segmentation Filename"
		entry $f.1.e  -textvariable segment(numarksfnam) -width 48
		pack $f.1.e $f.1.ll -side left -padx 2
		pack $f.1 -side top
		bind $f <Return> {set pr_gtnewmarks 1}
		bind $f <Escape> {set pr_gtnewmarks 0}
	}
	set segment(numarksfnam) [file rootname [file tail $segment(ofnamw)]]
	set pr_gtnewmarks 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_gtnewmarks
	while {!$finished} {
		tkwait variable pr_gtnewmarks
		switch -- $pr_gtnewmarks {
			1 {
				if {[string length $segment(numarksfnam)] <= 0} {
					Inf "NO SEGMENTATION-DATA FILENAME NAME ENTERED"
					continue
				}
				if {![ValidCDPRootname $segment(numarksfnam)]} {
					Inf " "INVALID SEGMENTATION-DATA FILENAME"
					continue
				}
				set outfnam [string tolower $segment(numarksfnam)]
				if {$asphrase} {
					append outfnam "_phrs"
				} else {
					append outfnam "_" $segment(headfirst) "_rsegs"
				}
				set outfnam [file join $segment(dirname) $outfnam$evv(TEXT_EXT)]
				if {[file exists $outfnam]} {
					set msg "FILE $segment(numarksfnam) ALREADY EXISTS: OVERWRITE IT ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					} 
				}
				if [catch {file delete $outfnam} zit] {
					Inf "CANNOT DELETE EXISTING FILE $segment(numarksfnam) : $zit"
					continue
				}
				if [catch {open $outfnam "w"} zit] {
					Inf "CANNOT OPEN FILE $segment(numarksfnam) TO SAVE NEW SEGMENTATION-DATA"
				} else {
					foreach mark $marks {
						puts $zit $mark
					}
					close $zit
				}
				if {($segment(process) == "TSTRETCH") || ($segment(process) == "TEXTURE")} {	;#	Attempt to copy assocd text-recorded file
					KeepAnyExistingSegmentNamesAfterTstretch	
				}
				Inf "NEW SEGMENTATION-DATA SAVED"
				set finished 1
			}
			2 {
				set segment(numarksfnam) [file rootname [file tail $segment(ofnamw)]]
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Find type (Head/Tail) and Number in name of file listed in segment(mixfiles)

proc GettrofFindMixFileInfo {fnam} {
	set findex [file rootname [file tail $fnam]]				;#	fnamePH12
	if {[string first "H" $findex] > 0} {
		set typ H												;#	Distinguish HEADs fron TAILs
	 } else {
		set typ T
	}
	set findex [ReverseString $findex]							;#	21HPemanf
	set len [string length $findex]
	set k 0
	while {$k < $len} {													
		if {![regexp {^[0-9]+$} [string index $findex $k]]} {	;#	21F
			break												;#k=012
		}
		incr k
	}
	incr k -1													;#	k = 1
	set findex [string range $findex 0 $k]						;#	21
	set findex [ReverseString $findex]							;#	12

	set finfo [list $typ $findex]
	return $finfo
}

##########
# ACCENT #
##########

proc Gettrof_Accent {} {
	global segment evv wstk prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId overload_line
 
	set quieten	  $segment(PAR0)

	set msg_typ	"HEAD SEGMENT "
	set msg_typ2 "TAIL SEGMENT "

	set msg "ACCENTING "
	append msg $msg_typ S 
	Block "$msg"

	;#	FIND AMPLITUDE OF ALL SEGMENTS

	set maxsamps [FindSegmentAmplitudes]
	if {[llength $maxsamps] <= 0} {
		UnBlock
		return 0
	}

	;#	PARAMS FOR READING CONTROL FILES

	set n 1
	while {$n <= $segment(vparams_cnt,$segment(process))} {
		if {[info exists segment(control$n,ACCENT)]} {
			set segment(zlim,$n) [expr [llength $segment(control$n,ACCENT)] - 1]
			set segment(zccnt,$n) 0
		}
		incr n
	}

	;#	PROCESSING PARAMS FOR WHILE-LOOP

	set n 1		;#	Index for first head segment to stack is 1 (segments count from 1)
	set j 0		;#	Indices for start and end times of segment, in marklist
	set k 1
	set hno 1	;#	Index of 1st HEAD file (headfile names are indexed from 1)
	set tno 1	;#	Index of 1st TAIL file (tailfile names are indexed from 1)

				;#	Extended final val in marklist, replaced by true end of file


	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	if {$quieten > 0.0} {
		GettrofAccentDovetails $marks
	}

	if {![MultipleProcessing]} {
		ClearNoexpands											;#	Clear all flags relating to mixfile lines being immovable
	}
	if {[MultipleProcessing]} {
		set segment(origmixlines) $segment(mixlines)			;#	Store existing mixlines, in case we need to baktrak
	}

	

	set OK 1
	catch {unset segment(recycline)}
	if {!$segment(headfirst)} {
		set lasttaillev [lindex $maxsamps 0]
		if {[MultipleProcessing]} {
			if {![GetRecycledSegment 1 TAIL]} {
				set OK 0
				break
			}
			set lasttfnam $segment(iifnam)
		} else {
			set lasttfnam $evv(MACH_OUTFNAME)TD1$evv(SNDFILE_EXT)
		}
		set lasttofnam $evv(MACH_OUTFNAME)TF1$evv(SNDFILE_EXT)
		incr n
		incr j
		incr k
		incr tno
	}

	while {$n <= $segment(cnt)} {

		wm title .blocker "PLEASE WAIT:        ACCENTING $msg_typ $n"

		set leftbase [lindex $marks $j]						;#	Head start
		if {$segment(multiproccnt)} {
			if {[lindex $segment(actionlist) $n] == 0} {
				incr n 2								;#	IF no action required								
				incr j 2								;#	Skip to next segment pair
				incr k 2
				incr hno
				incr tno
				continue
			}
		}

		;#	GET APPROPRIATE HEAD INPUT AND FILES (NAMES)

		if {[MultipleProcessing]} {
			if {![GetRecycledSegment $hno HEAD]} {
				set OK 0
				break
			}
			set hfnam $segment(iifnam)
			set headpos $segment(recycline)
		} else {
			set hfnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
			set headpos [lindex $marks $j]
			if {$n > 1} {
				set headpos [expr $headpos - $segment(SPLICE)]
			}
		}
		set hofnam $evv(MACH_OUTFNAME)HF$hno$evv(SNDFILE_EXT)

		;#	GET APPROPRIATE TAIL FILE (NAME)

		if {$n < $segment(cnt)} {
			if {$segment(phrase)} {
				set dotail 0
			} else {
				if {[MultipleProcessing]} {
					if {![GetRecycledSegment $tno TAIL]} {
						set OK 0
						break
					}
					set tfnam $segment(iifnam)
					set tailpos $segment(recycline)
				} else {
					set tfnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
					set tailpos [lindex $marks $k]
				}
				set tofnam $evv(MACH_OUTFNAME)TF$tno$evv(SNDFILE_EXT)
				set dotail 1
			}
		} else {
			set dotail 0
		}
		#	POSSIBLY-VARIABLE-PARAMETER CONVERSION

		set accentdB  [GetParamValueFromControl $leftbase 1]
		set accratio  [expr 1.0/[dBtoGain $accentdB]]
		set taildown  [GetParamValueFromControl $leftbase 2]

		;# DO ACCENTUATION

		set headlev [lindex $maxsamps $j]
		set taillev [lindex $maxsamps $k]


		;#	IF NOT ACCENTED, AND THE NON-ACCENTED SEGMENTS ARE TO BE QUIETEND, DO QUIETENING

		if {$quieten > 0.0 && ($accentdB <= 0.0)} {

			set hfnam [CheckAccentFileLogic $hfnam $hofnam]
			if {[string length $hfnam] <= 0} {
				set OK 0
				break
			}
			set gain [GetParamValueFromControl $leftbase 0]			;#	Time-varying vals of "quieten" stored in unused array "segment(control0,ACCENT)"

			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $hfnam $hofnam $gain

			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        QUIETENING $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN QUIETENING OF $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO QUIETEN $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $hofnam]} {
				Inf "NO QUIETENED $msg_typ $n CREATED"
				set OK 0
				break
			}

			if {$dotail} {

				set tfnam [CheckAccentFileLogic $tfnam $tofnam]
				if {[string length $tfnam] <= 0} {
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $tfnam $tofnam $gain

				set prg_dun 0
				set prg_abortd 0
				set nn $n
				incr nn
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        QUIETENING $msg_typ2 $nn"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN QUIETENING OF $msg_typ2 $nn"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO QUIETEN $msg_typ2 $nn"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $tofnam]} {
					Inf "NO QUIETENed $msg_typ2 $nn CREATED"
					set OK 0
					break
				}
			}

		} else {

			;#	ELSE ACCENT THE HEAD AND DE-ACCENT THE TAIL APPROPRIATELY

			if {$headlev < $segment(normlev)} {

				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 3 $hfnam $hofnam -l$segment(normlev)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        ACCENTING $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN ACCENTING OF $msg_typ $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO ACCENT $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $hofnam]} {
					Inf "NO ACCENTED $msg_typ $n CREATED"
					set OK 0
					break
				}

				set headlev $segment(normlev)

			} else {

				if [catch {file copy $hfnam $hofnam} zit] {
					Inf "CANNOT COPY (NON-NORMALISED) INPUT msg_typ $n : $zit"	
					set OK 0
					break
				}
			}

			if {$dotail} {
				set nutaillev [expr $headlev * $accratio]

				if {$taillev > $nutaillev} {

					set gain [expr $nutaillev/$taillev]
					set nn $n
					incr nn

					if {$taildown > 0.0} {
						if {![DoSegmentDurParse $tfnam]} {
							Inf "FAILED TO FIND DURATION OF $msg_typ2 $nn"
							set OK 0
							break
						}
						set segdur $segment(itemdur)
						set segmid [expr $segdur * $taildown]

						if {![GettrofTailDecayFile $segdur $segmid $gain]} {
							set OK 0
							break
						}
						set gain $segment(envfil)
					}

					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $tfnam $tofnam $gain
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        DE-ACCENTING $msg_typ2 $nn"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN DE-ACCENTING OF $msg_typ2 $nn"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO DE-ACCENT $msg_typ2 $nn"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $tofnam]} {
						Inf "NO DE-ACCENTED $msg_typ2 $nn CREATED"
						set OK 0
						break
					}

				} else {
					if [catch {file copy $tfnam $tofnam} zit] {
						Inf "CANNOT COPY (NON-NORMALISED) INPUT msg_typ2 $nn : $zit"	
						set OK 0
						break
					}
				}
			}

			;#	IF NESS, ADJUST LEVEL OF FIRST (TAIL) SEGMENT AND PLACE AS FIRST LINE OF MIX

			if {($n==2) && !$segment(headfirst)} {
				if {$lasttaillev > $nutaillev} {
					set gain [expr $nutaillev/$lasttaillev]

					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend loudness 1 $lasttfnam $lasttofnam $gain
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        DE-ACCENTING $msg_typ2 1"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN DE-ACCENTING OF $msg_typ2 1"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO DE-ACCENT $msg_typ2 1"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $lasttofnam]} {
						Inf "NO DE-ACCENTED $msg_typ2 1 CREATED"
						set OK 0
						break
					}

				} else {
					if [catch {file copy $lasttfnam $lasttofnam} zit] {
						Inf "CANNOT COPY (NON-NORMALISED) INPUT msg_typ2 1 : $zit"	
						set OK 0
						break
					}
				}
				if {[MultipleProcessing]} {
					set line [lindex $segment(mixlines) 0]
					set line [lreplace $line 0 0 $lasttofnam]
					set segment(mixlines) [lreplace $segment(mixlines) 0 0 $line]
				} else {
					set line [list $lasttofnam 0.0 1 1.0]
					lappend mixlines $line
				}
			}
		}

		;#	PLACE NEW HEAD AND TAIL INTO MIXFILE

		if {[MultipleProcessing]} {
			set line [lindex $segment(mixlines) $headpos]
			set line [lreplace $line 0 0 $hofnam]
			set segment(mixlines) [lreplace $segment(mixlines) $headpos $headpos $line]
			if {$dotail} {
				set line [lindex $segment(mixlines) $tailpos]
				set line [lreplace $line 0 0 $tofnam]
				set segment(mixlines) [lreplace $segment(mixlines) $tailpos $tailpos $line]
			}
		} else {
			set line [list $hofnam $headpos 1 1.0]
			lappend mixlines $line
			if {$dotail} {
				set line [list $tofnam $tailpos 1 1.0]
				lappend mixlines $line
			}
		}
		incr n 2
		incr j 2
		incr k 2
		incr hno
		incr tno
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	}

	if {$segment(multiproccnt)} {				;#	With multiprocess, don't mix until all processes done
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)
	} else {
		set segment(mixlines) $mixlines
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	;#	LEVEL ADJUSTING MIX

	if {![GettrofPossiblyMultichanMixdown 1]} {
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		set OK 0
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	return 1
}

#--- Assuming output file must be PH, or PT : return the name of a valid input file & delete any pre-existing output file:  

proc CheckAccentFileLogic {ifnam ofnam} {

	if {[string match $ifnam $ofnam]} {					;#	If we're trying to do process HF -> HF or TF -> TF
		if {[file exists $segment(othersnd)]} {			;#	Rename the input sound
			if [catch {file delete $segment(othersnd)} zit] {
				Inf "CANNOT DELETE INTERMEDIATE SOUNDFILE $segment(othersnd)"
				return {}
			}
		}
		if [catch {file rename $ifnam $segment(othersnd)} zit] {
			Inf "CANNOT RENAME INTERMEDIATE SOUNDFILE $ifnam"
			return {}
		}
		set ifnam $segment(othersnd)
		return $ifnam
	} else {											;#	Else, if the output sound (HF or TF) already exists,
		if {[file exists $ofnam]} {						;#	as we're going to replace it in the mix, delete it
			if [catch {file delete $ofnam} zit] {
				Inf "CANNOT DELETE INTERMEDIATE SOUNDFILE $ofnam"
				return {}
			}
		}
	}
	return $ifnam
}

#---- Create a curve to define UNaccented segment levels, so they crescendo and diminuendo around the site of accents
#
#	Function uses the unsassigned control-list "segment(control0,ACCENT) to store the curve
#	as there are no "control0" params 
#

proc GettrofAccentDovetails {marks} {
	global segment												;#		___ 1 __
	set quieten	 $segment(PAR0)									;#				|
	set quieten	 [expr 1.0/[dBtoGain $quieten]]					;#				| range
	set quietenrange [expr 1.0 - $quieten]						;#	quieten	x __|
																;#		___ 0 __
	set n 1
	set j 0
	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]
		set accentdB  [GetParamValueFromControl $leftbase 1]	;#					 6     6
		if {$accentdB <= 0.0} {									;# accents		 3       3   3
			set line [list $leftbase 0]							;#			0  0   0   0       0
			lappend lines $line									;#
			if {$n == 1} {
				set accentstart 0
			}
		} else {												;# output		 1	 1	 1 1 1 
			set line [list $leftbase 1]							;#			0  0   0   0       0
			lappend lines $line									;#
			if {$n == 1} {
				set accentstart 1
			}
		}
		incr n
		incr j
	}
	set len [llength $lines]
	set done 0
	set n 1
	set offcurve {}
	if {$accentstart} {
		set line [list 0.0 1.0]
		lappend offcurve $line
		set last_acctime 0.0
	} else {
		while {$n < $len} {
			set line [lindex $lines $n]
			set accent [lindex $line 1]
			if {$accent} {
				set last_acctime  [lindex $line 0]
				set dur $last_acctime

				;#	MAKE UPSLOPE

				set line [list 0.0 $quieten]					;#				  0.3  1.0		to pow		*diff		+quieten
				lappend offcurve $line							;# _____ 1		 _______		______		______		______
																;#  |			       x			x						x
				set val [expr pow(0.333,$segment(accentslope))]	;#	|			       x 		    x		   x		   xx
				set val [expr $val * $quietenrange]				;#	|			     x  		   x	  	  xx		   x	
				set val [expr $val + $quieten]					;# quietenrange		 x             x		  x			  x 
				set line [list [expr $dur * 0.3333] $val]		;#	|			   x			  x			 x			  x
				lappend offcurve $line							;#	|			   x			  x		   	 x			x
				set val [expr pow(0.666,$segment(accentslope))]	;# _|__quieten	 x			   x		   x			x_____
				set val [expr $val * $quietenrange]				;# _____ 0		_x________	   x______	   x______		______
				set val [expr $val + $quieten]
				set line [list [expr $dur * 0.6666] $val]
				lappend offcurve $line
				set line [list $last_acctime 1.0]
				lappend offcurve $line
				break
			}
			incr n
		}
		if {$n >= $len} {
			set done 1											;#	If no accents found, returns offcurve {}
		}
	}
	if {!$done} {
		set found_gap_between_accents 0
		while {$n < $len} {
			set line [lindex $lines $n]
			set accent [lindex $line 1]
			if {$accent} {
				if {$found_gap_between_accents} {
					set next_acctime [lindex $line 0]
					set dur [expr ($next_acctime - $last_acctime)/2.0]	;#	"dur" = HALF of duration between accents
					set midtime [expr $dur + $last_acctime]

					;#	MAKE DOWN-UP CURVE

					set line [list $last_acctime 1.0]				;#				   .3    1		to pow		*diff		+quieten
					lappend offcurve $line							;# _____ 1		 0___.6___		______		______		______
																	;#  |			 x				x			______		x
					set val [expr pow(0.666,$segment(accentslope))]	;#	|			 x 				x		   x		    x
					set val [expr $val * $quietenrange]				;#	|			   x  		     x	  	   x		     x	
					set val [expr $val + $quieten]					;# quietenrange	   x             x		    x			 x 
					set time [expr ($dur * 0.3333) + $last_acctime]	;#	|			     x			  x			x			   x
					set line [list $time $val]						;#	|			     x			  x		   	  x			   x  x
					lappend offcurve $line							;# _|__quieten			x			 x		  x  x		______x
					set val [expr pow(0.333,$segment(accentslope))]	;# _____ 0		 _______x_	    _____x	    _____x		______
					set val [expr $val * $quietenrange]				
					set val [expr $val + $quieten]
					set time [expr ($dur * 0.6666) + $last_acctime]
					set line [list $time $val]
					lappend offcurve $line
					set line [list $midtime $quieten]
					lappend offcurve $line

					set val [expr pow(0.333,$segment(accentslope))]
					set val [expr $val * $quietenrange]
					set val [expr $val + $quieten]
					set time [expr ($dur * 0.3333) + $midtime]
					set line [list $time $val]
					lappend offcurve $line
					set val [expr pow(0.666,$segment(accentslope))]
					set val [expr $val * $quietenrange]
					set val [expr $val + $quieten]
					set time [expr ($dur * 0.6666) + $midtime]
					set line [list $time $val]
					lappend offcurve $line
					set line [list $next_acctime 1.0]
					lappend offcurve $line
					set found_gap_between_accents 0
				
				} else {											;#	i.e. adjacent accents
					set last_acctime [lindex $line 0]
				}
				incr n
			} else {
				set found_gap_between_accents 1
				set next_acctime [lindex $line 0]
				incr n
				if {$n >= $len} {									;#	If reached sound end

					;#	MAKE DOWNSLOPE
					
					set line [list $last_acctime 1.0]
					set dur  [expr $next_acctime - $last_acctime]	;#				   .3    1		to pow		*diff		+quieten
					lappend offcurve $line							;# _____ 1		 0___.6___		______		______		______
																	;#  |			 x				x			______		x
					set val [expr pow(0.666,$segment(accentslope))]	;#	|			 x 				x		   x		    x
					set val [expr $val * $quietenrange]				;#	|			   x  		     x	  	   x		     x	
					set val [expr $val + $quieten]					;# quietenrange	   x             x		    x			 x 
					set time [expr ($dur * 0.3333) + $last_acctime]	;#	|			     x			  x			x			   x
					set line [list $time $val]						;#	|			     x			  x		   	  x			   x  x
					lappend offcurve $line							;# _|__quieten			x			 x		  x  x		______x
					set val [expr pow(0.333,$segment(accentslope))]	;# _____ 0		 _______x_	    _____x	    _____x		______
					set val [expr $val * $quietenrange]				
					set val [expr $val + $quieten]
					set time [expr ($dur * 0.6666) + $last_acctime]
					set line [list $time $val]
					lappend offcurve $line
					set line [list $next_acctime $quieten]
					lappend offcurve $line
				}
			}
		}
	}

	set len [llength $offcurve]
	if {$len == 0} {
		set segment(control0,ACCENT) $offcurve
		set segment(zlim,0) -1
		set segment(zccnt,0) 0
		return
	}

	;#	RATIONALISE DATA (SHOULDN'T BE NECCESSARY - BUT JUST IN CASE !!)

	set lasttime 0.0
	set n 1
	while {$n < $len} {
		set thistime [lindex [lindex $offcurve $n] 0]
		if {[Flteq $thistime $lasttime]} {
			set offcurve [lreplace $offcurve $n $n]
			incr len -1
		} else {
			incr n
		}
		set lasttime $thistime
	}
	set segment(control0,ACCENT) $offcurve
	set segment(zlim,0) [expr $len - 1]		;#	Use the unused zlim,zccnt (at 0) to make this curve accessible by GetParamValueFromControl 
	set segment(zccnt,0) 0
}

#------- FIND Level of all segments: Assumes a BLOCK is in place

proc FindSegmentAmplitudes {} {
	global segment evv CDPmaxId maxsamp_line done_maxsamp
	catch {unset maxsamps}
	set n 1
	set hno 1
	set tno 1
	set ishead 0
	if {$segment(headfirst) || $segment(phrase)} {
		set ishead 1
	}
	while {$n <= $segment(cnt)} {
		if {$ishead} {
			if {[MultipleProcessing]} {
				if {![GetRecycledSegment $hno HEAD]} {
					return {}
				}
				set ifnam $segment(iifnam)
			} else {
				set ifnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
			}
		} else {
			if {[MultipleProcessing]} {
				if {![GetRecycledSegment $tno TAIL]} {
					return {}
				}
				set ifnam $segment(iifnam)
			} else {
				set ifnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
			}
		}
		if {$ishead} {
			incr hno
		} else {
			incr tno
		}
		if {!$segment(phrase)} {
			set ishead [expr !$ishead]
		}
		wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SEGMENT $n"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $ifnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' ON SEGMENT $n"
			return {}
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE LEVEL OF SEGMENT $n"
			return {}
		}
		set maxoutsamp [lindex $maxsamp_line 0]
		if {$maxoutsamp <= 0.0} {
			Inf "SEGMENT $n HAS ZERO LEVEL"
			return {}
		}
		lappend maxsamps $maxoutsamp 
		incr n
	}
	return $maxsamps
}

#---- Tail decay to a final level by "decayend"

proc GettrofTailDecayFile {duration decayend endgain} {
	global segment
	if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE ENVELOPE FILE $segment(envfil) : $zit"
		return 0
	}												;#				1.0  0.3   		raised	
	set line [list 0.0 1.0]							;#				  0.6  0.0		to pow		*diff		+endgain
	lappend env $line								;# _____ 1		 _______		______					______
	set diff [expr 1.0 - $endgain]					;#  |			 x				x			______		x
	set val [expr pow(0.6666,$segment(accentpow))]	;#	|			 x  		    x			x
	set val [expr $val * $diff]						;#	|			   x  			  	  
	set val [expr $val + $endgain]					;# diff			   x              x			 			 x    
	set line [list [expr $decayend * 0.3333] $val]	;#	|				 x			  x			 x
	lappend env $line								;#	|				 x				x					   x  
	set val [expr pow(0.3333,$segment(accentpow))]	;# _|___endgain		   x			x x		   x 		_____x
	set val [expr $val * $diff]						;# _____ 0		_______x		______x		_____x		______
	set val [expr $val + $endgain]					;#
	set line [list [expr $decayend * 0.6666] $val]
	lappend env $line
	set line [list $decayend $endgain]
	lappend env $line
	set line [list $duration $endgain]
	lappend env $line
	if [catch {open $segment(envfil) "w"} zit] {
		Inf "CANNOT OPEN ENVELOPE FILE TO CREATE FADE"
		return 0
	}
	foreach line $env {
		puts $zit $line
	}
	close $zit
	return 1
}

#####################
#	TEST ROUTINES	#
#####################

#--- For testing purposes: play (1) Only segments that are to be processed OR (2) Only segments that have been processed

proc GettrofPlayProcessedOnly {pre} {
	global segment prg_dun prg_abortd simple_program_messages CDPidrun evv
	set gotfiletoplay 0
	if {$pre} {
		set ofnam $segment(premix)					;#	REDUNDANT ??
		if {[file exists $segment(premix)]} {
			set gotfiletoplay 1
		}
		set msg2 PREMODIFIED
	} else {
		set ofnam $segment(exclmix)					;#	REDUNDANT ??
		if {[file exists $segment(exclmix)]} {
			set gotfiletoplay 1
		}
		set msg2 MODIFIED
	}
	if {!$gotfiletoplay} {
		Block "PLEASE WAIT:        PREPARING MIX OF $msg2 SEGMENTS"

		set lastfindex 0
		if {![info exists segment(mixlines)]} {
			Inf "NO OUTPUT FROM PROCESS, YET"
			UnBlock
			return 0
		}
		set lines $segment(mixlines)
		foreach line $lines {
			set fnam [lindex $line 0]
			if {[GettrofFindIfFileProcessed $fnam]} {
				lappend nulines $line
			}
		}
		if {![info exists nulines]} {
			Inf "NO SEGMENTS HAVE BEEN PROCESSED"
			UnBlock
			return 0
		}
		set lines $nulines
		if {$pre} {
			set len [llength $lines]
			set n 0
			while {$n < $len} {
				set line [lindex $lines $n]
				set fnam [lindex $line 0]
				set finfo [GettrofFindMixFileInfo $fnam]
				set typ	   [lindex $finfo 0]
				set findex [lindex $finfo 1]
				if {$typ == "H"} {
					set nufnam $evv(DFLT_OUTNAME)HH$findex$evv(SNDFILE_EXT)
				} else {
					set nufnam $evv(MACH_OUTFNAME)TD$findex$evv(SNDFILE_EXT)
					if {![file exists $nufnam]} {
						set ifnam  $evv(MACH_OUTFNAME)TT$findex$evv(SNDFILE_EXT)
						set cmd [file join $evv(CDPROGRAM_DIR) envel]
						lappend cmd dovetail 1 $ifnam $nufnam $segment(SPLICE) $segment(SPLICE) 0 0 -t0
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        DOVETAILING TAIL SEGMENT $findex"
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "FAILED TO RUN PROCESS TO DOVETAIL TAIL SEGMENT $findex"
							catch {unset CDPidrun}
							UnBlock
							return 0
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO RUN DOVETAILING PROCESS FOR TAIL $findex"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							UnBlock
							return 0
						}
						if {![file exists $nufnam]} {
							Inf "FAILED TO CREATE DOVETAILED TAIL SEGMENT $findex"
							UnBlock
							return 0
						}
					}
				}
				set line  [lreplace $line  0 0 $nufnam]
				set lines [lreplace $lines $n $n $line]
				incr n
			}
		}
		if {[file exists $segment(mixdata)]} {
			if [catch {file delete $segment(mixdata)} zit] {
				Inf "CANNOT DELETE INTERMEDIATE TEMPORARY FILE $segment(mixdata)"
				UnBlock
				return 0
			}
		}
		if [catch {open $segment(mixdata) "w"} zit] {
			Inf "CANNOT OPEN TEMPORARY FILE TO CREATE MIX"
			UnBlock
			return 0
		}
		foreach line $lines {
			puts $zit $line
		}
		close $zit
		set cmd [file join $evv(CDPROGRAM_DIR) submix]
		lappend cmd mix $segment(mixdata) $ofnam
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN $msg2 SEGMENTS MIX"
			catch {unset CDPidrun}
			UnBlock
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE $msg2 SEGMENTS MIX"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			UnBlock
			return 0
		}
		if {![file exists $ofnam]} {
			Inf "NO $msg2 SEGMENTS MIX CREATED"
			UnBlock
			return 0
		}
		UnBlock
	}
	PlaySndfile $ofnam 0
	return 1
}

proc GettrofFindIfFileProcessed {fnam} {
	set findex [file rootname [file tail $fnam]]
	if {[string first "P" $findex] > 0} {
		set processed 1
		set findex [ReverseString $findex]						;#	21FHPemanf
		set len [string length $findex]
		set k 0
		while {$k < $len} {													
			if {![regexp {^[0-9]+$} [string index $findex $k]]} {;#	21F
				break											;#k=012
			}
			incr k
		}
		incr k -1												;#	k = 1
		set findex [string range $findex 0 $k]					;#	21
		return $findex
	}
	return 0
}

#---- Remove any testmixes created for last (set of) process(es)

proc DeleteGettrofTestMixes {} {
	global segment
	catch [file delete $segment(premix)]	
	catch [file delete $segment(exclmix)]
}

#---- Switch testing play-routines on and off

proc GettrofTesting {} {
	global segment
	if {$segment(testing)} {
		.gettrofs.14.pp.ou config -text "Output A Chosen\nSegment" -command "OutputChosenSeg"  -state normal -bd 2
		.gettrofs.14.pp.pp config -text "Play Chosen Segs\nPreprocessed" -command "GettrofPlayProcessedOnly 1"  -state normal -bd 2
		.gettrofs.14.pp.po config -text "Play Processed\nSegments"		 -command "GettrofPlayProcessedOnly 0"	-state normal -bd 2
	} else {
		.gettrofs.14.pp.ou config -text "" -state disabled -command {} -bd 0 -disabledforeground []
		.gettrofs.14.pp.pp config -text "" -state disabled -command {} -bd 0 -disabledforeground []
		.gettrofs.14.pp.po config -text "" -state disabled -command {} -bd 0 -disabledforeground []
	}
}

#######################
# TUNING AND PITCHING #
#######################

#--- GetData from a Text entry window

proc GettrofDataByTextEntry {typ} {
	global segment from_gettrof
	set from_gettrof 1
	set isbrktype 0
	Dlg_MakeTextfile 0 0
	if {![info exists segment(textdata)]} {
		return 3
	}
	switch -- $typ {
		intervals {										;#	SEMITONE INTERVALS FOR TRANSPOSITION
			set OK 1
			foreach item $segment(textdata) {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {![IsNumeric $item]} {
					Inf "NON-NUMERIC DATA ($item) ENTERED"
					return 3
				}
				if {($item > 48) || ($item < -48)} {
					Inf "TRANSPOSITION DATA ($item) OUT OF RANGE (-48 to 48)"
					return 3
				}
				lappend ints $item
			}
			if {![info exists ints]} {
				Inf "NO DATA ENTERED"
				return 3
			}
			set len [llength $ints]
			set len_less_one [expr $len - 1]
			set n 0
			while  {$n < $len_less_one} {
				set int_n [lindex $ints $n]
				set m $n
				incr m
				while {$m < $len} {
					set int_m [lindex $ints $m]
					if {$int_m == $int_n} {
						set ints [lreplace $ints $m $m]
						incr len -1
						incr len_less_one -1
						set OK 0
					} else {
						incr m
					}
				}
				incr n
			}
			if {!$OK} {
				Inf "DUPLICATED INTERVALS IN LIST HAVE BEEN ELIMINATED"
			}
			set segment(transpositions) $ints
		}
		pitches {										;#	PITCHES TO TRANSPOSE TO
			catch {unset segment(pitches)}
			set OK 1
			foreach item $segment(textdata) {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {![IsNumeric $item]} {
					Inf "NON-NUMERIC DATA ($item) ENTERED"
					return 3
				}
				if {($item > 127) || ($item < 0)} {
					Inf "PITCH DATA ($item) OUT OF RANGE (0 to 127)"
					return 3
				}
				lappend pitches $item
			}
			if {![info exists pitches]} {
				Inf "NO DATA ENTERED"
				return 3
			}
			set len [llength $pitches]
			if {$len != $segment(tuningcnt)} {
				Inf "WRONG NUMBER OF PITCHES : THERE ARE $segment(tuningcnt) SEGMENTS TO PITCH"
				return 3
			}
			set segment(pitches) $pitches
		}
		chords {										;#	PITCHES TO TRANSPOSE TO
			catch {unset segment(chords)}
			set OK 1
			catch {unset lines}
			foreach item $segment(textdata) {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend lines $item
			}
			if {![info exists lines]} {
				Inf "NO DATA ENTERED"
				return 3
			}
			set len [llength $lines]
			foreach line $lines { 
				catch {unset pitches}
				set line [split $line]
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					if {![IsNumeric $item]} {
						Inf "NON-NUMERIC DATA ($item) ENTERED"
						return 3
					}
					if {($item > 127) || ($item < 0)} {
						Inf "PITCH DATA ($item) OUT OF RANGE (0 to 127)"
						return 3
					}
					lappend pitches $item
				}
				lappend segment(chords) $pitches
				if {$len == 1} {
					 while {$len < $segment(tuningcnt)} {
						lappend segment(chords) $pitches
						incr len
					}
					break
				}
			}
			if {![info exists segment(chords)]} {
				Inf "NO DATA ENTERED"
				return 3
			}
			if {$segment(process) != "SPIKE"} {
				if {([llength $segment(chords)] != $segment(tuningcnt)) && ([llength $segment(chords)] != 1)} {
					Inf "WRONG NUMBER OF LINES ENTERED : NEED EITHER 1 OR $segment(tuningcnt) (WITH 1 OR MORE PITCH VALS ON EACH LINE)."
					return 3
				}
			}
		}
	}
	return 1
}

#--- Enter tuning data

proc TuningStyle {chords} {
	global segment pr_tunestyl tunestyl tunehead tuneweighted pitchartic tv_active evv
	set f .tunestyl
	NumberOfSegmentsToBeTuned $segment(process)
	if [Dlg_Create $f "SET TUNINGS FOR SEGMENTS" "set pr_tunestyl 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_tunestyl 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_tunestyl 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_tunestyl 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.0 -text "" -width 16
		if {$chords} {
			checkbutton $f.1.1  -text "Text Entry" -variable tunestyl -width 16 -command {set pr_tunestyl [GettrofDataByTextEntry chords]}
		} else {
			checkbutton $f.1.1  -text "Text Entry" -variable tunestyl -width 16 -command {set pr_tunestyl [GettrofDataByTextEntry pitches]}
		}
		frame $f.1.2
		if {$tv_active} {
			GettrofMakeKeyboardKey $f.1.2
		}
		label $f.1.3 -text "MIDI Kbd Entry" -width 16
		checkbutton $f.1.4  -text "Tune Head also" -variable tunehead -width 16
		checkbutton $f.1.5  -text "Weighted pitch" -variable tuneweighted -width 16
		checkbutton $f.1.6  -text "Articulation retained" -variable pitchartic -width 24
		set tunestyl 0
		set tunehead 0
		pack $f.1.0 $f.1.1 $f.1.2 $f.1.3 $f.1.4 $f.1.5 $f.1.6 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_tunestyl 1}
		bind $f <Escape> {set pr_tunestyl 0}
	}
	if {$tv_active} {
		bind .tunestyl.1.2.0   <ButtonPress-1> {}
		bind .tunestyl.1.2.1.0 <ButtonPress-1> {}
		bind .tunestyl.1.2.1.1 <ButtonPress-1> {}
		bind .tunestyl.1.2.1.2 <ButtonPress-1> {}
		bind .tunestyl.1.2.1.3 <ButtonPress-1> {}
		bind .tunestyl.1.2.1.4 <ButtonPress-1> {}
		bind .tunestyl.1.2.1.5 <ButtonPress-1> {}
		bind .tunestyl.1.2.1.6 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.0 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.1 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.2 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.3 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.4 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.5 <ButtonPress-1> {}
		bind .tunestyl.1.2.2.6 <ButtonPress-1> {}
		bind .tunestyl.1.2.3   <ButtonPress-1> {}

		bind .tunestyl.1.2.0   <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.0 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.1 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.2 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.3 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.4 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.5 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.1.6 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.0 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.1 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.2 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.3 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.4 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.5 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.2.6 <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
		bind .tunestyl.1.2.3   <ButtonPress-1> "GettrofGetNoteData $chords .tunestyl.1.2"
	}
	if {$segment(phrase)} {
		set tunehead 0 
		$f.1.4 config -text "" -state disabled -disabledforeground []
	} else {
		$f.1.4 config -text "Tune Head also" -state normal
	}
	if {$chords} {
		$f.1.0 config -text "1 OR $segment(tuningcnt) CHORDS"
		wm title . "SET TUNINGS FOR SEGMENTS"
		set tuneweighted 0
		set pitchartic 0
		$f.1.5 config -text "" -state disabled -disabledforeground []
		$f.1.6 config -text "" -state disabled -disabledforeground []
	} else {
		$f.1.0 config -text "$segment(tuningcnt) PITCHES"
		wm title . "SET PITCHES FOR SEGMENTS"
		set tuneweighted 1
		set pitchartic 1
		$f.1.5 config -text "Weighted pitch" -state normal
		$f.1.6 config -text "Articulation retained" -state normal
		set tuneweighted 1
	}
	catch {unset segment(chords)}
	catch {unset segment(pitches)}
	set pr_tunestyl 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_tunestyl
	while {!$finished} {
		tkwait variable pr_tunestyl
		switch -- $pr_tunestyl {
			1 {
				if {$chords} {
					if {![info exists segment(chords)] || ([llength $segment(chords)] <= 0)} {
						Inf "NO TUNINGS SET"
						continue
					}
					set segment(control1,TUNED) $segment(chords)	;#	Ensures data is remembered and can be stored in a patch
				} else {
					if {![info exists segment(pitches)] || ([llength $segment(pitches)] <= 0)} {
						Inf "NO PITCHES SET"
						continue
					}
					set segment(control1,PITCH) $segment(pitches)	;#	Ensures data is remembered and can be stored in a patch
				}
				if {$segment(phrase)} {
					set segment(par0) 0
					set segment(PAR0) 0					;#	This PARam ("also tune head") not applicable with phrases
				} else {
					set segment(par0) $tunehead
					set segment(PAR0) $segment(par0)	;#	This PARam must be set here, as not set later
				}
				if {!$chords} {
					set segment(par1) $tuneweighted
					set segment(PAR1) $segment(par1)	;#	This PARam must be set here, as not set later
					set segment(par2) $pitchartic
					set segment(PAR2) $segment(par2)	;#	This PARam must be set here, as not set later
				}
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			3 {
				set tunestyl 0
				continue							;#	If entry from text window fails		
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

#---- Creates small key like a keyboard which will activate TV, or bring up a dialog

proc GettrofMakeKeyboardKey {f} {
	frame $f.0 -height 1 -bg black
	frame $f.1 -height 12
	frame $f.2 -height 12
	frame $f.3 -height 1 -bg black
	frame $f.1.0 -width 1 -height 12 -bg black
	frame $f.1.1 -width 7 -height 12 -bg white
	frame $f.1.2 -width 8 -height 12 -bg black
	frame $f.1.3 -width 4 -height 12 -bg white
	frame $f.1.4 -width 8 -height 12 -bg black
	frame $f.1.5 -width 7 -height 12 -bg white
	frame $f.1.6 -width 1 -height 12 -bg black
	pack $f.1.0 $f.1.1 $f.1.2 $f.1.3 $f.1.4 $f.1.5 $f.1.6 -side left
	frame $f.2.0 -width 1  -height 8 -bg black
	frame $f.2.1 -width 11 -height 8 -bg white
	frame $f.2.2 -width 1  -height 8 -bg black
	frame $f.2.3 -width 10 -height 8 -bg white
	frame $f.2.4 -width 1  -height 8 -bg black
	frame $f.2.5 -width 11 -height 8 -bg white
	frame $f.2.6 -width 1  -height 8 -bg black
	pack $f.2.0 $f.2.1 $f.2.2 $f.2.3 $f.2.4 $f.2.5 $f.2.6 -side left
	pack $f.0 -side top -fill x -expand true
	pack $f.1 $f.2 -side top
	pack $f.3 -side top -fill x -expand true
}

#----- Establish window to enter 'notedata' for Tuning in Gettrof

proc GettrofGetNoteData {chords f} {
	global pr_notedata nd_entry nd_entryval tv_stop evv tunestyl segment
	set tunestyl 0
	switch -- $chords {
		0 {
			set ndmsg "Pitch line"
		}
		1 {
			set ndmsg "Chord(s)"
		}
		2 {
			set ndmsg "Timings"
		}
		3 {
			set ndmsg "Timed Pitches"
		}
	}
	set nd_entry 0
	set nd_entryval -1
	set f .notedata
	if [Dlg_Create $f "Generate Notedata" "set pr_notedata 0"] {
		button $f.0 -text "Abandon" -command "set pr_notedata 0"
		pack $f.0 -side top -pady 2
		switch -- $chords {
			0 -
			3 {
				label $f.00 -text "PRESS BUTTON BELOW, AND ENTER DATA FOR $segment(tuningcnt) NOTES"
			}
			1 {
				if {$segment(tuningcnt) == 1} {
					label $f.00 -text "PRESS BUTTON BELOW, AND ENTER DATA FOR 1 CHORD"
				} else {
					label $f.00 -text "PRESS BUTTON BELOW, AND ENTER DATA FOR 1 OR $segment(tuningcnt) CHORDS"
				}
			} 
			2 {
				label $f.00 -text "PRESS BUTTON BELOW, AND PLAY $segment(tuningcnt) TIMED NOTES"
			} 
		}
		pack $f.00 -side top -pady 2
		radiobutton $f.basic -text $ndmsg -variable nd_entryval -value 0 -height 2 -width 2 -command "DoGettrofGetNoteData $f $chords"
		pack $f.basic -side top -pady 2 -fill x -expand true -anchor w
		label $f.xx -text "HIT MIDI-KEY $tv_stop WHEN THIS MIDI DATA IS ALL ENTERED\n\n"
		pack $f.xx -side top -pady 2
		wm resizable $f 0 0
		bind $f <Escape> {set pr_notedata 0}
	}
	set finished 0
	set pr_notedata 0
	raise $f
	update idletasks
	StandardPosition2 $f
	My_Grab 0 $f pr_notedata
	while {!$finished} {
		tkwait variable pr_notedata
		switch -- $pr_notedata {
			0 {
				break
			} 
			1 {
				if {$nd_entry < 0} {
					break
				}
			}	
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}	

proc DoGettrofGetNoteData {f chords} {
	global pr_notedata
	set pr_notedata [GettrofNoteDataPitches $f $chords]
}

#----- Get Pitches of the input sounds as MIDI data, and update the data-entry window (or quit if all data entered)

proc GettrofNoteDataPitches {f chords} {
	global nd_entry pr_notedata pprg mmod nd_entryval evv

	switch -- $chords {
		0 {			;#	pitch line
			if {![DoTV $evv(GETTROFLINE) 0	$f 1]} {
				return 0
			}
		}
		1 {			;#	chord sets
			if {![DoTV $evv(GETTROFTUNING) 0 $f 1]} {
				return 0
			}
		}
		2 {			;#	timing
			if {![DoTV $evv(GETTROFTIMING) 0 $f 1]} {
				return 0
			}
		}
		3 {			;#	timing and pitch
			if {![DoTV $evv(GETTROFMOTIF) 0 $f 1]} {
				return 0
			}
		}
	}
	ActivateRadio
	set nd_entry -1
	DisableRadioExcept -1
	return 1
}

#--- Distort envel applied to tails in segmented sound, or phrases

proc Gettrof_TailTune {pitches} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId median_line boost

	set chords [expr !$pitches]

	if {$segment(PAR0)} {
		set tunehead 1						;#	Also tune head
		set segment(nonewmarks) 1			;#	BUT marks cannot be recycled
	} else {
		set tunehead 0
	}
	if {$pitches} {
		set weighted $segment(PAR1)
		set articd   $segment(PAR2)
		if {![info exists segment(pitches)]} {
			Inf "CANNOT FIND PITCH DATA FOR REPITCHING"
			return 0
		}
	} else {
		if {![info exists segment(chords)]} {
			Inf "CANNOT FIND CHORD DATA FOR TUNING"
			return 0
		}
	}
	set tuningcnt 0
	set mm 0								;#	Index in original marklist
	if {$segment(phrase)} {
		set n 1								;#	Phrases assumed to be all HEADS, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
		set hcnt 1
	} elseif {$segment(headfirst)} {
		set n 2								;#	Index for first segment to pluck is 2 (segments count from 1)
		set j 1								;#	Indices for start and end times of segment, in marklist
		set k 2
		if {![MultipleProcessing]} {
			set hfnam $evv(DFLT_OUTNAME)HH1$evv(SNDFILE_EXT)
			set line [list $hfnam [lindex $segment(marklist) $mm] 1 1.0]
			lappend mixlines $line			;#	Start mix with the unaltered HEAD segment = 1st segment
		}
		incr mm
		set nexthno 2						;#	Index of next HEAD File to use ( from 1)
		set tcnt 1							;#	Index of TAIL files (counted from 1)
	} else {
		set n 1								;#	TAIL First, segment 1 (segs count from 1) is first to process
		set j 0
		set k 1
		set nexthno 1
		set tcnt 1
	}
											;#	Extended final val in marklist, replaced by true end of file
	if {![MultipleProcessing]} {
		ClearNoexpands
	}

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	;#	TUNING/REPITCHING TAILS (alternate segments) OR PHRASES (= HEADS)

	if {[info exists segment(recycprocess)]} {
		set segment(origmixlines) $segment(mixlines)
	}
	if {[MultipleProcessing]} {
		set chancnt [GettrofMixChancnt]
	} else {
		set chancnt 1
	}
	set no_pitch 0

	set nn 1								;#	Params to read time-varying params	
	while {$nn <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$nn) [expr [llength $segment(control$nn,$segment(process))] - 1]
		set segment(zccnt,$nn) 0
		incr nn
	}
	if {$segment(phrase)} {
		set msg_type "PHRASE"
	} else {
		set msg_type "TAIL SEGMENT"
	}
	if {$pitches} {

		Block "PLEASE WAIT:        REPITCHING $msg_type"
		set msg3 "REPITCHED"

		;#	GET PITCH CONTOUR OF TAIL

		set OK 1
		while {$OK} {

			if {[file exists $segment(notedata)]} {
				if [catch {file delete $segment(notedata)} zit] {
					Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATA FILE $segment(notedata) : $zit"	
					set OK 0
					break
				}
			}
			if {$articd} {

				;#	FIND MEDIAN PITCHES OF SEGMENTS

				if {[file exists $segment(medianfil)]} {
					if [catch {file delete $segment(medianfil)} zit] {
						Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATA FILE $segment(medianfil) : $zit"	
						set OK 0
						break
					}
				}

				if [catch {open $segment(notedata) "w"} zit] {
					Inf "CANNOT OPEN INTERMEDIATE TEMPORARY DATA FILE $segment(notedata) : $zit"	
					set OK 0
					break
				}
				foreach mark $marks {
					puts $zit $mark
				}
				close $zit

				set cmd [file join $evv(CDPROGRAM_DIR) spectune]
				lappend cmd tune 6 $segment(ana,0) $segment(medianfil) $segment(notedata) -b
				if {!$weighted} {
					lappend  -r
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING MEDIAN PITCHES OF SEGMENTS"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN EXTRACTION-OF-MEDIAN-PITCHES PROCESS"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					Inf "FAILED TO FIND MEDIAN PITCHES OF SEGMENTS "
					set OK 0
					break
				}
				if {![file exists $segment(medianfil)]} {
					Inf "NO MEDIAN PITCHES OF SEGMENTS FOUND"
					set OK 0
					break
				}
				if [catch {open $segment(medianfil) "r"} zit] {
					Inf"CANNOT OPEN SEGMENT-MEDIAN-PITCHES FILE $segment(medianfil) TO READ DATA"
					set OK 0
					break
				}
				catch {unset medianpitches}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] <= 0} {
							continue
						}
						if {![IsNumeric $item]} {
							set OK 0
							break
						}
						lappend medianpitches $item
					}
					if {!$OK} {
						break
					}
				}
				close $zit
				if {!$OK} {
					break
				}
				if {![info exists medianpitches]} {
					Inf "NO DATA FOUND IN MEDIAN-PITCHES FILE"
					set OK 0
					break
				}
				if {[llength $medianpitches] != $segment(cnt)} {
					Inf "NUMBER OF MEDIAN-PITCHES DOES NOT TALLY WITH NUMBER OF SEGMENTS"
					set OK 0
					break
				}
			} else {

				;#	FIND PITCH CONTOUR OF SOUND

				if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
					Inf "CANNOT DELETE INTERMEDIATE TEMPORARY SOUNDFILE $segment(othersnd) : $zit"	
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) repitch]
				lappend cmd getpitch 2 $segment(ana,0) $segment(othersnd) $segment(notedata) -d0.000020
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING PITCH CONTOUR OF SOURCE"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN PITCH CONTOUR EXTRACTION PROCESS"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO EXTRACT PITCH CONTOUR OF SOURCE"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $segment(notedata)]} {
					Inf "NO SOURCE PITCH CONTOUR FOUND"
					set OK 0
					break
				}
				if [catch {open $segment(notedata) "r"} zit] {
					Inf "CANNOT OPEN FILE $segment(notedata) TO READ THE ORIGINAL PITCH-CONTOUR OF SOURCE"
					set OK 0
					break
				}
				catch {unset pitchcontour}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					set nuline {}
					set cnt 0
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] <= 0} {
							continue
						}
						if {![IsNumeric $item]} {
							set OK 0
							break
						}
						if {$cnt == 1} {							;#	Store contour as MIDI values
							set item [HzToMidi $item]
						}
						lappend nuline $item
						incr cnt
					}
					if {!$OK} {
						break
					}
					if {$cnt != 2} {
						Inf "INVALID DATA IN PITCH-CONTOUR FILE"
						set OK 0
						break
					}
					lappend pitchcontour $nuline
				}
				close $zit
				if {!$OK} {
					break
				}
				if {![info exists pitchcontour]} {
					Inf "NO DATA FOUND IN PITCH-CONTOUR FILE"
					set OK 0
					break
				}
			}
			break
		}
		if {!$OK} {
			set no_pitch 1
		}

	} else {
		Block "PLEASE WAIT:        TUNING $msg_type"
		set msg3 "TUNED"
	}

	set OK 1
	set ecnt 0

	while {$n <= $segment(cnt)} {

		set prescale 0
		if {[MultipleProcessing] && $pitches && [HasVerged $n]} {
			if {$boost} {
				set prescale 1
			}
		}

		set leftbase [lindex $marks $j]
		if {$chords} {
			set clarity [GetParamValueFromControl $leftbase 2]
			set clarity [expr pow($clarity,$segment(TUNECLARPOW))]
		}

		;#	ALWAYS A TAIL (or PHRASE = HEAD)

		if {$segment(multiproccnt) && ([lindex $segment(actionlist) $n] == 0)} {
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
				incr hcnt									;#	Phrases assumed to be all heads
				continue
			} else {
				incr mm 2									;#	If no tail processing required
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
				incr tcnt
				continue
			}
		}
		if {[MultipleProcessing]} {
			if {$segment(phrase)} {							;#	phrases only use HEAD numbering scheme (no tails)
				if {![GetRecycledSegment $hcnt HEAD]} {		;#	"segment(recycline)" gets position of HEAD
					set OK 0
					break
				}
			} else {
				if {![GetRecycledSegment $tcnt TAIL]} {		;#	At this point "segment(recycline)" gets position of TAIL
					set OK 0
					break
				}
			}
			set ifnam $segment(iifnam)
			set tailtime [lindex [lindex $segment(mixlines) $segment(recycline)] 1]

		} else {											;#	phrases only use multiple processing
			set ifnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
			set tailtime $leftbase
		}

		if {$no_pitch} {											;# If no pitch found
			if {![MultipleProcessing]} {
				set line [list $ifnam [lindex $marks $mm] 1 1.0]	;#	put untuned source in output
				lappend mixlines $line
			}														;#	and skip to next segment
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
				incr hcnt
				continue
			} else {
				incr mm 2
				incr n 2
				incr j 2
				incr k 2
				incr tcnt
				continue
			}
		}
		if {$segment(phrase)} {								;#	phrases only use HEAD numbering scheme
			set ofnam $evv(MACH_OUTFNAME)PH$hcnt$evv(SNDFILE_EXT)
		} else {
			set ofnam $evv(MACH_OUTFNAME)PT$tcnt$evv(SNDFILE_EXT)
		}
		if {[string match $ifnam $ofnam]} {					;#	e.g. VERGES has fused Head+Tail already to make PT
			if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(exclmix)"
				set OK 0
				break
			}
			if [catch {file rename $ifnam $segment(exclmix)} zit] {
				Inf "CANNOT RENAME INTERMEDIATE FILE $ifnam"
				set OK 0
				break
			}
			set ifnam $segment(exclmix)
		}

		if {$pitches && !$articd} {
			set starttime [lindex $marks $mm]
			set endtime   [lindex $marks [expr $mm + 1]]
			set pcontour [GetSegmentPitchContour $pitchcontour $starttime $endtime]
		}

		set tuning_head 0
		set joined_head 0

		;#	phrases don't use "tunehead" option

		if {$prescale} {
			if {![PrescaleForPitchlineAfterVergesWithBoost $ifnam $msg_type $n]} {
				set OK 0
				break
			}
		}

		if {$tunehead} {
			if {$segment(headfirst)} {
				set hcnt $tcnt						;#	Head associated with tail has same hno		H1 T1 H2 T2 H3 T3
			} else {								;#												----- ----- -----
				set hcnt [expr $tcnt - 1]			;#	Head associated with tail has previous hno	T1 H1 T2 H2 T3 H3
			}										;#												   ----- -----
			if {$hcnt > 0} {
				set tuning_head 1
				if {[MultipleProcessing]} {			;#	If tuning Head also "segment(recycline)" gets position of preceding HEAD
					if {![GetRecycledSegment $hcnt HEAD]} {
						set OK 0
						break
					}
					if {$segment(recycline) < 0} {	;#	No HEAD: (H already fused with T --> PT)
						set tuning_head 0
						set joined_head 1
					} else {
						set headtime [lindex [lindex $segment(mixlines) $segment(recycline)] 1]
						set mixstep [expr $tailtime - $headtime]
						set hfnam $segment(iifnam)
						if {$segment(doublehead)} {
							set hfnam2 $segment(iifnam2)
							set headtime2 [lindex [lindex $segment(mixlines) [expr $segment(recycline) + 1]] 1]
							set mixstep2 [expr $headtime2 - $headtime]
						}
					}																			;#	H1  T1	 H2	 T2
				} else {																		;#	| |		| |
					set hfnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)						;#	 __		 __
					set headtime [lindex $marks [expr $j - 1]]									;#	|  \____/  \____
					set mixstep [expr $tailtime - $headtime]									;#	   /	\  /	\
																								;# !!! DON'T DELETE THIS LINE!!
					if {$hcnt > 1} {															;#  |-|	   |--| 
						set mixstep [expr $mixstep + $segment(SPLICE)]							;#  mark	upsplice
					}																			;#			  step																			;#	step	+ mark

					set segment(iichan) 1			;#	If not multiple process, head must be mono
					set segment(doublehead) 0		;#	and not previously processed, so can't be doubled
				}

				if {$tuning_head} {

					;#	If repitching, and changing pitch contour, need to extend tvar transposition file back across head

					if {$pitches && !$articd} {
						catch {unset nupcontour}
						set pc [lindex $pcontour 0]
						set val [lindex $pc 1]
						set newpc [list 0.0 $val]
						lappend nupcontour $newpc
						foreach pc $pcontour {
							set time [expr [lindex $pc 0] + $mixstep]
							set val [lindex $pc 1]
							set newpc [list $time $val]
							lappend nupcontour $newpc
						}
						set pcontour $nupcontour 
					}
					if {[file exists $segment(fadesnd)]} {											
						if [catch {file delete $segment(fadesnd)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE TEMPORARY SOUND FILE $segment(fadesnd)"	
							set OK 0
							break
						}
					}
					if {[file exists $segment(mixdata)]} {
						if [catch {file delete $segment(mixdata)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE MIXFILE $segment(mixdata)"	
							set OK 0
							break
						}
					}

					;#	MAKE MIXFILE TO MIX HEAD TO TAIL

					catch {unset lines}
					if {$chancnt > 2} {
						set line $chancnt
						lappend lines $line
						set line [list $hfnam 0.0 $segment(iichan)]
						set kk 1
						while {$kk <= $segment(iichan)} {
							lappend line "$kk:$kk" 1.0
							incr kk
						}
						lappend lines $line
						if {$segment(doublehead)} {
							set line [list $hfnam2 $mixstep2 $segment(iichan2)]
							set kk 1
							while {$kk <= $segment(iichan2)} {
								lappend line "$kk:$kk" 1.0
								incr kk
							}
							lappend lines $line
						}
						set line [list $ifnam $mixstep 1 1:1 1.0]
						lappend lines $line
					} else {
						set line [list $hfnam 0.0 $segment(iichan) 1.0]
						lappend lines $line
						if {$segment(doublehead)} {
							set line [list $hfnam2 $mixstep2 $segment(iichan2) 1.0]
							lappend lines $line
						}
						set line [list $ifnam $mixstep 1 1.0]
						lappend lines $line
					}
					if [catch {open $segment(mixdata) "w"} zit] {
						Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixdata) TO JOIN HEAD TO TAIL : SEGMENT $n"
						set OK 0
						break
					}
					foreach line $lines {
						puts $zit $line
					}
					close $zit

					if {[file exists $segment(othersnd)]} {
						if [catch {file delete $segment(othersnd)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE TEMPORARY SOUND FILE $segment(othersnd)"	
							set OK 0
							break
						}
					}

					;#	MIX HEAD TO TAIL

					if {$chancnt > 2} {
						set cmd [file join $evv(CDPROGRAM_DIR) newmix]
						lappend cmd multichan $segment(mixdata) $segment(othersnd)
					} else {
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd mix $segment(mixdata) $segment(othersnd)
					}
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        RECOMBINING HEAD & TAIL FOR SEGMENT $n"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RECOMBINE HEAD & TAIL FOR SEGMENT $n"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE SOUND BY RECOMBINING HEAD & TAIL FOR SEGMENT $n"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $segment(othersnd)]} {
						Inf "NO FILE OF RECOMBINED HEAD & TAIL FOR SEGMENT $n"
						set OK 0
						break
					}
				}
			}
		}
		if {$segment(phrase)} {
			incr hcnt
		} else {
			incr tcnt
		}

		if {$tuning_head || $joined_head} {
			if {$tuning_head} {
				set thissnd $segment(othersnd)
			} else {
				set thissnd $ifnam
			}

		;#	IF PRE-EXISTING HEAD IS STEREO OR MULTICHAN EXTRACT ALL THE CHANNELS AS SEPARATE MONO FILES

			set thischancnt $chancnt
			if {$chancnt > 1} {
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 2 $thissnd
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING CHANNELS OF SEGMENT $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN CHANNEL EXTRACTION PROCESS FOR SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO EXTRACT CHANNELS FROM SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				set thischan 1
				while {$thischan <= $chancnt} {
					set ichfnam($thischan) [file rootname $thissnd]
					append ichfnam($thischan) "_c$thischan" $evv(SNDFILE_EXT)
					if {![file exists $ichfnam($thischan)]} {
						set thischancnt [expr $thischan - 1]
						break
					}
					incr thischan
				}
			} else {
				set ichfnam(1) $thissnd
			}

		;#	ELSE IF PRE-EXISTING HEAD (OR JOINED H+T) WAS MONO, ASSIGN IT TO CHANNEL 1 : OR, IF NO HEAD PROCESSING, RENAME INPUT AS CHANNEL 1

		} else {
			set ichfnam(1) $ifnam
			set thischancnt 1
		}

		;#	GET SPECTRUM OF EACH CHANNEL

		set OK2 1
		set thischan 1
		while {$thischan <= $thischancnt} {
			set msg2 "SEGMENT $n"
			if {$thischancnt > 1} {
				append msg2 " CHANNEL $thischan"
			}
			set aifnam($thischan) [file rootname [file tail $ichfnam($thischan)]]	;#	analysis of original chan
			append aifnam($thischan) $evv(ANALFILE_EXT)
			if {[file exists $aifnam($thischan)] && [catch {file delete $aifnam($thischan)} zit]} {
				Inf "CANNOT DELETE PRE-EXISTING ANALYIS FILE FOR $msg2 : $zit"
				set OK2 0
				break
			}
			set aofnam($thischan) [file rootname [file tail $ofnam]]				;#	tuned original chan
			append aofnam($thischan) "_c$thischan" $evv(ANALFILE_EXT)

			set ofnamc($thischan) [file rootname [file tail $ofnam]]				;#	output wavfile of tuned chan
			append ofnamc($thischan) "_c$thischan" $evv(SNDFILE_EXT)

			if {[file exists $aofnam($thischan)] && [catch {file delete $aofnam($thischan)} zit]} {
				Inf "CANNOT DELETE PRE-EXISTING ANALYIS FILE FOR OUTPUT OF $msg2 : $zit"
				set OK2 0
				break
			}
			if {[file exists $ofnamc($thischan)] && [catch {file delete $ofnamc($thischan)} zit]} {
				Inf "CANNOT DELETE PRE-EXISTING WAV FILE FOR OUTPUT OF $msg2 : $zit"
				set OK2 0
				break
			}
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd anal 1 $ichfnam($thischan) $aifnam($thischan) -c1024 -o3

			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF $msg2"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN SPECTRUM CREATION PROCESS FOR $msg2"
				catch {unset CDPidrun}
				set OK2 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SPECTRUM OF $msg2"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK2 0
				break
			}
			if {![file exists $aifnam($thischan)]} {
				Inf "NO SPECTRUM OF $msg2 CREATED"
				set OK2 0
				break
			}

			;#	GET TUNING DATA FOR CURRENT SEGMENT

			if {$chords} {
				if {$thischan == 1} {
					set thistuning [lindex $segment(chords) $tuningcnt]	
					incr tuningcnt
					if {$tuningcnt > $segment(tuningcnt)} {
						Inf "ANOMALY IN COUNTING CHORDS tuningcnt = $tuningcnt total input chords = $segment(tuningcnt)"
						set OK2 0
						break
					}
					if {[file exists $segment(notedata)]} {
						if [catch {file delete $segment(notedata)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATA FILE $segment(notedata) : $zit"	
							set OK2 0
							break
						}
					}
					if [catch {open $segment(notedata) "w"} zit] {
						Inf "CANNOT OPEN TEMPORARY DATA FILE $segment(notedata) TO WRITE TUNING DATA FOR SEGMENT $n : $zit"	
						set OK2 0
						break
					}
					foreach pitch $thistuning {
						puts $zit $pitch
					}
					close $zit
				}
			} else {  ;#	pitches
	
				set thistuning [lindex $segment(pitches) $tuningcnt]	
				incr tuningcnt
				if {$tuningcnt > $segment(tuningcnt)} {
					Inf "ANOMALY IN COUNTING PITCHES pitchcnt = $tuningcnt total input pitches = $segment(tuningcnt)"
					set OK2 0
					break
				}
				if {$articd} {												;#	If pitch-motion retained
					set medianpitch [lindex $medianpitches [expr $n - 1]]
					set transpos [expr $thistuning - $medianpitch]			;#	Simple transposition from median to thistuning
				} else {
					set len [llength $pcontour]								;#	If pitch-motion flattened
					set kj 0
					catch {unset tranposer}												
					while {$kj < $len} {									;#	Get pitch-contour value
						set pc [lindex $pcontour $kj]						;#	and convert to transposition required
						set val [lindex $pc 1]
						set val [expr $thistuning - $val]
						set pc [lreplace $pc 1 1 $val]
						lappend tranposer $pc
						incr kj
					}
					if {[file exists $segment(notedata)]} {
						if [catch {file delete $segment(notedata)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATA FILE $segment(notedata) : $zit"	
							set OK2 0
							break
						}
					}
					if [catch {open $segment(notedata) "w"} zit] {
						Inf "CANNOT OPEN TEMPORARY DATA FILE $segment(notedata) TO WRITE TRANSPOSITION DATA FOR SEGMENT $n : $zit"	
						set OK2 0
						break
					}
					foreach pc $tranposer {
						puts $zit $pc
					}
					close $zit
				}
			}

			if {$chords} {

				;#	TUNE EACH SEGMENT TO CHORD

				set cmd [file join $evv(CDPROGRAM_DIR) pitch]
				lappend cmd tune 2 $aifnam($thischan) $aofnam($thischan) $segment(notedata) -f1 -c$clarity -t16 -b10
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        TUNING SPECTRUM OF $msg2"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN TUNING SPECTRUM OF $msg2"
					catch {unset CDPidrun}
					set OK2 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO TUNE SPECTRUM OF $msg2"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK2 0
					break
				}
				if {![file exists $aofnam($thischan)]} {
					Inf "NO TUNED SPECTRUM OF $msg2 CREATED"
					set OK2 0
					break
				}

			} else {		;#	PITCHES
			
				set cmd [file join $evv(CDPROGRAM_DIR) repitch]
				lappend cmd transposef 3 $aifnam($thischan) $aofnam($thischan) -p4
				if {$articd} {
					lappend cmd $transpos
				} else {
					lappend cmd $segment(notedata)
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        REPITCHING SPECTRUM OF $msg2"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN REPITCHING OF SPECTRUM OF $msg2"
					catch {unset CDPidrun}
					set OK2 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO REPITCH SPECTRUM OF $msg2"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK2 0
					break
				}
				if {![file exists $aofnam($thischan)]} {
					Inf "NO REPITCHED SPECTRUM OF $msg2 CREATED"
					set OK2 0
					break
				}
			}
			;#	RECONVERT EACH CHANNEL TO WAV FORMAT	

			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd synth $aofnam($thischan) $ofnamc($thischan)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CREATING $msg3 $msg2"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO MAKE $msg3 $msg2"
				catch {unset CDPidrun}
				set OK2 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE $msg3 $msg2"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK2 0
				break
			}
			if {![file exists $ofnamc($thischan)]} {
				Inf "NO $msg3 $msg2 CREATED"
				set OK2 0
				break
			}
			if {!$tuning_head} {
				break
			}
			incr thischan
		}
		if {!$OK2} {
			set OK 0
			break
		}
		if {$tuning_head && ($thischancnt > 1)} {

			;#	IF NECESSARY, RECONSTRUCT THE STEREO OR MULTICHANNEL OUTPUT REQUIRED

			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd interleave
			set thischan 1
			while {$thischan <= $thischancnt} {
				lappend cmd $ofnamc($thischan)
				incr thischan
			}
			lappend cmd $segment(fadesnd)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        MERGING CHANNELS FROM SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO MERGE CHANNELS FROM SEGMENT $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO MERGE CHANNELS FROM SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $segment(fadesnd)]} {
				Inf "NO MERGED-CHANNELS-FILE OF TUNED SEGMENT $n CREATED"
				set OK 0
				break
			}

		} else {
			set segment(fadesnd) $ofnamc(1)

		}

		;#	DOVETAIL START OF RETUNED/REPITCHED OUTPUT

		set cmd [file join $evv(CDPROGRAM_DIR) envel]								;#	dovetail START
		lappend cmd dovetail 1 $segment(fadesnd) $ofnam $segment(SPLICE) 0.0 0 0 -t0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        DOVETAILING $msg3 SEGMENT $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO DOVETAIL $msg3 SEGMENT $n"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE DOVETAILED $msg3 SEGMENT $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "NO DOVETAILED $msg3 SEGMENT $n CREATED"
			set OK 0
			break
		}
		if {[string match $segment(fadesnd) $ofnamc(1)]} {
			set segment(fadesnd) $segment(fadesnd_dflt)
		}

		;#	REMOVE INTERMEDIATE TEMPORARY FILES

		catch {unset dellist}
		catch {unset prelist}
		foreach zzfnam [glob $evv(DFLT_OUTNAME)*] {		;#	Assemble names of all temporary files 
			lappend prelist $zzfnam						;#	which includes mono_chans, ana, tuned_ana and tuned_wav files (as well as textfiles) 
		}
		foreach zzfnam [glob $evv(MACH_OUTFNAME)*] {
			lappend prelist $zzfnam
		}
		foreach zzfnam $prelist {						;#	and choose all of then that have "_cN" tails.
			if {[string first "_c" $zzfnam] > 0} {
				lappend dellist $zzfnam
			}
		}
		if {[file exists $segment(exclmix)]} {			;#	If the input file had to be renamed, add to list.
			lappend dellist $segment(exclmix)
		}
		if {[info exists dellist]} {					;#	Delete all these.
			foreach delfnam $dellist {
				if [catch {file delete $delfnam} zit] {
					Inf "CANNOT DELETE INTERMEDIATE FILE $delfnam"
				}
			}
		}
		if {($thischancnt == 1) && [file exists $aifnam(1)]} {	;#	If input is MONO, same as above, and therefore no attempt at channel extraction
			if [catch {file delete $aifnam(1)} zit] {			;# 	initial anal file will have no "_cN" tail
				Inf "CANNOT DELETE INTERMEDIATE ANALYSIS FILE $aifnam(1) : $zit"
			}
		}
		
		;# PLACE TRANSFORMED LINE IN MIX
					
		if {[MultipleProcessing]} {
			set kk [expr $segment(recycline) + 1]		;#	mixlines numbered from 0 , segments (used here) from 1
			if {$tuning_head} {
				set line [lindex $segment(mixlines) $segment(recycline)]	;#	This is the (1st) of any HEAD lines, before the TAIL
				set time [lindex $line 1]
				set line [list $ofnam $time $thischancnt 1.0]
				PhraseLineReinsert $kk $line 1			;#	Reinsert the line, complete with new channel count and poss multichan format
														;#	and delete line AFTER the insertion point (the HEAD position) which is the original TAIL
				set segment(mixlines) [lreplace $segment(mixlines) $kk $kk]
				if {$segment(doublehead)} {				;#	Or if TWO head files replaced, delete 2 files after insertion point
					set segment(mixlines) [lreplace $segment(mixlines) $kk $kk]
					set cnt 2
				} else {
					set cnt 1
				}
				set lexlen [llength $segment(mixlines)]	;#	Line 2 -> Segment 3, contract the list of noexpand markers
				ContractNoexpand [expr $kk + 1] $lexlen $cnt	

			} else {
				PhraseLineReinsert $kk $ofnam 0			;#	If tail only, replaces tail-line, which is MONO (or STEREO after REVERB), so just replace name
			}
		} else {
			if {$tuning_head} {
				set thistime [lindex $marks [expr $mm - 1]]				;#	If tuning head, Head and tail have been fused,
				if {$thistime > 0.0} {									;#	so new file goes where HEAD would have been	
					set thistime [expr $thistime - $segment(SPLICE)]	
				}
			} else {
				set thistime [lindex $marks $mm]		;#	Else new file goes where tail goes
			}
			set line [list $ofnam $thistime 1 1.0]
			lappend mixlines $line
		}
		if {$segment(phrase)} {
			incr n
			incr j										;#	1 segment at a time, if phrases
			incr k
			continue
		}
		incr mm
		if {!$tunehead} {								;#	if NOT also tuning heads (in which case, heads handled above)
			set hfnam $evv(DFLT_OUTNAME)HH$nexthno$evv(SNDFILE_EXT)
			incr nexthno		
			if {[file exists $hfnam]} {					;#	If there's a following HEAD
				set mixtime [expr [lindex $marks $mm] - $segment(SPLICE)]
				set line [list $hfnam $mixtime 1 1.0]
				lappend mixlines $line					;#	Add it to mix
			}
		}
		incr mm
		incr n 2									;#	Skip to next (iterable) tail
		incr j 2									;#	and next strt and end markers (times) of segments	
		incr k 2
	}

	if {[info exists badsegs]} {
		set blen [llength $badsegs]
		if {$blen > 1} {
			set msg4 "SEGMENTS "
			incr blen -2
			foreach item [lrange $badsegs 0 $blen] {
				append msg4 "$item  "
			}
			append msg4 "AND [lindex $badsegs end] "

		} else {
			set msg4 "SEGMENT [lindex $badsegs 0] "
		}
		append msg4 "COULD NOT BE REPITCHED"
		Inf $msg4
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	} elseif {$segment(multiproccnt)} {				;#	With a multiprocess, we don't mix until we reach end
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)				;#	If a 2nd process, get the reconfigureed mixlines
	} else {
		set segment(mixlines) $mixlines				;#	If a 1st process, keep the original mixlines (for possible later reconfiguring)
	}
	if {$segment(expand) && !$segment(noexpand)} {
		if {![ExpandPhraseMix 1]} {
			Inf "CANNOT EXPAND THE SEGMENT STRING AS REQUESTED"
		} else {
			set mixlines $segment(mixlines)
		}
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}

	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	if {[info exists segment(recycprocess)]} {		;#	OUTPUT MIX MAY OVERLOAD + MAY BE MULTICHANNEL
		if {![GettrofPossiblyMultichanMixdown 1]} {
			set segment(mixlines) $segment(origmixlines)
			set OK 0
		}
	} else {										;#	STANDARD MONO MIX FOR PLUCK PROCESS
		if {![GettrofMixdown 1]} {
			set OK 0
		}
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	set segment(reordered) 0
	return 1
}

#---- How many chords OR pitches needed if all segs to be TUNED/PITCH are given different chords/pitches

proc NumberOfSegmentsToBeTuned {procc} {
	global segment
	set segment(tuningcnt) 0
	if {$segment(multiproccnt)} {
		foreach dud $segment(multido) {
			if {[lindex $dud 0] == $procc} {
				set actionlist [lindex $dud 1]
				foreach action $actionlist {
					if {$action} {
						incr segment(tuningcnt)
					}
				}
				break
			}
		}
	} else {													;#	(6) EVEN headfirst		HTHTHT	= 3 Tails		(6/2)
		set segment(tuningcnt) [expr $segment(cnt)/2]			;#	(6) EVEN !headfirst		THTHTH	= 3 Tails		(6/2)
		if {![IsEven $segment(cnt)] && !$segment(headfirst)} {	;#	(7)	ODD	 headfirst		HTHTHTH = 3 Tails		(7/2)
			incr segment(tuningcnt)								;#	(7)	ODD	 !headfirst		THTHTHT = 4 Tails		(7/2) + 1
		}
	}
}

#--- Extract pitch contour of a segment from the total pitch contour of the source

proc GetSegmentPitchContour {pitchcontour starttime endtime} {
	set n 0
	set len [llength $pitchcontour]
	while {$n < $len} {
		set pc [lindex $pitchcontour $n]
		set time [lindex $pc 0]
		set val  [lindex $pc 1]
		if {$time > $starttime}  {
			break
		}
		incr n
	}
	if {$n >= $len} {
		Inf "ERROR IN PITCH-CONTOUR ACCOUNTING (1)"
		return {}
	}
	incr n -1
	if {$n < 0} {
		Inf "ERROR IN PITCH-CONTOUR ACCOUNTING (2)"
		return {}
	}
	set lastpc [lindex $pitchcontour $n]
	set lasttime [lindex $lastpc 0]
	set lastval  [lindex $lastpc 1]
	set timegap [expr $time - $lasttime]
	set valgap  [expr $val  - $lastval]
	set timestep [expr $starttime - $lasttime]
	set timeratio [expr $timestep/$timegap]
	set valstep [expr $valgap * $timeratio]
	set val [expr $lastval + $valstep]
	set pcontour [list [list $starttime $val]]
	incr n
	while {$n < $len} {
		set pc [lindex $pitchcontour $n]
		set time [lindex $pc 0]
		set val  [lindex $pc 1]
		if {$time > $endtime} {
			break
		}
		lappend pcontour $pc
		incr n
	}
	incr n -1
	if {$n < 0} {
		Inf "ERROR IN PITCH-CONTOUR ACCOUNTING (3)"
		return {}
	}
	set lastpc [lindex $pitchcontour $n]
	set lasttime [lindex $lastpc 0]
	set lastval  [lindex $lastpc 1]
	set timegap [expr $time - $lasttime]
	set valgap  [expr $val  - $lastval]
	set timestep [expr $endtime - $lasttime]
	set timeratio [expr $timestep/$timegap]
	set valstep [expr $valgap * $timeratio]
	set val [expr $lastval + $valstep]
	set pc [list $endtime $val]
	lappend pcontour $pc
	set len [llength $pcontour]
	set nupcontour {}
	set n 0
	while {$n < $len} {
		set pc [lindex $pcontour $n]
		set time [lindex $pc 0]
		set time [expr $time - $starttime]
		set val [lindex $pc 1]
		set pc [list $time $val]
		lappend nupcontour $pc
		incr n
	}
	return $nupcontour
}

#--- Read Median Pitch from line output by "spectune"

proc GetMedianPitchOutput {} {
	global median_line
	set line [string trim $median_line]
	set line [split $line]
	foreach item $line {
		set item [string trim $item]
		if {[string length $item] <= 0} {
			continue
		}
		if {[IsNumeric $item]} {
			return $item
		}
	}
	return -1
}

#--- Read the "MEDIAN PITCH" data output for "PITCH" process

proc GetMedianPitchLine {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages median_line

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif {[string first INFO $line] >= 0} {
			set median_line $line
			return
		} elseif [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		}
	}
	update idletasks
}

#########
# TWANG #
#########

#--- Enter Anacrusis or Decay-tail choice for Twang

proc TwangStyle {} {
	global segment pr_twangstyl evv untwang twangnorm
	set f .twangstyl
	if [Dlg_Create $f "PRESET PARAMETERS FOR TWANG" "set pr_twangstyl 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_twangstyl 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_twangstyl 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_twangstyl 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		checkbutton $f.1.1  -text "Untwang"   -variable untwang -width 16
		checkbutton $f.1.2  -text "Normalise" -variable twangnorm -width 16
		set untwang 0
		set twangnorm 0
		pack $f.1.1 $f.1.2 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_twangstyl 1}
		bind $f <Escape> {set pr_twangstyl 0}
	}
	set pr_twangstyl 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_twangstyl
	while {!$finished} {
		tkwait variable pr_twangstyl
		switch -- $pr_twangstyl {
			1 {
				set segment(par0) $untwang
				set segment(PAR0) $untwang
				set segment(untwang) $untwang
				set segment(par1) $twangnorm
				set segment(PAR1) $twangnorm
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#--- Twang Head	
#
#	PRESETS param "Untwang?"	
#			param "Normalise?"
#
#	Normalise perhaps
#	For UNTWANG: Reverse File
#	Locate time of max, within range 0 to end-less-0.004	= X
#	Pvoc anal
#	CreateTwarpData
#	Do tstretch
#	PVOC synth
#	if len > p2+X CUT						param-2 = LENGTH
#	CreCreateDecayEnvelope					param-3 = ATTEN	(see curtail code to see how this is done)
#	Envel output
#
#	For UNTWANG: Reverse File
#

proc Gettrof_HeadTwang {} {
	global segment evv wstk prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId overload_line
 
	;#	READ FIXED PARAMS

	set untwang $segment(PAR0)
	set normalise $segment(PAR1)
	if {!$segment(phrase)} {
		set fadestart $segment(PAR2)
		set fadexp	  $segment(PAR3)
	}

	;#	PARAMS FOR READING CONTROL FILES

	set n 1
	while {$n <= $segment(vparams_cnt,$segment(process))} {
		if {[info exists segment(control$n,TWANG)]} {
			set segment(zlim,$n) [expr [llength $segment(control$n,TWANG)] - 1]
			set segment(zccnt,$n) 0
		}
		incr n
	}

	;#	PROCESSING PARAMS FOR WHILE-LOOP

	if {$segment(phrase) || $segment(headfirst)} {
		set ishead 1
	} else {
		set ishead 0
	}
	set n 1		;#	Index for first head segment to stack is 1 (segments count from 1)
	set noex 1
	set j 0		;#	Indices for start and end times of segment, in marklist
	set k 1
	set hno 1	;#	Index of 1st HEAD file (headfile names are indexed from 1)
	set tno 1	;#	Index of 1st TAIL file (tailfile names are indexed from 1)

				;#	Extended final val in marklist, replaced by true end of file

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	if {![MultipleProcessing]} {
		ClearNoexpands											;#	Clear all flags relating to mixfile lines being immovable
	}
	if {[MultipleProcessing]} {
		set segment(origmixlines) $segment(mixlines)			;#	Store existing mixlines, in case we need to baktrak
	}

	if {$segment(phrase)} {
		set msg_typ	PHRASE
	} else {
		set msg_typ	"HEAD SEGMENT"
	}
	set msg "TWANGING "
	append msg $msg_typ S 
	Block "$msg"

	set OK 1
	catch {unset segment(recycline)}
	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]							;#	Head start
		if {$ishead} {

			if {$segment(multiproccnt)} {
				if {[lindex $segment(actionlist) $n] == 0} {
					incr n
					incr noex									;#	IF no action required								
					incr j										;#	Skip to next segment
					incr k
					incr hno
					if {!$segment(phrase)} {					;#	Phrases always flagged as heads
						set ishead [expr !$ishead]
					}
					continue
				}
			}

			#	POSSIBLY-VARIABLE-PARAMETER CONVERSION

			set tstretch [GetParamValueFromControl $leftbase 1]
			set outdur	 [GetParamValueFromControl $leftbase 2]
			set decaypow [GetParamValueFromControl $leftbase 3]

			;#	GET TWANG PARAMETERS

			if {[MultipleProcessing]} {
				if {![GetRecycledSegment $hno HEAD]} {
					set OK 0
					break
				}
				set ifnam $segment(iifnam)
			} else {
				set ifnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
			}
			set ofnam $evv(MACH_OUTFNAME)PH$hno$evv(SNDFILE_EXT)

			;#	FIND TIME OF SEGMENT MAXLEVEL

			if {![DoSegmentDurParse $ifnam]} {
				Inf "FAILED TO FIND DURATION OF $msg_typ $n"
				set OK 0
				break
			}
			set segdur $segment(itemdur)
			if {$segdur <= 0.004} {
				Inf "WARNING: SEGMENT $n TOO SHORT (<0.004 secs) TO TWANG"
				incr n										;#	IF no action required								
				incr noex
				incr j										;#	Skip to next segment
				incr k
				incr hno
				if {!$segment(phrase)} {					;#	Phrases always flagged as heads
					set ishead [expr !$ishead]
				}
				continue
			}	

			;#	IF "Normalise" NORMALISE SOUNDFILE

			if {$normalise} {

				if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
					Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(fadesnd) : $zit"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 3 $ifnam $segment(fadesnd) -l0.9

				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker  "PLEASE WAIT:        NORMALISING $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN PROCESS TO NORMALISE $msg_typ $n"
					catch {unset CDPidrun}
					UnBlock
					return 0
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
# HEREH COULD BE OMITTED -->
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO NORMALISE $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
				}
# <-- HEREH COULD BE OMITTED
				if {[file exists $segment(fadesnd)]} {
					set ifnam $segment(fadesnd)
				}
			}

			;#	IF "Untwang" REVERSE SOUNDFILE

			if {$untwang} {

				if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
					Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(othersnd) : $zit"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd radical 1 $ifnam $segment(othersnd)

				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker  "PLEASE WAIT:        REVERSING $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN PROCESS TO REVERSE $msg_typ $n"
					catch {unset CDPidrun}
					UnBlock
					return 0
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO REVERSE $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					return 0
				}
				if {![file exists $segment(othersnd)]} {
					Inf "NO REVERSED INFILE CREATED FOR $msg_typ $n"
					UnBlock
					return 0
				}
				set jfnam $segment(othersnd)

			} else {
				set jfnam $ifnam
			}
			set cmd [file join $evv(CDPROGRAM_DIR) sndinfo]
			lappend cmd maxsamp2 $jfnam 0 [expr $segdur - 0.004]
			catch {unset maxsamp_line}
			set done_maxsamp 0
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "FAILED TO RUN 'sndinfo maxsamp2' FOR SEGMENT $n"
				set OK 0
				break
	   		} else {
	   			fileevent $CDPmaxId readable "Get_Maxsamp_Info_Segment"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				Inf "CANNOT RETRIEVE MAXIMUM SAMPLE INFORMATION FOR SEGMENT $n"
				set OK 0
				break
			}
			set gotatk 0
			foreach line $maxsamp_line {
				if {[string first "time" $line] >= 0} {
					set line [split $line]
					foreach item $line {
						if {[string length $item] <= 0} {
							continue
						}
						if {[IsNumeric $item]} {
							set atktime $item
							set gotatk 1
							break
						}
					}
				}
				if {$gotatk} {
					break
				}
			}
			if {!$gotatk} {
				Inf "FAILED TO FIND TIME OF ATTACK IN SEGMENT $n"
				set OK 0
				break
			}

			;#	CREATE ANAL FILE
			
			set afnam [file rootname $ifnam]
			append afnam $evv(ANALFILE_EXT)
			if {[file exists $afnam] && [catch {file delete $afnam} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE ANALYSIS FILE $afnam : $zit"
				set OK 0
				break
			}
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd anal 1 $jfnam $afnam -c1024 -o3
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}

			wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO CREATE SPECTRUM OF $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SPECTRUM OF $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $afnam]} {
				Inf "NO SPECTRUM OF $msg_typ $n CREATED"
				set OK 0
				break
			}

			;#	CREATE TIME-STRETCH WARPFILE

			set twarpdata [CreateTwarpData $atktime $segdur $tstretch]

			if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE DATA FILE $segment(notedata) : $zit"
				set OK 0
				break
			}
			if [catch {open $segment(notedata) "w"} zit] {
				Inf "CANNOT OPEN TIMEWARP DATA FILE $segment(notedata) : $zit"
				set OK 0
				break
			}
			foreach line $twarpdata {
				puts $zit $line
			}
			close $zit

			;#	DO TWANG-TIMESTRETCH

			set aofnam $evv(MACH_OUTFNAME)$n$evv(ANALFILE_EXT)
			if {[file exists $aofnam] && [catch {file delete $aofnam} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE SPECTRAL FILE $aofnam : $zit"
				set OK 0
				break
			}

			set cmd [file join $evv(CDPROGRAM_DIR) stretch]
			lappend cmd time 1 $afnam $aofnam $segment(notedata)
			
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}

			wm title .blocker "PLEASE WAIT:        TIMESTRETCHING $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO TIMESTRETCH $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO TIMESTRETCH $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $aofnam]} {
				Inf "NO TIMESTRETCHED VERSION OF $msg_typ $n CREATED"
				set OK 0
				break
			}

			set wofnam $evv(MACH_OUTFNAME)XX$n$evv(SNDFILE_EXT)
			if {[file exists $wofnam] && [catch {file delete $wofnam} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE SOUNDFILE $wofnam : $zit"
				set OK2 0
				break
			}
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd synth $aofnam $wofnam
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF TIMESTRETCHED $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN WAVEFORM CREATION FOR TIMESTRETCHED $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE WAVEFORM OF TIMESTRETCHED $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $wofnam]} {
				Inf "NO WAVEFORM OF TIMESTRETCHED $msg_typ $n CREATED"
				set OK 0
				break
			}
			if {![DoSegmentDurParse $wofnam]} {
				Inf "FAILED TO FIND DURATION OF TIMESTRETCHED $msg_typ $n"
				set OK 0
				break
			}
			set tstrdur $segment(itemdur)

			;#	IF OUTPUT LONG ENOUGH TO CUT, CUT IT

			set cuttime [expr $outdur + $atktime]

			if {$tstrdur > $cuttime} {

				if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
					Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(othersnd) : $zit"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd cut 1 $wofnam $segment(othersnd) 0 $cuttime -w0		;#	Output will be enveloped, SO zero splicelen OK
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CUTTING TO SIZE TIMESTRETCHED $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN CUT-TO-SIZE PROCESS FOR TIMESTRETCHED $msg_typ $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE CUT-TO-SIZE TIMESTRETCHED $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $segment(othersnd)]} {
					Inf "NO CUT-TO-SIZE TIMESTRETCHED $msg_typ $n CREATED"
					set OK 0
					break
				}
				set jfnam $segment(othersnd)
				set envendtime $cuttime
			} else {
				set jfnam $wofnam	
				set envendtime $tstrdur
			}

			;#	CREATE POST-ENVELOPE FILE

			set envdata [CreateDecayEnvelope $atktime $envendtime $decaypow]

			if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE ENVELOPE FILE $segment(envfil) : $zit"
				set OK 0
				break
			}
			if [catch {open $segment(envfil) "w"} zit] {
				Inf "CANNOT OPEN ENVELOPE DATA FILE $segment(envfil) : $zit"
				set OK 0
				break
			}
			foreach line $envdata {
				puts $zit $line
			}
			close $zit

			;#	ENVELOPE THE OUTPUT

			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $jfnam $ofnam $segment(envfil)		;#	Output will be enveloped
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        ENVELOPING TIMESTRETCHED $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN ENVELOPING PROCESS FOR TIMESTRETCHED $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE ENVELOPED TIMESTRETCHED $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO ENVELOPED TIMESTRETCHED $msg_typ $n CREATED"
				set OK 0
				break
			}

			;#	IF "Untwang" RE-REVERSE SOUND

			if {$untwang} {

				if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
					Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(othersnd) : $zit"
					set OK 0
					break
				}
				if [catch {file rename $ofnam $segment(othersnd)} zit] {
					Inf "CANNOT RENAME OUTPUT FILE $ofnam, FOR SOUND REVERSAL: $zit"
					set OK 0
					break
				}

				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd radical 1 $segment(othersnd) $ofnam

				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker  "PLEASE WAIT:        RE-REVERSING $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN PROCESS TO RE-REVERSE $msg_typ $n"
					catch {unset CDPidrun}
					UnBlock
					return 0
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO RE-REVERSE $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					return 0
				}
				if {![file exists $ofnam]} {
					Inf "NO RE-REVERSED OUTFILE CREATED FOR $msg_typ $n"
					UnBlock
					return 0
				}
			}

			;#		PUT TWANGED-HEAD INTO MIXFILE

			catch {unset nulines}
			if {[MultipleProcessing]} {
				set line [lindex $segment(mixlines) $segment(recycline)]
				set line [lreplace $line 0 0 $ofnam]
				if {$untwang} {
					set ttime [lindex $line 1]
					set anacrulen [expr $envendtime - $segdur]
					set ttime [expr $ttime - $anacrulen]
					set line [lreplace $line 1 1 $ttime]
				}	
				set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
			} else {
				if {$untwang} {
					set anacrulen [expr $envendtime - $segdur]
					if {$n == 1} {
						set ttime [expr $leftbase - $anacrulen]
					} else {
						set ttime [expr $leftbase - $segment(SPLICE) - $anacrulen]
					}
					set line [list $ofnam $ttime 1 1.0]
				} else {
					set line [list $ofnam $leftbase 1 1.0]
				}
				lappend mixlines $line
			}
			set segment(noexpand,$noex) 1
			incr hno

		} else {		;#	A TAIL

			if {$segment(multiproccnt)} {
				if {[lindex $segment(actionlist) $n] == 0} {
					incr n									;#	IF no action required								
					incr noex								;#	IF no action required								
					incr j									;#	Skip to next segment
					incr k
					incr tno
					if {!$segment(phrase)} {				;#	Phrases always flagged as heads
						set ishead [expr !$ishead]
					}
					continue
				}
			}

			;#	IF TAIL IS TO BE FADED-UP

			if {$fadestart != 1.0} {

				if {[MultipleProcessing]} {
					if {![GetRecycledSegment $tno TAIL]} {
						set OK 0
						break
					}
					set ifnam $segment(iifnam)
				} else {
					set ifnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
				}
				set ofnam $evv(MACH_OUTFNAME)TF$tno$evv(SNDFILE_EXT)

				set OK2 1

				while {$OK2} {
					if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
						Inf "CANNOT DELETE PREVIOUS ENVELOPE FILE $segment(envfil) : $zit"
						set OK2 0
						break
					}
					if {![DoSegmentDurParse $ifnam]} {
						Inf "FAILED TO FIND DURATION OF TAIL $tcnt: CANNOT DO TAIL FADE"
						set OK2 0
						break
					}
					set taildur $segment(itemdur)
					catch {unset env}
					if {$fadexp != 1.0} {								;#				0.0  0.6   		raised	
						set line [list 0.0 $fadestart]					;#				  0.3  1.0		to pow		*diff	+fadestart
						lappend env $line								;# _____ 1		 _______		______		______		______
						set diff [expr 1.0 - $fadestart]				;#  |			       x			x						x
						set val [expr pow(0.333,$fadexp)]				;#	|			       x 		    x		   x		   xx
						set val [expr $val * $diff]						;#	|			     x  		   x	  	  xx		   x	
						set val [expr $val + $fadestart]				;# diff			     x             x		  x			  x 
						set line [list [expr $taildur * 0.3333] $val]	;#	|			   x			  x			 x			  x
						lappend env $line								;#	|			   x			  x		   	 x			x
						set val [expr pow(0.666,$fadexp)]				;# _|__fadestart x			   x		   x			x
						set val [expr $val * $diff]						;# _____ 0		_x________	   x______	   x______		______
						set val [expr $val + $fadestart]
						set line [list [expr $taildur * 0.6666] $val]
						lappend env $line
						set line [list $taildur 1.0]
						lappend env $line
					} else {
						set line [list 0.0 $fadestart]
						lappend env $line
						set line [list $taildur 1.0]
						lappend env $line
					}
					if {[catch {open $segment(envfil) "w"} zit]} {
						Inf "CANNOT OPEN ENVELOPE FILE TO CREATE UPFADE"
						set OK2 0
						break
					} else {
						foreach line $env {
							puts $zit $line
						}
						close $zit
					}
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $ifnam $ofnam $segment(envfil) 

					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        UPFADING SEGMENT $n"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN UPFADE OF SEGMENT $n"
						catch {unset CDPidrun}
						set OK2 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE UPFADING SEGMENT $n"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK2 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO UPFADING SEGMENT $n CREATED"
						set OK2 0
						break
					}
					break
				}
				if {!$OK2} {
					set ofnam $ifnam		;#	Use the non-upfaded tail
				}
				if {[MultipleProcessing]} {
					PhraseLineReinsert [expr $segment(recycline) + 1] $ofnam 0
				} else {
					set line [list $ofnam $leftbase 1 1.0]
					lappend mixlines $line
				}

			} else {

			;#	NO UPFADE: WITH MULTIPROC (MIXFILE ALREADY EXISTS) NO ACTION REQUIRED: 
			;#	BUT WITH SINGLE PROCESS INSERT THE TAIL IN THE MIXFILE,

				if {![MultipleProcessing]} {
					set ofnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
					set line [list $ofnam $leftbase 1 1.0]
					lappend mixlines $line
				}
			}
			incr tno
		}
		incr n
		incr noex
		incr j
		incr k
		if {!$segment(phrase)} {
			set ishead [expr !$ishead]
		}
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	}

	if {$untwang} {

		;#	DEAL WITH ANACRUSES STARTING AT A TIME BEFORE ZERO-TIME IN CURRENT MIX

		if {[MultipleProcessing]} {
			set mixlines $segment(mixlines)
		}
		set mintime 1000000
		foreach line $mixlines {
			set ttime [lindex $line 1]
			if {$ttime < $mintime} {
				set mintime $ttime
			}
		}
		if {$mintime < 0.0} {					;#	If any anacrusis starts prior to time zero,
			catch {unset nulines}				;#	push all timings of mixfile lines forward, so mix starts at time zero
			foreach line $mixlines {
				set ttime [lindex $line 1]
				set ttime [expr $ttime - $mintime]
				if {$ttime < 0.0} {				;#	Catch any arithmetic error
					set ttime 0.0
				}
				set line [lreplace $line 1 1 $ttime]
				lappend nulines $line
			}
			if {[MultipleProcessing]} {
				set segment(mixlines) $nulines
			} else {
				set mixlines $nulines
			}
		}
	}
	if {$segment(multiproccnt)} {				;#	With multiprocess, don't mix until all processes done
		UnBlock
		return 1
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)
	} else {
		set segment(mixlines) $mixlines
	}
	if {$segment(expand) && !$segment(noexpand)} {
		if {![ExpandPhraseMix 1]} {
			Inf "CANNOT EXPAND THE SEGMENT STRING AS REQUESTED"
		} else {
			set mixlines $segment(mixlines)
		}
	}	
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	;#	LEVEL ADJUSTING MIX

	if {![GettrofPossiblyMultichanMixdown 1]} {
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		set OK 0
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	return 1
}

#---- Create timewarping file for "Twang"
#
#	Add frametime to time of max sample	-> Y
#	Create twarp-file	0		1
#						Y		1
#						Y+0.003	p1		param-1 =  tstretch
#						endtime	p1
#

proc CreateTwarpData {maxtime endtime tstretch} {
	global segment
	set maxtime [expr $maxtime + $segment(frametime)]		;#	Add frame-duration to position of maxtime, to allow for PVOC delay
	set line [list 0 1]
	lappend lines $line
	set line [list $maxtime 1]								;#	No time-stretch up to this time		
	lappend lines $line
	set maxtime [expr $maxtime + 0.003]						;#	Advance by 0.03 and go to max stretch
	set line [list $maxtime $tstretch]
	lappend lines $line
	set line [list $endtime $tstretch]
	lappend lines $line
	return $lines
}
	
#---- Create Fade-envelope for "Twang"

proc CreateDecayEnvelope {starttime endtime atten} {
	global segment
	set duration [expr $endtime - $starttime]
	set timestep [expr $duration/$segment(envpoints)]
	set line [list 0 1]
	lappend lines $line
	set line [list $starttime 1]
	lappend lines $line
	set m 1
	set k 0
	while {$k < $segment(envpoints)} {
		set level [expr 1.0 - (double($m)/double($segment(envpoints)))]
		if {$level < 0.0} {
			set level 0.0
		}
		set level [expr pow($level,$atten)]
		if {[string first "e" $level] >= 0} {
			set level [ConvertVerySmallNumberENotationToNumeric $level]
		}
		set thistime [expr $starttime + ($timestep * $m)]
		if {$k == [expr $segment(envpoints) - 1]} {
			set line [list $endtime $level]
		} else {
			set line [list $thistime $level]
		}
		lappend lines $line
		incr m
		incr k
	}
	return $lines
}

#---- Get ALL maximum sample information

proc Get_Maxsamp_Info_Segment {} {
	global CDPmaxId done_maxsamp maxsamp_line

	if {[info exists CDPmaxId] && [eof $CDPmaxId]} {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match ERROR:* $line] {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} else {
			lappend maxsamp_line $line
			return
		}
	}
	update idletasks
}			

#--- Replace "e" notation of small numbers by pure numeric ("IsNumeric" does not recognise e-notation)

proc ConvertVerySmallNumberENotationToNumeric {str} {
	set epos [string first "e" $str]						;#		05.47e-007	0.47e-007
	set substr [string range $str 0 [expr $epos - 1]]		;#		05.47		0.47
	set substr [StripLeadingZeros $substr]					;#		 5.47		 .47
	set k $epos
	incr k 2
	set powstr [string range $str $k end]					;#		007			007
	set powstr [StripLeadingZerosFromInteger $powstr]		;#		  7			  7
	set val "0."											;#	val	0.			0.
	set zeros [expr $powstr - 1]										
	set zcnt 0
	while {$zcnt < $zeros} {
		append val "0"
		incr zcnt											;#	val	0.000000
	}
	if {[string match [string index $substr 0] "."]} {		;#		5.47		.47
		set zzz "0"											;#		5.47		0.47
		append zzz $substr
		set substr $zzz
	}
	set substr [split $substr "."]							;#		{5} {47}	{0} {47}
	append val [lindex $substr 0]							;#		0.0000005	0.0000000
	if {[llength $substr] > 1} {							;#		0,000000547	0.000000047
		append val [lindex $substr 1]
	}
	return $val
}

##########
# RETIME #
##########

#--- Entry of Preset params for retiming

proc RetimeStyle {} {
	global segment pr_retimstyl evv unretim retimnorm ocl tunehead tuneweighted pitchartic tv_active
	set f .retimstyl
	set segment(remotif) 0

	NumberOfSegmentsToBeRetimed

	if [Dlg_Create $f "PRESET PARAMETERS FOR RETIME" "set pr_retimstyl 0" -height 20 -borderwidth $evv(SBDR)] {

		label $f.00 -text "Enter TIMES by tapping Key or from MIDI keyboard" -width 50 -fg $evv(SPECIAL)
		pack $f.00 -side top -pady 2
		frame $f.0
		label $f.0.ll -text "$segment(tuningcnt) NOTES" -width 10
		button $f.0.s -text "Use Settings" -command "set pr_retimstyl 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_retimstyl 2" -width 18
		button $f.0.e -text "Export"	   -command "set pr_retimstyl 3" -width 10
		button $f.0.i -text "Import"	   -command "set pr_retimstyl 4" -width 10
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_retimstyl 0" -width 8
		pack $f.0.ll $f.0.s $f.0.s $f.0.s $f.0.l $f.0.e $f.0.i $f.0.h -side left -padx 2
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		frame $f.1.1
		button $f.1.1.times   -text "TAP\nTIMES\nHERE" -command "Timer" -width 10
		frame $f.1.1.1
		button $f.1.1.1.stop    -text "KEEP"  -width 5 -command {set pr_retimstyl [NuNuTimeCalc]}
		button $f.1.1.1.restart -text "AGAIN" -width 5 -command {set pr_retimstyl 6}
		pack $f.1.1.1.stop $f.1.1.1.restart -side left
		pack $f.1.1.times $f.1.1.1 -side top
		frame $f.1.2
		if {$tv_active} {
			GettrofMakeKeyboardKey $f.1.2
		}
		set tunehead 0
		set tuneweighted 1
		set pitchartic 1
		pack $f.1.1 $f.1.2 -side left -padx 4
		pack $f.1 -side top -pady 4

		GettrofResetRetimeCheckbuttons

		wm resizable $f 0 0
		bind $f <Return> {set pr_retimstyl 1}
		bind $f <Escape> {set pr_retimstyl 0}
	}
	.retimstyl.0.ll config -text "$segment(tuningcnt) NOTES"
	.retimstyl.1.1.times config -state normal -bg $evv(EMPH)
	.retimstyl.1.1.1.stop config -state normal
	.retimstyl.1.1.1.restart config -state disabled
	catch {unset segment(ocl)}
	set pr_retimstyl 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_retimstyl
	while {!$finished} {
		tkwait variable pr_retimstyl
		switch -- $pr_retimstyl {
			1 {
				if {![info exists segment(ocl)]} {
					Inf "NO TIMINGS ENTERED"
					continue
				}
				set len [llength $segment(ocl)]
				if {$len != $segment(tuningcnt)} {
					Inf "WRONG NUMBER OF NOTES ($len) : NEED $segment(tuningcnt)"
					continue
				}
				set segment(control1,RETIME) $segment(ocl)	;#	Stored as time-variable param, so it can be saved to a patch
															;#	but must NOT be accessible from Param Entry!!!!
				set segment(par0) $segment(retimestyle)		;#	Derived from entry-button in interface		
				set segment(PAR0) $segment(par0)			;#	None of these accessible on interface
				set segment(lastpar0,RETIME) $segment(par0)	;#	So also setup "lastpar" value here
				set segment(par1) $tunehead					;#	allowing params to be saved to file.
				set segment(PAR1) $segment(par1)
				set segment(lastpar1,RETIME) $segment(par1)
				set segment(par2) $tuneweighted
				set segment(PAR2) $segment(par2)
				set segment(lastpar2,RETIME) $segment(par2)
				set segment(par3) $pitchartic
				set segment(PAR3) $segment(par3)
				set segment(lastpar3,RETIME) $segment(par3)
				set finished 1
			}
			2 {									;#	GO TO LOAD A PATCH
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			3 {
				if {![info exists segment(ocl)]} {
					Inf "NO TIMINGS ENTERED"
					.retimstyl.1.1.times	 config -state normal -bg $evv(EMPH)
					.retimstyl.1.1.1.stop	 config -state normal
					.retimstyl.1.1.1.restart config -state disabled
					continue
				}
				set len [llength $segment(ocl)]
				if {$len != $segment(tuningcnt)} {
					Inf "WRONG NUMBER OF NOTES ($len) : NEED $segment(tuningcnt)"
					.retimstyl.1.1.times	 config -state normal -bg $evv(EMPH)
					.retimstyl.1.1.1.stop	 config -state normal
					.retimstyl.1.1.1.restart config -state disabled
					continue
				}
				ExportTroflist 0
			}
			4 {
				ImportTroflist
			}
			0 {									;#	ABANDON
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
			5 {									;#	TIME TAP, DATA FOUND
				if {[llength $ocl] != $segment(tuningcnt)} {
					Inf "WRONG NUMBER OF NOTES ([llength $ocl]) : NEED $segment(tuningcnt)"
					unset ocl
				} else {
					set segment(ocl) $ocl
					unset ocl
				}
				.retimstyl.1.1.1.restart config -state normal
			}
			6 {									;#	TIME TAP, RESET TO START AGAIN
				.retimstyl.1.1.times	 config -state normal -bg $evv(EMPH)
				.retimstyl.1.1.1.stop	 config -state normal
				.retimstyl.1.1.1.restart config -state disabled
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

proc GettrofResetRetimeCheckbuttons {} {
	global segment tunehead tuneweighted pitchartic tv_active

	.retimstyl.00 config -text "Enter TIMES by tapping Key or from MIDI keyboard" -width 50
	set tuneweighted	 0
	set tunehead		 0
	set pitchartic		 0
	if {$tv_active} {
		GettrofRetimeKbdBinding 0
	}
}

#--- Export and Import timing-sets held in textfiles to Voicebox RETIME

proc ExportTroflist {snack} {
	global segment snack_list pr_extrof extrofnam evv wstk chlist

	if {$snack} {
		set timeseq $snack_list
	} else {
		set timeseq $segment(ocl)
	}
	set f .extrof
	if [Dlg_Create $f "EXPORT SEGMENT TIMINGS" "set pr_extrof 0" -height 20 -borderwidth $evv(SBDR)] {

		frame $f.0
		button $f.0.x -text "Export"  -command "set pr_extrof 1" -width 8
		button $f.0.q -text "Abandon" -command "set pr_extrof 0" -width 8
		pack $f.0.x -side left
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Filename"
		entry $f.1.e -textvariable extrofnam -width 64
		pack $f.1.ll $f.1.e -side left -padx 4
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_extrof 1}
		bind $f <Escape> {set pr_extrof 0}
	}
	set extrofnam [file rootname [lindex $chlist 0]]
	set pr_extrof 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_extrof $f.1.e
	while {!$finished} {
		tkwait variable pr_extrof
		switch -- $pr_extrof {
			1 {
				if {[string length $extrofnam] <= 0} {
					Inf "NO FILENAME ENTERED"
					continue
				}
				set ofnam [string tolower $extrofnam]
				if {![ValidCDPRootname $ofnam]} {
					continue
				}
				append ofnam $evv(TEXT_EXT)
				if {[file exists $ofnam]} {
					set msg "FILE $extrofnam ALREADY EXISTS: OVERWRITE IT??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					if {![DeleteNonSndfileFromSystem $ofnam]} {
						continue
					}
				}
				if [catch {open $ofnam "w"} zit] {
					Inf "CANNOT OPEN FILE $extrofnam TO EXPORT SEGMENTATION DATA"
					continue
				}
				foreach time $timeseq {
					set time [string trim $time]
					if {([string length $time] <= 0) || ![IsNumeric $time]} {
						continue
					}
					puts $zit $time
				}
				close $zit
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "FILE $ofnam IS ON THE WORKSPACE"
				}
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc ImportTroflist {} {
	global segment pr_imptrof evv wstk pa wl
	set f .imptrof
	set k 0
	foreach fnam [$wl get 0 end] {
		if {[IsAListofNumbers $pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(MINNUM)) == 0.0) && ($pa($fnam,$evv(NUMSIZE)) >= $segment(tuningcnt))} {
			lappend fnams $fnam
			incr k
		}
	}
	if {$k <= 0} {
		Inf "NO TEXTFILES OF (POSSIBLE) TIMING DATA (OF SUFFICIENT LENGTH) FOUND ON WORKSPACE"
		return
	}
	if [Dlg_Create $f "IMPORT SEGMENT TIMINGS FROM TEXTFILE ON WORKSPACE" "set pr_imptrof 0" -height 20 -borderwidth $evv(SBDR)] {

		frame $f.0
		button $f.0.x -text "Import"  -command "set pr_imptrof 1" -width 8
		button $f.0.q -text "Abandon" -command "set pr_imptrof 0" -width 8
		pack $f.0.x -side left
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.tit -text "Possible Number Lists" -fg $evv(SPECIAL)
		Scrolled_Listbox $f.1.ll -width 120 -height 24 -selectmode single
		pack $f.1.tit $f.1.ll -side top -pady 2
		pack $f.1 -side top -pady 2 -fill x -expand true
		wm resizable $f 0 0
		bind $f <Return> {set pr_imptrof 1}
		bind $f <Escape> {set pr_imptrof 0}
	}
	$f.1.ll.list delete 0 end
	foreach fnam $fnams {
		$f.1.ll.list insert end $fnam
	}
	set pr_imptrof 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_imptrof $f.1.ll.list
	while {!$finished} {
		tkwait variable pr_imptrof
		switch -- $pr_imptrof {
			1 {
				if {$k == 1} {
					set fnam [$f.1.ll.list get 0]
				} else {
					set i [$f.1.ll.list curselection]
					if {$i < 0} {							
						Inf "NO ITEM(S) SELECTED"
						continue
					}
					set fnam [$f.1.ll.list get $i]
				}
				if [catch {open $fnam "r"} zit] {
					Inf "CANNOT OPEN FILE $fnam TO READ THE DATA"
					continue
				}
				set cnt 0
				set OK 1
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					set line [split $line]
					foreach time $line {
						set time [string trim $time]
						if {[string length $time] <= 0} {
							continue
						}
						if {![IsNumeric $time]} {
							Inf "INVALID DATA ($time) IN FILE $fnam"
							set OK 0
							break
						}
						if {$cnt == 0} {
							if {$time != 0.0} {
								Inf "VALUES IN FILE $fnam DO NOT BEGIN AT 0.0"
								set OK 0
								break
							}
							set lasttime $time
						} elseif {$time <= $lasttime} {
							Inf "VALUES ($lasttime $time) IN FILE $fnam DO NOT INCREASE"
							set OK 0
							break
						}
						lappend times $time
						incr cnt
					}
					if {!$OK} {
						break
					}
				}
				close $zit
				if {!$OK} {
					continue
				}
				if {$cnt > $segment(tuningcnt)} {
					set msg "TOO MANY TIMES ($cnt) IN FILE $fnam : KEEP THE FIRST $segment(tuningcnt) ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					} else {
						set endd [expr $segment(tuningcnt) - 1]
						set times [lrange $times 0 $endd]
					}
				}
				set segment(ocl) $times
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Massage Timing Data entered by Clicking on on-screen Pad

proc NuNuTimeCalc {} {
	global ocl segment evv shrhy

	if {[info exists shrhy(kbd)]} {
		.shrhy.1.1.times config -state disabled -bg [option get . background {}]
		.shrhy.1.1.1.stop  config -state disabled
	} else {
		.retimstyl.1.1.times config -state disabled -bg [option get . background {}]
		.retimstyl.1.1.1.stop  config -state disabled
	}
	if {![info exists ocl] || ([llength $ocl] <= 0)} {
		Inf "NO TIMES ENTERED"
		return 3
	}
	set n 0
	if {![info exists shrhy(kbd)] && $segment(remotif)} {
		catch {unset nuocl}
		set line [lindex $ocl 0]
		set time [lindex $line 0]
		set baseval [expr double($time) / $evv(CLOCK_TICK)]
		foreach line $ocl {
			set time [lindex $line 0]
			set time [expr (double($time) / $evv(CLOCK_TICK)) - $baseval]
			if {$time < 0.0} {
				set time 0.0			;#	Catch any arithmetic error
			}
			set line [lreplace $line 0 0 $time]
			lappend nuocl $line
			incr n
		}
		set ocl $nuocl
	} else {
		set baseval [expr double([lindex $ocl 0]) / $evv(CLOCK_TICK)]
		foreach time $ocl {
			set time [expr (double($time) / $evv(CLOCK_TICK)) - $baseval]
			set ocl [lreplace $ocl $n $n $time]
			incr n
		}
	}
	set ocl [lreplace $ocl 0 0 0.0]
	return 5
}

#--- Switches MIDI-Kbd entry between getting TIMINGS amd getting MOTIF

proc GettrofRetimeKbdBinding {motif} {

	set f .retimstyl.1.2

	bind $f.0   <ButtonPress-1> {}
	bind $f.1.0 <ButtonPress-1> {}
	bind $f.1.1 <ButtonPress-1> {}
	bind $f.1.2 <ButtonPress-1> {}
	bind $f.1.3 <ButtonPress-1> {}
	bind $f.1.4 <ButtonPress-1> {}
	bind $f.1.5 <ButtonPress-1> {}
	bind $f.1.6 <ButtonPress-1> {}
	bind $f.2.0 <ButtonPress-1> {}
	bind $f.2.1 <ButtonPress-1> {}
	bind $f.2.2 <ButtonPress-1> {}
	bind $f.2.3 <ButtonPress-1> {}
	bind $f.2.4 <ButtonPress-1> {}
	bind $f.2.5 <ButtonPress-1> {}
	bind $f.2.6 <ButtonPress-1> {}
	bind $f.3   <ButtonPress-1> {}

	if {$motif} {

		bind $f.0   <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.0 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.1 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.2 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.3 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.4 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.5 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.1.6 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.0 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.1 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.2 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.3 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.4 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.5 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.2.6 <ButtonPress-1> "GettrofGetNoteData 3 $f"
		bind $f.3   <ButtonPress-1> "GettrofGetNoteData 3 $f"

	} else {

		bind $f.0   <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.0 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.1 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.2 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.3 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.4 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.5 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.1.6 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.0 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.1 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.2 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.3 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.4 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.5 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.2.6 <ButtonPress-1> "GettrofGetNoteData 2 $f"
		bind $f.3   <ButtonPress-1> "GettrofGetNoteData 2 $f"
	}
}

#---- How many times we need to retime the file, which may be outcome of previous processes where HEads are duplicated, or merged-with-tails
#
#	Calculations in Gettrof_Retime assume the ORIGINAL segment(cnt) of the file, before processing.
#	It then retimes data at Heads (Tails simply following Heads as before),
#	and works out what to do if Heads are missing, or duplicated.
#	So count Heads and, if Tail first (also timed) add 1


proc NumberOfSegmentsToBeRetimed {} {
	global segment
	if {$segment(phrase)} {
		set segment(tuningcnt) $segment(cnt)						;#	All phrases are Heads
	} else {
		set segment(tuningcnt) [expr $segment(cnt)/2]				;#	T H T H T H		tail 1st segs even	segcnt 6 hcnt 6/2	  = 3 + firstseg(tail) = 4
		if {$segment(headfirst) && ![IsEven $segment(cnt)]} {		;#	H T H T H T		head 1st segs even	segcnt 6 hcnt 6/2	  = 3	
			incr segment(tuningcnt)									;#	T H T H T		tail 1st segs odd	segcnt 5 hcnt 5/2	  = 2 + firstseg(tail) = 3
		}															;#	H T H T H		head 1st segs odd	segcnt 5 hcnt 5/2 + 1 = 3
		if {!$segment(headfirst)} {
			incr segment(tuningcnt)									;#	T H T H T H		= 3 Heads + firstseg(tail) = 4
		}															;#	T H T H T		= 2 Heads + firstseg(tail) = 3
	}
}

#--- Retiming the Data

proc Gettrof_Retime {} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages

	set typ		 $segment(PAR0)		;#	shrink, stretch, cut ?
	set tunehead $segment(PAR1)		;#	if altering pitch, tune head
	set weighted $segment(PAR2)		;#	if altering pitch, consider pitched window amplitudes when assessing pitch-median
	set artic	 $segment(PAR3)		;#	retain original pitch-artics (otherwise flatten output pitch)

	;#	Extended final val in marklist, replaced by true end of file

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

	set ismultichan 0
	if {![info exists segment(mixlines)]} {
		set retime_only 1
		CreateSegmentMixfile $marks
	} else {
		set retime_only 0
		if {[llength [lindex $segment(mixlines) 0]] < 4} {
			set ismultichan 1
		}
	}
	RemoveTemporaryFilesNotinMixlist

	set segment(multiproccnt) 0

	;#	PARAMS FOR READING CONTROL FILES

	set n 1
	while {$n <= $segment(vparams_cnt,$segment(process))} {
		if {[info exists segment(control$n,RETIME)]} {
			set segment(zlim,$n) [expr [llength $segment(control$n,RETIME)] - 1]
			set segment(zccnt,$n) 0
		}
		incr n
	}

	;#	PROCESSING PARAMS FOR WHILE-LOOP

	ClearNoexpands												;#	Clear all flags relating to mixfile lines being immovable

	set segment(origmixlines) $segment(mixlines)				;#	Store existing mixlines, in case we need to baktrak

	if {$segment(phrase)} {
		set msg_typ	"PHRASE"
	} else {
		set msg_typ	"SEGMENT"
	}
	set msg "RETIMING "
	append msg $msg_typ S 
	Block "$msg"

	if {$segment(phrase) || $segment(headfirst)} {
		set ishead 1
	} else {
		set ishead 0
	}
	set n 1		;#	Index for first head segment to stack is 1 (segments count from 1)
	set j 0		;#	Indices for new start times of segments
	set hno 1	;#	Index of 1st HEAD file (headfile names are indexed from 1)
	set tno 1	;#	Index of 1st TAIL file (tailfile names are indexed from 1)

	set OK 1
	catch {unset segment(recycline)}
	set hrecycline 0
	set duplhdlineno -1
	set duplstep 0
	set tail_absorbed_head 0							;#	These processes NOT ACCESSIBLE in "Phrase" mode
	set lastretimed {}

	while {$n <= $segment(cnt)} {

		if {$ishead} {
			set tail_absorbed_head 0

		;#	FIND RELEVANT MIXFILE LINES

			set heads [FindRelevantHeadFileForRetimeAndVerges $hno]
			set ffnam			   [lindex $heads 0]
			set segment(recycline) [lindex $heads 1]
			set duplhdlineno	   [lindex $heads 2]
			if {$segment(recycline) < 0} {				;#	HEAD has been absorbed in Tail by a retune process with "Tune Heads" option
				set tail_absorbed_head 1
				set heads [FindRelevantTailFileForRetime $tno]
				set ffnam			   [lindex $heads 0]
				set segment(recycline) [lindex $heads 1]
				set duplhdlineno	   [lindex $heads 2]
			}
			if {$segment(phrase)} {

			;#	FIND NEXT HEAD FILE
	
				if {$n < $segment(cnt)} {
					set hhno [expr $hno + 1]
					set heads [FindRelevantHeadFileForRetimeAndVerges $hhno]
					set segment(nextline) [lindex $heads 1]
				}

			} else {

				;#	FIND NEXT TAIL FILE
	
				if {$n < $segment(cnt)} {
					if {$tail_absorbed_head} {
						set segment(nextline) $segment(recycline)
					} else {
						set tails [FindRelevantTailFileForRetime $tno]
						set segment(nextline) [lindex $tails 1]
					}
				}

				;#	FIND NEXT HEAD FILE
		
				if {$n < [expr $segment(cnt) - 1]} {
					set hhno [expr $hno + 1]
					set ttno [expr $tno + 1]
					set heads [FindRelevantHeadFileForRetimeAndVerges $hhno]
					set segment(nextnextline) [lindex $heads 1]
					if {$segment(nextnextline) < 0} {						;#	If no Following HEAD exists, could have been merged with its tail
						set heads [FindRelevantTailFileForRetime $ttno]		;#	so look for a TAIL
						set segment(nextnextline) [lindex $heads 1]
					}
				}
			}

		} else {

			;#	FIND RELEVANT TAIL FILE

			set tails [FindRelevantTailFileForRetime $tno]
			set ffnam [lindex $tails 0]
			set segment(recycline) [lindex $tails 1]

			if {$n == 1} {													;#	If at FIRST tail, need to know where next HEAD is
				set heads [FindRelevantHeadFileForRetimeAndVerges $hno]
				set segment(nextline) [lindex $heads 1]
				if {$segment(nextline) < 0} {								;#	If no Following HEAD exists, could have been merged with its tail, so look for a TAIL
					set heads [FindRelevantTailFileForRetime [expr $tno + 1]]
					set segment(nextline) [lindex $heads 1]
				}
			}
		}
		if {[lsearch $lastretimed $ffnam] >= 0} {
			if {$segment(phrase)} {
				incr hno
			} else {
				if {$ishead} {
					incr hno
				} else {
					incr tno
				}
				set ishead [expr !$ishead]
			}
			incr n
			incr j
			continue
		}
		lappend lastretimed $ffnam


			;#	GET NEW TIMING : (AT START, AND AT EACH HEAD)

		set q -1						;#	n=	1 2 3 4
		if {$n == 1} {					;#		T H T H
			set q 0						;#  hcnt  1   2
		} elseif {$ishead} {			;#	q   0 1   2
			set q $hno					;#
			if {$segment(headfirst)} {	;#	n=	1 2 3 4
				incr q -1				;#		H T H T	(headfirst)
			}							;#	hcnt1   2
		}								;#	q   0   1
		if {$q >= 0} {
			set thistim [lindex $segment(control1,RETIME) $q]		;#	either {t} {t} {t} {t} OR {t p} {t p} {t p} {t p} 
			set thisthistim $thistim
		}
			;#	RETIME EXISTING MIXLINE, OR CREATE NEW MIXLINE WITH NEW TIMINGS; NOTE ORIGINAL & NEW STEP BETWEEN FILES

		if {$segment(recycline) >= 0}  {		;#	HEREH ????? COULD IT NOT BE SO ????
			set line [lindex $segment(mixlines) $segment(recycline)]
		}

		if {$segment(phrase)} {

			set oldtime [lindex $line 1]

			;#	RETIME PHRASE

			if {$duplhdlineno >= 0} {
				set duplheadline [lindex $segment(mixlines) $duplhdlineno]
				set mainheadtime [lindex $line 1]
				set duplheadtime [lindex $duplheadline 1]
				set duplstep [expr $duplheadtime - $mainheadtime]

				;#	IF ORDER OF DUPLICATE HEADS is HH-PH (TEXTURE) : MIX TOGETHER AND REPLACE BY new PH AT LINE OF HH & retime it (Removing original PH line)

				if {$duplstep >= 0.0} {
					if {![ReplaceDuplicateHeadsInPhraseBySingleHeadAndRetime $duplhdlineno $ismultichan $thistim $n]} {
						set OK 0
						break
					}
					;#	REPLACE FILE WE'RE WORKING ON BY MERGED HEAD-DUPLHEAD

					set ffnam [lindex [lindex $segment(mixlines) $segment(recycline)] 0]	
					set duplhdlineno -1

				} else {

				;#	IF ORDER IS PH-HH WE PROCESS PH LINE LATER AND MOVE THE HH & PH LINES HERE

					set line [lreplace $line 1 1 $thistim]
					set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
					set duplheadline [lreplace $duplheadline 1 1 [expr $thistim + $duplstep]]
					set segment(mixlines) [lreplace $segment(mixlines) $duplhdlineno $duplhdlineno $duplheadline]
				}
			} else {
				set duplstep 0
				set line [lreplace $line 1 1 $thistim]
				set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
			}

			;#	FIND ORIGINAL STEP TO NEXT PHRASE

			if {$n < $segment(cnt)} {
				set nextline [lindex $segment(mixlines) $segment(nextline)]
				set oldnexttime [lindex $nextline 1]
				set oldstep [expr $oldnexttime - $oldtime]
			}				

			;#	FIND DURATION OF PHRASE

			if {$typ == "OVERLAP"} {
				set dur 0				;#	Dummy val : "dur" not needed with this typ
			} else {
				if {![DoSegmentDurParse $ffnam]} {
					Inf "FAILED TO FIND DURATION OF PHRASE $n: CANNOT DO RETIMING"
					set OK 0
					break
				}
				set dur $segment(itemdur)
			}
			if {$n != $segment(cnt)} {
				set seginf [list $ffnam $segment(recycline) $duplhdlineno -1 $dur $oldstep $duplstep 0 ]
				lappend seginfo $seginf 
			}

		} else {

			;# NEED TO PAIR UP HEAD-TAIL, BUT NOT INITIAL TAIL

			if {$ishead} {

				if {$segment(recycline) < 0}  {												;#	(If HEAD does not exist,ignore retiming of HEAD)
					set nutailtim $thistim													;#	TAIL (which incorporates head) will be placed at "thistim"
					set HtoTstep 0.0
				} else {
					set oldtime [lindex $line 1]
					if {$n < [expr $segment(cnt) - 1]} {									;#		H.......T.......H.......T.......H.......
						set nextline [lindex $segment(mixlines) $segment(nextnextline)]		;#	n=	1 ...						  segcnt
						set oldnexttime [lindex $nextline 1]								;#							segcnt-1
						set oldstep [expr $oldnexttime - $oldtime]							;#						HtoTstep
					}																		;#						|------|
					if {$n < $segment(cnt)} {												;#		H.......T.......H.......T.......H.......				
						set nextline [lindex $segment(mixlines) $segment(nextline)]			;#								HtoTstep
						set oldnexttime [lindex $nextline 1]								;#								|------|
						set HtoTstep [expr $oldnexttime - $oldtime]							;#		T.......H.......T.......H.......T.......
					}
					if {$duplhdlineno >= 0} {
						set duplheadline [lindex $segment(mixlines) $duplhdlineno]
						set mainheadtime [lindex $line 1]
						set duplheadtime [lindex $duplheadline 1]
						set duplstep [expr $duplheadtime - $mainheadtime]
					} else {
						set duplstep 0
					}	
					set line [lreplace $line 1 1 $thistim]
					set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
					if {$duplhdlineno >= 0} {
						set duplheadline [lreplace $duplheadline 1 1 [expr $thistim + $duplstep]]
						set segment(mixlines) [lreplace $segment(mixlines) $duplhdlineno $duplhdlineno $duplheadline]
						lappend lastretimed [lindex $duplheadline 0]
					}
					set hrecycline $segment(recycline)

					set nutailtim [expr $thistim + $HtoTstep]								;#	Following tail derives time from displacement of this Head	
																							;#	retaining orig distance from Head
				}
			} else {

				if {$tail_absorbed_head} {
					set HtoTstep 0
				}
				if {$n == 1} {																;#	Line 1 remains at time zero - no need to retime it.
					set nextline [lindex $segment(mixlines) $segment(nextline)]				;#		|------| = oldstep
					set oldnexttime [lindex $nextline 1]									;#		T.......H.......T.......H.......T.......
					set oldstep $oldnexttime												;#	n=	1 ...
					set HtoTstep 0
				} else {																	;#	Otherwise there must be a preceding Head, which establishes	"nutailtim"
					set line [lreplace $line 1 1 $nutailtim]								
					set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline) $line]
				}

				if {$typ == "OVERLAP"} {
					set dur 0				;#	Dummy val : "dur" not needed with this typ
				} else {
					if {![DoSegmentDurParse $ffnam]} {
						Inf "FAILED TO FIND DURATION OF SEGMENT $n ($ffnam) : CANNOT DO RETIMING"
						set OK 0
						break
					}
					set dur $segment(itemdur)
				}
				if {($n == $segment(cnt))} {
					if {[GettrofTailAtEnd]} {
						set seginf [list $ffnam $segment(recycline) $duplhdlineno $hrecycline $dur END $duplstep $HtoTstep]
						lappend seginfo $seginf 
					}
				} else {
					set seginf [list $ffnam $segment(recycline) $duplhdlineno $hrecycline $dur $oldstep $duplstep $HtoTstep]
					lappend seginfo $seginf 
				}
			}
		}
		if {$ishead & ($n > 1)} {
			lappend newsteps [expr $thisthistim - $lasttim]
		}

		if {($n == 1) || $ishead} {
			set lasttim $thisthistim
		}
		if {$segment(phrase)} {
			incr hno
		} else {
			if {$ishead} {
				incr hno
			} else {
				incr tno
			}
			set ishead [expr !$ishead]
		}
		incr n
		incr j
	}
	if {!$OK} {
		UnBlock
		return 0
	}

	;# newstep (to next H)			|1|  2|  3|		|1|  2|  3|			|  1|  2|		|  1|  2|  3|
	;# (from start or last  H)		T H T H	T H		T H	T H	T H	T		H T	H T	H T		H T	H T	H T H
	;# seginf (at T but NOT at end)	|1| 2|  3|		|1| 2|  3| X		| 1|  2| X		| 1|  2|  3|
	;# NB Tail at END will not be stretched/shrunk/cut
	;#								T H T H	T H		T H	T H	T H	T		H T	H T	H T		H T	H T	H T H
	;#(s = stretched : > = moved)	s >	s >	s >		s >	s >	s >			  s > s	>		  s > s > s >

	catch {unset nuseginfo}
	foreach seginf $seginfo newstep $newsteps {
		lappend seginf $newstep
		lappend nuseginfo $seginf
	}
	set seginfo $nuseginfo
	set lastduplhdline -1

	while {$OK} {
		if {$typ != "OVERLAP"} {
			set docut 0
			set doshrink 0
			set dostretch 0
			set n 0
			set m 1
			set len [llength $seginfo]
			catch {unset failmsgs}
			while {$n < $len} {
				set seginf     [lindex $seginfo $n]
				set ifnam	   [lindex $seginf 0]
				set trecycline [lindex $seginf 1]
				set duplhdline [lindex $seginf 2]
				set hrecycline [lindex $seginf 3]
				set dur		   [lindex $seginf 4]
				set oldstep    [lindex $seginf 5]
				set duplstep   [lindex $seginf 6]
				set HtoTstep   [lindex $seginf 7]
				set newstep    [lindex $seginf 8]
				if {$oldstep == "END"} {
					break
				}
				set ofnam [GenerateRetimeOutfnamFromInfnam $ifnam]
				set taillen    [expr $oldstep - $HtoTstep]
				set stepchange [expr $newstep - $oldstep]							;#	Find change in step between Head segments
				if {$m < $len} {
					set nextduplhdline [lindex [lindex $seginfo $m] 2]
					set nextduplstep [lindex [lindex $seginfo $m] 6]
				} else {
					set nextduplhdline -1
					set nextduplstep 0
				}
				set	htmerged 0
				set changed 0
				if {$typ == "CUT"} {
					set newtaillen [expr $taillen + $stepchange]						;#	Calc new length of taillen required	
					if {$stepchange < 0.0} {											;#	Only cut if step change is -ve
						set changed 1
						set docut 1
						if {$newtaillen <= $segment(SPLICE)} {							;#	If new tail would be too short, merge it with head and cut HT-combo
							if {$segment(phrase)} {
								set qmsg "SEGMENT $ifnam CANNOT BE SHRUNK"
								lappend failmsgs $qmsg
								incr n
								continue
							} elseif {$trecycline == 0} {
								set qmsg "INITIAL SEGMENT CANNOT BE SHRUNK"
								lappend failmsgs $qmsg
								incr n
								continue
							} else {
								set qmsg "JOINED HEAD [lindex [lindex $segment(mixlines) $hrecycline] 0] && TAIL [lindex [lindex $segment(mixlines) $trecycline] 0] "
								lappend failmsgs $qmsg
							}
							if {![MergeHeadAndTail_forRetime $n $hrecycline $trecycline $ifnam]} {
								set OK 0
								break
							}
							set newtaillen [expr $newtaillen + $HtoTstep]
							set htmerged 1
						}

						;#	DO CUTTING

						if {$docut} {
							if {![DoSegmentDurParse $ifnam]} {
								set OK 0
								break
							}
							if {$segment(itemdur) <= $segment(SPLICE)} {
								set qmsg "$ifnam WAS TOO SHORT TO CUT TO SIZE\n"
								lapend failmsgs $qmsg
								incr n
								continue
							} elseif {$segment(itemdur) <= $newtaillen} {				;#	If item shorter than new tailgap, don't attempt to cut
								set changed 0
							} else {
								if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
									Inf "CANNOT DELETE PREVIOUS FILE $ofnam : $zit"
									set OK 0
									break
								}
								set cmd [file join $evv(CDPROGRAM_DIR) envel]
								lappend cmd curtail 1 $ifnam $ofnam [expr $newtaillen - $segment(SPLICE)] $newtaillen 0 -t0
								set prg_dun 0
								set prg_abortd 0
								catch {unset simple_program_messages}
								wm title .blocker "PLEASE WAIT:        CUTTING SEGMENT $n TO SIZE"
								if [catch {open "|$cmd"} CDPidrun] {
									ErrShow "FAILED IN CUT PROCESS FOR SEGMENT $n"
									catch {unset CDPidrun}
									set OK 0
									break
								} else {
									fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
								}
								vwait prg_dun
								if {$prg_abortd} {
									set prg_dun 0
								}
								if {!$prg_dun} {
									set msg "FAILED TO CREATE CUT SEGMENT $n"
									set msg [AddSimpleMessages $msg]
									ErrShow $msg
									set OK 0
									break
								}
								if {![file exists $ofnam]} {
									Inf "NO CUT SEGMENT $n CREATED"
									set OK 0
									break
								}
							}

						;#	IF THE NEXT HT PAIR HAS A DUPLICATE HEAD + DUPLICATE HEAD FALLS BEFORE TRUE HEAD
						;#	CUT IT SHORTER AND MOVE START TO START IF TAIL


			;#	IF DUPLICATE HEAD AND ORDER is PH-HH (BOUNCE without Bounceover) = PREHEAD

							if {($nextduplhdline >= 0) && ($nextduplstep < 0.0)} {
								set nexthxline [lindex $segment(mixlines) $nextduplhdline]
								set nextfnam [lindex $nexthxline 0]
								set nexthtim [lindex $nexthxline 1]
								set heretime [lindex [lindex $segment(mixlines) $trecycline] 1]

								set nextcut [expr $heretime - $nexthtim]
								if {$nextcut > 0.0} {									;#	If next- pre-head now falls BEFORE current event
									if {[DoSegmentDurParse $nextfnam]} {
										set cutlen [expr $segment(itemdur) - $nextcut]	;#	Required new duration of pre-head

										if {$cutlen <= $segment(SPLICE)} {				;#	If it would be too short to cut, delete it

											set segment(mixlines) [lreplace $segment(mixlines) $nextduplhdline $nextduplhdline]

										} else {
											set zxfnam [file rootname $nextfnam]		;#	Else Shorten pre-head to fall within preceding tail
											append zxfnam "_x" $evv(SNDFILE_EXT)
											if {[file exists $zxfnam] && [catch {file delete $zxfnam} zit]} {
												Inf "CANNOT DELETE INTERMEDIATE FILE $zxfnam : $zit"
												set OK 0
												break
											}
											set cmd [file join $evv(CDPROGRAM_DIR) envel]
											lappend cmd curtail 1 $nextfnam $zxfnam [expr $cutlen - $segment(SPLICE)] $cutlen 0 -t0
											set prg_dun 0
											set prg_abortd 0
											catch {unset simple_program_messages}
											wm title .blocker "PLEASE WAIT:        CUTTING PRE-HEAD SEGMENT $n TO SIZE"
											if [catch {open "|$cmd"} CDPidrun] {
												ErrShow "FAILED IN CUT PROCESS FOR PRE-HEAD SEGMENT $n"
												catch {unset CDPidrun}
												set OK 0
												break
											} else {
												fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
											}
											vwait prg_dun
											if {$prg_abortd} {
												set prg_dun 0
											}
											if {!$prg_dun} {
												set msg "FAILED TO CREATE CUT PRE-HEAD SEGMENT $n"
												set msg [AddSimpleMessages $msg]
												ErrShow $msg
												set OK 0
												break
											}
											if {![file exists $zxfnam]} {
												Inf "NO PRE-HEAD CUT SEGMENT $n CREATED"
												set OK 0
												break
											}											;#	Move its start time appropriately
											set nexthtim [expr $nexthtim + $nextcut]
											set nexthxline [lreplace $nexthxline 0 1 $zxfnam $nexthtim]
											set segment(mixlines) [lreplace $segment(mixlines) $nextduplhdline $nextduplhdline $nexthxline]
										}
									}
								}
							}
						}
					}

				;#	SHRINK AND STRETCH TYPES

				} else {																	;#	If Shrink-if-ness OR Shrink-&-Stretch and stepchange < 0 : use TSTRETCH
																							;#	If Shrink-&-Stretch && stepchange > 0 : use TSTRETCH
					if {($stepchange < 0.0) || (($typ == "STRETCH") && ($stepchange > 0.0))} {

						set changed 1

							;#	ESTABLISH TIMESTRETCH RATIO	AND NEW TAILLEN

						set strratio [expr ($newstep + $segment(SPLICE))/($oldstep + $segment(SPLICE))]				;#	With a Duplicate Head preceding following Head (as in Bounce)
						if {$strratio > $segment(maxstretch)} {														;#	Tail len is less
							set strratio $segment(maxstretch)														;#		|--------taillen--------|
						}																							;#	H	T	(dH)				H
						if {!$segment(phrase) && ![LineIsTailAtStartOfMix $trecycline] && ($nextduplstep < 0.0)} {	;#		|TRUE|-----duplstep-----|
							set taillen [expr $taillen + $nextduplstep]												;#		|tail|
						}																							;#		| len|
						set newtaillen [expr $taillen * $strratio]

						if {$newtaillen <= $segment(TWOSPLICE)} {							;#	If new tail would be too short, merge it with head and shrink HT-combo
							if {$segment(phrase)} {
								set qmsg "SEGMENT $ifnam CANNOT BE SHRUNK"
								lappend failmsgs $qmsg
								incr n
								continue
							} elseif {($ismultichan && ($trecycline == 1)) || (!$ismultichan && ($trecycline == 0))} {
								set qmsg "INITIAL SEGMENT CANNOT BE SHRUNK"
								lappend failmsgs $qmsg
								incr n
								continue
							} else {
								set qmsg "JOINED HEAD [lindex [lindex $segment(mixlines) $hrecycline] 0] && TAIL [lindex [lindex $segment(mixlines) $trecycline] 0] "
								lappend failmsgs $qmsg
							}
							;#	IF TAIL TOO SHORT, MERGE HEAD+TAIL

							if {![MergeHeadAndTail_forRetime $n $hrecycline $trecycline $ifnam]} {
								set OK 0
								break
							}
							set newtaillen [expr $newtaillen + $HtoTstep]
							set htmerged 1

						}
						set strrationum $strratio
						if {$strratio < 1.0} {
							if {[DoSegmentDurParse $ifnam]} {								;#	If existing Tail (or H+T) is too short to shrink, skip
								if {$segment(itemdur) <= $segment(TWOSPLICE)} {
									set qmsg "$ifnam WAS TOO SHORT TO SHRINK TO SIZE\n"
									lappend failmsgs $qmsg
									incr n
									continue
								}
							}
							set strratio [expr ($newtaillen + $segment(SPLICE))/$dur]
						} else {															;#	Avoid stretching initial up-splice
							catch {unset env}
							set strratio [expr $newtaillen/($dur - $segment(SPLICE))]
							if {$strratio > $segment(maxstretch)} {
								set strratio $segment(maxstretch)							;#	Timestretch limited to speech-plausible
							}
							set eline [list 0.0 1]
							lappend env $eline
							set eline [list $segment(SPLICE) 1]
							lappend env $eline
							set eline [list [expr $segment(SPLICE) + $evv(FLTERR)] $strratio]
							lappend env $eline
							set eline [list 10000 $strratio]
							lappend env $eline
							if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
								Inf "CANNOT DELETE INTERMEDIATE TIMESTRETCH-DATA FILE $segment(envfil) : $zit"
								set OK 0
								break
							}
							if [catch {open $segment(envfil) "w"} zit] {
								Inf "CANNOT CREATE TIMESTRETCH-DATA FILE $segment(envfil) : $zit"
								set OK 0
								break
							}
							foreach line $env {
								puts $zit $line
							}
							close $zit
							set strratio $segment(envfil)
						}
							;#	PREPARE TO TIMESTRETCH/SHRINK

						set ofnama [file rootname $ofnam]
						append ofnama $evv(ANALFILE_EXT)
		
						if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
							Inf "CANNOT DELETE INTERMEDIATE SOUNDFILE $segment(fadesnd) : $zit"
							set OK 0
							break
						}

						;#	GET SPECTRUM OF TAIL (OR MERGED HEAD+TAIL)

						set thischans [lindex [lindex $segment(mixlines) $trecycline] 2]
						catch {unset segment(innams)}
						catch {unset segment(ofnamxs)}
						if {$thischans == 1} {
							set segment(innams) $ifnam
						} else {
							if {![RetimeSplitToMonoChans $ifnam $thischans]} {
								set OK 0
								break
							}
						}

						;#	TIMESTRETCH MONO FILES

						set zn 1
						foreach zifnam $segment(innams) {
							if {![GettrofRetimeTstretch $zifnam $ofnama $zn $thischans $strratio]} {
								set OK 0
								break
							}
							incr zn
						}
						if {$thischans > 1} {

							;#	IF SRC NOT MONO, MERGE TIMESTRETCHED CHANNELS

							if {![GettrofMergeTstretchedChans $ifnam]} {
								set OK 0
								break
							}
						}
				
						;#	DOVETAIL OUTPUT

						if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
							Inf "CANNOT DELETE PREVIOUS FILE $ofnam : $zit"
							set OK 0
							break
						}
						if {![DovetailRetimeOutput $segment(fadesnd) $ofnam $strratio]} { 
							set OK 0
							break
						}

						;#	IF THE NEXT HT PAIR HAS A DUPLICATE HEAD + DUPLICATE HEAD FALLS BEFORE TRUE HEAD, DO APPROPRIATE TIME-STRETCH/SHRINK

						if {($nextduplhdline >= 0) && ($nextduplstep < 0.0)} {
							set nexthxline [lindex $segment(mixlines) $nextduplhdline]
							set nextfnam  [lindex $nexthxline 0]
							set nexthtim  [lindex $nexthxline 1]
							set nextchans [lindex $nexthxline 2]
							set heretime [lindex [lindex $segment(mixlines) $trecycline] 1]

						;#	FIND LENGTH WHEN IT IS SHRUNK OR STRETCHED

							if {[DoSegmentDurParse $nextfnam]} {

								set cutlen [expr $segment(itemdur) - $segment(SPLICE)]		;#	Required new duration of pre-head
								set cutlen [expr $cutlen * $strrationum]					;#	Avoid stretching splices at start of DUPLHEAD
								set cutlen [expr $cutlen + $segment(SPLICE)]

						;#	IF ORIG SEG TOO SHORT TO SHRINK, OR SHRUNK SEG WOULD BE TOO SHORT FOR PVOC SYNTH, DELETE IT
						
								if {($segment(itemdur) <= $segment(TWOSPLICE)) || ($cutlen <= $segment(TWOSPLICE))} {	
									set segment(mixlines) [lreplace $segment(mixlines) $nextduplhdline $nextduplhdline]
									set qmsg "$ifnam WAS TOO SHORT TO SHRINK TO SIZE\n"
									lappend failmsgs $qmsg

								} else {

						;#	CALCULATE HOW FAR START OF DUPLHEAD WILL NEED TO BEW MOVED IN MIX

									set timeshift [expr $segment(itemdur) - $cutlen]

						;#	SHORTEN OR STRETCH PRE-HEAD TO FALL WITHIN PRECEDING TAIL USING STRRATIO NUMERICAL VAL

									set strratio $strrationum

						;#	IF STRETCHING, USE ENVELOPE TO AVOID STRETCH OF INITIAL SPLICE

									if {$strrationum > 1.0} {
										catch {unset env}
										set eline [list 0.0 1]
										lappend env $eline
										set eline [list $segment(SPLICE) 1]
										lappend env $eline
										set eline [list [expr $segment(SPLICE) + $evv(FLTERR)] $strratio]
										lappend env $eline
										set eline [list 10000 $strratio]
										lappend env $eline
										if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
											Inf "CANNOT DELETE INTERMEDIATE TIMESTRETCH-DATA FILE $segment(envfil) : $zit"
											set OK 0
											break
										}
										if [catch {open $segment(envfil) "w"} zit] {
											Inf "CANNOT CREATE TIMESTRETCH-DATA FILE $segment(envfil) : $zit"
											set OK 0
											break
										}
										foreach line $env {
											puts $zit $line
										}
										close $zit
										set strratio $segment(envfil)
									}

									;#	SETUP OUTFILE NAME

									set zxfnam [file rootname $nextfnam]
									append zxfnam "_x" $evv(SNDFILE_EXT)		;#	This is name of final output of this shrink-process
									if {[file exists $zxfnam] && [catch {file delete $zxfnam} zit]} {
										Inf "CANNOT DELETE INTERMEDIATE FILE $zxfnam : $zit"
										set OK 0
										break									;#	This will be name of pre-dovetailed output
									}
									if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
										Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit"
										set OK 0
										break									
									}
									catch {unset segment(innams)}						;#	The (separated-out mono) inputs to timeshrink process

									if {$nextchans == 1} {

										lappend segment(innams) $nextfnam

									} else {

										;#	IF HEAD NOT MONO, SPLIT PRE-HEAD INTO SEPARATE CHANNELS		

										if {![RetimeSplitToMonoChans $nextfnam $nextchans]} {
											set OK 0
											break
										}
									}

									set ofnama [file rootname $ofnam]
									append ofnama "_x" $evv(ANALFILE_EXT)

									;#	FOR EACH (MONO) INPUT WAV FILE, TIMESTRETCH

									set msg3 ""
									set zn 1
									foreach ifnam $segment(innams) {
										if {![GettrofRetimeTstretch $ifnam $ofnama $zn $thischans $strratio]} {
											set OK 0
											break
										}
										incr zn
									}
									if {!$OK} {
										break
									}

									if {$nextchans > 1} {

										;#	IF ORIGINAL PRE-HEAD NOT MONO, MERGE TIMESTRETCHED CHANNELS
										
										if {![GettrofMergeTstretchedChans]} {
											set OK 0
											break
										}
									}
								
									;#	DOVETAIL OUTPUT

									if {![DovetailRetimeOutput $segment(fadesnd) $zxfnam 0]} { 
										set OK 0
										break
									}
								}													;#	Move its start time appropriately
								set nexthtim [expr $nexthtim + $timeshift]
								set nexthxline [lreplace $nexthxline 0 1 $zxfnam $nexthtim]
								set segment(mixlines) [lreplace $segment(mixlines) $nextduplhdline $nextduplhdline $nexthxline]
							}
						}
					}
				}

					;#	IF HEAD+TAIL MERGED, MARK A TAIL-LINE IN MIXFILE FOR DELETION, 
					;#	AND PREPARE TO INSERT MERGED HEAD+TAIL AT ORIG POSITION OF HEAD

				if {$htmerged} {
					set line [lindex $segment(mixlines) $trecycline]
					set line [lreplace $line 0 end 0]						;#	Deleted line flagged in mix by being set to "0"
						set segment(mixlines) [lreplace $segment(mixlines) $trecycline $trecycline $line]
					if {$duplhdline >= 0} {
						set line [lindex $segment(mixlines) $duplhdline]
						set line [lreplace $line 0 end 0]					;#	Deleted EXTRA Head-processed line : set to "0"
						set segment(mixlines) [lreplace $segment(mixlines) $duplhdline $duplhdline $line]
					}
					set trecycline $hrecycline								;#	And set line-in-which-time-is-to-be replaced as Head of H/T pair
				}

				;#	IF FILE CUT, SHRUNK OR STRETCHED, INSERT CUT FILE IN (ALREADY RETIMED) OUTPUT MIX

				if {$changed} {
					set line [lindex $segment(mixlines) $trecycline]
					set line [lreplace $line 0 0 $ofnam]	
					set segment(mixlines) [lreplace $segment(mixlines) $trecycline $trecycline $line]
				}
				incr n
				incr m
			}

			;#	DELETE ANY MIXFILE LINES MARKED FOR DELETION (WHERE HEAD+TAIL HAVE BEEN MERGED)
				
			set n 0
			set len [llength $segment(mixlines)]
			while {$n < $len} {
				set line [lindex $segment(mixlines) $n]
				if {[string match [lindex $line 0] "0"]} {
					set segment(mixlines) [lreplace $segment(mixlines) $n $n]
					incr len -1
				} else {
					incr n
				}
			}
			if {[info exists failmsgs]} {
				set msg ""
				foreach fmsg $failmsgs {
					append msg "$fmsg\n"
				}
				Inf $msg
			}
		}
		break
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	set OK 0
	foreach origline $segment(origmixlines) line segment(mixlines) {
		if {![string match $origline $line]} {
			set OK 1
			break
		}
	}
	if {!$OK} {
		Inf "SOURCE HAS NOT BEEN RETIMED (RETIME DATA HAD NO EFFECT)"
		if {$retime_only} {
			return 0
		}
	}

	# DO FINAL MIXDOWN : DO LEVEL TEST THING

	DoMultichanCorrection
	DoRetimingCorrection

	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	;#	LEVEL ADJUSTING MIX

	if {![GettrofPossiblyMultichanMixdown 1]} {
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}
	set segment(retimed) 1
	UnBlock
	return 1
}

#--- For timestretch/shrink in RETIME, with a non-mono file, split into mono channel components

proc RetimeSplitToMonoChans {fnam channels} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages
	set kfnam [file rootname $fnam]
	set OK 1
	set zn 1
	while {$zn <= $channels} {
		set zzfnam $kfnam
		append zzfnam "_c" $zn $evv(SNDFILE_EXT)
		if {[file exists $zzfnam] && [catch {file delete $zzfnam} zit]} {
			Inf "CANNOT DELETE INTERMEDIATE FILE $zzfnam : $zit"
			set OK 0
			break
		}
		incr zn
	}
	if {!$OK} {
		return 0
	}
	catch {unset segment(ofnamxs)}
	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 2 $fnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}

	wm title .blocker "PLEASE WAIT:        SPLITTING SEGMENT $fnam INTO SEPARATE CHANNELS"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO SPLIT SEGMENT $fnam INTO SEPARATE CHANNELS"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO SPLIT SEGMENT $fnam INTO SEPARATE CHANNELS"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	set zn 1
	while {$zn <= $channels} {
		set zzfnam $kfnam
		append zzfnam "_c" $zn $evv(SNDFILE_EXT)
		if {![file exists $zzfnam]} {
			Inf "NO CHANNEL $zn OF $fnam EXTRACTED"
			return 0
		}
		lappend segment(innams) $zzfnam
		incr zn
	}
	if {!$OK} {
		break
	}
	return 1
}

#--- IF processed phrase has duplicate Heads for one segment, if processed Head is after orig Head, join together ....

proc ReplaceDuplicateHeadsInPhraseBySingleHeadAndRetime {duplhdlineno multichan thistim n} {
	global evv segment prg_dun prg_abortd simple_program_messages CDPidrun

	set line [lindex $segment(mixlines) $segment(recycline)]
	set duplheadline [lindex $segment(mixlines) $duplhdlineno]

	set pfnam [lindex $line 0]
	set pfnam [file rootname $pfnam]
	append pfnam "_x" $evv(SNDFILE_EXT)

	set processed_head_fnam [lindex $duplheadline 0]

	if {[file exists $segment(mixdata)] && [catch {file delete $segment(mixdata)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE MIXFILE $segment(mixdata) : $zit"
		return 0
	}														
	
	;#	CREATE A MIXFILE TO JOIN HEAD to DUPLHEAD
	
	if {$multichan} {
		set submixline [lindex $segment(mixlines) 0]
		lappend submix $submixline
	}
	set starttime 1000000.0
	set submixline [lindex $segment(mixlines) $segment(recycline)]
	lappend submix $submixline
	set thistime [lindex $submixline 1]
	if {$thistime < $starttime} {
		set starttime $thistime
	}
	set submixline [lindex $segment(mixlines) $duplhdlineno]
	lappend submix $submixline
	set thistime [lindex $submixline 1]
	set chans [lindex $submixline 2]
	if {$thistime < $starttime} {
		set starttime $thistime
	}
	if {$starttime > 0.0} {
		set smlen [llength $submix]
		set kkf $multichan
		while {$kkf < $smlen} {	
			set submixline [lindex $submix $kkf]
			set thistime [lindex $submixline 1]
			set thistime [expr $thistime - $starttime]
			if {$thistime < 0.0} {
				set thistime 0.0
			}
			set submixline [lreplace $submixline 1 1 $thistime]
			set submix [lreplace $submix $kkf $kkf $submixline]
			incr kkf
		}
	}
	if [catch {open $segment(mixdata) "w"} zit] {
		Inf "CANNOT OPEN INTERMEDIATE MIXFILE FOR PHRASE $n : $zit"
		return 0
	}
	foreach submixline $submix {
		puts $zit $submixline
	}
	close $zit

	;#	MIX TO JOIN

	if {$multichan} {
		set cmd [file join $evv(CDPROGRAM_DIR) newmix]
		lappend cmd multichan $segment(mixdata) $pfnam
	} else {
		set cmd [file join $evv(CDPROGRAM_DIR) submix]
		lappend cmd mix $segment(mixdata) $pfnam
	}
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        JOINING DOUBLE HEAD AT PHRASE $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN JOINING OF DOUBLE HEAD AT PHRASE $n"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE JOINED DOUBLE HEAD AT PHRASE $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $pfnam]} {
		Inf "NO JOINED DOUBLE HEAD FOR PHRASE $n CREATED"
		return 0
	}
	if [catch {file delete $processed_head_fnam} zit] {
		Inf "CANNOT DELETE ORIGINAL FILE $processed_head_fnam : $zit"
		return 0
	}
	if [catch {file rename $pfnam $processed_head_fnam} zit] {
		Inf "CANNOT RENAME JOINED HEADS $n FILE to $processed_head_fnam : $zit"
		return 0
	}

	;#	THE PH LINE NOW REFERS TO THE NEW (FUSED) HH-PH : SET IT TO THE NEW TIMING

	set duplheadline [lreplace $duplheadline 1 1 $thistim]			;#	This ensures that any multichannel mix format retained
	set segment(mixlines) [lreplace $segment(mixlines) $duplhdlineno $duplhdlineno $duplheadline]

	;#	DELETE THE ORIGINAL HH LINE

	set segment(mixlines) [lreplace $segment(mixlines) $segment(recycline) $segment(recycline)]
	return 1
}

#--- For timestretch/shrink in RETIME, Convert Mono to spectrum, timestretch, convert back to wav, (assemble output names if src not mono)

proc GettrofRetimeTstretch {ifnam ofnama zn thischans strratio} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages 

	set ifnama [file rootname $ifnam]
	append ifnama $evv(ANALFILE_EXT)
	if {[file exists $ifnama] && [catch {file delete $ifnama} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $ifnama : $zit"
		return 0
	}
	set msg3 ""
	if {$thischans > 1} {
		set msg3 "CHANNEL $zn"
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd anal 1 $ifnam $ifnama -c1024 -o3
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}

	wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF SEGMENT [file rootname $ifnam] $msg3"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO CREATE SPECTRUM OF SEGMENT [file rootname $ifnam] $msg3"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE SPECTRUM OF SEGMENT [file rootname $ifnam] $msg3"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ifnama]} {
		Inf "NO SPECTRUM OF [file rootname $ifnam] $msg3 CREATED"
		return 0
	}

	if {[file exists $ofnama] && [catch {file delete $ofnama} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE SPECTRAL FILE $ofnama : $zit"
		return 0
	}

	;#	TIMESTRETCH TAIL (OR MERGED HEAD+TAIL)

	set cmd [file join $evv(CDPROGRAM_DIR) stretch]
	lappend cmd time 1 $ifnama $ofnama $strratio

	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}

	wm title .blocker "PLEASE WAIT:        TIMESTRETCHING [file rootname $ifnam] $msg3"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO TIMESTRETCH [file rootname $ifnam] $msg3"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO TIMESTRETCH [file rootname $ifnam] $msg3"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnama]} {
		Inf "NO TIMESTRETCHED VERSION OF [file rootname $ifnam]  $msg3 CREATED"
		return 0
	}

	;#	RESYNTH TIMESTRETCHED TAIL (OR MERGED HEAD+TAIL)

	if {$thischans > 1} {
		set ofnamx [file rootname $ofnama]
		append ofnamx "_c" $zn $evv(SNDFILE_EXT)
		lappend segment(ofnamxs) $ofnamx			;#	MONO-extracted from stereo or multichan goes to PRE-channelmerge files
	} else {
		set ofnamx $segment(fadesnd)				;#	MONO input goes directly to PRE-dovetail file
	}
	if {[file exists $ofnamx] && [catch {file delete $ofnamx} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE SOUND FILE $ofnamx : $zit"
		set OK 0
		break
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd synth $ofnama $ofnamx
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF TIMESTRETCHED [file rootname $ifnam] $msg3"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN WAVEFORM CREATION FOR TIMESTRETCHED [file rootname $ifnam] $msg3"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE WAVEFORM OF TIMESTRETCHED [file rootname $ifnam] $msg3"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnamx]} {
		Inf "NO WAVEFORM OF TIMESTRETCHED [file rootname $ifnam] $msg3 CREATED"
		return 0
	}
	return 1
}

#--- For timestretch/shrink in RETIME, with a non-mono srcfile, merge mono channel components into multichan output

proc GettrofMergeTstretchedChans {ifnam} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages

	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	lappend cmd interleave
	foreach ofnamx $segment(ofnamxs) {
		lappend cmd $ofnamx
	}
	lappend cmd $segment(fadesnd)

	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        MERGING TIMESTRETCHED CHANNELS OF SEGMENT [file rootname $ifnam]"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO MERGE TIMESTRETCHED CHANNELS OF SEGMENT [file rootname $ifnam]"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO MERGE TIMESTRETCHED CHANNELS OF SEGMENT [file rootname $ifnam]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(fadesnd)]} {
		Inf "NO CHANNEL-MERGED TIMESTRETCHED SEGMENT [file rootname $ifnam] CREATED"
		return 0
	}
	return 1
}

#--- For timestretch/shrink in RETIME, Dovetail the timestretched output

proc DovetailRetimeOutput {ifnam ofnam strratio} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages

	if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
		Inf "CANNOT DELETE PREVIOUS FILE $ofnam : $zit"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) envel]
	lappend cmd dovetail 1 $segment(fadesnd) $ofnam
	if {$strratio < 1.0} {
		lappend cmd $segment(frametime) $segment(frametime) 
	} else {
		lappend cmd $segment(frametime) $segment(SPLICE) 
	}
	lappend cmd  1 1 -t0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        DOVETAILING TIMESTRETCHED SEGMENT [file rootname $ifnam]"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO DOVETAIL TIMESTRETCHED SEGMENT [file rootname $ifnam]"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE DOVETAILED TIMESTRETCHED SEGMENT [file rootname $ifnam]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO EXACT DOVETAILED TIMESTRETCHED SEGMENT [file rootname $ifnam] CREATED"
		return 0
	}
	return 1
}

;#--- Get rid of all intermediate files not being used in mix

proc RemoveTemporaryFilesNotinMixlist {} {
	global segment evv
	if {![catch {glob $evv(DFLT_OUTNAME)*}]} {
		foreach fnam [glob $evv(DFLT_OUTNAME)*] {
			lappend dellist $fnam
		}
	}
	if {![catch {glob $evv(MACH_OUTFNAME)*}]} {
		foreach fnam [glob $evv(MACH_OUTFNAME)*] {
			lappend dellist $fnam
		}
	}
	if {![info exists dellist]} {
		return 1
	}
	set k 0
	set len [llength $dellist]
	while {$k < $len} {
		set fnam [lindex $dellist $k]
		if {[GetTrofFileIsInMixlist $fnam] >= 0} {
			set dellist [lreplace $dellist $k $k]
			incr len -1
		} else {
			incr k
		}
	}
	if {![info exists dellist]} {
		return 1
	}
	foreach fnam $dellist {
		if [catch {file delete $fnam} zit] {
			lappend badfiles $fnam
		}
	}
	if {[info exists badfiles]} {
		set msg "CANNOT DELETE THE FOLLOWING INTERMEDIATE FILES\n"
		foreach fnam $badfiles {
			append msg "$fnam\n"
		}
		Inf $msg
		return 0
	}
	return 1
}

proc GetTrofFileIsInMixlist {fnam} {
	global segment
	set n 0
	foreach line $segment(mixlines) {
		set thisfnam [lindex $line 0]
		if {[string match $fnam $thisfnam]} {
			return $n
		}
		incr n
	}
	return -1
}

proc LineIsTailAtStartOfMix {lineno} {
	global segment
	set firstline 0
	if {[llength [lindex $segment(mixlines) $firstline]] < 4} {
		incr firstline
	}
	if {$lineno == $firstline} {
		if {$segment(headfirst)} {
			return 0
		} else {
			return 1
		}
	}
	return 0
}

#--- If any mixtimes fall below zero, readjust all mix times

proc DoRetimingCorrection {} {
	global segment
	set starttime 1000000.0
	foreach line $segment(mixlines) {
		if {[llength $line] > 1} {
			set thistime [lindex $line 1]
			if {$thistime < $starttime} {
				set starttime $thistime
			}
		}
	}
	if {$starttime >= 0.0} {
		return
	}
	set len [llength $segment(mixlines)]
	set k 0
	while {$k < $len} {
		set line [lindex $segment(mixlines) $k]
		if {[llength $line] > 1} {
			set thistime [lindex $line 1]
			set thistime [expr $thistime - $starttime]
			if {$thistime < 0.0} {
				set thistime 0.0
			}
			set line [lreplace $line 1 1 $thistime]
			set segment(mixlines) [lreplace $segment(mixlines) $k $k $line]
		}
		incr k
	}
}

;#--- Find filename and line-no-in-mix of the currently required Head file

proc FindRelevantHeadFileForRetimeAndVerges {hno} {
	global segment evv
	set duplhead -1
	set srcfile $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
	set srcfile_is_inmix [GetTrofSrcfileIsInMixlist $srcfile]
	set ifnam $evv(MACH_OUTFNAME)PH$hno$evv(SNDFILE_EXT)
	set processedfile_isinmix [GetTrofSrcfileIsInMixlist $ifnam]
	if {$processedfile_isinmix < 0} {
		set ifnam $evv(MACH_OUTFNAME)HF$hno$evv(SNDFILE_EXT)
		set processedfile_isinmix [GetTrofSrcfileIsInMixlist $ifnam]
		if {$processedfile_isinmix < 0} {
			if {$srcfile_is_inmix >= 0} {
				set ifnam $srcfile
				set headline $srcfile_is_inmix
			} else {
				set headline -1										;#	HEADline may have been absorbed in a TAIL (by Retunr with Tune Heads option)
			}
		}
	}
	if {$processedfile_isinmix >= 0} {
		if {$srcfile_is_inmix >= 0} {								;#	2 HEAD files (of same number) in mix (TEXTURE does this!!)
			set ifnam $srcfile
			set headline $srcfile_is_inmix
			set duplhead $processedfile_isinmix
		} else {
			set headline $processedfile_isinmix
		}
	}
	return [list $ifnam $headline $duplhead]
}

;#--- Find filename and line-no-in-mix of the currently required Tail file

proc FindRelevantTailFileForRetime {tno} {
	global segment evv
	set ifnam $evv(MACH_OUTFNAME)PT$tno$evv(SNDFILE_EXT)
	set tailline [GetTrofSrcfileIsInMixlist $ifnam]
	if {$tailline < 0} {
		set ifnam $evv(MACH_OUTFNAME)TF$tno$evv(SNDFILE_EXT)
		set tailline [GetTrofSrcfileIsInMixlist $ifnam]
		if {$tailline < 0} {
			set ifnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)
			set tailline [GetTrofSrcfileIsInMixlist $ifnam]
		}
	}
	return [list $ifnam $tailline]
}

;#--- Is named file in current mixlines, and if so, return it's line number

proc GetTrofSrcfileIsInMixlist {fnam} {
	global segment
	set n 0
	foreach line $segment(mixlines) {
		set thisfnam [lindex $line 0]
		if {[string match $fnam $thisfnam]} {
			return $n
		}
		incr n
	}
	return -1
}

#---- "UnTwang" not compatible with RETIME as segment onsets times have been shuffled

proc NonCompatibleRetime {} {
	global segment
	set lastprocess 0
	if {[info exists segment(lastprocess)]} {
		set lastprocess $segment(lastprocess)
	} else {
		set lastprocess $segment(process)
	}
	if {($lastprocess == "TWANG") && $segment(untwang)} {
		Inf "PREVIOUS PROCESS, \"UNTWANG\", NOT COMPATIBLE WITH RETIMING."
		return 1
	}
	if {$lastprocess == "SUPPRESS"} {
		Inf "PREVIOUS PROCESS, \"SUPPRESS\", NOT COMPATIBLE WITH RETIMING."
		return 1
	}
	if {$segment(suppress_used)} {
		Inf "\"SUPPRESS\" PROCESS USED PREVIOUSLY : NOT COMPATIBLE WITH RETIMING."
		return 1
	}
	return 0
}

#--- When timestretching without a pre-existing mixfile, create one from original segments

proc CreateSegmentMixfile {marks} {
	global segment evv
	if {$segment(phrase)} {
		set j 0
		set n 1
		while {$n <= $segment(cnt)} {
			set ifnam $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
			set time [lindex $marks $j]
			if {$n > 1} {
				set time [expr $time - $segment(SPLICE)]
			}
			set line [list $ifnam $time 1 1.0]
			lappend segment(mixlines) $line
			incr n
			incr j
		}
	} else {
		if {$segment(headfirst)} {
			set ishead 1
		} else {
			set ishead 0
		}
		set tno 1
		set hno 1
		set j 0
		set n 1
		while {$n <= $segment(cnt)} {
			if {$ishead} {
				set ifnam $evv(DFLT_OUTNAME)HH$hno$evv(SNDFILE_EXT)
				incr hno
				set time [lindex $marks $j]									;# n=	 1  2			 3	4	
				if {$n > 1} {												;#		 Times			 |	|	
					set time [expr $time - $segment(SPLICE)]				;#		 |  |			 |  |
				}															;#		 |---\			/----\
			} else {														;#		 Heads			 |	|
				set ifnam $evv(MACH_OUTFNAME)TD$tno$evv(SNDFILE_EXT)			;# hno=	 1	|			 2	|
				incr tno													;#		 |	|/----------\|	|
				set time [lindex $marks $j]									;#		 	Tails		 |	
			}																;# tno=	 	1			 |		
			set line [list $ifnam $time 1 1.0]
			lappend segment(mixlines) $line

			set ishead [expr !$ishead]
			incr n
			incr j
		}
	}
}

#---- Generate an appropriate outfilename (from infilename) for RETIME

proc GenerateRetimeOutfnamFromInfnam {ifnam} {
	global segment evv
	if {$segment(phrase)} {
		set typ HH
		set k [string first $typ $ifnam]
		if {$k < 0} {
			set typ PH
			set k [string first $typ $ifnam]
		}
		incr k -1
		set ofnam [string range $ifnam 0 $k]
		append ofnam "HX"
		incr k 3
		set ofnamend [string range $ifnam $k end]
		append ofnam $ofnamend
	} else {
		set typ TD
		set k [string first $typ $ifnam]
		if {$k < 0} {
			set typ TF
			set k [string first $typ $ifnam]
		}
		if {$k < 0} {
			set typ PT
			set k [string first $typ $ifnam]
		}
		incr k -1
		set ofnam [string range $ifnam 0 $k]
		if {$typ == "PT"} {
			append ofnam "TF"
		} else {
			append ofnam "PT"
		}
		incr k 3
		set ofnamend [string range $ifnam $k end]
		append ofnam $ofnamend
	}
	return $ofnam
}

#---- Merge Head & Tail where necessary in RETIME

proc MergeHeadAndTail_forRetime {n hrecycline trecycline ifnam} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	PREPARE TO MERGE HEAD AND TAIL

	if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd) : $zit"
		return 0
	}
	if {[file exists $segment(mixdata)] && [catch {file delete $segment(mixdata)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(mixdata) : $zit"
		return 0
	}														;#	Create a mixfile to join H to T
	set hline  [lindex $segment(mixlines) $hrecycline]
	set hhfnam [lindex $hline 0]
	set htime  [lindex $hline 1]
	set hchans [lindex $hline 2]
	set tline  [lindex $segment(mixlines) $trecycline]
	set ttfnam [lindex $tline 0]
	set ttime  [lindex $tline 1]
	set mtime [expr $ttime - $htime]

	;#	CREATE SUBMIX FILE TO MERGE HEAD AND TAIL

	catch {unset submix}
	if {$hchans > 1} { 

		;# IF HEAD TO BE MERGED AND SHRUNK IS NOT MONO, CONVERT TO MONO

		set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
		lappend cmd chans 4 $hhfnam $segment(othersnd)
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        REDUCING $hchans CHANNEL SEGMENT [file rootname $hhfnam] TO MONO"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO REDUCE $hchans CHANNEL SEGMENT [file rootname $hhfnam] TO MONO"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE MONO VERSION OF SEGMENT [file rootname $hhfnam]"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $segment(othersnd)]} {
			Inf "NO MONO VERSION OF [file rootname $hhfnam] CREATED"
			return 0
		}
		if [catch {file delete $hhfnam} zit] {
			Inf "CANNOT DELETE ORIGINAL MULTICHANNEL SEGMENT [file rootname $hhfnam]"
			return 0
		}
		if [catch {file rename $segment(othersnd) $hhfnam} zit] {
			Inf "CANNOT RENAME MONO-CONVERTED SEGMENT [file rootname $hhfnam]"
			return 0
		}
		set hchans 1
	}
	set line [list $hhfnam 0.0 $hchans 1.0]
	lappend submix $line
	set line [list $ttfnam $mtime 1 1.0]				;#	Tails are always MONO
	lappend submix $line

	if {[catch {open $segment(mixdata) "w"} zit]} {
		Inf "CANNOT OPEN INTERMEDIATE MIXFILE $segment(mixdata) TO JOIN HEAD TO TAIL : $zit"
		return 0
	}
	foreach line $submix {
		puts $zit $line
	}
	close $zit
	;#	MERGE HEAD AND TAIL

	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	lappend cmd mix $segment(mixdata) $segment(othersnd)

	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        COMBINING HEAD & TAIL SEGMENTS AT LINES $hrecycline $trecycline"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN MIX TO COMBINE HEAD & TAIL SEGMENTS AT LINES $hrecycline $trecycline"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO COMBINE HEAD & TAIL SEGMENTS  AT LINES $hrecycline $trecycline"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(othersnd)]} {
		Inf "NO FILE OF COMBINED HEAD & TAIL SEGMENTS  AT LINES $hrecycline $trecycline CREATED"
		return 0
	}
	if [catch {file delete $ifnam} zit] {
		Inf "CANNOT DELETE INTERMEDIATE FILE $ifnam : $zit"
		return 0
	}
	if [catch {file rename $segment(othersnd) $ifnam} zit] {
		Inf "CANNOT RENAME INTERMEDIATE FILE $segment(othersnd) : $zit"
		return 0
	}
	return 1
}

############################################################################################
# OTHER = VIBRATO : SCAN : LOOP : REVERB : DISTREP : VERGES : DELRING : TREMOLO : ZIGACCEL #
############################################################################################

#--- Distort envel applied to tails in segmented sound, or phrases

proc Gettrof_Other {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	if {$segment(phrase)} {
		set msg_type "PHRASE"
	} else {
		set msg_type "TAIL SEGMENT"
	}

	Block "PLEASE WAIT:        MODIFYING $msg_type"


	;#	SET PRESET PARAMS

	set msgfail ""
	set tunehead  0
	set needsmono 0
	set trimtosiz 0
	set tuningcnt 0
	set crossfad  0
	set normalize 0

	switch -- $segment(process) {
		"VIBRATO" -
		"SCAN" {
			set trimtosiz 1
		}
		"LOOP" {
			set scattrd $segment(PAR0)
		}
		"REVERB" {
			set crossfad $segment(PAR0)
			set needsmono 1
			set normalize 1
		}
		"DISTREP" {
			set telescope $segment(PAR0)
			set needsmono 1
		}
		"VERGES" {
			set boost $segment(PAR0)
			if {!$segment(phrase)} {
				set tunehead 1					;#	Tune head COMPULSORY (except phrases, which have no H/T division)
			}
			set segment(nonewmarks) 1			;#	Marks cannot be recycled
			GetVergesMaxsampLocations			;#	Either in Head or in 1st 1/5th of H+T fusion
		}
		"DELRING" {
			set tunehead $segment(PAR0)
			if {$tunehead} {					;#	Also tune head
				set segment(nonewmarks) 1		;#	BUT marks cannot be recycled
			}
			set crossfad $segment(PAR1)
			set needsmono 1
			set trimtosiz 1
			set normalize 1
		}
		"TREMOLO" {
			set crossfad $segment(PAR0)
		}
		"ZIGACCEL" {
			set minzig $segment(PAR0)
			set ziglog $segment(PAR1)
		}
		"FORMOVE" {
			set tunehead $segment(PAR0)
			set transit $segment(PAR1)
			set normalize 1
		}
	}
	set hcnt 1								;#	Indices of first HEAD asnd TAIL files
	set tcnt 1

	;#	ESTABLISH COUNTING

	set mm 0								;#	Index in original marklist
	set n 1									;#	Segments count from 1 : segment 1 is first (tail or phrase) to process, by default
	set j 0									;#	Time-marks indices from 0
	set k 1
	set nexthno 1							;#	Index of next HEAD File to use,	(T1 ~H1~ T2 H2 ....)

	if {$segment(phrase)} {
		set segment(headfirst) 1
	} elseif {$segment(headfirst)} {
		if {![MultipleProcessing] && !$tunehead} {
			set hfnam $evv(DFLT_OUTNAME)HH1$evv(SNDFILE_EXT)
			set line [list $hfnam [lindex $segment(marklist) $mm] 1 1.0]
			lappend mixlines $line			;#	Start mix with the unaltered HEAD segment = 1st segment
		}
		incr hcnt
		incr n								;#	Index for first (TAIL) segment to modify is 2 (segments count from 1)
		incr j								;#	Indices for start and end times of segment, in marklist
		incr k
		incr mm
		incr nexthno						;#	Index of next HEAD File to use	(H1 T1 ~H2~ ....)
	}

	if {![MultipleProcessing]} {
		ClearNoexpands
	} else {
		set segment(origmixlines) $segment(mixlines)
	}
											;#	Extended final val in marklist, replaced by true end of file

	set marks [lreplace $segment(marklist) end end $segment(wavdur)]

											;#	Establish counters and limits for reading brkpnt tables of vparams
	set nn 1
	while {$nn <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$nn) [expr [llength $segment(control$nn,$segment(process))] - 1]
		set segment(zccnt,$nn) 0
		incr nn
	}

	;#	MODIFYING TAILS (alternate segments) OR PHRASES (= HEADS)

	if {$tunehead && [MultipleProcessing]} {
		set chancnt [GettrofMixChancnt]		;#	Head could have been transformed to stereo or multichan by a previous process
	} else {
		set chancnt 1
	}

	set OK 1

	while {$n <= $segment(cnt)} {
		set leftbase [lindex $marks $j]

		switch -- $segment(process) {
			DISTREP {
				set grpcnt  [GetParamValueFromControl $leftbase 1]
				set repcnt  [GetParamValueFromControl $leftbase 2]
				set durprop [GetParamValueFromControl $leftbase 3]
			}
			VIBRATO {
				set vibfrq  [GetParamValueFromControl $leftbase 1]
				set vibdep  [GetParamValueFromControl $leftbase 2]
			}
			TREMOLO {
				set vibfrq  [GetParamValueFromControl $leftbase 1]
				set vibdep  [GetParamValueFromControl $leftbase 2]
				set narrow  [GetParamValueFromControl $leftbase 3]
			}
			ZIGACCEL {
				set zigrep  [expr int(round([GetParamValueFromControl $leftbase 1]))]
				set zigfrc  [GetParamValueFromControl $leftbase 2]
			}
			REVERB {
				set stadsiz [GetParamValueFromControl $leftbase 1]
				set echocnt [GetParamValueFromControl $leftbase 2]
				set echocnt [expr int(round($echocnt))]
				set maxdur  [GetParamValueFromControl $leftbase 3]
			}
			LOOP {
				set lenprop [GetParamValueFromControl $leftbase 1]
				set durprop [GetParamValueFromControl $leftbase 2]
				if {!$scattrd} {
					set advance [GetParamValueFromControl $leftbase 3]
				}
			}
			SCAN {
				set sttprop [GetParamValueFromControl $leftbase 1]
				set endprop [GetParamValueFromControl $leftbase 2]
				set durprop [GetParamValueFromControl $leftbase 3]
			}
			VERGES {
				set vrgtrns [GetParamValueFromControl $leftbase 1]
				set vrgslop [GetParamValueFromControl $leftbase 2]
				set vrgdur  [GetParamValueFromControl $leftbase 3]
			}
			FORMOVE {
				set fortrns [GetParamValueFromControl $leftbase 1]
			}
		}	
			;#	ALWAYS A TAIL (or PHRASE = HEAD)
			
		set nn $n
		if {!$segment(phrase) && ($segment(process) == "VERGES")} {	;#	with VERGES: "tail" ACTION is linked to prior HEAD.
			if {$nn > 1} {
				incr nn -1
			}
		}
		if {$segment(multiproccnt) && ([lindex $segment(actionlist) $nn] == 0)} {
			if {$segment(phrase)} {
				incr mm
				incr n
				incr j
				incr k
				incr hcnt									;#	Phrases assumed to be all heads
				continue
			} else {
				incr mm 2									;#	If no tail processing required
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
				incr tcnt
				continue
			}
		}
		if {[MultipleProcessing]} {
			if {$segment(phrase)} {							;#	phrases only use HEAD numbering scheme (no tails)
				if {![GetRecycledSegment $hcnt HEAD]} {		;#	"segment(recycline)" gets position of HEAD
					set OK 0
					break
				}
			} else {
				if {![GetRecycledSegment $tcnt TAIL]} {		;#	At this point "segment(recycline)" gets position of TAIL
					set OK 0
					break
				}
			}
			set ifnam $segment(iifnam)
			set tailtime [lindex [lindex $segment(mixlines) $segment(recycline)] 1]

		} else {											;#	phrases only use multiple processing, so this is for H/T types and NOT phrases
			set ifnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
			set tailtime $leftbase
		}

		if {$segment(phrase)} {								;#	phrases only use HEAD numbering scheme
			set ofnam $evv(MACH_OUTFNAME)PH$hcnt$evv(SNDFILE_EXT)
		} else {
			set ofnam $evv(MACH_OUTFNAME)PT$tcnt$evv(SNDFILE_EXT)
		}

		set tuning_head 0
		set ttchan 1								;#	In case hhcnt = 0, ttchan not set below: but in this case we're at tail as first seg, and tails are mono
		set htchan 1								;#	Where head fused with tail, htchan = Count of channels in Head (which may be stereo or multichan)
													;#	For cases with NO fusion with head, this defaults to 1, as all Tails are mono
		;#	phrases don't use "tunehead" option

		if {$tunehead} {
			if {$segment(headfirst)} {
				set hhcnt $tcnt						;#	Head associated with tail has same hcnt		H1 T1 H2 T2 H3 T3
			} else {								;#												----- ----- -----
				set hhcnt [expr $tcnt - 1]			;#	Head associated with tail has previous hcnt	T1 H1 T2 H2 T3 H3
			}										;#												   ----- -----
			if {$hhcnt > 0} {
				set OK5 1
				while {$OK5} {
					set tuning_head 1
					if {[MultipleProcessing]} {			;#	If tuning Head also "segment(recycline)" gets position of preceding HEAD
						set orig_recycline $segment(recycline)
						set headdata [FindRelevantHeadFileForRetimeAndVerges $hhcnt]
						set segment(recycline) [lindex $headdata 1]
						if {$segment(recycline) < 0} {	;#	The Head has already been absorbed into the tail
							set tuning_head 0			;#	so no merging of head, BUT we must redefine segment(recycline) as the TAIL line
							set segment(recycline) $orig_recycline
							break
						}
						set hfnam			   [lindex $headdata 0]
						set duplhead           [lindex $headdata 2]
						set head_line [lindex $segment(mixlines) $segment(recycline)]
						set headtime        [lindex $head_line 1]
						set segment(iichan) [lindex $head_line 2]
						set taildata [FindRelevantTailFileForRetime $tcnt]
						set tail_line [lindex $segment(mixlines) [lindex $taildata 1]]
						set ttchan [lindex $tail_line 2]
						set mixstep [expr $tailtime - $headtime]
						if {$duplhead >= 0} {
							set hfnam2		 [lindex [lindex $segment(mixlines) $duplhead] 0]
							set headtime2	 [lindex [lindex $segment(mixlines) $duplhead] 1]
							set segment(iichan2) [lindex [lindex $segment(mixlines) $duplhead] 2]
							set mixstep2 [expr $headtime2 - $headtime]
						}																			;#	H1  T1	 H2	 T2
					} else {																		;#	| |		| |
						set hfnam $evv(DFLT_OUTNAME)HH$hhcnt$evv(SNDFILE_EXT)						;#	 __		 __
						set headtime [lindex $marks [expr $j - 1]]									;#	|  \____/  \____
						set mixstep [expr $tailtime - $headtime]									;#	   /	\  /	\
																									;# !!! DON'T DELETE THIS LINE!!
						if {$hhcnt > 1} {															;#  |-|	   |--| 
							set mixstep [expr $mixstep + $segment(SPLICE)]							;#  mark	upsplice
						}																			;#			  step
						set segment(iichan) 1			;#	If not multiple process, head must be mono
						set segment(doublehead) 0		;#	and not previously processed, so can't be doubled
					}
					set segment(fadesnd) $segment(fadesnd_dflt)
					if {[file exists $segment(fadesnd)]} {											
						if [catch {file delete $segment(fadesnd)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE TEMPORARY SOUND FILE $segment(fadesnd)"	
							set OK 0
							break
						}
					}
					if {[file exists $segment(mixdata)]} {
						if [catch {file delete $segment(mixdata)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE MIXFILE $segment(mixdata)"	
							set OK 0
							break
						}
					}

					;#	MAKE MIXFILE TO MIX HEAD TO TAIL

					set m $n
					if {$segment(process) == "VERGES"} {
						incr m -1
					}
					catch {unset lines}
					set htchan $ttchan
					if {$segment(iichan) > $htchan} {
						set htchan $segment(iichan)
					}
					if {$segment(doublehead) && ($segment(iichan2) > $htchan)} {
						set htchan $segment(iichan2)
					}
					if {$htchan > 2} {
						set line $htchan
						lappend lines $line
						set line [list $hfnam 0.0 $segment(iichan)]
						set kk 1
						while {$kk <= $segment(iichan)} {
							lappend line "$kk:$kk" 1.0
							incr kk
						}
						lappend lines $line
						if {$duplhead} {
							set line [list $hfnam2 $mixstep2 $segment(iichan2)]
							set kk 1
							while {$kk <= $segment(iichan2)} {
								lappend line "$kk:$kk" 1.0
								incr kk
							}
							lappend lines $line
						}
						set line [list $ifnam $mixstep 1 1:1 1.0]
						lappend lines $line
					} else {
						set line [list $hfnam 0.0 $segment(iichan) 1.0]
						lappend lines $line
						if {$segment(doublehead)} {
							set line [list $hfnam2 $mixstep2 $segment(iichan2) 1.0]
							lappend lines $line
						}
						set line [list $ifnam $mixstep $ttchan 1.0]
						lappend lines $line
					}
					if [catch {open $segment(mixdata) "w"} zit] {
						Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixdata) TO JOIN HEAD TO TAIL : SEGMENT $m"
						set OK 0
						break
					}
					foreach line $lines {
						puts $zit $line
					}
					close $zit

					if {[file exists $segment(othersnd)]} {
						if [catch {file delete $segment(othersnd)} zit] {
							Inf "CANNOT DELETE INTERMEDIATE TEMPORARY SOUND FILE $segment(othersnd)"	
							set OK 0
							break
						}
					}

					;#	MIX HEAD TO TAIL

					if {$htchan > 2} {
						set cmd [file join $evv(CDPROGRAM_DIR) newmix]
						lappend cmd multichan $segment(mixdata) $segment(othersnd)
					} else {
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd mix $segment(mixdata) $segment(othersnd)
					}
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        RECOMBINING HEAD & TAIL FOR SEGMENT $m"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RECOMBINE HEAD & TAIL FOR SEGMENT $m"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE SOUND BY RECOMBINING HEAD & TAIL FOR SEGMENT $m"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $segment(othersnd)]} {
						Inf "NO FILE OF RECOMBINED HEAD & TAIL FOR SEGMENT $m"
						set OK 0
						break
					}
					break
				}
				if {!$OK} {
					break
				}
			}
		}
		if {$segment(phrase)} {
			incr hcnt
		} else {
			incr tcnt
			incr hcnt
		}

		if {$tuning_head || $needsmono} {

		;#	IF PRE-EXISTING HEAD IS STEREO OR MULTICHAN EXTRACT ALL THE CHANNELS AS SEPARATE MONO FILES

			set thischancnt $htchan
			if {$htchan > 1} {
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 2
				if {$tuning_head} {
					lappend cmd $segment(othersnd)
				} else {
					lappend cmd $ifnam
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING CHANNELS OF SEGMENT $n"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN CHANNEL EXTRACTION PROCESS FOR SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO EXTRACT CHANNELS FROM SEGMENT $n"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				set thischan 1
				while {$thischan <= $htchan} {
					set ichfnam($thischan) [file rootname $segment(othersnd)]
					append ichfnam($thischan) "_c$thischan" $evv(SNDFILE_EXT)
					if {![file exists $ichfnam($thischan)]} {
						set thischancnt [expr $thischan - 1]
						break
					}
					incr thischan
				}
			} else {
				if {$tuning_head} {
					set ichfnam(1) $segment(othersnd)
				} else {
					set ichfnam(1) $ifnam
				}
			}

		;#	ELSE IF PRE-EXISTING HEAD WAS MONO OR WE DON'T NEED MONO INPUT, ASSIGN INPUT TO "CHANNEL 1"
		;#	OR, IF NO HEAD PROCESSING, RENAME INPUT AS CHANNEL 1

		} else {
			set ichfnam(1) $ifnam
			set thischancnt 1
		}

		;#	RUN PROCESS ON EACH INPUT

		set OK2 1
		set OK44 1
		set thischan 1
		while {$thischan <= $thischancnt} {

			set iiifnam $ichfnam($thischan)
			if {![DoSegmentDurParse $iiifnam]} {
				Inf "CANNOT FIND DURATION OF SEGMENT $n"
				set OK2 0
				break
			}
			set indur $segment(itemdur)
			set ofnamc($thischan) [file rootname $iiifnam]
			append ofnamc($thischan) "_xxx" $evv(SNDFILE_EXT)
			if {[file exists $ofnamc($thischan)] && [catch {file delete $ofnamc($thischan)} zit]} {
				Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $ofnamc($thischan) : $zit"
				set OK2 0
				break
			}

			;#	PRE-PROCESS AND ESTABLISH CMDLINE

			switch -- $segment(process) {
				DISTREP {
					set outdur [expr $indur * $durprop]
					set cmd [file join $evv(CDPROGRAM_DIR) distortt]
					lappend cmd repeat $iiifnam $ofnamc($thischan) $grpcnt $repcnt $segment(MSPLICE) $outdur
					if {$telescope} {
						lappend cmd -t
					}

				}
				DELRING {

					;#	GET TUNING DATA FOR CURRENT SEGMENT

					set thistuning [lindex $segment(pitches) $tuningcnt]	
					incr tuningcnt
					if {$tuningcnt > $segment(tuningcnt)} {
						Inf "ANOMALY IN COUNTING PITCHES pitchcnt = $tuningcnt total input pitches = $segment(tuningcnt)"
						set OK2 0
						break
					}
					;#	GET DELAY 

					set frq [MidiToHz $thistuning]
					set del [expr $evv(SECS_TO_MS)/$frq]
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd revecho 1 $iiifnam $ofnamc($thischan) $del $segment(DELAYED_SIG_IN_MIX) $segment(FEEDBACK) $segment(DELAY_TAIL)
				}
				VIBRATO {

					if {![GettrofGenerateRandomScatteredParam $vibfrq $indur $segment(notedata)]} {
						set OK2 0
						break
					}
					if {![GettrofGenerateRandomScatteredParam $vibdep $indur $segment(notedata2)]} {
						set OK2 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd speed 6 $iiifnam $ofnamc($thischan) $segment(notedata) $segment(notedata2)
				}
				TREMOLO {

					if {![GettrofGenerateRandomScatteredParam $vibfrq $indur $segment(notedata)]} {
						set OK2 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) tremolo]
					lappend cmd tremolo 1 $iiifnam $ofnamc($thischan) $segment(notedata) $vibdep 1 $narrow

				}
				ZIGACCEL {
					set cmd [file join $evv(CDPROGRAM_DIR) distmore] 
					lappend cmd segszig 2 $iiifnam $ofnamc($thischan) $zigrep
					if {$minzig > 0} {
						lappend cmd -s$minzig
					}
					if {$zigfrc < 1.0} {
						lappend cmd -p$zigfrc
					}
					if {$ziglog} {
						lappend cmd -l
					}
				}
				REVERB {
					set cmd [file join $evv(CDPROGRAM_DIR) modify] 
					lappend cmd revecho 3 $iiifnam $ofnamc($thischan) -g1 -r1 -s$stadsiz -e$echocnt -n
				}
				LOOP {

					set maxloop [expr $indur - (2.0 * $segment(SPLICE))]					;#	param limits in "MODIFY LOOP" program
					set maxloopstart [expr $indur - (2.0 * $segment(SPLICE))]
					set looplen [expr ($indur - $segment(SPLICE)) * $lenprop] 
					if {$looplen < $segment(TWOSPLICE)} {
						set looplen $segment(TWOSPLICE)
					}
					if {$indur <= $segment(TWOSPLICE)} {
						Inf "$msg_type $n TO CREATE LOOPS"
						set OK44 0
						break
					}
					set outdur [expr $indur * $durprop]
					if {$scattrd} {
						if {![CutIterationElement $indur $lenprop $looplen $iiifnam $msg_type $n]} {	;# --> segment(fadesnd)
							set OK44 0
							break
						}
						set delay [expr ($looplen/3.0) * 2.0]									;#	Iterate with delay 2/3 of len and randomisation 0.7 (Delay in secs)
																								;#	so scattering doesn't unoverlap repets: also use pitch and amp scatter
						set cmd [file join $evv(CDPROGRAM_DIR) extend]
						lappend cmd iterate 1 $segment(fadesnd) $ofnamc($thischan) $outdur -d$delay -r0.7 -p0.6 -a0.3 -f0 -g0 -s3
						set normalize 1
					} else {
						if {$looplen > $maxloop} {
							set looplen [expr $maxloop - $evv(FLTERR)]
						}
						if {$looplen < $segment(TWOSPLICE)} {
							set OK44 0
							break
						}
						set loopstart $segment(SPLICE)
						if {$loopstart > $maxloopstart} {
							set loopstart $maxloopstart
						}
						set looplen [expr $looplen * $evv(SECS_TO_MS)]
						set cmd [file join $evv(CDPROGRAM_DIR) extend] 
						lappend cmd loop 2 $iiifnam $ofnamc($thischan) $outdur $loopstart $looplen -l$advance -b
						set normalize 0
					}
				}
				SCAN {

					;#	CREATE ZIGZAG DATA IN segment(notedata)

					if {![GettrofCreateZigdata $indur $sttprop $endprop $durprop $msg_type $n]} {	;#	--> segment(notedata)
						set OK44 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) extend]
					lappend cmd zigzag 2 $iiifnam $ofnamc($thischan) $segment(notedata) -s$segment(MSPLICE)
									
				}
				FORMOVE {
					set zfnam [file rootname $iiifnam]
					append zfnam $evv(ANALFILE_EXT)
					if {[file exists $zfnam] && [catch {file delete $zfnam} zit]} {
						Inf "CANNOT DELETE PREVIOUS INTERMEDIATE ANALYSIS FILE $zfnam : $zit"
						set OK44 0
						break
					}
					set qfnam [file rootname $ofnamc($thischan)]
					append qfnam $evv(ANALFILE_EXT)
					if {[file exists $qfnam] && [catch {file delete $qfnam} zit]} {
						Inf "CANNOT DELETE PREVIOUS INTERMEDIATE ANALYSIS FILE $qfnam : $zit"
						set OK44 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $iiifnam $zfnam -c1024 -o3
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF $msg_type $n"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN SPECTRUM CREATION FOR $msg_type $n"
						catch {unset CDPidrun}
						set OK44 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE SPECTRUM OF $msg_type $n"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK44 0
						break
					}
					if {![file exists $zfnam]} { 
						Inf "NO SPECTRUM OF $msg_type $n CREATED"		
						set OK44 0
						break
					}
			
					if {$transit} {
						if {![DoSegmentDurParse $iiifnam]} {								;#	returns "segment(itemdur)"
							Inf "CANNOT FIND DURATION OF INPUT SEGMENT $msg_type $n"
							set OK44 0
							break
						}
						if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
							Inf "CANNOT DELETE PREVIOUS BRKPOINT FILE $segment(envfil) : $zit"
							set OK44 0
							break
						}
						catch {unset env}
						if {$transit == 1} {
							set line [list 0.0 0]
							lappend env $line
							set line [list $segment(itemdur) $fortrns]
							lappend env $line
						} else {
							set line [list 0.0 $fortrns]
							lappend env $line
							set line [list $segment(itemdur) 0]
							lappend env $line
						}
						if {[catch {open $segment(envfil) "w"} zit]} {
							Inf "CANNOT OPEN ENVELOPE FILE TO CROSSFADE DATA"
							set crosOK 0
							break
						} else {
							foreach line $env {
								puts $zit $line
							}
							close $zit
						}
						set vval $segment(envfil)
					} else {
						set vval $fortrns
					}
					set cmd [file join $evv(CDPROGRAM_DIR) repitch]
					lappend cmd transpose 3 $zfnam $qfnam $vval
				}
				VERGES {
					set atk -1
					if {$segment(phrase)} {
						if {[info exists segment(maxloc,$ifnam)]} {				;#	For phrases, every insegment is worked on
							set atk [expr double($segment(maxloc,$ifnam))/$segment(srate)]
						} else {
							GetVergesMaxsampLocationOther $ifnam $n
							set atk [expr double($segment(maxloc,$ifnam))/$segment(srate)]
						}
					} else {													;#	Otherwise If at first segment and it's a TAIL, VERGE is on tail
						if {!$tuning_head} {									;#	Or Head already-absorbed into tail
							if {[info exists segment(maxloc,$ifnam)]} {
								set atk [expr double($segment(maxloc,$ifnam))/$segment(srate)]
							} else {
								GetVergesMaxsampLocationOther $ifnam $n
								set atk [expr double($segment(maxloc,$ifnam))/$segment(srate)]
							}
						} else {												;#	Otherwise VERGES use associated HEAD file

							if {[info exists segment(maxloc,$hfnam)]} {
								set atk [expr double($segment(maxloc,$hfnam))/$segment(srate)]
							} else {
								GetVergesMaxsampLocationOther $hfnam $n
								set atk [expr double($segment(maxloc,$hfnam))/$segment(srate)]
							}
						}
					}
					if {$atk < 0} {
						append msgfail "NO MAXSAMP LOCATION INFO FOUND FOR FILE $ifnam\n"
						set atk $segment(SPLICE)
					}
					if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
						Inf "CANNOT DELETE PREVIOUS INTERMEDIATE DATA FILE $segment(notedata) : $zit"
						set OK2 0
						break
					}
					if [catch {open $segment(notedata) "w"} zit] {
						Inf "CANNOT OPEN DATA FILE $segment(notedata) TO WRITE VERGE MAXSPOINT FOR $msg_type $n : $zit"
						set OK2 0
						break
					}
					puts $zit $atk
					close $zit
					set cmd [file join $evv(CDPROGRAM_DIR) verges]
					lappend cmd verges $iiifnam $ofnamc($thischan) $segment(notedata) -t$vrgtrns -e$vrgslop -d$vrgdur
					if {$boost} {
						lappend cmd -b
					}
				}
			}

			if {$OK44} {

				;#	PROCESS

				set khk [lsearch $segment(processes) $segment(process)]
				set nam [lindex  $segment(procnames) $khk]
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        RUNNING $nam ON $msg_type $n"
				if [catch {open "|$cmd"} CDPidrun] {
					append msgfail "FAILED TO RUN $nam ON $msg_type $n\n"
					catch {unset CDPidrun}
					set OK44 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO DO $nam WITH $msg_type $n"
					set msg [AddSimpleMessages $msg]
					append msgfail $msg\n
					set OK44 0
					break
				}
				if {$segment(process) == "FORMOVE"} {
					if {![file exists $qfnam]} {
						append msgfail "NO $nam PROCESSED $msg_type $n CREATED\n"
						set OK44 0
						break
					}
				} elseif {![file exists $ofnamc($thischan)]} {
					append msgfail "NO $nam PROCESSED $msg_type $n CREATED\n"
					set OK44 0
					break
				}

				;#	POST PROCESSING PRE-CHANNEL-MERGE

				if {$segment(process) == "REVERB"} {								;#	Reverb process generate stereo output
					if {$htchan > 1} {												;#	If source is a mono channel of a stereo or multichan file		
						if {![GettrofStereoToMono $ofnamc($thischan) $msg_type $n]} {;#	Mix output to mono
							set OK44 0
							break
						}
					} else {
						set segment(stereo_out) 1									;#	Else (input mono) flag stereo output
					}
				}
				if {$segment(process) == "DELRING"} {								;#	Check for overload
					if {![DelringOverloadCheck $ofnamc($thischan) $msg_type $n $cmd]} {
						set OK44 0
						break
					}
				}
				if {$segment(process) == "FORMOVE"} {								;#	Convert to wav, and dovetail
					if {![FormoveSynthTrim $qfnam $ofnamc($thischan) $msg_type $n]} {
						set OK44 0
						break
					}
				}
				incr thischan
			}
		}

		if {!$OK2} {
			set OK 0
			break
		}
		if {!$OK44} {										;#	IF a process fails for 1 segment, still carry on
			if {![MopUp]} {
				set OK 0
				break
			}
			if {$segment(phrase)} {
				incr n
				incr j										;#	1 segment at a time, if phrases
				incr k
			} else {
				if {![MultipleProcessing]} {
					if {$tuning_head} {
						set thistime [lindex $marks [expr $mm - 1]]				;#	If tuning head, Head and tail were to be fused,
						if {$thistime > 0.0} {									;#	so Original HEAD file goes where HEAD would have been	
							set thistime [expr $thistime - $segment(SPLICE)]	
						}
						set line [list $hfnam $thistime 1 1.0]
						lappend mixlines $line
					}
					set thistime [lindex $marks $mm]							;#	Original TAIL file goes where tail goes
					set line [list $ifnam $thistime 1 1.0]
					lappend mixlines $line
				}
				incr mm 2
				incr n 2									;#	Skip to next (iterable) tail
				incr j 2									;#	and next strt and end markers (times) of segments	
				incr k 2
			}
			continue
		}

		set segment(fadesnd) $segment(fadesnd_dflt)
		if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
			Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(fadesnd) : $zit"
			return 0
		}

		if {$thischancnt > 1} {

			;#	IF NECESSARY, RECONSTRUCT THE STEREO OR MULTICHANNEL OUTPUT REQUIRED

			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd interleave
			set thischan 1
			while {$thischan <= $thischancnt} {
				lappend cmd $ofnamc($thischan)
				incr thischan
			}
			lappend cmd $segment(fadesnd)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        MERGING CHANNELS FROM SEGMENT $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO MERGE CHANNELS FROM SEGMENT $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO MERGE CHANNELS FROM SEGMENT $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $segment(fadesnd)]} {
				Inf "NO MERGED-CHANNELS-FILE OF TUNED SEGMENT $n CREATED"
				set OK 0
				break
			}

		} else {
			set segment(fadesnd) $ofnamc(1)
		}

		if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
			Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $ofnam : $zit"
			return 0
		}

		;#	POST PROCESSING POST-CHANNEL-MERGE

		set done_output 0

		;#	TRIMMING OUTPUT SIZE

		if {$segment(process) == "REVERB"} {						;#	If reverbd output too long, curtail to size (with possibly long fade)
			if {![DoSegmentDurParse $segment(fadesnd)]} {
				Inf "CANNOT FIND DURATION OF PROCESSED $msg_type $n"
				set OK 0
				break
			}
			set maxoutdur [expr $indur * $maxdur]
			if {$segment(itemdur) > $maxoutdur} {
				if {$maxoutdur <= [expr $indur + $segment(SPLICE)]} {
					set curstart [expr $maxoutdur - $segment(SPLICE)]
				} else {
					set curstart $indur
				}
				set curend $maxoutdur 

				if {![GettrofCurtailEnd $segment(fadesnd) $ofnam $curstart $curend $msg_type $n]} {
					set OK 0
					break
				}
				set done_output 1
			}
		} else {
			;#	DELRING
			;#	VIBRATO
			;#	SCAN	
			if {$trimtosiz} {								;#	possibly need to trim to size
				if {![DoSegmentDurParse $segment(fadesnd)]} {
					Inf "CANNOT FIND DURATION OF PROCESSED $msg_type $n"
					set OK2 0
					break
				}
				if {$segment(process) == "SCAN"} {
					set required_dur [expr $indur * $durprop]
				} else {
					set required_dur $indur
				}
				if {$segment(itemdur) > $required_dur} {
					set curstart [expr $required_dur - $segment(SPLICE)]
					set curend $required_dur 
					if {![GettrofCurtailEnd $segment(fadesnd) $ofnam $curstart $curend $msg_type $n]} {
						set OK 0
						break
					}
					set done_output 1
				}
			}
		}
		if {!$done_output} {
			if [catch {file rename $segment(fadesnd) $ofnam} zit] {
				Inf "CANNOT RENAME OUTPUT FILE FOR $msg_type $n : $zit"
				set OK 0
				break
			}
		}

		;#	NORMALISING AND CROSSFADING

		if {$normalize} {
			set zOK 1
			while {$zOK} {
				if {[file exists $segment(bakupsnd)] && [catch {file delete $segment(bakupsnd)} zit]} {
					Inf "CANNOT DELETE PRE-EXISTING BACKUP SOUND : $zit\nCANNOT NORMALISE PROCESSED $msg_type $n"
					break
				}
				if [catch {file copy $ofnam $segment(bakupsnd)} zit] {
					Inf "CANNOT BACKUP PROCESSED $msg_type $n : $zit\nCANNOT NORMALISE"
					break
				}
				if {[GettrofDoNormalise $ifnam $ofnam $msg_type $n]} {
					if [catch {file delete $ofnam} zit] {
						Inf "CANNOT DELETE PRE-NORMALISED OUTPUT FOR $msg_type $n : $zit\nCANNOT NORMALISE"
						break
					}
					if [catch {file rename $segment(fadesnd) $ofnam} zit] {
						Inf "CANNOT RENAME NORMALISED OUTPUT FOR $msg_type $n : $zit\nCANNOT NORMALISE"
						if [catch {file rename $segment(bakupsnd) $ofnam} zit] {
							Inf "CANNOT RECOVER ORIGINAL PROCESSED $msg_type $n (AFTER NORMALISATION FAILED) : $zit"
							set OK 0
						}
					}
				} ;#	Else File normalisation fails, keeps original
				break
			}
			if {!$OK} {
				break
			}
		}
		if {$crossfad} {
			set zOK 1
			while {$zOK} {
				if {[file exists $segment(bakupsnd)] && [catch {file delete $segment(bakupsnd)} zit]} {
					Inf "CANNOT DELETE PRE-EXISTING BACKUP SOUND : $zit\nCANNOT NORMALISE PROCESSED $msg_type $n"
					break
				}
				if [catch {file copy $ofnam $segment(bakupsnd)} zit] {
					Inf "CANNOT BACKUP PROCESSED $msg_type $n : $zit\nCANNOT NORMALISE"
					break
				}
				if {![GettrofDoCrossfade $ifnam $ofnam $indur $htchan $msg_type $n]} {
															;#	If file crossfading fails, keeps original
					if [catch {file rename $segment(bakupsnd) $ofnam} zit] {
						Inf "CANNOT RECOVER ORIGINAL PROCESSED $msg_type $n (AFTER CROSSFADE FAILED) : $zit"
						set OK 0
					}
				}
				break
			}
			if {!$OK} {
				break
			}
		}

		;#	REMOVE INTERMEDIATE TEMPORARY FILES

		if {![MopUp]} {
			set OK 0
			break
		}

		set segment(fadesnd) $segment(fadesnd_dflt)

		;# PLACE TRANSFORMED LINE IN MIX
					
		if {[MultipleProcessing]} {
			set kk [expr $segment(recycline) + 1]		;#	mixlines numbered from 0 , segments (used here) from 1
			if {$tuning_head} {
				set line [lindex $segment(mixlines) $segment(recycline)]	;#	This is the (1st) of any HEAD lines, before the TAIL
				set time [lindex $line 1]
				set line [list $ofnam $time $thischancnt 1.0]
				if {[info exists segment(stereo_out)]} {;#	Mono input with reverb produces stereo output	
					set line [list $ofnam $time 2 1.0]
					unset segment(stereo_out)
				} else {
					set line [list $ofnam $time $thischancnt 1.0]
				}
				PhraseLineReinsert $kk $line 1			;#	Reinsert the line, complete with new channel count and poss multichan format
														;#	and delete line AFTER the insertion point (the HEAD position) which is the original TAIL
				set segment(mixlines) [lreplace $segment(mixlines) $kk $kk]
				if {$segment(doublehead)} {				;#	Or if TWO head files replaced, delete 2 files after insertion point
					set segment(mixlines) [lreplace $segment(mixlines) $kk $kk]
					set cnt 2
				} else {
					set cnt 1
				}
				set lexlen [llength $segment(mixlines)]	;#	Line 2 -> Segment 3, contract the list of noexpand markers
				ContractNoexpand [expr $kk + 1] $lexlen $cnt	

			} else {
				if {[info exists segment(stereo_out)]} {						;#	Mono input with reverb produces stereo output	
					set line [lindex $segment(mixlines) $segment(recycline)]
					set time [lindex $line 1]
					set line [list $ofnam $time 2 1.0]	;#	Marked as stereo
					PhraseLineReinsert $kk $line 1
					unset segment(stereo_out)
				} else {
					PhraseLineReinsert $kk $ofnam 0		;#	If tail only, replaces tail-line, which is MONO, so just replace name
				}
			}
		} else {
			if {$tuning_head} {
				set thistime [lindex $marks [expr $mm - 1]]				;#	If tuning head, Head and tail have been fused,
				if {$thistime > 0.0} {									;#	so new file goes where HEAD would have been	
					set thistime [expr $thistime - $segment(SPLICE)]	
				}
			} else {
				set thistime [lindex $marks $mm]		;#	Else new file goes where tail goes
			}
			if {[info exists segment(stereo_out)]} {
				set line [list $ofnam $thistime 2 1.0]
				unset segment(stereo_out)
			} else {
				set line [list $ofnam $thistime 1 1.0]
			}
			lappend mixlines $line
		}

		if {$segment(phrase)} {
			incr n
			incr j										;#	1 segment at a time, if phrases
			incr k
			continue
		}
		incr mm
		if {!$tunehead} {								;#	if NOT also tuning heads (in which case, heads handled above)
			set hfnam $evv(DFLT_OUTNAME)HH$nexthno$evv(SNDFILE_EXT)
			incr nexthno		
			if {[file exists $hfnam]} {					;#	If there's a following HEAD
				set mixtime [expr [lindex $marks $mm] - $segment(SPLICE)]
				set line [list $hfnam $mixtime 1 1.0]
				lappend mixlines $line					;#	Add it to mix
			}
		}
		incr mm
		incr n 2									;#	Skip to next (iterable) tail
		incr j 2									;#	and next strt and end markers (times) of segments	
		incr k 2
	}
	if {[string length $msgfail] > 0} {
		Inf "$msgfail"
	}
	if {!$OK} {
		UnBlock
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		return 0
	} else {
		if {$segment(process) == "ZIGACCEL"} {
			if {[info exists segment(recycprocess)]} {
				set newmixlines [RespaceMixForZigAccel $segment(mixlines) 1]
				if {[string length $newmixlines] <= 0} {
					Inf "CANNOT RESPACE THE OUTPUT FOR ZIGACCEL"
				} else {
					set segment(mixlines) $newmixlines
				}
			} else {
				set newmixlines [RespaceMixForZigAccel $mixlines 0]
				if {[string length $newmixlines] <= 0} {
					Inf "CANNOT RESPACE THE OUTPUT FOR ZIGACCEL"
				} else {
					set mixlines $newmixlines
				}
			}
			set segment(expand) 0
		}
		if {$segment(multiproccnt)} {				;#	With a multiprocess, we don't mix until we reach end
			UnBlock
			return 1
		}
	}
	if {[info exists segment(recycprocess)]} {
		set mixlines $segment(mixlines)				;#	If a 2nd process, get the reconfigureed mixlines
	} else {
		set segment(mixlines) $mixlines				;#	If a 1st process, keep the original mixlines (for possible later reconfiguring)
	}
	if {$segment(expand) && !$segment(noexpand)} {
		if {![ExpandPhraseMix 1]} {
			Inf "CANNOT EXPAND THE SEGMENT STRING AS REQUESTED"
		} else {
			set mixlines $segment(mixlines)
		}
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}

	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit

	if {![GettrofPossiblyMultichanMixdown 1]} {			;#	Some of these programs may produce extended tails which overlay other segs, so may overload
		if {[info exists segment(recycprocess)]} {		;#	Output may also be multichan, if Heads are also processed
			set segment(mixlines) $segment(origmixlines)
			set OK 0
		}
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	set segment(reordered) 0
	return 1
}

#--- Resynth and dovetail output from FORMOVE

proc FormoveSynthTrim {ifnam ofnam msg_type n} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun overload_line

	set gain 1.0
	set wfnam [file rootname $segment(premix)]
	append wfnam $evv(ANALFILE_EXT)
	set OK 0
	set iifnam $ifnam
	while {!$OK} {
		if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
			Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(exclmix) TO RESYNTH FORMANT MOVED $msg_type $n"
			return 0
		}

		;#	CREATE WAVEFORM OF FORMANT-MOVED SEGMENT

		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd synth $iifnam $segment(exclmix)
		set prg_dun 0
		set prg_abortd 0
		catch {unset overload_line}
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF FORMANT-MOVED $msg_type $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN WAVEFORM CREATION FOR FORMANT-MOVED $msg_type $n"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "GetPostVocodeOverloadLine"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE WAVEFORM OF FORMANT-MOVED $msg_type $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $segment(exclmix)]} {
			Inf "NO WAVEFORM OF FORMANT-MOVED $msg_type $n CREATED"
			return 0
		}

		;#	CHECK FOR OVERLOAD

		if {[info exists overload_line]} {
			set nugain [VocodeResynthOverloaded]
			if {$nugain >= $gain} {
				set OK 1
				break
			}

			;#	IF OVERLOADED, REDUCE LEVEL OF ANALSIS FILE

			if {[file exists $wfnam] && [catch {file delete $wfnam} zit]} {
				Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $wfnam TO ATTENUATE FORMANT MOVED $msg_type $n"
				return 0
			}
			set cmd [file join $evv(CDPROGRAM_DIR) spec] 
			lappend cmd gain $ifnam $wfnam $nugain
			set prg_dun 0
			set prg_abortd 0
			catch {unset overload_line}
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        ATTENUATING FORMANT-MOVED $msg_type $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN ATTENUATION OF FORMANT-MOVED $msg_type $n"
				catch {unset CDPidrun}
				return 0
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE ATTENUATED FORMANT-MOVED $msg_type $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				return 0
			}
			if {![file exists $wfnam]} {
				Inf "NO ATTENUATED FORMANT-MOVED $msg_type $n CREATED"
				return 0
			}

			;#	AND USE REDUCED-LEVEL ANALFILE AS INPUT TO RESYNTH

			set iifnam $wfnam

		} else {
			set OK 1
		}
	}

	;#	NOW DOVETAIL THE WAV OUTPUT

	set cmd [file join $evv(CDPROGRAM_DIR) envel]
	lappend cmd dovetail 1 $segment(exclmix) $ofnam $segment(SPLICE) $segment(SPLICE) 1 1 -t0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        DOVETAILING FORMANT-MOVED $msg_type $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO DOVETAIL FORMANT-MOVED $msg_type $n"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE DOVETAILED FORMANT-MOVED $msg_type $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO DOVETAILED FORMANT-MOVED $msg_type $n CREATED"
		return 0
	}
	return 1
}

#--- MIDI Kbbd entry of pitches for Delay-feedback process

proc DelRingStyle {} {
	global segment pr_delringstyl evv ocl tunehead crosfadd tv_active
	if {!$tv_active} {
		Inf "CANNOT USE THIS OPTION WITHOUT A CONNECTED MIDI KEYBOARD AND THE PROGRAM \"TV\""
		return 0
	}
	set f .delringstyl
	NumberOfSegmentsToBeTuned DELRING

	if [Dlg_Create $f "PRESET PITCHES FOR DELAY RING" "set pr_delringstyl 0" -height 20 -borderwidth $evv(SBDR)] {
		
		label $f.00 -text "Enter PITCHES from MIDI keyboard" -width 50 -fg $evv(SPECIAL)
		pack $f.00 -side top -pady 2
		frame $f.0
		label $f.0.ll -text "$segment(tuningcnt) NOTES" -width 10
		button $f.0.s -text "Use Pitches"  -command "set pr_delringstyl 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_delringstyl 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_delringstyl 0" -width 8
		pack $f.0.ll $f.0.s $f.0.s $f.0.s $f.0.l $f.0.h -side left -padx 2
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		set ff [frame $f.1.1]
		GettrofMakeKeyboardKey $ff
		bind $ff.0   <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.0 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.1 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.2 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.3 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.4 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.5 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.1.6 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.0 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.1 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.2 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.3 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.4 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.5 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.2.6 <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		bind $ff.3   <ButtonPress-1> "GettrofGetNoteData 0 $ff.1.1"
		checkbutton $f.1.2  -text "Tune Head also" -variable tunehead -width 16
		checkbutton $f.1.3  -text "Crossfade into" -variable crosfadd -width 16
		set tunehead 0
		pack $f.1.1 $f.1.2 $f.1.3 -side left -padx 4
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_delringstyl 1}
		bind $f <Escape> {set pr_delringstyl 0}
	}
	if {$segment(phrase)} {
		$f.1.2 config -state disabled -disabledforeground []		;#	No Head/Tail pairs to fuse
	} else {
		$f.1.2 config -state normal
	}
	.delringstyl.0.ll config -text "$segment(tuningcnt) NOTES"
	catch {unset segment(pitches)}
	set pr_delringstyl 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_delringstyl
	while {!$finished} {
		tkwait variable pr_delringstyl
		switch -- $pr_delringstyl {
			1 {
				if {![info exists segment(pitches)] || ([llength $segment(pitches)] <= 0)} {
					Inf "NO PITCHES SET"
					continue
				}
				set segment(control1,DELRING) $segment(pitches)	;#	Stored as time-variable param, so it can be saved to a patch
				set segment(par0) $tunehead						;#	Derived from entry-button in interface		
				set segment(PAR0) $segment(par0)				;#	None of these accessible on interface
				set segment(lastpar0,DELRING) $segment(par0)	;#	So also setup "lastpar" value here
				set segment(par1) $crosfadd						;#	Derived from entry-button in interface		
				set segment(PAR1) $segment(par1)				;#	None of these accessible on interface
				set segment(lastpar1,DELRING) $segment(par1)	;#	So also setup "lastpar" value here
				set finished 1
			}
			2 {									;#	GO TO LOAD A PATCH
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {									;#	ABANDON
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#--- Enter "Boost" setting for VERGES or "Telescope" setting for DISTREP or etc...

proc VergesStyle {} {
	global segment pr_vergstyl evv boost
	set f .vergstyl
	switch -- $segment(process) {
		"VERGES"  { set nam "PRESET PARAMETERS FOR VERGES" }
		"DISTREP" { set nam "PRESET PARAMETERS FOR WAVESET REPEAT" }
		"TREMOLO" { set nam "PRESET PARAMETERS FOR TREMOLO" }
		"REVERB"  { set nam "PRESET PARAMETERS FOR REVERB" }
		"LOOP"	  {	set nam "PRESET PARAMETERS FOR LOOP" }
	}
	if [Dlg_Create $f $nam "set pr_vergstyl 0" -width 40 -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_vergstyl 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_vergstyl 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_vergstyl 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		checkbutton $f.1  -text "Boost Verge Level" -variable boost -width 18
		set boost 1
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_vergstyl 1}
		bind $f <Escape> {set pr_vergstyl 0}
	}
	switch -- $segment(process) {
		"VERGES"  { $f.1 config -text "Boost Verge Level" } 
		"DISTREP" { $f.1 config -text "Telescope Output" }
		"TREMOLO" { $f.1 config -text "Crossfade into" }
		"REVERB"  { $f.1 config -text "Crossfade into" }
		"LOOP"	  { $f.1 config -text "Scattered Loop" }
	}
	;#	IF NO PREVIOUS CALL TO FUNCTION, OR FUNCTION CALLED WITH DIFFERENT PROCESS

	if {![info exists segment(last_vergepreset_process)] || ($segment(last_vergepreset_process) != $segment(process))} {

		#	GOTO LAST VAL FOR PROCESS, OR, IF NONE EXISTS, TO DEFAULT

		if {[info exists segment(lastpar0,$segment(process))]} {
			set boost $segment(lastpar0,$segment(process))
		} else {
			switch --  $segment(process) {
				"VERGES" -
				"DISTREP" {
					set boost 1
				}
				"TREMOLO" -
				"REVERB"  -
				"LOOP" {
					set boost 0
				}
			}
		}
	}
	set pr_vergstyl 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_vergstyl
	while {!$finished} {
		tkwait variable pr_vergstyl
		switch -- $pr_vergstyl {
			1 {
				set segment(par0) $boost
				set segment(PAR0) $boost
				set segment(lastpar0,$segment(process)) $segment(par0)
				set segment(last_vergepreset_process) $segment(process)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

#--- Enter "Preset params for FORMOVE...

proc FormoveStyle {} {
	global segment pr_formov evv tunehead
	set f .formov
	if [Dlg_Create $f "PRESET PARAMETERS FOR \"MOVE FORMANTS\"" "set pr_formov 0" -width 40 -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_formov 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_formov 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_formov 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		checkbutton $f.1.hd -text  "Use Head also" -variable tunehead -width 18
		radiobutton $f.1.fno -text "All transposed"			 -variable segment(par1) -value 0 -width 16
		radiobutton $f.1.fto -text "Transit to transposed"	 -variable segment(par1) -value 1 -width 26
		radiobutton $f.1.ffr -text "Transit from transposed" -variable segment(par1) -value 2 -width 26
		pack $f.1.hd $f.1.fno $f.1.fto $f.1.ffr -side left
		pack $f.1 -side top -pady 4
		set segment(par1) -1
		set tunehead 0
		wm resizable $f 0 0
		bind $f <Return> {set pr_formov 1}
		bind $f <Escape> {set pr_formov 0}
	}
	if {$segment(phrase)} {
		set tunehead 0 
		$f.1.hd config -text "" -state disabled -disabledforeground []			;#	No Head/Tail pairs to fuse
	}
	set pr_formov 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_formov
	while {!$finished} {
		tkwait variable pr_formov
		switch -- $pr_formov {
			1 {
				if {$segment(par1) < 0} {
					Inf "NO TRANSIT TYPE SPECIFIED"
					continue
				}
				set segment(par0) $tunehead
				set segment(PAR0) $tunehead
				set segment(lastpar0,FORMOVE) $segment(par0)
				set segment(PAR1) $segment(par1)
				set segment(lastpar1,FORMOVE) $segment(par1)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

#--- Removes any files related to channel-extraction from multichan source
#--- and any previous outputfile that has been superceded

proc MopUp {} {
	global segment evv
	set fils 1
	if [catch {glob $evv(DFLT_OUTNAME)*}] {
		set fils 0
	}
	if {$fils} {
		foreach zzfnam [glob $evv(DFLT_OUTNAME)*] {		;#	Assemble names of all temporary files 
			lappend prelist $zzfnam						;#	which includes mono_chans, ana, tuned_ana and tuned_wav files (as well as textfiles) 
		}
	}
	set fils 1
	if [catch {glob $evv(MACH_OUTFNAME)*}] {
		set fils 0
	}
	if {$fils} {
		foreach zzfnam [glob $evv(MACH_OUTFNAME)*] {
			lappend prelist $zzfnam
		}
	}
	if {[info exists prelist]} {
		foreach zzfnam $prelist {						;#	and choose all of then that have "_cN" tails.
			if {[string first "_c" $zzfnam] > 0} {
				lappend dellist $zzfnam					;#	or _xxx tails
			} elseif {[string first "_xxx" $zzfnam] > 0} {
				lappend dellist $zzfnam
			}
		}
	}
	if {[file exists $segment(exclmix)]} {			;#	If the input file had to be renamed, add to list.
		lappend dellist $segment(exclmix)
	}
	if {[info exists dellist]} {
		foreach delfnam $dellist {
			if [catch {file delete $delfnam} zit] {
				Inf "CANNOT DELETE INTERMEDIATE FILE $delfnam"
				return 0
			}
		}
	}
	return 1
}

#--- Take a fixed param and scatter value through time, writing to a brkpnt file

proc GettrofGenerateRandomScatteredParam {inval indur fnam} {
	global segment
	set sum 0.0
	set times [list $sum]
	while {$sum < $indur} {
		set step [expr rand() * 0.1]			;#	Generate steps between 0.1 and 0,2 secs long
		set step [expr $step + 0.1]
		set sum [expr $sum + $step]
		lappend times $sum
	}
	set len [llength $times]
	set inrang [expr $inval/4.0]
	set minval [expr $inval - $inrang]
	set maxval [expr $inval + $inrang]
	set inrang [expr $maxval - $minval]
	set n 0
	while {$n < $len} {
		set val [expr rand() * $inrang]
		set val [expr $val + $minval]
		lappend vals $val
		incr n
	}
	foreach time $times val $vals {
		set line [list $time $val]
		lappend lines $line
	}
	if {[file exists $fnam] && [catch {file delete $fnam} zit]} {
		Inf "CANNOT DELETE EXISTING DATA FILE $fnam" : $zit"
		return 0
	}
	if [catch {open $fnam "w"} zit] {
		Inf "CANNOT OPEN FILE $fnam TO WRITE JITTERED PARAM" : $zit"
		return 0
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	return 1
}

#--- Find how many zigs+zags needed to generate required duration

proc GettrofCreateZigdata {indur sttprop endprop durprop msg_typ n} {
	global segment

	;#	TRY TO FORCE ZIGS TO BE INSIDE THE OUTER SPLICES

	if {$indur <= $segment(TWOSPLICE)} {
		Inf "$msg_typ $n TOO SHORT FOR ZIGS"
		return 0
	}
	if {$endprop < $sttprop} {
		set temp $endprop
		set endprop $sttprop
		set sttprop $temp
	}
	set outdur [expr $indur * $durprop]
	set startzig [expr (($indur - $segment(TWOSPLICE)) * $sttprop) + $segment(SPLICE)]		;#	Use indur minus 2 outer splice lengths
	set endzig   [expr (($indur - $segment(TWOSPLICE)) * $endprop) + $segment(SPLICE)]
	if {[expr $endzig - $startzig] < $segment(TWOSPLICE)} {
		set startzig [expr (($indur - $segment(SPLICE)) * $sttprop) + $segment(SPLICE)]		;#	Use indur minus 1 outer splice lengths
		set endzig   [expr (($indur - $segment(SPLICE)) * $endprop) + $segment(SPLICE)]
		if {[expr $endzig - $startzig] < $segment(TWOSPLICE)} {
			set startzig [expr ($indur * $sttprop)]											;#	Use indur
			set endzig   [expr ($indur * $endprop)]
			if {[expr $endzig - $startzig] < $segment(TWOSPLICE)} {
				set startzig [expr ($indur * $sttprop)]										;#	Use start of zig and a double splicelen
				set endzig [expr $startzig + $segment(TWOSPLICE)]
				if {$endzig >= $indur} {
					set startzig 0.0														;#	Use start of seg and a double splicelen 
					set endzig $segment(TWOSPLICE)
				}
			}
		}
	}
	
	set ziglen [expr $endzig - $startzig]

	;#	COUNT NUMBER OF ZIGS REQUIRED

	set effective_ziglen [expr $ziglen - $segment(SPLICE)]
	set zigcnt 0
	set zigoutdur $startzig
	while {$zigoutdur <= $outdur} {
		set zigoutdur [expr $zigoutdur + $effective_ziglen]
		incr zigcnt
	}
	;#	CREATE ZIGZAG DATA

	set iszag 0
	set zigs [list 0]
	set z 0
	while {$z < $zigcnt} {
		if {$iszag} {
			lappend zigs $startzig
		} else {
			lappend zigs $endzig
		}
		set iszag [expr !$iszag]
		incr z
	}
	lappend zigs $indur
	if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
		Inf "CANNOT DELETE PREVIOUS INTERMEDIATE DATA FILE $segment(notedata) : $zit"
		return 0
	}
	if [catch {open $segment(notedata) "w"} zit] {
		Inf "CANNOT OPEN SCAN DATA FILE $segment(notedata) : $zit"
		return 0
	}
	foreach zig $zigs {
		puts $zit $zig
	}
	close $zit
	return 1
}

#--- Cut start part of segment, to Iterate --> segment(fadesnd)

proc CutIterationElement {indur lenprop looplen iiifnam msg_type n} {
	global segment evv prg_dun prg_abortd CDPidrun simple_program_messages

	;#	CURTAIL FROM START TO REQUIRED SIZE

	set (fadesnd) $segment(fadesnd_dflt)
	if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
		Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(fadesnd) : $zit"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) envel] 
	lappend cmd curtail 1 $iiifnam $segment(fadesnd) [expr $looplen - $segment(SPLICE)] $looplen 0 -t0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        CUTTING LOOP ELEMENT FROM $msg_type $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN CUTTING OF LOOP ELEMENT FROM $msg_type $n"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CUT LOOP ELEMENT FROM $msg_type $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(fadesnd)]} {
		Inf "NO LOOP ELEMENT CUT FROM $msg_type $n CREATED"
		return 0
	}
	return 1
}

#--- Find where maxsamps occur, in Heads (or first 1/5 of H/T fusion) 

proc GetVergesMaxsampLocations {} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId
	if {$segment(phrase)} {
		set ishead 1
	} else {
		set ishead 0
		if {$segment(headfirst)} {
			set ishead 1
		}
	}
	set msgfail ""
	set hcnt 1
	set tcnt 1
	set n 1
	while {$n <= $segment(cnt)} {
		if {$ishead} {
			if {[MultipleProcessing]} {
				if {$segment(multiproccnt)} {
					if {[lindex $segment(actionlist) $n] == 0} {
						incr n												;#	IF no action required								
						incr hcnt
						if {!$segment(phrase)} {							;#	Skip to next seg
							set ishead [expr !$ishead]
						}
						continue
					}
				}
				set headdata [FindRelevantHeadFileForRetimeAndVerges $hcnt]	;#	Look in existing mixdata for relevant HEAD file
				set headline [lindex $headdata 1]
				incr hcnt
				if {$headline >= 0} {
					set ifnam [lindex $headdata 0]							;#	Found head in mixfile, remember it
					lappend ifnamdata [list $ifnam $n H]
				} else {													;#	But if no HEAD file found in mixlines	
					if {$segment(phrase)} {									
						incr n												;#	Phrases are ALL Heads
						continue											;#	so Skip to next entry

					} else {												;#	With H/T data, tailfile could have absorbed head
						set ishead [expr !$ishead]							;#	so look for following tail
						set taildata [FindRelevantTailFileForRetime	$tcnt]
						set tailline [lindex $taildata 1]
						incr tcnt
						if {$tailline >= 0} {								;#	If tail found
							set ifnam [lindex $taildata 0]					;#	Use tail instead of Head
							lappend ifnamdata [list $ifnam $n T]
						} else {											;#	Otherwise					
							set ishead [expr !$ishead]						;#	Go back to Heads
							incr n											;#	and Skip to next entry
							continue
						}
					}
				}
			} else {														;#	IF not a multiprocess
				set ifnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)		;#	capture original Head
				lappend ifnamdata [list $ifnam $n H]
				incr hcnt
			}
		} else {															;#	If a tail, (can't be a phrase) 
			if {$n == 1} {													;#	IF tail at start of sound, find a place to place attack
				set ifnam ""
				if {[MultipleProcessing]} {
					if {[GetRecycledSegment $tcnt TAIL]} {
						set ifnam $segment(iifnam)
					}
				} else {
					set ifnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
				}
				if {[string length $ifnam] > 0} {
					lappend ifnamdata [list $ifnam $n T]
				}
			}																;#	else, skip it
			incr tcnt																			
		}
		if {!$segment(phrase)} {											;#	Phrases are ALL Heads
			set ishead [expr !$ishead]
		}
		incr n
	}

	foreach dataitem $ifnamdata {
		set ifnam [lindex $dataitem 0]
		set n     [lindex $dataitem 1]
		set typ   [lindex $dataitem 2]

		wm title .blocker "PLEASE WAIT:        FINDING MAXLEVEL LOCATION OF HEAD SEGMENT $n"

		set OK 1
		if {![DoSegmentDurParse $ifnam]} {
			append msgfail "FAILED TO FIND DURATION OF SEGMENT $n\n"		;#	If its duration can't be found,
			set loc [expr int(ceil($segment(SPLICE) * $segment(srate)))]	;#	Default location to end of opening splice
		} elseif {$segment(phrase) || ($typ == "T")} {						;#	If the item to be processed is a full tail (or a complete phrase)
			while {$OK} {
				set gotatk 0 
				set endsearch [expr $segment(itemdur)/5.0]						;#	Otherwise, look for max in first 1/5th of H+T segment (or phrase)
				if {$endsearch < $segment(TWOSPLICE)} {
					set endsearch $segment(TWOSPLICE)
				}
				catch {unset maxsamp_line}
				set done_maxsamp 0
				set cmd [file join $evv(CDPROGRAM_DIR) sndinfo]
				lappend cmd maxsamp2 $ifnam 0.0 $endsearch 
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'sndinfo maxsamp2' TO FIND MAXLEVEL LOCATION OF HEAD PORTION OF SEGMENT $n"
					break
	   			} else {
	   				fileevent $CDPmaxId readable "Get_Maxsamp_Info_Segment"
				}
	 			vwait done_maxsamp
				if {[info exists maxsamp_line]} {
					foreach line $maxsamp_line {
						if {[string first "at:" $line] >= 0} {
							set line [split $line]
							foreach item $line {
								if {[string length $item] <= 0} {
									continue
								}
								if {[IsNumeric $item]} {
									set loc $item
									set gotatk 1
									break
								}
							}
						}
						if {$gotatk} {
							break
						}
					}
				}
				break
			}
			if {!$gotatk} {
				append msgfail "CANNOT RETRIEVE MAXLEVEL LOCATION OF HEAD PORTION OF SEGMENT $n\n"
				set loc [expr int(round(($segment(itemdur)/2.0) * $segment(srate)))]	;#	Default location halfway through segment
			}
		} else {																;#	Otherwise look for maximum in associated Head	
			
			while {$OK} {
				catch {unset maxsamp_line}
				set done_maxsamp 0
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				lappend cmd $ifnam
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' TO FIND MAXLEVEL LOCATION OF HEAD SEGMENT $n"
					set loc [expr int(round(($segment(itemdur)/2.0) * $segment(srate))))]	;#	Default location halfway through segment
					break
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {[info exists maxsamp_line] && ([lindex $maxsamp_line 0] > 0.0)} {
					set loc [lindex $maxsamp_line 1]
				} else {
					append msgfail "CANNOT RETRIEVE MAXLEVEL LOCATION OF SEGMENT $n\n"
					if {![DoSegmentDurParse $ifnam]} {
						append msgfail "FAILED TO FIND DURATION OF SEGMENT $n\n"
						set loc [expr int(ceil($segment(SPLICE) * $segment(srate)))]			;#	Default location to end of opening splice
					} else {
						set loc [expr int(round(($segment(itemdur)/2.0) * $segment(srate))))]	;#	Default location halfway through segment
					}
				}
				break
			}
		}
		set segment(maxloc,$ifnam) $loc
	}
	if {[string length $msgfail] > 0} {
		Inf $msgfail
	}
}

#--- Maxsamp location where H+T have been pre-merged by another process

proc GetVergesMaxsampLocationOther {ifnam n} {
	global evv segment maxsamp_line done_maxsamp CDPmaxId
	if {![DoSegmentDurParse $ifnam]} {
		append msgfail "FAILED TO FIND DURATION OF MERGED HEAD/TAIL $n\n"	;#	If its duration can't be found,
		set loc [expr int(ceil($segment(SPLICE) * $segment(srate)))]		;#	Default location to end of opening splice
	} else {
		set endsearch [expr $segment(itemdur)/5.0]						;#	Otherwise, look for max in first 1/5th of H+T segment (or phrase)
		if {$endsearch < $segment(TWOSPLICE)} {
			set endsearch $segment(TWOSPLICE)
		}
		catch {unset maxsamp_line}
		set done_maxsamp 0
		set gotatk 0
		while {!$gotatk} {
			set cmd [file join $evv(CDPROGRAM_DIR) sndinfo]
			lappend cmd maxsamp2 $ifnam 0.0 $endsearch 
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "FAILED TO RUN 'sndinfo maxsamp2' TO FIND MAXLEVEL LOCATION OF HEAD PORTION OF MERGED HEAD/TAIL $n"
				break
	   		} else {
	   			fileevent $CDPmaxId readable "Get_Maxsamp_Info_Segment"
			}
	 		vwait done_maxsamp
			set gotatk 0
			if {[info exists maxsamp_line]} {
				foreach line $maxsamp_line {
					if {[string first "at:" $line] >= 0} {
						set line [split $line]
						foreach item $line {
							if {[string length $item] <= 0} {
								continue
							}
							if {[IsNumeric $item]} {
								set loc $item
								set gotatk 1
								break
							}
						}
					}
					if {$gotatk} {
						break
					}
				}
			}
			break
		}
		if {!$gotatk} {
			append msgfail "CANNOT RETRIEVE MAXLEVEL LOCATION OF MERGED HEAD/TAIL $n\n"
			set loc [expr int(ceil($segment(SPLICE) * $segment(srate)))]		;#	Default location to end of opening splice
		}
	}		
	set segment(maxloc,$ifnam) $loc
}

#--- Convert stereo output of REVERB to mono, for single chans of multichan srcs

proc GettrofStereoToMono {ooofnam msg_type n} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
		Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $segment(exclmix) : $zit"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 4 $ooofnam $segment(exclmix)
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING CHANNELS MERGE ON PROCESSED $msg_type $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN CHANNELS MERGE ON PROCESSED $msg_type $n"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO MERGE CHANNELS OF PROCESSED $msg_type $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(exclmix)]} {
		Inf "NO MERGED CHANNEL VERSION OF PROCESSED $msg_type $n CREATED"
		return 0
	}
	if [catch {file delete $ooofnam} zit] {
		Inf "CANNOT DELETE INTERMEDIATE FILE $ooofnam: $zit"
		return 0
	}	
	if [catch {file rename $segment(exclmix) $ooofnam} zit] {
		Inf "CANNOT RENAME INTERMEDIATE FILE $segment(exclmix): $zit"
		return 0
	}
	return 1
}

#---- Trim off ends of output from Gettrof_Other

proc GettrofCurtailEnd {ifnam ofnam curstart curend msg_type n} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	set cmd [file join $evv(CDPROGRAM_DIR) envel]
	lappend cmd curtail 1 $ifnam $ofnam $curstart $curend 0 -t0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        CURTAILING PROCESSED $msg_type $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN CURTAILING ON PROCESSED $msg_type $n"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CURTAIL PROCESSED $msg_type $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO CURTAILED PROCESSED $msg_type $n CREATED"
		return 0
	}
	return 1
}

#---- Trim level of item

proc GettrofSegmentLevel {ifnam n} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId

	wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SEGMENT $n"
	set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
	lappend cmd $ifnam
	catch {unset maxsamp_line}
	set done_maxsamp 0
	if [catch {open "|$cmd"} CDPmaxId] {
		Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR SEGMENT $n"
		return -1
	} else {
	   	fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
	}
	vwait done_maxsamp
	if {![info exists maxsamp_line]} {
		Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF SEGMENT $n"
		return -1
	}
	set level [lindex $maxsamp_line 0]
	if {$level <= 0.0} {
		Inf "SEGMENT $n HAS ZERO LEVEL"
		return -1
	}
	return $level
}

#---- Adjust level of Gettrof_Other output to levl of input

proc GettrofDoNormalise {ifnam ofnam msg_type n} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	set inlevel [GettrofSegmentLevel $ifnam $n]
	if {$inlevel < 0.0} {
		Inf "CANNOT FIND LEVEL OF INPUT $msg_type $n : CANNOT NORMALISE TRANSFORMED OUTPUT"
		return 0
	}
	set outlevel [GettrofSegmentLevel $ofnam $n]
	if {$outlevel < 0.0} {
		Inf "CANNOT FIND LEVEL OF OUTPUT $msg_type $n : CANNOT NORMALISE"
		return 0
	}
	if {$outlevel <= $inlevel} {
		return 0
	}
	set segment(fadesnd) $segment(fadesnd_dflt)
	if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit\nCANNOT NORMALISE OUTPUT $msg_type $n"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) modify]
	lappend cmd loudness 4 $ofnam $segment(fadesnd) -l$inlevel
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        NORMALISING PROCESSED $msg_type $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO NORMALISE PROCESSED $msg_type $n"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO NORMALISE PROCESSED $msg_type $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(fadesnd)]} {
		Inf "NO NORMALISED VERSION OF $msg_type $n CREATED"
		return 0
	}
	return 1
}

#--- Crossfade from input to output for Gettrof_Other

proc GettrofDoCrossfade {ifnam ofnam indur chancnt msg_type n} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	set crossfade_possible 1
	set iifnam $ifnam
	if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(exclmix) : $zit\nCANNOT CROSSFADE OUTPUT $msg_type $n"
		return 0
	}
	if {$segment(process) == "TREMOLO"} {					;#	First, attempt crossfade via enveloped mix
		set donenv 0
		while {!$donenv} {
			set segment(fadesnd) $segment(fadesnd_dflt)
			if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit\n"
				break
			}
			if {[file exists $segment(premix)] && [catch {file delete $segment(premix)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(premix) : $zit\n"
				break
			}
			if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE ENVELOPE FILE $segment(envfil) : $zit\n"
				break
			}
			set halfdur [expr $indur/2.0] 
			set line [list 0.0 1.0]
			lappend lines $line
			set line [list $halfdur 0.0]
			lappend lines $line
			set line [list $indur 0.0]
			lappend lines $line
			if [catch {open $segment(envfil) "w"} zit] {
				Inf "CANNOT OPEN INTERMEDIATE ENVELOPE FILE $segment(envfil) : $zit\n"
				break
			}
			foreach line $lines {
				puts $zit $line
			}
			close $zit
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $ifnam $segment(fadesnd) $segment(envfil)		;#	Envelope infile1
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        ENVELOPING $ifnam"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO ENVELOPE $ifnam"
				catch {unset CDPidrun}
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO ENVELOPE $ifnam"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				break
			}
			if {![file exists $segment(fadesnd)]} {
				Inf "NO ENVELOPED VERSION OF $ifnam $n CREATED"
				break
			}
			if [catch {file delete $segment(envfil)} zit] {
				Inf "CANNOT DELETE (2) INTERMEDIATE ENVELOPE FILE $segment(envfil) : $zit\n"
				break
			}
			unset lines
			set line [list 0.0 0.0]
			lappend lines $line
			set line [list $halfdur 1.0]
			lappend lines $line
			set line [list $indur 1.0]
			lappend lines $line
			if [catch {open $segment(envfil) "w"} zit] {
				Inf "CANNOT REOPEN INTERMEDIATE ENVELOPE FILE $segment(envfil) : $zit\n"
				break
			}
			foreach line $lines {
				puts $zit $line
			}
			close $zit
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $ofnam $segment(premix)	$segment(envfil)				;#	Envelope ofil
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        ENVELOPING $ofnam"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO ENVELOPE $ofnam"
				catch {unset CDPidrun}
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO ENVELOPE $ofnam"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				break
			}
			if {![file exists $segment(premix)]} {
				Inf "NO ENVELOPED VERSION OF $ofnam CREATED"
				break
			}
			if {[file exists $segment(mixdata)] && [catch {file delete $segment(mixdata)]} zit]} {
				Inf "CANNOT DELETE (3) INTERMEDIATE MIXFILE $segment(mixdata) : $zit\n"
				break
			}
			if {[MultipleProcessing]} {
				set chans $segment(iichan)
			} else {
				set chans 1
			}
			unset lines
			set line [list $segment(fadesnd) 0.0 $chans 1.0]
			lappend lines $line
			set line [list $segment(premix) 0.0 $chans 1.0]
			lappend lines $line
			if [catch {open $segment(mixdata) "w"} zit] {
				Inf "CANNOT OPEN INTERMEDIATE MIXFILE $segment(mixdata) : $zit\n"
				break
			}
			foreach line $lines {
				puts $zit $line
			}
			close $zit
			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd mix $segment(mixdata) $segment(exclmix)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CROSSFADING PROCESSED $msg_type $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO CROSSFADING PROCESSED $msg_type $n"
				catch {unset CDPidrun}
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CROSSFADE PROCESSED $msg_type $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				break
			}
			if {![file exists $segment(exclmix)]} {
				Inf "NO CROSSFADED PROCESSED $msg_type $n CREATED"
				break
			}
			set donenv 1
			break
		}
		if {$donenv} {
			if [catch {file delete $ofnam} zit] {						;#	Name of (input) ofnam needed for output of crossfade
				Inf "CANNOT DELETE INTERMEDIATE FILE $ofnam: $zit"
				set donenv 0
			} else {
				if [catch {file rename $segment(exclmix) $ofnam} zit] {	;#	Name of (input) ofnam needed for output of crossfade
					Inf "CANNOT RENAME PROCESSED $msg_type $n AFTER CROSSFADING : $zit"
					return 0											;#	As we've deleted orig input, project fails, return 0
				} else {
					return 1											;#	This crossfade type succeeded, RETURN 1		
				}
			}		
		}
		if {!$donenv} {													;#	If this crossfade failed, prepare to do simpler crossfade below
			if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(exclmix) : $zit\nCANNOT CROSSFADE OUTPUT $msg_type $n"
				set crossfade_possible 0
			}
		}
	} elseif {$segment(process) == "REVERB"} {
		if {$chancnt == 1} {											;#	Input is Mono, REVERB output is Stereo
			set crossfade_possible 1
			while {$crossfade_possible} {
				set segment(fadesnd) $segment(fadesnd_dflt)
				if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
					Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit\nCANNOT CROSSFADE OUTPUT $msg_type $n"
					set crossfade_possible 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 5 $ifnam $segment(fadesnd)			;#	Convert infile to stereo, before attempting crossfade
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CONVERTING $msg_type $n TO STEREO"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN PROCESS TO CONVERT $msg_type $n TO STEREO : CANNOT DO CROSSFADE"
					catch {unset CDPidrun}
					set crossfade_possible 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CONVERT $msg_type $n TO STEREO : CANNOT DO CROSSFADE"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set crossfade_possible 0
					break
				}
				if {![file exists $segment(fadesnd)]} {
					Inf "NO STEREO VERSION OF $msg_type $n CREATED : CANNOT DO CROSSFADE"
					set crossfade_possible 0
					break
				}
				break
			}
			if {$crossfade_possible} {
				if [catch {file rename $ofnam $segment(exclmix)} zit] {	;#	Name of (input) ofnam needed for output of crossfade
					Inf "CANNOT RENAME PROCESSED $msg_type $n FOR CROSSFADING : $zit"
					set crossfade_possible 0
				} else {
					set iifnam $segment(fadesnd)
				}
			}
		}
	} else {
		if [catch {file rename $ofnam $segment(exclmix)} zit] {
			Inf "CANNOT RENAME PRE-CROSSFADE $msg_type $n : $zit"
			set crossfade_possible 0
		}
	}
	if {$crossfade_possible} {
		set cmd [file join $evv(CDPROGRAM_DIR) submix]					;#	Linear crossfade from start to end of 1st infile (2nd has been tested for being longer)
		lappend cmd crossfade 1 $iifnam $segment(exclmix) $ofnam -s0 -b0 -e$indur	
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CROSSFADING PROCESSED $msg_type $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN PROCESS TO CROSSFADE PROCESSED $msg_type $n"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CROSSFADE PROCESSED $msg_type $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $ofnam]} {
			Inf "NO CROSSFADED VERSION OF $msg_type $n CREATED"
			return 0
		}
		if [catch {open $ofnam "r"} zit] {
			#NB: ONLY WORKS IF THIS OPEN/CLOSE EVENT HAPPENS HERE : (May force correct timing order)
			# Without it, the program runs, but the output is not retained!!
			Inf "Output file is $ofnam but can't open"
		}
		close $zit
	}
	return 1
}

#-- A segment to be tuned (with PITCHLINE) has previously been (HTmerged &) processed with VERGES

proc HasVerged {n} {
	global segment
	incr n -1												;#	Go to previous segment
	foreach dud $segment(multido) {							
		if {[lindex $dud 0] == "VERGES"} {					;#	Find if VERGES process has been used
			set actionlist [lindex $dud 1]				
			set previous_action [lindex $actionlist $n]		;#	If so, has it been used on previous segment(Head of the Tail)
			if {$previous_action} {							;#	IF so, return 1, for possible prescaling of input to PITCHLINE
				return 1
			} 
			return 0
		}
	}
	return 0
}

#--- Prescale file that has run through VERGES  with "boost" to avoid overload in Pitchline process

proc PrescaleForPitchlineAfterVergesWithBoost {ifnam msg_type n} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit\nCANNOT PRESCALE $msg_type $n"
		return 1
	}
	set cmd [file join $evv(CDPROGRAM_DIR) modify]
	lappend cmd loudness 1 $ifnam $segment(fadesnd) $segment(PRESCALE)
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        PRESCALING $msg_type $n"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO PRESCALE $msg_type $n"
		catch {unset CDPidrun}
		return 1
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO PRESCALE $msg_type $n"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 1
	}
	if {![file exists $segment(fadesnd)]} {
		Inf "NO PRESCALED VERSION OF $msg_type $n CREATED"
		return 1
	}
	if {[file exists $segment(bakupsnd)] && [catch {file delete $segment(bakupsnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(bakupsnd) : $zit\nCANNOT PRESCALE $msg_type $n"
		return 1
	}
	if [catch {file copy $ifnam $segment(bakupsnd)} zit] {
		Inf "CANNOT BACKUP INPUT FILE  : $zit\nCANNOT PRESCALE $msg_type $n"
		return 1
	}
	if [catch {file delete $ifnam} zit] {
		Inf "CANNOT DELETE ORIGINAL INPUT FILE  : $zit\nCANNOT PRESCALE $msg_type $n"
		return 1
	}
	if [catch {file rename $segment(fadesnd) $ifnam} zit] {
		Inf "CANNOT RENAME PRESCALED FILE  : $zit\nCANNOT PRESCALE $msg_type $n"
		if [catch {file rename $segment(bakupsnd) $ifnam} zit] {
			Inf "FAILED TO PRESCALE $msg_type $n (ORIGINAL FILE LOST): $zit"
			return 0
		}
	}
	return 1
}

#--- Delring feedback may overload, so check and rerun with prescaling if ness

proc DelringOverloadCheck {ofnam msg_typ n incmd} {
	global segment evv prg_dun set prg_abortd simple_program_messages CDPidrun maxsamp_line done_maxsamp CDPmaxId

	set gain 1.0
	set OK 1
	set OK2 0
	set OK3 0
	set reprocesscnt 1
	while {!$OK2} {
		wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF PROCESSED $msg_typ $n (pass $reprocesscnt)"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $ofnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR PROCESSED $msg_typ $n (pass $reprocesscnt)"
			set OK 0
			break
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF PROCESSED $msg_typ $n (pass $reprocesscnt)"
			set OK 0
			break
		}
		if {$OK3} {
			break
		}
		set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
		if {$maxoutsamp <= 0.0} {
			Inf "PROCESSED $msg_typ $n (pass $reprocesscnt) HAS ZERO LEVEL"
			set OK 0
			break
		}
		if {$maxoutsamp > 0.98} {										;#	Gain close to 1.0 indicates output has probably overloadad
			set gain [expr $gain * 0.1]									;#	Reduce gain by factor of ten and re-run
		} elseif {($maxoutsamp < $segment(maxlev)) && ($gain < 1.0)} {	;#	If gain has been adjusted, but maxsamp now below max
			set gain [expr ($segment(maxlev)/$maxoutsamp) * $gain]		;#	reset gain to give a maximal non-distorted output
			set OK3 1													;#	and force loop-exit after next pass
		} else {
			set OK2 1
			break
		}
		if {[catch {file delete $ofnam} zit]} {
			Inf "CANNOT DELETE PREVIOUS MIX OUTPUT, TO MODIFY LEVEL"
			set OK 0
			break
		}
		set cmd [concat $incmd -p$gain]
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        REPROCESSING $msg_typ $n (pass $reprocesscnt)"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO REPROCESSING $msg_typ $n (pass $reprocesscnt)"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SOUND BY REPROCESSING $msg_typ $n (pass $reprocesscnt)"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "NO REPROCESSED $msg_typ $n CREATED (pass $reprocesscnt)"
			set OK 0
			break
		}
		incr reprocesscnt
	}
	if {!$OK} {
		return 0
	}
	return 1
}

##########
# VOCODE #
##########

#--- Check for compatible properties in 2 analysis files

proc GettrofCompatibleAnalFiles {afnam1 afnam2} {
	global pa evv
	set anaprops1 {}
	lappend anaprops1 $pa($afnam1,$evv(SRATE))
	lappend anaprops1 $pa($afnam1,$evv(CHANS))
	lappend anaprops1 $pa($afnam1,$evv(ARATE))
	lappend anaprops1 $pa($afnam1,$evv(FRAMETIME))
	lappend anaprops1 $pa($afnam1,$evv(NYQUIST))
	set anaprops2 {}
	lappend anaprops2 $pa($afnam2,$evv(SRATE))
	lappend anaprops2 $pa($afnam2,$evv(CHANS))
	lappend anaprops2 $pa($afnam2,$evv(ARATE))
	lappend anaprops2 $pa($afnam2,$evv(FRAMETIME))
	lappend anaprops2 $pa($afnam2,$evv(NYQUIST))
	foreach prp1 $anaprops1 prp2 $anaprops2 {
		if {$prp1 != $prp2} {
			return 0
		}
	}
	return 1
}

#--- Enter style for Vocode

proc VocodeStyle {} {
	global segment pr_voccod voccod evv wstk
	set f .voccod
	if [Dlg_Create $f "SET STYLE FOR VOCODE" "set pr_voccod 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		label $f.0.vs -text "\"VS\" = Vocoding Signal" -fg $evv(SPECIAL)
		button $f.0.s -text "Use Settings" -command "set pr_voccod 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_voccod 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_voccod 0" -width 8
		pack $f.0.s $f.0.l $f.0.h $f.0.vs -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		radiobutton $f.1.1  -text "Cut up VS to correct sized segments"		 -variable segment(par0) -value 1  -width 30
		radiobutton $f.1.2  -text "Stretch/shrink VS to correct sizes"		 -variable segment(par0) -value 2  -width 30
		radiobutton $f.1.3  -text "Stretch/shrink predefined segments of VS" -variable segment(par0) -value 3  -width 35
		radiobutton $f.1.4  -text "Stretch/shrink Source"					 -variable segment(par0) -value 4  -width 20
		pack $f.1.1 $f.1.2 $f.1.3 $f.1.4 -side left
		pack $f.1 -side top -pady 4
		frame $f.2
		checkbutton $f.2.ch  -text "Vocode Head Also" -variable segment(par1) -width 16
		pack $f.2.ch -side left
		pack $f.2 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_voccod 1}
		bind $f <Escape> {set pr_voccod 0}
	}
	set segment(par0) 0
	set segment(par1) 0
	if {[expr $segment(infilecnt) - 1] >= $segment(cnt)}  {
		$f.1.1 config -text "" -state disabled -disabledforeground []
		$f.1.2 config -text "Stretch/shrink VSs to correct sizes"
		$f.1.3 config -text "" -state disabled -disabledforeground []
	} else {
		$f.1.1 config -text "Cut up VS to correct sized segments" -state normal
		$f.1.2 config -text "Stretch/shrink VS to correct sizes"
		$f.1.3 config -text "Stretch/shrink predefined segments of VS" -state normal
	}
	if {$segment(phrase)} {
		$f.2.ch  config -text "" -state disabled -disabledforeground []
	} else {
		$f.2.ch  config -text "Vocode Head Also" -state normal
	}

	set pr_voccod 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_voccod
	while {!$finished} {
		tkwait variable pr_voccod
		switch -- $pr_voccod {
			1 {
				switch -- $segment(par0) {
					0 {
						Inf "VOCODING STYLE NOT CHOSEN"
						continue
					}
					1 {
						if {$segment(vocdur) <= $segment(dur)} {
							Inf "FILE $segment(src,1) TOO SHORT ([TwoSigFig $segment(vocdur)] secs) TO CUT TO MATCH SOURCE ([TwoSigFig $segment(dur)] secs)"
							continue
						}
					}
					3 {
						if {![FindVocodeSegmentation]} {
							continue
						}
					}
				}
				set segment(PAR0) $segment(par0)	;#	This Param must be set here, as not set later
				set segment(lastpar0,$segment(process)) $segment(par0)
				set segment(PAR1) $segment(par1)	;#	This Param must be set here, as not set later
				set segment(lastpar1,$segment(process)) $segment(par1)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#---- Preparing vocode signla and src segments for the vocode process
#
#	Control Structure
#
#	segment(PAR0)
#---------------------------------------------------------------------------------------------------------------------------
#			1		   |		2		   |			3	   |			4	   |	2+multivocs	   |	4+multivocs	    |
#---------------------------------------------------------------------------------------------------------------------------
#	1 VOCODE SIG	   |1 VOCODE SIG	   |1 VOCODE SIG	   |1 VOCODE SIG	   |MULTIPLE VOC SIGS  |MULTIPLE VOC SIGS	|
#	CUT TO CHUNKS	   |USE FOR EACH SEG   |SEGMENTS SPECIFIED |TSTR SRC SEGS	   |USE ONE PER SEG	   |USE ONE PER SEG		|
#	SIZEOF SEGS		   |AND TSTR TO SIZ	   |TSTR THEM TO SIZ   |TO VOCSSIZ		   |TSTR TO VOCSSIZ	   |TSTR SRCSEGS TO VOCSSIZ
#---------------------------------------------------------------------------------------------------------------------------
#					   |				   |				   |				   |				   |					|		
#	GETSIZE-OF-VOC~~~~~~GETSIZE-OF-VOC~~~~~~GETSIZE-OF-VOC~~~~~~GETSIZE-OF-VOC		GETSIZESOF-VOCS~~~~~GETSIZESOF-VOCS		|
#					   |				   |				   |				   |				   |					|		
#	GETSIZE-OF-SEGS~~~~~GETSIZE-OF-SEGS~~~~~GETSIZE-OF-SEGS~~~~~GETSIZE-OF-SEGS~~~~~GETSIZE-OF-SEGS~~~~~GETSIZE-OF-SEGS		|
#	AND-NAMES			AND-NAMES			AND-NAMES			AND-NAMES			AND-NAMES			AND-NAMES			|
#					   |				   |				   |				   |				   |					|		
#																if(FUSEHEAD) DO~~~~~~~~~~~~~~~~~~~~~~~~~if(FUSEHEAD) DO		|
#					   |				   |				   |				   |				   |					|		
#																GET_CHANCNT_HEAD~~~~~~~~~~~~~~~~~~~~~~~~GET_CHANCNT_HEAD	|
#					   |				   |				   |				   |				   |					|		
#	CUT-CHUNKS-TO-SIZE	N-COPIES VOC		VOC-SEGMENTATION	if(MULTICHAN)~~~~~~~~~~~~~~~~~~~~~~~~~~~if(MULTICHAN)		|
#																SEPARATE-CHANS							SEPARATE-CHANS		|
#					   |				   |				   |				   |				   |					|		
#	GET SEGSPEC			GET SEGSPEC			GET SEGSPEC			GET SEGSPEC(S)~~~~~~~~~~~~~~~~~~~~~~~~~~GET SEGSPEC(S)		|
#					   |				   |				   |				   |				   |					|		
#	->List				->List				->List				-->List(oflists)						-->List(oflists)	|
#					   |				   |				   |				   |				   |					|		
#																CALC-INVTSTR-RATIO~~~~~~~~~~~~~~~~~~~~~~CALC-INVTSTR-RATIO	|
#					   |				   |				   |				   |				   |					|		
#						CALC-TSTR-RATIO	~~~	CALC-TSTR-RATIO	~~~~~~~~~~~~~~~~~~~~~~~	CALC-TSTR-RATIO	   |					|	
#					   |				   |				   |				   |				   |					|		
#							TSTR ~~~~~~~~~~~~~~	TSTR ~~~~~~~~~~~~~~	TSTR ~~~~~~~~~~~~~~	TSTR ~~~~~~~~~~~~~~	TSTR			|
#					   |				   |				   |				   |				   |					|		
#		VOCODE ~~~~~~~~~~~~	VOCODE ~~~~~~~~~~~~	VOCODE ~~~~~~~~~~~~	VOCODE ~~~~~~~~~~~~	VOCODE ~~~~~~~~~~~~	VOCODE			|
#					   |				   |				   |				   |				   |					|		
#---------------------------------------------------------------------------------------------------------------------------

proc Gettrof_TailVocode {} {
	global segment evv wstk

	if {![ClearIntermediateVocodeFiles]} {
		return 0
	}
	if {![MultipleProcessing]} {
		VocodeMakePreliminaryMixFile	;#	Setup a mixfile of the original segments
	}
	set vocode_head 0 
	if {!$segment(phrase)} {
		set vocode_head $segment(PAR1)
	}

	;#	GET NAMES, DURATIONS AND CHANCNTS OF VOCODABLE SEGMENTS

	set data [VocodeSegmentNamesSizesAndChancnts $vocode_head]
	set segnos	[lindex $data 0]		;#	segment-no that is to be vocoded
	set fnams	[lindex $data 1]		;#	Names of segment files to be vocoded
	set hnams	[lindex $data 2]		;#	Names of any associated Head files (or "0") for any vocode_head option
	set segdurs [lindex $data 3]		;#	Src segment durations
	set xsgdurs [lindex $data 4]		;#	Default durations, if any head fusion fails
	set sgchans	[lindex $data 5]		;#	Channel count of src segment
	set sgtimes [lindex $data 6]		;#	Segment entrytimes in mixfile
	set dfltims	[lindex $data 7]		;#	Ditto, if any headfusion fails

	;#	LIST NAMES & DURATION OF VOCODING SIGNAL(S), FOR EACH VOCODABLE SEGMENT

	set data [VocodeVocSigNamesAndSizes]
	if {[string match $data "0"]} {
		return 0
	}
	set vocnams [lindex $data 0]
	set vocdurs [lindex $data 1]

	;#	VOcode data storage
	;#	VOCDATA = list (0)	SEGNO	(1)SEGNAME	(2)SEGHEADNAME	(3)SEGDUR	(4)DFLTDUR	 (5)SEGCHANCNT	 (6)VOCFILNAM  (7)VOCFILDUR	(8)	HEADFUSED (9) SEGTIME	10) DFLTTIME
	;#											  0 if no Head	Nonphrase:	 Nonphrase:		Initially									Intially
	;#															Taildur OR	  Taildur	 (for nonphrase)									0
	;#															H+T dur if	   only		   Tail chancnt
	;#														    Heads Fused

	foreach segno $segnos fnam $fnams hnam $hnams segdur $segdurs xsgdur $xsgdurs sgchan $sgchans vocnam $vocnams vocdur $vocdurs sgtim $sgtimes dfltim $dfltims {
		set vocitem [list $segno $fnam $hnam $segdur $xsgdur $sgchan $vocnam $vocdur 0 $sgtim $dfltim]
		lappend vocdata $vocitem
	} 

	;#	IF REQUIRED, REPLACE TAIL BY MERGED HEAD-AND-TAIL, AS SEGMENT TO PROCESS
	;#	(If this fails, original duration of tail (4) is substituted (at (3)) on vocdata entry).
	;#	If it succeeds, substitute: name of fused head at (1) chan cnt of fusedHT at (5) Headfused=name-of-orig-head-in,ixfile at (8)

	set OK 1

	Block "PLEASE WAIT:        VOCODING"


	while {$OK} {
		if {$vocode_head} {
			set vocdata [VocodeHeadMerge $vocdata]
		}
			;#	GET THE SPECTRAL FILE(S) FROM THE SEGMENT (CHANNELS) TO PROCESS, IF NESS

		set vocdata [VocodeGetSegmentAnalfiles $vocdata]
		if {[string match $vocdata "0"]} {
			set OK 0
			break
		}
			;#	GET THE SPECTRAL FILE(S) FROM THE OTHER SIGNAL(S) - CUTTING UP THE OTHER SIGNAL IF SPECIFIED

		set vocdata [VocodeGetOtherSpectra $vocdata $vocode_head]
		if {[string match $vocdata "0"]} {
			set OK 0
			break
		}
			;#	TIMESTRETCH/SHRINK EACH VOCODING SIGNAL OR EACH SEGMENT - TO MATCH CORRESPONDING OTHER

		set vocdata [VocodeDoTimestretching $vocdata]
		if {[string match $vocdata "0"]} {
			set OK 0
			break
		}
		set vocdata [DoVocoding $vocdata]
		if {[string match $vocdata "0"]} {
			set OK 0
			break
		}
		break
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	if {![VocodingReport $vocdata]} {
		UnBlock
		return 0
	}
	if {$segment(multiproccnt)} {				;#	With a multiprocess, we don't mix until we reach end
		UnBlock
		return 1
	}
	DoMultichanCorrection
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		if {[info exists segment(recycprocess)]} {
			set segment(mixlines) $segment(origmixlines)
		}
		UnBlock
		return 0
	}

	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofPossiblyMultichanMixdown 1]} {			;#	Some of these programs may produce extended tails which overlay other segs, so may overload
		if {![GettrofPossiblyMultichanMixdown 1]} {		;#	Output may also be multichan, if Heads are also processed
			set segment(mixlines) $segment(origmixlines)
			set OK 0
		}
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	UnBlock
	set segment(reordered) 0
	return 1
}

#--- Get rid of temporary files from any previous vocode process

proc ClearIntermediateVocodeFiles {} {
	global evv
	set matchnam $evv(MACH_OUTFNAME)
	append matchnam "_V"
	set fils 1
	if [catch {glob $matchnam*} zit] {
		set fils 0
	}
	if {$fils} {
		foreach zzfnam [glob $matchnam*] {
			lappend dellist $zzfnam
		}
	}
	set matchnam $evv(DFLT_OUTNAME)
	append matchnam "_V"
	set fils 1
	if [catch {glob $matchnam*} zit] {
		set fils 0
	}
	if {$fils} {
		foreach zzfnam [glob $matchnam*] {
			lappend dellist $zzfnam
		}
	}
	if {[info exists dellist]} {
		foreach zzfnam $dellist {
			if [catch {file delete $zzfnam} zit] {
				Inf "CANNOT DELETE INTERMEDIATE VOCODING FILE $zzfnam : $zit"
				return 0
			}
		}
	}
	return 1
}

#--- Find a segmentation file for the vocoding signal

proc FindVocodeSegmentation {} {
	global segment evv wstk
	if {$segment(phrase)} {
		set fnam [file rootname [file tail $segment(src,1)]]
		append fnam "_phrs" $evv(TEXT_EXT) 
		set fnam [file join $segment(dirname) $fnam]
		if {[file exists $fnam]} {
			lappend fnams $fnam
		} 
	} else {
		set fnam [file rootname [file tail $segment(src,1)]]
		append fnam "_0_rsegs" $evv(TEXT_EXT) 
		set fnam [file join $segment(dirname) $fnam]
		if {[file exists $fnam]} {
			lappend fnams $fnam
		} 
		set fnam [file rootname [file tail $segment(src,1)]]
		append fnam "_1_rsegs" $evv(TEXT_EXT) 
		set fnam [file join $segment(dirname) $fnam]
		if {[file exists $fnam]} {
			lappend fnams $fnam
		}
	}
	if {[info exists fnams]} {
		foreach fnam $fnams {
			set msg "USE SIGNAL SEGMENTATION IN FILE [file rootname [file tail $fnam]] ?"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				set segfnam $fnam
				set segment(vocsegfnam) $segfnam
				return 1
			}
		}
		if {![info exists segfnam]} {
			set msg2 "NO SEGMENTATION FILE SELECTED FOR [file tail $segment(src,1)]\n\n"
			append msg2 "PLEASE CHOOSE AN EXISTING SEGMENTATION FILE\n"
			append msg2 "OR (RE)SEGMENT THE SIGNAL\n"
			append msg2 "BEFORE PROCEEDING."
			Inf $msg2
			return 0
		}
	} else {
		set msg2 "NO SEGMENTATION FILE FOUND FOR [file tail $segment(src,1)] : USE AN EXISTING SEGMENTATION ??\n"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg2]
		set origmarklist $segment(marklist)
		set origmarkfnam $segment(rfnam)
		if {$segment(phrase)} {
			if {![LoadVboxFile PHRASE]} {
				Inf "PLEASE RESTART AND SEGMENT THE SIGNAL BEFORE PROCEEDING."
				return 0
			} else {
				set segment(vocsegfnam) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
				set segment(rfnam) $origmarkfnam
				set segment(vocmarklist) $segment(marklist)
				set segment(marklist) $origmarklist
			}
		} else {
			if {![LoadVboxFile REFINED]} {
				Inf "PLEASE RESTART AND SEGMENT THE SIGNAL BEFORE PROCEEDING."
				return 0
			} else {
				set segment(vocsegfnam) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
				set segment(rfnam) $origmarkfnam
				set segment(vocmarklist) $segment(marklist)
				set segment(marklist) $origmarklist
			}
		}
	}
	return 1
}

#--- Get the segmentation of the vocoding signal

proc GetVocodeSegmentation {matchheads} {
	global segment wstk

	if [catch {open $segment(vocsegfnam) "r"} zit] {
		Inf "CANNOT OPEN SEGMENTATION DATA [file tail $segment(vocsegfnam)] : $zit\n\nCANNOT PROCEED"
		return 0
	}
	catch {unset segment(vocmarklist)} 
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		lappend segment(vocmarklist) $line
	}
	if {![info exists segment(vocmarklist)]} {
		Inf "NO SEGMENTATION DATA RECOVERED FROM FILE [file tail $segment(vocsegfnam)] : CANNOT PROCEED"
		return 0
	}
	set headfirst_in_vocsignal 1
	if {!$segment(phrase)} {
		if {[string first "_0_rsegs" $segment(vocsegfnam)] > 0} {
			set headfirst_in_vocsignal 0
		}
	}
	set contrahead 0
	if {$segment(headfirst) != $headfirst_in_vocsignal} {					;#	If not both headfirst, eliminate first seg in vocoding signal
		if {$matchheads} {
			Inf "SOURCE AND TRANSFER SEGMENTATIONS DO NOT BOTH START WITH A TAIL (OR BOTH WITH A HEAD)"
			return 0
		}
		set contrahead 1
		set origlen [llength $segment(vocmarklist)]
		set segment(vocmarklist) [lreplace $segment(vocmarklist) 0 0]
	}
	set mlen [llength $segment(marklist)]
	set len [llength $segment(vocmarklist)]
	if {$len < $mlen} {
		set msg "INSUFFICIENT SEGMENTATION MARKS ($len) IN VOCODING SIGNAL\n"
		if {$contrahead && ($origlen == $mlen)} {
			append msg "BECAUSE ONE SEGMENTATION IS HEADFIRST AND THE OTHER NOT\n"
		}
		append msg "\n(NEED AT LEAST [expr $mlen + $contrahead] MARKS)"
		Inf $msg
		return 0
	} elseif {$len > $mlen} {
		set msg "TOO MANY SEGMENTATION MARKS ($len) FOR VOCODING SIGNAL (NEED ONLY $mlen)\n\n"
		append msg "IGNORING FINAL [expr $len - $mlen] MARKS\n\n"
		append msg "IS THIS OK ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return 0
		}
		set segment(vocmarklist) [lrange $segment(vocmarklist) 0 [expr $mlen - 1]]
	} elseif {$matchheads} {
		set segment(vocmarklist) [lreplace $segment(vocmarklist) end end $segment(vocdur)]		;#	For TRANSFER, Final time must be end of file2
	}
	return 1
}

#-- Get unique name for vocode outfile

proc GetVocodeOutnam {fnam} {
	global evv										
	set ofnam [file rootname [file tail $fnam]]		;#	src.ana
	append ofnam "_VSTR" $evv(ANALFILE_EXT)			;#	src_VSTR.ana
	return $ofnam									
}

#--- Fuse head to tail, for vocode process

proc FuseHeadForVocode {headfile tailfile ichans zfnam segno} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages
	global maxsamp_line done_maxsamp CDPmaxId

	if {[file exists $zfnam] && [catch {file delete $zfnam} zit]} {
		Inf "CANNOT DELETE PREVIOUS MERGED HEAD FILE FOR SEGMENT $segno"
		return 0
	}
	if {[file exists $segment(mixdata)] && [catch {file delete $segment(mixdata)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE FILE $segment(mixdata) : $zit\n"
		return 0
	}
	set hchans 1
	set tchans 1
	if {[MultipleProcessing]} {
		set headline [GetTrofSrcfileIsInMixlist $headfile]
		set hchans [lindex [lindex $segment(mixlines) $headline] 2]
		set htime  [lindex [lindex $segment(mixlines) $headline] 1]
		set tailline [GetTrofSrcfileIsInMixlist $tailfile]
		set tchans [lindex [lindex $segment(mixlines) $tailline] 2]
		set ttime  [lindex [lindex $segment(mixlines) $tailline] 1]
	} else {
		set htime [lindex $segment(marklist) [expr $segno - 2]]		;#	possible missing Head (prior to a Tail at segno 1) already handled
		set ttime [lindex $segment(marklist) [expr $segno - 1]]
		if {$htime > 0.0} {
			set htime [expr $htime - $segment(SPLICE)]				;#	Allow for upsplice on Head (only)
			if {$htime < 0.0} {
				set htime 0.0
			}
		}
	}
	set mixstep [expr $ttime - $htime]
	if {$hchans > 2} {
		set line $hchans
		lappend lines $line
		set line [list $headfile 0.0]
		set chan 1
		while {$chan <= $hchans} {
			set rout $chan
			append rout ":" $chan
			lappend line $rout 1.0
			incr chan
		}
		lappend lines $line
		set line [list $tailfile $mixstep $tchans 1:1 1.0]				;#	Src Tail always mono
		lappend lines $line

	} else {
		set line [list $headfile 0.0 $hchans 1.0]
		lappend lines $line	
		set line [list $tailfile $mixstep $tchans 1.0]					;#	Src Tail always mono
		lappend lines $line
	}
	if [catch {open $segment(mixdata) "w"} zit] {
		Inf "CANNOT OPEN MIXDATA FILE $segment(mixdata) FOR HEAD FUSING OF SEGMENT $segno: $zit\n"
		return 0
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	
	set gain 1.0
	set OK 1
	set OK2 0
	set OK3 0
	set mixcnt 1

	while {!$OK2} {
		if {[file exists $zfnam]} {
			if [catch {file delete $zfnam} zit] {
				Inf "CANNOT DELETE PREVIOUS MIX OUTPUT (pass $mixcnt)"
				set OK 0
				break
			}
		}
		if {$hchans <= 2} {
			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd mix $segment(mixdata) $zfnam -g$gain
		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $segment(mixdata) $zfnam -g$gain
		}
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        FUSING HEAD FOR SEGMENT $segno (pass $mixcnt)"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN FUSING HEAD FOR SEGMENT $segno (pass $mixcnt)"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO FUSE HEAD FOR SEGMENT $segno (pass $mixcnt)"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $zfnam]} {
			Inf "NO FUSED HEAD FOR SEGMENT $segno CREATED (pass $mixcnt)"
			set OK 0
			break
		}
		if {$OK3} {
			break
		}
		wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF FUSED HEAD FOR SEGMENT $segno (pass $mixcnt)"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $zfnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' (pass $mixcnt)"
			set OK 0
			break
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF FUSED HEAD FOR SEGMENT $segno  (pass $mixcnt)"
			set OK 0
			break
		}
		set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
		if {$maxoutsamp <= 0.0} {
			Inf "FUSED HEAD FOR SEGMENT $segno  (pass $mixcnt) HAS ZERO LEVEL"
			set OK 0
			break
		}
		if {$maxoutsamp > 0.98} {										;#	Gain close to 1.0 indicates output has probably overloadad
			set gain [expr $gain * 0.1]									;#	Reduce gain by factor of ten and re-run

		} elseif {($maxoutsamp < $segment(maxlev)) && ($gain < 1.0)} {	;#	If gain has been adjusted, but maxsamp now below max
			set gain [expr ($segment(maxlev)/$maxoutsamp) * $gain]		;#	reset gain to give a maximal non-distorted output
			set OK3 1													;#	and force loop-exit after next pass
		} else {
			set OK2 1													;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
		}
		incr mixcnt
	}
	if {!$OK} {
		return 0
	}
	return $hchans
}

#--- Get analysis file from a segment wavfile

proc AnalysisFileFromSegmentWav {ifnam segno channo} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages
	set ofnam [file rootname $ifnam]
	append ofnam $evv(ANALFILE_EXT)
	if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
		Inf "CANNOT DELETE PREVIOUS SPECTRAL FILE FOR SEGMENT $segno"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd anal 1 $ifnam $ofnam -c1024 -o3
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	set msg2 "$segno "
	if {$channo > 0} {
		append msg2 "CHANNEL $channo "
	}
	wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF SEGMENT $msg2 OF SOURCE"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN SPECTRUM CREATION FOR SEGMENT $msg2 OF SOURCE"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE SPECTRUM OF SEGMENT $msg2 OF SOURCE"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} { 
		Inf "NO SPECTRUM OF SEGMENT $msg2 OF SOURCE CREATED"		
		return 0
	}
	return [list $ifnam $ofnam]
}

#--- Extract channels from a multichannel segment

proc GettrofExtractAllChannels {ifnam chancnt segno} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages
	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 2 $ifnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        EXTRACTING CHANNELS OF SEGMENT $segno"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN CHANNEL EXTRACTION PROCESS FOR SEGMENT $segno"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO EXTRACT CHANNELS FROM SEGMENT $segno"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	set thischan 1
	while {$thischan <= $chancnt} {
		set ichfnam($thischan) [file rootname $ifnam]
		append ichfnam($thischan) "_c$thischan" $evv(SNDFILE_EXT)
		if {[file exists $ichfnam($thischan)]} {
			lappend outfiles $ichfnam($thischan)
		}
		incr thischan
	}
	if {![info exists outfiles] || ([llength $outfiles] < $chancnt)} {
		Inf "NOT ALL CHANNELS EXTRACTED FROM SEGMENT $segno"
		return 0
	}
	return $outfiles
}

#----	Find appropriate segments for the vocoding process

proc GetSegmentsForVocode {segno vocode_head} {
	global segment evv
	set headfile 0
	if {$segment(phrase)} {
		set hcnt $segno
	} else {												;#	!headfirst									headfirst		
		set hcnt [expr $segno/2]							;#	1  (2)	3  (4)	5	segcnt				   (1)	2  (3)	4  (5)	
		set tcnt [expr $segno/2]							;#	0	1	1	2	2	segct/2					0	1	1	2	2
		if {!$segment(headfirst)} {							;#	T	H	T	H	T							H	T	H	T	H			
			incr tcnt										;#	0	1->		2->		hcnt = segcnt/2			1->		2->		  hcnt = segcnt/2		
		}													;#	1		2		3	tcnt = segcnt/2 + 1			1		2	  tcnt = segcnt/2	
	}														;#	Process is on TAIL segment number: relevant Head number is head BEFORE that tail
	set ichans 1
	if {[MultipleProcessing]} {
		if {$segment(phrase)} {
			set headdata [FindRelevantHeadFileForRetimeAndVerges $hcnt]			;#	Phrases are all Heads
			set file_to_process [lindex $headdata 0]
			set head_line [lindex $segment(mixlines) [lindex $headdata 1]]
			set ichans [lindex $head_line 2]
		} else {
			set taildata [FindRelevantTailFileForRetime $tcnt]
			set file_to_process [lindex $taildata 0]
			set tail_line [lindex $segment(mixlines) [lindex $taildata 1]]
			set ichans [lindex $tail_line 2]
			if {$vocode_head && ($hcnt > 0)} {									;#	There may be no prior Head
				set headdata [FindRelevantHeadFileForRetimeAndVerges $hcnt]
				if {[lindex $headdata 1] >= 0} {
					set headfile [lindex $headdata 0]
				}
			}
		}
	} else {
		set file_to_process $evv(MACH_OUTFNAME)
		append file_to_process "TD" $tcnt $evv(SNDFILE_EXT)
		if {$vocode_head && ($hcnt > 0)} {
			set headfile $evv(DFLT_OUTNAME)
			append headfile "HH" $hcnt $evv(SNDFILE_EXT)
		}
	}
	return [list $file_to_process $headfile $ichans]
}

#--- List durations and chancnt of each vocodable segment

proc VocodeSegmentNamesSizesAndChancnts {vocode_head} {
	global segment
	set is_possibly_extended 0
	catch {unset actionlist}
	if {$segment(multiproccnt)} {
		foreach dud $segment(multido) {
			if {[lindex $dud 0] == $segment(process)} {
				set actionlist [lindex $dud 1]
				break
			}
		}
		set is_possibly_extended [GettrofProcessesMayTimeExtendSegments]
	}
	set mm -1
	set kk 0
	set jj 1
	set is_head 1
	set marks [lreplace $segment(marklist) end end $segment(dur)]		;#	Put endofsrc time as last emtry in marklist
	if {!$segment(phrase) && !$segment(headfirst)} {
		set is_head 0
	}																			
	while {$jj <= $segment(cnt)} {
		if {$segment(phrase) || !$is_head} {

			if {[info exists actionlist]} {								;#	If a multiple-process
				if {[lindex $segment(actionlist) $jj] == 0} {			;#	Only vocode segments that are marked for vocoding
					set is_head [expr !$is_head]
					incr jj
					incr kk
					incr mm
					continue
				}
			}
			;#	FIND DURATION OF SRC SEGMENT, OR SEGMENT FUSED-WITH-HEAD

			if {$vocode_head && ($mm >= 0)} {
				set segtime_in_mix [lindex $marks $mm]									;#	Start of head
				set dflttim_in_mix [lindex $marks $kk]									;#	Start of tail, if head-fusion fails
				if {$mm != 0} {																		
					set segtime_in_mix [expr $segtime_in_mix - $segment(SPLICE)]		;#	Allow for upsplice on Head (except a head at start of segments)
				}																		;#					   __ __			 __ __ __
				set segdur [expr [lindex $marks $jj] - $segtime_in_mix]					;#	all but 1st T of T HT HT or any T of HT HT HT
				set xsgdur [expr [lindex $marks $jj] - $dflttim_in_mix]					;#	(xsegdur used if head-fusion fails = duration of tail only)	
			} else {
				set segtime_in_mix [lindex $marks $kk]
				set dflttim_in_mix $segtime_in_mix
				set segdur [expr [lindex $marks $jj] - $segtime_in_mix]					;#	1st T of T HT HT  OR !vochead	T H T H T   OR phrase	H H H H
				if {$segment(phrase) && ($mm != 0)} {																		
					set segtime_in_mix [expr $segtime_in_mix - $segment(SPLICE)]		;#	Allow for upsplice on Head (except a head at start of segments)
				}																		;#
				set xsgdur $segdur
			}
			if {$segment(phrase) && ($jj != $segment(cnt))} {							;#	splice-out on end of phrases, except last
				set segdur [expr $segdur + $segment(SPLICE)]
				set xsgdur $segdur
			}
			set thedata [GetSegmentsForVocode $jj $vocode_head]			;#	RETURNS LIST = "file-to-process		assoc-headfile-if-any		chancnt"
			set fnam	[lindex $thedata 0]
			set hfnam	[lindex $thedata 1]
			set ichans  [lindex $thedata 2]

			if {$is_possibly_extended} {												;#	Processes like BOUNCE can change timing of mixlist by inserting extra file
				set tmixline [GetTrofSrcfileIsInMixlist $fnam]							;#	so confirm segment times from actual mixfile
				set segtime_in_mix [lindex [lindex $segment(mixlines) $tmixline] 1]
				set dflttim_in_mix $segtime_in_mix
				if {![string match $hfnam "0"] && $vocode_head} {
					set hmixline [GetTrofSrcfileIsInMixlist $hfnam]
					set segtime_in_mix [lindex [lindex $segment(mixlines) $hmixline] 1]
				}
			}
			lappend segnos $jj
			lappend fnams $fnam
			lappend hfnams $hfnam
			lappend segdurs $segdur
			lappend xsgdurs $xsgdur
			lappend hchcnts $ichans
			lappend segtims	$segtime_in_mix
			lappend dflttms $dflttim_in_mix
		}
		set is_head [expr !$is_head]
		incr jj
		incr kk
		incr mm
	}
	return [list $segnos $fnams $hfnams $segdurs $xsgdurs $hchcnts $segtims $dflttms]
}

#--- List durations of vocoding signal(s) for each vocoded segment

proc VocodeVocSigNamesAndSizes {} {
	global segment
	catch {unset actionlist}
	if {$segment(multiproccnt)} {
		foreach dud $segment(multido) {
			if {[lindex $dud 0] == $segment(process)} {
				set actionlist [lindex $dud 1]
				break
			}
		}
		set actioncnt 0
		foreach action $actionlist {
			incr actioncnt $action
		}
	}

	set vocodedsegs_cnt 0
	set segcnt 0
	set is_head 1
	if {!$segment(phrase) && !$segment(headfirst)} {
		set is_head 0											
	}
	set jj 1

	if {$segment(infilecnt) > 2} {

		;#	USE MULTIPLE VOCODE SRCS: COUNT and FIND DURATIONS of OTHER INFILES
		
		if {$segment(multiproccnt)} {
			while {$jj <= $actioncnt} {
				if {![DoSegmentDurParse $segment(src,$jj)]} {
					Inf "FAILED TO FIND DURATION OF INPUT VOCODING FILE $segment(src,$jj)"
					return 0
				}
				lappend vocdurs $segment(itemdur)
				lappend vocnams $segment(src,$jj)
				incr jj
			}
		} else {
			while {$jj <= $segment(cnt)} {
				if {$segment(phrase) || !$is_head} {
					if {![DoSegmentDurParse $segment(src,$jj)]} {
						Inf "FAILED TO FIND DURATION OF INPUT VOCODING FILE $segment(src,$jj)"
						return 0
					}
					lappend vocdurs $segment(itemdur)
					lappend vocnams $segment(src,$jj)
				}
				set is_head [expr !$is_head]
				incr jj
			}
		}

	} else {
		
		#	USING A SINGLE VOCODE SRC, DUPLICATE IT'S SIZE CORRECT NUMBER OF TIMES	
		
		if {$segment(multiproccnt)} {
			while {$jj <= $actioncnt} {
				lappend vocnams $segment(src,1)
				lappend vocdurs $segment(vocdur)
				incr jj
			}
		} else {
			while {$jj <= $segment(cnt)} {
				if {$segment(phrase) || !$is_head} {
					lappend vocnams $segment(src,1)
					lappend vocdurs $segment(vocdur)
				}
				set is_head [expr !$is_head]
				incr jj
			}
		}
	}
	return [list $vocnams $vocdurs]
}

#--- Do any fusion of head and tail, if required
#
#	VOCDATA = list (0)	SEGNO	(1)SEGNAME	(2)SEGHEADNAME	(3)SEGDUR	(4)DFLTDUR	 (5)SEGCHANCNT	 (6)VOCFILNAM  (7)VOCFILDUR	(8)	HEADFUSED (9) SEGTIME	10) DFLTTIME

proc VocodeHeadMerge {vocdata} {
	global segment evv
	set len [llength $vocdata]
	set kk 0
	while {$kk < $len} {
		set vocitem [lindex $vocdata $kk]
		set segno			[lindex $vocitem 0]
		set file_to_process [lindex $vocitem 1]
		set headfile		[lindex $vocitem 2]
		set ichans			[lindex $vocitem 5]				;#	channel count of existing Tail
				
		if {[string match $headfile "0"]} {					;# Head file already fused -> tail-named H+T file
			;#	file (tailtype) correct						;# or doesn't exist (Tail at start), so nothing to do
			;#	dur (H+T - or just T for an initial tail) correct
			;#	ichans = tail chans correct					;# ichans = chancnt of fused H+T, or Tail at start, chancnt = 1 by dflt.
		} else {
			set zfnam [file rootname [file tail $headfile]]	;#	Create unique name for fused H+T
			set yfnam [file rootname [file tail $file_to_process]]
			append zfnam $yfnam $evv(SNDFILE_EXT)			
															;#	Attempt to fuse Head and Tail
			set hchans [FuseHeadForVocode $headfile $file_to_process $ichans $zfnam $segno]
			if {$hchans < 1} {								;#	IF attempt to Fuse HEad fails
				set segdur [lindex $vocitem 4]				;#	just use orig file_to_process, with CORRECT (tail only) duration
				set vocitem [lreplace $vocitem 3 3 $segdur]
				set segtim [lindex $vocitem 10]				;#	replace segment tim in mix by dflttime
				set vocitem [lreplace $vocitem 9 9 $segtim]
			} else {										;#	else
				set vocitem [lreplace $vocitem 1 1 $zfnam]	;#	used fused HT file
				set vocitem [lreplace $vocitem 5 5 $hchans]	;#	with new channel-cnt 
				set vocitem [lreplace $vocitem 8 8 $file_to_process]	;#	Flag that Head is fused : put name of orig tail here: it needs to be deleted from mix at end
			}
			set vocdata [lreplace $vocdata $kk $kk $vocitem]
		}
		incr kk
	}
	return $vocdata
}

#--- Get analfile version of segment-to-vocode, or of each channel of segment-to-vocode

proc VocodeGetSegmentAnalfiles {vocdata} {
#
#	VOCDATA = list (0)	SEGNO	(1)SEGNAME	(2)SEGHEADNAME	(3)SEGDUR	(4)DFLTDUR	 (5)SEGCHANCNT	 (6)VOCFILNAM  (7)VOCFILDUR	(8)	HEADFUSED (9) SEGTIME	10) DFLTTIME -> 11) SEGWAVNAME

	global segment evv
	set len [llength $vocdata]
	set kk 0
	while {$kk < $len} {
		set vocitem [lindex $vocdata $kk]
		set segno			[lindex $vocitem 0]
		set file_to_process [lindex $vocitem 1]
		set ichans			[lindex $vocitem 5]
		if {[string match [file extension $file_to_process] $evv(ANALFILE_EXT)]} {
			incr kk
			continue
		}
		if {$ichans == 1} {
			set file_list [AnalysisFileFromSegmentWav $file_to_process $segno 0]
			if {[string match $file_list "0"]} {
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			} else {
				set file_wav		[lindex $file_list 0]
				set file_to_process [lindex $file_list 1]
				set vocitem [lreplace $vocitem 1 1 $file_to_process]
				lappend vocitem $file_wav
				set vocdata [lreplace $vocdata $kk $kk $vocitem]
			}
		} else {
			set chanfiles [GettrofExtractAllChannels $file_to_process $ichans $segno]
			if {[llength $chanfiles] <= 1} {
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			}
			set OK 1
			set kjk 0
			set chans_wav {}
			set chans_to_process {}
			set chancnt 1
			while {$chancnt <= $ichans} {
				set chanfile [lindex $chanfiles $kjk]
				set file_list [AnalysisFileFromSegmentWav $chanfile $segno $chancnt]
				if {[string match $file_list "0"]} {
					set OK 0
					break
				} else {
					lappend chans_wav	[lindex $file_list 0]
					set chan_to_process [lindex $file_list 1]
					lappend chans_to_process $chan_to_process
				}
				incr kjk
			}

			if {!$OK} {
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			}
			set vocitem [lreplace $vocitem 1 1 $chans_to_process]	;#	NB Here, "chans_to_process" is a LIST of files
			lappend vocitem $chans_wav								;#	As is associated list of wav files from which spectra derived
			set vocdata [lreplace $vocdata $kk $kk $vocitem]
		}
		incr kk
	}
	if {[llength $vocdata] <= 0} {
		Inf "NO VOCODABLE SEGMENTS"
		return 0
	}
	return $vocdata
}

#---	Where vocoding data is cut or segmented, find cut times and do cuts
#
#	VOCDATA = list (0)	SEGNO	(1)SEGNAME	(2)SEGHEADNAME	(3)SEGDUR	(4)DFLTDUR	 (5)SEGCHANCNT	 (6)VOCFILNAM  (7)VOCFILDUR	(8)	HEADFUSED (9) SEGTIME	10) DFLTTIME	11) SEGWAVNAME

proc VocodeGetOtherSpectra {vocdata vocode_head} {
	global segment pa evv CDPidrun prg_dun prg_abortd simple_program_messages

	;#	FOR CUT OR PRESEGMENTED VOCODING SIGNAL, GET SEGMENTATION TIMES
	
	set cutup 0
	if {$segment(PAR0) == 1} {				;#	CUT
		set segment(vocmarklist) $segment(marklist)
		set segment(vocmarklist) [lreplace $segment(vocmarklist) end end $segment(dur)]			;#	Force last mark to end of src
		set cutup 1
	} elseif {$segment(PAR0) == 3} {		;#	PRESEGMENTED
		if {![GetVocodeSegmentation 0]} {	;#	finds appropriate segment(vocmarklist)
			return 0
		}
		set segment(vocmarklist) [lreplace $segment(vocmarklist) end end $segment(vocdur)]		;#	Force last mark to end of vocsig
		set cutup 1
	}
	
	;#	CUT UP THE OTHER SIGNAL APPROPRIATELY, IF NESS, AND REPLACE BY ANAL FILE IN vocdata 

	if {$segment(process) == "VOCODE"} {
		set msg2 "VOCODING"
	} else {
		set msg2 "VOCODED"
	}

	set len [llength $vocdata]
	set kk 0
	while {$kk < $len} {
		set vocitem [lindex $vocdata $kk]
		set segno   [lindex $vocitem 0]
		if {!$cutup} {
			if {$segment(infilecnt) > 2} {
				set ofnam $segment(ana,$kk)			;#	If no cutting to be done, replace .wav file by related .ana file
				set thisdur $pa($segment(ana,$kk),$evv(DUR))
			} else {
				set ofnam $segment(ana,2)			;#	Ditto, 1-vocoding-file-only case
				set thisdur $segment(vocdur)
			}
		} else {
			set vocfile [lindex $vocitem 6]
			set j $segno
			set k [expr $segno - 1]
			set m [expr $segno - 2]

			wm title .blocker "PLEASE WAIT:        CUTTING SEGMENT $segno OF THE $msg2 SIGNAL"
			set ofnam $evv(MACH_OUTFNAME)
			append ofnam "_V" $j $evv(SNDFILE_EXT)
			if {$vocode_head && ($m >= 0)} {											;#	IF HEad also vocoded
				set stttime [expr [lindex $segment(vocmarklist) $m] - $segment(SPLICE)]	;#	Include length of preceding Head IF it exists
				if {$stttime < 0.0} {													;#	with a presplice, if that's possible
					set stttime 0.0
				}
			} else {
				set stttime [lindex $segment(vocmarklist) $k]
			}
			set endtime [lindex $segment(vocmarklist) $j]
			set thisdur [expr $endtime - $stttime]
			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			lappend cmd cut 1 $segment(src,1) $ofnam $stttime $endtime -w$segment(SPLICE)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CUTTING SEGMENT $j OF THE $msg2 SIGNAL"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN CUTTING OF SEGMENT $j OF THE $msg2 SIGNAL"
				catch {unset CDPidrun}
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SEGMENT $j OF THE $msg2 SIGNAL"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			}
			if {![file exists $ofnam]} {
				Inf "NO CUT SEGMENT $j OF THE $msg2 SIGNAL CREATED"
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			}
			set ifnam $ofnam
			set ofnam [file rootname $ofnam]
			append ofnam $evv(ANALFILE_EXT)
			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd anal 1 $ifnam $ofnam -c1024 -o3
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF SEGMENT $j OF THE $msg2 SIGNAL"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN SPECTRUM CREATION FOR SEGMENT $j OF THE $msg2 VOCODING SIGNAL"
				catch {unset CDPidrun}
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SPECTRUM OF SEGMENT $j OF THE $msg2 SIGNAL"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				lappend badsegs $j
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			}
			if {![file exists $ofnam]} {
				Inf "NO SPECTRUM OF SEGMENT $j OF THE $msg2 SIGNAL CREATED"
				lappend badsegs $j
				set vocdata [lreplace $vocdata $kk $kk]
				incr len -1
				continue
			}
		}
		set vocitem [lreplace $vocitem 6 6 $ofnam]		;#	Replace vocoding file to be used by segment-of-vocoding-file
		set vocitem [lreplace $vocitem 7 7 $thisdur]	;#	Replace duration by duration of cut-segment
		set vocdata [lreplace $vocdata $kk $kk $vocitem]
		incr kk
	}
	if {$len <= 0} {
		Inf "NO VOCODABLE SEGMENTS (A)"
		return 0
	}
	return $vocdata
}

#--- Do any necessary timestretching of segments of voc-signal segments, and replace in vocdata
#
#	VOCDATA = list (0)	SEGNO	(1)SEGNAME	(2)SEGHEADNAME	(3)SEGDUR	(4)DFLTDUR	 (5)SEGCHANCNT	 (6)VOCFILNAM  (7)VOCFILDUR	(8)	HEADFUSED (9) SEGTIME	10) DFLTTIME	11) SEGWAVNAME

proc VocodeDoTimestretching {vocdata} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages

	if {$segment(PAR0) == 1} {
		return $vocdata				;#	No tstretch necessary as vocoding elements have been cut to size
	}
	if {$segment(process) == "VOCODE"} {
		set msg4 "VOCODABLE-SIGNAL"
	} else {			;#	 "EDOCOV"
		set msg4 "VOCODING-SIGNAL"
	}
	catch {unset seg_src_wavs}
	set len [llength $vocdata]
	set kk 0
	while {$kk < $len} {
		set vocitem [lindex $vocdata $kk]
		set segno	[lindex $vocitem 0]
		set segfils	[lindex $vocitem 1]
		set segdur	[lindex $vocitem 3]
		set vocfil	[lindex $vocitem 6]
		set vocdur	[lindex $vocitem 7]
		switch -- $segment(PAR0) {
			2 -
			3 {								;#	Stretch the vocoding signal	
				set effective_dur [expr $segdur + $segment(SPLICE)]	;#	Need to allow for dovetail after vocode
				set stratio [expr $effective_dur/$vocdur]
				set ichans 1				;#	Always stretching a mono source
				set msg2 "$msg4 FOR SEGMENT $segno"
				set stretch_src 0
			}
			default {						;#	Stretch the src segment		
				set effective_dur [expr $vocdur + $segment(SPLICE)]	;#	Need to allow for dovetail after vocode
				set stratio [expr $effective_dur/$segdur]
				set ichans	[lindex $vocitem 5]
				set msg2 "SOURCE SEGMENT $segno"
				set stretch_src 1
			}
		}
		set OK 1
		set kjk 0
		set ichancnt 1
		while {$ichancnt <= $ichans} {
			if {$stretch_src} {
				set ifnam [lindex $segfil $kjk]
			} else {
				set ifnam $vocfil
			}
			set msg3 $msg2
			if {$ichans > 1} {
				append msg3 " CHANNEL $ichancnt"
			}
			set ofnam [GetVocodeOutnam $ifnam]
			set cmd [file join $evv(CDPROGRAM_DIR) stretch]
			lappend cmd time 1 $ifnam $ofnam $stratio
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        TIMESTRETCHING $msg3"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN TIMESTRETCHING OF $msg3"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE TIMESTRETCHED $msg3"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO TIMESTRETCHED $msg3 CREATED"
				set OK 0
				break
			}
			if {$stretch_src} {
				if {$ichans == 1} {
					set segfils $ofnam
				} else {
					set segfils [lreplace $segfils $kjk $kjk $ofnam]	;#	Replace 1 or more channels of src by its tstretched version
				}
				set qfnam [file rootname $ofnam]
				append qfnam $evv(SNDFILE_EXT)
				set segment(fadesnd) segment(fadesnd_dflt)
				if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
					Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd synth $ofnam $segment(fadesnd)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF TIMESTRETCHED $msg3"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN WAVEFORM CREATION FOR TIMESTRETCHED $msg3"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE WAVEFORM OF TIMESTRETCHED $msg3"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $segment(fadesnd)]} {
					Inf "NO WAVEFORM OF TIMESTRETCHED $msg3 CREATED"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) envel]
				lappend cmd dovetail 1 $segment(fadesnd) $qfnam $segment(frametime) $segment(frametime)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING DOVETAILED WAVEFORM OF TIMESTRETCHED $msg3"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN DOVETAILING OF WAVEFORM FOR TIMESTRETCHED $msg3"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE DOVETAILED WAVEFORM OF TIMESTRETCHED $msg3"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $qfnam]} {
					Inf "NO DOVETAILED WAVEFORM OF TIMESTRETCHED $msg3 CREATED"
					set OK 0
					break
				}
				lappend seg_src_wavs $qfnam				
			} else {
				set vocfil $ofnam										;#	Replace vocoding-sig by its tstretched version
			}
			incr ichancnt
			incr kjk
		}
		if {!$OK} {
			set vocdata [lreplace $vocdata $kk $kk]
			incr len -1
			continue
		}
		if {$stretch_src} {
			set vocitem [lreplace $vocitem 1 1 $segfils]				;#	Replace srcfile or src-filelist in vocsegs entry
			set newsegdur  [lindex $vocitem 7]							
			set origsegdur [lindex $vocitem 3]
			set vocitem [lreplace $vocitem 3 3 $newsegdur]				;#	Replace segdur with duration of voc-signal
			set vocitem [lreplace $vocitem 7 7 $origsegdur]				;#	Retain orig segdur for later mixfile-substitution calculations
			set vocitem [lreplace $vocitem 11 11 $seg_src_wavs]			;#	Replace original seg-wav srcs by tstretched seg wav-srcs
		} else {
			set vocitem [lreplace $vocitem 6 6 $vocfil]					;#	Replace vocoding-sig in vocsegs entry (same duration as orig)
		}
		set segment(vocsegs) [lreplace $segment(vocsegs) $kk $kk $vocitem]
		incr kk
	}
	if {$len <= 0} {
		return 0
	}
	return $vocdata
}

#----- Do the vocoding
#
#	VOCDATA = list (0)	SEGNO	(1)SEGNAME	(2)SEGHEADNAME	(3)SEGDUR	(4)DFLTDUR	 (5)SEGCHANCNT	 (6)VOCFILNAM  (7)VOCFILDUR	(8)	HEADFUSED (9) SEGTIME	10) DFLTTIME	11) SEGWAVNAME
#						  *			  *							 *						    *				*		 (if PAR0=4		    *
#															  Vocoded												 orig segdur	
#															  Segdur												 before tstr)
#																														  *
#				file1 is shaped by the vocoding
#					  file2 provides vocode info
#	cmd= vocode	file1 file2 outfile
#
#	File may be clipped on pvoc resynth, so reduce levels and rerun whole cycle
#

proc DoVocoding {vocdata} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages overload_line

	;#	PARAMS FOR READING CONTROL FILES

	set n 1
	while {$n <= $segment(vparams_cnt,$segment(process))} {
		if {[info exists segment(control$n,$segment(process))]} {
			set segment(zlim,$n) [expr [llength $segment(control$n,$segment(process))] - 1]
			set segment(zccnt,$n) 0
		}
		incr n
	}
	set len [llength $vocdata]
	set kjk 0
	while {$kjk < $len} {
		set vocitem [lindex $vocdata $kjk]
		set segno	[lindex $vocitem 0]
		if {$segment(phrase)} {
			set hno $segno
		} else {
			set tno [expr $segno/2]
			if {!$segment(headfirst)} {
				incr tno
			}
		}
		set segdur  [lindex $vocitem 3]
		set vocfil  [lindex $vocitem 6]
		set segfils [lindex $vocitem 1]
		set swgfils [lindex $vocitem 11]			;#	wavfils from which segfils are derived
		set origsegdur [lindex $vocitem 7]
		set chancnt [llength $segfils]
		set channo 1
		set OK 1
		set gain 1.0
		while {$OK} {
		
			;#	GET EACH VOCODING FILE (WITH HEAD FUSION, MAY BE SEVERAL CHANS), VOCODE AND RESYNTH
			
			catch {unset ifnams}
			catch {unset ofnams}
			foreach segfil $segfils swgfil $swgfils {
				if {$segment(phrase)} {
					set msg2 "PHRASE $segno" 
				} else {
					set msg2 "SEGMENT $segno"
				}
				if {$chancnt > 1} {
					append  msg2 " CHANNEL $channo"
				}
				set ofnam [file rootname [file tail $segfil]]
				append ofnam "_VV" $evv(ANALFILE_EXT)
				if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
					Inf "CANNOT DELETE INTERMEDIATE VOCODE FILE $ofnam : $zit"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) formants]
				if {$segment(process) == "VOCODE"} {
					lappend cmd vocode $vocfil $segfil $ofnam -p4
				} else {			;#	 "EDOCOV"
					lappend cmd vocode $segfil $vocfil $ofnam -p4
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        VOCODING USING $msg2"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN VOCODING USING $msg2"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE VOCODED OUTPUT WITH $msg2"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO VOCODED OUTPUT WITH $msg2 CREATED"
					set OK 0
					break
				}
				set ifnam $ofnam
				set ofnam [file rootname $ofnam]
				append ofnam $evv(SNDFILE_EXT)

				if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
					Inf "CANNOT DELETE INTERMEDIATE VOCODE FILE $ofnam : $zit"
					set OK 0
					break
				}
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd synth $ifnam $ofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset overload_line}
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF VOCODED OUTPUT FOR $msg2"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN WAVEFORM CREATION FOR VOCODED OUTPUT FOR $msg2"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "GetPostVocodeOverloadLine"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE WAVEFORM OF VOCODED OUTPUT FOR $msg2"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO WAVEFORM OF VOCODED OUTPUT FOR $msg2 CREATED"
					set OK 0
					break
				}
				;#		CHECK IF PVOC OUTPUT HAS OVERLOADED

				if {[info exists overload_line]} {
					set nugain [VocodeResynthOverloaded]
					if {$nugain < $gain} {
						set gain $nugain
					}
				}

				;#	ASSEMBLE ALL ANA (ifnam) AND WAV (ofnam) VERSIONS OF VOCODED FILES

				lappend ifnams $ifnam
				lappend ofnams $ofnam
				incr channo
			}
			if {!$OK} {
				break
			}

				;#	IF (ANY) PVOC OUTPUT HAS OVERLOADED, REDUCE LEVEL AND RERUN (ALL) PVOC SYNTH(S)

			if {$gain < 1.0} {
				foreach ifnam $ifnams ofnam $ofnams {
					set zfnam [file rootname $ofnam]
					lappend zfnam "_G" $evv(ANALFILE_EXT)
					set cmd [file join $evv(CDPROGRAM_DIR) spec]	
					lappend cmd gain $ifnam $zfnam $gain
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        ADJUSTING LEVEL OF VOCODED OUTPUT FOR $msg2"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN LEVEL ADJUSTMENT OF VOCODED OUTPPUT FOR $msg2"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE LEVEL-ADJUSTED VOCODED OUTPUT FOR $msg2"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $zfnam]} {
						Inf "NO LEVEL-ADJUSTED VOCODED OUTPUT FOR $msg2 CREATED"
						set OK 0
						break
					}

					;#	OVERWRITE ORIGINAL VOCODED (wav) OUTPUT

					if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
						Inf "CANNOT DELETE INTERMEDIATE VOCODING FILE $ofnam : $zit"
						set OK 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd synth $zfnam $ofnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF GAIN-ADJUSTED VOCODED $msg2"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN WAVEFORM CREATION FOR GAIN-ADJUSTED VOCODED OUTPUT FOR $msg2"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE WAVEFORM OF GAIN-ADJUSTED VOCODED OUTPUT FOR $msg2"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO WAVEFORM CREATED OF GAIN-ADJUSTED VOCODED OUTPUT FOR $msg2"
						set OK 0
						break
					}
				}
				if {!$OK} {															;#	Vocode failed, delete vocdata for this segment
					break
				}
			}
			if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(othersnd) : $zit"
				set OK 0
				break
			}

			;#	IF NECESSARY, INTERLEAVE CHANNELS TO MAKE MULTICHANNEL OUTPUT

			if {$chancnt == 1} {
				if {[catch {file rename $ofnam $segment(othersnd)} zit]} {
					Inf "CANNOT RENAME VOCODED FILE $ofnam : $zit"
					set OK 0
					break
				}
			} else {
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd interleave
				foreach ofnam $ofnams {
					lappend cmd $ofnam
				}
				lappend cmd $segment(othersnd)

				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        MERGING CHANNELS OF VOCODED OUTPUT FOR $msg2"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN CHANNEL MERGE OF VOCODED $msg2"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE CHANNEL-MERGED VOCODED OUTPUT FOR $msg2"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $segment(othersnd)]} {
					Inf "NO CHANNEL-MERGED VOCODED OUTPUT FOR $msg2 CREATED"
					set OK 0
					break
				}
			}

			;#	IF NECESSARY, DO CROSSFADE

			set segment(fadesnd) $segment(fadesnd_dflt)
			if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
				Inf "CANNOT DELETE INTERMEDIATE FILE $segment(fadesnd) : $zit"
				set OK 0
				break
			}

			set leftbase [expr $segno - 1]
			set sttcros [GetParamValueFromControl $leftbase 1]
			set endcros	[GetParamValueFromControl $leftbase 2]
			set crospow [GetParamValueFromControl $leftbase 3]

			set do_cros 1
			if {($sttcros == 1.0) && ($endcros == 1.0)} {
				set do_cros 0
			}
			if {$do_cros} {
				set crosOK 1
				set srcfnam $swgfil
				set vocfnam $segment(othersnd)
				while {$crosOK} {

					;#	IF CROSSFADE, CREATE SLOPE OF CROSSFADE

					catch {unset env}
					if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
						Inf "CANNOT DELETE INTERMEDIATE FILE $segment(envfil) : $zit"
						set crosOK 0
						break
					}													;#				0.0  0.6   		raised	
					if {$crospow != 1} {								;#				  0.3  1.0		to pow		*diff		+sttcros
						set line [list 0.0 $sttcros]					;# _____ 1						______		______		______
						lappend env $line								;#				 _______			 x
						set diff [expr $endcros - $sttcros]				;# ___			       x			 x					______
						set val [expr pow(0.333,$crospow)]				;#	|  endcros	       x   		    x		_____		     x
						set val [expr $val * $diff]						;#	|			     x  		    x	  	    x		    xx	
						set val [expr $val + $sttcros]					;# diff			     x						   xx		    x 
						set line [list [expr $segdur * 0.3333] $val]	;#	|			   x			   x		   x		   x
						lappend env $line								;#	|			   x			   x	   	  x			x  x
						set val [expr pow(0.666,$crospow)]				;# _|__sttcros   x			   x		   x  x			x_____
						set val [expr $val * $diff]						;# _____ 0		_x________	   x______	   x______		______
						set val [expr $val + $sttcros]
						set line [list [expr $segdur * 0.6666] $val]
						lappend env $line
						set line [list $segdur $endcros]
						lappend env $line
					} else {
						set line [list 0.0 $sttcros]
						lappend env $line
						set line [list $segdur $endcros]
						lappend env $line
					}
					if {[catch {open $segment(envfil) "w"} zit]} {
						Inf "CANNOT OPEN ENVELOPE FILE TO CROSSFADE DATA"
						set crosOK 0
						break
					} else {
						foreach line $env {
							puts $zit $line
						}
						close $zit
					}

					set cmd [file join $evv(CDPROGRAM_DIR) submix]
					lappend cmd balance $vocfnam $srcfnam $segment(fadesnd) -k$segment(envfil)
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        CROSSFADING VOCODED OUTPUT FOR $msg2"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN CROSSFADE OF VOCODED OUTPUT FOR $msg2"
						catch {unset CDPidrun}
						set crosOK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE CROSSFADED VOCODED OUTPUT FOR $msg2"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set crosOK 0
						break
					}
					if {![file exists $segment(fadesnd)]} {
						Inf "NO CROSSFADED VOCODED OUTPUT FOR $msg2 CREATED"
						set crosOK 0
						break
					}
					break
				}
				if {!$crosOK} {

					Inf "CROSSFADING VOCODED OUTPUT FOR SEGMENT $segno FAILED"
					set do_cros 0		;#	CROSSFADING FAILED - USE UNCROSSFADED
				}
			}
			if {!$do_cros} {

				;#	IF NOT CROSSFADING, RENAME VOCODED SIG

				if [catch {file rename $segment(othersnd) $segment(fadesnd)} zit] {
					Inf "CANNOT RENAME INTERMEDIATE FILE $segment(fadesnd) (VOCODED OUTPUT FOR $msg2) \n$zit"
					set OK 0
					break
				}
			}
			set ofnam $evv(MACH_OUTFNAME)
			if {$segment(phrase)} {
				append ofnam PH$hno$evv(SNDFILE_EXT)
			} else {
				append ofnam PT$tno$evv(SNDFILE_EXT)
			}
			if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
				Inf "CANNOT DELETE PRE-EXISTING FILE $ofnam : $zit"
				set OK 0
				break
			}
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd dovetail 1 $segment(fadesnd) $ofnam $segment(SPLICE) $segment(SPLICE) 1 1 -t0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        DOVETAILING VOCODED OUTPUT FROM SEGMENT $segno"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO DOVETAIL VOCODED OUTPUT FROM SEGMENT $segno"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE DOVETAILED VOCODED OUTPUT FROM SEGMENT $segno"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO DOVETAILED VOCODED OUTPUT FROM SEGMENT $segno CREATED"
				set OK 0
				break
			}
			break
		}
		if {!$OK} {															;#	VOcode failed, delete vocdata for this segment
			set vocdata [lreplace $vocdata $kjk $kjk]
			incr len -1
			continue
		}

		;#	SUBSTITUTE VOCODED SOUND IN MIXFILE

		set headfused [lindex $vocitem 8]
		catch {unset file_to_eliminate}
		set newsegdur [lindex $vocitem 3]
		if {![string match $headfused 0]} {
			set file_to_eliminate $headfused
			set	headfused 1
		}
		set segtime	[lindex $vocitem 9]
		set mlen [llength $segment(mixlines)]
		set nnn 0
		catch {unset tadjusts}
		while {$nnn < $mlen} {
			set mixline [lindex $segment(mixlines) $nnn]
			if {[llength $mixline] > 1} {
				set time [lindex $mixline 1]
				if {[Flteq $time $segtime]} {
					set mixline [lreplace $mixline 0 0 $ofnam]
					set segment(mixlines) [lreplace $segment(mixlines) $nnn $nnn $mixline]
					lappend tadjusts [list $nnn [expr $segdur - $origsegdur]]		;#	Has segment changed in size ??
					break
				}
			}
			incr nnn
		}
		if {$nnn >= $mlen} {
			Inf "FAILED TO FIND SUBSTITUTION LINE(S) IN MIXFILE"
			set vocdata [lreplace $vocdata $kjk $kjk]
			incr len -1
			continue
		}
		if [info exists file_to_eliminate] {
			set nnn 0
			while {$nnn < $mlen} {
				set mixline [lindex $segment(mixlines) $nnn]
				if {[llength $mixline] > 1} {
					set fnam [lindex $mixline 0]
					if {[string match $fnam $file_to_eliminate]} {
						set segment(mixlines) [lreplace $segment(mixlines) $nnn $nnn]
						incr mlen -1
						break
					}
				}
				incr nnn
			}
		}
		incr kjk
	}			
	if {$len <= 0} {
		Inf "FAILED TO VOCODE ANY SEGMENTS"
		return 0
	}
	if {[info exists tadjusts]} {
		foreach tadjust $tadjusts {
			set substituted_line [lindex $tadjust 0]
			set timeshift		 [lindex $tadjust 1]
			if {$timeshift > 0} {
				set kkk $substituted_line
				incr kkk
				while {$kkk < $mlen} {
					set line [lindex $segment(mixlines) $kkk]
					set tim [lindex $line 1]
					set tim [expr $tim + $timeshift]
					set line [lreplace $line 1 1 $tim]
					set segment(mixlines) [lreplace $segment(mixlines) $kkk $kkk $line]
					incr kkk
				}
			}
		}			
	}
	ClearIntermediateVocodeFiles
	if {!$OK} {
		return 0
	}
	return $vocdata
}

#--- For Vocode : report if any segs not vocoded

proc VocodingReport {vocdata} {
	global segment
	if {$vocdata == 0} {
		Inf "VOCODING FAILED FOR ALL SEGMENTS"
		return 0
	}
	if {$segment(multiproccnt)} {
		foreach dud $segment(multido) {
			if {[lindex $dud 0] == $segment(process)} {
				set actionlist [lindex $dud 1]
				break
			}
		}
	}
	foreach vocitem $vocdata {
		lappend segnos [lindex $vocitem 0]
	}
	set kk 1
	if {!$segment(phrase) && $segment(headfirst)} {
		incr kk
	}
	while {$kk <= $segment(cnt)} {
		if {$segment(multiproccnt)} {
			set action [lindex $actionlist $kk]
		} else {
			set action 1
		}
		if {$action && ([lsearch $segnos $kk] < 0)} {
			lappend badsegs $kk
		}
		incr kk
		if {!$segment(phrase)} {
			incr kk
		}
	}
	if {[info exists badsegs]} {
		set msg "VOCODING FAILED FOR THESE SEGMENTS\n"
		foreach badseg $badsegs {
			append msg "  $badseg"
		}
		Inf $msg
	}
	return 1
}

#--- For Vocode (if not a multiprocess) set up segment(mixfile) for case of NO processing

proc VocodeMakePreliminaryMixFile {} {
	global segment evv
	set tcnt 1
	set hcnt 1
	set is_head 0
	if {$segment(headfirst)} {
		set is_head 1
	}
	set k 0
	while {$k < $segment(cnt)} {
		set time [lindex $segment(marklist) $k]
		if {$is_head} {
			set time [expr $time - $segment(SPLICE)]
			if {$time < 0.0} {
				set time 0.0
			}
			set fnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
			set mixline [list $fnam $time 1 1.0]
			lappend mixlines $mixline
			incr hcnt
		} else {
			set fnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
			set mixline [list $fnam $time 1 1.0]
			lappend mixlines $mixline
			incr tcnt
		}
		set is_head [expr !$is_head]
		incr k
	}
	set segment(mixlines) $mixlines
}

#--- Read any "OVERLOAD" info sent by "Texture" program

proc GetPostVocodeOverloadLine {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages overload_line

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		} else {
			lappend overload_line $line
			return
		}
	}
	update idletasks
}

proc VocodeResynthOverloaded {} {
	global overload_line segment
	foreach line $overload_line {
		if {[string first "You should reduce" $line] >= 0} {
			set line [string trim $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {[IsNumeric $item]} {
					set item [expr $item * $segment(maxlev)]
					return $item
				}
			}
		}
	}
	return 1.0
}

#################
# MISCELLANEOUS #
#################

#-- Ensures that dflt are not changed to output names, for a new run

proc ResetDfltFilenames {} {
	global segment
	set segment(troflist)	$segment(troflist_dflt)
	set segment(nutroflist)	$segment(nutroflist_dflt)
	set segment(prectrlfil)	$segment(prectrlfil_dflt)
	set segment(controlfil)	$segment(controlfil_dflt)
	set segment(outfnamplay) $segment(outfnamplay_dflt)
	set segment(outfnam)    $segment(outfnam_dflt)
}

#--- Test routine to catch any attempt to use processes that are not yet implemented

proc NonImplementedProcess {procc} {
	switch -- $procc {
		PLUCKED -
		DISTREP -
		DELRING -
		VIBRATO -
		TREMOLO -
		REVERB -
		LOOP -
		SCAN -
		VERGES -
		TUNED -
		PITCH -
		SUPPRESS -
		RETIME -
		TEXTURE -
		BOUNCE  -
		TWANG  -
		FORMOVE -
		VOCODE - 
		EDOCOV -
		TRANSFER -
		ZIGZAG -
		ITERATE -
		TIMESTRETCH -
		REVERSAL -
		SHRHYTHM -
 		ARTICULATION -
		ZIGACCEL -
		HPITCH -
		PINCH -
		SQUASH -
		LIQUID -
		SQUEEZE -
		DEEPEN -
		DEEPREV -
		TUBEREV -
		SPIKE -
		SQZBOX -
		TSTRETCH -
		ROUGHEN -
		RANDSTEP -
		ACCENT {
			return 0
		}
	}
	Inf "PROCESS $procc NOT YET IMPLEMENTED"
	return 1
}
#--- Does process (in multiprocess) require preset flags or params?

proc GettrofProcessHasPresets {} {
	global segment
	switch -- $segment(process) {
		TEXTURE -
		BOUNCE  -
		TUNED   -
		PITCH   -
		DELRING -
		VERGES -
		DISTREP -
		REVERB -
		TREMOLO -
		LOOP -
		FORMOVE -
		VOCODE -
		EDOCOV -
		TRANSFER -
		ZIGACCEL -
		HPITCH -
		TUBEREV -
		SPIKE -
		SQZBOX -
		TSTRETCH -
		TWANG {
			return 1
		}
	}
	return 0
}

#--- Does process add extra files to the mix (rather than simply replacing existing ones) ?

proc GettrofProcessMayInsertExtraFile {} {
	global segment
	if {[MultipleProcessing]} {
		foreach dud $segment(multido) {
			set procc [lindex $dud 0]
			lappend procs $procc
		}
	} else {
		set procs [list $segment(process)]
	}
	foreach procc $procs {
		switch -- $procc {
			TEXTURE -
			BOUNCE  {
				return 1
			}
		}
	}
	return 0
}


#--- May process shift times of existing segments

proc GettrofProcessesMayTimeExtendSegments {} {
	global segment
	if {[MultipleProcessing]} {
		foreach dud $segment(multido) {
			set procc [lindex $dud 0]
			lappend procs $procc
		}
	} else {
		set procs [list $segment(process)]
	}
	foreach procc $procs {
		switch -- $procc {
			BOUNCE  {
				return 1
			}
		}
	}
	return 0
}

#--- Possibly save the segmentation-marks, the component files and the mix associated with the output sound.

proc PossiblySaveDataRelatedToOutputSound {} {
	global segment wstk evv shrhy
	if {$segment(process) == "SHRHYTHM"} {									;#	ALWAYS Save MM and Scansion data for shrhythm files
		foreach qstep $shrhy(qsteps) scan $shrhy(scansion) { 
			switch -- $qstep {
				1 {
					set scanval "."
				}
				2 {
					if {$scan == "."} {
						set scanval "./"
					} else {
						set scanval "_"
					}
				}
				default {
					if {$scan == "."} {
						set scanval "./"						;#	qstep			3	4	5	6	7
					}
					set restlen [expr $qstep - 2]				;#	restlen			1	2	3	4	5
					set longrestlen [expr $restlen/2]			;#	longrestlen		0	1	1	2	2
					set k 0
					while {$k < $longrestlen} {					;#	longrestlen=0	
						append scanval "~"						;#	restlen remains	1
						incr k									;#	else restlen-2
						incr restlen -2							;#	goes to				0	1	0	1
					}
					if {$restlen > 0} {							
						append scanval "/"
					}
				}
			}
			lappend scanvals $scanval
		}
		set basfnam [file join $segment(dirname) $segment(lastnam,sound)]
		set mmfnam $basfnam
		append mmfnam "_mm" $evv(TEXT_EXT)
		set scfnam $basfnam
		append scfnam "_scan" $evv(TEXT_EXT)
		set acfnam $basfnam
		append acfnam "_acc" $evv(TEXT_EXT)
		set OK 1
		while {$OK} {
			if {[file exists $mmfnam] && [catch {file delete $mmfnam} zit]} {
				Inf "CANNOT DELETE EXISTING \"MM\" TEMPO DATA FILE FOR SOUND $segment(lastnam,sound)"
				break
			}
			if {[file exists $scfnam] && [catch {file delete $scfnam} zit]} {
				Inf "CANNOT DELETE EXISTING SCANSION DATA FILE FOR SOUND $segment(lastnam,sound)"
				break
			}
			if {[file exists $acfnam] && [catch {file delete $acfnam} zit]} {
				Inf "CANNOT DELETE EXISTING ACCENTUATION DATA FILE FOR SOUND $segment(lastnam,sound)"
				break
			}
			if [catch {open $mmfnam "w"} zit] {
				break
			}
			if [catch {open $scfnam "w"} zit2] {
				close $zit
				break
			}
			if [catch {open $acfnam "w"} zit3] {
				close $zit
				close $zit2
				break
			}
			puts $zit $shrhy(MM)
			close $zit
			puts $zit2 $scanvals
			close $zit2
			puts $zit3 $shrhy(accents)
			close $zit3
			break
		}																	;#	Possibly save segmentation data
	}
	switch -- $segment(process) {
		"PINCH" -
		"SQUASH" -
		"LIQUID" -
		"SQUEEZE" -
		"DEEPEN" -
		"DEEPREV" -
		"TUBEREV" -
		"SPIKE" -
		"ROUGHEN" -
		"RANDSTEP" {
			set msg "SAVE ORIGINAL SEGMENTATION OF INPUT SOUND, FOR OUTPUT SOUND ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				SaveNewMarks 0 1
			}
		}
		default {
			if {($segment(process) == "TSTRETCH") && ([llength $segment(numarks)] <= 0)} {
				return
			}
			if {($segment(process) == "HPITCH") || ($segment(process) == "SQZBOX") || ($segment(process) == "TSTRETCH") || \
			(!$segment(phrase) && !$segment(nonewmarks) \
			&& ($segment(process) != "TIMESTRETCH") && ($segment(process) != "ZIGZAG") \
			&& ($segment(process) != "SHRHYTHM") && ($segment(process) != "ARTICULATION"))} {
				set msg "SAVE NEW SEGMENTATION FOR OUTPUT SOUND ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {($segment(process) == "HPITCH") || ($segment(process) == "SQZBOX")} {
						SaveNewMarks 1 0
					} else {
						SaveNewMarks 0 0
					}
				}
			}
		}
	}
	set segment(nonewmarks) 0												;#	Possibly save segments and mixfile (for further work)

	if {($segment(process) != "TIMESTRETCH") && ($segment(process) != "ZIGZAG") && ($segment(process) != "REVERSAL")} {
		set msg "SAVE OUTPUT SOUND COMPONENTS AND ASSOCIATED MIXFILE ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -default no -message $msg]
		if {$choice == "yes"} {
			ExportSegmentation 1
		}
	}
}

#--- Does process (selected in multiprocess) delete Heads ?

proc TailProcessMayMergeHeadToTail {prcc} {
	global segment
	if {[lsearch $segment(headdellist) $prcc] >= 0} {
		return 1
	}
	return 0
}

#--- Force any head-deleting process to end of multiprocesses order, and if there are more than 1, warn

proc HeadDeletersToEnd {len} {
	global segment
	set head_deleter 0
	set n 0
	while {$n < $len} {
		set dud [lindex $segment(multido) $n]
		set prcc [lindex $dud 0]
		if {[TailProcessMayMergeHeadToTail $prcc]} {
			if {[info exists hd]} {
				set k [lsearch $hd $prcc]
				if {$k < 0} {
					lappend hd $prcc
					incr head_deleter
				}
			} else {
				lappend hd $prcc
				incr head_deleter
			}
			set segment(multido) [lreplace $segment(multido) $n $n]
			lappend segment(multido) $dud
		}
		incr n
	}
	if {$head_deleter > 1} {
		set msg "\"Tune Head also\" CAN ONLY BE USED IN THE LAST OF THE PROCESSES\n"
		foreach prcc $hd {
			append msg "$prcc  "
		}
		append msg "\n"
		Inf $msg
	}
}

#--- Force any head-deleting process to end of multiprocesses order, and if there are more than 1, warn

proc VergesProcessToEnd {len} {
	global segment
	set n 0
	while {$n < $len} {
		set dud [lindex $segment(multido) $n]
		set prcc [lindex $dud 0]
		if {$prcc == "VERGES"} {
			set segment(multido) [lreplace $segment(multido) $n $n]
			lappend segment(multido) $dud
			break
		}
		incr n
	}
}

#--- Force any head-deleting process to end of multiprocesses order, and if there are more than 1, warn

proc SuppressProcessToEnd {len} {
	global segment
	set n 0
	set segment(suppress_used) 0
	while {$n < $len} {
		set dud [lindex $segment(multido) $n]
		set prcc [lindex $dud 0]
		if {$prcc == "SUPPRESS"} {
			set segment(multido) [lreplace $segment(multido) $n $n]
			lappend segment(multido) $dud
			set segment(suppress_used) 1
			break
		}
		incr n
	}
}

#--- Is current mixfile format a multichannel format ?

proc GettrofIsMultiChanMix {mixlines} {
	if {[llength [lindex $mixlines 0]] > 1} {
		return 0
	}
	return 1
}

#---- Play output sound

proc GettrofPlayOutputSound {} {
	global segment
	if {![file exists $segment(outfnamplay)]} {
		Inf "NO OUTPUT FILE TO PLAY"
		return 0
	}
	PlaySndfile $segment(outfnamplay) 0
	return 1
}

#---- Return max number of channels in a PSEUDO-non-multichan mixdown file 

proc GettrofMixChancnt {} {
	global segment
	set chans 0
	foreach line $segment(mixlines) {
		if {[llength $line] >= 3} {
			set chan [lindex $line 2]
			if {$chan > $chans} {
				set chans $chan
			}
		}
	}
	return $chans
}

#---- Return format of an existing REAL mixdown file

proc GettrofMixFormat {} {
	global segment
	if {![info exists segment(mixlines)]} {
		return -1
	}
	set chans 0
	if {[llength [lindex $segment(mixlines) 0]] == 1} {
		return 1
	}
	 return 0
}

#--- Convert REAL mixdown file back to pseudo-non-multichan format, if ness

proc GettrofDeconvertMultichanFormat {} {
	global segment
	set cnt 0
	foreach line $segment(mixlines) {
		if {$cnt == 0} {
			if {[llength $line] > 1} {		;#	Not multichan format
				return
			}
			incr cnt						;#	Else, skip line 1
			continue
		}
		set nuline [lrange $line 0 2]
		lappend nuline [lindex $line end]
		lappend nulines $nuline
	}
	set segment(mixlines) $nulines
}

#---- Turning various displays ON and OFF

proc GettrofRetimeOff {} {
	global pr_gettrofs 
	.gettrofs.9.r.tit config -text ""
	.gettrofs.9.r.ovr config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.r.csp config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.r.shp config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.r.shr config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.r.srs config -text "" -command {} -state disabled -bd 0
}

proc GettrofRetimeOn {} {
	global pr_gettrofs segment
	.gettrofs.9.r.tit config -text "RETIMING PROCESSES"
	.gettrofs.9.r.ovr config -text "OVERLAP & SPACE"  -command "set segment(retimestyle) OVERLAP; set pr_gettrofs RETIME"		-state normal -bd 2
	.gettrofs.9.r.csp config -text "CUT & SPACE"	  -command "set segment(retimestyle) CUT;	  set pr_gettrofs RETIME"		-state normal -bd 2
	.gettrofs.9.r.shp config -text "SHRINK & SPACE"   -command "set segment(retimestyle) SHRINK;  set pr_gettrofs RETIME"		-state normal -bd 2
	.gettrofs.9.r.shr config -text "SHRINK & STRETCH" -command "set segment(retimestyle) STRETCH; set pr_gettrofs RETIME"		-state normal -bd 2
	.gettrofs.9.r.srs config -text "SHRINK RHYTHMS"   -command "set pr_gettrofs SHRHYTHM"		-state normal -bd 2
	.gettrofs.7.bak config -text "Backtrack"		  -command "ResetGetSyllabTrofs RECHOOSE"	-state normal -bd 4
}

proc GettrofWarpOff {} {
	global pr_gettrofs 
	.gettrofs.9.w.tit config -text ""
	.gettrofs.9.w.tst config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.w.itr config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.w.ziz config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.w.rvl config -text "" -command {} -state disabled -bd 0
}

proc GettrofWarpOn {} {
	global pr_gettrofs 
	.gettrofs.9.w.tit config -text "TIMEWARP PROCESSES"
	.gettrofs.9.w.tst config -text "SPECTRAL STRETCH" -command "set pr_gettrofs TIMESTRETCH"	 -state normal -bd 2
	.gettrofs.9.w.itr config -text "ITERATE STRETCH"  -command "set pr_gettrofs ITERATE"		 -state normal -bd 2
	.gettrofs.9.w.ziz config -text "ZIGZAG STRETCH"	  -command "set pr_gettrofs ZIGZAG"			 -state normal -bd 2
	.gettrofs.9.w.rvl config -text "TIME REVERSALS"   -command "set pr_gettrofs REVERSAL"		 -state normal -bd 2
	.gettrofs.7.bak config -text "Backtrack"		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
}

proc GettrofTailsOff {} {
	.gettrofs.9.t.tit config -text ""
	.gettrofs.9.t.gra config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.plu config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.drp config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.dng config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.vib config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.trm config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.rev config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.lop config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.scn config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.zac config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.fom config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.tun config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.pch config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.spc config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.mny config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.for config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.t.trf config -text "" -command {} -state disabled -bd 0
}

proc GettrofTailsOn {} {
	global pr_gettrofs segment released
	.gettrofs.9.t.tit config -text "TAIL PROCESSES"
	.gettrofs.9.t.gra config -text "SUPPRESS"		  -command "set pr_gettrofs SUPPRESS" -state normal -bd 2
	.gettrofs.9.t.plu config -text "PLUCKED"		  -command "set pr_gettrofs PLUCKED"  -state normal -bd 2
	.gettrofs.9.t.drp config -text "WAVESET REPEAT"   -command "set pr_gettrofs DISTREP"  -state normal -bd 2
	.gettrofs.9.t.dng config -text "DELAY RING"		  -command "set pr_gettrofs DELRING"  -state normal -bd 2
	.gettrofs.9.t.vib config -text "VIBRATO"		  -command "set pr_gettrofs VIBRATO"  -state normal -bd 2
	.gettrofs.9.t.trm config -text "TREMOLO"		  -command "set pr_gettrofs TREMOLO"  -state normal -bd 2
	.gettrofs.9.t.rev config -text "REVERB"		      -command "set pr_gettrofs REVERB"	  -state normal -bd 2
	.gettrofs.9.t.lop config -text "LOOP"			  -command "set pr_gettrofs LOOP"	  -state normal -bd 2
	.gettrofs.9.t.scn config -text "SCAN"			  -command "set pr_gettrofs SCAN"	  -state normal -bd 2
	.gettrofs.9.t.zac config -text "ZIG ACCEL"		  -command "set pr_gettrofs ZIGACCEL" -state normal -bd 2
	.gettrofs.9.t.fom config -text "MOVE FORMANTS"	  -command "set pr_gettrofs FORMOVE"  -state normal -bd 2
	.gettrofs.9.t.tun config -text "TUNED"			  -command "set pr_gettrofs TUNED"	  -state normal -bd 2
	.gettrofs.9.t.pch config -text "PITCH LINE"		  -command "set pr_gettrofs PITCH"	  -state normal -bd 2
	.gettrofs.9.t.spc config -text "VOCODE"			  -command "set pr_gettrofs VOCODE"	  -state normal -bd 2
	.gettrofs.9.t.for config -text "BE VOCODED"		  -command "set pr_gettrofs EDOCOV"	  -state normal -bd 2
	if {[info exists released(integratetime)]} {
		.gettrofs.9.t.trf config -text "TRANSFER"	  -command "set pr_gettrofs TRANSFER" -state normal -bd 2
	}
	if {![info exists segment(recycprocess)]} {
		.gettrofs.9.t.mny config -text "A COMBINATION"	  -command "StartCombinedProcesses"			 -state normal -bd 2
	}
	.gettrofs.7.bak config -text "Backtrack"		  -command "ResetGetSyllabTrofs RECHOOSE"	 -state normal -bd 4
}

proc GettrofHeadsOff {} {
	.gettrofs.9.h.tit config -text ""
	.gettrofs.9.h.txt config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.h.bbb config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.h.stk config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.h.crm config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.h.ver config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.h.hep config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.h.mny config -text "" -command {} -state disabled -bd 0
}

proc GettrofHeadsOn {} {
	global pr_gettrofs segment
	.gettrofs.9.h.tit config -text "HEAD PROCESSES"
	.gettrofs.9.h.txt config -text "TEXTURE" -command "set pr_gettrofs TEXTURE" -state normal -bd 2
	.gettrofs.9.h.bbb config -text "BOUNCE"	 -command "set pr_gettrofs BOUNCE"	-state normal -bd 2
	.gettrofs.9.h.stk config -text "ACCENT"	 -command "set pr_gettrofs ACCENT"	-state normal -bd 2
	.gettrofs.9.h.crm config -text "TWANG"	 -command "set pr_gettrofs TWANG"	-state normal -bd 2
	.gettrofs.9.h.ver config -text "VERGES"	 -command "set pr_gettrofs VERGES"	-state normal -bd 2
	.gettrofs.9.h.hep config -text "PITCH"   -command "set pr_gettrofs HPITCH"	-state normal -bd 2
	if {![info exists segment(recycprocess)]} {
		.gettrofs.9.h.mny config -text "A COMBINATION" -command "StartCombinedProcesses"	   -state normal -bd 2
	}
	.gettrofs.7.bak config -text "Backtrack"	   -command "ResetGetSyllabTrofs RECHOOSE" -state normal -bd 4
}

proc GettrofSegmentsOff {} {
	.gettrofs.9.s.tit config -text ""
	.gettrofs.9.s.mny config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.reo config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.rem config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.rtc config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.pii config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.sqq config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.lqq config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.hss config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.dpp config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.dpr config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.tbr config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.rgg config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.rss config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.spk config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.sqb config -text "" -command {} -state disabled -bd 0
	.gettrofs.9.s.str config -text "" -command {} -state disabled -bd 0

}

proc GettrofSegmentsOn {for_phrases} {
	global pr_gettrofs
	.gettrofs.9.s.tit config -text "SEGMENT PROCESSES"
	.gettrofs.9.s.reo config -text "REORDER"	  -command "set pr_gettrofs REORDER"      -state normal -bd 2
	.gettrofs.9.s.rem config -text "REMOTIF"	  -command "set pr_gettrofs REMOTIF"      -state normal -bd 2
	.gettrofs.9.s.rtc config -text "ARTICULATE"	  -command "set pr_gettrofs ARTICULATION" -state normal -bd 2
	.gettrofs.9.s.pii config -text "PINCH"		  -command "set pr_gettrofs PINCH"		  -state normal -bd 2
	.gettrofs.9.s.sqq config -text "SQUASH"		  -command "set pr_gettrofs SQUASH"		  -state normal -bd 2
	.gettrofs.9.s.lqq config -text "LIQUIDISE"	  -command "set pr_gettrofs LIQUID"		  -state normal -bd 2
	.gettrofs.9.s.hss config -text "HIGH SQUEEZE" -command "set pr_gettrofs SQUEEZE"	  -state normal -bd 2
	.gettrofs.9.s.dpp config -text "DEEPEN"		  -command "set pr_gettrofs DEEPEN"		  -state normal -bd 2
	.gettrofs.9.s.dpr config -text "LOW RESONANCE" -command "set pr_gettrofs DEEPREV"	  -state normal -bd 2
	.gettrofs.9.s.tbr config -text "TUBE RESONANCE" -command "set pr_gettrofs TUBEREV"	  -state normal -bd 2
	.gettrofs.9.s.rgg config -text "ROUGHEN"	  -command "set pr_gettrofs ROUGHEN"	  -state normal -bd 2
	.gettrofs.9.s.rss config -text "RANDSTEP IN"  -command "set pr_gettrofs RANDSTEP"	  -state normal -bd 2
	.gettrofs.9.s.spk config -text "SPIKE"		  -command "set pr_gettrofs SPIKE"		  -state normal -bd 2
	.gettrofs.9.s.sqb config -text "SQUEEZEBOX"	  -command "set pr_gettrofs SQZBOX"		  -state normal -bd 2
	.gettrofs.9.s.str config -text "TIME STRETCH" -command "set pr_gettrofs TSTRETCH"	  -state normal -bd 2
	if {$for_phrases} {
		.gettrofs.9.s.mny config -text "A COMBINATION" -command "StartCombinedProcesses" -state normal -bd 2
		.gettrofs.7.bak config -text "" -command {} -state disabled -bd 0
	} else {
		.gettrofs.9.s.mny config -text "" -command {} -state disabled -bd 0
		.gettrofs.7.bak config -text "Backtrack" -command "ResetGetSyllabTrofs RECHOOSE" -state normal -bd 4
	}
}

proc HideParamEntry {all} {
	.gettrofs.10.fixd  config -text "" -command {} -state disabled -disabledforeground []
	.gettrofs.10.tvar  config -text "" -command {} -state disabled -disabledforeground []
	.gettrofs.11.asis  config -text "" -command {} -state disabled -disabledforeground []
	.gettrofs.11.flat  config -text "" -command {} -state disabled -disabledforeground []
	.gettrofs.11.lin   config -text "" -command {} -state disabled -disabledforeground []
	.gettrofs.11.tf    config -text "" -command {} -state disabled -disabledforeground []
	if {$all} {
		HideFixedValueEntryDisplay
	}
}

proc HideOutputActions {} {
	.gettrofs.14.pp.ou config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.pp.pp config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.pp.po config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.pp.tt config -text "\n\n" -state disabled  -disabledforeground []
	bind .gettrofs <Key-space> {}
	.gettrofs.14.pp.p config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.pp.v config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.pr config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.cy config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.14.sp config  -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
}

proc HideProcessTypeHeadings {} {
	.gettrofs.7.tw	config -text "" -command {} -bd 0 -state disabled
	.gettrofs.7.tp	config -text "" -command {} -bd 0 -state disabled
	.gettrofs.7.hp  config -text "" -command {} -bd 0 -state disabled
	.gettrofs.7.sp	config -text "" -command {} -bd 0 -state disabled
	.gettrofs.7.rt	config -text "" -command {} -bd 0 -state disabled
	.gettrofs.6.ex	config -text "" -command {} -bd 0 -state disabled
}

proc HideParamUseStyle {} {
	.gettrofs.11.asis  config -text "" -command {} -state disabled -bd 0 -disabledforeground []
	.gettrofs.11.flat  config -text "" -command {} -state disabled -bd 0 -disabledforeground []
	.gettrofs.11.lin   config -text "" -command {} -state disabled -bd 0 -disabledforeground []
	.gettrofs.11.tf    config -text "" -command {} -state disabled -bd 0 -disabledforeground []
}

proc HideFixedValueEntryDisplay {} {
	.gettrofs.12.ll  config -text ""
	.gettrofs.12.fxv config -state disabled -bd 0 -disabledbackground [option get . background {}]
	.gettrofs.12.do  config -text "" -command {} -state disabled -bd 0
	.gettrofs.12.hh  config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
	.gettrofs.12.dd  config -text "" -command {} -state disabled -bd 0
	.gettrofs.12.cc  config -text "" -command {} -state disabled -bd 0
	.gettrofs.12.vv  config -text "" -command {} -state disabled -bd 0
}

#--- Hide "Save to File" Block : If NOT "all", filename-in-use is being displayed or etc.

proc GettrofHideSaveToFile {all} {
	.gettrofs.3.s config -text ""   -command {} -state disabled -bd 0
	.gettrofs.3.n config -text ""   -command {} -state disabled -bd 0
	.gettrofs.4.nam config -text "" -command {} -state disabled -bd 0
	.gettrofs.4.pnm config -text "" -command {} -state disabled -bd 0
	if {$all} {
		.gettrofs.4.sav	config -text "" -command {} -state disabled -bd 0 -bg [option get . background {}]
		.gettrofs.4.ll config -text ""
	}
}

#--- Display name of fixed-or-variable param, and the Fixed & Variable selection buttons

proc SetupFixvarParam {} {
	global segment
	if {($segment(vp) == 1) && (($segment(process) == "TUNED") || ($segment(process) == "HPITCH") || ($segment(process) == "SQZBOX") || ($segment(process) == "TSTRETCH"))} {
		incr segment(vp)				;#	First variable param entered earlier from MIDI keyboard or as timing data from Snack
	}
	.gettrofs.9a.pnam config -text "Enter parameter [string toupper $segment(vlabel$segment(vp))]"
	wm title .gettrofs "ENTER VALUE FOR PARAMETER [string toupper $segment(vlabel$segment(vp))]"
	.gettrofs.10.fixd config	-text "Fixed Value"  -command "GotoControlDataEntry" -state normal
	.gettrofs.10.tvar config	-text "Time Varying" -command "GotoControlDataEntry" -state normal
	set segment(haction) 0
}


#--- Put (appropriate) previous filename into filename box on interface

proc DisplayGettrofLastName {} {
	global segment
	if {[info exists segment(lastnam,$segment(savetype))]} {
		set segment(xfnam) $segment(lastnam,$segment(savetype))
		ForceVal  .gettrofs.4.segfil $segment(xfnam)	
	} else {
		switch -- $segment(savetype) {
			sound		{ set msg2 "OUTPUT SOUNDFILE NAME " }
			phrasexport	{ set msg2 "GENERIC SOUNDFILE-NAME FOR EXPORTING PHRASE SEGMENTS " }
			export		{ set msg2 "GENERIC SOUNDFILE-NAME FOR EXPORTING HEAD AND TAIL SEGMENTS " }
		}
		set msg "NO PREVIOUS "
		append msg $msg2 
		append msg "EXISTS"
		Inf $msg
	}
}

#-- Quick reload of Segmentation or Control Data

proc GettrofReload {} {		
	global segment evv
	set segment(again) 0
	ResetGetSyllabTrofs INITIALISE
	.gettrofs.00.ps config -text "" -bd 0 -command {} -state disabled -bg [option get . background {}]
	set OK 0
	if {[info exists segment(lastload)]} {
		set type  [lindex $segment(lastload) 0]
		set f_nam [lindex $segment(lastload) 1]
		set OK 1
		while {$OK} {
			switch -- $type {
				RAW {
					set segment(fnam) $f_nam
					
				}
				REFINED -
				PHRASE {
					set testfnam [file join $segment(dirname) $f_nam$evv(TEXT_EXT)]
					if [catch {open $testfnam "r"} zit] {
						Inf "CANNOT OPEN FILE $f_nam TO READ $type SEGMENTATION DATA"
						set OK 0
						break
					}
					catch {unset segment(marklist)}
					while {[gets $zit line] >= 0} {
						lappend segment(marklist) $line
					}
					close $zit
					set segment(rfnam) $f_nam
					set segment(cnt) [expr [llength $segment(marklist)] - 1]
					GettrofLoadAssociatedText
				} 
				CONTROL {
					set testfnam [file join $segment(dirname) $f_nam$evv(TEXT_EXT)]
					if [catch {open $testfnam "r"} zit] {
						Inf "CANNOT OPEN FILE $f_nam TO READ CONTROL DATA"
						set OK 0
						break
					}
					catch {unset segment(nucontrol)}
					while {[gets $zit line] >= 0} {
						lappend segment(nucontrol) $line
					}
					close $zit
					set segment(cfnam) $f_nam
				} 
			}
			break
		}
	}
	if {!$OK} {
		return
	}
	switch -- $type {
		RAW {
			set segment(phrase) 0
			set segment(xfnam) $segment(fnam)
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			set segment(troflist) [file join $segment(dirname) $segment(fnam)$evv(TEXT_EXT)]
			set segment(type) 0
			set segment(action) 0
			set segment(returnkeystate) R_SEGREFINE
			ResetGetSyllabTrofs GOTO_REFINE_SEGMENTATION
		}
		REFINED {
			set segment(phrase) 0
			set segment(xfnam) $segment(rfnam)
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			set segment(nutroflist) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
			set segment(type) 0
			set segment(action) 0
			set segment(headfirst) [GetHeadfirstData $segment(rfnam)]
			.gettrofs.6.h config -text "First Segment is HEAD" -state disabled
			.gettrofs.6.t config -text "First Segment is TAIL" -state disabled
			.gettrofs.6.vw config -text "See Segmentation"  -state normal -bd 2 -command "set segment(exportsegs) 1; DisplaySegmentation" -bg $evv(SNCOLOR)
			.gettrofs.6.tx config -text "Segmentation Text" -state normal -bd 2 -command "GettrofMultiInit_and_Mnemonics ENTERTEXT"
			switch -- $segment(headfirst) {
				0 {
					.gettrofs.6.t config -disabledforeground $evv(POINT) 
					.gettrofs.6.h config -text "" -disabledforeground [] 
				}
				1 { 
					.gettrofs.6.t config -text "" -disabledforeground [] 
					.gettrofs.6.h config -disabledforeground $evv(POINT) 
				}
			}
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
		}
		PHRASE {
			set segment(phrase) 1
			set segment(xfnam) $segment(rfnam)
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			set segment(nutroflist) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
			set segment(type) 0
			set segment(action) 0
			if {![SegmentSound 0]} {
				ResetGetSyllabTrofs INITIALISE
				continue
			}
			GettrofMakePhraseMixlines
			.gettrofs.6.h config -text "" -state disabled
			.gettrofs.6.t config -text "" -state disabled
			.gettrofs.6.vw config -text "See Segmentation"  -state normal -bd 2 -command "set segment(exportsegs) 1; DisplaySegmentation" -bg $evv(SNCOLOR)
			.gettrofs.6.tx config -text "Segmentation Text" -state normal -bd 2 -command "GettrofMultiInit_and_Mnemonics ENTERTEXT"
			.gettrofs.0.p config -text "" -command {} -bd 0 -bg [option get . background {}]
			.gettrofs.0.r config -text "" -command {} -bd 0
			.gettrofs.0.c config -text "" -command {} -bd 0
			set segment(again) 0
			.gettrofs.0.rd config -text "" -command {} -state disabled -disabledforeground []
			set segment(returnkeystate) R_INACTIVE
			ResetGetSyllabTrofs GOT_REFINED_DATA_GOTO_PROCESS_TYPE
		}
		CONTROL {
			set segment(phrase) 0
			set segment(xfnam) $segment(cfnam)
			ForceVal .gettrofs.4.segfil $segment(xfnam)
			set segment(controlfil) [file join $segment(dirname) $segment(cfnam)$evv(TEXT_EXT)]
			set segment(type) 0
			set segment(action) 0
			set segment(cload) 1
			.gettrofs.6.h config -text "" -state disabled -disabledforeground [] 
			.gettrofs.6.t config -text "" -state disabled -disabledforeground [] 
			.gettrofs.6.vw config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			.gettrofs.6.tx config -text "" -command {} -state disabled -bd 0 -background [option get . background {}]
			set segment(returnkeystate) R_INACTIVE
			ResetProcessBlock TIMESTRETCH_ONLY
		}
	}
}

#--- Is last segment (of H/T segmentation) a Tail

proc GettrofTailAtEnd {} {
	global segment												;#				T H T H	T H		H T	H T	H T
	if {[IsEven $segment(cnt)] && $segment(headfirst)} {		;#segcnt		  Even=1		  Even=1
		return 1												;#headfirst			0				1
	}															;#tail_at_end		0				1
																;#				T H	T H	T H	T	H T	H T	H T H										
	if {![IsEven $segment(cnt)] && !$segment(headfirst)} {		;#segcnt		  Even=0		  Even=0
		return 1												;#headfirst			0				1
	}															;#tail_at_end		1				0
	return 0
}

#--- Does multiprocess require more than 1 input file ?

proc PatchNeedsMultipleFiles {} {
	global segment
	set n 0
	while {$n < $segment(cnt)} {											;#	For every entrybox
		if {[string match [$segment(me$n) cget -state] normal]} {			;#	if it is active
			set code [$segment(me$n) get]									;#	Get the code entered, if any
			set k [lsearch $segment(proccodes) $code]						;#	If a code has been entered
			if {$k >= 0} {													;#	Set related (n) multiflag value, to the code index (k)
				set thisproc [lindex $segment(processes) $k]
				if {[IsaMultifileProcess $thisproc]} {
					return 1
				}
			}
		}
		incr n
	}
	return 0
}

#--- Does process require more than 1 input file ?

proc IsaMultifileProcess {prc} {
	global segment
	switch -- $prc {
		"VOCODE" -
		"EDOCOV" -
		"TRANSFER" {
			return 1
		}
	}
	return 0
}

##################################
# FUNCTIONS NOT CURRENTLY IN USE #
##################################

#--- Mixdown of which is NOT the final after-process(es) mixdown : with level cheching : RETURNS maxlevel (or 0) 
#--- NB Assumes Block is set

proc GettrofOtherMix {ofnam} {
	global segment evv prg_dun set prg_abortd simple_program_messages CDPidrun maxsamp_line done_maxsamp CDPmaxId
	set gain 1.0
	set OK 1
	set OK2 0
	set OK3 0
	set mixcnt 1
	wm title .blocker "PLEASE WAIT:        RECOMBINING TRANSPOSED SEGMENTS"
	while {!$OK2} {
		if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
			Inf "CANNOT DELETE PREVIOUS MIX OUTPUT, TO MODIFY LEVEL"
			set OK 0
			break
		}
		set cmd [file join $evv(CDPROGRAM_DIR) submix]
		lappend cmd mix $segment(mixdata) $ofnam -g$gain
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        RECOMBINING TRANSPOSED SEGMENTS (pass $mixcnt)"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN TRANSPOSED SEGMENT RECOMBINATION MIX (pass $mixcnt)"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SOUND BY RECOMBINING TRANSPOSED SEGMENTS (pass $mixcnt)"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "NO FILE OF RECOMBINED TRANSPOSED SEGMENTS CREATED (pass $mixcnt)"
			set OK 0
			break
		}
		wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF OUTPUT MIX (pass $mixcnt)"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $ofnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' (pass $mixcnt)"
			set OK 0
			break
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF OUTPUT MIX (pass $mixcnt)"
			set OK 0
			break
		}
		set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
		if {$maxoutsamp <= 0.0} {
			Inf "OUTPUT MIX (pass $mixcnt) HAS ZERO LEVEL"
			set OK 0
			break
		}
		if {$OK3} {
			break
		}

		if {$maxoutsamp > 0.98} {										;#	Gain close to 1.0 indicates output has probably overloadad
			set gain [expr $gain * 0.1]									;#	Reduce gain by factor of ten and re-run

		} elseif {($maxoutsamp < $segment(maxlev)) && ($gain < 1.0)} {	;#	If gain has been adjusted, but maxsamp now below max
			set gain [expr ($segment(maxlev)/$maxoutsamp) * $gain]		;#	reset gain to give a maximal non-distorted output
			set OK3 1													;#	and force loop-exit after next pass
		} else {
			set OK2 1													;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
		}
		incr mixcnt
	}
	if {!$OK} {
		return 0
	}
	return $maxoutsamp
}

#------- Log to base 2, for interval <--> ratio conversions

proc LogToBaseTwo {x} {
	global segment
	set x [expr log($x) * $segment(ONE_OVER_LN2)]
	return $x
}

#--- Min of 2 vals

proc TrofSegMin {a b} {
	if {$a < $b} {
		return $a
	}
	return $b
}

#################
#
#	HEREH  !!!! BE SURE TO INSERT NEW PROCESS NAME in FILE "_newdisplay" at text "IN SOUND VIEW DISPLAY"
#
# FILENAME INFO
#	
#	Original HEAD segment (dovetailed)			cdptestHH (DFLT_OUTNAME)HH		NB DFLT_OUTNAME && MACH_OUTFNAME distinguish source head name from processed src
#	Intermediate File for crossfading/retime	_outHX	  (MACH_OUTFNAME)HX		So if BOTH (same numbered) present	| (DFLT_OUTNAME)HH2  -> (DFLT_OUTNAME)HX2
#	Other Intermediate File for retime			cdptestHX (DFLT_OUTNAME)HX		& RETIME shrinks/stretches BOTH 	| (MACH_OUTFNAME)PH2 -> (MACH_OUTFNAME)HX2
#
#	On recycling mix after TAIL process, look for _outHH
#
#	Original TAIL segment (no dovetails)		_outTT	(MACH_OUTFNAME)TT
#	Dovetailed TAIL segment						_outTD	(MACH_OUTFNAME)TD
#	Dovetailed TAIL with fade					_outTF	(MACH_OUTFNAME)TF	(fade produced by previous HEAD process)
#
#	On recycling mix after HEAD process, look first for _outTF then for _outTD
#
#	Processed HEAD segment						_outPH	(MACH_OUTFNAME)PH
#	Processed TAIL segment						_outPT	(MACH_OUTFNAME)PT
#
#	Head process HH --------> PH		If Head process affects Tail -------> TF
#	Accent		 HH --------> HF		Accent may affect ALL other T & H --> TF/HF (with some possible renaming if TF/HF names used before)
#	Tail process TT/TD/TF --> PT		If Tail process affects Head -- Head is pre-merged with tail, so NO NEW Head type produced
#
#	set segment(init)		Allows default param vals for processes to be set, without them (initially) appearing in their respective entry boxes
#	set segment(hti_init)   Allows flag-setting (from non-preserved to preserved) at reorder-window startup, without triggering warning message.
#
#	proc GetRecycledSegment				Finds the H or T file to process in current pass
#
#	FILES AND LISTINGS OF SEGMENTATION DATA
#
#	segment(troflist)   is a temporary FILE containing the UNrefined marklist data
#	segment(nutroflist) is a temporary FILE containing the refined marklist data or the phrase marklist data
#	segment(fnam)		is the rootname-without-tail of the bakdup FILE containing the unrefined segmentation data
#	segment(rfnam)		is the rootname-without-tail of the bakdup FILE containing the refined segmentation, or phrase, data
#	segment(cfnam)		is the rootname-without-tail of the bakdup FILE containing the control data
#	segment(xfnam)		is the segment(rfnam), segment(fnam) or segment(cfnam), shown in the window
#	segment(marklist)	is a list of the times marking the segmentation of the file. These start at 0 and end AFTER file end
#	segment(cnt)		is a count of the segments thus marked (marklist length minus 1)
#	
#	DoSegmentation		Creates Segmentation marks for the sound
#	SegmentSound		Cuts the sounds into segments
#	
#	MNEMONIC TEXTS ASSOCIATED WITH  SEGMENTATION DATA
#
#	segment(mtext$n)	Mnemonic Texts
#	segment(tx$n)		Entry boxes for texts
#
#	segment(rtext$n)	Reordered Texts
#	segment(re$n)		Entry boxes for reordered texts
#
#	REORDERED SEGMENTATIONS
#
#	set segment(cnt)		Number of segments in a sound
#	set segment(reordercnt) Number of segments after reordering
#	set segment(reordered)  Flags that sound has been reordered
#	set segment(disordered) Flags that H/T alternation may have been compromised (file cannot be recycled)
#	set segment(htj)		Flag set (normal state) causes H/T ALTERNATION to be preserved in any reordering of segments   
#	set segment(htp)		Flag set causes H/T ORIGINAL-PAIRINGS to be preserved in any reordering of segments   
#	set segment(hti)		Flag set to 1 (normal state) means that H/T alternation preserved : set to 2 H/T pairings preserved
#
#	If reordering and Timestretching, Reordering must be done first.
#
#	SEGMENTATION TO PHRASES (RATHER THAN AS HEAD/TAIL ALTERNATIONS)
#
#	Segmentating into (words or) phrases (dflt is to segment into Heads - usually consonants - and Tails)
#	Segmentation cuts are slightly different
#
#	segment(phrase)			Flags that sound is being marked for words or phrases, rather than Heads amd Tails
#	segment(phraserefine)	Flags that word-or-phrase marking is being refined
#
#	Where lines are INSERTED into the mix output, the "noexpand" flags above that insertion need to be shuffled upwards with "AdvanceNoexpand".
#
#	If 2 adjacent files in mixfile are of the SAME TYPE (Head or Tail) and have the SAME INDEXING NUMBER
#	(e.g. "TEXTURE" which creates a new textured-segment,, but keeps the original source) - these are NOT separated by "segment(expand)"
#
#	PARAMETER ENTRY
#
#	FIXED-value-params
#
#	segment(PAR$n)		FIXED-value-parameter value
#	segment(par$n)		Value entered on interface
#	segment(entry$n)	Entry box for parameter
#	segment(label$n)	Name-on-interface for parameter
#
#	HideFixedParamEntryBoxes		At this point, displayed values segment(par$n) are transfered to actual used values segment(PAR$n) 
#
#	POSSIBLY-timevariable-params (vparams)
#
#	These get stored as brktables (whether entered as fixed values or as graphs) 
#
#	segment(control$n,PROCESS)	The brktables, 
#	segment(zlim,$n)	which are read using known functions for their end and size. 
#	segment(zccnt,$n)	These two params MUST be set-up in the final processing function e.g. "Gettrof_HeadBounce"
#
#	segment(dflt$n,PROCESS...		Default values of non-timevariable params
#	segment(lo$n)		Lo limit of current process's tiome-variable param n
#	segment(hi$n)		Hi limit of current process's tiome-variable param n
#	segment(pv$n) 1.0	Default level of current process's time-variable param n
#
#	PRESET PARAMS
#
#	 (e.g. the number of channels in a texture, or global flags, set by checkbuttons OR a set of pitches, times, or chords)
#
#	Processes with  PRESETS have to use the switch-arm of the main window
#	which calls "GettrofPresets" (which calls a unique function fo each process)
#
#	If these are FIXED-value-params (usually entered from checkbuttons or radiobuttons)
#	they MUST ALSO APPEAR, in "readonly" boxes, in the display of NOT-timevariable-params
#	!!!!! so that they can be saved in a "Patch", if a Patch is saved !!!!!
#
#	segment(paramcnt,PROCESS) determines the total number of fixed-parameters (preset or otherwise) the process can use
#	segment(paramstt,PROCESS) is the number of the 1st fixed-parameter that can be actively entered from the fixed-param display
#	
#	e.g.If we have 2 preset FIXED Params, and 3 normal (to enter on the interface), we write
#	segment(paramcnt,PROCESS) 5		All 4 are displayed
#	segment(paramstt,PROCESS) 2		Only the last 3 params can be entered (from start at "2")"
#
#	If they are MULTIVALUED params e.g pitches, chords, times (usually entered from MIDI Kbd icon or TIMETAP button)
#	they must also by remembered as vparams, so that Saving and Loading a patch will see them and remember them,
#	but they will NOT appear on the interface. (we sometimes also copy to segment(pitches) or segment(chords) when we Save/Load patches).
#
#	If there are no other vparams, the interface should go directly to run-program (rather than reading vparams).
#
#	If there ARE other vparams, these should be numbered appropriately
#	Normally, vparams are numbered from 1 (vaprams1,vparams2, etc)
#	With a PRESET vparam, the OTHER (interface accessible) vparams are numbered from AFTER the presets
#	e.g. with 1 preset, named vparams are numbered (vparams2,vparams3 etc)
#
#	In these cases, when process goes to "SetupFixvarParam"
#	this function must be told to SKIP the preset param (see function for mechanism)
#
#
#	KEEPING TRACK OF FILES ADDED TO THE MIXLIST (which means counting mixfile lines is not equivalent to counting through the marklist)
#
#	TEXTURE adds files to the mixlist so length of mixlist does not tally with segment(cnt) (count of original segments)
#	BOUNCE	may OR MAY NOT add files to the mixlist : we cannot know in advance whether these files have been added
#
#	segment(addsfile)	Flags processes that WILL add files to the mixlist
#	segment(didaddfil)	Flags processes that actually did add files to the mixlist
#							This starts out equal to "addsfile" but is updated whenever a process that MIGHT, actually DOES	
#
#	EXPANSION OF OUTPUT TO FORCE SEGMENTS TO ABUTT END-TO-END (AND OVERRIDING IT)
#
#	segment(expand)			Global Flag set in top window forces output segments to be end-to-end (with overlap splice), and NOT overlapped
#	segment(noexpand$n)		Set for individual segments, overrides segment(expand) for that segment
#
#
#	HOW PARAMETER BOXES ARE SET UP ON THE  DISPLAY : AND HOW THEY CAN BE ALTERED BY PRESET VALUES
#
#	"GettrofParamDefaultsAndVariableParamRanges"
#
#	This sets up 
#	The TOTAL count of Fixed-Value-Parameters for the process						   = segment(paramcnt,PROCESS)
#	The number of first Fixed-value-Parameter which can be input from params interface = segment(paramstt,PROCESS)
#	The default values of parameters injected when "Dflt" button is used e.g.			set segment(dflt1,PROCESS) 1.0
#	The parameter number of the crosspar parameter (where it exists) e.g.			  	set segment(crospar) 4
#	The total count of possibly-time-variable params: e.g.								set	segment(vparams_cnt,PROCESS) 3
#	The Ranges and defaults of ALL possibly-time-variable params: e.g.					set segment(lo1) 0.01	set segment(hi1) 1.0	set segment(pv1) 0.05
#
#	If Multivalued presets are used, This function must be called BEFORE "GettrofPresets"
#	(can't remember why!!) 
#
#	HOWEVER!!! FIXED-VAL PARAMETERS CAN VARY FROM OPTION TO OPTION WITHIN A PROCESS, ACTIVATED BY PRESETS
#
#	Some special parameter can determine what the other parameters can do (do they exist, what is their name, their range etc)
#	These must appear in the PRESETS (set up in a function called from "GettrofPresets", see above).
#
#	What value the preset has (e.g. bounce-overlay setting in BOUNCE)
#	can affect the name, default value, range and even visibility of other parameters in the param-input display.
#	These different options must first be set up in the presets-function called from "GettrofPresets"
#
#	(1) displayed-default value in Fixed-entry-box-of-Tvar-params can be set up differently from option to option.
#		e.g.	set segment(pv3)  0.92
#	(2)	default values for Fixed--params can be set up differently from option to option.
#		e.g.	set segment(par5) 2.0			(shown on display when 1st entered)
# 				set segment(dflt5,PROCESS) 2  	(called to display if default button pressed)
#	(3) Which params can be actively entered (others are pre-set and readonly, or invisible) can be set up differently from option to option
#		NB the preset Fixed-parama should always be flagged as inaccessible
#		e.g.	set segment(paramstt,PROCESS) 4	Only Params from 4 onwards are accessible by user - this can vary from option to option
#		NB the preset Variable-param should always be inaccessible
#		e.g.	with 1 tvariable param, First vparam listed will be vparam2 (not vparam1) and vparam1 will be skipped (see above)
#
#	Alternative ranges for fixed-params (determined  by which PRESET is set) can be established in 
#	"CheckSegParamsAndEstablishVparamNames"
#	
#	Finally, at the call to the particular PROCESS in "ResetGetSyllabTrofs" (see case "BOUNCE")
#
#	(1) PRESET Parameter is set to be displayed but cannot be changed
#		   e.g.	$segment(entry0) config -state readonly -bd 2	
#
#	(2) Status of entry boxes can be changed according to which value the PRESET has
#		(a) Names of parameters can be changed
#		   e.g.	$segment(label0) config -text "Type"
#		(b) (Unused) Parameter can be made invisible
#		   e.g.	$segment(entry1) config -state disabled -bd 0 -bg [option get . background {}]
#
#	ALSO
#
#	If options are set up to use different numbers of parameters,
#	"RememberGettrofParams" must be edited to reflect this (unused params cannot be "Remembered"!!)
#
#	TROUBLESHOOTING
#
#	If values do not appear in any of the Fixed-param entry boxes,
#
#		(1) "paramcnt" may not be correctly set in "GettrofParamDefaultsAndVariableParamRanges"
#		(2)	"segment(dflt1,PROCESS)" may not be preset in "GettrofParamDefaultsAndVariableParamRanges"
#
#	COUNTING PROBLEMS
#
#		counted from 0 : Fixed Params					Mixfile-Lines, segment-mnemonics, reordered-segment-mnemonics,										 
#		counted from 1 : Possibly-timevariable Params	Segment-NUMBERING, Tail-Name-NUMBERING, Head-Name-NUMBERING, Phrase-Name-NUMBERING, 
#
#	PhraseLineReinsert	Takes SEGMENT numbers : 
#						Where processes have (previously) inserted lines into a mix (in a multiple process)
#						the mixLINE we're working on will be derived from "GetRecycledSegment" as "segment(recycline)"
#						so to reinsert the associated line, use PhraseLineReinsert with the param "segment(recycline) + 1"
#
#
#	MONO and STEREO and MULTICHANNEL
#
#	Input is always mono
#	MOST TAIL PROCESSES (AND RECYCLE which processes TAILS first) have MONO outputs
#
#	Tail processes that alter HEADS need to know channel count of HEAD files they are incorporating
#	as HEAD PROCESSES can produce stereo or multichannel output (e.g. TEXTURE)
#
#	Some Tail processes INFORPORATE the preceding HEAD, if there is one (so code structure must ceal with this)
#
#	GETTING FILENAMES IN EXISTING MIXFILE (multiprocess)
#
#	GetRecycledSegment
#
#	segment(iifnam)		Is the (1st) filename returned from "GetRecycledSegment"
#	segment(iichan)		Is the chancnt of the named (1st) file returned from "GetRecycledSegment" (Needed by TUNING & PITCH)
#	segment(doublehead)	When a TAIL process is to alter the preceding head, flags that there are TWO (same-numbered) Head(-derived) files preceding the tail
#
#	In this case a 2nd (HEAD-derived) file is returned as
#
#	segment(iifnam2)	The 2nd filename returned from "GetRecycledSegment"
#	segment(iichan2)	The chancnt of the 2nd file returned from "GetRecycledSegment"
#
#	FindRelevantHeadFileForRetimeAndVerges
#
#	Similar function, but now will tell you if NO Head exists (where it has been absorbed into tail by TUNED (or PITCHLINE) with "Also tune Head" option, or VERGES)
#	so that a Process using Tail that wants to absorb Head does not go wrong looking for non-eistent Head!!
#
#	NEWDISPLAY
#
#	New processes need to be listed in "_newdisplay.tcl" !!!!
#																		
#	INTERNAL AND REAL MIXFILES
#																		
#	Mixfiles internally are in standard (mono/stereo type) format, but may have more than 2 chans assigned.
#	This allows consistent counting of mixfile lines.
#	On moving to the final mixdown, any anomalous standard-format files are converted to multichan format files to expedite the mixing.
#
#	RETIME (of H/T type segments) 
#
#	Has to deal with three Problems : Steps-between-events are normally between HHs: 
#
#	(1) 2nd Head, where original HH falls BEFORE processed PH (Texture process)
#			If Current Event is shrunk, PH may need to be shrunk.
#			If Current Event expanded,  PH needs to be fused with HH, 
#
#	(2) 2nd Head, where original HH falls AFTER processed Head PH (Bounce process)
#			If PRECEDING Event is shrunk, PH may need to be shrunk 
#
#	(3)	Head HH missing,absorbed into Tail PT (Tune/Pitch processes which "also Tune Head")
#			Alternative management of retiming process (and possbly TUNING and PITCHLINE with "Also Tune Heads" called after VERGES.
#
#########
#	Logic of CHOOSE_DATA_ENTRY_STYLE
#
#	"PROCESS HAS PRESETS : BUT NO (DISPLAYABLE) FIXED OR VARIABLE PARAMS" {
#		if {![info exists segment(vp)]} {
#			$segment(label0) config -text "Tune Head"		PUT NAMES OF PRESET PARAMS HERE
#			$segment(entry0) config -state readonly -bd 2	NB Entry box is readonly
#			$segment(label1) config -text "Crossfade into"
#			$segment(entry1) config -state readonly -bd 2
#			SetupGettrofParamEntryBoxes	`					SET TO DISPLAY THESE ON INTERFACE
#		} else {											
#			unset segment(vp)
#			set segment(returnkeystate) R_RUN				THEN SET TO GO DIRECTLY TO RUN PROCESS (No variable params to enter)
#			ResetGetSyllabTrofs CONTROL_DATA_UNSAVED_GOTO_RUN_PROCESS
#		}
#	}
#	"PROCESS HAS PRESETS AND (POSSIBLY FIXED PARAMS AND) VARIABLE PARAMS" {
#		if {![info exists segment(vp)]} {
#			$segment(label0) config -text "Antiplucks"		PUT NAMES OF PRESET PARAMS HERE
#			$segment(entry0) config -state readonly -bd 2	Entry box is readonly
#			focus $segment(entry0)
#			$segment(label1) config -text "Gain"			|
#			$segment(entry1) config -state normal -bd 2		|
#			$segment(label2) config -text "Tail End Level"	|
#			$segment(entry2) config -state normal -bd 2		|	ESTABLISH NAMES OF ALL OTHER PARAMS (FIXED FIRST, THEN VARIABLE)
#			$segment(label3) config -text "Fade Steepness"	|
#			$segment(entry3) config -state normal -bd 2		|
#			$segment(label4) config -text "Crossfade"		|
#			$segment(entry4) config -state normal -bd 2		|
#			SetupGettrofParamEntryBoxes						SET TO DISPLAY PRESET (AND ANY OTHER FIXED) PARAMS ON INTERFACE
#		} else {
#			set segment(shape) 0
#			SetupFixvarParam								THEN SET FOR ENTERING VARIABLE PARMS
#
#		}
#	}
#	"PROCESS HAS NO FIXED PARAMS, BUT HAS VARIABLE PARAMS"  {
#			if {![info exists segment(vp)]} {
#				CheckSegParamsAndEstablishVparamNames		;#	No fixed or preset params, needs to establish vparam names
#				set segment(vp) 1							;#	and start counting vparams	
#				set segment(shape) 0
#				SetupFixvarParam							;#	AND go directly to variable-params
#			} else {
#				set segment(shape) 0
#				SetupFixvarParam
#			}
#		}
#	}
#	"PROCESS HAS NO PARAMS" {
#		set segment(shape) 0
#		set segment(haction) 0
#	}
#
######

############
# TRANSFER #
############

proc DoTransfer {} {
	global segment

	if {![SegmentSound 1]} {
		return 0
	}
	if {![Gettrof_TailTransfer]} {
		return 0
	}
	return 1
}

#--- Enter presets for Transfer

proc TransferStyle {} {
	global segment wstk pr_transfr transfr evv wstk trtt trdd trpp traa trgg trss lasttrss
	set f .transfr
	if [Dlg_Create $f "SET STYLE FOR VOCODE" "set pr_transfr 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_transfr 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_transfr 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_transfr 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "TRANSFER   "
		checkbutton $f.1.tt  -text "Timing"   -variable trtt -width 10 -command "ResetTransferGate"
		set trtt 1
		set trdd 1
		checkbutton $f.1.dd  -text "Duration" -variable trdd -width 10 -command "ResetTransferGate"
		frame $f.1.1
		label $f.1.1.ll -text "Pitch" -width 20
		radiobutton $f.1.1.1  -text "(no change)"   -variable trpp -value 0
		radiobutton $f.1.1.2  -text "Mean Pitch"	-variable trpp -value 1
		radiobutton $f.1.1.3  -text "Pitch Contour" -variable trpp -value 2
		pack $f.1.1.ll $f.1.1.1 $f.1.1.2 $f.1.1.3 -side top -anchor w
		frame $f.1.2
		set trpp 1
		label $f.1.2.ll -text "Loudness" -width 20
		radiobutton $f.1.2.1  -text "(no change)"		-variable traa -value 0
		radiobutton $f.1.2.2  -text "Loudness"			-variable traa -value 1
		radiobutton $f.1.2.3  -text "Loudness Envelope" -variable traa -value 2
		pack $f.1.2.ll $f.1.2.1 $f.1.2.2 $f.1.2.3 -side top -anchor w
		set traa 2
		checkbutton $f.1.ss -text "Remove Silence" -variable trss -width 16
		if {[info exists lasttrss]} {
			set trss $lasttrss
		} else {
			set trss 0
		}
		label $f.1.gl  -text "Gate Level" -width  10
		entry $f.1.gg  -textvariable trgg -width 6
		pack $f.1.ll $f.1.tt $f.1.dd $f.1.1 $f.1.2 $f.1.ss $f.1.gl $f.1.gg -side left -anchor n
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_transfr 1}
		bind $f <Escape> {set pr_transfr 0}
	}
	set pr_transfr 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	ResetTransferGate
	My_Grab 0 $f pr_transfr
	while {!$finished} {
		tkwait variable pr_transfr
		set transflag 0
		switch -- $pr_transfr {
			1 {
				set marklen [llength $segment(marklist)]
				if {![FindVocodeSegmentation]} {
					continue
				}
				if {!$segment(phrase)} {
					if {$segment(headfirst)} {
						if {[string first "_0_" $segment(vocsegfnam)] > 0} {
							Inf "THE TWO SEGMENTATIONS ARE NOT BOTH WITH HEAD-SEGMENT FIRST"
							continue
						}
					} else {
						if {[string first "_1_" $segment(vocsegfnam)] > 0} {
							Inf "THE TWO SEGMENTATIONS ARE NOT BOTH WITH TAIL-SEGMENT FIRST"
							continue
						}
					}
				}
				if {![GetVocodeSegmentation 1]} {
					continue
				}
				if {[expr $trtt + $trdd + $trpp + $traa] == 0} {
					Inf "NO TRANSFER OF PROPERTIES SELECTED"
					continue
				}
				if {$trtt} {
					set transflag [expr $transflag | 1]
				}
				if {$trdd} {
					set transflag [expr $transflag | 2]
				}
				if {$trpp} {
					if {$trpp == 2} {
						set transflag [expr $transflag | 16]
					} else {
						set transflag [expr $transflag | 4]
					}
				} else {
					catch {unset segment(tradjust)}
				}
				if {$traa} {
					if {$traa == 2} {
						set transflag [expr $transflag | 32]
					} else {
						set transflag [expr $transflag | 8]
					}
				}
				set segment(par0) $transflag
				set segment(PAR0) $segment(par0)	;#	This Param must be set here, as not set later
				set segment(lastpar0,$segment(process)) $segment(par0)
				if {[string length $trgg] <= 0} {
					set segment(par1) 0.0
				} else {
					set segment(par1) $trgg
				}
				set segment(PAR1) $segment(par1)	;#	This Param must be set here, as not set later
				set segment(lastpar1,$segment(process)) $segment(par1)

				set segment(par2) $trss
				set segment(PAR2) $segment(par2)	;#	This Param must be set here, as not set later
				set segment(lastpar2,$segment(process)) $segment(par2)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

#--- "Gate level" only visible if "duration" option selected

proc ResetTransferGate {} {
	global segment trgg trdd trss trtt lasttrss
	if {$trdd} {
		.transfr.1.gl config -text "Gate Level"
		.transfr.1.gg config -state normal -bd 2
		set trgg $segment(dflt1,TRANSFER)
		if {$trtt} {
			set lasttrss $trss
			set trss 0
			.transfr.1.ss config -text "" -state disabled -disabledforeground []
		} else {
			.transfr.1.ss config -text "Remove Silence" -state normal
			if {[info exists lasttrss]} {
				set trss $lasttrss
			} else {
				set trss 0
			}
		}
	} else {
		set trgg ""
		.transfr.1.gl config -text ""
		.transfr.1.gg config -state disabled -bd 0 -disabledbackground [option get . background {}]
		set lasttrss $trss
		set trss 0
		.transfr.1.ss config -text "" -state disabled -disabledforeground []
	}
}

#---- Transfer properties from File2 to  File1

proc Gettrof_TailTransfer {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun maxsamp_line done_maxsamp CDPmaxId

	set doretime   0	
	set doredur	   0
	set dorepitch  0
	set docontour  0
	set doloudness 0
	set doenvel    0
	set segment(report) {} 

	Block "PLEASE WAIT:        TRANSFERRING CHARACTERISTICS OF 2nd FILE TO 1st"

	if {$segment(phrase)} {
		set hcnt $segno
	} else {												;#	!headfirst									headfirst		
		set hcnt [expr $segment(cnt)/2]						;#	1  (2)	3  (4)	5	segcnt				   (1)	2  (3)	4  (5)	
		set tcnt [expr $segment(cnt)/2]						;#	0	1	1	2	2	segct/2					0	1	1	2	2
		if {!$segment(headfirst)} {							;#	T	H	T	H	T							H	T	H	T	H			
			incr hcnt										;#	0	1->		2->		hcnt = segcnt/2			1->		2->		  hcnt = segcnt/2		
		}													;#	1		2		3	tcnt = segcnt/2 + 1			1		2	  tcnt = segcnt/2	
	}														;#	Process is on TAIL segment number: relevant Head number is head BEFORE that tail

	if {$segment(PAR0) & 1} {
		set doretime 1
	}
	if {$segment(PAR0) & 2} {
		set doredur 1
	}
	if {$segment(PAR0) & 16} {
		set dorepitch 1
		set docontour 1
	} elseif {$segment(PAR0) & 4} {
		set dorepitch 1
		}
	if {$segment(PAR0) & 32} {
		set doloudness 1
		set doenvel 1
	} elseif {$segment(PAR0) & 8} {
		set doloudness 1
	}

	set marks1 $segment(marklist)
	set marks1 [lreplace $marks1 end end $segment(dur)]
	set marks2 $segment(vocmarklist)
	set marks2 [lreplace $marks2 end end $segment(vocdur)]
	catch {unset segment(truedurs)}

	set HT1files [GettrofCutFile1HeadsPlusTails $marks1]
	if {[string match $HT1files "0"]} {
		UnBlock
		return 0
	}
	set HT1anas [GetSpectrumOfSegment $HT1files 0]
	if {[string match $HT1files "0"]} {
		UnBlock
		return 0
	}
	if {$doredur} {
		set HT2files [GettrofCutFile2HeadsPlusTails $marks2]
		if {[string match $HT2files "0"]} {
			UnBlock
			return 0
		}
		set segment(truedurs) [GetTrueDursOfFileTwo $HT2files]
		if {[string match $segment(truedurs) "0"]} {
			UnBlock
			return 0
		}
	}
	set n 0
	while {$n < $hcnt} {
		lappend tstrs 1.0						;#	Preset timestretches to 1.0 (no change)
		lappend transps 0.0						;#	Preset transpostions to 0.0 (no change)
		lappend gains 1.0						;#	Preset gains to 1.0 (no change)
		incr n
	}
	set squeeze_out_silence 0
	if {$segment(PAR2)} {
		set squeeze_out_silence 1
	}
	set segment(squeezable) 0

	if {$doretime || $doredur} {
		set data [GetFilesSegmentTimingsAndDurs $marks1 $marks2]
		set tims1 [lindex $data 0]
		set durs1 [lindex $data 1]
		set heddurs1 [lindex $data 2] 
		set tims2 [lindex $data 3]
		set durs2 [lindex $data 4]
		set heddurs2 [lindex $data 5]

		if {$doretime} {
			set tstrs [GenerateAnyTstrData $durs1 $heddurs1 $durs2 $heddurs2 $tstrs 0]	;#	Checkout any segs that must be shrunk
			if {!$doredur} {
				set segment(squeezable) [TransferRetimeSqueezable $marks1 $marks2]		;#	Retimed but not redured : squeezable only if steps don't increase
			}
		}
		if {$doredur} {
			if {$doretime} {															;#	Retimed AND redured : squeezable only if no silent gaps in 2nd file
				set segment(squeezable) [TransferRetimeDurationSqueezable $segment(truedurs) $marks2]
			} else {																	;#	Redured but not retimed : squeezable only if durs don't shrink
				set segment(squeezable) [TransferDurationSqueezable $HT1files $segment(truedurs)]
			}																			;#	Checkout any segs that must be shrunk/stretched (overrides above)
			set tstrs [GenerateAnyTstrData $durs1 $heddurs1 $segment(truedurs) $heddurs2 $tstrs 1]
		}
	}
	if {$dorepitch} {
		catch {unset T1tails}
		catch {unset T2tails}
		set T2tails [CutFile2Tails $marks2]
		if {[string match $T2tails "0"]} {
			UnBlock
			return 0
		}
		set T2tails [GetSpectrumOfSegment $T2tails 1]
		if {[string match $T2tails "0"]} {
			UnBlock
			return 0
		}
		set T1tails [GetFile1Tails $marks1]
		set T1tails [GetSpectrumOfSegment $T1tails 1]
		if {[string match $T1tails "0"]} {
			UnBlock
			return 0
		}
		if {$docontour} {
			set transps [FindPitchContourTranspositions $marks1 $marks2]
			if {[string match $transps "0"]} {
				UnBlock
				return 0
			}
		} else {
			set meanpitches1 [ExtractMedianPitchesOfTailsOrPhrases $segment(ana,0) $marks1]
			if {[string match $meanpitches1 "0"]} {
				UnBlock
				return 0
			}
			set meanpitches2 [ExtractMedianPitchesOfTailsOrPhrases $segment(ana,1) $marks2]
			if {[string match $meanpitches2 "0"]} {
				UnBlock
				return 0
			}
			set transps [GenerateTransferTranspositionsBetweenMeanPitches $meanpitches1 $meanpitches2]
		}
	}
	if {$doloudness} {
		if {$doenvel} {
			set gains [GetTransferEnvels $marks1 $marks2 1]
			if {[string match $gains "0"]} {
				UnBlock
				return 0
			}
		} else {
			set gains [GetTransferEnvels $marks1 $marks2 0]
			if {[string match $gains "0"]} {
				UnBlock
				return 0
			}
		}
	}

	if {$segment(phrase)} {
		set msg_typ "PHRASE"
	} else {
		set msg_typ "HEAD-TAIL-SET"
	}

	;#	ESTABLISH OUTTIMES IN OUTPUT MIXFILE

	if {$doretime} {
		set mixtimes [GetTransferMixtimes $marks2]
	} else {
		set mixtimes [GetTransferMixtimes $marks1]
	}

	set OK 1
	set n 1

	foreach wavfnam $HT1files anafnam $HT1anas tstr $tstrs transp $transps gain $gains mixtime $mixtimes {

		set outana1 $evv(DFLT_OUTNAME)HF$n$evv(ANALFILE_EXT)
		set outana2 $evv(DFLT_OUTNAME)PH$n$evv(ANALFILE_EXT)
		set outwav0	$evv(DFLT_OUTNAME)PH$n$evv(SNDFILE_EXT)
		set outwav1	$evv(DFLT_OUTNAME)HF$n$evv(SNDFILE_EXT)
		set outwav2 $evv(DFLT_OUTNAME)HX$n$evv(SNDFILE_EXT)

		;#	SET DEFAULT WAV OUTFILE NAME

		set ofnam $wavfnam
		catch {unset ofnama}

		set do_trans 0
		if {$dorepitch || $docontour} {
			set do_trans 1
		}
		set do_gain 0
		if {$doloudness || $doenvel} {
			set do_gain 1
		}

		;#	DO STRETCH, IF ANY

		if {![IsNumeric $tstr] || ![Flteq $tstr 1.0]} {

			;#	STRETCH ANAFNAM --> OUTANA1		OFNAMA becomes OUTANA1

			set cmd [file join $evv(CDPROGRAM_DIR) stretch]
			lappend cmd time 1 $anafnam $outana1 $tstr
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        TIMESTRETCHING $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PROCESS TO TIMESTRETCH $msg_typ $n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO TIMESTRETCH $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $outana1]} {
				Inf "NO TIMESTRETCHED VERSION OF $msg_typ $n CREATED"
				set OK 0
				break
			}
			set ofnama $outana1
		
			;#	IF FILE WILL ALSO BE PITCH-CONTOURED, TIME-STRETCH CONTOUR-DATA

			if {$docontour} {
				if [catch {open $transp "r"} zit] {
					lappend segment(report) "CANNOT OPEN TRANSPOSITION DATA FILE FOR $msg_typ $n TO TIMESTRETCH IT : $zit"
					lappend segment(report) "              CANNOT TRANSPOSE THIS ITEM"
					set do_trans 0
				} else {
					catch {unset nulines}
					set OK2 1
					while {[gets $zit line] >= 0} {
						set line [string trim $line]
						set line [split $line]
						set cnt 0
						foreach item $line {
							set item [string trim $item]
							if {[string length $item] <= 0} {
								continue
							}
							if {$cnt == 0} {
								if {$item == 0.0} {
									set nupair [list 0.0]					;#	No timestretch at time zero
								} else {
									if {![IsNumeric $tstr]} {
										set nutim [GetTimeFromVariableTstr $tstr $item $msg_typ $n]
										if {$nutim < 0.0} {
											set OK2 0						;#	Failed to find integrated-time from tstr file
											break
										} else {
											set tstr [expr $nutim/$item]	;#	Tstretch is integrated-value
										}
									}
									set nupair [list [expr $item * $tstr]]	;#	Tstretch is either integrated val, or fixed val
								}
							} else {
								lappend nupair $item
								lappend nulines $nupair
							}
							incr cnt
						}
						if {!$OK2} {
							break
						}
					}
					close $zit
					if {!$OK2} {
						lappend segment(report) "              CANNOT TRANSPOSE THIS ITEM"
						set do_trans 0
					} elseif [catch {file delete $transp} zit] {
						lappend segment(report) "CANNOT REMOVE UNSTRETCHED TRANSPOSITION FILE FOR $msg_typ $n : $zit"
						lappend segment(report) "              CANNOT TRANSPOSE THIS ITEM"
						set do_trans 0
					} elseif [catch {open $transp "w"} zit] {
						lappend segment(report) "CANNOT OPEN NEW TRANSPOSITION DATA FILE FOR $msg_typ $n : $zit"
						lappend segment(report) "              CANNOT TRANSPOSE THIS ITEM"
						set do_trans 0
					} else {
						foreach line $nulines {
							puts $zit $line
						}
						close $zit
					}
				}
			}

			;#	IF FILE WILL ALSO BE LOUDNESS-ENVELOPED, TIME-STRETCH ENVELOPE-DATA

			if {$doenvel} {
				if [catch {open $gain "r"} zit] {
					lappend segment(report) "CANNOT OPEN ENVELOPE DATA FILE FOR $msg_typ $n TO TIMESTRETCH : $zit"
					lappend segment(report) "              CANNOT ENVELOPE THIS ITEM"
					set do_gain 0
				} else {
					catch {unset nulines}
					set OK2 1
					while {[gets $zit line] >= 0} {
						set line [string trim $line]
						set line [split $line]
						set cnt 0
						foreach item $line {
							set item [string trim $item]
							if {[string length $item] <= 0} {
								continue
							}
							if {$cnt == 0} {
								if {$item == 0.0} {
									set nupair [list 0.0]					;#	No timestretch at time zero
								} else {
									if {![IsNumeric $tstr]} {
										set nutim [GetTimeFromVariableTstr $tstr $item $msg_typ $n]
										if {$nutim < 0.0} {
											set OK2
											break
										}
										set tstr [expr $nutim/$item]
									}
									set nupair [list [expr $item * $tstr]]
								}
							} else {
								lappend nupair $item
								lappend nulines $nupair
							}
							incr cnt
						}
						if {!$OK2} {
							break
						}
					}
					close $zit
					if {!$OK2} {
						lappend segment(report) "              CANNOT ENVELOPE THIS ITEM"
						set do_gain 0
					} elseif [catch {file delete $gain} zit] {
						lappend segment(report) "CANNOT REMOVE UNSTRETCHED ENVELOPE FILE FOR $msg_typ $n : $zit"
						lappend segment(report) "              CANNOT ENVELOPE THIS ITEM"
						set do_gain 0
					} elseif [catch {open $gain "w"} zit] {
						lappend segment(report) "CANNOT OPEN NEW ENVELOPE DATA FILE FOR $msg_typ $n : $zit"
						lappend segment(report) "              CANNOT ENVELOPE THIS ITEM"
						set do_gain 0
					} else {
						foreach line $nulines {
							puts $zit $line
						}
						close $zit
					}
				}
			}
		}

		if {$do_trans && (![IsNumeric $transp] || ![Flteq $transp 0.0])} {

			if {![info exists ofnama]} {
				set ofnama $anafnam		;#	If no stretched analfile, OFNAMA becomes input analfile ANAFNAM
			}

			;#	DO TRANSPOSITION, IF ANY, OFNAMA --> OUTANA2	OFNAMA becomes OUTANA2

			set OK2 1
			while {$OK2} {
				set cmd [file join $evv(CDPROGRAM_DIR) repitch]
				lappend cmd transpose 3 $ofnama $outana2 $transp
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        TRANSPOSING $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					lappend segment(report) "FAILED TO RUN PROCESS TO TRANSPOSE $msg_typ $n"
					catch {unset CDPidrun}
					set OK2 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO TRANSPOSE $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					lappend segment(report) "$msg"
					set OK2 0
					break
				}
				if {![file exists $outana2]} {
					lappend segment(report) "NO TRANSPOSED VERSION OF $msg_typ $n CREATED"
					set OK2 0
					break
				}
				set ofnama $outana2
				break
			}
		}

		;#	IF THERE'S AN OUTPUT ANALYSIS FILE, CONVERT BACK TO WAV AND DOVETAIL : OFNAMA --> OUTWAV0 --> OUTWAV1 : OFNAM becomes OUTWAV1(or 0)

		if {[info exists ofnama]} {

			set ofnam [TransferSynthTrim $ofnama $outwav0 $outwav1 $msg_typ $n $tstr]
			if {[string match $ofnam "0"]} {
				set OK 0
				break
			}
		}

		;#	DO GAIN, IF ANY : OFNAM --> OUTWAV2

		if {$do_gain && (![IsNumeric $gain] || ![Flteq $gain 1.0])} {
			set OK2 0			;#	Test if level OK
			set OK3 0			;#	Test whether changed level-change has finished
			set OK4 1			;#	Test whether level change succeeds at all
			set adjust 1.0
			while {!$OK2} {
				if {[file exists $outwav2] && [catch {file delete $outwav2} zit]} {
					Inf "CANNOT DELETE PREVIOUS GAIN-MODIFIED VERSION OF  $msg_typ $n"
					set OK4 0
					break
				}
				if {$doenvel} {
					set msg3 "ENVELOPE"
				} else {
					set msg3 "LEVEL"
				}
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $ofnam $outwav2 $gain 
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        MODIFYING $msg3 OF $msg_typ $n"
				if [catch {open "|$cmd"} CDPidrun] {
					lappend segment(report) "FAILED TO RUN PROCESS TO MODIFY $msg3 OF $msg_typ $n"
					catch {unset CDPidrun}
					set OK4 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CHANGE  $msg3 OF $msg_typ $n"
					set msg [AddSimpleMessages $msg]
					lappend segment(report) "$msg"
					set OK4 0
					break
				}
				if {![file exists $outwav2]} {
					lappend segment(report) "NO VERSION OF $msg_typ $n WITH CHANGED $msg3 CREATED"
					set OK4 0
					break
				}

				wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF  $msg_typ $n WITH CHANGED $msg3"
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				catch {unset maxsamp_line}
				set done_maxsamp 0
				lappend cmd $outwav2
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)'"
					set OK4 0
					break
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {![info exists maxsamp_line]} {
					Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF  $msg_typ $n WITH CHANGED $msg3"
					set OK4 0
					break
				}
				if {$OK3} {
					break
				}

				set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
				if {$maxoutsamp <= 0.0} {
					Inf "$msg_typ $n WITH CHANGED $msg3 HAS ZERO LEVEL"
					set OK4 0
					break
				}

				if {$maxoutsamp > 0.98} {										;#	Gain close to 1.0 indicates output has probably overloadad
					set adjust 0.1 
					set gain [ReadjustTransferGain $gain $adjust $msg_typ $n]	;#	Reduce gain by factor of ten and re-run
					if {[string match gain "0"]} {
						set OK4 0
						break
					}
				} elseif {($maxoutsamp < $segment(maxlev)) && ($adjust < 1.0)} {;#	If gain has been adjusted, but maxsamp now below max
					set adjust [expr $segment(maxlev)/$maxoutsamp]
					set gain [ReadjustTransferGain $gain $adjust $msg_typ $n]	;#	reset gain to give a maximal non-distorted output
					if {[string match gain "0"]} {
						set OK4 0
						break
					}
					set OK3 1													;#	and force loop-exit after next pass
				} else {
					set OK2 1													;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
				}
			}
			if {!$OK4} {							;#	If gain process fails entirely, accept file WITHOUT level-adjust			
				set outwav2 $ofnam
			}
		} else {		;#	ELSE OUTWAV2 becomes OFNAM
		
			set outwav2 $ofnam
		
		}
		set mixline [list $outwav2 $mixtime 1 1.0]
		lappend mixlines $mixline
		incr n
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	if {[llength $segment(report)] > 0} {
		set msg ""
		foreach line $segment(report) {
			append msg "$line\n"
		}
		Inf $msg
	}

	set segment(mixlines) $mixlines

	if {$segment(squeezable)} {
		GettrofTransferCloseupMix
	} elseif {$squeeze_out_silence} {
		GettrofTransferRemoveSilences	
	}
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN FILE segment(mixfil) TO WRITE FINAL SEGMENT REMIXING DATA"
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofPossiblyMultichanMixdown 1]} {		;#	Use this version, in case inadvertent overload!!
		set OK 0
	}
	UnBlock
	if {!$OK} {
		return 0
	}
	return 1

	#	HEREH
	#	FOR EACH PHRASE OR HEAD-TAIL PAIR (OR LEAD TAIL, OR TRAILING HEAD)
	#		WORK OUT IF RETIME OR REDUR IMPLIES STRETCHING/SHRINKING, AND SET TSTRETCH-COEFF
	#		IF PITCH (OR CONTOUR) REQUIRED, FIND IT
	#		IF LOUDNESS (OR ENVELOPE) REQUIRED, FIND IT
}

#--- Get timings and durations of segments in 2nd file

proc GetFilesSegmentTimingsAndDurs {marks1 marks2} {
	global segment
	set len [llength $marks1]
	if {$segment(phrase)} {
		set j 0
		set k 1
		while {$k < $len} {
			set tim [lindex $marks1 $j]
			lappend tims $tim
			set endtim [lindex $marks1 $k]
			if {$k < $len} {
				set endtim [expr $endtim + $segment(SPLICE)]	;#	All phrases have a downsplice, except at end of file
			}
			set dur [expr $endtim - $tim]
			lappend durs $dur
			lappend heddurs $dur
			incr j
			incr k
		}
	} else {
		set tcnt 1
		set hcnt 1
		set ishead 1
		if {!$segment(headfirst)} {
			lappend tims 0.0
			lappend durs [lindex $marks1 1]
			lappend heddurs 0.0
			incr tcnt
			set m 1												;#	T  /H	T  /H	T
			set j 2												;#		m	j	k
			set k 3												;#	|---		m	j	k
																;#	   |--------	   len
		} else {												;#			   |--------|				   
			set m 0												;#	H	T  /H	T  /H	T
			set j 1												;#  m	j	k
			set k 2												;#			m	j	k
		}														;#	|-------		m	j	k
		while {$k < $len} {										;#		   |--------	   len
			if {$ishead} {										;#				   |--------
				set tim [lindex $marks1 $m]
				if {$m > 0} {
					set tim [expr $tim - $segment(SPLICE)]		;#	All Heads, except at very start of file, have an upsplice
				}
				lappend tims $tim
				set endtim [lindex $marks1 $k]
				set dur [expr $endtim - $tim]
				lappend durs $dur
				set endhed [lindex $marks1 $j]
				set heddur [expr $endhed - $tim]
				lappend heddurs $heddur
				incr tcnt
				incr hcnt
			}
			incr m
			incr j
			incr k
			set ishead [expr !$ishead]
		}
		if {($j < $len) && $ishead} {							;#	If data has an isolated Head at end
			set tim [lindex $marks1 $m]							;#				   /H
			set tim [expr $tim - $segment(SPLICE)]				;#					m	j  (k)
			lappend tims $tim									;#					   len
			set endtim [lindex $marks1 $j]						;#				   |----
			set dur [expr $endtim - $tim]
			lappend durs $dur
			lappend heddurs $dur
		}														
	}
	set len [llength $marks2]
	if {$segment(phrase)} {
		set j 0
		set k 1
		while {$k < $len} {
			set tim [lindex $marks2 $j]
			lappend tims2 $tim
			set endtim [lindex $marks2 $k]
			if {$k < $len} {
				set endtim [expr $endtim + $segment(SPLICE)]	;#	All phrases have a downsplice, except at end of file
			}
			set dur [expr $endtim - $tim]
			lappend durs2 $dur
			lappend heddurs2 $dur
			incr j
			incr k
		}
	} else {
		set tcnt 1
		set hcnt 1
		set ishead 1
		if {!$segment(headfirst)} {
			lappend tims2 0.0
			lappend durs2 [lindex $marks2 1]
			lappend heddurs2 0.0
			incr tcnt
			set m 1												;#	T  /H	T  /H	T
			set j 2												;#		m	j	k
			set k 3												;#	|---		m	j	k
																;#	   |--------	   len
		} else {												;#			   |--------|				   
			set m 0												;#	H	T  /H	T  /H	T
			set j 1												;#  m	j	k
			set k 2												;#			m	j	k
		}														;#	|-------		m	j	k
		while {$k < $len} {										;#		   |--------	   len
			if {$ishead} {										;#				   |--------
				set tim [lindex $marks2 $m]
				if {$m > 0} {
					set tim [expr $tim - $segment(SPLICE)]		;#	All Heads, except at very start of file, have an upsplice
				}
				lappend tims2 $tim
				set endtim [lindex $marks2 $k]
				set dur [expr $endtim - $tim]
				set endhed [lindex $marks2 $j]
				set heddur [expr $endhed - $tim]
				lappend heddurs2 $heddur
				lappend durs2 $dur
				incr tcnt
				incr hcnt
			}
			incr m
			incr j
			incr k
			set ishead [expr !$ishead]
		}
		if {($j <$len) && $ishead} {							;#	If data has an isolated Head at end
			set tim [lindex $marks2 $m]							;#				   /H
			set tim [expr $tim - $segment(SPLICE)]				;#					m	j  (k)
			lappend tims2 $tim									;#					   len
			set endtim [lindex $marks2 $j]						;#				   |----
			set dur [expr $endtim - $tim]
			lappend durs2 $dur
			lappend heddurs2 $dur
		}														
	}
	return [list $tims $durs $heddurs $tims2 $durs2 $heddurs2]
}

#--- If segment retimed so timesteps are shorter, segments will need to be tshrunk

proc GenerateAnyTstrData {durs1 heddurs1 durs2 heddurs2 tstrs also_do_stretch} {
	global segment evv
	set segno 1
	set cnt 0
	set msg "PHRASE"
	if {!$segment(phrase)} {
		set msg "HEAD-TAIL-UNIT"
	}
	foreach dur1 $durs1 heddur1 $heddurs1 dur2 $durs2 heddur2 $heddurs2 {
		if {$dur2 < $dur1} {
			if {$segment(phrase)} {
				set tstr [expr $dur2/$dur1]
			} else {
				catch {unset env}								;#	Shrink tail to achieve new retimed distance
				set taildur1 [expr $dur1 - $heddur1]			;#	Creating brkpnt file in timeframe of src
				set taildur2 [expr $dur2 - $heddur2]
				set tstr [expr $taildur2/$taildur1]
				if {$heddur1 > 0.0} {
					set line [list 0.0 1.0]
					lappend env $line
					set line [list $heddur1 1.0]
					lappend env $line
					set hedafter [expr $heddur1 + $segment(brkminstep)]
					set line [list $hedafter $tstr]
					lappend env $line
				} else {
					set line [list 0.0 $tstr]
					lappend env $line
				}
				set line [list $dur1 $tstr]
				lappend env $line
				set fnam [file rootname $segment(envfil)]
				append fnam "_$segno" $evv(TEXT_EXT)
				if {[file exists $fnam] && [catch {file delete $fnam} zit]} {
					Inf "CANNOT DELETE TIMESTRETCH DATA FOR $msg $segno"
					return 0
				}
				if [catch {open $fnam "w"} zit] {
					Inf "CANNOT OPEN FILE $fnam TO WRITE TIMESTRETCH DATA FOR $msg $segno"
					return 0
				}
				foreach line $env {
					puts $zit $line
				}
				close $zit
				set tstr $fnam
				set tstrs [lreplace $tstrs $cnt $cnt $tstr]
			}
		} elseif {$also_do_stretch && ($dur2 > $dur1)} {
			if {$segment(phrase)} {
				set tstr [expr $dur2/$dur1]
			} else {
				catch {unset env}								;#	Otherwise shrink tail to achieve new retimed distance
				set taildur1 [expr $dur1 - $heddur1]			;#	Creating brkpnt file in timeframe of src
				set taildur2 [expr $dur2 - $heddur2]
				set tstr [expr $taildur2/$taildur1]
				if {$heddur1 > 0.0} {
					set line [list 0.0 1.0]
					lappend env $line
					set line [list $heddur1 1.0]
					lappend env $line
					set hedafter [expr $heddur1 + $segment(brkminstep)]
					set line [list $hedafter $tstr]
					lappend env $line
				} else {
					set line [list 0.0 $tstr]
					lappend env $line
				}
				set line [list $dur1 $tstr]
				lappend env $line
				set fnam [file rootname $segment(envfil)]
				append fnam "_$segno" $evv(TEXT_EXT)
				if {[file exists $fnam] && [catch {file delete $fnam} zit]} {
					Inf "CANNOT DELETE TIMESTRETCH DATA FOR $msg $segno"
					return 0
				}
				if [catch {open $fnam "w"} zit] {
					Inf "CANNOT OPEN FILE $fnam TO WRITE TIMESTRETCH DATA FOR $msg $segno"
					return 0
				}
				foreach line $env {
					puts $zit $line
				}
				close $zit
				set tstr $fnam
				set tstrs [lreplace $tstrs $cnt $cnt $tstr]
			}
		}
		incr segno
		incr cnt
	}
	return $tstrs
}

#--- Cut out HT pairs

proc GettrofCutFile2HeadsPlusTails {marks} {
	global segment evv
	set len [llength $marks]
	if {$segment(phrase)} {
		set j 0
		set k 1
		while {$k <= $len} {
			set segfnam [file rootname $segment(othersnd)]
			append segfnam "_BB_" $k $evv(SNDFILE_EXT)
			set stttim [lindex $marks $j]
			set endtim [lindex $marks $k]
			if {$k < $len} {
				set endtim [expr $endtim + $segment(SPLICE)]	;#	All phrases have a downsplice, except at end of file
			}
			if {![TransferCutFile $stttim $endtim $segfnam $k 2]} {
				return 0
			}
			lappend HTfiles $segfnam
			incr j
			incr k
		}
	} else {
		set tcnt 1
		set ishead 1
		set m 0												;#	H	T  /H	T  /H	T
		set j 1												;#  m	j	k
		set k 2												;#			m	j	k
		if {!$segment(headfirst)} {
			set segfnam [file rootname $segment(othersnd)]
			append segfnam "_BB_" $j $evv(SNDFILE_EXT)
			set stttim 0.0
			set endtim [lindex $marks 1]
			if {![TransferCutFile $stttim $endtim $segfnam $j 2]} {
				return 0
			}
			lappend HTfiles $segfnam
			incr tcnt
			incr m
			incr j
			incr k
		}
		while {$k < $len} {
			if {$ishead} {
				set segfnam [file rootname $segment(othersnd)]
				append segfnam "_BB_" $tcnt $evv(SNDFILE_EXT)
				set stttim [lindex $marks $m]
				if {$m > 0} {
					set stttim [expr $stttim - $segment(SPLICE)];#	All Heads, except at very start of file, have an upsplice
				}
				set endtim [lindex $marks $k]
				if {![TransferCutFile $stttim $endtim $segfnam $j 2]} {
					return 0
				}
				lappend HTfiles $segfnam
				incr tcnt
			}
			incr m
			incr j
			incr k
			set ishead [expr !$ishead]
		}
		if {($j <$len) && $ishead} {							;#	If data has an isolated Head at end
			set segfnam [file rootname $segment(othersnd)]
			append segfnam "_BB_" $tcnt $evv(SNDFILE_EXT)
			set stttim [lindex $marks $m]						;#				   /H
			set stttim [expr $stttim - $segment(SPLICE)]		;#					m	j  (k)
			set endtim [lindex $marks $j]						;#				   |----
			if {![TransferCutFile $stttim $endtim $segfnam $j 2]} {
				return 0
			}
			lappend HTfiles $segfnam
		}														
	}
	return $HTfiles
}

#--- Cut only Tails from File2

proc CutFile2Tails {marks} {
	global segment evv
	set len [llength $marks]
	if {$segment(phrase)} {
		set j 0
		set k 1
		while {$k <= $len} {
			set segfnam [file rootname $segment(othersnd)]
			append segfnam "_CC_" $k $evv(SNDFILE_EXT)
			set stttim [lindex $marks $j]
			set endtim [lindex $marks $k]
			if {$k < $len} {
				set endtim [expr $endtim + $segment(SPLICE)]	;#	All phrases have a downsplice, except at end of file
			}
			if {![TransferCutFile $stttim $endtim $segfnam $k 2]} {
				return 0
			}
			lappend Ttails $segfnam
			incr j
			incr k
		}
	} else {
		set tcnt 1
		set ishead 0
		if {$segment(headfirst)} {
			set ishead 1
		}
		set j 0												;#	H	T  /H	T  /H	T
		set k 1												;#  j	k
		while {$k <= $len} {								;#		j	k	ETC
			if {!$ishead} {
				set segfnam [file rootname $segment(othersnd)]
				append segfnam "_CC_" $tcnt $evv(SNDFILE_EXT)
				if {[file exists $segfnam] && [catch {file delete $segfnam} zit]} {
					Inf "CANNOT DELETE PREVIOUS SEGMENT OF FILE $segment(src,1) : $zit"
					return 0
				}
				set stttim [lindex $marks $j]
				set endtim [lindex $marks $k]
				if {$k < [expr $len - 1]} {
					set endtim [expr $endtim + $segment(SPLICE)]	;#	All Tails, except at very end of file, have a downsplice
				}
				if {![TransferCutFile $stttim $endtim $segfnam $k 2]} {
					return 0
				}
				lappend Ttails $segfnam
				incr tcnt
			}
			incr j
			incr k
			set ishead [expr !$ishead]
		}
	}
	return $Ttails
}

#---- Cut H/T pair, or Phrase from 2nd file.

proc TransferCutFile {starttime endtime ofnam segno fileno} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
	incr fileno -1
	lappend cmd cut 1 $segment(src,$fileno) $ofnam $starttime $endtime -w15
	set prg_dun 0
	set prg_abortd 0
	set msg2 "PHRASE"
	if {!$segment(phrase)} {
		set msg2 "HEAD-TAIL-SET"
	}
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        CUTTING $msg2 $segno FROM FILE $segment(src,$fileno)"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO CUT $msg2 $segno FROM FILE $segment(src,$fileno)"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CUT $msg2 $segno  FROM FILE $segment(src,$fileno)"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO OUTFILE $msg2 $segno  FROM FILE $segment(src,$fileno) CREATED"
		return 0
	}
	return 1
}

#---- Use envelope to determine where segments from File2 fall to "zero" level

proc GetTrueDursOfFileTwo {HTfiles} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set gate $segment(PAR1)
	catch {unset truedurs}
	set msg2 "PHRASE"
	if {!$segment(phrase)} {
		set msg2 "HEAD-TAIL-SET"
	}
	set OK 1
	set segno 1
	foreach fnam $HTfiles {
		if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
			Inf "CANNOT DELETE EXISTING ENVELOPE DATA FILE $segment(envfil) : $zit"
			return 0
		}
		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd extract 2 $fnam $segment(envfil) 5 -d0.0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        EXTRACTING ENVELOPE OF $msg2 $segno"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN PROCESS TO EXTRACT ENVELOPE OF $msg2 $segno"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO GET ENVELOPE OF $msg2 $segno"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $segment(envfil)]} {
			Inf "NO ENVELOPE OF $msg2 $segno CREATED"
			return 0
		}
		if [catch {open $segment(envfil) "r"} zit] {
			Inf "CANNOT OPEN ENVELOPE FILE FROM $msg2 $segno : $zit"
			return 0
		}
		catch {unset vals}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {![IsNumeric $item]} {
					Inf "INVALID DATA ($item) IN ENVELOPE OF $msg2 $segno"
					set OK 0
					break
				}

				lappend vals $item
			}
			if {!$OK} {
				break
			}
		}
		close $zit
		if {$OK && ![info exists vals]} {
			Inf "NO ENVELOPE DATA FOUND IN ENVELOPE FILE OF $msg2 $segno"
			set OK 0
		}
		if {!$OK} {
			return 0
		}
		set vals [ReverseList $vals] 
		set tcnt 1
		catch {unset endtime}
		foreach {val time} $vals {			;#	Find time where (reversed) signal exceeds gate
			if {$val > $gate} {
				if {$tcnt > 1} {
					incr tcnt -2
				} 
				set endtime [lindex $vals $tcnt]
				break
			}
			incr tcnt 2
		}
		if {![info exists endtime]} {
			lappend segment(report) "ENVELOPE OF $msg2 $segno NEVER RISES ABOVE GATE LEVEL : SET ITS DURATION AS STEP TO NEXT $msg2 START\n"
			set endtime [lindex $vals 1]
		} 
		lappend truedurs $endtime
		incr segno
	}
	return $truedurs
}

#--- Get spectra of File Tails or Phrases

proc GetSpectrumOfSegment {tailwavs tails_only} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set msg2 "PHRASE"
	if {!$segment(phrase)} {
		if {$tails_only} {
			set msg2 "TAIL"
		} else {
			set msg2 "HEAD-TAIL-SET"
		}
	}
	set segno 1
	catch {unset HTtails}
	foreach ifnam $tailwavs {
		set ofnam [file rootname $ifnam]
		append ofnam $evv(ANALFILE_EXT)
		if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
			Inf "CANNOT DELETE EXISTING ENVELOPE DATA FILE $ofnam : $zit"
			return 0
		}
		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd anal 1 $ifnam $ofnam -c1024 -o3
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF $msg2 $segno"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN SPECTRUM CREATION FOR $msg2 $segno"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SPECTRUM OF  $msg2 $segno"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $ofnam]} {
			Inf "NO SPECTRUM OF $msg2 $segno CREATED"
			return 0
		}
		lappend HTtails $ofnam 
	}
	return $HTtails
}

#--- List the tail segments in the Src

proc GetFile1Tails {marks} {
	global segment evv
	catch {unset Ttails}
	set len [llength $marks]
	if {$segment(phrase)} {
		set j 0
		set k 1
		while {$k <= $len} {
			set segfnam $evv(MACH_OUTFNAME)TD$k$evv(SNDFILE_EXT)
			lappend Ttails $segfnam
			incr j
			incr k
		}
	} else {
		set tcnt 1
		set ishead 0
		if {$segment(headfirst)} {
			set ishead 1
		}
		set j 0												;#	H	T  /H	T  /H	T
		set k 1												;#  m	j
		while {$k <= $len} {								;#		m	j	ETC
			if {!$ishead} {
				set segfnam $evv(MACH_OUTFNAME)TD$tcnt$evv(SNDFILE_EXT)
				lappend Ttails $segfnam
				incr tcnt
			}
			incr j
			incr k
			set ishead [expr !$ishead]
		}
	}
	return $Ttails
}

#---- Compare pitch contours of input files, eand generate poitch-contour transpositions

proc FindPitchContourTranspositions {marks1 marks2} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	FIND PITCH CONTOUR OF ENTIRE SRC

	set pitchcontour1 [ExtractPitchContour $segment(ana,0)]
	if {[string match $pitchcontour1 "0"]} {
		return 0
	}

	;# FIND PITCH CONTOUR OF ENTIRE OTHER FILE

	set pitchcontour2 [ExtractPitchContour $segment(ana,1)]
	if {[string match $pitchcontour2 "0"]} {
		return 0
	}

	;#	GET HEAD AND TAIL TIMINGS FROM SRC

	if {$segment(phrase)} {
		wm title .blocker "PLEASE WAIT:        GENERATING TRANSPOSITION CONTOURS FOR ALL PHRASES"
	} else {
		wm title .blocker "PLEASE WAIT:        GENERATING TRANSPOSITION CONTOURS FOR ALL HEAD-TAIL PAIRS"
	}

	;#	GET HEAD AND TAIL TIMINGS FROM 1st FILE

	set timetrios1 [GetHeadPlusTailOrPhraseTimings $marks1 0]

	;#	GET HEAD AND TAIL TIMINGS FROM 2nd FILE

	set timetrios2 [GetHeadPlusTailOrPhraseTimings $marks2 1]

	;#	GET LOCAL PITCH-CONTOURS OF TAILS (OR PHRASES)

	set segment(contourcnt) 0
	set startdat [lindex $pitchcontour1 0] 
	set segment(c_pretime) [lindex $startdat 0]
	set segment(c_preval)  [lindex $startdat 1]
	set len [llength $pitchcontour1]
	foreach timetrio $timetrios1 {
		set localcontour [EstablishLocalTailPitchContour $pitchcontour1 $timetrio $len $segment(dur)]
		set localcontour [LocalContourToZeroTime $localcontour]
		set localcontour [RemoveTimeDuplicatesFromContour $localcontour]
		lappend localcontours1 $localcontour
	}
	set segment(contourcnt) 0
	set startdat [lindex $pitchcontour2 0] 
	set segment(c_pretime) [lindex $startdat 0]
	set segment(c_preval)  [lindex $startdat 1]
	set len [llength $pitchcontour2]
	foreach timetrio $timetrios2 {
		set localcontour [EstablishLocalTailPitchContour $pitchcontour2 $timetrio $len $segment(vocdur)]
		set localcontour [LocalContourToZeroTime $localcontour]
		set localcontour [RemoveTimeDuplicatesFromContour $localcontour]
		lappend localcontours2 $localcontour
	}

	;#	GENERATE TRANSPOSITION CONTOURS FOR EACH H+T OR PHRASE

	set transpositionsets [GenerateLocalContourTranspositions $localcontours1 $localcontours2 $timetrios1]
	set transps [WriteContourTranspositionBrkfiles $transpositionsets]
	if {[string match $transps "0"]} {
		return 0
	}
	return $transps
}

#---- Derive local pitch-contour of tail from overall pitch-contour of sound

proc EstablishLocalTailPitchContour {pitchcontour timetrio len totaldur} {
	global segment
	set headstt [lindex $timetrio 0]
	set tailstt [lindex $timetrio 1]
	set tailend [lindex $timetrio 2]
	while {$segment(contourcnt) < $len} {
		set thisdat [lindex $pitchcontour $segment(contourcnt)] 
		set time [lindex $thisdat 0]
		set val  [lindex $thisdat 1]
		if {$time <= $tailstt} {
			set segment(c_pretime) $time
			set segment(c_preval) $val
		} else {
			set done 0
			catch {unset localcontour}
			set posttime $time
			set postval $val									;#		| tailtime
			set timediff [expr $posttime - $segment(c_pretime)]	;#	|pre			|post
			set toffset  [expr $tailstt - $segment(c_pretime)]	;#	------diff------
			set tratio [expr $toffset/$timediff]				;#  ---- offset
			set vdiff [expr $postval - $segment(c_preval)]
			set vstep [expr $vdiff * $tratio]
			set val [expr $segment(c_preval) + $vstep]
			set nupair [list $tailstt $val]						;#	Establish timeval pair for start of tail
			lappend localcontour $nupair
			while {$posttime < $tailend} {
				set nupair [list $posttime $postval]
				lappend localcontour $nupair
				set segment(c_pretime) $posttime
				set segment(c_preval) $postval
				incr segment(contourcnt)
				if {$segment(contourcnt) >= $len} {
					set thisdat [lindex $pitchcontour end]
					set val [lindex $thisdat 1]
					set nupair [list $totaldur $val]
					lappend localcontour $nupair
					set done 1
					break
				}
				set thisdat [lindex $pitchcontour $segment(contourcnt)] 
				set posttime [lindex $thisdat 0]
				set postval  [lindex $thisdat 1]
			}
			if {!$done} {
				set timediff [expr $posttime - $segment(c_pretime)]	;#	|pre			|post
				set toffset  [expr $tailend - $segment(c_pretime)]	;#	------diff------
				set tratio [expr $toffset/$timediff]				;#  ---- offset
				set vdiff [expr $postval - $segment(c_preval)]
				set vstep [expr $vdiff * $tratio]
				set val [expr $segment(c_preval) + $vstep]
				set nupair [list $tailend $val]						;#	Establish timeval pair for start of tail
				lappend localcontour $nupair
			}
			break	;#	Once local contour found: break out of local loop
		}
		incr segment(contourcnt)
	}
	return $localcontour
}

#--- Readjust local pitchcontour times to start at start of Tail

proc LocalContourToZeroTime {localcontour} {
	set stttime [lindex [lindex $localcontour 0] 0]
	set loclen [llength $localcontour]
	set k 0														;#	Adjust local-contour times
	while {$k < $loclen} {
		set dat [lindex $localcontour $k]
		set time [lindex $dat 0]								;#	Times			| |		| |	| | adjusted to zero ->
		set time [expr $time - $stttime]						;#	| |		| |	| |
		set dat [lreplace $dat 0 0 $time]						
		set localcontour [lreplace $localcontour $k $k $dat]
		incr k
	}
	return $localcontour
}

#--- Ensure there are no duplicated times in local pitch-contour

proc RemoveTimeDuplicatesFromContour {localcontour} {
	set len [llength $localcontour]
	set len_less_one [expr $len - 1]
	set k 0
	while {$k < $len_less_one} {								;#	Remove any duplicate times in contour
		set ktim [lindex [lindex $localcontour $k] 0]
		set j $k
		incr j
		while {$j < $len} {
			set jtim [lindex [lindex $localcontour $j] 0]
			if {[Flteq $ktim $jtim]} {
				set localcontour [lreplace $localcontour $j $j]
				incr len -1
				incr len_less_one -1
			} else {
				incr j
			}
		}
		incr k
	}
	return $localcontour
}

#-- Derive transposition brkpnts from local pitch-contours

proc GenerateLocalContourTranspositions {contours1 contours2 timetrios} {
	global segment
	set i 0
	foreach contour1 $contours1 contour2 $contours2 timetrio $timetrios {
		set headstt [lindex $timetrio 0]
		set tailstt [lindex $timetrio 1]
		set hoffset [expr $tailstt - $headstt]
		set olddur [lindex [lindex $contour1 end] 0]
		set newdur [lindex [lindex $contour2 end] 0]
		set tstr [expr $newdur/$olddur]

		set len  [llength $contour1]
		set len2 [llength $contour2]
		set k 0
		while {$k < $len} {									;#	tstretch 1st file tail-contour to same length as 2nd file tail-contour
			set dat [lindex $contour1 $k]
			set time  [lindex $dat 0]
			set time [expr $time * $tstr]
			set dat [lreplace $dat 0 0 $time]
			set contour1 [lreplace $contour1 $k $k $dat]
			incr k
		}
		set k 0
		set preval1 [lindex [lindex $contour2 0] 1]
		while {$k < $len} {									;#	Replace pitch val by transpos val -> in contour1
			set dat1 [lindex $contour1 $k]
			set tim1 [lindex $dat1 0]
			set val1 [lindex $dat1 1]
			set j 1
			set pretim 0.0
			set preval $preval1
			set done 0
			while {$j < $len2} {
				set dat2 [lindex $contour2 $j]
				set posttim [lindex $dat2 0]
				set postval  [lindex $dat2 1]
				if {$posttim >= $tim1} {
					set timdiff [expr $posttim - $pretim]
					set toffset	[expr $tim1 - $pretim]
					set tratio  [expr $toffset/$timdiff]
					set valdiff [expr $postval - $preval]
					set vstep	[expr $valdiff * $tratio]
					set val		[expr $preval + $vstep]
					set transpos [expr $val - $val1]
					set dat1 [lreplace $dat1 1 1 $transpos]
					set contour1 [lreplace $contour1 $k $k $dat1]	
					set done 1
					break
				} else {
					set pretim $posttim
					set preval $postval
					incr j
				}
			}
			if {!$done} {
				set val	[lindex [lindex $contour2 end] 1]
				set transpos [expr $val - $val1]
				set dat1 [lreplace $dat1 1 1 $transpos]
				set contour1 [lreplace $contour1 $k $k $dat1]
			}
			incr k
		}
		if {$hoffset > 0.0} {
			set firstval [lindex [lindex $contour1 0] 1]	;#	If ness, add in transposition  of Head, same as start of tail
			set nudat [list 0.0 $firstval]
			set nucontour [list $nudat]
			set k 0
			while {$k < $len} {								;#	and move all other values forward by Head-offset
				set dat [lindex $contour1 $k]
				set time  [lindex $dat 0]
				set time [expr $time + $hoffset]
				set dat [lreplace $dat 0 0 $time]
				lappend nucontour $dat
				incr k
			}
		} else {
			set nucontour $contour1
		}
		if {[info exists segment(tradjust,$i)]} {
			set zlen [llength $nucontour]
			set zz 0
			while {$zz < $zlen} {
				set nupair [lindex $nucontour $zz]
				set transp [lindex $nupair 1]
				set transp [expr $transp + $segment(tradjust,$i)]
				set nupair [lreplace $nupair 1 1 $transp]
				set nucontour [lreplace $nucontour $zz $zz $nupair]
				incr zz
			}
			unset segment(tradjust,$i)
		}
		lappend transpossets $nucontour
		incr i
	}
	return $transpossets
}

#---- Extract pitch contour of whole file

proc ExtractPitchContour {fnam} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATAFILE $segment(notedata) : $zit"	
		return 0
	}
	if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE TEMPORARY SOUNDFILE $segment(exclmix) : $zit"	
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) repitch]
	lappend cmd getpitch 2 $fnam $segment(exclmix) $segment(notedata) -d0.000020
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        EXTRACTING PITCH CONTOUR OF [file rootname $fnam]"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PITCH CONTOUR EXTRACTION PROCESS FOR [file rootname $fnam]"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO EXTRACT PITCH CONTOUR OF [file rootname $fnam]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(notedata)]} {
		Inf "NO SOURCE PITCH CONTOUR FOUND"
		return 0
	}
	if [catch {open $segment(notedata) "r"} zit] {
		Inf "CANNOT OPEN FILE $segment(notedata) TO READ PITCH-CONTOUR [file rootname $fnam]"
		return 0
	}
	catch {unset pitchcontour}
	set OK 1
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set line [split $line]
		set nuline {}
		set cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item]} {
				set OK 0
				break
			}
			if {$cnt == 1} {							;#	Store contour as MIDI values
				set item [HzToMidi $item]
			}
			lappend nuline $item
			incr cnt
		}
		if {!$OK} {
			break
		}
		if {$cnt != 2} {
			Inf "INVALID DATA IN PITCH-CONTOUR FILE FROM FILE [file rootname $fnam]"
			return 0
		}
		lappend pitchcontour $nuline
	}
	close $zit
	if {!$OK} {
		return 0
	}
	if {![info exists pitchcontour]} {
		Inf "NO DATA FOUND IN PITCH-CONTOUR FILE"
		return 0
	}
	return $pitchcontour
}

#----- Get timings of headstart, tailstart, unit-end

proc GetHeadPlusTailOrPhraseTimings {marks is_truedurs} {
	global segment
	catch {unset timetrios}
	set len [llength $marks]
	set get_truedurs 0
	if {$is_truedurs && [info exists segment(truedurs)]} {
		set get_truedurs 1
	}
	if {$segment(phrase)} {
		set j 0
		set k 1
		while {$k < $len} {
			set tim [lindex $marks $j]
			if {$get_truedurs} {										;#	H	H   H
				set endtim [expr $tim + [lindex $segment(truedurs) $j]]	;#	j	k
			} else {													;#		j	k
				set endtim [lindex $marks $k]							;#	|---|	j	k
			}															;#	tim |---|   len
			set timetrio [list $tim $tim $endtim]						;#   endhed	|---|		
			lappend timetrios $timetrio									;#	 endtail
			incr j
			incr k
		}
	} else {															;#	H	T   H	T   H	T
		set cnt 0														;#  m	j	k
		set m 0															;#			m	j	k
		set j 1															;#	|-------|		m	j	k
		set k 2															;#		    |-------|	   len	
		set ishead 1													;#	tim end end	    |-------
		if {!$segment(headfirst)} {										;#		hed tail ETC
			set tim 0.0
			if {$get_truedurs} {
				set endtim [expr $tim + [lindex $segment(truedurs) $cnt]]
				incr cnt
			} else {
				set endtim [lindex $marks 1]
			}															;#	T   H	T   H	T
			set timetrio [list $tim $tim $endtim]						;#		m	j	k
			lappend timetrios $timetrio									;#	|---|		m	j	k
			incr m														;#	    |-------|	   len
			incr j														;# tim		    |-------|
			incr k														;#endhed
		}																;#	   end
		while {$k < $len} {												;#	   tail
			if {$ishead} {
				set tim [lindex $marks $m]
				if {$get_truedurs} {
					set endtim [expr $tim + [lindex $segment(truedurs) $cnt]]
					incr cnt
				} else {
					set endtim [lindex $marks $k]
				}
				set endhed [lindex $marks $j]
				set timetrio [list $tim $endhed $endtim]
				lappend timetrios $timetrio
			}
			incr m
			incr j
			incr k
			set ishead [expr !$ishead]
		}																;#	If data has an isolated Head at end
		if {($j < $len) && $ishead} {									;#	T   H	T   H
			lappend tims $tim											;#		m	j	k  
			if {$get_truedurs} {										;#				m	j  (k)
				set endtim [expr $tim + [lindex $segment(truedurs) $cnt]] ;#	|-------|  len
				incr cnt												;#				|---|
			} else {													;#			  tim  endhed
				set endtim [lindex $marks $j]							;#				   endtail
			}
			set timetrio [list $tim $endtim $endtim]
			lappend timetrios $timetrio
		}
	}
	return $timetrios
}

#--- Write transposition brkdate into brkpnt files, and return filenames

proc WriteContourTranspositionBrkfiles {transpossets} {
	global segment evv
	catch {unset transps}
	set gfnam [file rootname $segment(fadesnd)]
	append gfnam "_JJ_"
	if {$segment(phrase)} {
		set msg2 "PHRASE"
	} else {
		set msg2 "HEAD-TAIL PAIR"
	}
	set cnt 1
	foreach transposset $transpossets {
		set fnam $gfnam
		append fnam $cnt $evv(TEXT_EXT)
		if {[file exists $fnam] && [catch {file delete $fnam} zit]} {
			Inf "CANNOT DELETE EXISTING TRANSPOSITION DATAFILE $fnam: $zit"	
			return 0
		}
		if [catch {open $fnam "w"} zit] {
			Inf "CANNOT OPEN DATAFILE $fnam TO WRITE TRANSPOSITION DATA FOR $msg2 $cnt: $zit"	
			return 0
		}
		foreach line $transposset {
			puts $zit $line
		}
		close $zit
		lappend transps $fnam	
		incr cnt
	}
	return $transps
}

#--- Extract list of median pitches of Tails, or Phrases

proc ExtractMedianPitchesOfTailsOrPhrases {ifnam marks} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set ofnam [file rootname $segment(fadesnd)]
	append ofnam "_RR" $evv(TEXT_EXT)
	if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
		Inf "CANNOT DELETE EXISTING MEDIAN PITCH DATAFILE $ofnam : $zit"	
		return 0
	}
	if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE DATAFILE $segment(notedata) : $zit"	
		return 0
	}
	if [catch {open $segment(notedata) "w"} zit] {
		Inf "CANNOT OPEN DATAFILE $segment(notedata) TO WRITE SEGMENTATION DATA FOR FILE [file rootname $ifnam] : $zit"	
		return 0
	}
	foreach time $marks {
		puts $zit $time
	}
	close $zit

	;#	FIND MEDIAN PITCH OF ALL SEGMENTS

	set cmd [file join $evv(CDPROGRAM_DIR) spectune]
	lappend cmd tune 6 $ifnam $ofnam $segment(notedata)
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        EXTRACTING MEDIAN PITCHES OF SEGMENTS IN FILE [file rootname $ifnam]"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN MEDIAN PITCH EXTRACTION PROCESS FOR SEGMENTS IN [file rootname $ifnam]"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO EXTRACT MEDIAN PITCHES OF SEGMENTS IN [file rootname $ifnam]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO MEDIAN PITCHES FOUND FOR SEGMENTS IN FILE [file rootname $ifnam]"
		return 0
	}
	if [catch {open $ofnam "r"} zit] {
		Inf "CANNOT OPEN FILE $ofnam TO READ MEDIAN PITCHES OF SEGMENTS IN FILE [file rootname $ifnam]"
		return 0
	}
	set OK 1
	catch {unset allpitches}
	catch {unset pitches}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set line [split $line]
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item]} {
				Inf "INVALID DATA AMONG MEDIAN PITCHES IN FILE $ofnam EXTRACTED FROM FILE [file rootname $ifnam]"
				set OK 0
				break
			}
			lappend allpitches $item
		}
		if {!$OK} {
			break
		}
	}
	close $zit
	if {!$OK} {
		return 0
	}
	if {$segment(phrase)} {
		set pitches $allpitches
	} else {
		set len [llength $marks]
		incr len -1
		set ishead 0
		if {$segment(headfirst)} {
			set ishead 1
		}
		set j 0
		while {$j < $len} {
			if {!$ishead} {
				lappend pitches [lindex $allpitches $j]			;#	Assemble pitches of tails (only)
			}
			set ishead [expr !$ishead]
			incr j
		}
	}
	return $pitches
}

#---- Get transpositions between mean pitches of segments

proc GenerateTransferTranspositionsBetweenMeanPitches {pitches1 pitches2} {
	global segment
	set i 0
	foreach pitch1 $pitches1 pitch2 $pitches2 {
		if {($pitch1 == 0) || ($pitch2 == 0)} {
			set transp 0
		} else {
			set transp [expr $pitch2 - $pitch1]
		}
		if {[info exists segment(tradjust,$i)]} {
			set transp [expr $transp + $segment(tradjust,$i)]
			unset segment(tradjust,$i)
		}
		lappend transps $transp
		incr i
	}

	return $transps
}

#---- Join up H+T of File 1

proc GettrofCutFile1HeadsPlusTails {marks} {
	global segment evv
	set len [llength $marks]
	set hcnt 1
	if {$segment(phrase)} {
		foreach line $segment(mixlines) {
			set fnam $evv(DFLT_OUTNAME)HH$hcnt$evv(SNDFILE_EXT)
			lappend HTfiles $fnam
			incr hcnt
		}
	} else {
		set tcnt 1
		set ishead 1
		set m 0												;#	H	T  /H	T  /H	T
		set j 1												;#  m	j	k
		set k 2												;#			m	j	k
		if {!$segment(headfirst)} {
			set segfnam [file rootname $segment(othersnd)]
			append segfnam "_Z_" $tcnt $evv(SNDFILE_EXT)
			set stttim 0.0
			set endtim [lindex $marks 1]
			if {![TransferCutFile $stttim $endtim $segfnam $j 1]} {
				return 0
			}
			lappend HTfiles $segfnam
			incr tcnt
			incr m
			incr j
			incr k
		}
		while {$k < $len} {
			if {$ishead} {
				set segfnam [file rootname $segment(othersnd)]
				append segfnam "_Z_" $tcnt $evv(SNDFILE_EXT)
				set stttim [lindex $marks $m]
				if {$m > 0} {
					set stttim [expr $stttim - $segment(SPLICE)];#	All Heads, except at very start of file, have an upsplice
				}
				set endtim [lindex $marks $k]
				if {![TransferCutFile $stttim $endtim $segfnam $j 1]} {
					return 0
				}
				lappend HTfiles $segfnam
				incr tcnt
			}
			incr m
			incr j
			incr k
			set ishead [expr !$ishead]
		}
		if {($j <$len) && $ishead} {							;#	If data has an isolated Head at end
			set segfnam [file rootname $segment(othersnd)]
			append segfnam "_Z_" $tcnt $evv(SNDFILE_EXT)
			set stttim [lindex $marks $m]						;#				   /H
			set stttim [expr $stttim - $segment(SPLICE)]		;#					m	j  (k)
			set endtim [lindex $marks $j]						;#				   |----
			if {![TransferCutFile $stttim $endtim $segfnam $j 1]} {
				return 0
			}
			lappend HTfiles $segfnam
		}														
	}
	return $HTfiles
}

#---- Transfer Envelope or Level, of each seg, from File 2 to File 1

proc GetTransferEnvels {marks1 marks2 getenvel} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	FIND ENVELOPE OF ENTIRE SRC

	set envel1 [ExtractEnvelope $segment(src,0)]
	if {[string match $envel1 "0"]} {
		return 0
	}

	;# FIND ENVELOPE OF ENTIRE OTHER FILE

	set envel2 [ExtractEnvelope $segment(src,1)]
	if {[string match $envel2 "0"]} {
		return 0
	}

	;#	GET HEAD AND TAIL TIMINGS FROM SRC

	if {$segment(phrase)} {
		wm title .blocker "PLEASE WAIT:        GENERATING LOUDNESS ENVELOPES FOR ALL PHRASES"
	} else {
		wm title .blocker "PLEASE WAIT:        GENERATING LOUDNESS ENVELOPES FOR ALL HEAD-TAIL PAIRS"
	}

	;#	GET HEAD AND TAIL TIMINGS FROM 1st FILE

	set timetrios1 [GetHeadPlusTailOrPhraseTimings $marks1 0]

	;#	GET HEAD AND TAIL TIMINGS FROM 2nd FILE

	set timetrios2 [GetHeadPlusTailOrPhraseTimings $marks2 1]

	;#	GET LOCAL ENVELOPES OF TAILS (OR PHRASES)

	set segment(envelcnt) 0
	set startdat [lindex $envel1 0] 
	set segment(c_pretime) [lindex $startdat 0]
	set segment(c_preval)  [lindex $startdat 1]
	set len [llength $envel1]
	foreach timetrio $timetrios1 {
		set localenvel [EstablishLocalEnvelope $envel1 $timetrio $len $segment(dur)]
		if {$getenvel} {
			set localenvel [LocalEnvelToZeroTime $localenvel]
			set localenvel [RemoveTimeDuplicatesFromContour $localenvel]
			lappend localenvels1 $localenvel
		} else {
			set localmax [LocalEnvelMax $localenvel]
			lappend maxvals1 $localmax
		}
	}
	set segment(envelcnt) 0
	set startdat [lindex $envel2 0] 
	set segment(c_pretime) [lindex $startdat 0]
	set segment(c_preval)  [lindex $startdat 1]
	set len [llength $envel2]
	foreach timetrio $timetrios2 {
		set localenvel [EstablishLocalEnvelope $envel2 $timetrio $len $segment(vocdur)]
		if {$getenvel} {
			set localenvel [LocalEnvelToZeroTime $localenvel]
			set localenvel [RemoveTimeDuplicatesFromContour $localenvel]
			lappend localenvels2 $localenvel
		} else {
			set localmax [LocalEnvelMax $localenvel]
			lappend maxvals2 $localmax
		}
	}

	;#	GENERATE ENVELOPE FILES FOR EACH H+T OR PHRASE
	
	if {$getenvel} {
		set envels [GenerateLocalEnvelGains $localenvels1 $localenvels2 $timetrios1]
		set gains [WriteGainBrkfiles $envels]
		if {[string match $gains "0"]} {
			return 0
		}
	} else {
		set gains [GenerateLocalGains $maxvals1 $maxvals2]
	}
	return $gains
}

#---- Derive local envelope of Head+Tail (or Phrase) from overall Envelope of sound

proc EstablishLocalEnvelope {envel timetrio len totaldur} {
	global segment
	set headstt [lindex $timetrio 0]
	set tailstt [lindex $timetrio 1]
	set tailend [lindex $timetrio 2]
	while {$segment(envelcnt) < $len} {
		set thisdat [lindex $envel $segment(envelcnt)] 
		set time [lindex $thisdat 0]
		set val  [lindex $thisdat 1]
		if {$time <= $headstt} {
			set segment(c_pretime) $time
			set segment(c_preval) $val
		} else {
			set done 0
			catch {unset localenvel}
			set posttime $time
			set postval $val									;#		| headtime
			set timediff [expr $posttime - $segment(c_pretime)]	;#	|pre			|post
			set toffset  [expr $headstt - $segment(c_pretime)]	;#	------diff------
			set tratio [expr $toffset/$timediff]				;#  ---- offset
			set vdiff [expr $postval - $segment(c_preval)]
			set vstep [expr $vdiff * $tratio]
			set val [expr $segment(c_preval) + $vstep]
			set nupair [list $headstt $val]						;#	Establish timeval pair for start of H+T
			lappend localenvel $nupair
			while {$posttime < $tailend} {
				set nupair [list $posttime $postval]
				lappend localenvel $nupair
				set segment(c_pretime) $posttime
				set segment(c_preval) $postval
				incr segment(envelcnt)
				if {$segment(envelcnt) >= $len} {
					set thisdat [lindex $envel end]
					set val [lindex $thisdat 1]
					set nupair [list $totaldur $val]
					lappend localenvel $nupair
					set done 1
					break
				}
				set thisdat [lindex $envel $segment(envelcnt)] 
				set posttime [lindex $thisdat 0]
				set postval  [lindex $thisdat 1]
			}
			if {!$done} {
				set timediff [expr $posttime - $segment(c_pretime)]	;#	|pre			|post
				set toffset  [expr $tailend - $segment(c_pretime)]	;#	------diff------
				set tratio [expr $toffset/$timediff]				;#  ---- offset
				set vdiff [expr $postval - $segment(c_preval)]
				set vstep [expr $vdiff * $tratio]
				set val [expr $segment(c_preval) + $vstep]
				set nupair [list $tailend $val]						;#	Establish timeval pair for start of tail
				lappend localenvel $nupair
			}
			break	;#	Once local envel found: break out of local loop
		}
		incr segment(envelcnt)
	}
	return $localenvel
}

#--- Readjust local envelope times to start at start of Head

proc LocalEnvelToZeroTime {localenvel} {
	set stttime [lindex [lindex $localenvel 0] 0]
	set loclen [llength $localenvel]
	set k 0														;#	Adjust local-envel times
	while {$k < $loclen} {
		set dat [lindex $localenvel $k]
		set time [lindex $dat 0]								;#	Times			| |		| |	| | adjusted to zero ->
		set time [expr $time - $stttime]						;#	| |		| |	| |
		set dat [lreplace $dat 0 0 $time]						
		set localenvel [lreplace $localenvel $k $k $dat]
		incr k
	}
	return $localenvel
}

#--- Ensure there are no duplicated times in local pitch-contour or envelope

proc RemoveTimeDuplicatesFromContour {localcontour} {
	set len [llength $localcontour]
	set len_less_one [expr $len - 1]
	set k 0
	while {$k < $len_less_one} {								;#	Remove any duplicate times in contour
		set ktim [lindex [lindex $localcontour $k] 0]
		set j $k
		incr j
		while {$j < $len} {
			set jtim [lindex [lindex $localcontour $j] 0]
			if {[Flteq $ktim $jtim]} {
				set localcontour [lreplace $localcontour $j $j]
				incr len -1
				incr len_less_one -1
			} else {
				incr j
			}
		}
		incr k
	}
	return $localcontour
}

#-- Derive envelope-gain brkpnts from local envelopes

proc GenerateLocalEnvelGains {envels1 envels2 timetrios} {
	global segment
	foreach envel1 $envels1 envel2 $envels2 timetrio $timetrios {
		set headstt [lindex $timetrio 0]
		set tailend [lindex $timetrio 2]
		set olddur [lindex [lindex $envel1 end] 0]
		set newdur [lindex [lindex $envel2 end] 0]
		set tstr [expr $newdur/$olddur]

		set len  [llength $envel1]
		set len2 [llength $envel2]
		set k 0
		while {$k < $len} {									;#	tstretch 1st file tail-envel to same length as 2nd file tail-envel
			set dat [lindex $envel1 $k]
			set time  [lindex $dat 0]
			set time [expr $time * $tstr]
			set dat [lreplace $dat 0 0 $time]
			set envel1 [lreplace $envel1 $k $k $dat]
			incr k
		}
		set k 0
		set j 1
		set preval1 [lindex [lindex $envel2 0] 1]
		catch {unset envel}
		while {$k < $len} {									;#	Replace loudness val by gain val -> in envel1
			set dat1 [lindex $envel1 $k]
			set tim1 [lindex $dat1 0]
			set val1 [lindex $dat1 1]
			set pretim 0.0
			set preval $preval1
			set done 0
			while {$j < $len2} {
				set dat2 [lindex $envel2 $j]
				set posttim [lindex $dat2 0]
				set postval [lindex $dat2 1]
				if {$posttim >= $tim1} {
					set timdiff [expr $posttim - $pretim]
					set toffset	[expr $tim1 - $pretim]
					set tratio  [expr $toffset/$timdiff]
					set valdiff [expr $postval - $preval]
					set vstep	[expr $valdiff * $tratio]
					set val		[expr $preval + $vstep]
					set gain [expr $val/$val1]
					if {$gain > $segment(gainlimit)} {
						set gain $segment(gainlimit)
					}
					set env $dat1
					set env [lreplace $env 1 1 $gain]
					lappend envel $env
					set done 1
					break
				} else {
					set pretim $posttim
					set preval $postval
					incr j
				}
			}
			if {!$done} {
				set val	[lindex [lindex $envel2 end] 1]
				set gain [expr $val/$val1]
				if {$gain > $segment(gainlimit)} {
					set gain $segment(gainlimit)
				}
				set env $dat1
				set env [lreplace $env 1 1 $gain]
				lappend envel $env
			}
			incr k
		}
		lappend envels $envel
	}
	return $envels
}

#---- Extract Complete Envelope of one of input files

proc ExtractEnvelope {fnam} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	if {[file exists $segment(envfil)] && [catch {file delete $segment(envfil)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATAFILE $segment(envfil) : $zit"	
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) envel]
	lappend cmd extract 2 $fnam $segment(envfil) 20 -d0.0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        EXTRACTING ENVELOPE OF FILE $fnam"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO EXTRACT ENVELOPE OF FILE $fnam"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO GET ENVELOPE OF FILE $fnam"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $segment(envfil)]} {
		Inf "NO ENVELOPE OF FILE $fnam CREATED"
		return 0
	}
	if [catch {open $segment(envfil) "r"} zit] {
		Inf "CANNOT OPEN ENVELOPE FILE FROM FILE $fnam : $zit"
		return 0
	}
	catch {unset envel}
	set OK 1
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set line [split $line]
		set nuline {}
		set cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item]} {
				set OK 0
				break
			}
			lappend nuline $item
			incr cnt
		}
		if {!$OK} {
			break
		}
		if {$cnt != 2} {
			Inf "INVALID DATA IN ENVELOPE FILE $segment(envfil) FROM FILE [file rootname $fnam]"
			return 0
		}
		lappend envel $nuline
	}
	close $zit
	if {!$OK} {
		return 0
	}
	if {![info exists envel]} {
		Inf "NO DATA FOUND IN ENVELOPE FILE $segment(envfil) FROM FILE [file rootname $fnam]"
		return 0
	}
	return $envel
}

#--- Write gain brkdate into brkpnt files, and return filenames

proc WriteGainBrkfiles {gainsets} {
	global segment evv
	catch {unset gains}
	set gfnam [file rootname $segment(fadesnd)]
	append gfnam "_FF_"
	if {$segment(phrase)} {
		set msg2 "PHRASE"
	} else {
		set msg2 "HEAD-TAIL PAIR"
	}
	set cnt 1
	foreach gainset $gainsets {
		set fnam $gfnam
		append fnam $cnt $evv(TEXT_EXT)
		if {[file exists $fnam] && [catch {file delete $fnam} zit]} {
			Inf "CANNOT DELETE EXISTING ENVELOPE DATAFILE $fnam: $zit"	
			return 0
		}
		if [catch {open $fnam "w"} zit] {
			Inf "CANNOT OPEN DATAFILE $fnam TO WRITE ENVELOPE DATA FOR $msg2 $cnt: $zit"	
			return 0
		}
		foreach line $gainset {
			puts $zit $line
		}
		close $zit
		lappend gains $fnam	
		incr cnt
	}
	return $gains
}

#--- Find maxvalue in Local Envelope

proc LocalEnvelMax {envel} {
	set maxval -10000
	foreach dat $envel {
		set val [lindex $dat 1]
		if {$val > $maxval} {
			set maxval $val
		}
	}
	return $maxval
}

#--- Find Gain for segment from ratio of segment maxlevels

proc GenerateLocalGains {maxvals1 maxvals2} {
	foreach maxval1 $maxvals1 maxval2 $maxvals2 {
		if {[Flteq $maxval1 0.0] || ($maxval1 < 0.0) || [Flteq $maxval2 0.0] || ($maxval2 < 0.0)} {
			lappend gains 0.0
		} else {
			lappend gains [expr $maxval2/$maxval1]
		}
	}
	return $gains
}

#--- Find start-times of sounds in final mix

proc GetTransferMixtimes {marks} {
	global segment
	if {$segment(phrase)} {
		set outtimes [lreplace $marks end end]
	} else {
		set len [llength $marks]
		incr len -1
		set ishead 0
		if {$segment(headfirst)} {
			set ishead 1
		}
		set j 0
		while {$j < $len} {
			if {$j == 0} {
				set outtime [lindex $marks $j]
				lappend outtimes $outtime
			} elseif {$ishead} {
				set outtime [lindex $marks $j]
				set outtime [expr $outtime - $segment(SPLICE)]
				lappend outtimes $outtime
			}
			set ishead [expr !$ishead]
			incr j
		}
	}
	return $outtimes
}

#--- Dovetail resynthesized file from any spectral processing

proc DovetailTransferOutput {ifnam ofnam strratio msg_typ n} {
	global segment evv CDPidrun prg_dun prg_abortd simple_program_messages

	if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
		lappend segment(report) "CANNOT DELETE PREVIOUS FILE $ofnam : $zit"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) envel]
	lappend cmd dovetail 1 $ifnam $ofnam
	if {$strratio < 1.0} {
		lappend cmd $segment(frametime) $segment(frametime) 
	} else {
		lappend cmd $segment(frametime) $segment(SPLICE) 
	}
	lappend cmd  1 1 -t0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        DOVETAILING MODIFIED $msg_typ $n"
	if [catch {open "|$cmd"} CDPidrun] {
		lappend segment(report) "FAILED TO RUN DOVETAILING"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		lappend segment(report) "FAILED TO CREATE DOVETAILED VERSION"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $ofnam]} {
		lappend segment(report) "NO DOVETAILED VERSION CREATED"
		return 0
	}
	return 1
}

#--- Deduce stretched time from variable-tstretch data

proc GetTimeFromVariableTstr {fnam time msg_typ n} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId
	
	set cmd [file join $evv(CDPROGRAM_DIR) integratetime]
	lappend cmd $fnam $time $segment(srate)
	catch {unset maxsamp_line}
	set done_maxsamp 0
	wm title .blocker "PLEASE WAIT:        FINDING STRETCHED TIME FOR $msg_typ $n"
	if [catch {open "|$cmd"} CDPmaxId] {
		lappend segment(report) "FAILED TO RUN TIME INTEGRATION FOR $msg_typ $n"
		catch {unset CDPmaxId}
		return -1
	} else {
		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
	}
	vwait done_maxsamp
	if {![info exists maxsamp_line]} {
		lappend segment(report) "CANNOT RETRIEVE INTEGRATED STRETCHED TIME FOR $msg_typ $n"
		return -1
	}
	set dat [split $maxsamp_line]
	foreach item $dat {
		set item [string trim $item]
		if {[string length $item] <= 0} {
			continue
		}
		if {[IsNumeric $item]} {
			set time $item
			break
		}
	}
	if {![info exists time]} {
		Inf "CANNOT READ INTERGRATED STRETCHED TIME FOR $msg_typ $n"
		return -1
	}
	return $time
}

#--- Resynth and dovetail output from TRANSFER MODS

proc TransferSynthTrim {ifnam ofnam0 ofnam1 msg_typ n tstr} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun overload_line
	set gain 1.0
	set iifnam $ifnam
	set wfnam [file rootname $segment(premix)]
	append wfnam "_SS" $evv(ANALFILE_EXT)
	set OK 0
	while {!$OK} {

		;#	CREATE WAVEFORM OF MODIFIED SEGMENT

		if {[file exists $ofnam0] && [catch {file delete $ofnam0} zit]} {
			lappend segment(report) "CANNOT DELETE PREVIOUS WAVEFORM OF MODIFIED $msg_typ $n: $zit"
			return 0
		}
		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd synth $iifnam $ofnam0
		set prg_dun 0
		set prg_abortd 0
		catch {unset overload_line}
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF MODIFIED $msg_typ $n"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN WAVEFORM CREATION FOR MODIFIED $msg_typ $n"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "GetPostVocodeOverloadLine"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE WAVEFORM OF MODIFIED $msg_typ $n"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $ofnam0]} {
			Inf "NO WAVEFORM OF MODIFIED $msg_typ $n CREATED"
			return 0
		}

		;#	CHECK FOR OVERLOAD

		if {[info exists overload_line]} {
			set nugain [VocodeResynthOverloaded]
			if {$nugain >= $gain} {
				set OK 1
				break
			}

			;#	IF OVERLOADED, REDUCE LEVEL OF ANALSIS FILE

			if {[file exists $wfnam] && [catch {file delete $wfnam} zit]} {
				Inf "CANNOT DELETE PREVIOUS INTERMEDIATE FILE $wfnam TO ATTENUATE SPECTRUM OF MODIFIED $msg_typ $n"
				return 0
			}
			set cmd [file join $evv(CDPROGRAM_DIR) spec] 
			lappend cmd gain $ifnam $wfnam $nugain
			set prg_dun 0
			set prg_abortd 0
			catch {unset overload_line}
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        ATTENUATING SPECTRUM OF MODIFIED $msg_typ $n"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN ATTENUATION OF SPECTRUM OF MODIFIED $msg_typ $n"
				catch {unset CDPidrun}
				return 0
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE ATTENUATED SPECTRUM OF MODIFIED $msg_typ $n"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				return 0
			}
			if {![file exists $wfnam]} {
				Inf "NO ATTENUATED SPECTRUM OF MODIFIED $msg_typ $n CREATED"
				return 0
			}

			;#	AND USE REDUCED-LEVEL ANALFILE AS INPUT TO RESYNTH

			set iifnam $wfnam

		} else {
			set OK 1				;#	No overload : break from loop
		}
	}
	set ofnam $ofnam0

	;#	NOW DOVETAIL THE WAV OUTPUT

	if {![IsNumeric $tstr]} {
		catch {unset t_str}
		if [catch {open $tstr "r"} zit] {
			lappend segment(report) "FAILED TO OPEN TIMESTRETCH FILE $tstr : $zit"
			lappend segment(report) "              $msg_typ $n COULD NOT BE DOVETAILED"
		} else {
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					set t_str $item						;#	Keep last stretch-value in tstr file
				}
			}
			close $zit
		}
		if {![info exists t_str]} {
			lappend segment(report) "FAILED TO READ LAST VALUE FROM TIMESTRETCH FILE $tstr : $zit"
			lappend segment(report) "              $msg_typ $n COULD NOT BE DOVETAILED"
		}
	} else {
		set t_str $tstr
	}
	if {[info exists t_str]} {
		if {![DovetailTransferOutput $ofnam0 $ofnam1 $t_str $msg_typ $n]} {
			lappend segment(report) "              $msg_typ $n COULD NOT BE DOVETAILED"
		} else {
			set ofnam $ofnam1
		}
	}
	return $ofnam
}

#--- Adjust Gain, if previous gained output overloads

proc ReadjustTransferGain {gain adjust msg_typ n} {
	global segment
	if {![IsNumeric $gain]} {
		if [catch {open $gain "r"} zit] {
			lappend segment(report) "CANNOT OPEN GAIN FILE $gain FOR $msg_typ $n TO ADJUST LEVELS BY $adjust : $zit"
			return 0
		}
		catch {unset nulines}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			set line [split $line]
			set cnt 0
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {$cnt == 0} {
					set nupair [list $item]
				} else {
					lappend nupair [expr $item * $adjust]
					lappend nulines $nupair
				}
				incr cnt
			}
		}
		close $zit
		if [catch {file delete $gain} zit] {
			lappend segment(report) "CANNOT REMOVE ORIGINAL GAIN FILE $gain FOR $msg_typ $n : $zit"
			return 0
		}
		if [catch {open $gain "w"} zit] {
			lappend segment(report) "CANNOT REOPEN GAIN FILE $gain FOR $msg_typ $n TO SET LEVELS ADJUSTED BY $adjust : $zit"
			return 0
		}
		foreach line $nulines {
			puts $zit $line
		}
		close $zit
	} else {
		set gain [expr $gain * $adjust]
	}
	return $gain
}

#--- Eliminate spurious gaps between events

proc GettrofTransferCloseupMix {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set times 0
	set sum 0
	set n 1
	foreach line $segment(mixlines) {
		set fnam [lindex $line 0]
		if {![DoSegmentDurParse $fnam]} {
			Inf "FAILED TO SQUEEZE OUTPUT MIX"
			return
		}
		set sum [expr $sum + $segment(itemdur) - ($segment(SPLICE)/2)]
		lappend times $sum
	}
	set len [llength $segment(mixlines)]
	set k 0
	while {$k < $len} {
		set line [lindex $segment(mixlines) $k]
		set time [lindex $times $k]
		set line [lreplace $line 1 1 $time]
		set segment(mixlines) [lreplace $segment(mixlines) $k $k $line]
		incr k
	}
	return
}

#--- Eliminate silent gaps between events

proc GettrofTransferRemoveSilences {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set times 0
	set sum 0
	set n 1
	foreach line $segment(mixlines) truedur $segment(truedurs) {
		set fnam [lindex $line 0]
		if {![DoSegmentDurParse $fnam]} {
			Inf "FAILED TO SQUEEZE OUTPUT MIX"
			return
		}
		set sum [expr $sum + $truedur - ($segment(SPLICE)/2)]
		lappend times $sum
	}
	set len [llength $segment(mixlines)]
	set k 0
	while {$k < $len} {
		set line [lindex $segment(mixlines) $k]
		set time [lindex $times $k]
		set line [lreplace $line 1 1 $time]
		set segment(mixlines) [lreplace $segment(mixlines) $k $k $line]
		incr k
	}
	return
}

#--- Is output squeezable if duration altered

proc TransferDurationSqueezable {HT1files truedurs} {
	global segment
	foreach fnam1 $HT1files dur2 $truedurs {
		if {![DoSegmentDurParse $fnam1]} {
			Inf "FAILED TO TEST SQUEEZABILITY"
			return 0
		}
		set dur1 $segment(itemdur)	;#	dur1 _____ ________ _______	(NOT RETIMED)
		if {$dur2 < $dur1} {		;#	dur2 __      __   __
			return 0				;#	out  __	   __	    __ naturally gapped
		}
	}
	return 1
}

#--- Is output squeezable it timings altered

proc TransferRetimeSqueezable {marks1 marks2} {
	set outtimessrc1 [GetTransferMixtimes $marks1] 
	set outtimessrc2 [GetTransferMixtimes $marks2]
	set len [llength $outtimessrc1]
	set j 0
	set k 1
	while {$k < $len}  {		
		set step1 [expr [lindex $outtimessrc1 $k] - [lindex $outtimessrc1 $j]]
		set step2 [expr [lindex $outtimessrc2 $k] - [lindex $outtimessrc2 $j]]
		if {$step2 > $step1} {
			return 0				;# stp1 ____ ____ ____	(NOT DUR EXPANDED)
		}							;# stp2 _______ _________ _________
		incr j						;# out  ____	____	  ____	naturally gapped		
		incr k
	}
	return 1
}

#--- Is output squeezable if duration altered and segments retimed

proc TransferRetimeDurationSqueezable {truedurs marks2} {
	global segment
	set outtimessrc2 [GetTransferMixtimes $marks2]
	set len [llength $outtimessrc2]
	set j 0
	set k 1
	while {$k < $len}  {		
		lappend steps2 [expr [lindex $outtimessrc2 $k] - [lindex $outtimessrc2 $j]]
		incr k
		incr j
	}												;# if dur2 < step2
	foreach dur2 $truedurs step2 $steps2 {			;#	stp2	|------|-------|--->
		if {$dur2 < $step2} {						;#	dur2	 __		__		__
			return 0								;#	out		 __		__		__
		}
	}
	return 1
}

proc ModifyTranspositionSet {} {
	global segment pr_modtrset modtrsetval tradjust evv
	set f .modtrset
	catch {unset tradjust}
	if [Dlg_Create $f "MODIFY TRANSFER TRANSPOSITIONS" "set pr_modtrset 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Apply the Data"	  -command "set pr_modtrset 1" -width 18
		button $f.0.l -text "Save Transposition"  -command "set pr_modtrset 2" -width 18
		label  $f.0.d1 -text "" -width 16
		button $f.0.h -text "Help"				  -command "set pr_modtrset 3" -width 8 -bg $evv(HELP)
		button $f.0.v -text "View"				  -command "set pr_modtrset 4" -width 8 -bg $evv(SNCOLOR)
		label  $f.0.d2 -text "" -width 16
		button $f.0.q -text "Abandon"			  -command "set pr_modtrset 0" -width 8
		pack $f.0.s $f.0.l $f.0.d1 $f.0.h $f.0.v $f.0.d2 -side left -padx 2
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.gl  -text "Transpose by" -width  14
		entry $f.1.gg  -textvariable modtrsetval -width 6
		pack $f.1.gl $f.1.gg -side left -anchor n
		pack $f.1 -side top -pady 4
		frame $f.2
		Scrolled_Listbox $f.2.ll -width 20 -height 24 -selectmode single
		pack $f.2.ll -side top -pady 2
		pack $f.2 -side top -pady 2 -fill x -expand true
		wm resizable $f 0 0
		bind $f <Return> {set pr_modtrset 1}
		bind $f <Escape> {set pr_modtrset 0}
	}
	.modtrset.2.ll.list delete 0 end
	set n 1
	foreach line $segment(mixlines) {
		set line "Segment $n"
		.modtrset.2.ll.list  insert end $line			
		incr n
	}
	set pr_modtrset 0
	set modtrsetval ""
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	ResetTransferGate
	My_Grab 0 $f pr_modtrset
	while {!$finished} {
		tkwait variable pr_modtrset
		set transflag 0
		switch -- $pr_modtrset {
			1 {
				if {![info exists tradjust]} {					;#	IF no data saved, save any current primed data
					set i [.modtrset.2.ll.list curselection]
					if {$i < 0} {
						Inf "NO SEGMENT SELECTED"
						continue
					}
					if {([string length $modtrsetval] <= 0) || ![IsNumeric $modtrsetval] || ($modtrsetval > 24) || ($modtrsetval < -24)} {
						Inf "INVALID TRANSPOSITION VALUE (range -24 to +24)"
						continue
					}
					set tradjust($i) $modtrsetval
					Inf "TRANSPOSITION OF SEGMENT [expr $i + 1] ADJUSTED BY $modtrsetval SEMITONES"
				}
				foreach nam [array names tradjust] {
					set segment(tradjust,$nam) $tradjust($nam)
				}
				set finished 1
			}
			2 {
				set i [.modtrset.2.ll.list curselection]
				if {$i < 0} {
					Inf "NO SEGMENT SELECTED"
					continue
				}
				if {([string length $modtrsetval] <= 0) || ![IsNumeric $modtrsetval] || ($modtrsetval > 24) || ($modtrsetval < -24)} {
					Inf "INVALID TRANSPOSITION VALUE (range -24 to +24)"
					continue
				}
				set tradjust($i) $modtrsetval
				Inf "TRANSPOSITION OF SEGMENT [expr $i + 1] ADJUSTED BY $modtrsetval SEMITONES"
				set modtrsetval ""
			}
			3 {
				set msg "MODIFY TRANSFER TRANSPOSITIONS\n"
				append msg "\n"
				append msg "When you rerun \"TRANSFER\",\n"
				append msg "you can move the auto-generated transposition values\n"
				append msg "for a particular segment or segments.\n"
				append msg "\n"
				append msg "(1)  Enter a transposition value in the \"Transpose by\" box.\n"
				append msg "(2)  Hilight a segment in the list which you wish to shift.\n"
				append msg "(3)  Press \"Save Transposition\".\n"
				append msg "           (If transposing ONLY ONE segment, you can skip this step).\n"
				append msg "(4)  Repeat for each segment you wish to shift.\n"
				append msg "(5)  Once all transpositions have been entered, press \"Apply the Data\".\n"
				append msg "\n"
				append msg "NB\n"
				append msg "(a)  The data will be discarded after \"TRANSFER\" has been rerun.\n"
				append msg "(b)  These modifications will NOT be saved should you choose to \"Save Parameters\".\n"
				append msg "\n"
				append msg "You can assess which segments you wish to shift by looking at \"VIEW\".\n"
				append msg "\n"
				Inf $msg
			}
			4 {
				set segment(displaytransfer) 1
				TrofSegOutputSndView
				unset segment(displaytransfer)
			}
			0 {
				set finished 1
			}
		}				
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Display output of transfer process, with (possibly merged) segments shown

proc DoTransferDisplay {} {
	global segment evv pa
	if {[file exists $segment(notedata2)] && [catch {file delete $segment(notedata2)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE DATA FILE $segment(notedata2) : $zit"
		return 0
	}
	if [catch {open $segment(notedata2) "w"} zit] {
		Inf "CANNOT OPEN DATA FILE $segment(notedata2) TO WRITE NEW MARKS: $zit"
		return 0
	}
	if {![info exists pa($segment(outfnamplay),$evv(DUR))]} {
		if {![DoSegmentDurParse $segment(outfnamplay)]} {
			Inf "FAILED TO FIND DURATION OF OUTPUT SOUND"
			return 0
		}
		set pa($segment(outfnamplay),$evv(DUR)) $segment(itemdur)
	}
	if {[info exists segment(intext)]} {
		set origintext $segment(intext)
		unset segment(intext)
	}
	if {[info exists segment(nutroflist)]} {
		set orignutroflist $segment(nutroflist)
	}
	foreach zzline $segment(mixlines) {
		set mark [lindex $zzline 1]
		lappend marks $mark
	}
	foreach mark $marks  {
		puts $zit $mark
	}
	close $zit
	set segment(nutroflist) $segment(notedata2) 
	set segment(displaysegs) 1
	set segment(outdisplay) 1
	SnackDisplay $evv(SN_TIMESLIST) troflist $segment(outfnamplay) 0
	unset segment(displaysegs)
	unset segment(outdisplay)
	if {[info exists origintext]} {
		set segment(intext) $origintext
	}
	if {[info exists orignutroflist]} {
		set segment(nutroflist) $orignutroflist
	}
	return 1
}

#--- Convert from H/T segmentation to Phase-type segmentation (Merge H+Ts)

proc ConvertHTDataToPhraseData {} {
	global segment evv wstk shrhy
	if {!$segment(conv)} {
		return 0
	}
	if {![info exists segment(rfnam)]} {
		return 0
	}
	if {$segment(phrase)} {
		Inf "THIS IS ALREADY PHRASE-TYPE DATA"
		return 0
	}
	set dotext 0
	if {[info exists segment(intext)]} {
		set dotext 1
	}
	if {$segment(headfirst)} {
		set k 0
	} else {
		if {!(($segment(process) == "SHRHYTHM") || ($segment(process) == "ARTICULATION") || ($segment(process) == "HPITCH") \
		|| ($segment(process) == "SPIKE") || ($segment(process) == "SQZBOX") || ($segment(process) == "TSTRETCH"))} {	;#	Shrrhythm, artic & hpitch processes  ignore any 1st-seg tail
			lappend newlist 0.0							;#	whereas other processes treat the first tail as a Phrase unit, as other HEad-Tail pairs			
			if {$dotext} {								;#	So set a phrase at 0, next phrase begins at marklist item 1, so k = 1
				lappend newtxt [lindex $segment(intext) 0]
			}
		}
		set k 1
	}
	while {$k < $segment(cnt)} {
		lappend newlist [lindex $segment(marklist) $k]
		if {$dotext} {
			lappend newtxt [lindex $segment(intext) $k]
		}
		incr k 2
	}
	set segment(cnt) [llength $newlist]
	lappend newlist [lindex $segment(marklist) end]
	set segment(marklist) $newlist
	if {$dotext} {
		set segment(oldtext) $segment(intext)
		set	segment(intext) $newtxt
	}
	set segment(phrase) 1

	if {($segment(process) != "SHRHYTHM") && ($segment(process) != "ARTICULATION") && ($segment(process) != "HPITCH") \
	&& ($segment(process) != "SPIKE") && ($segment(process) != "SQZBOX") && ($segment(process) != "TSTRETCH")} {
		set msg "SAVE THIS PHRASE DATA ??"
		set choice [tk_messageBox -type yesno -icon warning -default yes -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set OK 1
			while {$OK} {
				set f_nam [file rootname [file tail $segment(src,0)]]
				append f_nam "_phrs" $evv(TEXT_EXT)
				set fullname [file join $segment(dirname) $f_nam]
				if {[file exists $fullname]} {
					set msg "FILE $f_nam ALREADY EXISTS : OVERWRITE IT ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						break
					}
				}
				if [catch {open $fullname "w"} zit] {
					Inf "CANNOT OPEN FILE $fnam TO WRITE PHRASE DATA"
					break
				}
				foreach val $segment(marklist) {
					puts $zit $val
				}
				close $zit
				if {!$dotext} {
					break
				}
				set msg "SAVE ASSOCIATED TEXT DATA ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					break
				}
				set f_nam [file rootname [file tail $segment(src,0)]]
				append f_nam "_phrs" $evv(TEXT_EXT)
				set fullname [file join $segment(dirname) $f_nam]
				if {[file exists $fullname]} {
					set msg "FILE $fnam ALREADY EXISTS : OVERWRITE IT ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						break
					}
				}
				if [catch {open $fullname "w"} zit] {
					Inf "CANNOT OPEN FILE $fnam TO WRITE PHRASE TEXT-DATA"
					break
				}
				foreach val $segment(intext) {
					puts $zit $val
				}
				close $zit
				break
			}
		}
		DeleteAllTemporaryFiles
		if {![SegmentSound 0]} {
			ResetGetSyllabTrofs INITIALISE
			return 0
		}
	}

	;#	set up new marks for Soundview Display

	if {($segment(process) == "SHRHYTHM") || ($segment(process) == "ARTICULATION") || ($segment(process) == "HPITCH") \
	|| ($segment(process) == "SPIKE") || ($segment(process) == "SQZBOX") || ($segment(process) == "TSTRETCH")} {
		set segment(nutroflist) $segment(nutroflist_dflt)
	} else {
		set segment(nutroflist) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
	}
	if [catch {open $segment(nutroflist) "w"} zit] {
		Inf "CANNOT OPEN FILE TO USE TO DISPLAY THE NEW SEGMENTATION"
	} else {
		foreach val $segment(marklist) {
			puts $zit $val
		}
		close $zit
	}	 
	if {($segment(process) != "SHRHYTHM") && ($segment(process) != "ARTICULATION" && ($segment(process) != "HPITCH") \
	&& ($segment(process) != "SPIKE") && ($segment(process) != "SQZBOX") && ($segment(process) != "TSTRETCH"))} {
		GettrofMakePhraseMixlines
		.gettrofs.6.h config -text "" -state disabled
		.gettrofs.6.t config -text "" -state disabled
		set segment(headfirst) -1
		.gettrofs.0.p config -text "" -command {} -bd 0 -bg [option get . background {}]
		.gettrofs.0.r config -text "" -command {} -bd 0
		.gettrofs.0.c config -text "" -command {} -bd 0
		.gettrofs.0.rd config -text "" -command {} -state disabled -disabledforeground []
	}
	set segment(again) 0
	set segment(conv) 0
	.gettrofs.2.pc config -text "" -state disabled -disabledforeground [] -command {}
	return 1
}

#--- Enter presets for Time Reversal

proc ReversalStyle {} {
	global segment wstk pr_trversal trversal evv wstk rvsal lasttrversal
	set f .trversal
	if [Dlg_Create $f "SET STYLE FOR TIME REVERSAL" "set pr_trversal 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_trversal 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_trversal 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_trversal 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "REVERSAL GROUPS"
		radiobutton $f.1.1  -text "TAILS"					-variable rvsal -value 1
		radiobutton $f.1.2  -text "HEADS"					-variable rvsal -value 2
		radiobutton $f.1.3  -text "HT pairs"				-variable rvsal -value 3
		radiobutton $f.1.4  -text "keep H: reverse THT"		-variable rvsal -value 4
		radiobutton $f.1.5  -text "THTH"					-variable rvsal -value 5
		radiobutton $f.1.6  -text "keep H: reverseTHTHT"	-variable rvsal -value 6
		radiobutton $f.1.7  -text "HTHTHT"					-variable rvsal -value 7
		radiobutton $f.1.8  -text "keep H: reverseTHTHTHT"	-variable rvsal -value 8
		radiobutton $f.1.9  -text "HTHTHTHT"				-variable rvsal -value 9
		pack $f.1.ll $f.1.1 $f.1.2 $f.1.3 $f.1.4 $f.1.5 $f.1.6 $f.1.7 $f.1.8 $f.1.9 -side top -anchor w
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_trversal 1}
		bind $f <Escape> {set pr_trversal 0}
	}
	if {[info exists lasttrversal]} {
		set rvsal $lasttrversal
	} else {
		set rvsal 0
	}
	set pr_trversal 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_trversal
	while {!$finished} {
		tkwait variable pr_trversal
		set transflag 0
		switch -- $pr_trversal {
			1 {
				set segment(par0) $rvsal
				set segment(PAR0) $segment(par0)	;#	This Param must be set here, as not set later
				set segment(lastpar0,$segment(process)) $segment(par0)
				set lasttrversal $rvsal
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

proc DoReversal {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	NO PROCESSING OF HEADS THEN TAILS OR VICE VERSA

	catch {unset segment(recycproc)}

	;#	FORCE 1st HEAD TO BE AT START OF MARKS LIST

##	set segment(headfirst) [GetHeadfirstData $segment(rfnam)]
	if {!$segment(headfirst)} {
		set marks [lrange $segment(marklist) 1 end]
		if [catch {open $segment(troflist) "w"} zit] {
			Inf "CANNOT OPEN TEMPORARY FILE $segment(troflist) TO WRITE REVISED SEGMENT DATA"
			return 0
		}
		foreach mark $marks {
			puts $zit $mark
		}
		close $zit
	} else {
		set marks $segment(marklist)
		set segment(troflist) [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]
	}
	set segment(cnt) [llength $segment(marklist)]
	incr segment(cnt) -1
	set cmd [file join $evv(CDPROGRAM_DIR) distmore]
	lappend cmd segsbkwd $segment(PAR0) $segment(src,0) $segment(outfnamplay) $segment(troflist)
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	Block "PLEASE WAIT:        Running Segmentwise Time Reversal on File $segment(src,0)"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN PROCESS TO SEGMENTWISE-REVERSE $segment(src,0)"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO SEGMENTWISE-REVERSE $segment(src,0)"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $segment(troflist)]} {
		Inf "NO OUTFILE SEGMENTWISE-REVERSAL OF $segment(src,0)"
		UnBlock
		return 0
	}
	switch -- $segment(PAR0) {
		1 -
		2 {
			set segment(numarks) $marks
		}
		default {
		catch {unset segment(numarks)}
			set j [expr $segment(PAR0) - 1]
			set k 0
			while {$k < $segment(cnt)} {
				if {[expr $k % $j] == 0} {
					lappend segment(numarks) [lindex $marks $k]
				}
				if {![IsEven $j] && [expr $k % $j] == 1} {
					lappend segment(numarks) [lindex $marks $k]
				}
				incr k
			}
			lappend segment(numarks) [lindex $segment(marklist) end]
		}
	}
	UnBlock
	return 1
}

#--- Enter "Preset params for ZigAccel

proc ZigAccelStyle {} {
	global segment pr_zigacc evv zig_acc zig_shrnk last_zig_shrnk zig_log
	set f .zigacc
	if [Dlg_Create $f "PRESET PARAMETERS FOR ZIG ACCEL" "set pr_zigacc 0" -width 40 -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_zigacc 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_zigacc 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_zigacc 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		checkbutton $f.1.ns -text  "No shrinkage" -variable zig_acc -width 18 -command ZigAccNoShrink
		entry $f.1.e -textvariable zig_shrnk -width 6
		label $f.1.ll -text "Minimum zig size after shrinkage" -width 34
		checkbutton $f.1.nl -text  "Log shrink" -variable zig_log -width 12
		set zig_log 0
		pack $f.1.ns $f.1.e $f.1.ll $f.1.nl -side left
		pack $f.1 -side top -pady 4
		set zig_acc 0
		set zig_shrnk [expr ($segment(MSPLICE) * 2) + 1]
		catch {unset last_zig_shrnk}
		wm resizable $f 0 0
		bind $f <Return> {set pr_zigacc 1}
		bind $f <Escape> {set pr_zigacc 0}
	}
	set minshrink [expr ($segment(MSPLICE) * 2) + 1]
	set pr_zigacc 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_zigacc
	while {!$finished} {
		tkwait variable pr_zigacc
		switch -- $pr_zigacc {
			1 {
				set zig_shrnk [$f.1.e get]
				if {$zig_acc} {
					set segment(par0) 0
				} else {
					if {([string length $zig_shrnk] <= 0) || ![IsNumeric $zig_shrnk] || ($zig_shrnk < $minshrink)} { 
						Inf "INVALID VALUE (\"$zig_shrnk\") FOR MINIMUM ZIG LENGTH (Range >= $minshrink mS)"
						continue
					}
					set segment(par0) $zig_shrnk
				}
				set segment(PAR0) $segment(par0)
				set segment(lastpar0,ZIGACCEL) $segment(par0)
				set segment(par1) $zig_log
				set segment(PAR1) $segment(par1)
				set segment(lastpar1,ZIGACCEL) $segment(par1)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

proc ZigAccNoShrink {} {
	global zig_acc segment zig_shrnk last_zig_shrnk zig_log last_ziglog
	switch -- $zig_acc {
		1 {
			set last_zig_shrnk $zig_shrnk
			set zig_shrnk ""
			ForceVal .zigacc.1.e $zig_shrnk
			.zigacc.1.e config -bd 0 -state disabled -disabledbackground [option get . background {}]
			.zigacc.1.ll config -text ""
			set last_ziglog $zig_log
			set zig_log 0
			.zigacc.1.nl config -text "" -state disabled -disabledforeground []
		}
		0 {
			.zigacc.1.e config -bd 2 -state normal
			.zigacc.1.ll config -text "Minimum zig size after shrinkage"
			if {[info exists last_zig_shrnk] && ([string length $last_zig_shrnk] > 0)} {
				set zig_shrnk $last_zig_shrnk
				ForceVal .zigacc.1.e $zig_shrnk
			}
			.zigacc.1.nl config -text "Log shrink" -state normal
			if {[info exists last_ziglog]} {
				set zig_log $last_ziglog
			}
		}
	}
}

#--- Zigaccel pushes mixitems apart (tikme-stretching), so mix must be retimed

proc RespaceMixForZigAccel {mixlines recycd} {
	global segment
	if {$recycd} {
		set multichan 0
		if {[llength [lindex $mixlines 0]] < 2} {
			set multichan 1
		}
		set len [llength $mixlines]
		set len_less_one [expr $len - 1]
		set kk $multichan
		set jj $kk
		incr kk
		set lasttime [lindex [lindex $mixlines $jj] 1]
		while {$kk < $len} {
			set thistime [lindex [lindex $mixlines $kk] 1]
			lappend steps [expr $thistime - $lasttime]
			set lasttime $thistime
			incr kk
			incr jj
		}
		set sum 0.0
		set cnt 0
		set ishead 1
		set kk $multichan
		while {$kk < $len} {
			set line [lindex $mixlines $kk]
			set fnam [lindex $line 0]
			set time $sum
			set line [lreplace $line 1 1 $time]
			set mixlines [lreplace $mixlines $kk $kk $line]
			if {$ishead} {
				if {$kk < $len_less_one} {
					set sum [expr $sum + [lindex $steps $cnt]]
				}
			} else {
				if {![DoSegmentDurParse $fnam]} {
					Inf "FAILED TO FIND DURATION OF OUTPUT SEGMENT [expr $kk - $multichan + 1]"
					return ""
				}
				set sum [expr $sum + $segment(itemdur) - $segment(SPLICE)]
			}
			set ishead [expr !$ishead]
			incr kk		;#	kk	 indexes lines
			incr cnt	;#	cnt indexes list of steps between lines
		}
	} else {
		set kk 0
		set sum 0.0
		set len [llength $mixlines]
		while {$kk < $len} {
			set line [lindex $mixlines $kk]
			set fnam [lindex $line 0]
			set time $sum
			set line [lreplace $line 1 1 $time]
			set mixlines [lreplace $mixlines $kk $kk $line]
			if {![DoSegmentDurParse $fnam]} {
				Inf "FAILED TO FIND DURATION OF OUTPUT SEGMENT [expr $kk - $multichan + 1]"
				return ""
			}
			set sum [expr $sum + $segment(itemdur) - $segment(SPLICE)]
			incr kk
		}
	}
	return $mixlines
}

##################
# SHRINK RHYTHMS #
##################

#--- Setup preset params for Shrink Rhythms

proc ShrhythmStyle {} {
	global segment wstk pr_shrhy shrhy evv wstk ocl tv_active
	set shrhy(kbd) 1
	if {!$segment(phrase)} {
		set segment(conv) 1
		set segment(oldmarks) $segment(marklist)
		set segment(oldheadfirst) $segment(headfirst)
		set segment(oldcnt) $segment(cnt)
		if {![ConvertHTDataToPhraseData]} {
			return 0
		}
		if {!$segment(oldheadfirst)} {		;#	DON'T KEEP THE INITIAL TAIL, IF ANY
			set segment(marklist) [lreplace $segment(marklist) 0 0 [lindex $segment(oldmarks) 1]]
		}
		DeleteAllTemporaryFilesExcept $segment(nutroflist)
		if {![SegmentSound 1]} {
			return 0
		}
	}
	set segment(tuningcnt) [llength $segment(marklist)]
	incr segment(tuningcnt) -1
	set segment(cnt) $segment(tuningcnt)

	set f .shrhy
	if [Dlg_Create $f "SET STYLE FOR SHRINK RHYTHMS" "set pr_shrhy 0" -height 20 -borderwidth $evv(SBDR) -width 120] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_shrhy 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_shrhy 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_shrhy 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		frame $f.10
		frame $f.1
		radiobutton $f.10.tap -text "Tap Times or Use Kbd" -variable shrhy(tap) -value 1 -width 20 -command "ShowShrhyKeybd 1"
		radiobutton $f.10.val -text "Choose Pattern"	-variable shrhy(tap) -value 2 -width 14 -command "ShowShrhyKeybd 1"
		radiobutton $f.10.scn -text "Do Scansion" -variable shrhy(tap) -value 3 -width 11 -command "ShowShrhyKeybd 1"
		frame $f.10.1
		button $f.10.1.times   -text "TAP\nTIMES\nHERE" -command "Timer" -width 10
		frame $f.10.1.1
		button $f.10.1.1.stop    -text "KEEP"  -width 5 -command {set pr_shrhy [NuNuTimeCalc]}
		button $f.10.1.1.restart -text "AGAIN" -width 5 -command {set pr_shrhy 6}
		pack $f.10.1.1.stop $f.10.1.1.restart -side left
		pack $f.10.1.times $f.10.1.1 -side top
		frame $f.10.2
		if {$tv_active} {
			GettrofMakeKeyboardKey $f.10.2
		}
		label $f.10.cnt -text "$segment(tuningcnt) NOTES"
		label $f.1.rhs -text "Rhythm Style"
		radiobutton $f.1.dada		-text "Daadi-" -variable shrhy(rhystyl) -value 1
		radiobutton $f.1.didida		-text "di-di-" -variable shrhy(rhystyl) -value 2
		label $f.1.shr -text "Shrink size (mS)"
		entry $f.1.e -textvariable shrhy(mshrink) -width 6 -state readonly
		set shrhy(rhystyl) 0
		set shrhy(mshrink) ""
		label $f.1.arr -text "Use \"Command\" Up/Down" -fg $evv(SPECIAL) -width 20
		label $f.1.acl -text "Accentuation"
		entry $f.1.acc -textvariable shrhy(accentuation) -width 4 -state readonly
		label $f.1.zzz -text "\"Control\" Up/Down" -fg $evv(SPECIAL) -width 20
		pack $f.10.tap $f.10.val $f.10.scn $f.10.1 $f.10.2 $f.10.cnt -side left -padx 4 -anchor w
		pack $f.1.rhs $f.1.dada $f.1.didida $f.1.shr $f.1.e $f.1.arr $f.1.acl $f.1.acc $f.1.zzz -side left -padx 4 -anchor w
		set shrhy(accentuation) 0
		frame $f.1a
		label $f.1a.tt -text "Tempo MM: " -width 10
		entry $f.1a.et -textvariable shrhy(tempo) -width 8
		label $f.1a.tempohlp -text "Use LEFT & RIGHT Arrows (With \"Control\" for Fast change)" -fg $evv(SPECIAL) -width 60
		pack $f.1a.tt $f.1a.et $f.1a.tempohlp -side left
		frame $f.2
		label $f.2.dupl -text "DUPLE " -width 7 -fg $evv(SPECIAL)
		radiobutton $f.2.dada		-text "DaDa"		-variable shrhy(rhythm) -value 1 -width 4 -command ShrhyDone
		radiobutton $f.2.didida		-text "DidiDa"		-variable shrhy(rhythm) -value 2 -width 6 -command ShrhyDone
		label $f.2.trpl -text "TRIPLE " -width 7 -fg $evv(SPECIAL)
		radiobutton $f.2.dada_		-text "DaDa--"		-variable shrhy(rhythm) -value 3 -width 6 -command ShrhyDone
		radiobutton $f.2.dadidi_	-text "DaDidi--"	-variable shrhy(rhythm) -value 4 -width 8 -command ShrhyDone
		radiobutton $f.2.didida_	-text "DidiDa--"	-variable shrhy(rhythm) -value 5 -width 8 -command ShrhyDone
		radiobutton $f.2.didididi_	-text "Didididi--"	-variable shrhy(rhythm) -value 6 -width 8 -command ShrhyDone
		label $f.2.quad -text "QUAD " -width 7 -fg $evv(SPECIAL)
		radiobutton $f.2.dididadada -text "DidiDaDaDa"	-variable shrhy(rhythm) -value 7 -width 8 -command ShrhyDone
		radiobutton $f.2.didi_dada  -text "Didi--DaDa"	-variable shrhy(rhythm) -value 8 -width 8 -command ShrhyDone
		radiobutton $f.2.didida_da  -text "DidiDa--Da"	-variable shrhy(rhythm) -value 9 -width 8 -command ShrhyDone
		radiobutton $f.2.dididada_  -text "DidiDaDa--"	-variable shrhy(rhythm) -value 10 -width 8 -command ShrhyDone
		radiobutton $f.2.dididida_  -text "Didididi----" -variable shrhy(rhythm) -value 11 -width 8 -command ShrhyDone
		pack $f.2.dupl $f.2.dada $f.2.didida $f.2.trpl $f.2.dada_ $f.2.dadidi_ $f.2.didida_ -side left
		pack $f.2.didididi_ $f.2.quad $f.2.dididadada $f.2.didi_dada $f.2.didida_da $f.2.dididada_ $f.2.dididida_ -side left
		frame $f.3
		label $f.3.off -text "OFFSET " -width 7 -fg $evv(SPECIAL)
		radiobutton $f.3.off0 -text "0" -variable shrhy(offset) -value 0 -width 2
		radiobutton $f.3.off1 -text "1" -variable shrhy(offset) -value 1 -width 2
		radiobutton $f.3.off2 -text "2" -variable shrhy(offset) -value 2 -width 2
		radiobutton $f.3.off3 -text "3" -variable shrhy(offset) -value 3 -width 2
		label $f.3.rnd -text "RAND OMIT " -width 10 -fg $evv(SPECIAL)
		label $f.3.rndhlp -text "  Use UP & DOWN Arrows" -fg $evv(SPECIAL)
		checkbutton $f.3.restore -text "Restore Original" -variable shrhy(restore) -width 12 -command ShrhyRestore

		entry $f.3.ee -textvariable shrhy(rand) -state readonly 
		pack $f.3.off $f.3.off0 $f.3.off1 $f.3.off2 $f.3.off3 $f.3.rnd $f.3.ee $f.3.rndhlp $f.3.restore -side left
		bind $f <Up> {IncrShrhyRand 0}
		bind $f <Down> {IncrShrhyRand 1}
		bind $f <Command-Up> {IncrShrhyShrink 0}
		bind $f <Command-Down> {IncrShrhyShrink 1}
		bind $f <Control-Up> {IncrShrhyAccentuation 0}
		bind $f <Control-Down> {IncrShrhyAccentuation 1}
		bind $f <Left> {IncrShrhyTempo 1 1}
		bind $f <Right> {IncrShrhyTempo 0 1}
		bind $f <Control-Left> {IncrShrhyTempo 1 10}
		bind $f <Control-Right> {IncrShrhyTempo 0 10}
		pack $f.0 $f.1 $f.10 $f.1a $f.2 $f.3 -side top -side top -fill x -expand true -pady 4
		wm resizable $f 0 0
		set shrhy(tap) 0
		ShowShrhyKeybd 0
		bind $f <Return> {set pr_shrhy 1}
		bind $f <Escape> {set pr_shrhy 0}
	}
	set shrhy(restore) 0
	$f.3.restore config -text "" -state disabled -disabledforeground []
	set shrhy(tap) 0
	ShowShrhyKeybd 0
	set shrhy(restore) 0
	set shrhy(done) 0
	set shrhy(rhythm) 0
	set pr_shrhy 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_shrhy
	while {!$finished} {
		set shrhy(done) 0
		tkwait variable pr_shrhy
		set transflag 0
		if {$pr_shrhy == 1 || $pr_shrhy == 5} { 
			if {$shrhy(mshrink) == 0} {
				set msg "NO SHRINKAGE : IS THIS OK ??"
				set choice [tk_messageBox -type yesno -icon warning -default yes -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
			}
		}
		switch -- $pr_shrhy {
			1 {
				switch -- $shrhy(done) {
					2 {						;#	LOAD SCANSION, ACCENT PATTERN ALSO LOADED
						set paired 0
						foreach qstep $shrhy(qsteps) {
							if {$qstep == 2} {
								set paired 1
								break
							}
						}
						set shrhy(minstep) [expr 60.0/double($shrhy(tempo))]
						if {$paired} {
							set shrhy(minstep) [expr $shrhy(minstep) / 2.0]
						}
						set shrhy(MM) $shrhy(tempo)
						catch {unset segment(numarks)}
						set sum 0
						foreach qstep $shrhy(qsteps) {
							lappend segment(numarks) $sum					
							set sum [expr $sum + ($qstep * $shrhy(minstep))]
						}
						lappend segment(numarks) $sum					
					}
					1 {						;#	ENTER PATTERN AS A SET VALUE) e.g. didiDaDa: ACCENT PATTERN DERIVED FROM PATTERN, HERE
						if {$shrhy(rhythm) == 0} {
							Inf "NO RHYTHM SELECTED"
							continue
						}
						set cnt 0
						catch {unset shrhy(qsteps)}
						catch {unset shrhy(accents)}
						switch -- $shrhy(rhythm) {
							1 {			;#	DaDa
								while {$cnt < $segment(tuningcnt)} {
									lappend shrhy(qsteps) 1
									if {[IsEven $cnt]} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr cnt
								}
								set beatgroup 1
							}
							2 {			;#	DidiDa
								switch -- $shrhy(offset) {
									0 -
									2 { set pos 0 }
									1 -
									3 { set pos 2 }
								}
								set pos [expr $shrhy(offset) % 3]
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 2 }
									}
									if {[expr $cnt % 3] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 3]
									incr cnt
								}
								set beatgroup 2
							}
							3 {			;#	DaDa--
								switch -- $shrhy(offset) {
									1		{ set pos 1 }
									default { set pos 0 }
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 2 }
									}
									if {[IsEven $cnt]} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 2]
									incr cnt
								}
								set beatgroup 1
							}
							4 {			;#	DaDidi--
								switch -- $shrhy(offset) {
									1		{ set pos 1 }
									default { set pos 0 }
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 2 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 3 }
									}
									if {[expr $cnt % 3] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 3]
									incr cnt
								}
								set beatgroup 2
							}
							5 {			;#	DidiDa--
								switch -- $shrhy(offset) {
									1		{ set pos 1 }
									default { set pos 0 }
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 4 }
									}
									if {[expr $cnt % 3] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 3]
									incr cnt
								}
								set beatgroup 2
							}
							6 {			;#	Didididi--
								switch -- $shrhy(offset) {
									1		{set pos 2}
									default { set pos 0 }
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 1 }
										3 {	lappend shrhy(qsteps) 3 }
									}
									if {[expr $cnt % 4] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 4]
									incr cnt
								}
								set beatgroup 2
							}
							7 {			;# DidiDaDaDa
								switch -- $shrhy(offset) {
									0 {set pos 0}
									1 {set pos 2}
									2 {set pos 3}
									3 {set pos 4}
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 2 }
										3 {	lappend shrhy(qsteps) 2 }
										4 {	lappend shrhy(qsteps) 2 }
									}
									if {[expr $cnt % 5] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 5]
									incr cnt
								}
								set beatgroup 2
							}
							8 {			;#	Didi--DaDa
								switch -- $shrhy(offset) {
									0 {set pos 0}
									1 {set pos 2}
									2 {set pos 2}
									3 {set pos 4}
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 3 }
										2 {	lappend shrhy(qsteps) 2 }
										3 {	lappend shrhy(qsteps) 2 }
									}
									if {[expr $cnt % 4] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 4]
									incr cnt
								}
								set beatgroup 2
							}
							9 {			;#	DidiDa--Da
								switch -- $shrhy(offset) {
									0 {set pos 0}
									1 {set pos 2}
									2 {set pos 3}
									3 {set pos 3}
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 4 }
										3 {	lappend shrhy(qsteps) 2 }
									}
									if {[expr $cnt % 4] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 4]
									incr cnt
								}
								set beatgroup 2
							}
							10 {			;#	DidiDaDa--
								switch -- $shrhy(offset) {
									0 {set pos 0}
									1 {set pos 2}
									2 {set pos 3}
									3 {set pos 0}
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 2 }
										3 {	lappend shrhy(qsteps) 4 }
									}
									if {[expr $cnt % 4] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 4]
									incr cnt
								}
								set beatgroup 2
							}
							11 {			;#	DidiDidi----
								switch -- $shrhy(offset) {
									1		{set pos 2}
									default {set pos 0}
								}
								while {$cnt < $segment(tuningcnt)} {
									switch -- $pos {
										0 {	lappend shrhy(qsteps) 1 }
										1 {	lappend shrhy(qsteps) 1 }
										2 {	lappend shrhy(qsteps) 1 }
										3 {	lappend shrhy(qsteps) 5 }
									}
									if {[expr $cnt % 4] == 0} {
										lappend shrhy(accents) 1
									} else {
										lappend shrhy(accents) 0
									}
									incr pos
									set pos [expr $pos % 4]
									incr cnt
								}
								set beatgroup 2
							}
						}
						if {$shrhy(rand) > 0.0} {
							set origlen [llength $shrhy(qsteps)]
							set moresteps [concat $beatgroup $shrhy(qsteps)]		;#	Double the length of the original qset
							set moreaccs  [concat 0 $shrhy(accents)]				;#	Double the length of the original accents set
							set shrhy(qsteps) [concat $shrhy(qsteps) $moresteps]
							set shrhy(acents) [concat $shrhy(accents) $moreaccs]
							set nulen [llength $shrhy(qsteps)]
							set omits [expr int(round($shrhy(rand) * 10.0))]		;#	omits is the number of items out of 10, to omit
							set nucnt 0
							set nutop [expr $nucnt + 10]							;#	nucnt and nutop are start and end of 10 unit blocks in enlarged qset		
							if {$nutop > $nulen} {									;#	but final block may be shorter than 10	
								set nutop $nulen
							}														;#	nutop is a limit, nutopcnt counts the top item below that limit	
							set nutopcnt [expr $nutop - 1]
							set permcnt [expr $nutop - $nucnt]						;#	Actual number (possibly less than 10) of items in the block
							if {$permcnt < 10} {
								set omits [expr int(round((double)omits * (double)permcnt/10.0))]		;#	Reduce items to omit if permlen is < 10
							}
							set cnt 0												;#	cnt counts the final set as random omissions are made
							catch {unset nuq}
							catch {unset nua}
							while {$cnt < $origlen} {
								set subset [lrange $shrhy(qsteps) $nucnt $nutopcnt]	;#	Get 10 (or possibly less) items from the expanded qset
								set substa [lrange $shrhy(accents) $nucnt $nutopcnt];#	Get 10 (or possibly less) items from the expanded accents
								if {$omits > 0} {
									set omitlist [ShRhyPerm $permcnt $omits $cnt]	;#	omitlist = the items will be omitted
								} else {
									set omitlist {}
								}
								set z 0
								while {$z < $permcnt} {
									if {[lsearch $omitlist $z] < 0} {				;#	If this item of subset is NOT to be omitted
										lappend nuq [lindex $subset $z]				;#	Append it to the final list, and incr cnt of final list
										lappend nua [lindex $substa $z]				;#	Append it to the final list, and incr cnt of final list
										incr cnt
										if {$cnt == $origlen} {
											break
										}
									} else {										;#	Else, extend the final element in new list by this (event omitted) amount
										set sum [expr [lindex $nuq end] + [lindex $subset $z]]
										set nuq [lreplace $nuq end end $sum]
									}
									incr z
								}
								if {$cnt == $origlen} {
									break
								}
								incr nucnt 10
								incr nutop 10
								if {$nutop > $nulen} {
									set nutop $nulen
								}
								set nutopcnt [expr $nutop - 1]
								set permcnt [expr $nutop - $nucnt]					;#	Actual number (possibly less than 10) of items in the block
								if {$permcnt < 10} {
									set omits [expr int(round((double)omits * (double)permcnt/10.0))]
								}
							}
							set shrhy(qsteps) $nuq
							set shrhy(accents) $nua
						}
						catch {unset segment(numarks)}
						set sum 0.0
						
						set beat [expr 60.0/($shrhy(tempo) * $beatgroup)]
						foreach qstep $shrhy(qsteps) {
							lappend segment(numarks) $sum					
							set sum [expr $sum + ($qstep * $beat)]
						}
						lappend segment(numarks) $sum	
						set shrhy(minstep) $beat
						set beat [expr $beat * $beatgroup]				
						set shrhy(MM) [expr int(round(60.0/$beat))]
					} 
					0 {				;#	MIDI KBD ENTRY

						if {![info exists segment(ocl)]} {
							Inf "NO NOTES ENTERED"
							continue
						} else {
							set inlen [llength $segment(ocl)]
						}
						if {$inlen < $segment(tuningcnt)} {
							if {$inlen < 3} {
								set msg "INSUFFICIENT NOTES ([llength $segment(ocl)]): NEED $segment(tuningcnt)"
								continue
							} else {
								set msg "INSUFFICIENT NOTES ([llength $segment(ocl)]): NEED $segment(tuningcnt): USE AS REPEATED PATTERN ?"
								set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
								if {$choice == "yes"} {
									set segment(ocl) [ShRhyRepeater $segment(ocl)]	;#	Quantisation inside this function, +Accent pattern deduced here
								} else {
									continue
								}
							}
						} elseif {$inlen > $segment(tuningcnt)} {
							set segment(ocl) [lrange $segment(ocl) 0 [expr $segment(tuningcnt) - 1]]
							QuantizeShRhy 1											;#	+Accent pattern deduced here, accents fall on (leading) double-length event
						} else {
							QuantizeShRhy 1											;#	+Accent pattern deduced here, accents fall on (leading) double-length event
						}
						set shrhy(orig_qsteps) $shrhy(qsteps)
						ReviseShRhy													;#	If qsteps changed, accent pattern is also revised

						catch {unset segment(numarks)}
						set paired 0
						set sum 0
						foreach qstep $shrhy(qsteps) {
							if {$qstep == 2} {
								set paired 1
							}
							lappend segment(numarks) $sum					
							set sum [expr $sum + ($qstep * $shrhy(minstep))]
						}
						lappend segment(numarks) $sum					
						set shrhy(tempo) [expr 60.0/$shrhy(minstep)]
						if {$paired} {
							set shrhy(tempo) [expr $shrhy(tempo)/2]
						}
						set shrhy(MM) [expr int(round($shrhy(tempo)))]
					}
				}
					;#	IF SCANSION NOT LOADED, DEDUCE IT HERE

				if {$shrhy(done) != 2} {
					catch {unset shrhy(scansion)}
					switch -- $shrhy(rhystyl) {
						2 {
							foreach qstep $shrhy(qsteps) {
								lappend shrhy(scansion) "."
							}
						}
						1 {
							set triplets 0
							set msg "SCAN IN TRIPLETS ??"
							set choice [tk_messageBox -type yesno -icon warning -default no -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set triplets 1
								set shrhy(MM) [expr int(round($shrhy(MM) * 0.6666666))]
							}
							set ssum 0
							foreach qstep $shrhy(qsteps) {
								if {$qstep == 1} {
									lappend shrhy(scansion) "."
								} else {
									if {$triplets} {
										if {[expr $ssum % 3] == 0}  {
											lappend shrhy(scansion) "-"
										} else {
											lappend shrhy(scansion) "."
										}
									} else {		
										if {[IsEven $ssum]}  {
											lappend shrhy(scansion) "-"
										} else {
											lappend shrhy(scansion) "."
										}
									}
								}
								incr ssum $qstep
							}
						}
					}
				}
				set segment(control1) $segment(numarks)
				set segment(lastcontrol1,$segment(process)) $segment(control1)
				set endval [expr [lindex $segment(numarks) end] + 10.0]		;#	Post end marker
				set segment(numarks) [lreplace $segment(numarks) end end $endval]
				set segment(par0) $shrhy(MM)
				set segment(PAR0) $segment(par0)	;#	These Param must be set here, as not set later
				set segment(lastpar0,$segment(process)) $segment(par0)
				set segment(par1) $shrhy(mshrink)
				set segment(PAR1) $segment(par1)
				set segment(lastpar1,$segment(process)) $segment(par1)
				set segment(par2) $shrhy(rhystyl)
				set segment(PAR2) $segment(par2)
				set segment(lastpar2,$segment(process)) $segment(par2)
				set segment(par3) $shrhy(accentuation)
				set segment(PAR3) $segment(par3)
				set segment(lastpar3,$segment(process)) $segment(par3)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
			5 {									;#	TIME TAP, DATA FOUND
				set inlen [llength $ocl]
				if {$inlen < $segment(tuningcnt)} {
					if {$inlen < 3} {
						set msg "INSUFFICIENT NOTES ($inlen): NEED $segment(tuningcnt)"
						unset ocl
						.shrhy.1.1.1.restart config -state normal
						continue
					} else {
						set msg "INSUFFICIENT NOTES ($inlen): NEED $segment(tuningcnt): USE AS REPEATED PATTERN ?"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "yes"} {
							set segment(ocl) [ShRhyRepeater $ocl]	;#	+Accent pattern deduced, Accent on 1st event of repeating pattern
						} else {
							unset ocl
							.shrhy.1.1.1.restart config -state normal
							continue
						}
					}
				} elseif {$inlen > $segment(tuningcnt)} {
					set segment(ocl) [lrange $ocl 0 [expr $segment(tuningcnt) - 1]]
					QuantizeShRhy 1							;#	+Accent pattern deduced here, accents fall on (leading) double-length event
				} else {
					set segment(ocl) $ocl
					QuantizeShRhy 1							;#	+Accent pattern deduced here, accents fall on (leading) double-length event
				}
				set shrhy(orig_qsteps) $shrhy(qsteps)
				ReviseShRhy									;#	If qsteps changed, accent pattern is also revised
				unset ocl
				.shrhy.1.1.1.restart config -state normal
				catch {unset segment(numarks)}
				set paired 0
				set sum 0
				foreach qstep $shrhy(qsteps) {
					if {$qstep == 2} {
						set paired 1
					}
					lappend segment(numarks) $sum					
					set sum [expr $sum + ($qstep * $shrhy(minstep))]
				}
				lappend segment(numarks) $sum					
				set shrhy(tempo) [expr 60.0/$shrhy(minstep)]
				if {$paired} {
					set shrhy(tempo) [expr $shrhy(tempo)/2]
				}
				set shrhy(MM) [expr int(round($shrhy(tempo)))]

				catch {unset shrhy(scansion)}

				;#	DERIVE SCANSION

				switch -- $shrhy(rhystyl) {					
					2 {
						foreach qstep $shrhy(qsteps) {
							lappend shrhy(scansion) "."
						}
					}
					1 {
						set triplets 0
						set msg "SCAN IN TRIPLETS ??"
						set choice [tk_messageBox -type yesno -icon warning -default no -parent [lindex $wstk end] -message $msg]
						if {$choice == "yes"} {
							set triplets 1
							set shrhy(MM) [expr int(round($shrhy(MM) * 0.6666666))]
						}
						catch {unset shrhy(scansion)}
						set sum 0
						foreach qstep $shrhy(qsteps) {
							if {$qstep == 1}  {
								lappend shrhy(scansion) "."
							} else {
								if {$triplets} {
									if {[expr $sum % 3] == 0}  {
										lappend shrhy(scansion) "-"
									} else {
										lappend shrhy(scansion) "."
									}
								} else {		
									if {[IsEven $sum]}  {
										lappend shrhy(scansion) "-"
									} else {
										lappend shrhy(scansion) "."
									}
								}
							}
							set sum [expr $sum + $qstep]
						}
					}
				}
				set segment(control1) $segment(numarks)
				set segment(lastcontrol1,$segment(process)) $segment(control1)
				set endval [expr [lindex $segment(numarks) end] + 10.0]		;#	Post end marker
				set segment(numarks) [lreplace $segment(numarks) end end $endval]
				set segment(par0) $shrhy(MM)
				set segment(PAR0) $segment(par0)	;#	These Param must be set here, as not set later
				set segment(lastpar0,$segment(process)) $segment(par0)
				set segment(par1) $shrhy(mshrink)
				set segment(PAR1) $segment(par1)
				set segment(lastpar1,$segment(process)) $segment(par1)
				set segment(par2) $shrhy(rhystyl)
				set segment(PAR2) $segment(par2)
				set segment(lastpar2,$segment(process)) $segment(par2)
				set finished 1
			}
			6 {									;#	TIME TAP, RESET TO START AGAIN
				.shrhy.10.1.times	 config -state normal -bg $evv(EMPH)
				.shrhy.10.1.1.stop	 config -state normal
				.shrhy.10.1.1.restart config -state disabled
			}
		}
	}
	catch {unset shrhy(orig_qsteps)}
	unset shrhy(kbd)
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

proc ShowShrhyKeybd {warn} {
	global segment wstk pr_shrhy shrhy evv wstk tv_active
	if {$warn} {
		if {$shrhy(rhystyl) == 0 && ($shrhy(tap) != 3)} {
			Inf "ENTER RHYTHM STYLE FIRST"
			set shrhy(tap) 0
			return
		}
		if {[string length $shrhy(mshrink)] == 0} {
			Inf "ENTER SHRINK SIZE FIRST"
			set shrhy(tap) 0
			return
		} elseif {$shrhy(mshrink) == 0} {
			set msg "NO SHRINKING : IS THIS OK ?? IF NOT, ENTER SHRINK SIZE NOW"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				set shrhy(tap) 0
				return
			}
		}
	}
	switch -- $shrhy(tap) {
		0 {
			.shrhy.10.1.times config -text "\n\n" -command {} -state disabled -bd 0
			.shrhy.10.1.1.stop    config -text "" -command {} -state disabled -bd 0
			.shrhy.10.1.1.restart config -text "" -command {} -state disabled -bd 0
			if {$tv_active} {
				bind .shrhy.10.2.0   <ButtonPress-1> {}
				bind .shrhy.10.2.1.0 <ButtonPress-1> {}
				bind .shrhy.10.2.1.1 <ButtonPress-1> {}
				bind .shrhy.10.2.1.2 <ButtonPress-1> {}
				bind .shrhy.10.2.1.3 <ButtonPress-1> {}
				bind .shrhy.10.2.1.4 <ButtonPress-1> {}
				bind .shrhy.10.2.1.5 <ButtonPress-1> {}
				bind .shrhy.10.2.1.6 <ButtonPress-1> {}
				bind .shrhy.10.2.2.0 <ButtonPress-1> {}
				bind .shrhy.10.2.2.1 <ButtonPress-1> {}
				bind .shrhy.10.2.2.2 <ButtonPress-1> {}
				bind .shrhy.10.2.2.3 <ButtonPress-1> {}
				bind .shrhy.10.2.2.4 <ButtonPress-1> {}
				bind .shrhy.10.2.2.5 <ButtonPress-1> {}
				bind .shrhy.10.2.2.6 <ButtonPress-1> {}
				bind .shrhy.10.2.3   <ButtonPress-1> {}
			}
			.shrhy.1a.tt config -text ""
			.shrhy.1a.et config -state disabled -bd 0  -disabledbackground [option get . background {}]
			.shrhy.1a.tempohlp config -text ""
			set shrhy(tempo) ""
			.shrhy.2.dupl config -text ""
			.shrhy.2.dada config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida config -text ""	-state disabled -disabledforeground []
			.shrhy.2.trpl config -text ""
			.shrhy.2.dada_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dadidi_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didididi_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.quad config -text ""
			.shrhy.2.dididadada config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didi_dada  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida_da  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dididada_  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dididida_  config -text ""	-state disabled -disabledforeground []
			.shrhy.3.off config -text ""
			.shrhy.3.off0 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off1 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off2 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off3 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.rnd config -text ""
			.shrhy.3.rndhlp config -text ""
			set shrhy(offset) -1
			set shrhy(rhythm) 0
			set shrhy(rand) ""
			.shrhy.3.ee config -state disabled -bd 0 -disabledbackground [option get . background {}]
			bind .shrhy <Up> {}
			bind .shrhy <Down> {}
			bind .shrhy <Left> {}
			bind .shrhy <Right> {}
			bind .shrhy <Control-Right> {}
			bind .shrhy <Control-Left>  {}
		}
		1 {
			.shrhy.10.1.times     config -text "TAP\nTIMES\nHERE" -command "Timer" -state normal -bd 2
			.shrhy.10.1.1.stop    config -text "KEEP" -command {set pr_shrhy [NuNuTimeCalc]} -state normal -bd 2
			.shrhy.10.1.1.restart config -text "AGAIN" -command {set pr_shrhy 6} -state normal -bd 2
			if {$tv_active} {
				bind .shrhy.10.2.0   <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.0 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.1 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.2 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.3 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.4 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.5 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.1.6 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.0 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.1 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.2 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.3 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.4 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.5 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.2.6 <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
				bind .shrhy.10.2.3   <ButtonPress-1> "GettrofGetNoteData 2 .shrhy.1.2"
			}
			.shrhy.1a.tt config -text ""
			.shrhy.1a.et config -state disabled -bd 0  -disabledbackground [option get . background {}]
			.shrhy.1a.tempohlp config -text ""
			if {[IsNumeric $shrhy(tempo)]} {	
				set shrhy(lasttempo) $shrhy(tempo)
				set shrhy(tempo) ""
			}
			.shrhy.2.dupl config -text ""
			.shrhy.2.dada config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida config -text ""	-state disabled -disabledforeground []
			.shrhy.2.trpl config -text ""
			.shrhy.2.dada_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dadidi_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didididi_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.quad config -text ""
			.shrhy.2.dididadada config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didi_dada  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida_da  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dididada_  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dididida_  config -text ""	-state disabled -disabledforeground []
			.shrhy.3.off config -text ""
			.shrhy.3.off0 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off1 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off2 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off3 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.rnd config -text ""
			.shrhy.3.rndhlp config -text ""
			if {[IsNumeric $shrhy(rand)]} {
				set shrhy(lastrand) $shrhy(rand)
				set shrhy(rand) ""
			}
			set shrhy(lastoffset) $shrhy(offset)
			set shrhy(offset) -1
			set shrhy(lastrhythm) $shrhy(rhythm)
			set shrhy(rhythm) 0
			.shrhy.3.ee config -state disabled -bd 0 -disabledbackground [option get . background {}]
			bind .shrhy <Up> {}
			bind .shrhy <Down> {}
			bind .shrhy <Left> {}
			bind .shrhy <Right> {}
			bind .shrhy <Control-Right> {}
			bind .shrhy <Control-Left>  {}
		}
		2 {
			.shrhy.10.1.times config -text "\n\n" -command {} -state disabled -bd 0
			.shrhy.10.1.1.stop    config -text "" -command {} -state disabled -bd 0
			.shrhy.10.1.1.restart config -text "" -command {} -state disabled -bd 0
			if {$tv_active} {
				bind .shrhy.10.2.0   <ButtonPress-1> {}
				bind .shrhy.10.2.1.0 <ButtonPress-1> {}
				bind .shrhy.10.2.1.1 <ButtonPress-1> {}
				bind .shrhy.10.2.1.2 <ButtonPress-1> {}
				bind .shrhy.10.2.1.3 <ButtonPress-1> {}
				bind .shrhy.10.2.1.4 <ButtonPress-1> {}
				bind .shrhy.10.2.1.5 <ButtonPress-1> {}
				bind .shrhy.10.2.1.6 <ButtonPress-1> {}
				bind .shrhy.10.2.2.0 <ButtonPress-1> {}
				bind .shrhy.10.2.2.1 <ButtonPress-1> {}
				bind .shrhy.10.2.2.2 <ButtonPress-1> {}
				bind .shrhy.10.2.2.3 <ButtonPress-1> {}
				bind .shrhy.10.2.2.4 <ButtonPress-1> {}
				bind .shrhy.10.2.2.5 <ButtonPress-1> {}
				bind .shrhy.10.2.2.6 <ButtonPress-1> {}
				bind .shrhy.10.2.3   <ButtonPress-1> {}
			}
			.shrhy.1a.tt config -text "Tempo MM "
			.shrhy.1a.et config -state normal -bd 2
			.shrhy.1a.tempohlp config -text "Use LEFT & RIGHT Arrows (With \"Control\" for Fast change)"
			if {[info exists shrhy(lasttempo)]} {	
				set shrhy(tempo) $shrhy(lasttempo)
			} else {
				set shrhy(tempo) $segment(SHRHY_DFLTTEMPO)
			}
			.shrhy.2.dupl config -text "DUPLE "
			.shrhy.2.dada   config -text "DaDa"	  -state normal
			.shrhy.2.didida	config -text "DidiDa" -state normal
			.shrhy.2.trpl config -text "TRIPLE "
			.shrhy.2.dada_	 config -text "DaDa--"	 -state normal
			.shrhy.2.dadidi_ config	-text "DaDidi--" -state normal
			.shrhy.2.didida_ config	-text "DidiDa--" -state normal
			.shrhy.2.didididi_ config	-text "Didididi--" -state normal
			.shrhy.2.quad config -text "QUAD "
			.shrhy.2.dididadada config -text "DidiDaDaDa" -state normal
			.shrhy.2.didi_dada  config -text "Didi--DaDa" -state normal
			.shrhy.2.didida_da  config -text "DidiDa--Da" -state normal
			.shrhy.2.dididada_  config -text "DidiDaDa--" -state normal
			.shrhy.2.dididida_ config	-text "Didididi----" -state normal
			.shrhy.3.off config -text "OFFSET "
			.shrhy.3.off0 config -text "0" -state normal
			.shrhy.3.off1 config -text "1" -state normal
			.shrhy.3.off2 config -text "2" -state normal
			.shrhy.3.off3 config -text "3" -state normal
			.shrhy.3.rnd config -text "RAND OMIT "
			.shrhy.3.rndhlp config -text "  Use UP & DOWN Arrows"
			.shrhy.3.ee config -state readonly -bd 2
			if {[info exists shrhy(lastrand)]} {
				set shrhy(rand) $shrhy(lastrand)
			} else {
				set shrhy(rand) 0
			}
			if {[info exists shrhy(lastoffset)]} {
				set shrhy(offset) $shrhy(lastoffset)
			} else {
				set shrhy(offset) 0
			}
			if {[info exists shrhy(lastrhythm)]} {
				set shrhy(rhythm) $shrhy(lastrhythm)
			} else {
				set shrhy(rhythm) 0
			}
			bind .shrhy <Up> {IncrShrhyRand 0}
			bind .shrhy <Down> {IncrShrhyRand 1}
			bind .shrhy <Right> {IncrShrhyTempo 0 1}
			bind .shrhy <Left> {IncrShrhyTempo 1 1}
			bind .shrhy <Control-Left> {IncrShrhyTempo 1 10}
			bind .shrhy <Control-Right> {IncrShrhyTempo 0 10}
		}
		3 {
			.shrhy.10.1.times config -text "\n\n" -command {} -state disabled -bd 0
			.shrhy.10.1.1.stop    config -text "" -command {} -state disabled -bd 0
			.shrhy.10.1.1.restart config -text "" -command {} -state disabled -bd 0
			if {$tv_active} {
				bind .shrhy.10.2.0   <ButtonPress-1> {}
				bind .shrhy.10.2.1.0 <ButtonPress-1> {}
				bind .shrhy.10.2.1.1 <ButtonPress-1> {}
				bind .shrhy.10.2.1.2 <ButtonPress-1> {}
				bind .shrhy.10.2.1.3 <ButtonPress-1> {}
				bind .shrhy.10.2.1.4 <ButtonPress-1> {}
				bind .shrhy.10.2.1.5 <ButtonPress-1> {}
				bind .shrhy.10.2.1.6 <ButtonPress-1> {}
				bind .shrhy.10.2.2.0 <ButtonPress-1> {}
				bind .shrhy.10.2.2.1 <ButtonPress-1> {}
				bind .shrhy.10.2.2.2 <ButtonPress-1> {}
				bind .shrhy.10.2.2.3 <ButtonPress-1> {}
				bind .shrhy.10.2.2.4 <ButtonPress-1> {}
				bind .shrhy.10.2.2.5 <ButtonPress-1> {}
				bind .shrhy.10.2.2.6 <ButtonPress-1> {}
				bind .shrhy.10.2.3   <ButtonPress-1> {}
			}
			.shrhy.1a.tt config -text ""
			.shrhy.1a.et config -state disabled -bd 0  -disabledbackground [option get . background {}]
			.shrhy.1a.tempohlp config -text ""
			set shrhy(tempo) ""
			.shrhy.2.dupl config -text ""
			.shrhy.2.dada config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida config -text ""	-state disabled -disabledforeground []
			.shrhy.2.trpl config -text ""
			.shrhy.2.dada_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dadidi_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didididi_ config -text ""	-state disabled -disabledforeground []
			.shrhy.2.quad config -text ""
			.shrhy.2.dididadada config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didi_dada  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.didida_da  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dididada_  config -text ""	-state disabled -disabledforeground []
			.shrhy.2.dididida_  config -text ""	-state disabled -disabledforeground []
			.shrhy.3.off config -text ""
			.shrhy.3.off0 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off1 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off2 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.off3 config -text ""  -state disabled -disabledforeground []
			.shrhy.3.rnd config -text ""
			.shrhy.3.rndhlp config -text ""
			set shrhy(offset) -1
			set shrhy(rhythm) 0
			set shrhy(rand) ""
			.shrhy.3.ee config -state disabled -bd 0 -disabledbackground [option get . background {}]
			bind .shrhy <Up> {}
			bind .shrhy <Down> {}
			bind .shrhy <Left> {}
			bind .shrhy <Right> {}
			bind .shrhy <Control-Right> {}
			bind .shrhy <Control-Left>  {}
			if {![info exists segment(intext)]} {
				Inf "NO ACCOMPANYING TEXT : CREATE THIS IN \"Segmentation Text\""
			}
			GettrofMultiInit_and_Mnemonics ENTERSCAN
		}
	}
}

proc IncrShrhyRand {down} {
	global shrhy
	if {$down} {
		if {$shrhy(rand) > 0.0} {
			set shrhy(rand) [expr $shrhy(rand) - 0.1]
			if {$shrhy(rand) < 0.0} {
				set shrhy(rand) 0.0
			}
		}
	} else {
		if {$shrhy(rand) < 0.5} {
			set shrhy(rand) [expr $shrhy(rand) + 0.1]
			if {$shrhy(rand) > 0.5} {
				set shrhy(rand) 0.5
			}
		}
	}
}

proc IncrShrhyShrink {down} {
	global shrhy
	if {$down} {
		if {[string length $shrhy(mshrink)] == 0} {
			set shrhy(mshrink) 150
		} elseif {$shrhy(mshrink) > 0} {
			incr shrhy(mshrink) -10
		}
	} else {
		if {[string length $shrhy(mshrink)] == 0} {
			set shrhy(mshrink) 150
		} elseif {$shrhy(mshrink) < 1000} {
			incr shrhy(mshrink) 10
		}
	}
}

proc IncrShrhyAccentuation {down} {
	global shrhy
	if {$down} {
		if {$shrhy(accentuation) > 1} {
			set shrhy(accentuation) [expr $shrhy(accentuation) - 0.1]
			if {[Flteq $shrhy(accentuation) 1.0]} {
				set shrhy(accentuation) 0
			}
		}
	} else {
		if {$shrhy(accentuation) <= 1} {
			set shrhy(accentuation) 1.1
		} elseif {$shrhy(accentuation) < 10} {
			set shrhy(accentuation) [expr $shrhy(accentuation) + 0.1]
			if {$shrhy(accentuation) > 10.0} {
				set shrhy(accentuation) 10
			}
		}
	}
}

proc IncrShrhyTempo {down shift} {
	global shrhy
	if {$down} {
		if {$shrhy(tempo) > 10} {
			incr shrhy(tempo) [expr -$shift]
			if {$shrhy(tempo) < 10} {
				set shrhy(tempo) 10
			}
		}
	} else {
		if {$shrhy(tempo) < 600} {
			incr shrhy(tempo) $shift
			if {$shrhy(tempo) > 600} {
				set shrhy(tempo) 600
			}
		}
	}
}

proc QuantizeShRhy {getacc} {
	global segment shrhy
	set len [llength $segment(ocl)]
	set shrhy(minstep) 10000000
	set lastocl [lindex $segment(ocl) 0]
	set n 1
	while {$n < $len} {
		set thisocl [lindex $segment(ocl) $n]
		set step [expr $thisocl - $lastocl]
		lappend steps $step
		if {$step < $shrhy(minstep)} {
			set shrhy(minstep) $step
		}
		set lastocl $thisocl
		incr n
	}
	set lastqstep 0
	catch {unset shrhy(qsteps)}
	if {$getacc} {
		catch {unset shrhy(accents)}
	}
	foreach step $steps {
		set qstep [expr int(round($step/$shrhy(minstep)))]
		lappend shrhy(qsteps) $qstep
		if {$getacc} {
			if {($qstep == 2) && ($lastqstep != 2)} {
				lappend shrhy(accents) 1
			} else {
				lappend shrhy(accents) 0
			}
			set lastqstep $qstep
		}
	}
	unset steps
	set sum 0.0
	foreach qstep $shrhy(qsteps) {
		set step [expr $qstep * $shrhy(minstep)]
		lappend nuocls $sum
		set sum [expr $sum + $step]
	}
	lappend nuocls $sum
	set segment(ocl) $nuocls
}

#--- Generate repeating-unit pattern

proc ShRhyRepeater {ocl} {
	global segment shrhy wstk
	set gotq 0
	set segment(ocl) $ocl
	QuantizeShRhy 0						;#	Generate shrhy(qsteps) but not accents
	set qmax 0
	foreach qstep $shrhy(qsteps) {		;#	Find max qstep
		if {$qstep > $qmax} {
			set qmax $qstep
		}								;#	If max q step appears in middle of entered pattern, is it a repeating pattern		
	}									;#	o	o o		o	o o			o	o o	o		o	o o	o	
	set len [llength $shrhy(qsteps)]	;#	|	|_|  -	|	|_| 		|	|_|	|	-	|	|_| |
	if {![IsEven $len]} {				;#	  2  1	 3	  2  1			  2  1 1    4     2  1 1
		set mid [expr $len/2]			;#	  |==|		  |==|			  |====|		  |====|
		if {[lindex $shrhy(qsteps) $mid] == $qmax} {
			set k 0
			set j [expr $mid + 1]
			set match 1
			while {$j < $len} {
				if {[lindex $shrhy(qsteps) $j] != [lindex $shrhy(qsteps) $k]} {
					set match 0
					break
				}
				incr j 
				incr k
			}
			if {$match} {
				set msg "DID YOU ENTER A PATTERN WHICH REPEATED ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set shrhy(qsteps) [lrange $shrhy(qsteps) 0 $mid]
					set len [llength $shrhy(qsteps)]
					set shrhy(accents) 1
					set kkk 1
					while {$kkk < $len} {
						lappend shrhy(accents) 0
						incr kkk
					}
					set gotq 1
				}
			}
		}
	}
	if {!$gotq} {
		set qbase [ShrhyFindLongestUnit]
		lappend shrhy(qsteps) $qbase	;#	Find step to next repeating-unit, and insert at end of repeater-pattern
		incr len
		set shrhy(accents) 1
		set kkk 1
		while {$kkk < $len} {
			lappend shrhy(accents) 0
			incr kkk
		}
	}
	set sum 0
	set nuocls 0.0
	set n 0
	set kk 0
	set nuqsteps {}
	set nuaccs {}
	while {$n < $segment(tuningcnt)} {
		set sum [expr $sum + ([lindex $shrhy(qsteps) $kk] * $shrhy(minstep))]
		lappend nuqsteps [lindex $shrhy(qsteps) $kk]
		lappend nuacs [lindex $shrhy(accents) $kk]
		incr kk
		if {$kk >= $len} {				;#	Cycle around repeating pattern
			set kk 0
		}
		lappend nuocls $sum
		incr n
	}
	set segment(ocl) $nuocls
	set shrhy(qsteps) $nuqsteps
	set shrhy(accents) $nuacs
}

#--- Find most common qtime unit, and assume this is the "beat"

proc ShrhyFindLongestUnit {} {
	global shrhy
	set maxqval 0
	foreach qval $shrhy(qsteps) {
		if {$qval > $maxqval} {
			set maxqval $qval
		}
	}
	return $maxqval
}

proc ReviseShRhy {} {
	global shrhy pr_revshrhy evv
	set f .revshrhy
	if [Dlg_Create $f "REVISE RHYTHM PATTERN" "set pr_revshrhy 0" -height 20 -borderwidth $evv(SBDR) -width 120] {
		frame $f.0
		button $f.0.f -text "Finished"  -command "set pr_revshrhy 1" -width 12 -bg $evv(EMPH)
		button $f.0.s -text "Do The Edit"  -command "set pr_revshrhy 3" -width 12 -bg $evv(EMPH)
		button $f.0.q -text "Abandon Edit" -command "set pr_revshrhy 0" -width 12
		pack $f.0.f $f.0.s -side left -padx 4
		pack $f.0.q -side right 
		frame $f.1
		label $f.1.ll0 -text "BEAT PATTERN"	-width 120 -fg $evv(SPECIAL)
		label $f.1.ll1 -text "\n"	-width 120
		label $f.1.ll2 -text "\n"	-width 120
		label $f.1.ll3 -text "\n"	-width 120
		label $f.1.ll4 -text "\n"	-width 120
		label $f.1.ll5 -text "\n"	-width 120
		label $f.1.ll6 -text "\n"	-width 120
		pack $f.1.ll0 $f.1.ll1 $f.1.ll2 $f.1.ll3 $f.1.ll4 $f.1.ll5 $f.1.ll6 -side top -anchor w -pady 2
		frame $f.2
		label $f.2.lla -text "Change Value From :"
		entry $f.2.from -textvariable shrhy(qfrom) -state readonly -width 4
		label $f.2.llb -text " To "
		entry $f.2.to   -textvariable shrhy(qto) -state readonly -width 4
		label $f.2.llc -text "Use Left/Right & Up/Down Arrows" -fg $evv(SPECIAL)
		radiobutton $f.2.all -text "All"  -variable shrhy(qall) -value 1 -command ShrhyRevAll
		radiobutton $f.2.one -text "Item" -variable shrhy(qall) -value 0 -command ShrhyRevAll
		entry $f.2.item -textvariable shrhy(qitem) -width 4 -state readonly
		label $f.2.llx -text "Control Up/Down Arrows" -fg $evv(SPECIAL)
		radiobutton $f.2.bak -text Baktrak -variable shrhy(dobaktrak) -value 0 -command "set pr_revshrhy 2" 
		pack $f.2.lla $f.2.from $f.2.llb $f.2.to $f.2.llc $f.2.all $f.2.one $f.2.item $f.2.llx $f.2.bak -side left
		pack $f.0 $f.1 $f.2 -fill x -expand true -pady 4
		wm resizable $f 0 0
		bind $f <Up>    {IncrQrev 0 from}
		bind $f <Down>  {IncrQrev 1 from}
		bind $f <Right> {IncrQrev 0 to}
		bind $f <Left>  {IncrQrev 1 to}
		bind $f <Control-Up>   {IncrShrhyItem 0}
		bind $f <Control-Down> {IncrShrhyItem 1}
		bind $f <Return> {set pr_revshrhy 1}
		bind $f <Escape> {set pr_revshrhy 0}
	}
	set shrhy(qall) 1
	ShrhyRevAll
	set cnt 0
	set m 1
	set display ""
	foreach qval $shrhy(qsteps) {
		append display "$qval "
		incr cnt
		if {$cnt == 40} {
			$f.1.ll$m config -text $display
			incr m
			set display ""
			set cnt 0
			if {$m > 6} {
				Inf "TOO MANY VALUES TO DISPLAY"
				set cnt 0
				break
			}
		}
	}
	if {$cnt > 0} {
		$f.1.ll$m config -text $display
	}
	set shrhy(qno) 0
	set shrhy(qfrom) 0
	set shrhy(qto) 0
	set pr_revshrhy 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_revshrhy
	while {!$finished} {
		tkwait variable pr_revshrhy
		switch -- $pr_revshrhy {
			3 {
				if {($shrhy(qfrom) == 0) || ($shrhy(qto) == 0)} {
					Inf "SET BOTH \"From\" AND \"To\" TO NON-ZERO VALUES"
					continue
				}
				set OK 0
				if {$shrhy(qall)} {
					foreach qval $shrhy(qsteps) {
						if {$qval == $shrhy(qfrom)} {
							set OK 1
							break
						}
					}
					if {!$OK} {
						Inf "THERE ARE NO \"$shrhy(qfrom)\" VALUES TO CHANGE."
						continue
					}
					set shrhy(bakval) $shrhy(qsteps)
					set len [llength $shrhy(qsteps)]
					set n 0
					while {$n < $len} {
						set qval [lindex $shrhy(qsteps) $n]
						if {$qval == $shrhy(qfrom)} {
							set shrhy(qsteps) [lreplace $shrhy(qsteps) $n $n $shrhy(qto)]
						}
						incr n
					}
				} else {
					set n [expr $shrhy(qitem) - 1]
					if {[lindex $shrhy(qsteps) $n] != $shrhy(qfrom)} {
						Inf "ENTRY $shrhy(qitem) ([lindex $shrhy(qsteps) $n]) IS NOT EQUAL TO $shrhy(qfrom)"
						continue
					} else {
						set shrhy(bakval) [list $n $shrhy(qfrom)]
						set shrhy(qsteps) [lreplace $shrhy(qsteps) $n $n $shrhy(qto)]
					}
				}
				set cnt 0
				set m 1
				set display ""
				foreach qval $shrhy(qsteps) {
					append display "$qval "
					incr cnt
					if {$cnt == 40} {
						$f.1.ll$m config -text $display
						incr m
						set display ""
						set cnt 0
						if {$m > 6} {
							set cnt 0
							break
						}
					}
				}
				if {$cnt > 0} {
					$f.1.ll$m config -text $display
				}
			}
			2 {
				if {[info exists shrhy(bakval)]} {
					if {[llength $shrhy(bakval)] == 2} {
						set shrhy(qsteps) [lreplace $shrhy(qsteps) [lindex $shrhy(bakval) 0] [lindex $shrhy(bakval) 0] [lindex $shrhy(bakval) 1]] 
					} else {
						set shrhy(qsteps) $shrhy(bakval)
					}
					set cnt 0
					set m 1
					set display ""
					foreach qval $shrhy(qsteps) {
						append display "$qval "
						incr cnt
						if {$cnt == 40} {
							$f.1.ll$m config -text $display
							incr m
							set display ""
							set cnt 0
							if {$m > 6} {
								set cnt 0
								break
							}
						}
					}
					if {$cnt > 0} {
						$f.1.ll$m config -text $display
					}
					unset shrhy(bakval)
				} else {
					Inf "VALUE NOT CHANGED
				}
				set shrhy(dobaktrak) 0
			}
			0 {
				set shrhy(qsteps) $shrhy(orig_qsteps)
				unset {shrhy(orig_qsteps)}
				set finished 1
			}
			1 {
				catch {unset shrhy(accents)}
				foreach qstep $shrhy(qsteps) {
					if {$qstep == 2} {
						lappend shrhy(accents) 1
					} else {
						lappend shrhy(accents) 0
					}
				}
				unset {shrhy(orig_qsteps)}
				.shrhy.3.restore config -text "Restore Original" -state normal
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc IncrQrev {down typ} {
	global shrhy
	if {$down} {
		if {$typ == "from"} {
			if {$shrhy(qfrom) > 1} {
				incr shrhy(qfrom) -1
			}
		} else {
			if {$shrhy(qto) > 1} {
				incr shrhy(qto) -1
			}
		}
	} else {
		if {$typ == "from"} {
			if {$shrhy(qfrom) <64} {
				incr shrhy(qfrom)
			}
		} else {
			if {$shrhy(qto) < 64} {
				incr shrhy(qto)
			}
		}
	}
}

proc ShrhyRestore {} {
	global shrhy
	if {![info exists shrhy(orig_qsteps)]} {
		Inf "NO GLOBAL EDIT DONE"
		set shrhy(restore) 0
		return
	}
	if {[AreYouSure]} {
		set shrhy(qsteps) $shrhy(orig_qsteps)
		set shrhy(restore) 0
	}
}

proc ShrhyRevAll {} {
	global shrhy
	switch -- $shrhy(qall) {
		1 {
			if {[string length $shrhy(qitem)] > 0} {
				set shrhy(qitem_bakup) $shrhy(qitem)
			}
			set shrhy(qitem) ""
			.revshrhy.2.item config -bd 0 -state disabled -disabledbackground [option get . background {}]
			.revshrhy.2.llx config -text ""
		}
		0 {
			.revshrhy.2.item config -bd 2 -state readonly
			if {[info exists shrhy(qitem_bakup)]} {
				set shrhy(qitem) $shrhy(qitem_bakup)
				ForceVal .revshrhy.2.item $shrhy(qitem)
			}
			.revshrhy.2.llx config -text "Control Up/Down Arrows"
		}
	}
}

proc IncrShrhyItem {down} {
	global shrhy
	if {[.revshrhy.2.item cget -state] == "disabled"} {
		return
	}
	if {$down} {
		if {[string length $shrhy(qitem)] <= 0} {
			set shrhy(qitem) [llength $shrhy(qsteps)]
		} elseif {$shrhy(qitem) > 1} {
			incr shrhy(qitem) -1
		}
	} else {
		if {[string length $shrhy(qitem)] <= 0} {
			set shrhy(qitem) 1
		} elseif {$shrhy(qitem) < [llength $shrhy(qsteps)]} {
			incr shrhy(qitem)
		}
	}
}

proc ShrhyDone {} {
	global shrhy
	set shrhy(done) 1
}

;#	Specify "omits" random items out of "permcnt" to omit from expanded-qset

proc ShRhyPerm {permcnt omits outpos} {
	global mix_perm
	RandomiseOrder $permcnt
	set n 0
	while {$n < $omits} {
		lappend omitlist $mix_perm($n)											;#	Outputs mix_perm
		incr n
	}
	if {$outpos == 0} {															;#	If we're at start of output
		set k [lsearch $omitlist "0"]											;#	look for the omission of the 1st step-value
		if {$k >= 0} {															;#	which is not allowed in this case.
			set omitlist [lreplace $omitlist $k $k]								;#	So remove from omit list
			lappend omitlist [lindex $mix_perm($omits)]							;#	and substitute next item in perm
		}
	}
	return $omitlist
}


#--- Shrink & Rhythmicise

proc DoShrhythm {} {
	global segment
	Block "RUNNING SHRINK RHYTHM"
	if {![CalculateShrhythmShrinkings]} {
		UnBlock
		return 0
	}
	if {![AnalExtractSegs]} {
		UnBlock
		return 0
	}
	if {![ShrhythmStretch]} {
		UnBlock
		return 0
	}
	if {[info exists segment(oldmarks)]} {
		set segment(marklist) $segment(oldmarks)
		unset segment(oldmarks)
		set segment(cnt) $segment(oldcnt)
		unset segment(oldcnt)
	}
	if {[info exists segment(oldtext)]} {
		set segment(intext) $segment(oldtext)
		unset segment(oldtext)
	}
	UnBlock
	return 1
}

proc AnalExtractSegs {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun shrhy
	set matchnam $evv(DFLT_OUTNAME)
	append matchnam "HH"
	set fils 1
	if [catch {glob $matchnam*} zit] {
		Inf "FAILED TO FIND THE FILE SEGMENTS"
		return 0
	}
	foreach zzfnam [glob $matchnam*] {
		lappend fnams $zzfnam
	}
	set fnams [SortOnFinalIntegerIndexInName [string length "$evv(DFLT_OUTNAME)HH"] $fnams]
	
	set failed_msg ""

	set cfnams $fnams
	set cnt 1
	foreach fnam $fnams cut $shrhy(cuts) {
		if {$cut > 0.0} {
			set tempfnam $evv(MACH_OUTFNAME) 
			append tempfnam "TP" $cnt $evv(SNDFILE_EXT)
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd curtail 1 $fnam $tempfnam [expr $cut - $segment(SPLICE)] $cut 0 -t0
 			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CUTTTING SEGMENT $cnt"
			if [catch {open "|$cmd"} CDPidrun] {
				append failed_msg "FAILED TO RUN CUTTTING OF SEGMENT $cnt\n"
				catch {unset CDPidrun}
				continue										;#	the orig uncut file remains in cfnams
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CUT SEGMENT $cnt"
				set msg [AddSimpleMessages $msg]
				append failed_msg "$msg\n"
				continue
			}
			if {![file exists $tempfnam]} {
				append failed_msg "NO CUT SEGMENT $cnt CREATED\n"
				continue
			}
			set rep [expr $cnt - 1]
			set cfnams [lreplace $cfnams $rep $rep $tempfnam]
		}
		incr cnt
	}
	if {[string length $failed_msg] > 0} {
		Inf $failed_msg
	}
	set fnams $cfnams

	;#	SYNTH SILENCE AND ADD TO END OF EACH SEG

	set OK 1
	while {$OK} {
		set silfnam $evv(MACH_OUTFNAME)
		append silfnam 0 $evv(SNDFILE_EXT)
		set cmd [file join $evv(CDPROGRAM_DIR) synth]
		lappend cmd silence	$silfnam $segment(srate) 1 0.02
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CREATING SILENT TAIL FOR SEGMENTS"
		if [catch {open "|$cmd"} CDPidrun] {
			append failed_msg  "FAILED TO RUN SILENT TAIL CREATION\n"
			catch {unset CDPidrun}
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SILENT TAIL FOR SEGMENTS"
			set msg [AddSimpleMessages $msg]
			append failed_msg "$msg\n"
			set OK 0
			break
		}
		if {![file exists $silfnam]} {
			append failed_msg "NO SILENT TAIL FOR SEGMENTS CREATED\n"
			set OK 0
			break
		}

	;#	ADD SILENCE  TO END OF EACH SEG

		set cnt 1
		foreach fnam $fnams {
			set outfnam $evv(MACH_OUTFNAME)
			append outfnam $cnt $evv(SNDFILE_EXT)
			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			lappend cmd join $fnam $silfnam $outfnam -w0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        ADDING SILENT TAIL TO SEGMENT $cnt"
			if [catch {open "|$cmd"} CDPidrun] {
				append failed_msg "FAILED TO RUN SILENT TAIL CREATION\n"
				catch {unset CDPidrun}
				lappend outfnams $fnam		;#	IF fails, just use unextended input
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO ADD SILENT TAIL TO SEGMENT $cnt"
				set msg [AddSimpleMessages $msg]
				lappend outfnams $fnam
				append failed_msg "$msg\n"
				continue
			}
			if {![file exists $outfnam]} {
				append failed_msg "NO SILENT TAIL FOR SEGMENT $cnt CREATED\n"
				lappend outfnams $fnam
				continue
			}
			incr cnt
			lappend outfnams $outfnam
		}
		break
	}
	if {!$OK} {								;#	Failed to produce silent file, just use un-extended inputs
		set outfnams $fnams
	}

	;#	CREATE SPECTRUM OF EACH SEGMENT

	set cnt 1
	foreach fnam $outfnams {
		set afnam [file rootname $fnam]
		append afnam $evv(ANALFILE_EXT)
		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd anal 1 $fnam $afnam -c1024 -o3
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CREATING SPECTRUM OF SEGMENT $cnt"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN SPECTRUM CREATION FOR SEGMENT $cnt"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SPECTRUM OF SEGMENT $cnt"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			return 0
		}
		if {![file exists $afnam]} {
			Inf "NO SPECTRUM OF SEGMENT $cnt CREATED"
			return 0
		}
		incr cnt
	}
	return 1
}

proc CalculateShrhythmShrinkings {} {
	global shrhy segment evv

	;#	FIND SEGMENT DURATIONS (including any endsplice)

	set lasttime [lindex $segment(marklist) 0]
	foreach time [lrange $segment(marklist) 1 end] {
		set step [expr $time - $lasttime + $segment(SPLICE)]
		lappend durs $step
		set lasttime $time
	}
	set penulttime [llength $segment(marklist)]
	incr penulttime -2
	set lastdur [expr $segment(wavdur) - [lindex $segment(marklist) $penulttime]]
	set durs [lreplace $durs end end $lastdur]

	catch {unset shrhy(stretchers)}
	set shrinkdur [expr $shrhy(mshrink) * $evv(MS_TO_SECS)] 
	set cnt 1
	catch {unset shrhy(cuts)}
	foreach dur $durs qstep $shrhy(qsteps) scan $shrhy(scansion) {
		if {$shrinkdur <= 0} {
			set outdur [expr $qstep * $shrhy(minstep)]			;#	(max) Output duration is step between rhythmicised events
		} else {
			set outdur $shrinkdur								;#	(max) Output duration is specified mS length
			if {$scan == "-"} {
				set outdur [expr $outdur * 2.0]					;#	Doubled if a sustained item		
			}
		}
		if {([string length $dur] == 0) || ($outdur >= $dur)} {	;#	If there is an isolated Head at end of listing (so last HT "dur" does not exist), OR
			set str 1											;#	If the required outduration is larger than original duration, NO timestretching	
			lappend shrhy(cuts) 0
		} else {
			set maxlen [expr $outdur * $segment(HTDIV)]
			if {$dur > $maxlen} {
				lappend shrhy(cuts) $maxlen
				set str [expr $outdur/$maxlen]
			} else {
				lappend shrhy(cuts) 0
				set str [expr $outdur/$dur]
			}
		}
		lappend shrhy(stretchers) $str
		incr cnt
	}
	return 1
}

proc ShrhythmStretch {} {
	global segment shrhy evv prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	foreach zzfnam [glob $evv(MACH_OUTFNAME)*$evv(ANALFILE_EXT)] {
		lappend fnams $zzfnam
	}
	set fnams [SortOnFinalIntegerIndexInName [string length $evv(MACH_OUTFNAME)] $fnams]
	set tempfnam $evv(DFLT_OUTNAME)
	append tempfnam 111 $evv(SNDFILE_EXT)
	set tempfnam2 $evv(DFLT_OUTNAME)
	append tempfnam2 222 $evv(SNDFILE_EXT)
	set cnt 1
	foreach fnam $fnams str $shrhy(stretchers) {

		if {[string match $str "1"]} {
			set outfnam $evv(DFLT_OUTNAME)
			append outfnam "HH" $cnt $evv(SNDFILE_EXT)			;#	reuse original source segment
		} else {
			set basofnam $evv(MACH_OUTFNAME)
			append basofnam "PH" $cnt
			set ofnam $basofnam
			append ofnam $evv(ANALFILE_EXT)
			set outfnam $basofnam
			append outfnam $evv(SNDFILE_EXT)

			;#	TIMESHRINK SPECTRUM

			set cmd [file join $evv(CDPROGRAM_DIR) stretch]
			lappend cmd time 1 $fnam $ofnam $str
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        TIMESHRINKING SEGMENT $cnt"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN TIMESHRINKING OF SEGMENT $cnt"
				catch {unset CDPidrun}
				return 0
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO TIMESHRINK SEGMENT $cnt"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				return 0
			}
			if {![file exists $ofnam]} {
				Inf "NO TIMESHRUNK SEGMENT $cnt CREATED"
				return 0
			}

			;#	GENERATE WAV FILE

			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd synth $ofnam $tempfnam
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        CREATING SOUND FROM TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN SOUND CREATION FROM TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
				catch {unset CDPidrun}
				return 0
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SOUND FROM TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				return 0
			}
			if {![file exists $tempfnam]} {
				Inf "NO SOUND CREATED FROM TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
				return 0
			}

			;#	TRIM START OF RESYNTHD FILE

			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd dovetail 1 $tempfnam $tempfnam2 0.002 0 0 0 -t0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        DOVETAILING TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN DOVETAILING OF TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
				catch {unset CDPidrun}
				return 0
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO DOVETAIL TIMESHRUNK SPECTRUM OF SEGMENT $cnt"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				return 0
			}
			if {![file exists $tempfnam2]} {
				Inf "NO DOVETAILED TIMESHRUNK SPECTRUM OF SEGMENT $cnt CREATED"
				return 0
			}

			;#	TRIM SILENCE FROM END OF WAV FILE

			set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
			lappend cmd extract 3 $tempfnam2 $outfnam -g0 -s0 -b
			set OK 1
			while {$OK} {
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        TRIMMING END OF TIMESHRUNK SEGMENT $cnt"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN END TRIMMING OF TIMESHRUNK SEGMENT $cnt"
					catch {unset CDPidrun}
					return 0
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					if [catch {file copy $tempfnam $outfnam} zit] {
						Inf "FAILED TO TRIM END OF TIMESHRUNK SEGMENT $cnt : CANNOT COPY UNTRIMMED SOUND TO OUTPUT"
						return 0
					}
					break
				}
				if {![file exists $outfnam]} {
					if [catch {file copy $tempfnam $outfnam} zit] {
						Inf "NO SOUND END-TRIMMED TIMESHRUNK SEGMENT $cnt : CANNOT COPY UNTRIMMED SOUND TO OUTPUT"
						return 0
					}
					break
				}
				break
			}
			if [catch {file delete $tempfnam} zit] {
				Inf "CANNOT DELETE INTERMEDIATE TEMPORARY FILE $tempfnam"
				return 0
			}
			if [catch {file delete $tempfnam2} zit] {
				Inf "CANNOT DELETE INTERMEDIATE TEMPORARY FILE $tempfnam2"
				return 0
			}
		}
		lappend outfnams $outfnam
		incr cnt
	}

	;#	DO ANY ACCENTUATION PATTERN

	if {$shrhy(accentuation) > 1.0} {
		set atten [expr 1.0/$shrhy(accentuation)]
		set n 1
		set OK 1
		set fail_msg ""
		while {$OK} {
			foreach fnam $outfnams {
				wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SEGMENT $n"
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				catch {unset maxsamp_line}
				set done_maxsamp 0
				lappend cmd $fnam
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR SEGMENT $n"
					set OK 0 
					break
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {![info exists maxsamp_line]} {
					Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF SEGMENT $n"
					set OK 0
					break
				}
				set prelevel($n) [lindex $maxsamp_line 0]
				if {$prelevel($n) <= 0.0} {
					Inf "SEGMENT $n IS SILENT"
					set OK 0
					break
				}
				incr n
			}
			if {!$OK} {
				break
			}
			set m 0
			set n 1
			foreach fnam $outfnams {
				set gain [expr $segment(maxlev)/$prelevel($n)]
				if {[lindex $shrhy(accents) $m] == 0} {
					set gain [expr $gain * $atten]
					wm title .blocker "PLEASE WAIT:        DE-ACCENTING SEGMENT $cnt"
				} else {
					wm title .blocker "PLEASE WAIT:        ACCENTING SEGMENT $cnt"
				}
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $fnam $segment(othersnd) $gain
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "CANNOT RUN PROCESS TO ACCENT SEGMENT $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					append fail_msg "\nFAILED TO ACCENT SEGMENT $n"
					set fail_msg [AddSimpleMessages $fail_msg]
					incr n 
					continue
				}
				if {![file exists $segment(othersnd)]} {
					append fail_msg "\nNO ACCENTED SEGMENT $n CREATED"
					incr n 
					continue
				}	
				if [catch {file delete $fnam} zit] {
					append fail_msg "\nCANNOT DELETE PRE-ACCENTED VERSION OF SEGMENT $n"
					incr n 
					continue
				}	
				if [catch {file rename $segment(othersnd) $fnam} zit] {
					Inf "CANNOT RENAME ACCENTED VERSION OF SEGMENT $n : ORIGINAL SEGMENT LOST"
					set OK 0
					break
				}
				incr m	
				incr n
			}
			if {!$OK} {
				break
			}
			break
		}
		if {[string length $fail_msg] > 0} {
			Inf $fail_msg
		}
	}

	;#	DO FINAL MIX

	set len [llength $segment(numarks)]
	incr len -2
	set times [lrange $segment(numarks) 0 $len]		;#	Drop last post-sound time from numarks

	catch {unset segment(mixlines)}
	foreach fnam $outfnams time $times {
		set line [list $fnam $time 1 1.0]
		lappend segment(mixlines) $line
	}
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY FILE $segment(mixdata) TO MIX MODIFIED SEGMENTS"
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofMixdown 1]} {
		return 0
	}
	set segment(reordered) 0
	return 1
}

proc SortOnFinalIntegerIndexInName {preindexlen fnams} {				;#	Sort filenames
	foreach fnam $fnams {
		set indx [file rootname $fnam]
		set indx [string range $indx $preindexlen end]
		lappend indxs $indx
	}
	set len [llength $fnams]
	set len_less_one [expr $len - 1]
	set n 0
	while {$n < $len_less_one} {
		set ni [lindex $indxs $n]
		set nf [lindex $fnams $n]
		set m $n
		incr m
		while {$m < $len} {
			set mi [lindex $indxs $m]
			set mf [lindex $fnams $m]
			if {$mi < $ni} {
				set indxs [lreplace $indxs $m $m $ni]
				set indxs [lreplace $indxs $n $n $mi]
				set fnams [lreplace $fnams $m $m $nf]
				set fnams [lreplace $fnams $n $n $mf]
				set ni $mi
				set nf $mf
			}
			incr m
		}
		incr n
	}
	return $fnams
}

#-- Write scansion code selected into entry-box into focused on scansion-entry-box

proc SetScanEntryInFocus {k} {
	global segment
	set ebox [focus]												;#	Find the entrybox which has focus
	set n 0
	while {$n < $segment(cnt)} {									;#	Match this with the entry-box numbering	
		if {[string match $segment(me$n) $ebox]} {
			if {$k < 0} {
				set segment(mproc$n) ""
			} else {
				append segment(mproc$n) [lindex $segment(scicons) $k]
			}
			break
		}
		incr n
	}
}

#-- Write scansion code selected into entry-box into focused on scansion-entry-box

proc SetArticEntryInFocus {k} {
	global segment
	if {$k == -1} {
		Inf "USE Control Up/Down KEYS TO ENTER NUMERIC VALUES"
		return
	}
	set ebox [focus]												;#	Find the entrybox which has focus
	set n 0
	while {$n < $segment(cnt)} {									;#	Match this with the entry-box numbering	
		if {[string match $segment(me$n) $ebox]} {
			if {$k < 0} {
				set segment(mproc$n) ""
			} else {
				append segment(mproc$n) [lindex $segment(articons) $k]
			}
			break
		}
		incr n
	}
}

#--- Generate both qset and scansion from scansion accent and rest mnemonics

proc DecodeSegmentScansion {scantxt n} {
	global shrhy
	set len [string length $scantxt]
	set k 0
	set qval 0
	while {$k < $len} {
		set val [string index $scantxt $k]
		switch -- $val {
			"_" {
				if {$qval != 0} {
					Inf "CANNOT SET MORE THAN ONE \"SHORT\" OR \"LONG\" SCANSION FOR SEGMENT [expr $n + 1] ($scantxt)" 
					return {}
				}
				set qval 2
				set scan $val
			}
			"." {
				if {$qval != 0} {
					Inf "CANNOT SET MORE THAN ONE \"SHORT\" OR \"LONG\" SCANSION FOR SEGMENT [expr $n + 1] ($scantxt)" 
					return {}
				}
				set qval 1
				set scan $val
			}
			"~" {
				if {$qval == 0} {
					Inf "NO \"SHORT\" OR \"LONG\" SCANSION SET FOR SEGMENT [expr $n + 1] ($scantxt)" 
					return {}
				}
				incr qval 2
			}
			"/" {
				if {$qval == 0} {
					Inf "NO \"SHORT\" OR \"LONG\" SCANSION SET FOR SEGMENT [expr $n + 1] ($scantxt)"
					return {}
				}
				incr qval 1
			}
		}
		incr k
	}
	return [list $qval $scan]
}

#------ Load existing scansion data

proc LoadExistingScansion {} {
	global segment evv pr_ldscan shrhy
	if [catch {glob [file join $segment(dirname) *_scan*]} zit] {
		Inf "THERE ARE NO EXISTING SCANSION FILES"
		return 0
	}
	foreach zzfnam [glob [file join $segment(dirname) *_scan*]] {
		lappend fnams $zzfnam
	}
	set fnams [lsort $fnams]

	set f .ldscan
	if [Dlg_Create $f "LOAD A SCANSION" "set pr_ldscan 0" -height 20 -borderwidth $evv(SBDR) -width 120] {
		frame $f.0
		button $f.0.s -text "Select"	 -command "set pr_ldscan 1" -width 10
		button $f.0.q -text "Abandon"	 -command "set pr_ldscan 0" -width 10
		pack $f.0.s -side left
		pack $f.0.q -side right 
		frame $f.1
		Scrolled_Listbox $f.1.ll -width 20 -height 24 -selectmode single
		pack $f.1.ll -side top -pady 2
		pack $f.0 $f.1 -side top -pady 2 -fill x -expand true -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_ldscan 1}
		bind $f <Escape> {set pr_ldscan 0}
	}
	$f.1.ll.list delete 0 end
	foreach fnam $fnams {
		$f.1.ll.list insert end [file rootname [file tail $fnam]]
	}
	set pr_ldscan 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_ldscan $f.1.ll.list
	while {!$finished} {
		tkwait variable pr_ldscan
		switch -- $pr_ldscan {
			1 {
				set i [$f.1.ll.list curselection]
				if {$i < 0} {
					Inf "NO SCANSION FILE SELECTED"
					continue
				}
				set fnam [$f.1.ll.list get $i]
				set fnam [file join $segment(dirname) $fnam$evv(TEXT_EXT)]
				catch {unset scantxt}
				if [catch {open $fnam "r"} zit] {
					Inf "CANNOT OPEN SCANSION DATA FILE $fnam"
					continue
				}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					set scantxt $line
					break
				}
				close $zit
				if {![info exists scantxt]} {
					Inf "NO DATA IN SCANSION FILE $fnam"
					continue
				}
				set scantxts [split $scantxt]
				if {[llength $scantxts] != $segment(cnt)} {
					Inf "SCANSION DOES NOT TALLY WITH SEGMENTATION OF INPUT FILE"
					continue
				}
				catch {unset qsteps}
				catch {unset scansion}
				catch {unset accents}
				set OK 1
				foreach scantxt $scantxts {
					set scantxt [string trim $scantxt]
					set len [string length $scantxt]
					set k 0
					set qval 0
					set accent 0
					while {$k < $len} {
						set val [string index $scantxt $k]
						switch -- $val {
							"_" {
								if {$qval != 0} {
									Inf "INVALID SCANSION :CANNOT SET MORE THAN ONE \"SHORT\" OR \"LONG\" SCANSION FOR SEGMENT [expr $n + 1] ($scantxt)" 
									set OK 0
									break
								}
								set qval 2
								set accent 1
								set scan $val
							}
							"." {
								if {$qval != 0} {
									Inf "INVALID SCANSION : CANNOT SET MORE THAN ONE \"SHORT\" OR \"LONG\" SCANSION FOR SEGMENT [expr $n + 1] ($scantxt)" 
									set OK 0
									break
								}
								set qval 1
								set scan $val
							}
							"~" {
								if {$qval == 0} {
									Inf "INVALID SCANSION : NO \"SHORT\" OR \"LONG\" SCANSION SET FOR SEGMENT [expr $n + 1] ($scantxt)" 
									set OK 0
									break
								}
								incr qval 2
							}
							"/" {
								if {$qval == 0} {
									Inf "INVALID SCANSION : NO \"SHORT\" OR \"LONG\" SCANSION SET FOR SEGMENT [expr $n + 1] ($scantxt)"
									set OK 0
									break
								}
								incr qval 1
							}
							default {
								Inf "INVALID CHARACTER (\"$val\") IN SCANSION FILE"
								set OK 0
								break
							}
						}
						incr k
					}
					if {!$OK} {
						break
					}
					lappend qsteps $qval
					lappend scansion $scan
					lappend accents $accent
				}
				if {!$OK} {
					continue
				}
				set finished 1
			}
			0 {
				catch {unset qsteps}
				catch {unset scansion}
				set finished 1
			}
		}
	}
	set returnval 0
	if {[info exists qsteps]} {
		set shrhy(qsteps) $qsteps
		set shrhy(scansion) $scansion
		set shrhy(accents) $accents
		set n 0
		while {$n < $segment(cnt)} {
			set segment(mproc$n) [lindex $scantxts $n]
			incr n
		}
		set returnval 1
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return $returnval
}

proc LoadScansion {} {
	if {[LoadExistingScansion]} {
		Inf "NOW SET TEMPO"
		return LOAD_TEXT_SCANSION
	}
	return LOAD_TEXT_SCANSION_FAILED
}

#########################
# SINGLE SEGMENT OUTPUT #
#########################

proc OutputChosenSeg {} {
	global pr_choseg segment chosegno choseghead evv chosegnam prg_dun prg_abortd simple_program_messages CDPidrun 

	set f .choseg
	if [Dlg_Create $f "SELECT SEGMENT TO SAVE" "set pr_choseg 0" -height 20 -borderwidth $evv(SBDR) -width 120] {
		frame $f.0
		button $f.0.s -text "Select"	 -command "set pr_choseg 1" -width 10
		button $f.0.v -text "Sound View" -command ChosegView -bg $evv(SNCOLOR)
		button $f.0.q -text "Abandon"	 -command "set pr_choseg 0" -width 10
		pack $f.0.s $f.0.v -side left -padx 4
		pack $f.0.q -side right 
		frame $f.1
		entry $f.1.e -textvariable chosegno -width 8 -state readonly
		set chosegno 1
		label $f.1.ll -text "Select Segment to Save (Up/Dn Arrows)"
		checkbutton $f.1.hh -text  "With Head" -variable choseghead -width 12
		set choseghead 0
		pack $f.1.e $f.1.ll $f.1.hh -side left
		frame $f.2
		label $f.2.ll -text "Outfile Name"
		entry $f.2.e  -textvariable chosegnam -width 24
		pack $f.2.ll $f.2.e
		pack $f.0 $f.1 $f.2 -fill x -expand true -pady 4
		wm resizable $f 0 0
		bind $f <Up>   {IncrChoseg 0}
		bind $f <Down> {IncrChoseg 1}
		bind $f <Return> {set pr_choseg 1}
		bind $f <Escape> {set pr_choseg 0}
	}
	set choseghead 0
	if {$segment(phrase) || ![IsTailProcess $segment(process)]} {
		$f.1.hh config -text  "" -state disabled -disabledforeground []
	} else {
		$f.1.hh config -text  "With Head" -state normal
	}
	set pr_choseg 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_choseg
	while {!$finished} {
		tkwait variable pr_choseg
		switch -- $pr_choseg {
			1 {
				if {[string length $chosegnam] <= 0} {
					Inf "NO FILENAME ENTERED"
					continue
				}
				set ofnam [string tolower $chosegnam]
				if {![ValidCDPRootname $chosegnam]} {
					continue
				}
				append ofnam $evv(SNDFILE_EXT)
				if {[file exists $ofnam]} {
					set msg "FILE $ofnam ALREADY EXISTS: PLEASE CHOOSE A DIFFERENT NAME"
					continue
				}
				set finished 1
			}
			0 {
				set chosegno 0
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	if {$chosegno == 0} {
		return 0
	}
	if {$segment(phrase)} {
		set outfnam $evv(MACH_OUTFNAME)PH$chosegno$evv(SNDFILE_EXT)
	} else {
		if {$segment(headfirst)} {
			if {[IsTailProcess $segment(process)]} {
				set n [expr $chosegno/2]
				set outfnam $evv(MACH_OUTFNAME)PT$n$evv(SNDFILE_EXT)
			} else {
				set n [expr $chosegno/2]
				set outfnam $evv(MACH_OUTFNAME)PH$n$evv(SNDFILE_EXT)
			}
		} else {
			if {[IsTailProcess $segment(process)]} {
				set n [expr ($chosegno + 1)/2]
				set outfnam $evv(MACH_OUTFNAME)PT$n$evv(SNDFILE_EXT)
			} else {
				set n [expr $chosegno/2]
				set outfnam $evv(MACH_OUTFNAME)PH$n$evv(SNDFILE_EXT)
			}
		}
		if {![file exists $outfnam]} {
			Inf "CANNOT FIND TARGET SEGMENT"
			return 0
		}
	}
	set blocked 0
	if {$choseghead} {
		if {![info exists segment(mixlines)]} {
			Inf "NO OUTPUT FROM PROCESS, YET"
			return 0
		}
		if {$segment(headfirst)} {
			set houtfnam $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
		} else {
			incr n -1
			set houtfnam $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
		}
		if {![file exists $houtfnam]} {
			Inf "CANNOT FIND TARGET HEAD SEGMENT"
			return 0
		}
		set stt 0
		set ismulti 0
		set firstline [lindex $segment(mixlines) $stt]
		if {[string length $firstline] < 3} {
			lappend nulines $firstline		;#	Multichan
			set ismulti 1
			incr stt
		}
		foreach line [lrange $segment(mixlines) $stt end] {
			set fnam [lindex $line 0]
			if {[string match $fnam $houtfnam]} {
				lappend nulines $line
			} elseif {[string match $fnam $outfnam]} {
				lappend nulines $line
				break
			}
		}
		set stttime [lindex [lindex $nulines $stt] 1]
		set len [llength $nulines]
		while {$stt < $len} {
			set line [lindex $nulines $stt]
			set time [lindex $line 1]
			set time [expr $time - $stttime]
			if {$time < 0.0} {
				set time 0.0
			}
			set line [lreplace $line 1 1 $time]
			set nulines [lreplace $nulines $stt $stt $line]
			incr stt
		}
		if [catch {open $segment(mixdata) "w"} zit] {
			Inf "CANNOT OPEN TEMPORARY FILE $segment(mixdata) TO MIX HEAD AND TAIL"
			return 0
		}
		foreach line $nulines {
			puts $zit $line
		}
		close $zit

		if {$ismulti} {
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $segment(mixdata) $ofnam
		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd mix $segment(mixdata) $ofnam
		}
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		Block "PLEASE WAIT:        COMBINING HEAD AND TAIL"
		set blocked 1
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN RECOMBINATION MIX"
			catch {unset CDPidrun}
			UnBlock
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO JOIN HEAD TO TAIL"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			UnBlock
			return 0
		}
		if {![file exists $ofnam]} {
			Inf "NO FILE OF RECOMBINED HEAD AND TAIL CREATED"
			UnBlock
			return 0
		}
	} else {
		if [catch {file copy $outfnam $ofnam} zit] {
			Inf "CANNOT CREATE FILE WITH NAME $ofnam"
			return 0
		}
	}
	if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
		Inf "FILE $ofnam IS ON THE WORKSPACE"
	}
	if {$blocked} {
		UnBlock
	}
	return 1
}

proc ChosegView {} {
	global segment
	set segment(exportsegs) 1
	set segment(outdisplay) 1
	DisplaySegmentation
	unset segment(outdisplay)
}

proc IncrChoseg {down} {
	global segment chosegno
	if {$down} {
		if {$chosegno > 1} {
			incr chosegno -1
		}
	} else {
		if {$chosegno < $segment(cnt)} {
			incr chosegno
		}
	}
}

#####################
#	ARTICULATION	#
#####################
#
#	^		H		L		/		\		>		<		?		!		|		'		3		m		a		x		)
#
#	Accent	Raise	Lower	Pitch	Pitch	Timestr	Shrink	Questn	Deny	Clip	Hesti	Repet	Um,Ur	Alterna Omit	Tie		
#			Pitch	Pitch	Rise	Fall	&str	&shrnk	Rise	Fall			tate	tive:							Group	
#							from	from	stepto	stepto	frm		frm		Tshrnk					Asumes	Asumes			seg with		
#							exstng	exstng	next	next	below	above	syllab			numrc	bankof	bankof			previous
#							pitch	pitch					to		to		butnot			val		such	such			before	
#															above	below	stepto			+hesits	exists	exists			applying	
#																			next											previous
#	^^		      	      	//		\\		>>		<<		??		!!				''								X		artic
#	sffz	more	more	molto	molto	molto	molto	molto	molto			longer						  (&leave	
#																													gap)
#	/\3?!m will randvary on each application
#
#	m,a	assume bank of src snds, tied to THIS voice, exist			><| are incompatible	x) have to occur alone
#

proc DecodeSegmentArticulation {artictxt n} {
	global segment
	set m $n
	incr m
	set artictxt [string trim $artictxt]
	set len [string length $artictxt]
	if {$len <= 0} {
		lappend segment(artics) "."		;#	no articulation
	}
	set lastarticmne "@"
	set k 0
	set OK 1
	while {$k < $len} {
		set mne [string index $artictxt $k]
		set found_mne $mne																	;#	Remember ENTERED mne ("mne" can be modified here)
	
		;#	LOOK FOR VALID CHARACTERS, APART FROM NUMBERS

		switch -- $mne {
			"^" -
			"H" -
			"L" -
			"U" -
			"D" -
			"?" -
			"!" -
			">" -
			"<" -
			"|" -
			"'" -
			"m" -
			"t" -
			"x" -
			"X" -
			")" {
				if {[info exists segarticmne($mne)]} {										;#	Test if we already have this mne in articstring 
					switch -- $mne {	
						"|" -
						"t" {																;#	These vals cannot be repeated
							Inf "MORE THAN ONE \"$mne\" IN ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m"
							catch {unset segartics}
							return {}
						}
						default {															;#	Others must be used contiguously
							if {$lastarticmne != $mne} {
								Inf "NON-CONTIGUOUS REPEAT OF OF MNEMONIC \"$mne\" IN ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m"
								catch {unset segartics}
								return {}
							} else {														;# Contiguous use of value
								set endval [lindex $segartics end]							;# Get previous output artic
								append endval $mne											;# Append this mne to that
								set mne $endval
								set segartics [lreplace $segartics end end]					;#	Delete the output segartics endvel
							}																;#	(It will be replace by this new concatenated mne)
						}
					}
				}
				if {($mne == "x") || ($mne == "X") || ($mne == ")")} {
					if {$len > 1} {
						Inf "MNEMONIC \"$mne\" CAN ONLY BE USED ON ITS OWN (ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m)"
						catch {unset segartics}
						return {}
					}
				}
				if {($mne == ")") && ($n == 0)} {
					Inf "TIE CANNOT BE USED AS FIRST ARTICULATION (NO PREVIOUS SEGMENT TO TIE TO)"
					catch {unset segartics}
					return {}
				}
				if {[info exists segarticmne($found_mne)]} {
					incr segarticmne($found_mne)
					switch -- $found_mne {
						"t" -
						"H" - 
						"L" - 
						"U" - 
						"D" {
							if {$segarticmne($found_mne) > 1} {
								Inf "NO MORE THAN 1 \"$found_mne\" SYMBOL CAN BE USED FOR A SINGLE SEGMENT"
								catch {unset segartics}
								return {}
							}
						}
						"m" {
							;#	UNLIMITED NUMBER OF TICS POSSIBLE
						}
						default {
							if {$segarticmne($found_mne) > 2} {
								Inf "NO MORE THAN 2 \"$found_mne\" SYMBOLS CAN BE USED FOR A SINGLE SEGMENT"
								catch {unset segartics}
								return {}
							}
						}
					}
				} else {
					set segarticmne($found_mne) 1											;#	Note that we have found this mne in the articstring
				}
				lappend segartics $mne														;#	Add valid entered mne, or concatenated enterted mne, to segartics
			}
			default {

		;#	LOOK FOR NUMERIC VAL (INTEGER >= 1)

				if {[regexp {[1-9]} $mne]} {												;#	Cannot be more than 1 numeric value in string
					if {[info exists segarticmne(numval)]} {
						Inf "MORE THAN ONE NUMERIC VALUE IN ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m"
						catch {unset segartics}
						return {}
					}
					set numval $mne															;#	Concatenate any adjacent integers to make true numeric val
					set kk $k
					incr  kk
					while {$kk < $len} {
						set vvval [string index $artictxt $kk]
						if {[regexp {[0-9]} $vvval]} {
							append numval $vvval
							incr k
						}
						incr kk
					}
					set segarticmne(numval) 1												;#	Note that a numeric value has been found
					lappend segartics $numval												;#	Add numeric val to segartics
				} else {
					Inf "INVALID CHARACTER OR SPACE ($mne) IN  ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m"
					catch {unset segartics}
					return {}
				}
			}
		}
		set lastarticmne $found_mne															;#	Remember last found character
		incr k
	}
	set strcnt 0
	if {[info exists segarticmne(>)]} { incr strcnt }
	if {[info exists segarticmne(<)]} { incr strcnt }
	if {[info exists segarticmne(|)]} { incr strcnt }
	if {$strcnt > 1} {
		Inf "MNEMONICS \">\" \"<\" AND \"|\" CANNOT BE USED TOGETHER (ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m)"
		catch {unset segartics}
		return {}
	}
	set pcnt 0
	if {[info exists segarticmne(H)]} { incr pcnt }
	if {[info exists segarticmne(L)]} { incr pcnt }
	if {[info exists segarticmne(/)]} { incr pcnt }
	if {[info exists segarticmne(\\)]} { incr pcnt }
	if {[info exists segarticmne(?)]} { incr pcnt }
	if {[info exists segarticmne(!)]} { incr pcnt }
	if {$pcnt > 1} {
		Inf "MNEMONICS \"H\", \"L\", \"\\\", \"/\", \"?\", AND \"!\" CANNOT BE USED TOGETHER (ARTICULATION STRING \"$artictxt\" FOR SEGMENT $m)"
		catch {unset segartics}
		return {}
	}
	return $segartics
}

#------ Load existing articulation data

proc LoadArticulation {} {
	global segment evv pr_ldartic wstk
	if [catch {glob [file join $segment(dirname) $segment(src,0)_artic*]} zit] {
		Inf "THERE ARE NO EXISTING ARTICULATION FILES"
		return 0
	}
	foreach zzfnam [glob [file join $segment(dirname) $segment(src,0)_artic*]] {
		lappend fnams $zzfnam
	}
	set z [string first "_artic" [lindex $fnams 0]]
	if {$z > 0} { 
		incr z 6
		set fnams [SortOnFinalIntegerIndexInName $z $fnams]
	}
	set f .ldartic
	if [Dlg_Create $f "LOAD AN ARTICULATION" "set pr_ldartic 0" -height 20 -borderwidth $evv(SBDR) -width 120] {
		frame $f.0
		button $f.0.s -text "Select"		-command "set pr_ldartic 1" -width 12
		button $f.0.p -text "Get Previous"	-command "set pr_ldartic 3" -width 12
		button $f.0.dum -text "" -command {} -bd 0 -state disabled -bg [option get . background {}] -width 12
		button $f.0.d -text "Delete"		-command "set pr_ldartic 2" -width 12
		button $f.0.q -text "Abandon"		-command "set pr_ldartic 0" -width 12
		pack $f.0.s $f.0.p $f.0.dum -side left -padx 2
		pack $f.0.q $f.0.d -side right -padx 10
		frame $f.1
		Scrolled_Listbox $f.1.ll -width 50 -height 24 -selectmode single
		pack $f.1.ll -side top -pady 2
		pack $f.0 $f.1 -side top -pady 2 -fill x -expand true -pady 4
		wm resizable $f 0 0
		bind $f <Delete> {set pr_ldartic 2}
		bind $f <Return> {set pr_ldartic 1}
		bind $f <Escape> {set pr_ldartic 0}
	}
	$f.1.ll.list delete 0 end
	set incnt 0
	foreach fnam $fnams {
		$f.1.ll.list insert end [file rootname [file tail $fnam]]
		incr incnt
	}
	set pr_ldartic 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_ldartic $f.1.ll.list
	while {!$finished} {
		tkwait variable pr_ldartic
		switch -- $pr_ldartic {
			3 -
			1 {
				if {$pr_ldartic == 3} {
					if {![info exists segment(rtc,i)]} {
						set i $incnt
						incr i -1
					} else {
						set i $segment(rtc,i)
					}
				} else {
					if {$incnt == 1} {														;#	If only 1 file in list, consider it the selected file
						set i 0
					} else {
						set i [$f.1.ll.list curselection]
						if {$i < 0} {
							Inf "NO ARTICULATION FILE SELECTED"
							continue
						}
					}
				}
				set fnam [$f.1.ll.list get $i]
				set fnam [file join $segment(dirname) $fnam$evv(TEXT_EXT)]
				catch {unset artictxts}
				if [catch {open $fnam "r"} zit] {
					Inf "CANNOT OPEN ARTICULATION DATA FILE $fnam"
					continue
				}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					lappend artictxts $line
				}
				close $zit
				if {![info exists artictxts]} {
					Inf "NO DATA IN ARTICULATION FILE $fnam"
					continue
				}
				if {[llength $artictxts] != $segment(cnt)} {
					Inf "ARTICULATIONS COUNT ([llength $artictxts]) DOES NOT TALLY WITH SEGMENT COUNT ($segment(cnt)) OF INPUT FILE"
					continue
				}
				set segment(articloaded) $artictxts
				set n 0
				while {$n  < $segment(cnt)} {
					set artictxt  [lindex $artictxts $n]
					set artictxt [split $artictxt]
					set displaytxt ""
					foreach item $artictxt {
						set item [string trim $item]
						if {[string length $item] > 0} {
							append displaytxt $item
						}
					}
					set artictxts [lreplace $artictxts $n $n $displaytxt]
					incr n
				}
				catch {unset articulation}																	;#	"articulation" is all the articulations of the input
				set OK 1
				set cnt 1
				foreach artictxt $artictxts {
					catch {unset segartics}																	;#	segartics is the articulations of this segment
					if {[info exists segarticmne]} {														;#	segarticmne remembers which mnemonics have been used in this segment-articulation
						foreach nam [array names segarticmne] {
							catch {unset segarticmne($nam)}
						}
					}
					set artictxt [string trim $artictxt]
					set lastarticmne "@"
					set len [string length $artictxt]
					set k 0
					set OK 1
					while {$k < $len} {
						set mne [string index $artictxt $k]
						set found_mne $mne																	;#	Remember ENTERED mne ("mne" can be modified here)
					
						;#	LOOK FOR VALID CHARACTERS, APART FROM NUMBERS

						switch -- $mne {
							"^" -
							"H" -
							"L" -
							"U" -
							"D" -
							"?" -
							"!" -
							">" -
							"<" -
							"|" -
							"'" -
							"m" -
							"t" -
							"x" -
							"X" -
							")" -
							"." {
								if {[info exists segarticmne($mne)]} {										;#	Test if we already have this mne in articstring 
									switch -- $mne {	
										"|" -
										"t" -
										"H" -
										"L" -
										"U" -
										"D" {																;#	These vals cannot be repeated
											Inf "MORE THAN ONE \"$mne\" IN ARTICULATION STRING \"$artictxt\" FOR SEGMENT $cnt"
											set OK 0
											break
										}
										default {															;#	Others must be used contiguously
											if {$lastarticmne != $mne} {
												Inf "NON-CONTIGUOUS REPEAT OF OF MNEMONIC \"$mne\" IN ARTICULATION STRING \"$artictxt\" FOR SEGMENT $cnt"
												set OK 0
												break
											} else {														;# Contiguous use of value
												set endval [lindex $segartics end]							;# Get previous output artic
												append endval $mne											;# Append this mne to that
												set mne $endval
												set segartics [lreplace $segartics end end]					;#	Delete the output segartics endvel
											}																;#	(It will be replace by this new concatenated mne)
										}
									}
								}
								if {($mne == "x") || ($mne == "X") || ($mne == ")") || ($mne == ".")} {
									if {$len > 1} {
										Inf "MNEMONIC \"$mne\" CAN ONLY BE USED ON ITS OWN (ARTICULATION STRING \"$artictxt\" FOR SEGMENT $cnt)"
										set OK 0
										break
									}
								}
								set segarticmne($found_mne) 1												;#	Note that we have found this mne in the articstring
								lappend segartics $mne														;#	Add valid entered mne, or concatenated enterted mne, to segartics
							}
							"{" -
							"}" {
								incr k
								continue
							}
							default {

						;#	LOOK FOR NUMERIC VAL (INTEGER >= 1)

								if {[regexp {[1-9]} $mne]} {												;#	Cannot be more than 1 numeric value in string
									if {[info exists segarticmne(numval)]} {
										Inf "MORE THAN ONE NUMERIC VALUE IN ARTICULATION STRING \"$artictxt\" FOR SEGMENT $cnt"
										set OK 0
										break
									}
									set numval $mne															;#	Concatenate any adjacent integers to make true numeric val
									set kk $k
									incr  kk
									while {$kk < $len} {
										set vvval [string index $artictxt $kk]
										if {[regexp {[0-9]} $vvval]} {
											append numval $vvval
											incr k
										}
										incr kk
									}
									set segarticmne(numval) 1												;#	Note that a numeric value has been found
									lappend segartics $numval												;#	Add numeric val to segartics
								} else {
									Inf "INVALID CHARACTER OR SPACE ($mne) IN ARTICULATION FILE $fnam"
									set OK 0
									break
								}
							}
						}
						set lastarticmne $found_mne															;#	Remember last found character
						incr k
					}
					if {!$OK} {
						break
					}
					if {$segartics == ")"} {
						if {[llength $articulations] == 0} {
							Inf "TIE (\")\") IN SEGMENT 1 DOES NOT REFERENCE ANY PREVIOUS ARTICULATION SETTING"
							set OK 0
						} else {
							set lastartic [lindex $articulations end]
							if {![regexp {[DUHL?!><)]} $lastartic]} {
								Inf "TIE (\")\") IN SEGMENT $cnt HAS NO EFFECT (PREVIOUS ARTIC IS $lastartic)"
								set OK 0
							}
						}
					}
					if {!$OK} {
						break
					}
					set outartic ""
					foreach item $segartics {
						append outartic $item
					}
					if {$outartic == "."} {
						set outartic ""
					}
					lappend articulations $outartic
					incr cnt
				}
				if {!$OK} {
					catch {unset articulations}
					unset segment(articloaded)
					set msg "INVALID ARTICULATION DATA : DELETE FILE $fnam ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if [catch {file delete $fnam} zit] {
							Inf "CANNOT DELETE ARTICULATION FILE $fnam"
						} else {
							$f.1.ll.list delete $i
						}
					}
					continue
				}
				set strcnt 0
				if {[info exists segarticmne(>)]} { incr strcnt }
				if {[info exists segarticmne(<)]} { incr strcnt }
				if {[info exists segarticmne(|)]} { incr strcnt }
				if {$strcnt > 1} {
					Inf "MNEMONICS \">\" \"<\" AND \"|\" CANNOT BE USED TOGETHER (ARTICULATION STRING \"$artictxt\" FOR SEGMENT $cnt)"
					catch {unset articulations}
					continue
				}
				set pcnt 0
				if {[info exists segarticmne(H)]} { incr pcnt }
				if {[info exists segarticmne(L)]} { incr pcnt }
				if {[info exists segarticmne(U)]} { incr pcnt }
				if {[info exists segarticmne(D)]} { incr pcnt }
				if {[info exists segarticmne(?)]} { incr pcnt }
				if {[info exists segarticmne(!)]} { incr pcnt }
				if {$pcnt > 1} {
					Inf "MNEMONICS \"H\", \"L\", \"D\", \"U\", \"?\", AND \"!\" CANNOT BE USED TOGETHER (ARTICULATION STRING \"$artictxt\" FOR SEGMENT $cnt)"
					catch {unset articulations}
					unset segment(articloaded)
					continue
				}
				set kkk 0
				foreach artic $articulations {
					set segment(mproc$kkk) $artic
					incr kkk
				}
				set segment(rtc,i) $i
				set finished 1
			}
			2 {
				if {$incnt == 1} {														;#	If only 1 file in list, consider it the selected file
					set i 0
				} else {
					set i [$f.1.ll.list curselection]
					if {$i < 0} {
						Inf "NO ARTICULATION FILE SELECTED FOR DELETION"
						continue
					}
				}
				set dddfnam [$f.1.ll.list get $i]
				set msg "ARE YOU SURE YOU WANT TO DELETE ARTICULATION DATA FILE $dddfnam ??"
				set fnam [file join $segment(dirname) $dddfnam$evv(TEXT_EXT)]
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if [catch {file delete $fnam} zit] {
					Inf "CANNOT DELETE ARTICULATION FILE $dddfnam"
				} else {
					$f.1.ll.list delete $i
				}
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Incr or decrement any numerical value in an articulation string in an mprocN box

proc ArticulationNumberIncr {n up} {
	global segment
	set len [string length $segment(mproc$n)]			;#	No entry in this box, enter a "2" (min repets)
	if {$len <= 0} {
		set segment(mproc$n) 2
		return
	}
	set strend [expr $len - 1]							;#	No numeric component in this box
	set r [IsNumberInString $segment(mproc$n) $len]
	if {[llength $r] <= 0} {
		append segment(mproc$n) 2
		return
	}
	set sstt [lindex $r 0]
	set endd [lindex $r 1]
	set prestr ""
	set poststr ""
	if {$sstt > 0} {
		set prestr [string range $segment(mproc$n) 0 [expr $sstt - 1]]
	}
	if {$endd < $strend} {
		set poststr [string range $segment(mproc$n) [expr $endd + 1] $strend]
	}
	set numval [string range $segment(mproc$n) $sstt $endd]

	if {$up} {
		if {$numval < $segment(maxrep)} {
			incr numval
		}
	} else {
		if {$numval > 2} {
			incr numval -1
		}
	}
	set val $prestr
	append val $numval $poststr
	set segment(mproc$n) $val
}

proc IsNumberInString {str len} {
	set k 0
	while {$k < $len} {
		set i [string index $str $k]
		if {[regexp {[1-9]} $i]} {
			set numvalstt $k
			set numvalend $k
			break
		}
		incr k
	}
	if {$k >= $len} {
		return {}
	}
	incr k
	while {$k < $len} {
		set i [string index $str $k]
		if {[regexp {[0-9]} $i]} {
			set numvalend $k
		} else {
			break
		}
		incr k
	}
	return [list $numvalstt $numvalend]
} 

#--- Setup preset params for Articulation

proc ArticulationStyle {} {
	global segment wstk pr_artc artc evv wstk ocl tv_active
	if {!$segment(phrase)} {
		set segment(conv) 1
		set segment(oldmarks) $segment(marklist)
		set segment(oldheadfirst) $segment(headfirst)
		set segment(oldcnt) $segment(cnt)
		if {![ConvertHTDataToPhraseData]} {
			return 0
		}
		if {!$segment(oldheadfirst)} {		;#	DON'T KEEP THE INITIAL TAIL, IF ANY
			set segment(marklist) [lreplace $segment(marklist) 0 0 [lindex $segment(oldmarks) 1]]
		}
		DeleteAllTemporaryFilesExcept $segment(nutroflist)
		if {![SegmentSound 1]} {
			return 0
		}
	}
	set segment(tuningcnt) [llength $segment(marklist)]
	incr segment(tuningcnt) -1
	set segment(cnt) $segment(tuningcnt)
	catch {unset segment(articloaded)}

	if {![GettrofMultiInit_and_Mnemonics ARTICULATION]} {
		return 0
	}
	Block "PLEASE WAIT:        GENERATING ARTICULATION PARAMETERS"
	if {![TranslateArtics]} {
		UnBlock
		return 0
	}
	UnBlock
	return 1
}

#--- Translate articulation mnemonics into array values to be used in processing

proc TranslateArtics {} {
	global segment evv wstk
	
	;#	Empty all articulation-process arrays
								
	catch {unset segment(rtc,fnams)}			;#	Names of input segments
	catch {unset segment(rtc,segdurs)}			;#	Original durations of each segment
	catch {unset segment(rtc,headdurs)}			;#	Original (or default) durations of each segment's head
	catch {unset segment(rtc,seglevs)}			;#	Original levels of each segment
	catch {unset segment(rtc,outtimes)}			;#	Original output times of each segment in output mix
	catch {unset segment(rtc,pshifts)}			;#	Pshift vals for each segment
	catch {unset segment(rtc,tstretches)}		;#	Tstretch values for each segment
	catch {unset segment(rtc,accents)}			;#	Accent markings for each segment	
	catch {unset segment(rtc,gains)}			;#	Gain values for each segment	
	catch {unset segment(rtc,cuts)}				;#	Cut lengths for repeated items
	catch {unset segment(mixlines)}				;#	Out mix

	;#	ESTABLISH DURATION OF SEGMENTS, AND STORE THEIR NAMES AND A DEFAULT CUT VALUE(0) FOR EACH

	set n 1
	while {$n <= $segment(cnt)} {
		set fnam $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
		if {![DoSegmentDurParse $fnam]} {
			Inf "FAILED TO FIND DURATION OF SEGMENT $n"
			lappend segment(rtc,segdurs) 0
		} else {
			lappend segment(rtc,segdurs) $segment(itemdur)			;#	Find durations of all segments
		}
		lappend segment(rtc,fnams) $fnam							;#	Find (initial) names of all segments
		lappend segment(rtc,cuts) 0									;#	Initialise all cuts as zero
		incr n
	}

	;#	ESTABLISH (KNOWN OR DEFAULT) DURATIONS OF SEGMENT HEADS (Used when cutting segments during "Repeat"

	set headdur_cnt 0
	if {[info exists segment(oldmarks)]} {							;#	If segments produced by fusing H+T data
		set sttseg [lindex $segment(marklist) 0]
		set k 0
		set oldlen [llength $segment(oldmarks)]
		while {$k < $oldlen} {
			set oldsegtime [lindex $segment(oldmarks) $k]
			if {[Flteq $oldsegtime $sttseg]} {
				break
			}
			incr k
		}
		if {$k < $oldlen} {											;#	If found time in origmarks corresponding to start of new marklist
			set j $k												;#	Establish duration of segment heads.
			incr j
			set lastold [expr $oldlen - 1]
			while {$j < $oldlen} {
				set headdur [expr [lindex $segment(oldmarks) $j] - [lindex $segment(oldmarks) $k]]
				if {$k > 0} {										;#	If not the first timeval	
					set headdur [expr $headdur + $segment(SPLICE)]	;#	Add start upsplice length
				}
				if {$j < $lastold} {								;#	If not the final timeval
					set headdur [expr $headdur + $segment(SPLICE)]	;#	Add end downsplice length
				}
				lappend segment(rtc,headdurs) $headdur
				incr k 2
				incr j 2											;#	Advance both H and T markers in oldmarks
				incr headdur_cnt									;#	Advance in headdurs array
				if {$headdur_cnt >= $segment(cnt)} {
					break
				}
			}
		}
	}

	;#	IF (a) no oldmarks exist (so Head durations unknown and not set)
	;#	or (b) no correspondence found between old and new mark times, so no headdurs set (should be impossible)
	;#	or (c) not enough headdurs have been set (should be impossible)
	;#	SET DEFAULT HEADDURS

	while {$headdur_cnt < $segment(cnt)} {
		set dur [lindex $segment(rtc,segdurs) $headdur_cnt]
		if {$dur <= 0.0} {										;#	If duration not known, neither is headdur
			lappend segment(rtc,headdurs) 0.0
		} elseif {$dur <= $segment(rtc,dflthdur)} {				;#	IF segment shorter than default headdur, headdur = segment dur
			lappend segment(rtc,headdurs) $dur
		} else {												;#	Else, headdur set as a default value segment(rtc,dflthdur)
			lappend segment(rtc,headdurs) $segment(rtc,dflthdur)
		}
		incr headdur_cnt
	}

	;#	ESTABLISH (INITIAL) segment(mixlines) AND segment(rtc,outtimes) : CREATE FROM segment(marklist)
	;#	THESE WILL BE MODIFIED AS WE PROCEED

	set times $segment(marklist)						;#	Get times from marklist
	set times [lreplace $times end end]					;#	Delete AFTER END time from marklist
	set len [llength $times]
	set firsttime [lindex $times 0]
	if {$firsttime > 0.0} {								;#	IF start time is not zero, shuffle timelist to start at zero				
		set n 0
		while {$n < $len} {
			set time [expr [lindex $times $n] - $firsttime]
			if {$time < 0.0} {

				set time 0.0
			}
			set times [lreplace $times $n $n $time]
			incr n
		}
	}
	set n 1
	while {$n < $len} {									;#		Allow for upsplice in output mix (except for 1st file)
		set time [expr [lindex $times $n] - $segment(SPLICE)]
		if {$time < 0.0} {
			set time 0.0
		}
		set times [lreplace $times $n $n $time]
		incr n
	}
	set segment(rtc,outtimes) $times
	foreach fnam $segment(rtc,fnams) time $segment(rtc,outtimes) {
		set line [list $fnam $time 1 1.0]
		lappend segment(mixlines) $line
	}

	;#	DEAL FIRST WITH HESITATIONS, AND DELETIONS
	;#		(1) In segment(rtc,outtimes) & segment(mixlines): modify timing &/or delete items
	;#		(2)	(for deletions only) delete items from other existing arrays, & modify count of segments

	set articno 0		;#	counts the articulations
	set segno 0			;#	counts the segments (which may get deleted)

	foreach item $segment(artics) {
		
		set len [string length $item]
		set endd [expr $len - 1]

		;#	Accents

		set vals [list "'" "x" "X"]		;#	All hesitations, omissions, or replace-by-silences
		set do_hesit 0
		set do_omit 0
		set do_silence 0
		foreach val $vals { 
			set gotentries 0
			set k [string first $val $item]
			if {$k >= 0} {
				incr gotentries
				if {$k < $endd} {
					incr k
					if {[string index $item $k] == "$val"} {
						incr gotentries
					}
				}
				switch -- $val {
					"'" { 
						set do_hesit $gotentries
					}
					"x" {
						set do_omit 1
					}
					"X" {
						set do_silence 1
					}
				}
			}
		}
		if {!($do_hesit || $do_omit || $do_silence)} {
			incr segno
		} else {
			set lastline [expr $segment(cnt) - 1]
			if {$do_silence} {																	;#	Remove line: times unchanged
				set segment(mixlines)		 [lreplace $segment(mixlines)		 $segno $segno]
				set segment(rtc,fnams)		 [lreplace $segment(rtc,fnams)		 $segno $segno]
				set segment(rtc,segdurs)	 [lreplace $segment(rtc,segdurs)	 $segno $segno]
				set segment(rtc,headdurs)	 [lreplace $segment(rtc,headdurs)	 $segno $segno]
				set segment(rtc,outtimes)	 [lreplace $segment(rtc,outtimes)	 $segno $segno]
				incr segment(cnt) -1
			} elseif {$do_omit} {
				if {$segno < $lastline} {
					set m $segno
					incr m
					set step [expr [lindex $segment(rtc,outtimes) $m] - [lindex $segment(rtc,outtimes) $segno]]
					while {$m < $segment(cnt)} {
						set time [expr [lindex $segment(rtc,outtimes) $m] - $step]				;#	Move-backwards times of all later lines
						set segment(rtc,outtimes) [lreplace $segment(rtc,outtimes) $m $m $time]
						set line [lindex $segment(mixlines) $m]
						set time [expr [lindex $line 1] - $step]
						set line [lreplace $line 1 1 $time]
						set segment(mixlines) [lreplace $segment(mixlines) $m $m $line]
						incr m
					}
				}
				set segment(mixlines)		 [lreplace $segment(mixlines)		 $segno $segno]
				set segment(rtc,fnams)		 [lreplace $segment(rtc,fnams)		 $segno $segno]			;#	Remove line from mix
				set segment(rtc,segdurs)	 [lreplace $segment(rtc,segdurs)	 $segno $segno]
				set segment(rtc,headdurs)	 [lreplace $segment(rtc,headdurs)	 $segno $segno]
				set segment(rtc,outtimes)	 [lreplace $segment(rtc,outtimes)	 $segno $segno]
				incr segment(cnt) -1
			} else {
				switch -- $do_hesit {
					1 { 
						set range [expr $segment(rtc,hestop) - $segment(rtc,hesbot)]
						set step [expr (rand() * $range) + $segment(rtc,hesbot)]
					}
					2 { 
						set range [expr $segment(rtc,heshestop) - $segment(rtc,heshesbot)]
						set step [expr (rand() * $range) + $segment(rtc,heshesbot)]
					}
				}
				if {$segno < $lastline} {
					set m $segno
					incr m
					while {$m < $segment(cnt)} {
						set time [expr [lindex $segment(rtc,outtimes) $m] + $step]				;#	Move-forward times of all later lines
						set segment(rtc,outtimes) [lreplace $segment(rtc,outtimes) $m $m $time]
						set line [lindex $segment(mixlines) $m]
						set time [expr [lindex $line 1] + $step]
						set line [lreplace $line 1 1 $time]
						set segment(mixlines) [lreplace $segment(mixlines) $m $m $line]
						incr m
					}
				}
				incr segno																			;#	No lines deleted
			}
		}
		incr articno
	}

	;#	NB	So that the artics continue to tally with the segments,
	;#	NOW DELETE ALL THE "'x" and "X" ENTRIES FROM THE ARTICS

	set len [llength $segment(artics)]
	set n 0
	while {$n < $len} {
		set mne [lindex $segment(artics) $n]
		if {($mne == "x") || ($mne == "X")} {
			set segment(artics) [lreplace $segment(artics) $n $n]
			incr len -1
		} else {
			incr n
		}
	}

	;#	DEAL WITH REPETITIONS (repeated items are CUT and PSHIFTED-slightly LATER)

	;#	(A) ASSEMBLE ANY NUMERIC VALUES IN ARTICULATION DATA

	set len [llength $segment(artics)]
	set n 0
	catch {unset repeaters}
	while {$n < $len} {
		catch {unset numval}
		set artic [lindex $segment(artics) $n]
		set slen [string length $artic]
		set k 0
		while {$k < $slen} {
			set mne [string index $artic $k]
			if {[regexp {[1-9]} $mne]} {												;#	Look for numeric value in string
				set numval $mne															;#	Concatenate any adjacent integers to make true numeric val
				set kk $k
				incr  kk
				while {$kk < $slen} {
					set mne [string index $artic $kk]
					if {[regexp {[0-9]} $mne]} {
						append numval $mne
						incr k
					}
					incr kk
				}
			}
			incr k
		}

		if {[info exists numval]} {
			set line [list $n $numval]
			lappend repeaters $line
		}
		incr n
	}	

	;#	(B) IF NUMERIC DATA EXISTS, DO FIRST STAGE OF "REPETITION", DUPLICATING DATA IN ARRAYS, AND UPDATING MNEMONICS LIST

	if {[info exists repeaters]} {
		DoRepeaterArticulations $repeaters
	}

	;#	GO THROUGH ALL MNEMONICS AND DEAL WITH CUTTING of the REPEAT SEGS
	;#
	;#		(1)	Cut the marked items, naming the outfiles systematically
	;#		(2) replace in arrays	fnams -- names of newly cut files
	;#								segdurs - durs of newly cut files
	;#								outtimes - recalcd from durs of newly cut files (shuffle up those above)
	;#								mixlines - simil
	;#		(3) RETAIN THE "C" MNEMONIC for REINTERPRETATION (for Pshifting) IN THE NEXT PASS

	set n 0
	set len [llength $segment(artics)]
	set repcnt 1
	while {$n < $len} {
		if {[lindex $segment(artics) $n] == "C"} {
			DoSegmentArticCut $n $repcnt
			incr repcnt
		} else {
			set repcnt 1
		}
		incr n
	}

	;#	NB	At this stage segment(rtc,cuts) is finished with.
	;#		so no further adjustments to array length (in DoArticTie) is necessary

#TEST USE TO TEST RESULT OF ACTION
#if [catch {open "_testmix.mix" "w"} zit] {
#Inf "CANNOT OPEN TESTING MIX FILE _testmix.mix"
#} else {
#foreach line $segment(mixlines) {
#puts $zit $line
#}
#close $zit
#Inf "NOW TEST OUTPUT MIX _testmix.mix"
#}

	;#	DEAL WITH TIES
	;#	(1) If consecutive ties, Find all ties in the group of consecutive ties	
	;#	(2) Mix previous seg and all tied segs, using data from segment(mixlines)
	;#	(3)	Calc outdur from markist & SPLICE lens and replace val in array "durs" FOR PRE-TIE segment
	;#	(3)	Delete the mixed-in (tied) lines from arrays fnams, segdurs, headdurs, outtimes, mixlines 
	;#	(4)	Delete (all) the TIE artic(s) from artics list
	;#	(4)	Replace in arrays fnams -- names of mixed file
	;#								   mixlines - simil
	;#								   (NB outtimes array should not be modified by the TIE operation)

	set n 0
	while {$n < $len} {
		if {[lindex $segment(artics) $n] == ")"} {
			set m $n
			incr m
			while {$m < $len} {
				if {[lindex $segment(artics) $m] != ")"} {
					break
				}
				incr m
			}
			incr m -1
			DoArticTie $n $m
		}
		incr n
	}

	;#	IGNORING "m" AND "t" FOR THE MOMENT
	
	;#	DEAL WITH ACCENTS, TSTRETCHES AND PSHIFTS

	set kk 0
	set mm 1
	set got_single_acc 0
	set got_double_acc 0
	set lastline [expr $segment(cnt) - 1]

	foreach item $segment(artics) {
	
		set len [string length $item]
		set endd [expr $len - 1]

		;#	Accents

		set vals [list "^" "H" "L" "U" "D" "?" "!" ">" "<" "|" "C"]		;#	All accents, pshifts and tstretches: "C" is now interpreted as a small pshift of some type
		set pchtyp ""
		set tstrtyp	""
		foreach val $vals { 
			set gotentries 0
			set k [string first $val $item]
			if {$k >= 0} {
				incr gotentries
				if {$k < $endd} {
					incr k
					if {[string index $item $k] == "$val"} {
						incr gotentries
					}
				}
			}
			switch -- $val {
				"^" { 
					switch -- $gotentries {
						0 { lappend segment(rtc,accents) 0 }
						1 { lappend segment(rtc,accents) 1; set got_single_acc 1 }
						2 { lappend segment(rtc,accents) 2; set got_double_acc 1 }
					}
				}
				"H" {
					switch -- $gotentries {
						1 { set pchtyp H }
						2 { set pchtyp HH }
					}
				}
				"L" {
					switch -- $gotentries {
						1 { set pchtyp L }
						2 { set pchtyp LL }
					}
				}
				"U"	{
					switch -- $gotentries {
						1 { set pchtyp U }
						2 { set pchtyp UU }
					}
				}
				"D" {
					switch -- $gotentries {
						1 { set pchtyp D }
						2 { set pchtyp DD }
					}
				}
				"?" {
					switch -- $gotentries {
						1 { set pchtyp "?"  }
						2 { set pchtyp "??" }
					}
				}
				"!" {
					switch -- $gotentries {
						1 { set pchtyp "!" }
						2 { set pchtyp "!!" }
					}
				}
				">" { 
					switch -- $gotentries {
						1 { set tstrtyp ">" }
						2 { set tstrtyp ">>" }
					}
				}
				"<" { 
					switch -- $gotentries {
						1 { set tstrtyp "<" }
						2 { set tstrtyp "<<" }
					}
				}
				"|" { 
					switch -- $gotentries {
						1 { set tstrtyp "|" }
					}
				}
				"C" {
					if {$gotentries} {
						set pchtyp "C"
					}
				}
			}
		}
		;#	SET TSTRETCH PARAM (in Array Array segment(rtc,tstretches))

		if {[string length $tstrtyp] > 0} {
			switch -- $tstrtyp {
				">" {																;#	Get a randomised val of tstretch
					set range [expr $segment(rtc,tstrtop) - $segment(rtc,tstrbot)]
					set val [expr (rand() * $range) + $segment(rtc,tstrbot)]
				}
				">>" {
					set range [expr $segment(rtc,tstrstrtop) - $segment(rtc,tstrstrbot)]
					set val [expr (rand() * $range) + $segment(rtc,tstrstrbot)]
				}
				"<" {
					set range [expr $segment(rtc,tshrtop) - $segment(rtc,tshrbot)]
					set val [expr (rand() * $range) + $segment(rtc,tshrtop)]
				}
				"<<" {
					set range [expr $segment(rtc,tshrshrtop) - $segment(rtc,tshrshrbot)]
					set val [expr (rand() * $range) + $segment(rtc,tshrshrbot)]
				}
				"|" {																;#	Reduce indur to randomised cliplen
					set inlen [lindex $segment(rtc,segdurs) $kk]
					if {$inlen > 0.0} {
						if {$inlen < $segment(rtc,clipbot)} {
							set val $inlen											;#	For ultra short input seg, no clipping
						} elseif {$inlen < $segment(rtc,cliptop)} {
							set val $segment(rtc,clipbot)							;#	For very short input seg, use lowest clip val
						} else {
							set range [expr $segment(rtc,cliptop) - $segment(rtc,clipbot)]
							set val [expr (rand() * $range) + $segment(rtc,clipbot)]
						}
						set val [expr $val/$inlen]
					} else {														;#	Unless we've failed to find inlen in this case	
						set val 1.0
					}
				}
			}
			lappend segment(rtc,tstretches) $val									;#	Enter value for time-stretching
		
			if {$tstrtyp != "|"} {
	
				;#	IF TIMESTRETCH OR SHRINK, SHUFFLE UP ALL MIXTIMES (EXCEPT WHERE IT'S A "CLIP")

				if {$kk < $lastline} {
					set inlen [lindex $segment(rtc,segdurs) $kk]
					set step [expr ($inlen * $val) - $inlen]					
					set jj $kk
					incr jj
					while {$jj < $segment(cnt)} {
						set outtime [expr [lindex $segment(rtc,outtimes) $jj] + $step]
						set segment(rtc,outtimes) [lreplace $segment(rtc,outtimes) $jj $jj $outtime]
						set line [lindex $segment(mixlines) $jj]
						set time [expr [lindex $line 1] + $step]
						set line [lreplace $line 1 1 $time]
						set segment(mixlines) [lreplace $segment(mixlines) $jj $jj $line]
						incr jj
					}
				}
			}
				;#	IF TIMESTRETCH OR SHRINK, REPLACE VALUE OF SEGMENT DURATION, FOR USE IN ANY PSHIFT BRKFILES

			set segdur [expr [lindex $segment(rtc,segdurs) $kk] * $val]
			set segment(rtc,segdurs) [lreplace $segment(rtc,segdurs) $kk $kk $segdur]
					

			;# HEREH MODIFY OUPUT MIXTIME IF NOT "|"
			;# MODIFY VALS IN segment(rtc,segdurs) FOR USE IN MAKING PSHIFT BRKPNTFILES
		} else {
			lappend segment(rtc,tstretches) 1												;#	OR a 1
		}

		;#	SET PSHIFT PARAM (in Array segment(rtc,tstretches))

		if {[string length $pchtyp] > 0} {
			switch -- $pchtyp {
				"H"  {
					set range [expr $segment(rtc,pshftop) - $segment(rtc,pshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]				;#	Transpos up (in rand range)
					catch {unset lines}
					set line [list 0 $val]
					lappend lines $line														;#	Make brkpoint from start (transpos) to segdur at no trans
					set val [expr (($val - 1.0)/3) + 1]										;#  X
					set ddur [lindex $segment(rtc,segdurs) $kk]								;#			
					set subdur [expr $ddur/2.0]												;#							
					set line [list $subdur $val]											;#     X
					lappend lines $line														;#	-------X      
					set line [list $ddur 1.0]
					lappend lines $line
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"L" {
					set range [expr $segment(rtc,pshftopdn) - $segment(rtc,pshfbotdn)]		;#	Transpos down (in rand range)
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]
					set subval [expr (($val - 1.0) * 0.666) + 1]
					set val [expr 1.0/$val]
					set subval [expr 1.0/$subval]
					catch {unset lines}
					set line [list 0 1]
					lappend lines $line														;#	Make brkpoint from start (1) to segdur at transpos
					set ddur [lindex $segment(rtc,segdurs) $kk]								;#	--X		
					set subdur [expr $ddur/2.0]												;#	   							
					set line [list $subdur $subval]											;#     
					lappend lines $line														;#	     X          
					set line [list $ddur $val]												;#		     X
					lappend lines $line
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"U" {
					set range [expr $segment(rtc,pshftop) - $segment(rtc,pshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]				;#	End of transpos up (in rand range)
					set subval [expr (($val - 1.0)/3) + 1]
					catch {unset lines}
					set line [list 0 1]
					lappend lines $line														;#	Make brkpint from start (no transpos) to segdur at full val
					set ddur [lindex $segment(rtc,segdurs) $kk]								;#	        X	
					set subdur [expr $ddur/2.0]												;#
					set line [list $subdur $subval]											;#
					lappend lines $line														;#        X
					set line [list $ddur $val]												;#	--X
					lappend lines $line
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"D" {
					set range [expr $segment(rtc,pshftopdn) - $segment(rtc,pshfbotdn)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]
					set subval [expr (($val - 1.0)/3) + 1]
					set val [expr 1.0/$val]
					set subval [expr 1.0/$subval]
					catch {unset lines}
					set line [list 0 1]
					lappend lines $line														;#	Make brkpoint from start (1) to segdur at transpos
					set ddur [lindex $segment(rtc,segdurs) $kk]								;#	--X		
					set subdur [expr $ddur/2.0]												;#	     X							
					set line [list $subdur $subval]											;#     
					lappend lines $line														;#	             
					set line [list $ddur $val]												;#		    X
					lappend lines $line
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"?" {
					set range [expr $segment(rtc,pshftop) - $segment(rtc,pshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]
					set val [expr 1.0/$val]													;#	Start of transpos down (in rand range)
					catch {unset lines}
					set line [list 0 $val]
					lappend lines $line														;#	Make brkpint from start (down transpos)
					set range [expr $segment(rtc,pshftop) - $segment(rtc,pshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]				;#	End of transpos up (in rand range)
					set line [list [lindex $segment(rtc,segdurs) $kk] $val]
					lappend lines $line														;#	Make brkpint end (up transpos) at segdur
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"??" {
					set range [expr $segment(rtc,pshfshftop) - $segment(rtc,pshfshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfshfbot)]
					set val [expr 1.0/$val]													;#	Start of transpos down (in rand range)
					catch {unset lines}
					set line [list 0 $val]
					lappend lines $line														;#	Make brkpint from start (transpos down)
					set range [expr $segment(rtc,pshfshftop) - $segment(rtc,pshfshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfshfbot)]				;#	End of transpos up (in rand range)
					set line [list [lindex $segment(rtc,segdurs) $kk] $val]
					lappend lines $line														;#	Make brkpint to end (transpos up) at segdur
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"!" {
					set range [expr $segment(rtc,pshftop) - $segment(rtc,pshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]				;#	Start of transpos up (in rand range)
					catch {unset lines}
					set line [list 0 $val]
					lappend lines $line														;#	Make brkpint from start (up transpos)
					set range [expr $segment(rtc,pshftop) - $segment(rtc,pshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfbot)]
					set val [expr 1.0/$val]													;#	End of transpos down (in rand range)
					set line [list [lindex $segment(rtc,segdurs) $kk] $val]
					lappend lines $line														;#	Make brkpint end (dn transpos) at segdur
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"!!" {
					set range [expr $segment(rtc,pshfshftop) - $segment(rtc,pshfshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfshfbot)]				;#	Start of transpos up (in rand range)
					catch {unset lines}
					set line [list 0 $val]
					lappend lines $line														;#	Make brkpint from start (up transpos)
					set range [expr $segment(rtc,pshfshftop) - $segment(rtc,pshfshfbot)]
					set val [expr (rand() * $range) + $segment(rtc,pshfshfbot)]
					set val [expr 1.0/$val]													;#	End of transpos down (in rand range)
					set line [list [lindex $segment(rtc,segdurs) $kk] $val]
					lappend lines $line														;#	Make brkpint end (dn transpos) at segdur
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
				"C" {																		;#	small pitch mods for repeated segs
					set t_typ [expr rand()]													;#	Rand select from rise, fall or transpos up or down
					if {$t_typ >= 0.75} {
						set t_typ "rise"
					} elseif {$t_typ >= 0.5} {
						set t_typ "up"
					} elseif {$t_typ >= 0.25} {
						set t_typ "down"
					} else {
						set t_typ "fall"
					}
					catch {unset lines}
					set range [expr $segment(rtc,pshfshfmin) - 1.0]
					set shif [expr (rand() * $range) + 1.0]											;#	Rand generate pshift val over very small range
					switch -- $t_typ {
						"up" {
							set line [list 0.0 $shif]
							lappend lines $line
							set ddur [lindex $segment(rtc,segdurs) $kk]			;# X
							set subdur [expr $ddur/2.0]							;#		
							set subval [expr (($shif - 1.0)/3.0) + 1]			;#
							set line [list $subdur $subval]						;#	 X	 
							lappend lines $line									;#-------X
							set line [list $ddur 1]
							lappend lines $line
						}
						"down" {
							set line [list 0.0 1]
							lappend lines $line
							set ddur [lindex $segment(rtc,segdurs) $kk]			;#	--X
							set subdur [expr $ddur/2.0]							;#		  
							set subval [expr (($shif - 1.0)	* 0.666) + 1]		;#
							set lo_val [expr 1.0/$shif]							;#		X
							set subval [expr 1.0/$subval]						;#			X
							set line [list $subdur $subval]						;#
							lappend lines $line
							set line [list $ddur $lo_val]
							lappend lines $line
						}
						"rise" {
							set line [list 0.0 1]
							lappend lines $line
							set ddur [lindex $segment(rtc,segdurs) $kk]			;#		  X
							set subdur [expr $ddur/2.0]							;#
							set subval [expr (($shif - 1.0)/3.0) + 1]			;#
							set line [list $subdur $subval]						;#		 X
							lappend lines $line									;#	--X
							set line [list $ddur $shif]
							lappend lines $line
						}
						"fall" {
							set line [list 0.0 1]
							lappend lines $line
							set ddur [lindex $segment(rtc,segdurs) $kk]			;#	--X	
							set subdur [expr $ddur/2.0]							;#		  X
							set subval [expr (($shif - 1.0)/3.0) + 1]			;#
							set lo_val [expr 1.0/$shif]							;#
							set subval [expr 1.0/$subval]						;#			X
							set line [list $subdur $subval]						;#
							lappend lines $line
							set line [list $ddur $lo_val]
							lappend lines $line
						}
					}
					set fnam [file rootname [lindex $segment(rtc,fnams) $kk]]				;#	Make name for brkfile
					append fnam "P" $evv(TEXT_EXT)
					if [catch {open $fnam "w"} zit] {
						Inf "CANNOT OPEN PSHIFT BRKPNTFILE FOR (REPEAT) SEGMENT $mm"
						set val 1
					} else {
						foreach line $lines {
							puts $zit $line
						}
						close $zit
						set val $fnam
					}
				}
			}
			lappend segment(rtc,pshifts) $val												;#	Enter value for pitch-shifting
		} else {
			lappend segment(rtc,pshifts) 1													;#	OR a 1
		}
		incr kk
		incr mm
	}

	;#	DEAL WITH ACCENTS USING KNOWLEDGE ABOUT ACCENTUATION OF ~ALL~ SEGMENTS (SET segment(rtc,gains) array values)

	set dolevels 0
	if {$got_single_acc || $got_double_acc} {
		set dolevels 1
		if {[GetSegmentLevelsForArtic]} {
			if {$got_single_acc} {
				if {$got_double_acc} {												;#	There are double and single accents
					set loudest 1.0													;#	e.g. acc 2 accacc3	acc2 accacc 4
					set louder  [expr double($segment(rtc,acc))/double($segment(rtc,accacc))]		;#		 2/3			2/4 = 1/2
					set quiet	[expr 1.0/$segment(rtc,accacc)]										;#		 1/3			1/4
	
					set mm 1
					foreach lev $segment(rtc,seglevs) acc $segment(rtc,accents) segdur $segment(rtc,segdurs) headdur $segment(rtc,headdurs) zzfnam $segment(rtc,fnams) {
						if {$lev > 0.0} {											;#	If we've found the original level of the segment		
							set quietgain [expr ($segment(normlev)/$lev) * $quiet] 
							switch -- $acc {
								0 {	
									lappend segment(rtc,gains) $quietgain
								}
								1 { 
									set atkgain [expr ($segment(normlev)/$lev) * $louder]
									if {$headdur < $segdur} {						;#	If segment head is smaller than segment, end attack level at head end	
																					;#	Creating a breakpoint file to do this		
										set atkfnam [CreateArticAttackFile $atkgain $quietgain $headdur $segdur $zzfnam $mm]
										if {[string length $atkfnam] > 0} {
											lappend segment(rtc,gains) $atkfnam
										} else {
											lappend segment(rtc,gains) $atkgain
										}
									} else {
										lappend segment(rtc,gains) $atkgain
									}
								}
								2 { 
									set atkgain [expr ($segment(normlev)/$lev) * $loudest]
									if {$headdur < $segdur} {
										set atkfnam [CreateArticAttackFile $atkgain $quietgain $headdur $segdur $zzfnam $mm]
										if {[string length $atkfnam] > 0} {
											lappend segment(rtc,gains) $atkfnam
										} else {
											lappend segment(rtc,gains) $atkgain
										}
									} else {
										lappend segment(rtc,gains) $atkgain
									}
								}
							}
						} else {
							lappend segment(rtc,gains) 1.0							;#	If no orig level found, do nothing, gainwise
						}
						incr mm
					}
				} else {															;#	There are single accents only
					set loudest 1.0													;#	e.g. acc2
					set quiet	[expr 1.0/$segment(rtc,acc)]						;#		 1/2
					foreach lev $segment(rtc,seglevs) acc $segment(rtc,accents) segdur $segment(rtc,segdurs) headdur $segment(rtc,headdurs) zzfnam $segment(rtc,fnams) {
						if {$lev > 0.0} {											;#	If we've found the original level of the segment
							set quietgain [expr ($segment(normlev)/$lev) * $quiet] 
							switch -- $acc {
								0 {	
									lappend segment(rtc,gains) $quietgain
								}
								1 { 
									set atkgain [expr ($segment(normlev)/$lev) * $loudest]
									if {$headdur < $segdur} {
										set atkfnam [CreateArticAttackFile $atkgain $quietgain $headdur $segdur $zzfnam $mm]
										if {[string length $atkfnam] > 0} {
											lappend segment(rtc,gains) $atkfnam
										} else {
											lappend segment(rtc,gains) $atkgain
										}
									} else {
										lappend segment(rtc,gains) $atkgain
									}
								}
							}
						} else {
							lappend segment(rtc,gains) 1.0							;#	If no orig level found, do nothing, gainwise
						}
					}
				}
			} elseif {$got_double_acc} {											;#	Double attacks only
				set loudest 1.0
				set quiet	[expr 1.0/$segment(rtc,accacc)]
				foreach lev $segment(rtc,seglevs) acc $segment(rtc,accents) segdur $segment(rtc,segdurs) headdur $segment(rtc,headdurs) zzfnam $segment(rtc,fnams) {
					if {$lev > 0.0} {
						set quietgain [expr ($segment(normlev)/$lev) * $quiet] 
						switch -- $acc {
							0 {	
								lappend segment(rtc,gains) $quietgain
							}
							2 { 
								set atkgain [expr ($segment(normlev)/$lev) * $loudest]
								if {$headdur < $segdur} {
									set atkfnam [CreateArticAttackFile $atkgain $quietgain $headdur $segdur $zzfnam $mm]
									if {[string length $atkfnam] > 0} {
										lappend segment(rtc,gains) $atkfnam
									} else {
										lappend segment(rtc,gains) $atkgain
									}
								} else {
									lappend segment(rtc,gains) $atkgain
								}
							}
						}
					} else {
						lappend segment(rtc,gains) 1.0							;#	If no orig level found, do nothing, gainwise
					}
				}
			}
		} else {									;#	Failed to get ANY of the segment loudnesses
			set dolevels 0 	
		}
	}
	if {!$dolevels} {
		foreach fnam $segment(rtc,fnams) {			;#	If Failed to get ANY of the segment loudnesses
			lappend segment(rtc,gains) 1			;#	set gain to 1.0 i.e. do nothing to loudness
		}
	}

	;#	HEREH DEAL WITH GLOSSALALIA
	;#		1)	Do they exist 
	;#		2)	If >1 select at random
	;#		3)	What about their level (depends if level change used ... see gains)
	;#		4)	Insert in output mix (+ arrays ???? or unness at this stage)

	;#	FIND TICS AND GLOSSALIA MARKERS

	set kk 0							;#	Counts original segments
	set mm 1							;#	Counts original segments (before insertions) from 1
	set segcnt 0						;#	Counts segments including insertions
	set tics_failed 0
	set glos_failed 0
	set tic_firsttime 1
	set glos_firsttime 1
	foreach item $segment(artics) {
	
		set len [string length $item]
		set endd [expr $len - 1]

		set mfound [string first "m" $item]
		set tfound [string first "t" $item]
		if {($mfound < 0) && ($tfound < 0)} {
			incr segcnt
			incr kk
			incr mm
			continue
		}
		set k 0
		while {$k < $len} {
			set mne [string index $item $k]
			switch -- $mne {
				"t" {
					if {!$tics_failed} {												;#	If finding tics not already abandoned
						set gloss [GetGlossalalia 1 $tic_firsttime]						;#	Get a tic
						if {[llength $gloss] == 3} {									;#	If find tic
							InsertGlosOrTicInArticMix $segcnt $gloss t					;#	Add it to mix
							incr segcnt													;#	(this increases the index of next segment being accessed)
						} else {														;#	If can't find tics on this pass
							set msg "CONTINUE WITHOUT TICS ???"							;#	decide whether to continue without them
							set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
							if {$choice == "no"} {
								return 0
							}
							set tics_failed 1
						}				
						set tic_firsttime 0
					}
				}
				"m" {
					if {!$glos_failed} {												;#	SIMIL
						set gloss [GetGlossalalia 0 $glos_firsttime]
						if {[llength $gloss] == 3} {
							InsertGlosOrTicInArticMix $segcnt $gloss m
							incr segcnt
						} else {
							set msg "CONTINUE WITHOUT \"UM\"S ???"
							set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
							if {$choice == "no"} {
								return 0
							}
							set glos_failed 1
						}
						set glos_firsttime 0
					}	
				}
			}
			incr k
		}
		incr segcnt
		incr kk
		incr mm
	}

#TEST
#set cccnt 0
#set msg2 "IN_ARTIC\n"
#set n 0
#while {1} {
#if {[info exists segment(mproc$n)]} {
#if {[string length $segment(mproc$n)]<=0} {
#append msg2 ". "
#} else {
#append msg2 "$segment(mproc$n) "
#}
#incr cccnt
#} else {
#break
#}
#incr n
#}
#append msg2 "length $cccnt"
#set msg "$msg2\n"
#append msg "OUT_ARTICS (length [llength $segment(artics)]) =\n$segment(artics)\n"
#foreach nam [array names segment] {
#if {[string first "rtc" $nam] == 0} {
#lappend testnams $nam
#}
#}
#set testnams [lsort $testnams]
#foreach nam $testnams {
#if {[llength $segment($nam)] > 1} { 
#append msg "segment($nam) (length [llength $segment($nam)]) =\n$segment($nam)\n"
#}
#}
#Inf $msg

	return 1
}

#--- Do the Articulation processing using pre-existing arrays

proc DoArticulation {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	INPUT NAMES ARE IN segment(rtc,fnams)

	Block "PLEASE WAIT:        ARTICULATING THE INPUT SOUND"

	set nn 0
	set mm 1

	;#	PASS 1 : GENERATE ANY REQUIRED ANALYSIS FILES AND SUBSTITUTE IN segment(rtc,fnams)

	set OK 1
	while {$OK} {
		set sfnam $segment(fadesnd)
		set cmd [file join $evv(CDPROGRAM_DIR) synth]
		lappend cmd silence $sfnam $segment(srate) 1 0.02
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        CREATING SILENT FILE"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO CREATE SILENT FILE"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO CREATE SILENT FILE"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $sfnam]} {
			Inf "NO SILENT FILE CREATED"
			set OK 0
			break
		}
		break
	}
	while {$nn < $segment(cnt)} {
		set fnam [lindex $segment(rtc,fnams) $nn]
		set tstr [lindex $segment(rtc,tstretches) $nn]
		set pshf [lindex $segment(rtc,pshifts) $nn]
		if {([IsNumeric $tstr] && ($tstr == 1.0)) && ([IsNumeric $pshf] && ($pshf == 1.0))} {
			incr nn
			incr mm					;#	No analfile required, retain source in segment(rtc,fnams)
			continue
		}	
		set OK 1
		while {$OK} {
			if {[file exists $sfnam]} {
				set ofnam [file rootname $fnam]			;#	ADD SILENCE TO END OF SEG BEFORE ANAL
				append ofnam "_X" $evv(SNDFILE_EXT)
				if {![file exists $ofnam]} {			;#	(WHERE REPETS ARE INVOLVED, THIS FILE COULD ALREADY HAVE BEEN MADE)
					while {$OK} {
						set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
						lappend cmd join $fnam $sfnam $ofnam -w0
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        ADDING SILENCE TO END OF SEGMENT $mm"
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "FAILED TO RUN PROCESS TO ADD SILENCE TO END OF SEGMENT $mm"
							catch {unset CDPidrun}
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO ADD SILENCE TO END OF SEGMENT $mm"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							set OK 0
							break
						}
						if {![file exists $ofnam]} {
							Inf "NO  SEGMENT $mm WITH ADDED SILENCE CREATED"
							set OK 0
							break
						}
						set fnam $ofnam
						break
					}
				}
				set OK 1
			}
			set ofnam [file rootname $fnam]
			append ofnam $evv(ANALFILE_EXT)
			if {![file exists $ofnam]} {
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd anal 1 $fnam $ofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING SPECTRUM OF SEGMENT $mm"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO EXTRACT SPECTRUM OF SEGMENT $mm"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE SPECTRUM OF SEGMENT $mm"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO SPECTRUM OF SEGMENT $mm CREATED"
					set OK 0
					break
				}
			}
			break
		}
		if {!$OK} {
			UnBlock
			return 0
		}
		set segment(rtc,fnams) [lreplace $segment(rtc,fnams) $nn $nn $ofnam]
		incr nn
		incr mm
	}

	;#	PASS 2 : TIMESTRETCHING

	set nn 0
	set mm 1
	while {$nn < $segment(cnt)} {
		set fnam [lindex $segment(rtc,fnams) $nn]
		set tstr [lindex $segment(rtc,tstretches) $nn]
		set ftyp [file extension $fnam]
		if {![string match $ftyp $evv(ANALFILE_EXT)] || ([IsNumeric $tstr] && ($tstr == 1.0))} {
			incr nn
			incr mm					;#	no timestretching required: retain src or its analfile in segment(rtc,fnams)
			continue
		}
		set ofnam $evv(MACH_OUTFNAME)				;#	The MACH_OUTFNAME names have not yet been used
		append ofnam "HH" $mm $evv(ANALFILE_EXT) 
		set cmd [file join $evv(CDPROGRAM_DIR) stretch]
		lappend cmd time 1 $fnam $ofnam $tstr
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        TIMESTRETCHING SEGMENT $mm"
		set OK 1
		while {$OK} {
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN TIMESTRETCHING OF SEGMENT $mm"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE TIMESTRETCHED SEGMENT $mm"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO TIMESTRETCHED SEGMENT $mm CREATED"
				set OK 0
				break
			}
			break
		}
		if {!$OK} {
			UnBlock
			return 0
		}
		set segment(rtc,fnams) [lreplace $segment(rtc,fnams) $nn $nn $ofnam]
		incr nn
		incr mm
	}


	;#	PASS 3 : PITCH-SHIFTING

	set nn 0
	set mm 1
	while {$nn < $segment(cnt)} {
		set fnam [lindex $segment(rtc,fnams) $nn]
		set pshf [lindex $segment(rtc,pshifts) $nn]
		set ftyp [file extension $fnam]
		if {![string match $ftyp $evv(ANALFILE_EXT)] || ([IsNumeric $pshf] && ($pshf == 1.0))} {
			incr nn
			incr mm					;#	no pitchshifting required: retain src or its analfile in segment(rtc,fnams)
			continue
		}
		set ofnam $evv(MACH_OUTFNAME)
		append ofnam "PH" $mm $evv(ANALFILE_EXT)		;#	The PH name_extension has not yet been used
		set cmd [file join $evv(CDPROGRAM_DIR) repitch]
		lappend cmd transpose 1 $fnam $ofnam $pshf
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        PITCHSHIFTING SEGMENT $mm"
		set OK 1
		while {$OK} {
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN PITCHSHIFTING OF SEGMENT $mm"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE PITCHSHIFTED SEGMENT $mm"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO PITCHSHIFTED SEGMENT $mm CREATED"
				set OK 0
				break
			}
			break
		}
		if {!$OK} {
			UnBlock
			return 0
		}
		set segment(rtc,fnams) [lreplace $segment(rtc,fnams) $nn $nn $ofnam]
		incr nn
		incr mm
	}

	;#	PASS 4:	RESYNTH

	set nn 0
	set mm 1
	while {$nn < $segment(cnt)} {
		set fnam [lindex $segment(rtc,fnams) $nn]
		set ftyp [file extension $fnam]
		if {![string match $ftyp $evv(ANALFILE_EXT)]} {
			incr nn
			incr mm					;#	no resynth required: retain src in segment(rtc,fnams)
			continue
		}
		set ofnam [file rootname $fnam]
		append ofnam $evv(SNDFILE_EXT)
		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd synth $fnam $ofnam
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        RESYNTHESIZING TRANSFORMED SPECTRUM OF SEGMENT $mm"
		set OK 1
		while {$OK} {
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN RESYNTHESIS OF SEGMENT $mm"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE RESYNTHESIZED SEGMENT $mm"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO RESYNTHESIZED SEGMENT $mm CREATED"
				set OK 0
				break
			}
			break
		}
		set ffnam $ofnam
		set oofnam [file rootname $ofnam]
		append oofnam "_V" $evv(SNDFILE_EXT)
		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd dovetail 1 $ffnam $oofnam 0.002 0 0 0 -t0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        DOVETAILING SEGMENT $mm"
		set OK 1
		while {$OK} {
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN DOVETAILING OF SEGMENT $mm"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE DOVETAILED SEGMENT $mm"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $oofnam]} {
				Inf "NO DOVETAILED SEGMENT $mm CREATED"
				set OK 0
				break
			}
			set ofnam $oofnam
			break
		}
		if {!$OK} {
			UnBlock
			return 0
		}
		set segment(rtc,fnams) [lreplace $segment(rtc,fnams) $nn $nn $ofnam]
		incr nn
		incr mm
	}

	;#	PASS 5:	ATTACK

	set nn 0
	set mm 1
	while {$nn < $segment(cnt)} {
		set fnam [lindex $segment(rtc,fnams) $nn]
		set gain [lindex $segment(rtc,gains) $nn]
		if {[IsNumeric $gain]} {
			incr nn
			incr mm					;#	no gain-sculpting required: gain set in mixfile-recreate pass
			continue
		}
		set ofnam [file rootname $fnam]
		append ofnam "_G" $evv(SNDFILE_EXT)
		set cmd [file join $evv(CDPROGRAM_DIR) modify]
		lappend cmd loudness 1 $fnam $ofnam $gain
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        GENERATE ATTACK ON SEGMENT $mm"
		set OK 1
		while {$OK} {
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN ATTACK GENERATION ON SEGMENT $mm"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO GENERATE ATTACK ON SEGMENT $mm"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO ATTACK GENERATED ON SEGMENT $mm"
				set OK 0
				break
			}
			break
		}
		if {$OK} {
			set segment(rtc,fnams) [lreplace $segment(rtc,fnams) $nn $nn $ofnam]
			set segment(rtc,gains) [lreplace $segment(rtc,gains) $nn $nn 1.0]		;#	No further gain adjustment required when mixfile rewritten
		} else {
			catch {unset gainvals}													;#	If attack-gain failed
			if [catch {open $gain "r"} zit] {
				Inf "CANNOT OPEN ATTACK GAIN FILE $gain FOR SEGMENT $mm"			;#	Get gain-data from attack-file
				UnBlock
				return 0
			}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					lappend gainvals $item
				}
			}
			close $zit
			if {![info exists gainvals]} {
				Inf "CANNOT GET ATTACK GAIN VALUES FILE FROM FILE $gain FOR SEGMENT $mm"
				UnBlock
				return 0
			}
			set gain [lindex $gainvals end]											;#	and use last gain value in file as the gain in mixfile-gains pass
			set segment(rtc,gains) [lreplace $segment(rtc,gains) $nn $nn $gain]		;#	Do not replace the (rtc,fnam) by the ofnam (not generated)
		}
		incr nn
		incr mm
	}

	;#	RECONSTRUCT OUTPUT MIXFILE USING ARRAY VALUES
	
	set nn 0
	while {$nn < $segment(cnt)} {
		set mixline [lindex $segment(mixlines) $nn]
		set fnam 	[lindex $segment(rtc,fnams) $nn]
		set gain	[lindex $segment(rtc,gains) $nn]
		set mixline [lreplace $mixline 0 0 $fnam]
		set mixline [lreplace $mixline 3 3 $gain]
		set segment(mixlines) [lreplace $segment(mixlines) $nn $nn $mixline]
		incr nn
	}
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY FILE $segment(mixdata) TO MIX MODIFIED SEGMENTS"
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofMixdown 1]} {
		UnBlock
		return 0
	}
	UnBlock
	set segment(reordered) 0
	return 1
}

#-- Find input levels of segments

proc GetSegmentLevelsForArtic {} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId
	set cnt 1
	set OK 1
	set fail_msg ""
	set gotlevel 0
	foreach fnam $segment(rtc,fnams) {
		wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SEGMENT $cnt"
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $fnam
		if [catch {open "|$cmd"} CDPmaxId] {
			append fail_msg "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR SEGMENT $cnt\n"
			lappend segment(rtc,seglevs) 0.0									;#	On failure, flag level-not-found with a "0.0" val
			incr cnt
			continue
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			append fail_msg "CANNOT RETRIEVE MAXIMUM SAMPLE OF SEGMENT $cnt\n"
			lappend segment(rtc,seglevs) 0.0
			incr cnt
			continue
		}
		lappend segment(rtc,seglevs) [lindex $maxsamp_line 0]
		set gotlevel 1															;#	If the level of ANY segment is found, flag as a success
		incr cnt
	}
	if {[string length $fail_msg] > 0} {
		Inf $fail_msg
	}
	return $gotlevel
}

#---- Create an attack brkpoint file

proc CreateArticAttackFile {atkgain quietgain headdur segdur fnam mm} {
	global segment evv
	set line [list 0.0 $atkgain]
	lappend lines $line
	set line [list $headdur $atkgain]
	lappend lines $line
	set endhead [expr $headdur + $segment(rtc,dflatkfall)]
	if {$endhead < $segdur} {
		set line [list $endhead $quietgain]
		lappend lines $line
	}
	set line [list $segdur $quietgain]
	lappend lines $line
	set fnam [file rootname $fnam]				;#	Make name for brkfile
	append fnam "A" $evv(TEXT_EXT)
	if [catch {open $fnam "w"} zit] {
		Inf "CANNOT OPEN ATTACK BRKPNTFILE FOR SEGMENT $mm"
		return ""
	} else {
		foreach line $lines {
			puts $zit $line
		}
		close $zit
		set val $fnam
	}
	return $val
}

###########################
# REPEAT FOR ARTICULATION #
###########################

#--- Repeat elements requested
#
#	(1)	Insert repet-1 repeated items into arrays fnams,segdurs,headdurs,outtimes,mixlines by REPEATING EXISTING ITEMS
#	(2)	Insert repet-1 artics into artic list (but shufflup $segno vals in $repeaters list) with mnemonic "C"
#	(3)	On (shuffled upwards) original item, replace mnemonic with ditto-minus-numerics. If this means there is nothing left, replace with "."
#
#	fnams,segdurs,outtimes,mixlines will be further modified when "C" (cut) is implemented on the next pass
#	repeats marked with "C" will be replaced by cut tempfiles
#	and "C" will then mean small pshifts of these cut-tempfiles when we get to the analfile sigproc stage
#

proc DoRepeaterArticulations {repeaters} {
	global segment
	set repeatercnt 0
	set rlen [llength $repeaters]

	;#	GET EACH MNEMONIC CONTAINING A REPEATER

	while {$repeatercnt < $rlen} {
		set repeater [lindex $repeaters $repeatercnt]
		set segno [lindex $repeater 0]								;#	Get associated segment number
		set repet [lindex $repeater 1]								;#	and the number of repeats required (NB "3" means 3 occurences, and therefore 2 repeats

	;#	STRIP OUT NUMERIC VALUE FROM ASSOCIATED MNEMONIC, TO MAKE NEW MNEMONIC

		set mne [lindex $segment(artics) $segno]
		set slen [string length $mne]
		set mnecnt 0
		set numne ""
		while {$mnecnt < $slen} {
			set vvval [string index $mne $mnecnt]
			if {![regexp {[0-9]} $vvval]} {
				append numne $vvval
			}
			incr mnecnt
		}
		if {[string length $numne] <= 0} {							;#	If nothing left, mark new artic as "no articulation"
			set numne "."
		}

	;#	GET EXISTING VALUES FROM ARRAYS FOR THE SEGMENT-TO-BE-REPEATED

		set fnam	[lindex $segment(rtc,fnams)	   $segno]
		set segdur	[lindex $segment(rtc,segdurs)  $segno]
		set headdur	[lindex $segment(rtc,headdurs) $segno]
		set outtime	[lindex $segment(rtc,outtimes) $segno]
		set mixline	[lindex $segment(mixlines)	   $segno]

	;#	REPEAT EXISTING VALUES IN ALL OF THESE ARRAYS
	;#	AND INSERT AN ASSOCIATED "C" MNEMONIC INTO ARTICS LIST, FOR EACH REPEATED ELEMENT

		set repadd [expr $repet - 1]								;#	How many items to add				
		set addcnt 0
		while {$addcnt < $repadd} {									;#	Repeat the element(s) inserting them in arrays
			set segment(rtc,fnams)    [linsert $segment(rtc,fnams)	  $segno $fnam]
			set segment(rtc,segdurs)  [linsert $segment(rtc,segdurs)  $segno $segdur]
			set segment(rtc,headdurs) [linsert $segment(rtc,headdurs) $segno $headdur]
			set segment(rtc,outtimes) [linsert $segment(rtc,outtimes) $segno $outtime]
			set segment(mixlines)	  [linsert $segment(mixlines)	  $segno $mixline]
			set segment(artics)		  [linsert $segment(artics)		  $segno "C"]
			incr addcnt
		}
		
	;#	NOW REPLACE THE ORIGINAL REPEATER-CONTAINING MNEMONIC WITH NEW MNEMONIC IN THE LAST OF THE REPEATED ELEMENTS,
	;#	NB if segno=2 & repets=3, we add repadd=2 newsegs, and addcnt exits loop with val repadd=2
	;#	so  segno+addcnt skips over the 2 added segs to take us to orig (now moved) seg																	

		incr segno $addcnt
		set segment(artics)	[lreplace $segment(artics) $segno $segno $numne]

	;#	FINALLY, SHUFFLE UP THE REFERENCED SEGNOS IN ANY "REPEATER" ELEMENTS THAT FOLLOW

		set endcnt $repeatercnt
		incr endcnt
		while {$endcnt < $rlen} {										;#	Finally, shuffle up the segnos in the "repeaters"
			set repeater [lindex $repeaters $endcnt]					;#	to accomodate the added segments
			set segno [lindex $repeater 0]
			incr segno $repadd
			set repeater [lreplace $repeater 0 0 $segno]
			set repeaters [lreplace $repeaters $endcnt $endcnt $repeater]
			incr endcnt
		}
		incr repeatercnt
	}

	;#	AND RESET THE TOTAL NUMBER OF SEGMENTS

	set segment(cnt) [llength $segment(mixlines)]
}

#---- If any (repeating) segment is to be cut, do the cut, and replace relevant info in arrays

proc DoSegmentArticCut {segno repcnt} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun
	set fnam	[lindex $segment(rtc,fnams)	   $segno]
	set segdur	[lindex $segment(rtc,segdurs)  $segno]
	set headdur	[lindex $segment(rtc,headdurs) $segno]
	set cutmax [expr $headdur * 2.0]
	if {$cutmax > $segdur} {
		set cutmax $segdur
	}
	set range [expr $cutmax - $headdur]
	set k [expr pow(rand(),2.0)]					;#	Random distribution skewed towards 0
	set cutlen [expr ($range * $k) + $headdur]		;#	Random sized of segment-start to use (min is headdur)
	set curtailerror [expr ($segment(rtc,ENV_FSECSIZE)/double($segment(srate))) + $evv(FLTERR)]
	set OK 1												
	if {[expr $cutlen - $headdur] <= $curtailerror} {
		set OK 0									;#	Check curtail duration not too short for the "envel curtail" CDP program
	} else {
		set ofnam [file rootname $fnam]				;#	Generate unique outfile name that's not already been used
		set k 0
		append ofnam "_C" $k $evv(SNDFILE_EXT)
		while {[file exists $ofnam]} {
			incr k
			set ofnam [file rootname $fnam]
			append ofnam "_C" $k $evv(SNDFILE_EXT)
		}
													;#	Find the number of the ORIGINAL segment being repeated
		set srcno [file rootname [file tail $fnam]]	;#	cdptestHH21
		set k [string first "HH" $srcno]			;#		   HH21
		incr k 2									;#			 21
		set srcno [string range $srcno $k end]

		;#	CUT (BY "CURTAIL") THE REPEATED SEGMENT
														
		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd curtail 1 $fnam $ofnam $headdur $cutlen 1 -t0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		while {$OK} {		
			wm title .blocker "PLEASE WAIT:        CUTTING REPETITION $repcnt OF SEGMENT $srcno TO SIZE"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN CURTAILING OF REPETITION $repcnt OF SEGMENT $srcno"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE CURTAILED REPETITION $repcnt OF SEGMENT $srcno"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO CURTAILED REPETITION $repcnt OF SEGMENT $srcno CREATED"
				set OK 0
				break
			}
			break
		}
	}
	if {!$OK} {					;#	If curtail fails, just use uncurtailed seg
		set cutlen $segdur
		set ofnam $fnam
	}

	;#	UPDATE segdurs AND fnams ARRAYS

	set segment(rtc,segdurs) [lreplace $segment(rtc,segdurs) $segno $segno $cutlen]
	set segment(rtc,fnams)   [lreplace $segment(rtc,fnams)	 $segno $segno $ofnam]

	;#	ADD HESITATION AFTER CURTAILED REPET SEG (HES RANGE IS, HERE, MAX DOWN TO ZERO)

	set hes [expr rand() * $segment(rtc,hestop)]
	set hcutlen [expr $cutlen + $hes]

	;#	UPDATE (SHUFFLUP) outtimes ARRAY AND mixlines 

	set k $segno
	incr k
	while {$k < $segment(cnt)} {
		set outtime	[expr [lindex $segment(rtc,outtimes) $k] + $hcutlen]
		set segment(rtc,outtimes) [lreplace $segment(rtc,outtimes) $k $k $outtime]
		set mixline	[lindex $segment(mixlines) $k]
		set mixtime [expr [lindex $mixline 1] + $hcutlen]
		set mixline	[lreplace $mixline 1 1 $mixtime]
		set segment(mixlines) [lreplace $segment(mixlines) $k $k $mixline]
		incr k
	}
}

#---- Tie together segments before doing articulation

	;#	(1) If consecutive ties, Find all ties in the group of consecutive ties	
	;#	(2) Mix previous seg and all tied segs, using data from segment(mixlines)
	;#	(3)	Calc outdur from markist & SPLICE lens and replace val in array "durs" FOR PRE-TIE segment
	;#	(3)	Delete the mixed-in (tied) lines from arrays fnams, segdurs, headdurs, outtimes, mixlines 
	;#	(4)	Delete (all) the TIE artic(s) from artics list
	;#	(4)	Replace in arrays fnams -- names of mixed file
	;#								   mixlines - simil
	;#								   (NB outtimes array should not be modified by the TIE operation)


proc DoArticTie {segstart segend} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	CHECK THE TIE DATA

	if {$segstart == 0} {										;#	Can't use aq tie in first artic (no previous segment to tie to)
		return													;#	Should have been trapped earlier
	}
	set preseg [expr $segstart - 1]
	set preartic [lindex $segment(artics) $preseg]
	if {$preartic == "."} {
		Inf "THE SEGMENT BEFORE THE TIE(S) AT SEGMENT $segstart HAS NO ARTICULATION : TIE HAS NO EFFECT"
		return
	}

	;#	DERIVE OUTPUT DURATION OF TIED FILE

	set starttime [lindex [lindex $segment(mixlines) $preseg] 1]
	set endtime [lindex [lindex $segment(mixlines) $segend] 1]	;#	Endtime of output file = starttime of lastfile-in-mix + its duration		
	set endtime [expr $endtime + [lindex $segment(rtc,segdurs) $segend]]
	set nusegdur [expr $endtime - $starttime]

	;#	DERIVE A MIXFILE FOR THE TIED SEGMENTS FROM THE MAIN MIXFILE

	set numix [lrange $segment(mixlines) $preseg $segend]
	set firstfileinmix [lindex [lindex $numix 0] 0]
	if {$starttime > 0.0} {
		set k 0
		set len [llength $numix]
		while {$k < $len} {
			set mixline [lindex $numix $k]
			set mixtime [expr [lindex $mixline 1] - $starttime]
			if {$mixtime < 0.0} {
				set mixtime 0.0
			}
			set mixline [lreplace $mixline 1 1 $mixtime]
			set numix [lreplace $numix $k $k $mixline]
			incr k
		}
	}
	set mfnam [file rootname $firstfileinmix]
	append mfnam [GetTextfileExtension mix]
	if [catch {open $mfnam "w"} zit] {
		Inf "CANNOT OPEN SUBMIX FILE TO MIX TIED SEGMENTS AT SEGMENT $segstart"
		return
	}
	foreach line $numix {
		puts $zit $line
	}
	close $zit

	;#	RUN THE MIX OF THE TIED SEGMENTS

	set ofnam [file rootname $firstfileinmix]
	append ofnam "_T" $evv(SNDFILE_EXT)

	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	lappend cmd mix $mfnam $ofnam
	set prg_dun 0
	set prg_abortd 0
	set OK 1
	while {$OK} {
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        COMBINING SEGMENTS FOR TIE(S) AFTER SEGMENT $segstart"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN MIX TO COMBINE SEGMENTS FOR TIE(S) AT SEGMENT $segstart"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "FAILED TO COMBINE SEGMENTS FOR TIE(S) AT SEGMENT $segstart"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			break
		}
		if {![file exists $ofnam]} {
			Inf "COMBINED SEGMENTS, FOR TIE(S) AT SEGMENT $segstart, NOT CREATED"
			set OK 0
			break
		}
		break
	}
	if {!$OK} {										;#	Submix failed : Abandon the tie, but continue processing source
		return 1
	}

	;#	REPLACE FIRST OF PRE-TIED FILES (AND ITS DURATION) WITH TIED FILE
	
	set mixline [lindex $segment(mixlines) $preseg]
	set mixline [lreplace $mixline 0 0 $ofnam]
	set segment(mixlines) [lreplace $segment(mixlines) $preseg $preseg $mixline]
	set segment(rtc,fnams)   [lreplace $segment(rtc,fnams) $preseg $preseg $ofnam]
	set segment(rtc,segdurs) [lreplace $segment(rtc,segdurs) $preseg $preseg $nusegdur]
	
	;#	NOW DELETE THE OTHER FILES IN THE TIE FROM THE mixlines AND outtimes ARRAYS, AND THE ASSOCIATED "TIE" MNEMONICS
	
	set files_to_remove [expr $segend - $preseg]
	set n 0
	while {$n < $files_to_remove} {
		set segment(mixlines)	  [lreplace $segment(mixlines)	   $segstart $segstart]		;#	Later mixlines not modified
		set segment(rtc,outtimes) [lreplace $segment(rtc,outtimes) $segstart $segstart]		;#	Later outtimes not modified
		set segment(rtc,fnams)	  [lreplace $segment(rtc,fnams)	   $segstart $segstart]		;#	etc.
		set segment(rtc,segdurs)  [lreplace $segment(rtc,segdurs)  $segstart $segstart]
		set segment(rtc,headdurs) [lreplace $segment(rtc,headdurs) $segstart $segstart]
		set segment(artics)		  [lreplace $segment(artics)	   $segstart $segstart]
				;# THESE ARRAYS NOT YET ESTABLISHED
				;# seglevs, pshifts, tstretches, accents, gains
		incr n
	}

	;#	NB THE TIED OUTPUT AUTOMATICALLY GETS THE ARTICS OF THE FIRST FILE IN THE TIE

	set segment(cnt) [llength $segment(mixlines)]
}

################################
# GLOSSOLALIA FOR ARTICULATION #
################################

proc GetGlossalalia {tic firsttime} {
	global segment wstk
	set otherdir 0
	if {$tic} {
		set nam tic
		set nams tics
		set namdurs ticdurs
		set namlevs ticlevs
	} else {
		set nam um
		set nams ums
		set namdurs umdurs
		set namlevs umlevs
	}
	if {$firsttime} {
		if {![info exists segment($nams)]} {
			set msg "NO [string toupper $nams] KNOWN SO FAR : SPECIFY A DIRECTORY TO FIND [string toupper $nam] FILES ??"
			set choice [tk_messageBox -type yesno -icon warning -default yes -parent [lindex $wstk end] -message $msg]
		} else {
			set msg "SPECIFY DIFFERENT SOURCE DIRECTORY FOR [string toupper $nam] FILES ??"
			set choice [tk_messageBox -type yesno -icon warning -default no -parent [lindex $wstk end] -message $msg]
			set otherdir 1
		}
		if {$choice == "no"} {
			if {!$otherdir} {
				return {}				;#	No tics (or ums) exist already, and decide not to look for them, return fail
			}							;#	Else, sticking to the existing tics(ums) carry on
		} else {						
			SpecifyGlossolaliaDirectory $nam	;#	If looking for some, or different tics(ums) search for them in some directory
		}
		if {![info exists segment($nams)] || ([llength $segment($nams)] <= 0)} {
			return {}
		}
	}
	set len [llength $segment($nams)]
	set num [expr int(floor(rand() * $len))]
	set fnam [lindex $segment($nams) $num]
	set dur  [lindex $segment(rtc,$namdurs) $num]
	set lev  [lindex $segment(rtc,$namlevs) $num]
	return [list $fnam $dur $lev]
}

#---	Specify (and remember) directory for tics and ums

proc SpecifyGlossolaliaDirectory {tic} {
	global evv pr_lticum ticumdir segment maxsamp_line done_maxsamp CDPmaxId
	if {[string match $tic "tic"]} {
		set tic 1
	} else {
		set tic 0
	}
	set f .lticum
	if [Dlg_Create $f "DIRECTORY FOR TICS" "set pr_lticum 0" -height 20 -borderwidth $evv(SBDR) -width 120] {
		frame $f.0
		button $f.0.s -text "Select"	 -command "set pr_lticum 1" -width 10
		button $f.0.d -text "Find Directories"	 -command "set pr_lticum 2" -width 16
		button $f.0.q -text "Abandon"	 -command "set pr_lticum 0" -width 10
		pack $f.0.s $f.0.d -side left -padx 20
		pack $f.0.q -side right -padx 4
		frame $f.1
		label $f.1.ll -text "Directory for tics" -width 20
		entry $f.1.e -textvariable ticumdir -width 60
		pack $f.1.ll $f.1.e -side left
		pack $f.0 $f.1 -side top -pady 2 -fill x -expand true -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_lticum 1}
		bind $f <Escape> {set pr_lticum 0}
	}
	if {$tic} {
		wm title .lticum "DIRECTORY FOR TICS"
		$f.1.ll config -text "Directory for tics" 
		if {[info exists segments(rtc,ticdir)]} {
			set ticumdir $segments(rtc,ticdir)
		}
	} else {
		wm title .lticum "DIRECTORY FOR \"UM\"S"
		$f.1.ll config -text "Directory for \"um\"s" 
		if {[info exists segments(rtc,umdir)]} {
			set ticumdir $segments(rtc,umdir)
		}
	}
	set pr_lticum 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_lticum $f.1.ll
	while {!$finished} {
		tkwait variable pr_lticum
		switch -- $pr_lticum {
			1 {
				if {[string length $ticumdir] <= 0} {
					Inf "NO DIRECTORY NAME ENTERED"
					continue
				}
				if {![file exists $ticumdir] || ![file isdirectory $ticumdir]} {
					Inf "DIRECTORY $ticumdir DOES NOT EXIST"
					continue
				}
				if {$tic} {
					if [catch {glob [file join $ticumdir *_tic*]} zit] {
						Inf "THERE ARE NO TIC FILES IN THIS DIRECTORY"
						continue
					}
					set segment(ticdir) $ticumdir
					catch {unset segment(tics)}
					foreach zzfnam [glob [file join $ticumdir *_tic*]] {
						lappend segment(tics) $zzfnam
					}
					set len [llength $segment(tics)]
					set kk 0				;#	counts final number of tics
					set mm 1				;#	numbers original tics, before testing

					wm title .blocker "PLEASE WAIT:        FINDING DURATIONS AND LEVEL OF TICS"

					while {$kk < $len} {

						;#	FIND DURATION -> $segment(itemdur)

						set zzfnam [lindex $segment(tics) $kk]
						if {![DoSegmentDurParse $zzfnam]} {
							append fail_msg "FAILED TO FIND DURATION OF TIC $mm\n"
							set segment(tics) [lreplace $segment(tics) $kk $kk]
							incr len -1
							incr mm
							continue
						}

						;#	FIND LEVEL

						set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
						catch {unset maxsamp_line}
						set done_maxsamp 0
						lappend cmd $zzfnam
						if [catch {open "|$cmd"} CDPmaxId] {
							append fail_msg "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR TIC $mm\n"
							set segment(tics) [lreplace $segment(tics) $kk $kk]
							incr len -1
							incr mm
							continue
	   					} else {
	   						fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
						}
	 					vwait done_maxsamp
						if {![info exists maxsamp_line]} {
							append fail_msg "CANNOT RETRIEVE MAXIMUM SAMPLE OF TIC $mm\n"
							set segment(tics) [lreplace $segment(tics) $kk $kk]
							incr len -1
							incr mm
							continue
						}
						if {[lindex $maxsamp_line 0] <= 0.0} {
							append fail_msg "TIC $mm HAS ZERO LEVEL\n"
							set segment(tics) [lreplace $segment(tics) $kk $kk]
							incr len -1
							incr mm
							continue
						}
						lappend segment(rtc,ticlevs) [lindex $maxsamp_line 0]
						lappend segment(rtc,ticdurs) $segment(itemdur)
						incr kk
						incr mm
					}
					if {$len == 0} {
						Inf "THERE ARE NO VIABLE TICS IN THIS DIRECTORY"
						continue
					}
				} else {
					if [catch {glob [file join $ticumdir *_um*]} zit] {
						Inf "THERE ARE NO \"UM\" FILES IN THIS DIRECTORY"
						continue
					}
					set segment(umdir) $ticumdir
					catch {unset segment(ums)}
					foreach zzfnam [glob [file join $ticumdir *_um*]] {
						lappend segment(ums) $zzfnam
					}
					set len [llength $segment(ums)]
					set kk 0				;#	counts final number of ums
					set mm 1				;#	numbers original ums, before testing

					wm title .blocker "PLEASE WAIT:        FINDING DURATIONS AND LEVEL OF GLOSSOLALIA"

					while {$kk < $len} {

						;#	FIND DURATION -> $segment(itemdur)

						set zzfnam [lindex $segment(ums) $kk]
						if {![DoSegmentDurParse $zzfnam]} {
							append fail_msg "FAILED TO FIND DURATION OF TIC $mm\n"
							set segment(ums) [lreplace $segment(ums) $kk $kk]
							incr len -1
							incr mm
							continue
						}

						;#	FIND LEVEL

						set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
						catch {unset maxsamp_line}
						set done_maxsamp 0
						lappend cmd $zzfnam
						if [catch {open "|$cmd"} CDPmaxId] {
							append fail_msg "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR TIC $mm\n"
							set segment(ums) [lreplace $segment(ums) $kk $kk]
							incr len -1
							incr mm
							continue
	   					} else {
	   						fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
						}
	 					vwait done_maxsamp
						if {![info exists maxsamp_line]} {
							append fail_msg "CANNOT RETRIEVE MAXIMUM SAMPLE OF TIC $mm\n"
							set segment(tics) [lreplace $segment(ums) $kk $kk]
							incr len -1
							incr mm
							continue
						}
						if {[lindex $maxsamp_line 0] <= 0.0} {
							append fail_msg "TIC $mm HAS ZERO LEVEL\n"
							set segment(tics) [lreplace $segment(ums) $kk $kk]
							incr len -1
							incr mm
							continue
						}
						lappend segment(rtc,umlevs) [lindex $maxsamp_line 0]
						lappend segment(rtc,umdurs) $segment(itemdur)
						incr kk
						incr mm
					}
					if {$len == 0} {
						Inf "THERE ARE NO VIABLE GLOSOLALIA IN THIS DIRECTORY"
						continue
					}
				}
				set finished 1
			}
			2 {
				DoListingOfDirectories .lticum.1.e
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--	Save most recent directories used to do segmentation (and to find tics and ums if any)

proc SaveSegmentationDirs {} {
	global segment evv
	set dosave 0
	if {![info exists segment(rfnam)]} {
		return
	}
	if {[info exists segment(lastdirload)]} {
		set n 0
		while {$n < 9} {
			set item [lindex $segment(lastdirload) $n]
			switch -- $n {
				0 {
					if {![string match $item $segment(rfnam)]} {
						set dosave 1
						break
					}
				}
				1 {
					if {$item == "0"} {
						if {[info exists segment(ticdir)]} {
							set dosave 1
							break
						}
					} else {
						if {![info exists segment(ticdir)]} {
							set dosave 1
							break
						} elseif {![string match $item $segment(ticdir)]} {
							set dosave 1
							break
						}
					}
				}
				2 {
					if {$item == "0"} {
						if {[info exists segment(umdir)]} {
							set dosave 1
							break
						}
					} else {
						if {![info exists segment(umdir)]} {
							set dosave 1
							break
						} elseif {![string match $item $segment(umdir)]} {
							set dosave 1
							break
						}
					}
				}
				3 {
					if {$item == "0"} {
						if {[info exists segment(rtc,ticlevs)]} {
							set dosave 1
							break
						}
					} else {
						if {![info exists segment(rtc,ticlevs)]} {
							set dosave 1
							break
						} elseif {![string match $item $segment(rtc,ticlevs)]} {
							set dosave 1
							break
						}
					}
				}
				4 {
					if {$item == "0"} {
						if {[info exists segment(rtc,ticdurs)]} {
							set dosave 1
							break
						}
					} else {
						if {![info exists segment(rtc,ticdurs)]} {
							set dosave 1
							break
						} elseif {![string match $item $segment(rtc,ticdurs)]} {
							set dosave 1
							break
						}
					}
				}
				5 {
					if {$item == "0"} {
						if {[info exists segment(rtc,umlevs)]} {
							set dosave 1
							break
						}
					} else {
						if {![info exists segment(rtc,umlevs)]} {
							set dosave 1
							break
						} elseif {![string match $item $segment(rtc,umlevs)]} {
							set dosave 1
							break
						}
					}
				}
				6 {
					if {$item == "0"} {
						if {[info exists segment(rtc,umdurs)]} {
							set dosave 1
							break
						}
					} else {
						if {![info exists segment(rtc,umdurs)]} {
							set dosave 1
							break
						} elseif {![string match $item $segment(rtc,umdurs)]} {
							set dosave 1
							break
						}
					}
				}
				7 {
					if {$item != $segment(rtc,ticsub)} {
						set dosave 1
						break
					}
				}
				8 {
					if {$item != $segment(rtc,glosub)} {
						set dosave 1
						break
					}
				}
			}
			incr n
		}
	} else {
		set dosave 1
	}
	if {!$dosave} {
		return
	}											;#	0
	if {[info exists segment(rfnam)] && ([string length $segment(rfnam)] > 0) && [file exists [file join $segment(dirname) $segment(rfnam)$evv(TEXT_EXT)]]} {
		lappend output $segment(rfnam)
	} elseif {[info exists segment(rfnam_loaded)] && ([string length $segment(rfnam_loaded)] > 0) && [file exists [file join $segment(dirname) $segment(rfnam_loaded)$evv(TEXT_EXT)]]} {
		lappend output $segment(rfnam_loaded)	;#	In case VBOX was opened but no sound used this time, keep the previously loaded file
	} else {
		lappend output 0
	}
	if {[info exists segment(ticdir)]} {
		lappend output $segment(ticdir)			;#	1
	} else {
		lappend output 0
	}
	if {[info exists segment(umdir)]} {
		lappend output $segment(umdir)			;#	2
	} else {
		lappend output 0
	}
	if {[info exists segment(rtc,ticlevs)]} {
		lappend output $segment(rtc,ticlevs)
	} else {									;#	3
		lappend output 0
	}
	if {[info exists segment(rtc,ticdurs)]} {
		lappend output $segment(rtc,ticdurs)
	} else {									;#	4
		lappend output 0
	}
	if {[info exists segment(rtc,umlevs)]} {
		lappend output $segment(rtc,umlevs)
	} else {									;#	5
		lappend output 0
	}
	if {[info exists segment(rtc,umdurs)]} {
		lappend output $segment(rtc,umdurs)
	} else {									;#	6
		lappend output 0
	}
	lappend output $segment(rtc,ticsub)			;#	7
	lappend output $segment(rtc,glosub)			;#	8
	set fnam [file join $segment(dirname) _segdir$evv(TEXT_EXT)]
	if [catch {open $fnam "w"} zit] {
		Inf "CANNOT OPEN FILE $fnam TO SAVE LAST-USED DIRECTORIES FOR SEGMENTATION"
		return
	}
	foreach item $output {
		puts $zit $item
	}
	close $zit
}

#--	Load tics&ums from most recently used (or newly chosen) directory. Get fnams and maxsamps.
#				0			1			2			3		4		5		6					7			8
#	File has segdatafile  ticdirname  umdirname  ticlevs  ticdurs  umlevs  umdurs  supress_tics_flagval  supress_ums_flagval
#

proc LoadSegmentationDirs {} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId
	set fnam [file join $segment(dirname) _segdir$evv(TEXT_EXT)]
	if {![file exists $fnam]} {
		return 0
	}
	if [catch {open $fnam "r"} zit] {
		Inf "CANNOT OPEN FILE $fnam TO READ LATEST USED DIRECTORIES FOR TICS AND \"UM\"S"
		return 0
	}
	catch {unset segment(rtc,ticdurs)}
	catch {unset segment(rtc,ticlevs)}
	catch {unset segment(rtc,umdurs)}
	catch {unset segment(rtc,umlevs)}
	Block "PLEASE WAIT:        LOADING LAST USED SEGMENTATION DIRECTORIES"
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		lappend seg_data $line
	}
	close $zit
	if {![info exists seg_data] || ([llength $seg_data] != 9)} {
		Inf "BAD DATA IN FILE $fnam (INFORMATION ABOUT LAST USED SEGMENTATION DIRECTORIES)"
		UnBlock
		return 0
	}
	set zfnam [lindex $seg_data 0]
	if {($zfnam != "0") && [file exists [file join $segment(dirname) $zfnam$evv(TEXT_EXT)]]} {
		set segment(rfnam_loaded) $zfnam
		set segment(rfnam) $zfnam
	} else {
		catch {unset segment(rfnam_loaded)}
	}
	set ticdir [lindex $seg_data 1]
	if {$ticdir != "0"} {
		set segment(ticdir) $ticdir
		if [catch {glob [file join $segment(ticdir) *_tic*]} zit] {
			Inf "THERE ARE NO TIC FILES IN DIRECTORY $segment(ticdir)"
		} else {
			catch {unset segment(tics)}
			foreach zzfnam [glob [file join $segment(ticdir) *_tic*]] {
				lappend segment(tics) $zzfnam
			}
			set len [llength $segment(tics)]
			set kk 0				;#	counts final number of ums
			set mm 1				;#	numbers original ums, before testing

			set ticlevs [lindex $seg_data 3]
			set ticlevs [string trim $ticlevs]
			set ticlevs [split $ticlevs]
			foreach item $ticlevs {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend segment(rtc,ticlevs) $item
			}
			set ticdurs [lindex $seg_data 4]
			set ticdurs [string trim $ticdurs]
			set ticdurs [split $ticdurs]
			foreach item $ticdurs {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend segment(rtc,ticdurs) $item
			}
		}
	}
	set umdir [lindex $seg_data 2]
	if {$umdir != "0"} {
		set segment(umdir) $umdir
		if [catch {glob [file join $segment(umdir) *_um*]} zit] {
			Inf "THERE ARE NO \"UM\" FILES IN DIRECTORY $segment(ticdir)"
		} else {
			catch {unset segment(ums)}
			foreach zzfnam [glob [file join $segment(umdir) *_um*]] {
				lappend segment(ums) $zzfnam
			}
			set len [llength $segment(ums)]
			set kk 0				;#	counts final number of ums
			set mm 1				;#	numbers original ums, before testing

			set umlevs [lindex $seg_data 5]
			set umlevs [string trim $umlevs]
			set umlevs [split $umlevs]
			foreach item $umlevs {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend segment(rtc,umlevs) $item
			}
			set umdurs [lindex $seg_data 6]
			set umdurs [string trim $umdurs]
			set umdurs [split $umdurs]
			foreach item $umdurs {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend segment(rtc,umdurs) $item
			}
		}
	}
	set segment(rtc,ticsub) [lindex $seg_data 7]
	set segment(rtc,glosub) [lindex $seg_data 8]
	set segment(lastdirload) $seg_data 
	UnBlock
	return 1
}

#---- Insert glossolalia, at correct time and level, into output mix

proc InsertGlosOrTicInArticMix {segno glos typ} {
	global segment
	set fnam [lindex $glos 0]
	set dur  [lindex $glos 1]
	set lev  [lindex $glos 2]

	;#	ADD HESITATION AFTER GLOSS ITEM

	set hes [expr rand() * $segment(rtc,hestop)]
	set stepdur [expr $dur + $hes]

	;#	INSERT GLOS IN MIXLINES AT CORRECT TIME

	set mixtime [lindex [lindex $segment(mixlines) $segno] 1]					;#	Find time where gloss is to be inserted
	set mixline [list $fnam $mixtime 1 1.0]										;#	Create mixline for gloss at this time
	set segment(mixlines)	  [linsert $segment(mixlines)	  $segno $mixline]	;#	Insert this new line in the mix
	set segment(rtc,fnams)	  [linsert $segment(rtc,fnams)	  $segno $fnam]		;#	Insert name of gloss in fnams-array
	set segment(rtc,outtimes) [linsert $segment(rtc,outtimes) $segno $mixtime]	;#	Insert this new time in outtimes

	incr segment(cnt)

	;#	SHUFFLEUP TIMES OF MIXLINES BEYOND INSERTED LINE

	set k $segno
	incr k
	while {$k < $segment(cnt)} {
		set mixline [lindex $segment(mixlines) $k]
		set mixtime [expr [lindex $mixline 1] + $stepdur]
		set mixline [lreplace $mixline 1 1 $mixtime]
		set segment(mixlines) [lreplace $segment(mixlines) $k $k $mixline]
		set segment(rtc,outtimes) [lreplace $segment(rtc,outtimes) $k $k $mixtime]
		incr k
	}

	;#	SET GAIN LEVEL FOR INSERTED GLOSS, DEPENDING ON ACCENTATION IN REST OF PHRASE

	set accmax 0
	foreach acc $segment(rtc,accents) {
		if {$acc > $accmax} {
			set accmax $acc
		}
	}
	switch -- $accmax {
		0 {		;#	No accents
			set gain 1.0
		}
		1 {
			set quiet [expr 1.0/$segment(rtc,acc)]
			set gain  [expr ($segment(normlev)/$lev) * $quiet] 
		}
		2 {
			set quiet [expr 1.0/$segment(rtc,accacc)]
			set gain  [expr ($segment(normlev)/$lev) * $quiet]
		}
	}
	if {$typ == "t"} {
		if {$segment(rtc,ticsub)} {			;#	subdue level of tic
			set gain [expr $gain/2.0]
		}
	} else {
		if {$segment(rtc,glosub)} {			;#	subdue level of glossi
			set gain [expr $gain/2.0]
		}
	}
	set segment(rtc,gains) [linsert $segment(rtc,gains) $segno $gain]

	;#	INSERT DUMMY ENTRIES IN TIMESTRETCH AND PSHIFT ARRAYS

	set segment(rtc,pshifts)	[linsert $segment(rtc,pshifts)	  $segno 1.0]
	set segment(rtc,tstretches) [linsert $segment(rtc,tstretches) $segno 1.0]

;#	ALREADY USED ARRAYS, NO NEED TO MODIFY
;#	(rtc,seglevs)
;#	(rtc,accents)
;#	(rtc,cuts)
;#	(rtc,headdurs)
;#	(rtc,segdurs)

}

#----

proc LoadPreviousVboxFile {fnam type} {
	global segment evv evv
	if {![file exists $segment(dirname)] || ([string length $fnam] <= 0)} {
		Inf "THERE IS NO EXISTING SEGMENTATION FILE"
		return 0
	}
	set trufnam [file join $segment(dirname) $fnam$evv(TEXT_EXT)]
	if {![file exists $trufnam]} {
		Inf "PREVIOUSLY USED SEGMENTATION FILE ($trufnam) NO LONGER EXISTS"
		return 0
	}
	if [catch {open $trufnam  "r"} zit] {
		Inf "CANNOT OPEN FILE $trufnam TO READ SEGMENTATION DATA"
		return 0
	}
	catch {unset segment(marklist)}
	while {[gets $zit line] >= 0} {
		lappend segment(marklist) $line
	}
	close $zit
	set segment(cnt) [expr [llength $segment(marklist)] - 1]
	GettrofLoadAssociatedText
	set segment(lastload) [list $type $fnam]
	return 1
}

#--- Clean up after failure or completion, removing files specially grabbed to, or created on, workspace

proc RemovelFromWkspaceLoadedOrCreatedFiles {} {
	global chlist segment total_wksp_cnt wl
	set len [llength $chlist]
	set kjk 0
	while {$kjk < $len} {
		if {[info exists segment(i,$kjk)]} {
			if {$segment(i,$kjk) < 0} {
				set i [LstIndx $segment(src,$kjk) $wl]
				if {$i >= 0} {
					PurgeArray $segment(src,$kjk)
					incr total_wksp_cnt -1
					$wl delete $i
				}
			}
			unset segment(i,$kjk)
		} elseif {[info exists segment(j,$kjk)]} {
			if {$segment(j,$kjk) < 0} {
				set j [LstIndx $segment(ana,$kjk) $wl]
				if {$j >= 0} {
					PurgeArray $segment(ana,$kjk)
					incr total_wksp_cnt -1
					$wl delete $j
				}
			}
			unset segment(j,$kjk)
		}
		catch {unset segment(src,$kjk)}
		catch {unset segment(ana,$kjk)}
		incr kjk
	}
}

#--- Get overlap param for VBOX anal files
#
#	Why this works ....
#	From CDP's PVOC
#		switch(dz->iparam[PVOC_WIN_OVERLAP]){
#			case 0:	M = 4*dz->iparam[PVOC_CHANS];	break;	;#	PVOC_CHANS = input chans param to PVOC --> dz->infile->channels = PVOC_CHANS+2
#			case 1:	M = 2*dz->iparam[PVOC_CHANS];	break;
#			case 2: M = dz->iparam[PVOC_CHANS];		break;
#			case 3: M = N2;							break;	;#	N2 = chanpairs count = PVOC_CHANS/2
#		}
#		so	M				0	1	2	3
#			chansmultiplier	4	2	1	1/2	
#			halfchans_mult	8	4	2	1
#			powoftwo		3	2	1	0
#
#			so powoftwo = (3 - M)
#
# BUT ALSO	dz->iparam[PVOC_WIN_OVERLAP] = dz->iparam[PVOC_WINOVLP_INPUT]-1;
# so		OUTPUT THE VALUE overlap + 1
#

proc GetOverlap {chans winlen} {						;#	chans   = channels read from input
	set inchans $chans
	incr inchans -2										;#	inchans = channel-cnt INPUT to PVOC
	set chanpairs [expr $inchans/2]
	set overlap 0										;#	overlap	= 0,1,2,3
	while {$overlap < 4} {
		set z [expr 3 - $overlap]						;#		  z	= 3,2,1,0
		set twopow [expr int(pow(2,$z))]				;#	twopow	= 8,4,2,1
		set impulse_winlen [expr $twopow * $chanpairs]	
		if {$winlen == $impulse_winlen} {
			break										;#
		}
		incr overlap
	}
	incr overlap
	return $overlap
}

##############
# HEAD PITCH #
##############

proc DoHeadPitch {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	if {[info exists segment(intrinsic_pitch)] && $segment(intrinsic_pitch)} {

		Block "PLEASE WAIT: EXTRACTING PITCHES OF THE HEADS"

		if {![ExtractIntrinsicPitches 1]} {
			UnBlock
			return 0
		}
		UnBlock
	}
		;#	ELSE, PITCHES ALREADY STORED IN segment(pitches)

	;#	CONVERT SEGMENTS TO PHRASE SEGMENTATION

	set segment(conv) 1
	set segment(oldmarks) $segment(marklist)
	set segment(oldheadfirst) $segment(headfirst)
	set segment(oldcnt) $segment(cnt)
	if {![ConvertHTDataToPhraseData]} {
		return 0
	}

	if {!$segment(oldheadfirst)} {		;#	DON'T KEEP THE INITIAL TAIL, IF ANY
		set segment(marklist) [lreplace $segment(marklist) 0 0 [lindex $segment(oldmarks) 1]]
	}
	DeleteAllTemporaryFilesExcept $segment(nutroflist)
	if {![SegmentSound 1]} {
		return 0
	}
	set segment(tuningcnt) [llength $segment(marklist)]
	incr segment(tuningcnt) -1
	set segment(cnt) $segment(tuningcnt)


	;#	ESTABLISH DURATION OF SEGMENTS, AND STORE THEIR DURS AND NAMES

	catch {unset segment(rtc,fnams)}
	catch {unset segment(rtc,segdurs)}
	catch {unset segment(rtc,headdurs)}
	set n 1
	while {$n <= $segment(cnt)} {
		set fnam $evv(DFLT_OUTNAME)HH$n$evv(SNDFILE_EXT)
		if {![DoSegmentDurParse $fnam]} {
			Inf "FAILED TO FIND DURATION OF SEGMENT $n"
			lappend segment(rtc,segdurs) 0
		} else {
			lappend segment(rtc,segdurs) $segment(itemdur)			;#	Find durations of all segments
		}
		lappend segment(rtc,fnams) $fnam							;#	Find (initial) names of all segments
		incr n
	}

	;#	ESTABLISH (KNOWN OR DEFAULT) DURATIONS OF SEGMENT HEADS

	set headdur_cnt 0
	set sttseg [lindex $segment(marklist) 0]
	set k 0
	set oldlen [llength $segment(oldmarks)]
	while {$k < $oldlen} {
		set oldsegtime [lindex $segment(oldmarks) $k]
		if {[Flteq $oldsegtime $sttseg]} {
			break
		}
		incr k
	}
	if {$k < $oldlen} {											;#	If found time in origmarks corresponding to start of new marklist
		set j $k												;#	Establish duration of segment heads.
		incr j
		set lastold [expr $oldlen - 1]
		while {$j < $oldlen} {
			set headdur [expr [lindex $segment(oldmarks) $j] - [lindex $segment(oldmarks) $k]]
			if {$k > 0} {										;#	If not the first timeval	
				set headdur [expr $headdur + $segment(SPLICE)]	;#	Add start upsplice length
			}
			if {$j < $lastold} {								;#	If not the final timeval
				set headdur [expr $headdur + $segment(SPLICE)]	;#	Add end downsplice length
			}
			lappend segment(rtc,headdurs) $headdur
			incr k 2
			incr j 2											;#	Advance both H and T markers in oldmarks
			incr headdur_cnt									;#	Advance in headdurs array
			if {$headdur_cnt >= $segment(cnt)} {
				break
			}
		}
	}

	;#	IF (a) no correspondence found between old and new mark times, so no headdurs set (should be impossible)
	;#	or (b) not enough headdurs have been set (should be impossible)
	;#	SET DEFAULT HEADDURS

	while {$headdur_cnt < $segment(cnt)} {
		set dur [lindex $segment(rtc,segdurs) $headdur_cnt]
		if {$dur <= 0.0} {										;#	If duration not known, neither is headdur
			lappend segment(rtc,headdurs) 0.0
		} elseif {$dur <= $segment(rtc,dflthdur)} {				;#	IF segment shorter than default headdur, headdur = segment dur
			lappend segment(rtc,headdurs) $dur
		} else {												;#	Else, headdur set as a default value segment(rtc,dflthdur)
			lappend segment(rtc,headdurs) $segment(rtc,dflthdur)
		}
		incr headdur_cnt
	}

	;#	ESTABLISH (INITIAL) segment(mixlines) AND segment(rtc,outtimes) : CREATE FROM segment(marklist)
	;#	MIXLINES WILL BE MODIFIED AS WE PROCEED

	set times $segment(marklist)						;#	Get times from marklist
	set times [lreplace $times end end]					;#	Delete AFTER END time from marklist
	set len [llength $times]
	set firsttime [lindex $times 0]
	if {$firsttime > 0.0} {								;#	IF start time is not zero, shuffle timelist to start at zero				
		set n 0
		while {$n < $len} {
			set time [expr [lindex $times $n] - $firsttime]
			if {$time < 0.0} {

				set time 0.0
			}
			set times [lreplace $times $n $n $time]
			incr n
		}
	}
	set n 1
	while {$n < $len} {									;#		Allow for upsplice in output mix (except for 1st file)
		set time [expr [lindex $times $n] - $segment(SPLICE)]
		if {$time < 0.0} {
			set time 0.0
		}
		set times [lreplace $times $n $n $time]
		incr n
	}

	set segment(rtc,outtimes) $times
	foreach fnam $segment(rtc,fnams) time $segment(rtc,outtimes) {
		set line [list $fnam $time 1 1.0]
		lappend segment(mixlines) $line
	}

	;#	SET UP CONSTANTS AND VARIABLES FOR READING TVAR PARAMS

	set nn 2						;#	(segment(control1,HPITCH) is in segment(pitches), constant not needed
	while {$nn <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$nn) [expr [llength $segment(control$nn,HPITCH)] - 1]
		set segment(zccnt,$nn) 0
		incr nn
	}

	;#	RUN THE PROGRAM ON EACH SEGMENT

	set n 0
	set m 1
	set gotrepitch 0
	set failed_msg ""

	Block "PLEASE WAIT: PITCHING THE HEADS"

	foreach zfnam $segment(rtc,fnams) dur $segment(rtc,segdurs) headur $segment(rtc,headdurs) pitch $segment(pitches) origtime $segment(rtc,outtimes) {

		if {$segment(alltail)} {			;#	Incorporate (almost) all of tail
			set headur [expr $dur - 0.00001]
		}
		if {$headdur <= 0} {
			incr n
			incr m
			continue
		}
		set ph_pmult [GetParamValueFromControl $origtime 2]		;#	Get possibly time-varying params
		set ph_rand  [GetParamValueFromControl $origtime 3]
		set ph_dip   [GetParamValueFromControl $origtime 4]
		set ph_mid   [GetParamValueFromControl $origtime 5]

		set k [string first "HH" $zfnam]						;#	Create outfilename
		incr k 2
		set namend [string range $zfnam $k end]
		set ofnam $evv(MACH_OUTFNAME)
		append ofnam "PH" $namend
		
		set cmd [file join $evv(CDPROGRAM_DIR) newdelay]
		lappend cmd newdelay 2 $zfnam $ofnam $pitch $headur $ph_pmult
		if {$ph_rand > 0.0} {
			lappend cmd -r$ph_rand
		}
		if {$ph_dip > 1.0} {
			lappend cmd -d$ph_dip -m$ph_mid
		}
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        PITCHING HEAD OF SEGMENT $m"
		if [catch {open "|$cmd"} CDPidrun] {
			append failed_msg "FAILED TO RUN HEAD-PITCHING PROCESS FOR SEGMENT $m\n"
			catch {unset CDPidrun}
			incr n
			incr m
			continue
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			append failed_msg "FAILED TO PITCH HEAD OF SEGMENT $m\n"
			incr n
			incr m
			continue
		}
		if {![file exists $ofnam]} {
			append failed_msg "NO HEAD-PITCHED SEGMENT $m CREATED\n"
			incr n
			incr m
			continue
		}
		if {![DoSegmentDurParse $ofnam]} {
			append failed_msg "FAILED TO FIND DURATION OF HEAD-PITCHED SEGMENT $m\n"
			incr n
			incr m
			continue
		} else {
			set extend [expr $segment(itemdur) - $dur]
			set mixline [lindex $segment(mixlines) $n]
			set mixline [lreplace $mixline 0 0 $ofnam]								;#	Put outfile into mix
			set segment(mixlines) [lreplace $segment(mixlines) $n $n $mixline]
			set kk $m
			while {$kk < $segment(cnt)} {											;#	shufflup times in rest of mix
				set mixline [lindex $segment(mixlines) $kk]
				set mixtime [expr [lindex $mixline 1] + $extend]
				set mixline [lreplace $mixline 1 1 $mixtime]
				set segment(mixlines) [lreplace $segment(mixlines) $kk $kk $mixline]
				incr kk
			}
		}
		set gotrepitch 1		
		incr n
		incr m
	}
	if {!$gotrepitch} {
		Inf "FAILED TO DO ANY HEAD-PITCHING"
		UnBlock
		return 0
	}
	if {[string length $failed_msg] > 0} {
		Inf $failed_msg
	}
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY FILE $segment(mixdata) TO MIX MODIFIED SEGMENTS"
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofMixdown 1]} {
		UnBlock
		return 0
	}
	UnBlock
	set segment(reordered) 0
	return 1
}

#-- Extract medianpitch of heads, or of headtail pairs.

proc ExtractIntrinsicPitches {heads_only} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	;#	FIND MEDIAN PITCHES OF SEGMENTS

	set OK 1
	while {$OK} {
		if {[file exists $segment(medianfil)]} {
			if [catch {file delete $segment(medianfil)} zit] {
				Inf "CANNOT DELETE INTERMEDIATE TEMPORARY DATA FILE $segment(medianfil) : $zit"	
				set OK 0
				break
			}
		}
		set marks [lreplace $segment(marklist) end end $segment(wavdur)]

		if [catch {open $segment(notedata) "w"} zit] {
			Inf "CANNOT OPEN INTERMEDIATE TEMPORARY DATA FILE $segment(notedata) : $zit"	
			set OK 0
			break
		}
		foreach mark $marks {
			puts $zit $mark
		}
		close $zit

		set cmd [file join $evv(CDPROGRAM_DIR) spectune]
		lappend cmd tune 6 $segment(ana,0) $segment(medianfil) $segment(notedata) -b
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		wm title .blocker "PLEASE WAIT:        EXTRACTING MEDIAN PITCHES OF SEGMENTS"
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "FAILED TO RUN EXTRACTION-OF-MEDIAN-PITCHES PROCESS"
			catch {unset CDPidrun}
			set OK 0
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			Inf "FAILED TO FIND MEDIAN PITCHES OF SEGMENTS "
			set OK 0
			break
		}
		if {![file exists $segment(medianfil)]} {
			Inf "NO MEDIAN PITCHES OF SEGMENTS FOUND"
			set OK 0
			break
		}
		if [catch {open $segment(medianfil) "r"} zit] {
			Inf"CANNOT OPEN SEGMENT-MEDIAN-PITCHES FILE $segment(medianfil) TO READ DATA"
			set OK 0
			break
		}
		catch {unset medianpitches}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {![IsNumeric $item]} {
					set OK 0
					break
				}
				lappend medianpitches $item
			}
			if {!$OK} {
				break
			}
		}
		close $zit
		if {!$OK} {
			break
		}
		if {![info exists medianpitches]} {
			Inf "NO DATA FOUND IN MEDIAN-PITCHES FILE"
			set OK 0
			break
		}
		if {[llength $medianpitches] != $segment(cnt)} {
			Inf "NUMBER OF MEDIAN-PITCHES DOES NOT TALLY WITH NUMBER OF SEGMENTS"
			set OK 0
			break
		}
		break
	}
	if {!$OK} {
		return 0
	}
	if {$heads_only} {
		if {$segment(headfirst)} {
			set m -1			
			set k 0					;#	Point to first Head segment
			set j 1
		} else {
			set m 0
			set k 1					;#	Point to first Head segment
			set j 2
		}

		;#	TEST VALIDITY OF HEAD PITCHES

		while {$k < $segment(cnt)} {
			if {[lindex $medianpitches $k] > $segment(voicetop)} {
				if {$j < $segment(cnt)} {
					if {[lindex $medianpitches $j] < $segment(voicetop)} {			;#	If pitch of Head is out of range
						set medianpitches [lreplace $medianpitches $k $k [lindex $medianpitches $j]]	;#	replace by pitch of tail, if that in range
					}
				} elseif {$m >= 0} {
					if {[lindex $medianpitches $m] < $segment(voicetop)} {			;#	Else
						set medianpitches [lreplace $medianpitches $k $k [lindex $medianpitches $m]]	;#	replace by pitch of previous tail, if that in range
					}
				} else {															;#	else replace by zero marker
					set medianpitches [lreplace $medianpitches $k $k 0]
				}
			}
			incr k
			incr j
			incr m
		}

		;#	DELETE ALL TAIL PITCHES

		set k $segment(cnt)
		while {$k > 0} {
			incr k -1
			if {$segment(headfirst)} {
				if {![IsEven $k]} {
					set medianpitches [lreplace $medianpitches $k $k]
				}
			} else {
				if {[IsEven $k]} {
					set medianpitches [lreplace $medianpitches $k $k]
				}
			}
		}
	} else {

		set k 0					;#	Point to first segment

		;#	TEST VALIDITY OF HEADTAIL PITCHES

		while {$k < $segment(cnt)} {
			if {[lindex $medianpitches $k] > $segment(voicetop)} {
				set medianpitches [lreplace $medianpitches $k $k 0]
			}
			incr k
		}
	}

	;#	SUBSTITUTE BUM PITCHES BY CLOSEST ONE IN SOURCE-SEGMENTS

	set len [llength $medianpitches]
	set k 0
	while {$k < $len} {
		if {[lindex $medianpitches $k] == 0} {
			set j $k
			incr j -1
			while {$j >= 0} {
				if {[lindex $medianpitches $j] != 0} {
					set dnpitch [lindex $medianpitches $j]
					set dnstep [expr $k - $j]
					break
				}
				incr j -1
			}
			set j $k
			incr j
			while {$j < $len} {
				if {[lindex $medianpitches $j] != 0} {
					set uppitch [lindex $medianpitches $j]
					set upstep [expr $j - $k]
					break
				}
				incr j
			}
			if {[info exists upstep]} {
				if {[info exists dnstep]} {
					if {$upstep < $dnstep} {
						set pp $uppitch
					} elseif {$dnstep < $upstep} {
						set pp $dnpitch
					} else {
						set pp [expr ($uppitch + $dnpitch)/2.0]
					}
					unset dnstep
				} else {
					set pp $uppitch
				}
				unset upstep
			} elseif {info exists dnstep]} {
					set pp $dnpitch
					unset dnstep
			} else {
				Inf "NO VIABLE PITCH FOUND IN SOURCE FILE"
				return 0
			}
			set medianpitches [lreplace $medianpitches $k $k $pp]
		}
		incr k
	}
	if {$segment(tempered)} {
		set k 0
		while {$k < $len} {
			set pp [expr int(round([lindex $medianpitches $k]))]
			set medianpitches [lreplace $medianpitches $k $k $pp]
			incr k
		}
	}
	set segment(pitches) $medianpitches
	set segment(control1,PITCH) $segment(pitches)	;#	Allows data to be stored in a patch, and reloaded later
	return 1
}

#--- Enter tuning data

proc HeadPitchStyle {} {
	global segment pr_hedpich hedpich tunehead tuneweighted pitchartic tv_active evv
	set f .hedpich
	set segment(tuningcnt) [expr $segment(cnt)/2]	;#	Odd, headfirst			Even, headfirst		Odd, tailfirst		Even, tailfirst
	if {$segment(headfirst)} {						;#	5->2					4->2				5->2				4->2
		if {![IsEven $segment(cnt)]} {				;#	H T H T H		Else	H T H T				T H T H T			T H T H
			incr segment(tuningcnt)					;#	2->3 heads				2 heads				2 heads				2 heads
		}
	}
	if [Dlg_Create $f "SET PITCHES FOR PITCHED HEADS" "set pr_hedpich 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_hedpich 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_hedpich 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_hedpich 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true

		frame $f.1
		checkbutton $f.1.ch	-text "Incorporate Tail"  -variable segment(alltail)
		frame $f.1.00
		radiobutton $f.1.00.a  -text "Intrinsic Pitch"     -variable segment(intrinsic_pitch) -value 1 -width 20 -command "HeadPitchStyleRedisplay 0 0"
		radiobutton $f.1.00.b  -text "Intrinsic, Tempered" -variable segment(intrinsic_pitch) -value 2 -width 20 -command "HeadPitchStyleRedisplay 1 0"
		radiobutton $f.1.00.c  -text "Impose Pitches"      -variable segment(intrinsic_pitch) -value 0 -width 20 -command "HeadPitchStyleRedisplay 0 1"
		pack $f.1.ch $f.1.00.a  $f.1.00.b $f.1.00.c -side left
		label $f.1.0 -text "" -width 16
		checkbutton $f.1.1  -text "Text Entry" -variable hedpich -width 16 -command {set pr_hedpich [GettrofDataByTextEntry pitches]}
		frame $f.1.2
		if {$tv_active} {
			GettrofMakeKeyboardKey $f.1.2
		}
		label $f.1.3 -text "MIDI Kbd Entry" -width 16
		set hedpich 0
		set tunehead 0
		pack $f.1.00 $f.1.0 $f.1.1 $f.1.2 $f.1.3 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_hedpich 1}
		bind $f <Escape> {set pr_hedpich 0}
	}
	if {$tv_active} {
		bind .hedpich.1.2.0   <ButtonPress-1> {}
		bind .hedpich.1.2.1.0 <ButtonPress-1> {}
		bind .hedpich.1.2.1.1 <ButtonPress-1> {}
		bind .hedpich.1.2.1.2 <ButtonPress-1> {}
		bind .hedpich.1.2.1.3 <ButtonPress-1> {}
		bind .hedpich.1.2.1.4 <ButtonPress-1> {}
		bind .hedpich.1.2.1.5 <ButtonPress-1> {}
		bind .hedpich.1.2.1.6 <ButtonPress-1> {}
		bind .hedpich.1.2.2.0 <ButtonPress-1> {}
		bind .hedpich.1.2.2.1 <ButtonPress-1> {}
		bind .hedpich.1.2.2.2 <ButtonPress-1> {}
		bind .hedpich.1.2.2.3 <ButtonPress-1> {}
		bind .hedpich.1.2.2.4 <ButtonPress-1> {}
		bind .hedpich.1.2.2.5 <ButtonPress-1> {}
		bind .hedpich.1.2.2.6 <ButtonPress-1> {}
		bind .hedpich.1.2.3   <ButtonPress-1> {}

		bind .hedpich.1.2.0   <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.0 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.1 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.2 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.3 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.4 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.5 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.1.6 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.0 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.1 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.2 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.3 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.4 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.5 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.2.6 <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
		bind .hedpich.1.2.3   <ButtonPress-1> "GettrofGetNoteData 0 .hedpich.1.2"
	}
	if {[info exists segment(tempered)]} {
		if {$segment(tempered)}  {
			set segment(intrinsic_pitch) 2
		} 
	} elseif {[string length $segment(intrinsic_pitch)] <= 0} {
		set segment(intrinsic_pitch) 1
		set segment(tempered) 0
	}
	if {$segment(intrinsic_pitch)} {
		.hedpich.1.0 config -text "" -width 16
		if {$tv_active} {
			GettrofHideKeyboardKey .hedpich.1.2
			.hedpich.1.3 config -text ""
		}
		.hedpich.1.1  config -text "" -state disabled -command {} -disabledforeground []
	} else {
		.hedpich.1.0 config -text "$segment(tuningcnt) PITCHES" -width 16
		if {$tv_active} {
			GettrofShowKeyboardKey .hedpich.1.2	
			.hedpich.1.3 config -text "MIDI Kbd Entry"
		}
		.hedpich.1.1  config -text "Text Entry" -state normal -command {set pr_hedpich [GettrofDataByTextEntry pitches]}
	}
	catch {unset segment(pitches)}
	set pr_hedpich 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_hedpich
	while {!$finished} {
		tkwait variable pr_hedpich
		switch -- $pr_hedpich {
			1 {
				if {!$segment(intrinsic_pitch)} {
					if {![info exists segment(pitches)] || ([llength $segment(pitches)] <= 0)} {
						Inf "NO PITCHES SET"
						continue
					}
					set segment(control1,PITCH) $segment(pitches)	;#	Ensures data is remembered and can be stored in a patch
				}
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			3 {
				set hedpich 0
				continue							;#	If entry from text window fails		
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

proc HeadPitchStyleRedisplay {tempered imposed} {
	global segment tv_active
	if {$tempered} {
		set segment(tempered) 1
	} else {
		set segment(tempered) 0
	}
	if {$imposed} {
		.hedpich.1.0 config -text "$segment(tuningcnt) PITCHES" -width 16
		if {$tv_active} {
			GettrofShowKeyboardKey .hedpich.1.2	
			.hedpich.1.3 config -text "MIDI Kbd Entry"
		}
		.hedpich.1.1  config -text "Text Entry" -state normal -command {set pr_hedpich [GettrofDataByTextEntry pitches]}
	} else {
		.hedpich.1.0 config -text "" -width 16
		if {$tv_active} {
			GettrofHideKeyboardKey .hedpich.1.2
			.hedpich.1.3 config -text ""
		}
		.hedpich.1.1  config -text "" -state disabled -command {} -disabledforeground []

	}
}

proc GettrofHideKeyboardKey {f} {
	$f.0 config   -bg [option get . background {}]
	$f.3 config   -bg [option get . background {}]
	$f.1.0 config -bg [option get . background {}]
	$f.1.1 config -bg [option get . background {}]
	$f.1.2 config -bg [option get . background {}]
	$f.1.3 config -bg [option get . background {}]
	$f.1.4 config -bg [option get . background {}]
	$f.1.5 config -bg [option get . background {}]
	$f.1.6 config -bg [option get . background {}]
	$f.2.0 config -bg [option get . background {}]
	$f.2.1 config -bg [option get . background {}]
	$f.2.2 config -bg [option get . background {}]
	$f.2.3 config -bg [option get . background {}]
	$f.2.4 config -bg [option get . background {}]
	$f.2.5 config -bg [option get . background {}]
	$f.2.6 config -bg [option get . background {}]
	bind $f.0   <ButtonPress-1> {}
	bind $f.1.0 <ButtonPress-1> {}
	bind $f.1.1 <ButtonPress-1> {}
	bind $f.1.2 <ButtonPress-1> {}
	bind $f.1.3 <ButtonPress-1> {}
	bind $f.1.4 <ButtonPress-1> {}
	bind $f.1.5 <ButtonPress-1> {}
	bind $f.1.6 <ButtonPress-1> {}
	bind $f.2.0 <ButtonPress-1> {}
	bind $f.2.1 <ButtonPress-1> {}
	bind $f.2.2 <ButtonPress-1> {}
	bind $f.2.3 <ButtonPress-1> {}
	bind $f.2.4 <ButtonPress-1> {}
	bind $f.2.5 <ButtonPress-1> {}
	bind $f.2.6 <ButtonPress-1> {}
	bind $f.3   <ButtonPress-1> {}
}

proc GettrofShowKeyboardKey {f} {
	$f.0 config   -bg black
	$f.3 config   -bg black
	$f.1.0 config -bg black
	$f.1.1 config -bg white
	$f.1.2 config -bg black
	$f.1.3 config -bg white
	$f.1.4 config -bg black
	$f.1.5 config -bg white
	$f.1.6 config -bg black
	$f.2.0 config -bg black
	$f.2.1 config -bg white
	$f.2.2 config -bg black
	$f.2.3 config -bg white
	$f.2.4 config -bg black
	$f.2.5 config -bg white
	$f.2.6 config -bg black
	bind $f.0   <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.0 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.1 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.2 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.3 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.4 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.5 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.1.6 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.0 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.1 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.2 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.3 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.4 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.5 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.2.6 <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
	bind $f.3   <ButtonPress-1> "GettrofGetNoteData 0 $f.1.2"
}

#---- Recycle a sound saved at previous pass

proc RecycleSavedSound {} {
	global segment evv wl pa
	set segment(ambiguous) 0
	if {![info exists segment(recycle_savedfile)]} {					;#	should be impossible
		unset segment(recycle_savedfile)
		return 0
	}
	set fnam $segment(recycle_savedfile)$evv(SNDFILE_EXT)				;#	should be impossible
	if {![file exists $fnam]} {
		Inf "FILE $fnam NO LONGER EXISTS"
		unset segment(recycle_savedfile)
		return 0
	}
	set fnam $segment(recycle_savedfile)$evv(ANALFILE_EXT)				;#	should be impossible
	if {![file exists $fnam]} {
		Inf "FILE $fnam NO LONGER EXISTS"
		unset segment(recycle_savedfile)
		return 0
	}
	set gotphrs 0
	set gotseg0 0
	set gotseg1 0
	set fnam [file rootname [file tail $fnam]]
	set phrfnam $fnam
	append phrfnam "_phrs" $evv(TEXT_EXT)
	set phrfnam [file join $segment(dirname) $phrfnam]
	if {[file exists $phrfnam]} {
		set gotphrs 1
	}
	set segfnam0 $fnam
	append segfnam0 "_0_rsegs" $evv(TEXT_EXT)
	set segfnam0 [file join $segment(dirname) $segfnam0]
	if {[file exists $segfnam0]} {
		set gotseg0 1
	}
	set segfnam1 $fnam
	append segfnam1 "_1_rsegs" $evv(TEXT_EXT)
	set segfnam1 [file join $segment(dirname) $segfnam1]
	if {[file exists $segfnam1]} {
		set gotseg1 1
	}
	set gotsum [expr $gotphrs + $gotseg0 + $gotseg1] 
	if {$gotsum != 1} {
		if {[file exists $phrfnam] || ($gotsum == 0)} {
			set segment(ambiguous) 2		;#	segmentation data to use is ambiguously phrase-seg or not, or not known at all
		} else {
			set segment(ambiguous) 1		;#	segmentation data to use is ambiguous segmentation
		}
	} else {
		if {$gotphrs} { 
			set segment(rfnam) [file rootname [file tail $phrfnam]]
			set segment(phrase) 1
		} elseif {$gotseg0} {
			set segment(rfnam) [file rootname [file tail $segfnam0]]
			set segment(phrase) 0
		} else {
			set segment(rfnam) [file rootname [file tail $segfnam1]]
			set segment(phrase) 0
		}
	}
	set segment(src,0) $segment(recycle_savedfile)$evv(SNDFILE_EXT)
	set segment(chans)	$pa($segment(src,0),$evv(CHANS))
	set segment(insams) $pa($segment(src,0),$evv(INSAMS))
	set segment(srate)  $pa($segment(src,0),$evv(SRATE))
	set segment(dur)    $pa($segment(src,0),$evv(DUR))
	set segment(wavdur) $pa($segment(src,0),$evv(DUR))

	set segment(ana,0) $segment(recycle_savedfile)$evv(ANALFILE_EXT)
	set segment(frametime) $pa($segment(ana,0),$evv(FRAMETIME))

	set segment(infnam)	   $segment(src,0)
	set segment(dflt_fnam) [file rootname $segment(infnam)]
	append segment(dflt_fnam) "_segs"
	set segment(dflt_rfnam) [file rootname $segment(infnam)]
	append segment(dflt_rfnam) "_rsegs"
	set segment(dflt_cfnam) [file rootname $segment(infnam)]
	append segment(dflt_cfnam) "_csegs"
	DisplayGettrofSrcfileName
	.gettrofs.00.tit.tit config -text "Input File : [string toupper [file rootname [file tail $segment(infnam)]]]"
	unset segment(recycle_savedfile)
	return 1 
}

#--- Run one of the "specfnu" modes on the entire input sound.

proc DoSpecfnu {pproc} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId prg_dun set prg_abortd simple_program_messages CDPidrun

	set k [lsearch $segment(processes) $pproc]
	set pnam [lindex $segment(procnames) $k]

	Block "PLEASE WAIT: RUNNING \"$pnam\" ON SOURCE SOUND"

	set segment(outfnamplay) $segment(outfnamplay_dflt)
	if {[file exists $segment(outfnamplay)] && [catch {file delete $segment(outfnamplay)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(outfnamplay)"
		return 0
	}
	if {[file exists $segment(specfnusnd)] && [catch {file delete $segment(specfnusnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(specfnusnd)"
		return 0
	}

	set ifnam $segment(ana,0)
	set ofnam $segment(specfnusnd)

	if {$pproc == "SQUEEZE"} {
		set segment(othersnd)  $segment(othersnd_dflt)
		if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
			Inf "CANNOT DELETE INTERMEDATE FILE $segment(othersnd)"
			return 0
		}
		set segment(fadesnd)  $segment(fadesnd_dflt)
		if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
			Inf "CANNOT DELETE INTERMEDATE FILE $segment(fadesnd)"
			return 0
		}
		set OK 1
		while {$OK} {
			wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF INPUT SOUND"
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			catch {unset maxsamp_line}
			set done_maxsamp 0
			lappend cmd $segment(src,0)
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR INPUT SOUND"
				set inmaxsamp 0.0
				break
	   		} else {
	   			fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF INPUT"
				set inmaxsamp 0.0
				break
			}
			set inmaxsamp [lindex $maxsamp_line 0]
			break
		}
	} elseif {$pproc == "RANDSTEP"} {
		if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
			Inf "CANNOT DELETE INTERMEDATE FILE $segment(notedata)"
			return 0
		}
		catch {unset lines}
		set line "#SCALE"
		lappend lines $line
		lappend lines 12 60
		if [catch {open $segment(notedata) "w"} zit] {
			Inf "CANNOT OPEN INTERMEDATE DATA FILE $segment(notedata) TO WRITE DATA"
			return 0
		}
		foreach line $lines {
			puts $zit $line
		}
		close $zit
	}

	;#	FIND NAME OF PROCESS, AND RELATED WORDS, TO USE IN FAIL-MESSAGING

	if {$pproc == "RANDSTEP"} {
		set pnam2 "RANDSTEP"
	} else {
		set pnam2 $pnam
	}
	if {$pproc == "LIQUID"} {
		set pnam3 "LIQUIDISED"
	} elseif {$pproc == "SQUEEZE"} {
		set pnam3 "SQUEEZED"
	} elseif {$pproc == "RANDSTEP"} {
		set pnam3 "RANDSTEPPED"
	} else {
		set pnam3 $pproc
		append pnam3 "ED"
	}

	;#	ESTABLISH PARAMS

	switch -- $pproc {
		DEEPEN  {
			set m_ode 16
			set params [list $segment(PAR0) $segment(PAR1) -h10000 -B]
		}
		SQUASH  {
			set m_ode 2
			set params [list $segment(PAR0) $segment(PAR1)]
		}
		SQUEEZE {
			set m_ode 8
			set params [list $segment(PAR0) $segment(PAR0) $segment(PAR0) $segment(PAR0)]
		}
		PINCH	{
			set m_ode 3
			set params [list $segment(PAR0)]
		}
		LIQUID  {
			set m_ode 4
			set params [list $segment(PAR0)]
		}
		ROUGHEN {
			set m_ode 19
			set params [list $segment(PAR0) -h10000]
		}
		RANDSTEP {
			set m_ode 18
			set params [list $segment(notedata) 48 5 -h10000]
		}
	}

	set cmd [file join $evv(CDPROGRAM_DIR) specfnu]
	lappend cmd specfnu $m_ode $ifnam $ofnam
	set cmd [concat $cmd $params]
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING $pnam2 ON INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN $pnam2 PROCESS ON INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO $pnam2 THE INPUT SOUND"
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO $pnam3 VERSION OF INPUT SOUND CREATED"
		UnBlock
		return 0
	}
	set ifnam $ofnam
	if {$pproc == "SQUEEZE"} {
		set ofnam $segment(othersnd)
	} else {
		set ofnam $segment(outfnamplay)
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd synth $ifnam $ofnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RESYNTHESIZING TRANSFORMED SPECTRUM OF INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN RESYNTHESIS OF TRANSFORMED INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE RESYNTHESIZED TRANSFORMED INPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO RESYNTHESIZED TRANSFORMED INPUT SOUND CREATED"
		UnBlock
		return 0
	}
	if {$pproc == "SQUEEZE"} {
		set OK 1
		while {$OK} {

			;#	FILTER ofnam(ifnam) -> new ofnam

			set ifnam $ofnam
			set ofnam $segment(fadesnd)
			set cmd [file join $evv(CDPROGRAM_DIR) filter]
			lappend cmd lohi 1 $ifnam $ofnam -96 2500 2000 -t0 -s1
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        FILTERING TRANSFORMED INPUT SOUND"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN FILTERING TRANSFORMED INPUT SOUND"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO FILTER TRANSFORMED INPUT SOUND"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO FILTERED TRANSFORMED INPUT SOUND CREATED"
				set OK 0
				break
			}
			break
		}
		if {!$OK} {

			;#	IF FILTER FAILS use unfiltered source

			set ofnam $ifnam
		}
		set OK 0
		if {$inmaxsamp > 0.0} {
			set OK 1
			while {$OK} {
				wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF OUTPUT SOUND"
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				catch {unset maxsamp_line}
				set done_maxsamp 0
				lappend cmd $ofnam
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' FOR OUTPUT SOUND"
					set OK 0
					break
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {![info exists maxsamp_line]} {
					Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF OUTPUT"
					set OK 0
					break
				}
				set outmaxsamp [lindex $maxsamp_line 0]
				if {$outmaxsamp <= 0.0} {
					Inf "OUTPUT HAS ZERO LEVEL"
					set OK 0
					break
				}
				break
			}
			if {$OK} {
			
				;#	IF maxlevel found, normalise ofnam ->output
				
				while {$OK} {
					if {$inmaxsamp > $segment(maxlev)} {
						set inmaxsamp $segment(maxlev)
					}
					set gain [expr $inmaxsamp/$outmaxsamp]
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $ofnam $segment(outfnamplay) $gain
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        NORMALISING OUTPUT SOUND"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN NORMALISATION OF OUTPUT SOUND"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO NORMALISE OUTPUT SOUND"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $segment(outfnamplay)]} {
						Inf "NO NORMALISED OUTPUT SOUND CREATED"
						set OK 0
						break
					}
					break
				}
			}
		}
		if {!$OK} {
			;#	IF failed to find INPUT level OR failed to find OUTPUT level, or normalisation failed

			set segment(outfnamplay) $ofnam
		} 
	}
	if {$segment(multiproccnt)} {
		if {![RenameAnyWholefileProcessFileCreated $segment(process)]} {
			return 0
		}
	}
	UnBlock
	return 1
}

#--- Where whole-file-processes applied   . replace the segs-to-be-replaced by equivalent, transformed segs

proc DoWholeFileTransformCutsAndSubstituteInMixfile {} {
	global segment evv prg_dun prg_abortd simple_program_messages CDPidrun

	Block "PLEASE WAIT:        CUTTING TRANSFORMED SEGMENTS"

	set failed_msg ""
	set len [llength $segment(mixlines)]
	foreach dud $segment(multido) {
		set thisproc [lindex $dud 0]

		;#	IF ANY WHOLE-FILE TRANSFORMS, CUT OUT REQUIRED SEGS AND REPLACE ORIGS IN MIXFILE

		if {[IsCutableWholefileTransformationProcess $thisproc]} {
			wm title .blocker "PLEASE WAIT:        CUTTING \"$thisproc\" TRANSFORMED SEGMENTS"
			set actionlist [lindex $dud 1]
			set segno 0
			set segcnt 1
			foreach kk [lrange $actionlist 1 end] {		;#	actionlist has dummy entry at 0
				if {$kk} {								;#	Program acts on this segment
					set mixline [lindex $segment(mixlines) $segno]
					set stt [lindex $mixline 1]
					if {$segcnt < $len} {
						set endd [expr [lindex [lindex $segment(mixlines) $segcnt] 1] + $segment(SPLICE)]
					} else {
						set endd 32766				;#	Cuts at file end
					}
					set ifnam [file rootname $segment(outfnamplay)]			;#	Get appropriate Transformed WholeFile
					append ifnam "_" $thisproc $evv(SNDFILE_EXT)
					if {![file exists $ifnam]} {
						append failed_msg "FAILED TO FIND \"$thisproc\" TRANSFORMED FILE $ifnam\n"
						break
					}
					set ofnam [file rootname $segment(outfnamplay)]			;#	Cut required portion of file
					append ofnam "_" $segcnt $evv(SNDFILE_EXT)
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd cut 1 $ifnam $ofnam $stt $endd -w$segment(MSPLICE)
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        CUTTING \"$thisproc\" TRANSFORMED SEGMENT $segcnt"
					if [catch {open "|$cmd"} CDPidrun] {
						append failed_msg "FAILED TO RUN CUTTING PROCESS FOR \"$thisproc\" TRANSFORMED SEGMENT $segcnt\n"
						catch {unset CDPidrun}
						incr segno
						incr segcnt
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CUT \"$thisproc\" TRANSFORMED SEGMENT $segcnt"
						set msg [AddSimpleMessages $msg]
						append failed_msg "$msg\n"
						incr segno
						incr segcnt
						continue
					}
					if {![file exists $ofnam]} {
						append failed_msg "NO \"$thisproc\" TRANSFORMED SEGMENT $segcnt CREATED\n"
						incr segno
						incr segcnt
						continue
					}
					set mixline [lreplace $mixline 0 0 $ofnam]
					set segment(mixlines) [lreplace $segment(mixlines) $segno $segno $mixline]
				}
				incr segno
				incr segcnt
			}
		}
	}
	if {[string length $failed_msg] > 0} {
		Inf "$failed_msg"
	}
	UnBlock
}

proc WholefileProcessFileAlreadyExists {procc} {
	global segment evv
	if {[IsCutableWholefileTransformationProcess $procc]} {
		set sfnfnam [file rootname $segment(outfnamplay)]
		append sfnfnam "_" $procc $evv(SNDFILE_EXT)
		if {[file exists $sfnfnam]} {
			return 1
		}
	}
	return 0
}

proc RenameAnyWholefileProcessFileCreated {procc} {
	global segment evv
	set sfnfnam [file rootname $segment(outfnamplay)]
	append sfnfnam "_" $procc $evv(SNDFILE_EXT)
	if {![file exists $sfnfnam]} {
		if [catch {file rename $segment(outfnamplay) $sfnfnam} zit] {
			Inf "CANNOT RENAME OUTPUT OF WHOLE-FILE PROCESS \"$procc\""
			return 0
		}
	}
	return 1
}

#--- Run "Deeprev" the entire input sound.

proc DoDeepRev {} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId prg_dun set prg_abortd simple_program_messages CDPidrun

	Block "PLEASE WAIT: RUNNING \"LOW RESONANCE\" ON SOURCE SOUND"

	set segment(outfnamplay) $segment(outfnamplay_dflt)
	if {[file exists $segment(outfnamplay)] && [catch {file delete $segment(outfnamplay)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(outfnamplay)"
		UnBlock
		return 0
	}
	set segment(othersnd)  $segment(othersnd_dflt)
	if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(othersnd)"
		UnBlock
		return 0
	}
	set segment(fadesnd)  $segment(fadesnd_dflt)
	if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(fadesnd)"
		UnBlock
		return 0
	}
	if {[file exists $segment(specfnusnd)] && [catch {file delete $segment(specfnusnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(specfnusnd)"
		UnBlock
		return 0
	}
	if {[file exists $segment(mixfil)] && [catch {file delete $segment(mixfil)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(mixfil)"
		UnBlock
		return 0
	}

	;#	ESTABLISH PARAMS
	
	set transp	[expr -$segment(PAR0)]
	set stadsiz $segment(PAR1)
	set echocnt $segment(PAR2)
	set hfgain  $segment(PAR3)
	set toffset $segment(PAR4)

	set ifnam $segment(ana,0)
	set trdnfnam [file rootname $segment(othersnd)]
	append trdnfnam $evv(ANALFILE_EXT)

	set cmd [file join $evv(CDPROGRAM_DIR) repitch]
	lappend cmd transposef 3 $ifnam $trdnfnam -p4 $transp -l5 -h3000
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING TRANSPOSITION FOR \"LOW RESONANCE\" ON INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN TRANSPOSITION PROCESS ON INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO TRANSPOSE THE INPUT SOUND"
		UnBlock
		return 0
	}
	if {![file exists $trdnfnam]} {
		Inf "NO TRANSPOSED VERSION OF INPUT SOUND CREATED"
		UnBlock
		return 0
	}

	set ifnam $trdnfnam
	set ofnam $segment(othersnd) 

	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd synth $ifnam $ofnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF TRANSPOSED INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN WAVEFORM CREATION ON TRANSPOSED INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO CREATE WAVEFORM OF TRANSPOSED INPUT SOUND"
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO WAVEFORM OF TRANSPOSED INPUT SOUND CREATED"
		UnBlock
		return 0
	}

	set ifnam $ofnam
	set revfnam $segment(specfnusnd)

	set cmd [file join $evv(CDPROGRAM_DIR) modify]
	lappend cmd revecho 3 $ifnam $revfnam -g0.645654 -r1 -s$stadsiz -e$echocnt -n

	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING REVERBERATION ON TRANSPOSED INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN REVERBERATION FOR THE INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE REVERBERATED TRANSPOSED INPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $revfnam]} {
		Inf "NO REVERBERATED TRANSPOSED INPUT SOUND CREATED"
		UnBlock
		return 0
	}

	set ifnam $segment(src,0)
	set hffnam $segment(fadesnd)

	set cmd [file join $evv(CDPROGRAM_DIR) filter]
	lappend cmd lohi 1 $ifnam $hffnam -96 2500 2000 -t0 -s1
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING HIPASS FILTERING FOR \"LOW RESONANCE\" ON INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN HIPASS FILTER ON THE INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE HIGH PASS FILTERED INPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $hffnam]} {
		Inf "NO HIGH PASS FILTERED INPUT SOUND CREATED"
		UnBlock
		return 0
	}
	catch {unset segment(mixlines)}
	set line [list $hffnam 0.0 1 $hfgain C]
	lappend segment(mixlines) $line
	set line [list $revfnam $toffset 2 1.0]
	lappend segment(mixlines) $line

	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixfil) TO MIX COMPONENTS"
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofPossiblyMultichanMixdown 1]} {
		UnBlock
		return 0
	}
	UnBlock
	return 1
}

#--- Run "Tuberev" the entire input sound.

proc DoTubeRev {} {
	global segment pa evv maxsamp_line done_maxsamp CDPmaxId prg_dun prg_abortd simple_program_messages CDPidrun

	Block "PLEASE WAIT: RUNNING \"TUBE RESONANCE\" ON SOURCE SOUND"

	set segment(outfnamplay) $segment(outfnamplay_dflt)
	if {[file exists $segment(outfnamplay)] && [catch {file delete $segment(outfnamplay)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(outfnamplay)"
		UnBlock
		return 0
	}
	set segment(othersnd)  $segment(othersnd_dflt)
	if {[file exists $segment(othersnd)] && [catch {file delete $segment(othersnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(othersnd)"
		UnBlock
		return 0
	}
	set segment(fadesnd)  $segment(fadesnd_dflt)
	if {[file exists $segment(fadesnd)] && [catch {file delete $segment(fadesnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(fadesnd)"
		UnBlock
		return 0
	}
	if {[file exists $segment(specfnusnd)] && [catch {file delete $segment(specfnusnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(specfnusnd)"
		UnBlock
		return 0
	}
	if {[file exists $segment(bakupsnd)] && [catch {file delete $segment(bakupsnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(bakupsnd)"
		UnBlock
		return 0
	}
	if {[file exists $segment(mixfil)] && [catch {file delete $segment(mixfil)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(mixfil)"
		UnBlock
		return 0
	}
	if {[file exists $segment(premix)] && [catch {file delete $segment(premix)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(premix)"
		UnBlock
		return 0
	}
	if {[file exists $segment(exclmix)] && [catch {file delete $segment(exclmix)} zit]} {
		Inf "CANNOT DELETE INTERMEDATE FILE $segment(exclmix)"
		UnBlock
		return 0
	}

	;#	ESTABLISH PARAMS
	
	set respitch $segment(PAR0)
	set fshift	 $segment(PAR1)
	set stadsiz  $segment(PAR2)
	set echocnt  $segment(PAR3)
	set stadsiz2 $segment(PAR4)
	set echocnt2 $segment(PAR5)
	set hfgain   $segment(PAR6)
	set toffset  $segment(PAR7)

	set ifnam $segment(ana,0)
	set ofnam [file rootname $segment(othersnd)]
	append ofnam $evv(ANALFILE_EXT)

	set cmd [file join $evv(CDPROGRAM_DIR) hilite]
	lappend cmd filter 3 $ifnam $ofnam 440 20
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        LOWPASS FILTERING INPUT SPECTRUM"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN LOWPASS FILTERING OF INPUT SPECTRUM"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO LOWPASS FILTER INPUT SPECTRUM"
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO LOWPASS FILTERED VERSION OF INPUT SPECTRUM CREATED"
		UnBlock
		return 0
	}

	set ifnam $ofnam
	set ofnam [file rootname $segment(bakupsnd)]
	append ofnam $evv(ANALFILE_EXT)
	set c_chans [expr $pa($segment(ana,0),$evv(CHANS))/2]

	set cmd [file join $evv(CDPROGRAM_DIR) pitch]
	lappend cmd tune 2 $ifnam $ofnam $respitch -f1.0 -c1.0 -t$c_chans -b10.0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        TUNING FILTERED INPUT SPECTRUM"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN TUNING OF FILTERED INPUT SPECTRUM"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO CREATE WAVEFORM OF TRANSPOSED INPUT SOUND"
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO WAVEFORM OF TRANSPOSED INPUT SOUND CREATED"
		UnBlock
		return 0
	}
	
	set ifnam $ofnam
	set ofnam $segment(bakupsnd)

	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd synth $ifnam $ofnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF TUNED INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN WAVEFORM CREATION ON TUNED INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO CREATE WAVEFORM OF TUNED INPUT SOUND"
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO WAVEFORM OF TUNED INPUT SOUND CREATED"
		UnBlock
		return 0
	}

	set ifnam $ofnam
	set ofnam $segment(othersnd)

	set cmd [file join $evv(CDPROGRAM_DIR) filter]
	lappend cmd lohi 1 $ifnam $ofnam -96 2000 2500 -t0 -s1
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING LOPASS FILTERING OF TUNED INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN LOPASS FILTER ON TUNED INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE LOPASS FILTERED TUNED INPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO LOPASS FILTERED TUNED INPUT SOUND CREATED"
		UnBlock
		return 0
	}

	set ifnam $ofnam
	set ofnam $segment(fadesnd)

	set cmd [file join $evv(CDPROGRAM_DIR) modify]
	lappend cmd revecho 3 $ifnam $ofnam -g0.645654 -r1 -s$stadsiz -e$echocnt -n
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING REVERBERATION ON TRANSPOSED INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN REVERBERATION FOR THE INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE REVERBERATED TRANSPOSED INPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO REVERBERATED TRANSPOSED INPUT SOUND CREATED"
		UnBlock
		return 0
	}
	set revfnam $ofnam

	set ifnam $segment(ana,0)
	set ofnam [file rootname $segment(fadesnd)]
	append ofnam $evv(ANALFILE_EXT)
	set m_ode 8
	set params [list $segment(PAR1) $segment(PAR1) $segment(PAR1) $segment(PAR1)]
	set cmd [file join $evv(CDPROGRAM_DIR) specfnu]
	lappend cmd specfnu $m_ode $ifnam $ofnam
	set cmd [concat $cmd $params]
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING FREQUENCY SHIFT OF INPUT SPECTRUM"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "FAILED TO RUN FREQUENCY SHIFT OF INPUT SPECTRUM"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "FAILED TO FREQUENCY SHIFT THE INPUT SPECTRUM"
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO FREQUENCY SHIFTED INPUT SPECTRUM CREATED"
		UnBlock
		return 0
	}
	set ifnam $ofnam
	set ofnam $segment(specfnusnd)

	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd synth $ifnam $ofnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RESYNTHESIZING SHIFTED SPECTRUM OF INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN RESYNTHESIS OF SPECTRUM-SHIFTED INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE SPECTRUM-SHIFTED INPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO SPECTRUM-SHIFTED INPUT SOUND CREATED"
		UnBlock
		return 0
	}

	set ifnam $ofnam
	set ofnam $segment(exclmix)

	set cmd [file join $evv(CDPROGRAM_DIR) filter]
	lappend cmd lohi 1 $ifnam $ofnam -96 2500 2000 -t0 -s1
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING HIPASS FILTERING OF SHIFTED INPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN HIPASS FILTERING OF SHIFTED INPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE HIPASS FILTERED SHIFTED SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO HIPASS FILTERED SHIFTED SOUND CREATED"
		UnBlock
		return 0
	}

	set shffnam $ofnam

	catch {unset segment(mixlines)}
	set line [list $shffnam 0.0 1 $hfgain C]
	lappend segment(mixlines) $line
	set line [list $revfnam $toffset 2 1.0]
	lappend segment(mixlines) $line

	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixfil) TO MIX COMPONENTS"
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofPossiblyMultichanMixdown 1]} {
		UnBlock
		return 0
	}
	if [catch {file rename $segment(outfnamplay) $segment(premix)} zit] {
		Inf "CANNOT RENAME TEMPORARY MIXOUTPUT FILE $segment(outfnamplay)"
		UnBlock
		return 0
	}

	set ifnam $segment(premix)
	set ofnam $segment(outfnamplay)

	set cmd [file join $evv(CDPROGRAM_DIR) modify]
	lappend cmd revecho 3 $ifnam $ofnam -g0.645654 -r1 -s$stadsiz2 -e$echocnt2 -n
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        RUNNING REVERBERATION ON OUTPUT SOUND"
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "FAILED TO RUN REVERBERATION FOR THE OUTPUT SOUND"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "FAILED TO CREATE REVERBERATED OUTPUT SOUND"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {![file exists $ofnam]} {
		Inf "NO REVERBERATED OUTPUT SOUND CREATED"
		UnBlock
		return 0
	}
	set segment(outfnamplay) $ofnam
	UnBlock
	return 1
}

proc TuberevStyle {} {
	global segment pr_tubrev tubrev tunehead tuneweighted pitchartic tv_active evv
	set segment(tuningcnt) 1
	set f .tubrev
	if [Dlg_Create $f "SET PITCH FOR TUBE RESONANCE" "set pr_tubrev 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_tubrev 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_tubrev 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_tubrev 0" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true

		frame $f.1
		checkbutton $f.1.1  -text "Text Entry" -variable tubrev -width 16 -command {set pr_tubrev [GettrofDataByTextEntry pitches]}
		frame $f.1.2
		if {$tv_active} {
			GettrofMakeKeyboardKey $f.1.2
		}
		label $f.1.3 -text "MIDI Kbd Entry" -width 16
		set tubrev 0
		pack $f.1.1 $f.1.2 $f.1.3 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_tubrev 1}
		bind $f <Escape> {set pr_tubrev 0}
	}
	if {$tv_active} {
		bind .tubrev.1.2.0   <ButtonPress-1> {}
		bind .tubrev.1.2.1.0 <ButtonPress-1> {}
		bind .tubrev.1.2.1.1 <ButtonPress-1> {}
		bind .tubrev.1.2.1.2 <ButtonPress-1> {}
		bind .tubrev.1.2.1.3 <ButtonPress-1> {}
		bind .tubrev.1.2.1.4 <ButtonPress-1> {}
		bind .tubrev.1.2.1.5 <ButtonPress-1> {}
		bind .tubrev.1.2.1.6 <ButtonPress-1> {}
		bind .tubrev.1.2.2.0 <ButtonPress-1> {}
		bind .tubrev.1.2.2.1 <ButtonPress-1> {}
		bind .tubrev.1.2.2.2 <ButtonPress-1> {}
		bind .tubrev.1.2.2.3 <ButtonPress-1> {}
		bind .tubrev.1.2.2.4 <ButtonPress-1> {}
		bind .tubrev.1.2.2.5 <ButtonPress-1> {}
		bind .tubrev.1.2.2.6 <ButtonPress-1> {}
		bind .tubrev.1.2.3   <ButtonPress-1> {}

		bind .tubrev.1.2.0   <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.0 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.1 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.2 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.3 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.4 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.5 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.1.6 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.0 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.1 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.2 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.3 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.4 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.5 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.2.6 <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
		bind .tubrev.1.2.3   <ButtonPress-1> "GettrofGetNoteData 0 .tubrev.1.2"
	}
	catch {unset segment(pitches)}
	set pr_tubrev 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_tubrev
	while {!$finished} {
		tkwait variable pr_tubrev
		switch -- $pr_tubrev {
			1 {
				if {![info exists segment(pitches)] || ([llength $segment(pitches)] <= 0)} {
					Inf "NO PITCHES SET"
					continue
				}
				if {[llength $segment(pitches)] > 1} {
					Inf "TOO MANY PITCHES SET"
					continue
				}
				set segment(par0) [lindex $segment(pitches) 0]
				set segment(PAR0) $segment(par0)
				set segment(lastpar0,TUBEREV) $segment(par0)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			3 {
				set tubrev 0
				continue							;#	If entry from text window fails		
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

#########
# SPIKE #
#########

proc SpikeStyle {} {
	global segment pr_spike tspike spspike tv_active spiknorm evv
	set segment(tempered) 0
	set segment(tuningcnt) [expr $segment(cnt)/2]	;#	Odd, headfirst			Even, headfirst		Odd, tailfirst		Even, tailfirst
	if {$segment(headfirst)} {						;#	5->2					4->2				5->2				4->2
		if {![IsEven $segment(cnt)]} {				;#	H T H T H		Else	H T H T				T H T H T			T H T H
			incr segment(tuningcnt)					;#	2->3 heads				2 heads				2 heads				2 heads
		}
	}
	set segment(orig_tuningcnt) $segment(tuningcnt)
	set n 0
	set m 1
	if {!$segment(headfirst)} {
		incr n
		incr m
	}
	catch {unset segment(spikepos)}					;#	Initial default spike locations, 1/3 into joint H+T seg
	while {$n < $segment(cnt)} {
		set stt [lindex $segment(marklist) $n]
		if {$m >= $segment(cnt)} {
			set endd $segment(dur)
		} else {
			set endd [lindex $segment(marklist) $m]
		}
		set headlen [expr $endd - $stt]
		set spikepos [expr ($headlen/3) + $stt]
		lappend segment(spikepos) $stt				;#	TROF,HEAD,TROF triples
		lappend segment(spikepos) $spikepos
		lappend segment(spikepos) $endd
		incr n 2
		incr m 2
	}
	set segment(orig_spikepos) $segment(spikepos)

	set f .spike
	if [Dlg_Create $f "SET PARAMETERS FOR SPIKE" "set pr_spike 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_spike 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_spike 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		radiobutton $f.0.r1 -text "Specific Locations"  -variable spspike -value 1 -command "GettrofSpikeLocations" -width 18 
		radiobutton $f.0.r2 -text "1/3 into segment"    -variable spspike -value 0 -command "GettrofSpikeLocations" -width 18
		checkbutton $f.0.ch  -text "Normalise" -variable spiknorm -width 18
		set spiknorm 0
		button $f.0.q -text "Abandon"	   -command "set pr_spike 0" -width 8
		pack $f.0.s $f.0.l $f.0.h $f.0.r1 $f.0.r2 $f.0.ch -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true

		frame $f.1
		frame $f.1.00

		radiobutton $f.1.00.a  -text "As is"		  -variable segment(spiketyp) -value 0 -width 15 -command "SpikeStyleRedisplay 0"
		radiobutton $f.1.00.b  -text "Stacked"		  -variable segment(spiketyp) -value 1 -width 15 -command "SpikeStyleRedisplay 1"
		radiobutton $f.1.00.c  -text "Pitch-by-delay" -variable segment(spiketyp) -value 2 -width 15 -command "SpikeStyleRedisplay 2"
		radiobutton $f.1.00.d1 -text "Intrinsic" -variable segment(spikintrinsic) -value 1 -width 10 -command "SpikeStyleRedisplay 3"
		radiobutton $f.1.00.d2 -text "Explicit"  -variable segment(spikintrinsic) -value 0 -width 10 -command "SpikeStyleRedisplay 3"
		pack $f.1.00.a  $f.1.00.b $f.1.00.c $f.1.00.d1 $f.1.00.d2 -side left

		label $f.1.0 -text "" -width 22
		checkbutton $f.1.1  -text "Text Entry" -variable tspike -width 16 -command {set pr_spike [GettrofDataByTextEntry pitches]}
		frame $f.1.2
		if {$tv_active} {
			GettrofMakeKeyboardKey $f.1.2
		}
		label $f.1.3 -text "MIDI Kbd Entry" -width 16
		set tspike 0
		set tunehead 0
		pack $f.1.00 $f.1.0 $f.1.1 $f.1.2 $f.1.3 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_spike 1}
		bind $f <Escape> {set pr_spike 0}
	}
	set spspike -1
	set segment(spiketyp) -1
	.spike.1.00.a config -text ""  -state disabled -disabledforeground []
	.spike.1.00.b config -text ""  -state disabled -disabledforeground []
	.spike.1.00.c config -text ""  -state disabled -disabledforeground []
	set segment(spikintrinsic) -1
	.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
	.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
	SpikeStyleRedisplay 0

	if {$tv_active} {
		bind .spike.1.2.0   <ButtonPress-1> {}
		bind .spike.1.2.1.0 <ButtonPress-1> {}
		bind .spike.1.2.1.1 <ButtonPress-1> {}
		bind .spike.1.2.1.2 <ButtonPress-1> {}
		bind .spike.1.2.1.3 <ButtonPress-1> {}
		bind .spike.1.2.1.4 <ButtonPress-1> {}
		bind .spike.1.2.1.5 <ButtonPress-1> {}
		bind .spike.1.2.1.6 <ButtonPress-1> {}
		bind .spike.1.2.2.0 <ButtonPress-1> {}
		bind .spike.1.2.2.1 <ButtonPress-1> {}
		bind .spike.1.2.2.2 <ButtonPress-1> {}
		bind .spike.1.2.2.3 <ButtonPress-1> {}
		bind .spike.1.2.2.4 <ButtonPress-1> {}
		bind .spike.1.2.2.5 <ButtonPress-1> {}
		bind .spike.1.2.2.6 <ButtonPress-1> {}
		bind .spike.1.2.3   <ButtonPress-1> {}

		bind .spike.1.2.0   <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.0 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.1 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.2 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.3 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.4 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.5 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.1.6 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.0 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.1 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.2 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.3 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.4 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.5 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.2.6 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
		bind .spike.1.2.3   <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
	}
	catch {unset segment(pitches)}
	catch {unset segment(spikevals)}
	set pr_spike 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_spike
	while {!$finished} {
		tkwait variable pr_spike
		switch -- $pr_spike {
			1 {
				;#	STORE PARAMS FOR SPIKING, FOR EACH seg (A ZERO MEANS NO-SPIKING)
				
				if {$segment(spiketyp) < 0} {
					Inf "NO SPIKE STYLE SET"
					continue
				}
				if {[llength $segment(spikepos)] <= 0} {			;#	Probably redundant
					Inf "NO SPIKE TIMES SET"
					continue
				}
				if {$segment(spiketyp) == 1} {
					if {![info exists segment(chords)]} {
						Inf "NO CHORD SET"
						continue
					}
				} elseif {$segment(spiketyp) == 2} {
					if {$segment(spikintrinsic)} {
						set segment(intrinsic_pitch) 1
					} else {
						set segment(intrinsic_pitch) 0
						if {![info exists segment(pitches)] || ([llength $segment(pitches)] <= 0)} {
							Inf "NO PITCHES SET"
							continue
						}
					}
				}
				switch -- $segment(spiketyp) {
					0 -
					1 {
						set segment(dflt3,SPIKE) 2.5	;#	Downslope
						set segment(dflt5,SPIKE) 0.3	;#	Down Maxdur
					}
					2 {
						set segment(dflt3,SPIKE) 5		;#	Downslope
						set segment(dflt5,SPIKE) 0.1	;#	Down Maxdur
					}
				}
				set segment(par0) $segment(spiketyp)
				set segment(PAR0) $segment(par0)
				set segment(lastpar0,SPIKE) $segment(par0)

				set segment(par1) $spiknorm
				set segment(PAR1) $segment(par1)
				set segment(lastpar1,SPIKE) $segment(par1)

				set segment(control1) 0						;#	Default, NO Pitch
				if {$segment(spiketyp) == 1} {
					set segment(control1) [StripCurlies $segment(chords)]
				} elseif {($segment(spiketyp) == 2) && !$segment(intrinsic_pitch)} {
					set segment(control1) $segment(pitches)
				}
				set segment(lastcontrol1,$segment(process)) $segment(control1) ;#	Ensures data is remembered and can be stored in a patch

				set segment(control2) $segment(spikepos)
				set segment(lastcontrol2,$segment(process)) $segment(control2)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			3 {
				set tspike 0
				continue							;#	If entry from text window fails		
			}
			0 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

proc SpikeStyleRedisplay {typ} {
	global segment tv_active
	switch -- $typ {
		0 {
			if {$tv_active} {
				GettrofHideKeyboardKey .spike.1.2
				.spike.1.3 config -text ""
			}
			set segment(tuningcnt) $segment(orig_tuningcnt)
			.spike.1.0 config -text ""
			.spike.1.1  config -text "" -state disabled -command {} -disabledforeground []
			.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
			.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
			catch {unset segment(spike_explicit)}
		}
		1 {			;#	Stack
			set segment(tuningcnt) 1
			.spike.1.0 config -text "1 CHORD RELATIVE TO C60"
			if {$tv_active} {
				GettrofShowKeyboardKey .spike.1.2	
				.spike.1.3 config -text "MIDI Kbd Entry"
				bind .spike.1.2.0   <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.0 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.1 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.2 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.3 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.4 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.5 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.1.6 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.0 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.1 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.2 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.3 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.4 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.5 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.2.6 <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
				bind .spike.1.2.3   <ButtonPress-1> "GettrofGetNoteData 1 .spike.1.2"
			}
			.spike.1.1  config -text "Text Entry" -state normal -command {set pr_spike [GettrofDataByTextEntry chords]}
			.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
			.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
			catch {unset segment(spike_explicit)}
		}
		2 {		;#	Pitches for delay-tuning : intrinsic or to be entered ?
			catch {unset segment(spike_explicit)}		;#	Probably redundant
			set segment(spikintrinsic) -1
			.spike.1.00.d1 config -text "Intrinsic" -state normal
			.spike.1.00.d2 config -text "Explicit"  -state normal
			if {$tv_active} {
				GettrofHideKeyboardKey .spike.1.2
				.spike.1.3 config -text ""
			}
			.spike.1.0 config -text ""
			.spike.1.1  config -text "" -state disabled -command {} -disabledforeground []
		}
		3 {		;#	Pitches for delay-tuning
			set segment(tuningcnt) $segment(orig_tuningcnt)
			if {$segment(spikintrinsic)} {
				.spike.1.0 config -text ""
				.spike.1.1  config -text "" -state disabled -command {} -disabledforeground []
				if {$tv_active} {
					GettrofHideKeyboardKey .spike.1.2
					.spike.1.3 config -text ""
				}
				catch {unset segment(spike_explicit)}
			} else {
				.spike.1.0 config -text "$segment(tuningcnt) PITCHES" -width 22
				if {$tv_active} {
					GettrofShowKeyboardKey .spike.1.2	
					.spike.1.3 config -text "MIDI Kbd Entry"
					bind .spike.1.2.0   <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.0 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.1 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.2 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.3 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.4 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.5 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.1.6 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.0 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.1 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.2 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.3 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.4 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.5 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.2.6 <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
					bind .spike.1.2.3   <ButtonPress-1> "GettrofGetNoteData 0 .spike.1.2"
				}
				.spike.1.1  config -text "Text Entry" -state normal -command {set pr_spike [GettrofDataByTextEntry pitches]}
				set segment(spike_explicit) 1
			}
		}
	}
}

proc GettrofSpikeLocations {} {
	global pr_spike spspike segment wstk
	switch -- $spspike {
		0 {
			set segment(spikepos) $segment(orig_spikepos)
			set segment(tuningcnt) $segment(orig_tuningcnt)
			set segment(spiketyp) -1
			.spike.1.00.a config -text "As is"		    -state normal
			.spike.1.00.b config -text "Stacked"		-state normal
			.spike.1.00.c config -text "Pitch-by-delay" -state normal
			set segment(spikintrinsic) -1
			.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
			.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
			SpikeStyleRedisplay 0
		}
		1 {
			set get_spikepos 0
			if {[info exists segment(new_spikepos)]} {
				set msg "KEEP PREVIOUS IMPOSED SPIKE POSITIONS ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set segment(spikepos) $segment(new_spikepos)
					set segment(tuningcnt) [llength $segment(spikepos)]
					set segment(spiketyp) -1
					.spike.1.00.a config -text "As is"		    -state normal
					.spike.1.00.b config -text "Stacked"		-state normal
					.spike.1.00.c config -text "Pitch-by-delay" -state normal
					set segment(spikintrinsic) -1
					.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
					.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
					SpikeStyleRedisplay 0
				} else {
					set get_spikepos 1
				}
			} else {
				set get_spikepos 1
			}
			if {$get_spikepos} {
				if {[GetSpikePositions]} {
					set segment(tuningcnt) [llength $segment(spikepos)]
					set segment(spiketyp) -1
					.spike.1.00.a config -text "As is"		    -state normal
					.spike.1.00.b config -text "Stacked"		-state normal
					.spike.1.00.c config -text "Pitch-by-delay" -state normal
					set segment(spikintrinsic) -1
					.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
					.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
					SpikeStyleRedisplay 0
				} else {
					set segment(spikepos) $segment(orig_spikepos)
					set segment(tuningcnt) $segment(orig_tuningcnt)
					set segment(spiketyp) -1
					.spike.1.00.a config -text "" -state disabled -disabledforeground []
					.spike.1.00.b config -text "" -state disabled
					.spike.1.00.c config -text "" -state disabled
					set segment(spikintrinsic) -1
					.spike.1.00.d1 config  -text "" -state disabled -disabledforeground []
					.spike.1.00.d2 config  -text "" -state disabled -disabledforeground []
					set spspike -1
					SpikeStyleRedisplay 0
				}
			}
		}
	}
}

#---- Enter spike positions on waveform display

proc GetSpikePositions {} {					
	global segment evv
	set segment(spike_explicit) 1
	catch {unset segment(exportsegs)}								;#	Ensure, export segments is not called
	SnackDisplay $evv(SN_TIMESLIST) troflist $segment(src,0) 0
	unset segment(spike_explicit)
	if {![info exists segment(spikepos)] || ([llength $segment(spikepos)] <= 0)} {
		set segment(spikepos) $segment(orig_spikepos)
		return 0
	} else {
		set segment(new_spikepos) $segment(spikepos)
	}
	return 1
}

proc DoSpike {} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	;#	CONVERT SEGMENTS TO PHRASE SEGMENTATION

	set segment(conv) 1
	set segment(oldmarks) $segment(marklist)
	set segment(oldheadfirst) $segment(headfirst)
	set segment(oldcnt) $segment(cnt)
	if {![ConvertHTDataToPhraseData]} {
		return 0
	}

	if {!$segment(oldheadfirst)} {		;#	DON'T KEEP THE INITIAL TAIL, IF ANY
		set segment(marklist) [lreplace $segment(marklist) 0 0 [lindex $segment(oldmarks) 1]]
	}

	DeleteAllTemporaryFilesExcept $segment(nutroflist)

	;#	SEGMENT THE SOUND AS H/T PAIRS

	if {![SegmentSound 1]} {	
		SegReset
		return 0
	}
	;#	MAKE AN INITIAL (UNTRANSFORMED) MIXFILE FROM SEGMENTS

	set times $segment(marklist)						;#	Get times from marklist
	set times [lreplace $times end end]					;#	Delete AFTER END time from marklist
	set len [llength $times]
	set firsttime [lindex $times 0]
	if {$firsttime > 0.0} {								;#	IF start time is not zero, shuffle timelist to start at zero				
		set n 0
		while {$n < $len} {
			set time [expr [lindex $times $n] - $firsttime]
			if {$time < 0.0} {
				set time 0.0
			}
			set times [lreplace $times $n $n $time]
			incr n
		}
	}
	set n 1
	while {$n < $len} {									;#		Allow for upsplice in output mix (except for 1st file)
		set time [expr [lindex $times $n] - $segment(SPLICE)]
		if {$time < 0.0} {
			set time 0.0
		}
		set times [lreplace $times $n $n $time]
		incr n
	}
	catch {unset segment(mixlines)}
	set m 1
	foreach time $times {
		set ffnam $evv(DFLT_OUTNAME)
		append ffnam "HH" $m $evv(SNDFILE_EXT)
		set mixline [list $ffnam $time 1 1.0]
		lappend segment(mixlines) $mixline
		incr m
	}		
	
	;#	IF PITCHING WITH INTRINSIC PITCH

	if {[info exists segment(intrinsic_pitch)] && $segment(intrinsic_pitch)} {

		Block "PLEASE WAIT: EXTRACTING PITCHES OF THE SEGMENTS"

		if {![ExtractIntrinsicPitches 0]} {
			SegReset
			UnBlock
			return 0
		}
		UnBlock
	}

	if {[file exists $segment(specfnusnd)] && [catch {file delete $segment(specfnusnd)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE SOUNDFILE $segment(specfnusnd)"
		SegReset
		return 0
	}
	if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
		Inf "CANNOT DELETE INTERMEDIATE TEXTFILE $segment(notedata)"
		SegReset
		return 0
	}

	set spiktyp  $segment(PAR0)
	set normlise $segment(PAR1)
	set upslope  $segment(PAR2)
	set dnslope  $segment(PAR3)
	set upmaxdur $segment(PAR4)
	set dnmaxdur $segment(PAR5)

	set spikpitches $segment(control1)
	set spiktimes	$segment(control2)

	if {$spiktyp == 1} {		;#	STACKED PITCH

		;#	CONVERTED ENTERED PITCHES TO TRANSPOSITIONS, AND CACLULATE THE MAXIMUM TIME-EXPANSION FACTOR CAUSED BY STACKING

		set mintranspos 10000
		catch {unset transposes}
		foreach pitch $spikpitches {
			set transpos [expr $pitch - $segment(MIDDLE_C)]		;#	Transposition relative to Middle C
			if {$transpos < $mintranspos} {
				set mintranspos $transpos
			}
			lappend transposes $transpos
		}
		set frqshift [expr pow(2.0,($mintranspos/$evv(SEMITONES_PER_OCTAVE)))]	;#	e.g. mintranspos = -12
		set spikmaxexpand [expr 1.0/$frqshift]									;#	frqshift = 1/2
																				;#	time-expansion = 2.0
		set staksize [llength $spikpitches]
		if [catch {open $segment(notedata) "w"} zit] {
			Inf "CANNOT OPEN TEMPORARY DATA FILE $segment(notedata) TO WRITE TUNING DATA FOR SPIKE STACKS : $zit"	
			SegReset
			return 0
		}
		foreach transpos $transposes {
			puts $zit $transpos
		}
		close $zit
	}

	Block "PLEASE WAIT: RUNNING SPIKE"
	set failed_msg ""

	switch -- $spiktyp {
		0 {
			;#	AS IS : RUN SPIKE ON ENTIRE INPUT SOUND
		
			if [catch {open $segment(notedata) "w"} zit] {
				Inf "CANNOT OPEN TEMPORARY DATA FILE $segment(notedata) TO WRITE SPIKE TIMES DATA : $zit"	
				UnBlock
				SegReset
				return 0
			}
			foreach spiktime $spiktimes {
				puts $zit $spiktime
			}

			close $zit
			set ifnam $segment(src,0)
			set ofnam $segment(specfnusnd)
			set cmd [file join $evv(CDPROGRAM_DIR) spike]
			lappend cmd spike $ifnam $ofnam $segment(notedata) $upslope $dnslope
			if {$upmaxdur > 0} {
				lappend cmd -u$upmaxdur
			}
			if {$dnmaxdur > 0} {
				lappend cmd -d$dnmaxdur
			}
			if {$normlise} {
				lappend cmd -n
			}
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}

			wm title .blocker "PLEASE WAIT:        RUNNING SPIKE ON INPUT SOUND"

			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO RUN SPIKE ON INPUT SOUND"
				catch {unset CDPidrun}
				UnBlock
				SegReset
				return 0
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CREATE SPIKED INPUT SOUND"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				SegReset
				return 0
			}
			if {![file exists $ofnam]} {
				Inf "NO SPIKED INPUT SOUND CREATED"
				UnBlock
				SegReset
				return 0
			}
			;#	AS IS : CUT OUT SPIKED SEGS AND INSERT IN OUTPUT MIX
		
			set segno 0
			set segcnt 1
			set spkcnt 0
			set spikedone 0

			set nn 0
			catch {unset nutimes}
			foreach ttim $spiktimes {					;#	Get peak position forn Trof-Pk-Trof triples
				if {[expr $nn % 3] == 1} {
					lappend nutimes $ttim
				}
				incr nn
			}
			set spiktimes $nutimes
			set spklen [llength $spiktimes]
	
			wm title .blocker "PLEASE WAIT:        CUTTING SPIKED SEGMENTS AND INSERTING IN MIX"
	
			while {$segno < $segment(cnt)} {						;#	For every segment
				set stt [lindex $segment(marklist) $segno]
				if {$segcnt < $segment(cnt)} {
					set endd [lindex $segment(marklist) $segcnt]
				} else {
					set endd $segment(dur)
				}
				set spiktime [lindex $spiktimes $spkcnt]

				if {$spiktime < $endd} {						;#	If spike falls within segment	
					set OK 1									;#	Cut the spiked segment from whole spikesfile
					while {$OK} {								;#	and replace org segment in mixlines by this new segment
						set ifnam $ofnam
						set cfnam $evv(MACH_OUTFNAME)
						append cfnam "PZ" $segcnt $evv(SNDFILE_EXT)
						set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
						lappend cmd cut 1 $ifnam $cfnam $stt $endd -w$segment(MSPLICE)
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}

						wm title .blocker "PLEASE WAIT:        CUTTING SPIKED SEGMENT $segcnt"

						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "FAILED TO RUN CUT PROCESS FOR SPIKED SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO CUT SPIKED SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $cfnam]} {
							append failed_msg "NO SPIKED SEGMENT $segcnt CREATED\n"
							break
						}
						set mixline [lindex $segment(mixlines) $segno]
						set mixline [lreplace $mixline 0 0 $cfnam]
						set segment(mixlines) [lreplace $segment(mixlines) $segno $segno $mixline]
						set spikedone 1
						break
					}
					incr spkcnt
				}
				if {$spkcnt >= $spklen} {							;#	If we're out of spikes, quit
					break
				}
				incr segno
				incr segcnt
			}
		}
		1 {			;#	STACKED

			if {$normlise} {

				wm title .blocker "PLEASE WAIT:        FINDING MAXLEVEL IN SOURCE SOUND"
	
				catch {unset maxsamp_line}
				set done_maxsamp 0
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				lappend cmd $segment(src,0)
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' TO FIND MAXLEVEL OF INPUT FILE"
					UnBlock
					SegReset
					return 0
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {[info exists maxsamp_line]} {
					set maxwholefile [lindex $maxsamp_line 0]
					if {$maxwholefile <= 0.0} {
						Inf "INPUT FILE HAS ZERO LEVEL"
						UnBlock
						SegReset
						return 0
					}
					if {$maxwholefile > $segment(normlev)} {
						set maxwholefile $segment(normlev)
					}
				} else {
					Inf "FAILED TO FIND MAXLEVEL OF INPUT FILE"
					UnBlock
					SegReset
					return 0
				}
			}
			set nn 0
			catch {unset nutimes}
			foreach ttim $spiktimes {					;#	Get peak position forn Trof-Pk-Trof triples
				if {[expr $nn % 3] == 1} {
					lappend nutimes $ttim
				}
				incr nn
			}
			set spiktimes $nutimes
			set spklen [llength $spiktimes]

			set segno 0
			set segcnt 1
			set spkcnt 0
			set spikedone 0
			while {$segno < $segment(cnt)} {						;#	For every segment
				set stt [lindex $segment(marklist) $segno]
				if {$segcnt < $segment(cnt)} {
					set endd [lindex $segment(marklist) $segcnt]
				} else {
					set endd $segment(dur)
				}
				set spiktime [lindex $spiktimes $spkcnt]

				if {$spiktime < $endd} {							;#	If spike falls within segment	
					set OK 1
					while {$OK} {

						set ifnam [lindex [lindex $segment(mixlines) $segno] 0]

						;#	FIND LOCATION OF MAXSAMPLE IN SEGMENT

						wm title .blocker "PLEASE WAIT:        FINDING MAXLEVEL LOCATION IN SEGMENT $segcnt"

						catch {unset maxsamp_line}
						set done_maxsamp 0
						set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
						lappend cmd $ifnam
						if [catch {open "|$cmd"} CDPmaxId] {
							append failed_msg "FAILED TO FIND MAXLEVEL LOCATION OF SEGMENT $segcnt\n"
							set loc [expr int(round(($segment(itemdur)/2.0) * $segment(srate))))]	;#	Default location halfway through segment
							break
	   					} else {
	   						fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
						}
	 					vwait done_maxsamp
						if {[info exists maxsamp_line]} {
							set maxinseg [lindex $maxsamp_line 0]
							if {$maxinseg <= 0.0} {
								append failed_msg "SEGMENT $segcnt HAS ZERO LEVEL\n"
								break
							}
							set loc		 [lindex $maxsamp_line 1]
							set loc [expr double($loc)/double($segment(srate))]
						} else {
							append failed_msg "FAILED TO FIND LOCATION MAX LEVEL IN SEGMENT $segcnt\n"
							break
						}
						;#	RUN (NORMALISED) STACK

						wm title .blocker "PLEASE WAIT:        STACKING SEGMENT $segcnt"

						set ofnam $evv(DFLT_OUTNAME)
						append ofnam "PH" $segcnt $evv(SNDFILE_EXT)

						set cmd [file join $evv(CDPROGRAM_DIR) modify]
						lappend cmd stack $ifnam $ofnam $segment(notedata) $staksize 1 $loc 1 1 -n
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        STACKING SEGMENT $segcnt"
						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "FAILED TO RUN STACKING PROCESS FOR SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO STACK SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $ofnam]} {
							append failed_msg "NO STACKED SEGMENT $segcnt CREATED\n"
							break
						}
	
						;#	CUT SEGLEN FROM (EXPANDED-LEN) STACK, KEEPING MAXLOC IN PLACE

						wm title .blocker "PLEASE WAIT:        CUTTING STACKED SEGMENT $segcnt TO SIZE"

						set ifnam $ofnam
						set ofnam $evv(MACH_OUTFNAME)
						append ofnam "PP" $segcnt $evv(SNDFILE_EXT)

						set origseglen [expr $endd - $stt]
						if {$segno > 0.0} {		
							set origseglen [expr $origseglen + $segment(SPLICE)]	;# L
						}															;#			 ~~~~L~~~~
						set origpeakpos  [expr $spiktime - $stt]					;# o		 ~o~
																					;# 			|__|______|
																					;#
						set newseglen    [expr $origseglen * $spikmaxexpand]		;#		 ~~~~~~~~~~~~N~~~~~~~~~~~~	
						set peakposratio [expr $origpeakpos/$origseglen]			;#		 ~~n~~~
						set newpeakpos	 [expr $newseglen * $peakposratio]			;# n	|______|__________________|
						set peakshift	 [expr $newpeakpos - $origpeakpos]			;#
						set segcutend	 [expr $peakshift + $origseglen]			;#		(n-o)~~~~L~~~~    
																					;#		|---|__|______|-----------|     

						set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
						lappend cmd cut 1 $ifnam $ofnam $peakshift $segcutend -w$segment(MSPLICE)
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}

						wm title .blocker "PLEASE WAIT:        TRIMMING STACKED SEGMENT $segcnt"

						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "FAILED TO RUN TRIMMING PROCESS FOR STACKED SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO TRIM STACKED SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $ofnam]} {
							append failed_msg "NO TRIMMED STACKED SEGMENT $segcnt CREATED\n"
							break
						}

						;#	DO THE SPIKE

						if {[file exists $segment(notedata2)] && [catch {file delete $segment(notedata2)} zit]} {
							append failed_msg "CANNOT DELETE INTERMEDIATE TEXTFILE $segment(notedata2) FOR SEGMENT $segcnt\n"
							break
						}
						if {![DoSegmentDurParse $ofnam]} {
							append failed_msg "FAILED TO FIND DURATION OF TRIMMED STACKED SEGMENT $segcnt\n"
							break
						} else {
							set end_trof [expr $segment(itemdur) - $evv(FLTERR)]
						}
						set seg_spiktimes [list 0 $origpeakpos $end_trof]
						if [catch {open $segment(notedata2) "w"} zit] {
							append failed_msg "CANNOT OPEN INTERMEDIATE TEXTFILE $segment(notedata2) TO WRITE SPIKE DATA FOR SEGMENT $segcnt\n"
							break
						}
						foreach val $seg_spiktimes {
							puts $zit $val
						}
						close $zit

						set ifnam $ofnam
						set ofnam $evv(MACH_OUTFNAME)
						append ofnam "HX" $segcnt $evv(SNDFILE_EXT)

						set cmd [file join $evv(CDPROGRAM_DIR) spike]
						lappend cmd spike $ifnam $ofnam $segment(notedata2) $upslope $dnslope
						if {$upmaxdur > 0} {
							lappend cmd -u$upmaxdur
						}
						if {$dnmaxdur > 0} {
							lappend cmd -d$dnmaxdur
						}
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}

						wm title .blocker "PLEASE WAIT:        RUNNING SPIKE ON STACKED SEGMENT $segcnt"

						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "FAILED TO RUN SPIKE ON STACKED SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO CREATE SPIKED STACKED SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $ofnam]} {
							append failed_msg "NO SPIKED STACKED SEGMENT $segcnt CREATED\n"
							break
						}

						;#	ADJUST LEVEL

						wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SPIKED SEGMENT $segcnt"

						set cfnam $evv(MACH_OUTFNAME)
						append cfnam "PH" $segcnt $evv(SNDFILE_EXT)

						set ifnam $ofnam

						set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
						catch {unset maxsamp_line}
						set done_maxsamp 0
						lappend cmd $ifnam
						if [catch {open "|$cmd"} CDPmaxId] {
							append failed_msg "FAILED TO FIND MAXLEVEL OF OUTPUT SEGMENT $segcnt\n"
							break
	   					} else {
	   						fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
						}
	 					vwait done_maxsamp
						if {![info exists maxsamp_line]} {
							append failed_msg "CANNOT RETRIEVE MAXIMUM SAMPLE OF OUTPUT SEGMENT $segcnt\n"
							break
						}
						set prelevel [lindex $maxsamp_line 0]
						if {$prelevel <= 0.0} {
							append failed_msg "OUTPUT SEGMENT $segcnt HAS ZERO LEVEL\n"
							break
						}
						if {$normlise} {
							set gain [expr $maxwholefile/$prelevel]
						} else {
							set gain [expr $maxinseg/$prelevel]
						}

						wm title .blocker "PLEASE WAIT:        ADJUSTING LEVEL OF SPIKED SEGMENT $segcnt"

						set cmd [file join $evv(CDPROGRAM_DIR) modify]
						lappend cmd loudness 1 $ifnam $cfnam $gain
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "CANNOT NORMALISE LEVEL OF OUTPUT SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "CANNOT RUN PROCESS TO NORMALISE OUTPUT SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $cfnam]} {
							append failed_msg "NO NORMALISED OUTPUT SEGMENT $segcnt CREATED"\n
							break
						}
						set mixline [lindex $segment(mixlines) $segno]
						set mixline [lreplace $mixline 0 0 $cfnam]
						set segment(mixlines) [lreplace $segment(mixlines) $segno $segno $mixline]
						set spikedone 1
						break
					}
					incr spkcnt
				}
				if {$spkcnt >= $spklen} {
					break
				}
				incr segcnt
				incr segno
			}
		}
		2 {			;#	PITCHED

			if {$normlise} {

				wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF INPUT SOURCE"
	
				catch {unset maxsamp_line}
				set done_maxsamp 0
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				lappend cmd $segment(src,0)
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' TO FIND MAXLEVEL OF INPUT FILE"
					UnBlock
					SegReset
					return 0
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {[info exists maxsamp_line]} {
					set maxwholefile [lindex $maxsamp_line 0]
					if {$maxwholefile  <= 0.0} {
						Inf "INPUT FILE HAS ZERO LEVEL"
						UnBlock
						SegReset
						return 0
					}
					if {$maxwholefile > $segment(normlev)} {
						set maxwholefile $segment(normlev)
					}
				} else {
					Inf "FAILED TO FIND MAXLEVEL OF INPUT FILE"
					UnBlock
					SegReset
					return 0
				}
			}

			set nn 0
			catch {unset nutimes}
			foreach ttim $spiktimes {					;#	Get peak position forn Trof-Pk-Trof triples
				if {[expr $nn % 3] == 1} {
					lappend nutimes $ttim
				}
				incr nn
			}
			set spiktimes $nutimes
			set spklen [llength $spiktimes]

			set segno 0
			set segcnt 1
			set spkcnt 0
			set spikedone 0
			while {$segno < $segment(cnt)} {						;#	For every segment
				set stt [lindex $segment(marklist) $segno]
				if {$segcnt < $segment(cnt)} {
					set endd [lindex $segment(marklist) $segcnt]
				} else {
					set endd $segment(dur)
				}
				set spiktime [lindex $spiktimes $spkcnt]

				if {$spiktime < $endd} {						;#	If spike falls within segment	
					set OK 1
					while {$OK} {

						set ifnam [lindex [lindex $segment(mixlines) $segno] 0]
						set origseglen [expr $endd - $stt]
						if {$segno > 0} {
							set origseglen [expr $origseglen + $segment(SPLICE)]
						}
						set origpeakpos [expr $spiktime - $stt]
						if {$segno > 0} {
							set origpeakpos [expr $origpeakpos + $segment(SPLICE)]
						}
						if {!$normlise} {

							wm title .blocker "PLEASE WAIT:        FINDING LEVEL OF SEGMENT $segcnt"

							catch {unset maxsamp_line}
							set done_maxsamp 0
							set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
							lappend cmd $ifnam
							if [catch {open "|$cmd"} CDPmaxId] {
								append failed_msg "FAILED TO RUN 'maxsamp2$evv(EXEC)' TO FIND MAXLEVEL OF SEGMENT $segcnt\n"
								break
	   						} else {
	   							fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
							}
	 						vwait done_maxsamp
							if {[info exists maxsamp_line]} {
								set maxinseg [lindex $maxsamp_line 0]
							} else {
								append failed_msg "FAILED TO FIND MAXLEVEL OF SEGMENT $segcnt\n"
								break
							}
							if {$maxinseg <= 0.0} {
								append failed_msg "SEGMENT $segcnt HAS ZERO LEVEL\n"
								break
							}
						}

						set ofnam $evv(MACH_OUTFNAME)
						append ofnam "PX" $segcnt $evv(SNDFILE_EXT)

						;#	GET TUNING DATA FOR CURRENT SEGMENT, AND RELATED DELAY

						set thistuning [lindex $segment(pitches) $spkcnt]	
						set frq [MidiToHz $thistuning]
						set del [expr $evv(SECS_TO_MS)/$frq]

						;#	DELAY PITCH, CHECKING LEVEL

						set gggain 1.0
						set OKK 1
						set OKK2 0
						set OKK3 0
						set pppcnt 1
						wm title .blocker "PLEASE WAIT:        DELAY-PITCHING SEGMENT $segcnt (pass $pppcnt)"
						while {!$OKK2} {
							if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
								Inf "CANNOT DELETE PREVIOUS PITCHED SEGMENT $segcnt, TO MODIFY LEVEL"
								set OKK 0
								break
							}
							set cmd [file join $evv(CDPROGRAM_DIR) modify]
							lappend cmd revecho 1 $ifnam $ofnam $del $segment(DELAYED_SIG_IN_MIX) $segment(FEEDBACK) $segment(DELAY_TAIL)
							if {$gggain < 1.0} {
								lappend cmd -p$gggain
							} 
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							wm title .blocker "PLEASE WAIT:        PITCHING SEGMENT $segcnt (pass $pppcnt)"
							if [catch {open "|$cmd"} CDPidrun] {
								append failed_msg "FAILED TO RUN PITCHING FOR SEGMENT $segcnt (pass $pppcnt)\n"
								catch {unset CDPidrun}
								set OKK 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "FAILED TO PITCH SEGMENT $segcnt (pass $pppcnt)"
								set msg [AddSimpleMessages $msg]
								append failed_msg "$msg\n"
								set OKK 0
								break
							}
							if {![file exists $ofnam]} {
								append failed_msg "NO PITCHED SEGMENT $segcnt CREATED\ (pass $pppcnt)"
								set OKK 0
								break
							}
							wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF PITCHED SEGMENT $segcnt (pass $pppcnt)"
							set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
							catch {unset maxsamp_line}
							set done_maxsamp 0
							lappend cmd $ofnam
							if [catch {open "|$cmd"} CDPmaxId] {
								Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' (pass $pppcnt)"
								set OKK 0
								break
	   						} else {
	   							fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
							}
	 						vwait done_maxsamp
							if {![info exists maxsamp_line]} {
								Inf "CANNOT RETRIEVE MAXIMUM SAMPLE OF PITCHED SEGMENT	$segcnt (pass $pppcnt)"
								set OKK 0
								break
							}
							set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
							if {$maxoutsamp <= 0.0} {
								Inf "PITCHED SEGMENT $segcnt (pass $pppcnt) IS SILENT"
								set OKK 0
								break
							}
							if {$OKK3} {
								break
							}

							if {$maxoutsamp > 0.98} {										;#	Gain close to 1.0 indicates output has probably overloadad
								set gggain [expr $gggain * 0.1]								;#	Reduce gain by factor of ten and re-run

							} elseif {($maxoutsamp < $segment(maxlev)) && ($gggain < 1.0)} {;#	If gain has been adjusted, but maxsamp now below max
								set gggain [expr ($segment(maxlev)/$maxoutsamp) * $gggain]	;#	reset gain to give a maximal non-distorted output
								set OK3 1													;#	and force loop-exit after next pass
							} else {
								set OKK2 1													;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
							}
							incr pppcnt
						}
						if {!$OKK} {
							break
						}

						;#	CUT SEGLEN FROM (EXPANDED-LEN) DELAY-PITCHED VERSION

						set ifnam $ofnam
						set ofnam $evv(MACH_OUTFNAME)
						append ofnam "PP" $segcnt $evv(SNDFILE_EXT)

						set cmd [file join $evv(CDPROGRAM_DIR) envel]
						lappend cmd curtail 1 $ifnam $ofnam [expr $origseglen - $segment(SPLICE)] $origseglen 0 -t0
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}

						wm title .blocker "PLEASE WAIT:        CUTTING REPITCHED SEGMENT $segcnt TO SIZE"

						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "FAILED TO RUN CUT PROCESS FOR REPITCHED SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO CUT REPITCHED SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $ofnam]} {
							append failed_msg "NO CUT REPITCHED SEGMENT $segcnt CREATED\n"
							break
						}

						if {![DoSegmentDurParse $ofnam]} {
							append failed_msg "FAILED TO FIND DURATION OF CUT REPITCHED SEGMENT $segcnt\n"
							break
						} else {
							set end_trof [expr $segment(itemdur) - $evv(FLTERR)]
						}
						;#	DO THE SPIKE

						if {[file exists $segment(notedata2)] && [catch {file delete $segment(notedata2)} zit]} {
							append failed_msg "CANNOT DELETE INTERMEDIATE TEXTFILE $segment(notedata2) FOR SEGMENT $segcnt\n"
							break
						}
						set seg_spiktimes [list 0 $origpeakpos $end_trof]
						if [catch {open $segment(notedata2) "w"} zit] {
							append failed_msg "CANNOT OPEN INTERMEDIATE TEXTFILE $segment(notedata2) TO WRITE SPIKE DATA FOR SEGMENT $segcnt\n"
							break
						}
						foreach val $seg_spiktimes {
							puts $zit $val
						}
						close $zit

						set ifnam $ofnam
						set ofnam $evv(MACH_OUTFNAME)
						append ofnam "HX" $segcnt $evv(SNDFILE_EXT)

						set cmd [file join $evv(CDPROGRAM_DIR) spike]
						lappend cmd spike $ifnam $ofnam $segment(notedata2) $upslope $dnslope
						if {$upmaxdur > 0} {
							lappend cmd -u$upmaxdur
						}
						if {$dnmaxdur > 0} {
							lappend cmd -d$dnmaxdur
						}
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}

						wm title .blocker "PLEASE WAIT:        RUNNING SPIKE ON REPITCHED SEGMENT $segcnt"

						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "FAILED TO RUN SPIKE ON REPITCHED SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "FAILED TO CREATE SPIKED REPITCHED SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $ofnam]} {
							append failed_msg "NO SPIKED REPITCHED SEGMENT $segcnt CREATED\n"
							break
						}

						;#	ADJUST LEVEL

						set ifnam $ofnam
						set cfnam $evv(MACH_OUTFNAME)
						append cfnam "PH" $segcnt $evv(SNDFILE_EXT)

						wm title .blocker "PLEASE WAIT:        ADJUSTING LEVEL OF OUTPUT SEGMENT $segcnt"

						set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
						catch {unset maxsamp_line}
						set done_maxsamp 0
						lappend cmd $ifnam
						if [catch {open "|$cmd"} CDPmaxId] {
							append failed_msg "FAILED TO FIND MAXLEVEL OF OUTPUT SEGMENT $segcnt\n"
							break
	   					} else {
	   						fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
						}
	 					vwait done_maxsamp
						if {![info exists maxsamp_line]} {
							append failed_msg "CANNOT RETRIEVE MAXIMUM SAMPLE OF OUTPUT SEGMENT $segcnt\n"
							break
						}
						set prelevel [lindex $maxsamp_line 0]
						if {$prelevel <= 0.0} {
							append failed_msg "OUTPUT SEGMENT $segcnt HAS ZERO LEVEL\n"
							break
						}
						if {$normlise} {
							set gain [expr $maxwholefile/$prelevel]
						} else {
							set gain [expr $maxinseg/$prelevel]
						}
						set cmd [file join $evv(CDPROGRAM_DIR) modify]
						lappend cmd loudness 1 $ifnam $cfnam $gain
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							append failed_msg "CANNOT NORMALISE LEVEL OF OUTPUT SEGMENT $segcnt\n"
							catch {unset CDPidrun}
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "CANNOT RUN PROCESS TO NORMALISE OUTPUT SEGMENT $segcnt"
							set msg [AddSimpleMessages $msg]
							append failed_msg "$msg\n"
							break
						}
						if {![file exists $cfnam]} {
							append failed_msg "NO NORMALISED OUTPUT SEGMENT $segcnt CREATED"\n
							break
						}
						set mixline [lindex $segment(mixlines) $segno]
						set mixline [lreplace $mixline 0 0 $cfnam]
						set segment(mixlines) [lreplace $segment(mixlines) $segno $segno $mixline]
						set spikedone 1
						break
					}						
					incr spkcnt
				}
				if {$spkcnt >= $spklen} {
					break
				}
				incr segcnt
				incr segno
			}
		}
	}
	if {!$spikedone} {
		Inf "NO SPIKES RETAINED"
		UnBlock
		SegReset
		return 0
	}
	if {[string length $failed_msg] > 0} {
		Inf $failed_msg
	}
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixfil) TO MIX COMPONENTS"
		UnBlock
		SegReset
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofPossiblyMultichanMixdown 1]} {
		UnBlock
		SegReset
		return 0
	}
	UnBlock
	return 1
}

#---- Reset segment variables after returning from process that converts separate H and T segs to joined HT segs

proc SegReset {} {
	global segment
	catch {unset segment(intrinsic_pitch)}
	set segment(marklist)  $segment(oldmarks)
	set segment(headfirst) $segment(oldheadfirst)
	set segment(cnt)	   $segment(oldcnt)
	unset segment(oldmarks)
	unset segment(oldheadfirst)
	unset segment(oldcnt)
	set segment(conv) 0
	set segment(phrase) 0
}

##############
# SQUEEZEBOX #
##############

;#	SPECIFY SEGS TO STRETCH
;#	Params (1) Squeeze (2) Stretch
;#	OR
;#	Params (1) Ratio of lengths (stretch/squeeze) (2) Tempo SEE ALPHA
;#
;#	STRETCH IS DONE WITH BRKPNT FILE
;#	STRETCH: The default time at which stretch begins is 0.1 or 1/2 way into seg - whichever is less
;#			0	1			0				1
;#			.1	1			dur/2			1
;#			.11	N			((dur/2)+0.01)	N
;#			100 N#			100				N
;#	
;#	Considerations ALPHA
;#		Ratio of lengths = 2  --> Lengths Sq 1/3 & Str 2/3	
;#		Ratio of lengths 1.73 --> Lengths Sq 1/(1 + 1.73) & Str 1.73/(1 + 1.73)	Stretch longer
;#		Ratio of lengths 0.73 --> Lengths Sq 1/(1 + 0.73) & Str 0.73/(1 + 0.73)	Stretch shorter
;#		SO Squeezed (R1) = 1/(1 + r) TO Stretched (R2) = r/(1+r)
;#		Lengthgoal for squeeze = (60/Tempo) * R1
;#		Input dur = D1
;#		Squeeze = R1/D1
;#		Lengthgoal for stretch = (60/Tempo) * R2
;#		Input dur = D2
;#		Stretch = R2/D2
;#

proc DoSqueezeBox {} {
	global segment evv maxsamp_line done_maxsamp CDPmaxId prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	set strsegs $segment(control1)			;#	Read the list of stretchable segments

	set nn 2								;#	Set variables to read the (possibly tvarying) other params		
	while {$nn <= $segment(vparams_cnt,$segment(process))} {
		set segment(zlim,$nn) [expr [llength $segment(control$nn,$segment(process))] - 1]
		set segment(zccnt,$nn) 0
		incr nn
	}

	catch {unset segment(mixlines)}
	set mixtime 0.0

	set segment(conv) 1
	set segment(oldmarks) $segment(marklist)
	set segment(oldheadfirst) $segment(headfirst)
	set segment(oldcnt) $segment(cnt)
	if {![ConvertHTDataToPhraseData]} {
		return 0
	}

	if {!$segment(oldheadfirst)} {		;#	DON'T KEEP THE INITIAL TAIL, IF ANY
		set segment(marklist) [lreplace $segment(marklist) 0 0 [lindex $segment(oldmarks) 1]]
	}

	DeleteAllTemporaryFilesExcept $segment(nutroflist)

	set strseglen [llength $strsegs]		;#	Array of segnos to be stretched (NB cannot be adjacent)
	set strsegcnt 0							;#	Counters in stretch-segnos array
	set sqzcnt 0							;#	Local count of segs to be squeezed	
	set segno 0								;#	Counters for all segments
	set segcnt 1

	if {$segment(process) == "SQZBOX"} {
		Block "PLEASE WAIT:    RUNNING SQUEEZEBOX"
	} else {
		Block "PLEASE WAIT:    RUNNING TIME STRETCH"
	}
	set OK 1
	while {$segno < $segment(cnt)} {
		if {$strsegcnt >= $strseglen} {							;#	If out of stretchable-segs, quit loop
			break
		}
		set strseg [lindex $strsegs $strsegcnt]					;#	What is the current stretchedable segment

		;#	IF WE'VE REACHED A STRETCHABLE BLOCK

		if {$strseg == $segno} {

			;#	IF THERE IS A PRECEDING BLOCK OF SQUEEZABLE SEGMENTS

			if {$sqzcnt} {

				;#	FIND THEM

				set sttseg [expr $segno - $sqzcnt]
				set stt [lindex $segment(marklist) $sttseg]
				if {$sttseg > 0} {
					set stt [expr $stt - $segment(SPLICE)]
				}
				set endd [lindex $segment(marklist) $segno]
				set segdur [expr $endd - $stt]

				;#	CUT OUT SQUEEZABLE SEGBLOCK					;#	Cut out squeezable block of segs

				set ofnam $evv(DFLT_OUTNAME)
				append ofnam "HH" [expr $sttseg + 1] $evv(SNDFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd cut 1 $segment(src,0) $ofnam $stt $endd -w$segment(MSPLICE)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}

				wm title .blocker "PLEASE WAIT:        CUTTING SQUEEZABLE BLOCK AT SEGMENT $sttseg"

				if [catch {open "|$cmd"} CDPidrun] {
					Inf "FAILED TO RUN CUTTING PROCESS AT SEGMENT $sttseg\n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CUT BLOCK AT SEGMENT $sttseg"
					set msg [AddSimpleMessages $msg]
					Inf "$msg\n"
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO CUT BLOCK AT SEGMENT $sttseg CREATED\n"
					set OK 0
					break
				}

				if {$segment(process) == "SQZBOX"} {

					;#	FIND POSSIBLY TIME-VARYING SQUEEZE PARAMS

					set seg_time [lindex $segment(marklist) $sttseg]
					if {$segment(sqztempo)} {
						set tempo		[GetParamValueFromControl $seg_time 2]
						set strsqzratio [GetParamValueFromControl $seg_time 3]
						set beatdur [expr 60.0/$tempo]
						set R1 [expr 1.0/(1.0 + $strsqzratio)]
						set sqzdur [expr $beatdur * $R1]
					} else {
						set sqzfactor [GetParamValueFromControl $seg_time 2]
					}

					;#	CONVERT TO ANALFILE

					set ifnam $ofnam
					set ofnam [file rootname $ifnam]
					append ofnam $evv(ANALFILE_EXT)

					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $ifnam $ofnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        EXTRACTING SPECTRUM OF BLOCK AT SEGMENT $sttseg"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO EXTRACT SPECTRUM OF BLOCK AT SEGMENT $sttseg"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE SPECTRUM OF BLOCK AT SEGMENT $sttseg"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO SPECTRUM OF BLOCK AT SEGMENT $sttseg CREATED"
						set OK 0
						break
					}
			
					;#	GET SQUEEZEFACTOR

					if {$segment(sqztempo)} {
						set sqzfactor [expr $sqzdur/$segdur]
					}

					;#	DO SQUEEZE

					set ifnam $ofnam
					set ofnam $evv(MACH_OUTFNAME)
					append ofnam "PH" [expr $sttseg + 1] $evv(ANALFILE_EXT)

					set cmd [file join $evv(CDPROGRAM_DIR) stretch]
					lappend cmd time 1 $ifnam $ofnam $sqzfactor
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        SQUEEZING BLOCK AT SEGMENT $sttseg"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO SQUEEZE BLOCK AT SEGMENT $sttseg"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE SQUEEZED BLOCK AT SEGMENT $sttseg"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO SQUEEZED BLOCK AT SEGMENT $sttseg CREATED"
						set OK 0
						break
					}

					;#	CONVERT TO WAVFILE

					set ifnam $ofnam
					set ofnam [file rootname $ifnam]
					append ofnam $evv(SNDFILE_EXT)

					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd synth $ifnam $ofnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN CREATION OF WAVEFORM OF BLOCK AT SEGMENT $sttseg"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE WAVEFORM OF BLOCK AT SEGMENT $sttseg"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO WAVEFORM OF BLOCK AT SEGMENT $sttseg CREATED"
						set OK 0
						break
					}

					if {![DoSegmentDurParse $ofnam]} {
						Inf "FAILED TO FIND DURATION OF SQUEEZED BLOCK AT SEGMENT $sttseg\n"
						set OK 0
						break
					}	;#	Else, duration = segment(itemdur)

					;# DOVETAIL 

					if {$segment(itemdur) <= $segment(TWOSPLICE)} {
						set dovsplic [expr ($segment(itemdur)/2.0) - $evv(FLTERR)]
					} else {
						set dovsplic $segment(SPLICE)
					}
					set ifnam $ofnam
					set ofnam [file rootname $ifnam]
					append ofnam "_D" $evv(SNDFILE_EXT)

					set cmd [file join $evv(CDPROGRAM_DIR) envel]
					lappend cmd dovetail 1 $ifnam $ofnam $dovsplic $dovsplic 0 0 -t0
 					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        DOVETAILING WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "FAILED TO RUN DOVETAILING OF WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO CREATE DOVETAILED WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "NO WAVEFORM OF DOVETAILED SQUEEZED BLOCK AT SEGMENT $sttseg CREATED"
						set OK 0
						break
					}

				} else {
					set segment(itemdur) $segdur
				}

				;#	ADD OUTPUT TO MIXFILE

				set mixline [list $ofnam $mixtime 1 1.0]
				lappend segment(mixlines) $mixline
				set mixtime [expr $mixtime + $segment(itemdur) - $segment(SPLICE)]

				;#	RESET sqzcnt TO ZERO

				set sqzcnt 0									;#	Reset sqzcnt to zero
			}
			
			;#	NOW STRETCH CURRENT SEGMENT

				;#	FIND POSSIBLY TIME-VARYING STRETCH PARAMS

			set seg_time [lindex $segment(marklist) $segno]
			if {($segment(process) == "SQZBOX")} {
				if {$segment(sqztempo)} {
					set tempo		[GetParamValueFromControl $seg_time 2]
					set strsqzratio [GetParamValueFromControl $seg_time 3]
					set beatdur [expr 60.0/$tempo]
					set R2 [expr $strsqzratio/(1.0 + $strsqzratio)]
					set strdur [expr $beatdur * $R2]
				} else {
					set strfactor [GetParamValueFromControl $seg_time 3]
				}
			} else {
				set strfactor [GetParamValueFromControl $seg_time 2]
			}
			set stt [lindex $segment(marklist) $segno]
			if {$segno > 0} {
				set stt [expr $stt - $segment(SPLICE)]
			}
			if {$segcnt >= $segment(cnt)} {
				set endd $segment(dur)
			} else {
				set endd [lindex $segment(marklist) $segcnt]
			}
			set segdur [expr $endd - $stt]

			;#	CUT OUT STRETCHABLE SEGMENT

			set ofnam $evv(DFLT_OUTNAME)
			append ofnam "HH" $segcnt $evv(SNDFILE_EXT)

			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			lappend cmd cut 1 $segment(src,0) $ofnam $stt $endd -w$segment(MSPLICE)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}

			wm title .blocker "PLEASE WAIT:        CUTTING STRETCHABLE SEGMENT AT SEGMENT $segcnt"

			if [catch {open "|$cmd"} CDPidrun] {
				Inf "FAILED TO RUN CUTTING PROCESS AT SEGMENT $segcnt\n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CUT SEGMENT $segcnt"
				set msg [AddSimpleMessages $msg]
				Inf "$msg\n"
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO SEGMENT $segcnt CREATED\n"
				set OK 0
				break
			}

			;#	GET STRETCHFACTOR AND CREATE STRETCHING FILE

			if {($segment(process) == "SQZBOX") && $segment(sqztempo)} {
				set strfactor [expr $strdur/$segdur]
			}

			if {$segment(process) == "SQZBOX"} {
				if {$segdur < 0.2} {
					set strstttime [expr $segdur/2.0]
				} else {
					set strstttime 0.1
				}
				set hedend 0
			} else {
				set snn 0
				catch {unset hedend}
				foreach oldtim $segment(oldmarks) {
					if {[Flteq $oldtim $seg_time]} {						;#	Phrase-seg coincides with (old) Head segment
						set hedstt [lindex $segment(oldmarks) $snn]
						incr snn
						if {$snn >= $segment(oldcnt)} {
							set hedend $segment(dur)						;#	Get end of old Head = end of input file
						} else {	
							set hedend [lindex $segment(oldmarks) $snn]		;#	Get end of old Head = old tail-start
						}
						break
					}
					incr snn
				}
				if {![info exists hedend]} {
					Inf "CANNOT FIND END OF HEAD AT $seg_time"
					set OK 0
					break
				} else {
					set strstttime [expr $hedend - $hedstt]
				}
			}

			if {[info exists hedend]} {

				;#	CONVERT TO ANALFILE

				set ifnam $ofnam
				set ofnam [file rootname $ifnam]
				append ofnam $evv(ANALFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd anal 1 $ifnam $ofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING SPECTRUM OF SEGMENT $segcnt"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO EXTRACT SEGMENT OF SEGMENT $segcnt"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE SPECTRUM OF SEGMENT $segcnt"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO SPECTRUM OF SEGMENT $segcnt CREATED"
					set OK 0
					break
				}
		
				if {[file exists $segment(notedata)] && [catch {file delete $segment(notedata)} zit]} {
					Inf "CANNOT DELETE INTERMEDIATE TEXTFILE $segment(notedata)"
					set OK 0
					break
				}

				catch {unset lines}
				set line [list 0.0 1.0]
				lappend lines $line
				set line [list $strstttime 1.0]
				lappend lines $line
				set line [list [expr $strstttime + 0.01] $strfactor]
				lappend lines $line
				set line [list 100.0 $strfactor]
				lappend lines $line
				
				if [catch {open $segment(notedata) "w"} zit] {
					Inf "CANNOT OPEN TEMPORARY DATA FILE $segment(notedata) TO WRITE SPIKE TIMES DATA : $zit"	
					set OK 0
					break
				}
				foreach line $lines {
					puts $zit $line
				}
				close $zit

				;#	DO STRETCH

				set ifnam $ofnam
				set ofnam $evv(MACH_OUTFNAME)
				append ofnam "PH" $segcnt $evv(ANALFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) stretch]
				lappend cmd time 1 $ifnam $ofnam $segment(notedata)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        STRETCHING SEGMENT $segcnt"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO STRETCH SEGMENT $segcnt"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE STRETCHED SEGMENT $segcnt"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO STRETCHED SEGMENT $segcnt CREATED"
					set OK 0
					break
				}

				;#	CONVERT TO WAVFILE

				set ifnam $ofnam
				set ofnam [file rootname $ifnam]
				append ofnam $evv(SNDFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd synth $ifnam $ofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF STRETCHED SEGMENT $segcnt"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN CREATION OF WAVEFORM OF STRETCHED SEGMENT $segcnt"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE STRETCHED SEGMENT $segcnt"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO STRETCHED SEGMENT $segcnt CREATED"
					set OK 0
					break
				}

				;#	FIND OUTPUT DURATION OF STRETCHED OUTPUT

				if {![DoSegmentDurParse $ofnam]} {
					Inf "FAILED TO FIND DURATION OF SQUEEZED BLOCK AT SEGMENT $segcnt\n"
					set OK 0
					break
				}	;#	Else dur = segment(itemdur)
				
					;# DOVETAIL STRETCHED OUTPUT

				if {$segment(itemdur) <= $segment(TWOSPLICE)} {
					set dovsplic [expr $segment(itemdur)/2.0 - $evv(FLTERR)]
				} else {
					set dovsplic $segment(SPLICE)
				}
				set ifnam $ofnam
				set ofnam [file rootname $ifnam]
				append ofnam "_D" $evv(SNDFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) envel]
				lappend cmd dovetail 1 $ifnam $ofnam $dovsplic $dovsplic 0 0 -t0
 				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        DOVETAILING WAVEFORM OF STRETCHED SEGMENT $segcnt"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN DOVETAILING OF STRETCHED SEGMENT $segcnt"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE DOVETAILED STRETCHED SEGMENT $segcnt"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO WAVEFORM OF DOVETAILED SEGMENT $segcnt CREATED"
					set OK 0
					break
				}
			}

			;#	ADD STRETCHED OUTPUT TO MIXFILE

			set mixline [list $ofnam $mixtime 1 1.0]
			lappend segment(mixlines) $mixline
			set mixtime [expr $mixtime + $segment(itemdur) - $segment(SPLICE)]

			;#	FIND NEXT SEGMENT TO BE STRETCHED

			incr strsegcnt

		} else {

			;#	IF NOT AT A SEG-TO-STRETCH, COUNT IT AS A SEG TO SQUEEZE 

			incr sqzcnt	
		}

		incr segno
		incr segcnt
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	while {$OK} {
		if {$segno < $segment(cnt)} {								;#	If we've quit before end of all segs
			set stt [lindex $segment(marklist) $segno]				;#	Squeeze the remaining segs
			if {$segno > 0} {
				set stt [expr $stt - $segment(SPLICE)]
			}
			set endd $segment(dur)

			set segdur [expr $endd - $stt]

			;#	CUT OUT SQUEEZABLE SEGBLOCK					;#	Cut out squeezable block of segs

			set ofnam $evv(DFLT_OUTNAME)
			append ofnam "HH" $segcnt $evv(SNDFILE_EXT)

			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			lappend cmd cut 1 $segment(src,0) $ofnam $stt $endd -w$segment(MSPLICE)
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}

			wm title .blocker "PLEASE WAIT:        CUTTING SQUEEZABLE BLOCK AT SEGMENT $segno"

			if [catch {open "|$cmd"} CDPidrun] {
				Inf "FAILED TO RUN CUTTING PROCESS AT SEGMENT $segno\n"
				catch {unset CDPidrun}
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "FAILED TO CUT BLOCK AT SEGMENT $segno"
				set msg [AddSimpleMessages $msg]
				Inf "$msg\n"
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "NO CUT BLOCK AT SEGMENT $segno CREATED\n"
				set OK 0
				break
			}

			if {$segment(process) == "SQZBOX"} {

				;#	CONVERT TO ANALFILE

				set ifnam $ofnam
				set ofnam [file rootname $ifnam]
				append ofnam $evv(ANALFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd anal 1 $ifnam $ofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        EXTRACTING SPECTRUM OF BLOCK AT SEGMENT $segno"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO EXTRACT SPECTRUM OF BLOCK AT SEGMENT $segno"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE SPECTRUM OF BLOCK AT SEGMENT $segno"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO SPECTRUM OF BLOCK AT SEGMENT $segno CREATED"
					set OK 0
					break
				}

				;#	GET SQUEEZEFACTOR

				if {$segment(sqztempo)} {
					set tempo		[GetParamValueFromControl $seg_time 2]
					set strsqzratio [GetParamValueFromControl $seg_time 3]
					set beatdur [expr 60.0/$tempo]
					set R1 [expr 1.0/(1.0 + $strsqzratio)]
					set sqzdur [expr $beatdur * $R1]
				} else {
					set sqzfactor [GetParamValueFromControl $seg_time 2]
				}
				if {$segment(sqztempo)} {
					set sqzfactor [expr $sqzdur/$segdur]
				}

				;#	DO SQUEEZE

				set ifnam $ofnam
				set ofnam $evv(MACH_OUTFNAME)
				append ofnam "PH" $segcnt $evv(ANALFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) stretch]
				lappend cmd time 1 $ifnam $ofnam $sqzfactor
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        SQUEEZING BLOCK AT SEGMENT $segno"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO SQUEEZE BLOCK AT SEGMENT $segno"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE SQUEEZED BLOCK AT SEGMENT $segno"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO SQUEEZED BLOCK AT SEGMENT $segno CREATED"
					set OK 0
					break
				}

				;#	CONVERT TO WAVFILE

				set ifnam $ofnam
				set ofnam [file rootname $ifnam]
				append ofnam $evv(SNDFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd synth $ifnam $ofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $segno"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN CREATION OF WAVEFORM OF BLOCK AT SEGMENT $segno"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE WAVEFORM OF BLOCK AT SEGMENT $segno"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO WAVEFORM OF BLOCK AT SEGMENT $segno CREATED"
					set OK 0
					break
				}

				if {![DoSegmentDurParse $ofnam]} {
					Inf "FAILED TO FIND DURATION OF SQUEEZED BLOCK AT SEGMENT $sttseg\n"
					set OK 0
					break
				}	;#	Else, duration = segment(itemdur)

				;# DOVETAIL 

				if {$segment(itemdur) <= $segment(TWOSPLICE)} {
					set dovsplic [expr ($segment(itemdur)/2.0) - $evv(FLTERR)]
				} else {
					set dovsplic $segment(SPLICE)
				}
				set ifnam $ofnam
				set ofnam [file rootname $ifnam]
				append ofnam "_D" $evv(SNDFILE_EXT)

				set cmd [file join $evv(CDPROGRAM_DIR) envel]
				lappend cmd dovetail 1 $ifnam $ofnam $dovsplic $dovsplic 0 0 -t0
 				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        DOVETAILING WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "FAILED TO RUN DOVETAILING OF WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "FAILED TO CREATE DOVETAILED WAVEFORM OF SQUEEZED BLOCK AT SEGMENT $sttseg"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				if {![file exists $ofnam]} {
					Inf "NO WAVEFORM OF DOVETAILED SQUEEZED BLOCK AT SEGMENT $sttseg CREATED"
					set OK 0
					break
				}
			} else {
				set segment(itemdur) $segdur
			}
			set mixline [list $ofnam $mixtime 1 1.0]
			lappend segment(mixlines) $mixline
			set mixtime [expr $mixtime + $segment(itemdur) - $segment(SPLICE)]
		}
		break
	}
	if {!$OK} {
		UnBlock
		return 0
	}
	if [catch {open $segment(mixfil) "w"} zit] {
		Inf "CANNOT OPEN TEMPORARY MIXFILE $segment(mixfil) TO MIX COMPONENTS"
		UnBlock
		return 0
	}
	foreach line $segment(mixlines) {
		puts $zit $line
	}
	close $zit
	if {![GettrofMixdown 1]} {
		UnBlock
		return 0
	}
	;#	REMEMBER NEW SEGMENTATION FOR RECYCLING
	
	catch {unset segment(numarks)}
	if {$segment(process) == "SQZBOX"} {
		foreach line $segment(mixlines) {
			lappend segment(numarks) [lindex $line 1]
		}
	} else {
		set segment(numarks) [GetTstretchNewSegmentation]
	}
	UnBlock
	return 1
}

proc SqzboxStyle {} {
	global segment pr_sqzbx tv_active evv spsqzbx spsqztyp
	set segment(orig_spikepos) {}
	catch {unset segment(spikepos)}
	set f .sqzbx
	if [Dlg_Create $f "SET STRETCH LOCATIONS FOR SQUEEZEBOX" "set pr_sqzbx 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_sqzbx 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_sqzbx 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_sqzbx -1" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		radiobutton $f.1.1 -text "Specify Stretch Locations"  -variable spsqzbx -value 1 -command {set pr_sqzbx [GetSpikePositions]; set spsqzbx 0} -width 26 
		radiobutton $f.1.2 -text "Squeeze:Stretch"  -variable spsqztyp -value 0 -width 16 -command ShowSqzboxTimeEntry
		radiobutton $f.1.3 -text "Tempo(MM):Ratio"  -variable spsqztyp -value 1 -width 16 -command ShowSqzboxTimeEntry 
		pack $f.1.2 $f.1.3 $f.1.1 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_sqzbx 1}
		bind $f <Escape> {set pr_sqzbx -1}
	}
	.sqzbx.1.1 config -text ""  -variable spsqzbx -state disabled -disabledforeground []
	set pr_sqzbx 0
	set spsqztyp -1
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_sqzbx
	while {!$finished} {
		tkwait variable pr_sqzbx
		switch -- $pr_sqzbx {
			1 {
				;#	STORE PARAMS FOR SQZBOX
				if {![info exists segment(spikepos)]} {
					Inf "USE THE \"Specify Stretch Locations\" BUTTON TO ENTER LOCATIONS"
					set spsqzbx 0
					continue
				}
				if {[llength $segment(spikepos)] <= 0} {
					Inf "NO STRETCHABLE-SEGMENT TIMES ENTERED"
					set spsqzbx 0
					continue
				}
				if {$spsqztyp < 0} {
					Inf "NO SQUEEZEBOX PARAMETER TYPE SET"				
					continue
				}
				catch {unset str_times}
				set zz 0
				foreach item $segment(spikepos) {				;#	separate SPikes from trofs
					if {[expr $zz % 3] == 1} {
						lappend str_times $item
					}
					incr zz
				}
						
				set segment(par0) $spsqztyp
				set segment(PAR0) $segment(par0)
				set segment(lastpar0,SPIKE) $segment(par0)

				set segment(sqztempo) $spsqztyp
				set spklen [llength $str_times]
				set spkcnt 0
				set segno 2
				set htcnt 0
				if {!$segment(headfirst)} {
					incr segno
				}
				catch {unset str_segs}
				while {$segno < $segment(cnt)} {
					set endd [lindex $segment(marklist) $segno]				;#	Find which HT pair the indicated times fall in
					set str_time [lindex $str_times $spkcnt]
					if {$str_time < $endd} {
						lappend str_segs $htcnt
						incr spkcnt
						if {$spkcnt >= $spklen} {
							break
						}
					}
					incr segno 2
					incr htcnt
				}
				if {([IsEven $segment(cnt)] && !$segment(headfirst)) \
				|| (![IsEven $segment(cnt)] && $segment(headfirst))} {				;#	THTHTH	||	HTHTHTH  isolated H at end
					incr segno -1
					set endd [lindex $segment(marklist) $segno]				;#	Find which HT pair the indicated times fall in
					set str_time [lindex $str_times $spkcnt]
					if {$str_time < $endd} {
						lappend str_segs $htcnt
						incr htcnt
					}
				}
				if {![info exists str_segs]} {
					Inf "FAILED TO FIND THE STRETCHABLE SEGMENTS"
					continue
				}
				set len [llength $str_segs]
				set len_less_one [expr $len - 1]

				;#	Eliminate duplicate segs

				set OK 1
				set n 0
				while {$n < $len_less_one} {
					set segn [lindex $str_segs $n]
					set m $n
					incr m
					while {$m < $len} {
						set segm [lindex $str_segs $m]
						if {$segm == $segn} {
							set str_segs [lreplace $str_segs $m $m]
							incr len -1
							incr len_less_one -1
						} elseif {$segm - $segn < 2} {
							Inf "SELECTED SEGMENTS [expr $segn + 1] AND [expr $segm + 1] ARE ADJACENT: CANNOT PROCEED"
							set OK 0
							break
						} else {
							incr m
						}
					}
					if {!$OK} {
						break
					}
					incr n
				}
				if {!$OK} {
					unset segment(spikepos)
					continue
				}
				set segment(control1) $str_segs
				set segment(lastcontrol1,$segment(process)) $segment(control1)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				continue
			}
			-1 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	catch {unset segment(orig_spikepos)}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

proc ShowSqzboxTimeEntry {} {
	.sqzbx.1.1 config 
	.sqzbx.1.1 config -text "Specify Stretch Locations" -state normal
}

#--- Find new segmentation for TSTRETCH output

proc GetTstretchNewSegmentation {} {
	global segment
	set strsegs $segment(control1)			;#	Read the list of stretchable segments
	set strseglen [llength $strsegs]
	set strsegcnt 0
	set strseg [lindex $strsegs $strsegcnt]
	set segno 0
	set oldsegno 0
	set mixlen [llength $segment(mixlines)]
	set mixcnt 0
	set offset 0.0
	while {$segno < $segment(cnt)} {
		if {$segno == $strseg} {															;#	If AT a stretched segment	

			if {($segno == 0) && !$segment(oldheadfirst)} {									;#	Get the original segment times (with appropriate offset)
				lappend nutimes [lindex $segment(oldmarks) $oldsegno]						;#	Ignored tail of original segmentation is restored
				incr oldsegno
			}
			lappend nutimes [expr [lindex $segment(oldmarks) $oldsegno] + $offset]			;#	Keep original Head seg, + any str-offset
			incr oldsegno
			if {$oldsegno < $segment(oldcnt)} {
				lappend nutimes [expr [lindex $segment(oldmarks) $oldsegno] + $offset]		;#	Keep original Tail seg, it it exists, + any str-offset
				incr oldsegno
			}

			set stt [lindex $segment(marklist) $segno]										;#	Get start and end times of segment BEFORE stretching	
			set segend [expr $segno + 1]
			if {$segend < $segment(cnt)} {
				set endd [expr [lindex $segment(marklist) $segend] + $segment(SPLICE)]
			} else {
				set endd $segment(dur)
			}
			set origdur [expr $endd - $stt]													;#	Get duration of segment before stretching

			set stt [lindex [lindex $segment(mixlines) $mixcnt] 1]							;#	Get start and end times of new stretched-segment
			incr  mixcnt																	;#	In so doing, go to next mixline
			if {$mixcnt < $mixlen} {
				set endd [expr [lindex [lindex $segment(mixlines) $mixcnt] 1] + $segment(SPLICE)]
			} else {
				if {![DoSegmentDurParse $segment(outfnamplay)]} {
					Inf "FAILED TO FIND DURATION OF TIMESTRETCHED OUTPUT FILE\n"
					return {}
				}
				set endd $segment(itemdur)
			}
			set newdur [expr $endd - $stt]													;#	Get duration of stretched segment

			set stretch [expr $newdur - $origdur]											;#	Increment time-offset for new segment times by tstretching
			set offset [expr $offset + $stretch]

			incr strsegcnt																	;#	Go to next stretched segment
			if {$strsegcnt >= $strseglen} {													;#	If no more, set next stretched seg at HUGE	
				set strseg 1000000
			} else {											
				set strseg [lindex $strsegs $strsegcnt]
			}
			incr segno																		;#	Go to next segment

		} else {																			;#	If before next stretched segment

			while {$segno < $strseg} {														;#	Until we reach next stretched segment
				if {($segno == 0) && !$segment(oldheadfirst)} {
					lappend nutimes [lindex $segment(oldmarks) $oldsegno]					;#	Any ignored-tail of original segmentation is restored
					incr oldsegno
				}
				lappend nutimes [expr [lindex $segment(oldmarks) $oldsegno] + $offset]		;#	Keep original Head segtime of any non-stretced segment, with tstr-offset
				incr oldsegno
				if {$oldsegno < $segment(oldcnt)} {											;#	Keep original Tail segs of any non-stretced segment, if it exists, with tstr-offset
					lappend nutimes [expr [lindex $segment(oldmarks) $oldsegno] + $offset]
					incr oldsegno
				}
				incr segno
				if {$segno >= $segment(cnt)} {
					break
				}
			}
			incr mixcnt																		;#	Skip over the output mixline that represents these non-stretched segs
		}
	}
	return $nutimes
}

#--- Enter stretch segments for TSTRETCH

proc TstretchStyle {} {
	global segment pr_tttstr tv_active evv sptttstr
	set segment(orig_spikepos) {}
	catch {unset segment(spikepos)}
	set f .tttstr
	if [Dlg_Create $f "SET SEGMENTS FOR TIME STRETCHING" "set pr_tttstr 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Use Settings" -command "set pr_tttstr 1" -width 18
		button $f.0.l -text "Load Patch"   -command "set pr_tttstr 2" -width 18
		button $f.0.h -text "Help"	       -command "GettrofParamsHelp" -width 8 -bg $evv(HELP)
		button $f.0.q -text "Abandon"	   -command "set pr_tttstr -1" -width 8
		pack $f.0.s $f.0.l $f.0.h -side left -padx 16
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		radiobutton $f.1.1 -text "Specify Stretch Locations"  -variable sptttstr -value 1 -command {set pr_tttstr [GetSpikePositions]; set sptttstr 0} -width 26 
		pack $f.1.1 -side left
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Return> {set pr_tttstr 1}
		bind $f <Escape> {set pr_tttstr -1}
	}
	set pr_tttstr 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_tttstr
	while {!$finished} {
		tkwait variable pr_tttstr
		switch -- $pr_tttstr {
			1 {
				;#	STORE PARAMS FOR TSTRETCH
				if {![info exists segment(spikepos)]} {
					Inf "USE THE \"Specify Stretch Locations\" BUTTON TO ENTER LOCATIONS"
					set sptttstr 0
					continue
				}
				if {[llength $segment(spikepos)] <= 0} {
					Inf "NO STRETCHABLE-SEGMENT TIMES ENTERED"
					set sptttstr 0
					continue
				}
				catch {unset str_times}
				set zz 0
				foreach item $segment(spikepos) {				;#	separate SPikes from trofs
					if {[expr $zz % 3] == 1} {
						lappend str_times $item
					}
					incr zz
				}
				set spklen [llength $str_times]
				set spkcnt 0
				set segno 2
				set htcnt 0
				if {!$segment(headfirst)} {
					incr segno
				}
				catch {unset str_segs}
				while {$segno < $segment(cnt)} {
					set endd [lindex $segment(marklist) $segno]				;#	Find which HT pair the indicated times fall in
					set str_time [lindex $str_times $spkcnt]
					if {$str_time < $endd} {
						lappend str_segs $htcnt
						incr spkcnt
						if {$spkcnt >= $spklen} {
							break
						}
					}
					incr segno 2
					incr htcnt
				}
				if {([IsEven $segment(cnt)] && !$segment(headfirst)) \
				|| (![IsEven $segment(cnt)] && $segment(headfirst))} {				;#	THTHTH	||	HTHTHTH  isolated H at end
					incr segno -1
					set endd [lindex $segment(marklist) $segno]				;#	Find which HT pair the indicated times fall in
					set str_time [lindex $str_times $spkcnt]
					if {$str_time < $endd} {
						lappend str_segs $htcnt
						incr htcnt
					}
				}
				if {![info exists str_segs]} {
					Inf "FAILED TO FIND THE STRETCHABLE SEGMENTS"
					continue
				}
				set len [llength $str_segs]
				set len_less_one [expr $len - 1]

				;#	Eliminate duplicate segs

				if {$len > 1} {
					set n 0
					while {$n < $len_less_one} {
						set segn [lindex $str_segs $n]
						set m $n
						incr m
						while {$m < $len} {
							set segm [lindex $str_segs $m]
							if {$segm == $segn} {
								set str_segs [lreplace $str_segs $m $m]
								incr len -1
								incr len_less_one -1
							} else {
								incr m
							}
						}
						incr n
					}
				}
				set segment(control1) $str_segs
				set segment(lastcontrol1,$segment(process)) $segment(control1)
				set finished 1
			}
			2 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 2
			}
			0 {
				continue
			}
			-1 {
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return 0
			}
		}
	}
	catch {unset segment(orig_spikepos)}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	return 1
}

#-- Get any segment names associated with src, and associate them with tstretched src

proc KeepAnyExistingSegmentNamesAfterTstretch {} {
	global segment evv
	set ifnam $segment(rfnam)								;#	ifnam_1_rsegs		ifnam_0_rsegs		ifnam_phrs
	set kk [string length $ifnam]
	incr kk -1
	while {![string match [string index $ifnam $kk] "_"]} {
		incr kk -1
	}
	set ifnam  [string range $ifnam 0 $kk]					;#	ifnam_1_			ifnam_0_			ifnam_
	append ifnam "text" $evv(TEXT_EXT)						;#	ifnam_1_text.txt	ifnam_0_text.txt	ifnam_text.txt
	set ifnam [file join $segment(dirname) $ifnam]
	if {![file exists $ifnam]} {
		return												;#	No associated text-data
	}
	set gend [file tail $ifnam]
	set kk [string first "_1_text" $gend]
	if {$kk < 0} {
		set kk [string first "_0_text" $gend]
	}
	if {$kk < 0} {
		set kk [string first "_text" $gend]
	}														;#	ifnam_1_text.txt	ifnam_0_text.txt	ifnam_text.txt
	set gend [string range $gend $kk end]					;#	_1_text.txt			_0_text.txt			_text.txt
	set ofnam [file rootname [file tail $segment(ofnamw)]]	;#	dir/ofnam.wav -> ofnam
	append ofnam $gend										;#	ofnam_1_text.txt	ofnam_0_text.txt	ofnam_text.txt
	set ofnam [file join $segment(dirname) $ofnam]
	if {[file exists $ofnam] && [catch {file delete $ofnam} zit]} {
		Inf "CANNOT DELETE EXISTING RELATED TEXT DATA FILE: CANNOT CREATE NEW ONE"
	} elseif {[catch {file copy $ifnam $ofnam} zit]} {
		Inf "CANNOT COPY RELATED TEXT DATA FILE"
	}
}

###############

proc ListLoudestChannels {} {
	global chlist wl evv pr_lstld t_lstld ldst prg_dun set prg_abortd simple_program_messages CDPidrun pa wstk ldst_ext ldst_ext_last

	if {[info exists chlist] && ([llength $chlist] >= 1)}  {
		set fnams $chlist
	} else {
		set ilist [$wl curselection]
		if {[info exists ilist] && ([llength $ilist] >= 1) && ([lindex $ilist 0] >= 0)}  {
			foreach i $ilist {
				lappend fnams [$wl get $i]
			}
		}
	}
	if {![info exists fnams]} {
		Inf "Select soundfiles"
		return
	}
	foreach fnam $fnams {
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 2)} {
			Inf "$fnam is not a stereo or multichannel soundfile"
			return
		}
	}
	set f .lstld
	if [Dlg_Create $f "FIND LOUDEST CHANNEL" "set pr_lstld 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Run"  -command "set pr_lstld 1" -width 6
		label $f.0.ll -text "Outputs suffix (optional)" -width 25
		entry $f.0.e -textvariable ldst_ext -width 10
		set ldst_ext ""			
		button $f.0.q -text "Quit" -command "set pr_lstld 0" -width 6
		pack $f.0.s $f.0.ll $f.0.e -side left -padx 2
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		set t_lstld [text $f.1.t -setgrid true -wrap word -width 16 -height 40 \
		-xscrollcommand "$f.1.sx set" -yscrollcommand "$f.1.sy set"]
		scrollbar $f.1.sy -orient vert  -command "$f.1.t yview"
		scrollbar $f.1.sx -orient horiz -command "$f.1.t xview"
		pack $f.1.t -side left -fill both -expand true
		pack $f.1.sy -side right -fill y
		pack $f.1 -side top -pady 4
		wm resizable $f 0 0
		bind $f <Escape> {set pr_lstld 0}
	}
	bind $f <Return> {set pr_lstld 1}
	.lstld.0.s config -command "set pr_lstld 1"
	.lstld.0.ll config -text ""
	set ldst_ext_last $ldst_ext
	set ldst_ext ""
	.lstld.0.e config -bd 0 -state disabled -disabledbackground [option get . background {}]
	$t_lstld delete 1.0 end
	set pr_lstld 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_lstld
	while {!$finished} {
		tkwait variable pr_lstld
		switch -- $pr_lstld {
			0 {
				set finished 1
				break
			}
			1 {
				catch {unset xtract_list}
				$t_lstld delete 1.0 end
				Block "PLEASE WAIT:    Finding loudest channels"
				set cnt 0
				set goodcnt 0
				foreach fnam $fnams {
					incr cnt
					catch {unset ldst}
					wm title .blocker "PLEASE WAIT:        Finding loudest channel of file $fnam"
					set cmd [file join $evv(CDPROGRAM_DIR) sndinfo]
					lappend cmd loudchan $fnam
 					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run process to find loudest channel of file $fnam"
						set line "$cnt\t-"
						lappend ldst_list $line
						lappend xtract_list 0
						catch {unset CDPidrun}
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyLoudestChannelDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun || ![info exists ldst]} {
						set msg "Failed to find loudest channel of file $fnam"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set line "$cnt\t-"
						lappend ldst_list $line
						lappend xtract_list 0
						continue
					}
					set line "$cnt\t$ldst"
					lappend ldst_list $line
					lappend xtract_list $ldst
					incr goodcnt
				}
				UnBlock
				if {![info exists ldst_list] || ($goodcnt == 0)} {
					$t_lstld insert end "No loudest channels found"
					continue
				} else {
					foreach line $ldst_list {
						$t_lstld insert end "$line\n"
						incr cnt
					}
					set msg "Extract loudest channels ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						.lstld.0.ll config -text "Outputs suffix (optional)"
						.lstld.0.e  config -bd 2 -state normal
						if {[info exists ldst_ext_last]} {
							set ldst_ext $ldst_ext_last
						}
						.lstld.0.s config -command "set pr_lstld 2"
						bind .lstld <Return> {set pr_lstld 2}
					}
				}
				continue
			}				
			2 {
				if {[string length $ldst_ext] > 0} {
					if {![ValidCDPRootname $ldst_ext]} {
						Inf "Please choose a new file suffix (or none)"
						continue
					}
					set ldst_ext [string tolower $ldst_ext]
					set OK 1
					foreach ifnam $fnams x $xtract_list {
						if {$x > 0} {
							set xfnam [file rootname [file tail $ifnam]]
							lappend xfnam $ldst_ext $evv(SNDFILE_EXT)
							if {[file exists $xfnam]} {
								Inf "File $xfnam already exists : please delete it, or choose a new extension"
								set OK 0
								break
							}
						}
					}
					if {!$OK} {
						continue
					}
				}
				catch {unset badfiles}
				foreach fnam $fnams x $xtract_list {
					if {!$x} {
						continue
					}
					set ofnam [file rootname [file tail $fnam]]
					append ofnam "_c$x" $evv(SNDFILE_EXT)
					if {[file exists $ofnam]} {
						lappend badfiles $ofnam
					}
				}
				if [info exists badfiles] {
					set msg "The following channel-extracted files already exist: delete before proceeding"
					set cnt 0
					foreach bfnam $badfiles {
						append msg "\n$bfnam" 
						incr cnt
						if {$cnt > 20} {
							append msg "and more"
							break
						}
					}
					Inf $msg
					continue
				}
				if {[string length $ldst_ext] > 0} {
					catch {unset badfiles}
					foreach fnam $fnams x $xtract_list {
						if {!$x} {
							continue
						}
						set ofnam [file rootname [file tail $ifnam]]
						append ofnam "_$ldst_ext" $evv(SNDFILE_EXT)
						if {[file exists $ofnam]} {
							lappend badfiles $ofnam
						}
					}
					if [info exists badfiles] {
						set msg "The following channel-extracted files already exist: delete before proceeding"
						set cnt 0
						foreach bfnam $badfiles {
							append msg "\n$bfnam" 
							incr cnt
							if {$cnt > 20} {
								append msg "AND MORE"
								break
							}
						}
						Inf $msg
						continue
					}
				}
				Block "PLEASE WAIT:    Extracting loudest channels"
				set goodcnt 0
				catch {unset ofnams}
				foreach fnam $fnams x $xtract_list {
					if {!$x} {
						lappend ofnams 0
						continue
					}
					wm title .blocker "PLEASE WAIT:        Extracting channel $x of file $fnam"
					set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
					lappend cmd chans 1 $fnam $x
		 			set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run process to extract channel $x from file $fnam"
						catch {unset CDPidrun}
						lappend ofnams 0
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed to extract channel $x from file $fnam"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						lappend ofnams 0
						continue
					}
					set ofnam [file rootname [file tail $fnam]]
					append ofnam "_c$x" $evv(SNDFILE_EXT)
					if {![file exists $ofnam]} {
						Inf "No extracted channel $x from file $fnam created"
						lappend ofnams 0
						continue
					} else {
						lappend ofnams $ofnam
						incr goodcnt
					}
				}
				if {!$goodcnt} {
					Inf "No channels extracted"
					UnBlock
					continue
				}
				if {[string length $ldst_ext] > 0} {
					set cnt 0
					foreach ofnam $ofnams ifnam $fnams {
						if {[string match $ofnam 0]} {
							incr cnt
							continue
						}
						set nfnam [file rootname [file tail $ifnam]]
						append nfnam "_$ldst_ext" $evv(SNDFILE_EXT)
						if [catch {file rename $ofnam $nfnam} zit] {
							Inf "Cannot rename output file $ofnam to $nfnam"
						} else {
							set ofnams [lreplace $ofnams $cnt $cnt $nfnam]
						}
						incr cnt
					}
				}
				set ofnams [ReverseList $ofnams]
				foreach ofnam $ofnams {
					FileToWkspace $ofnam 0 0 0 0 1
				}
				UnBlock
				Inf "Files are on the workspace"
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Display info returned by running-batchfile in the the program-running display

proc HandleProcessOutputWithOnlyLoudestChannelDisplayed {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages ldst

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif {[string first "LOUDEST CHANNEL is" $line] >= 0} {
			set ldst [string range $line 19 end]
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		}
	}
	update idletasks
}

#------ Synchronise attacks of several files by padding some with silence at start, where necessary.

proc SyncFilesPad {} {
	global chlist pa evv wl prg_dun prg_abortd simple_program_messages CDPidrun pksync

	;#	CHECK FILES ON WKSPACE ARE MONO-STEREO SNDS

	catch {unset pksync}
	if {[info exists chlist] && ([llength $chlist] > 1)} {
		set fnams $chlist
	} else {
		set ilist [$wl curselection]
		if {[info exists ilist] && ([llength $ilist] > 1)} {
			set fnams $chlist
		}
	}
	if {![info exists fnams]} {
		Inf "Select two or more soundfiles"
		return
	}
	foreach fnam $fnams {
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) > 2)} {
			Inf "File $fnam is not a mono or stereo soundfile""
			return
		}
	}

	;#	CHECK NAME_PAD DOESN'T EXIST

	foreach fnam $fnams {
		set fnam [file rootname [file tail $fnam]]
		append fnam "_pad" $evv(SNDFILE_EXT)
		if {[file exists $fnam]} {
			Inf "Padded file with name $fnam already exists : delete before proceeding"
			return
		}
	}

	;#	USE SNDVIEW TO MARK PEAK IN EACH SOUND AND NOTE MAXIMUM PEAKTIME

	foreach fnam $fnams {
		SnackDisplay $evv(SN_SINGLETIME) syncpeaks $evv(TIME_OUT) $fnam
		if {[info exists maxpktime]} {
			if {$pksync > $maxpktime} {
				set maxpktime $pksync
			}
		} else {
			set maxpktime $pksync
		}
		lappend pktimes $pksync
	}

	;#	CALC DIFF OF PEAKS AND MAXPEAK

	foreach pktime $pktimes {
		set pkdiff [expr $maxpktime - $pktime]
		if {[Flteq $pkdiff 0.0]} {
			set pkdiff 0.0
		}
		lappend pkdiffs $pkdiff
	}
	set OK 1
	foreach pkdiff $pkdiffs {
		if {$pkdiff > 0.0} {
			set OK 0
			break
		}
	}
	if {$OK} {
		Inf "No padding required"
		return
	}

	;#	PAD WITH START-SILENCE ALL FILES NEEDING PADDING

	Block "PLEASE WAIT:        Silence padding files"

	set OK 1
	catch {unset ofnams}
	foreach fnam $fnams pkdiff $pkdiffs {
		if {$pkdiff > 0.0} {
			set ifnam [file rootname [file tail $fnam]]
			set ofnam $ifnam
			append ofnam "_pad" $evv(SNDFILE_EXT)
			set cmd [file join $evv(CDPROGRAM_DIR) prefix]
			lappend cmd silence $fnam $ofnam $pkdiff
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			wm title .blocker "PLEASE WAIT:        Silence padding file $ifnam"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed to run silence padding for file $ifnam"
				set OK 0
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed to create silence padded file $ifnam"
				set msg [AddSimpleMessages $msg]
				set OK 0
				break
			}
			if {![file exists $ofnam]} {
				Inf "No silence padded file $ifnam created"
				set OK 0
				break
			}
			lappend ofnams $ofnam
		}
	}
	if {!$OK} {
		catch {unset CDPidrun}
		if {[info exists ofnams]} {
			foreach ofnam $ofnams {
				catch {file delete $ofnam}
			}
		}
	}
	UnBlock
	if {[info exists ofnams]} {
		set ofnams [ReverseList $ofnams]
		foreach ofnam $ofnams {
			FileToWkspace $ofnam 0 0 0 0 1
		}
		Inf "Silence padded files are on the workspace"
	}
	return	
}

#----- SPECIALIST PROG TO MARK A SEGMENT IN A FILE, CUT THE FILE INTO THE PRE-MARK, MARKED AND POST-MARKED SEGMENTS, AND CREATE MIXFILE WITH SOUNS IN-SITU
#----- SO MIX REPRODUCES ORIGINAL SOUND: MARKED SEGMENT CAN THEN BE MODIFIED AND REPLACED, IN SITU IN ORIGINAL SOUND

proc SliceInSitu {} {
	global evv pa wl chlist wstk prg_dun prg_abortd simple_program_messages CDPidrun pr_inSitu inSitu segment interstr frztine pr_situtime sn_pts

	;# FIND, CHECK AND ORDER FILES
	
	set OK 0
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam $chlist
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set OK 1
		}
	}
	if {!$OK} {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				set OK 1
			}
		}
	}
	if {!$OK} {
		if {[info exists chlist] && ([llength $chlist] == 3)} {
			set fnams $chlist
			set fnams [VerifyThreeFiles $fnams]
			if {[llength $fnams] == 3} {
				set OK 1
			}
		}
		if {!$OK} {
			set ilist [$wl curselection]
			if {[llength $ilist] == 3} {
				foreach i $ilist {
					lappend fnams [$wl get $i]
				}
			}
			set fnams [VerifyThreeFiles $fnams]
			if {[llength $fnams] == 3} {
				set OK 1
			}
		}
		if {!$OK} { 
			Inf "Process requires either one soundfile or\n\na mixfile, the sound output of mix ~with same name~, and one soundfile in the mix"
			return
		}
		set fnamix [lindex $fnams 0]
		set fmxsnd [lindex $fnams 1]
		set fnam [lindex $fnams 2]

		;#	FIND TIME OF SOUNDFILE INSIDE MIXFILE

		if [catch {open $fnamix "r"} zit] {
			Inf "Cannot open mixfile [file rootname $fnamix] to check data"
			return
		}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			if {[string match [string index $line 0] ";"]} {
				continue
			}
			set line [split $line]
			set cnt 0
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				switch -- $cnt {
					0 {
						if {![string match $item $fnam]} {
							break
						}
					}
					1 {
						lappend times $item
						break
					}
				}
				incr cnt
			}
		}
		close $zit
		if {![info exists times]} {
			Inf "File [file tail $fnam] is not in the mix [file tail $fnamix]"
			return
		}
		catch {unset inSitu(offset)}
		if {[llength $times] == 1} {
			set inSitu(offset) [lindex $times 0]
		} else {
			set f .situtime
			if [Dlg_Create $f "Choose start-time in mix" "set pr_situtime 0" -height 20 -borderwidth $evv(SBDR)] {
				frame $f.0
				label $f.0.ll -text "Select Start Time by Clicking on Button" -fg $evv(SPECIAL)
				button $f.0.q -text "Abandon" -command "set pr_situtime 0" -width 6
				pack $f.0.ll -side left
				pack $f.0.q -side right 
				pack $f.0 -side top -fill x -expand true
				frame $f.1
				set n 0
				foreach time $times {
					button $f.1.$n -text [DecPlaces $time 4] -command "set inSitu(offset) $time; set pr_situtime 1" 
					pack $f.1.$n -side left
					incr n
				}
				pack $f.1 -side top -pady 2 -expand true
				bind $f <Escape> {set pr_situtime 0}
			}
			set pr_situtime 0
			raise $f
			update idletasks
			StandardPosition $f
			Simple_Grab 0 $f pr_situtime
			tkwait variable pr_situtime
			Simple_Release_to_Dialog $f
			if {![info exists inSitu(offset)]} {
				Inf "No soundfile start-time in mix has been selected"
				return
			}
			destroy $f
		}
		set chansmx	$pa($fmxsnd,$evv(CHANS))
	}

	set outfnam [file rootname [file tail $fnam]]
	set outfnam1 $outfnam
	append outfnam1 "_stt" $evv(SNDFILE_EXT)
	if {[file exists $outfnam1]} {
		Inf "File $outfnam1 already exists : please delete or rename before proceeding"
		return
	}
	set outfnam2 $outfnam
	append outfnam2 "_mid" $evv(SNDFILE_EXT)
	if {[file exists $outfnam2]} {
		Inf "File $outfnam2 already exists : please delete or rename before proceeding"
		return
	}
	set outfnam3 $outfnam
	append outfnam3 "_end" $evv(SNDFILE_EXT)
	if {[file exists $outfnam3]} {
		Inf "File $outfnam3 already exists : please delete or rename before proceeding"
		return
	}
	set chns $pa($fnam,$evv(CHANS))
	set dur	 $pa($fnam,$evv(DUR))
	set mixfile $outfnam
	append mixfile "_mix"
	if {$chns > 2} {
		append mixfile [GetTextfileExtension mmx]
	} else {
		append mixfile [GetTextfileExtension mix]
	}
	if {[file exists $mixfile]} {
		Inf "File $mixfile already exists : please delete or rename before proceeding"
		return
	}

	if {[info exists fnamix]} {
		if {$chansmx > 2} {

		;# IF MULTICHANNEL MIX-OUTPUT FILE, MAKE MONO VERSION FOR SNACK DISPLAY

			set seemxsnd [file rootname [file tail $fmxsnd]]
			append seemxsnd "_mono" $evv(SNDFILE_EXT)
			if {[file exists $seemxsnd]} {
				set msg "File $seemxsnd already exists : use this ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					Inf "Please delete file $seemxsnd before proceeding"
					return
				}
			} else {
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 4 $fmxsnd $seemxsnd
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				Block "PLEASE WAIT:        Converting multichannel mix output to mono"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed to run mono conversion for file [file rootname [file tail $fmxsnd]]"
					UnBlock
					return
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed to create mono file from multichannel mix input file [file rootname [file tail $fmxsnd]]"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					return
				}
				UnBlock
				if {![file exists $seemxsnd]} {
					Inf "No mono file $seemxsnd created"
					return
				}
				FileToWkspace $seemxsnd 0 0 0 0 1
			}
		} else {
			set seemxsnd $fmxsnd
		}
	}
	if {$chns > 2} {

	;# IF MULTICHANNEL SOUND OR SOUND-IN-MIX, MAKE MONO VERSION FOR SNACK DISPLAY

		set seesnd [file rootname [file tail $fnam]]
		append seesnd "_mono" $evv(SNDFILE_EXT)
		if {[file exists $seesnd]} {
			set msg "File $seesnd already exists : use this ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				Inf "Please delete file $seesnd before proceeding"
				return
			}
		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
			lappend cmd chans 4 $fnam $seesnd
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			Block "PLEASE WAIT:        Converting multichannel sound to mono"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed to run mono conversion for file [file rootname [file tail $fnam]]"
				UnBlock
				return
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed to create mono file from multichannel sound [file rootname [file tail $fnam]]"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				return
			}
			UnBlock
			if {![file exists $seesnd]} {
				Inf "No mono file $seesnd created"
				return
			}
			FileToWkspace $seesnd 0 0 0 0 1
		}
	} else {
		set seesnd $fnam
	}

	set f .inSitu
	if [Dlg_Create $f "Slice for processing in situ" "set pr_inSitu 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Run"  -command "set pr_inSitu 1" -width 6
		button $f.0.h -text "Help"  -command "HelpSliceInSitu" -width 4 -bg $evv(HELP)
		button $f.0.q -text "Quit" -command "set pr_inSitu 0" -width 6
		pack $f.0.s $f.0.h -padx 4 -side left
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		bind $f <Return> {set pr_inSitu 1}
		bind $f <Escape> {set pr_inSitu 0}
	}
	set cutfile $evv(DFLT_OUTNAME)
	append cutfile "0" $evv(TEXT_EXT)
	set pr_inSitu 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_inSitu
	while {!$finished} {
		tkwait variable pr_inSitu
		switch -- $pr_inSitu {
			1 {

				catch {unset sn_pts}
				if {[info exists fnamix]} {

				;#	MARK SEGMENT TO REPLACE, WITHIN MIX OUTPUTFILE, AND CHECK IT IS COMPATIBLE WITH SOUNDFILE

					SnackDisplay $evv(SN_TIMESLIST) internalstr $evv(TIME_OUT) $seemxsnd

					if {![info exists interstr]} {
						Inf "No times marked"
						continue
					}
					if {[llength $interstr] != 2} {
						Inf "Wrong number of time marks ; should be 2 marking the segment to replace"
						continue
					}
					set n 0
					while {$n < 2} {
						set zz [lindex $interstr $n]
						set zz [expr $zz - $inSitu(offset)]
						if {$zz < 0.0} {
							Inf "Time in soundfile is less than zero : start-time of sound in mix must be incorrect"
							break
						}
						if {$zz >= $dur} {
							Inf "Time is beyond end of soundfile : cannot proceed"
							break
						}
						set interstr [lreplace $interstr $n $n $zz]
						incr n
					}
					if {$n < 2} {
						continue
					}
					set sn_pts $interstr
					unset {interstr}
				}

				;#	SET OR CORRECT TIME MARKERS IN SOUND

				SnackDisplay $evv(SN_TIMESLIST) internalstr $evv(TIME_OUT) $seesnd
					
				if {![info exists interstr]} {
					Inf "No times marked"
					continue
				}
				if {[llength $interstr] != 2} {
					Inf "Wrong number of time marks ; should be 2 marking the segment to replace"
					continue
				}
				;#	CHECK VIABILITY OF SPECIFIED TIMES
																	;#		0	  interstr0	    interstr1	end
				set t1 [expr [lindex $interstr 0] + 0.015]			;#		|         |-------------|		|	
				set t2 [expr [lindex $interstr 1] - 0.015]			;#		|-----------|		  |---------|
																	;#		|			t1		 t2			|
	
				set cutlen   [expr [lindex $interstr 1] - [lindex $interstr 0]]
				if {$cutlen <= 0.032} {
					Inf "Segment to cut is too short for splices"
					continue
				}
				catch {unset cut1}
				catch {unset cut3}

				if {[lindex $interstr 0] < 0.015} {					;#	If 1st mark is very close to start
					set cut2 [list 0 [lindex $interstr 1]]			;#	Ignore cut 1, and extend marked seg(2) back to zero
				} else {
					set cut1 [list 0 $t1]
					set cut2 [list [lindex $interstr 0] [lindex $interstr 1]]
				}
				if {[expr $dur - [lindex $interstr 1]] < 0.015} {	;#	If last mark is very close to end
					set cut2 [lreplace $cut2 1 1 $dur]			;#	extend cut 2 to end of file
				} else {
					set cut3 [list $t2 $dur]						;#	else, cut segment at end
				}

				DeleteAllTemporaryFiles

				if {[info exists cut1]} {
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd cut 1 $fnam $outfnam1
					foreach item $cut1 {
						lappend cmd $item
					}
					lappend cmd -w15
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					Block "PLEASE WAIT:        Cutting 1st segment from source file"
					set OK 1
					while {$OK} {
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Failed to run cutting of 1st segment of input file"
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed to create 1st segment from input file"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							set OK 0
							break
						}
						if {![file exists $outfnam1]} {
							Inf "Segment 1 of the input file was not created"
							set OK 0
							break
						}
						break
					}
					if {!$OK} {
						catch {file delete $outfnam1}
						DeleteAllTemporaryFiles
						UnBlock
						continue
					}
				}
				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd cut 1 $fnam $outfnam2
				foreach item $cut2 {
					lappend cmd $item
				}
				lappend cmd -w15
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        Cutting 2nd segment from source file"
				set OK 1
				while {$OK} {
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run cutting of 2nd segment of input file"
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed to create 2nd segment from input file"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $outfnam2]} {
						Inf "Segments 2 the input file was not created"
						set OK 0
						break
					}
					break
				}
				if {!$OK} {
					DeleteAllTemporaryFiles
					UnBlock
					continue
				}
				if {[info exists cut3]} {
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd cut 1 $fnam $outfnam3
					foreach item $cut3 {
						lappend cmd $item
					}
					lappend cmd -w15
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        Cutting 3rd segment from source file"
					set OK 1
					while {$OK} {
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Failed to run cutting of 3rd segment of input file"
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed to create 3rd segment from input file"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							set OK 0
							break
						}
						if {![file exists $outfnam3]} {
							Inf "Segment 3 of the input file was not created"
							set OK 0
							break
						}
						break
					}
					if {!$OK} {
						DeleteAllTemporaryFiles
						UnBlock
						continue
					}
				}

				;#	CREATE REASSEMBLY MIX
				
				set filelist {}
				set timelist 0.0
				if {[info exists cut1]} {
					lappend filelist $outfnam1
					lappend timelist [lindex $interstr 0]
				}
				lappend filelist $outfnam2
				if {[info exists cut3]} {
					lappend filelist $outfnam3
					lappend timelist $t2
				}
				catch {unset mixlines}

				while {$OK} {
					if {$chns <= 2} {
						foreach fil $filelist tim $timelist {
							set line [list $fil $tim $chns 1.0]				
							lappend mixlines $line
						}
					} else {
						set line [list $chns]
						lappend mixlines $line
						foreach fil $filelist tim $timelist {
							set line [list $fil $tim $chns]
							set n 1
							while {$n <= $chns} {
								set rt $n
								append rt ":" $n
								lappend line $rt 1.0
								incr n
							}
							lappend mixlines $line
						}
					}
					if [catch {open $mixfile "w"} zit] {
						Inf "Cannot open mixfile $mixfile to create output mix"
						set OK 0
						break
					}
					foreach line $mixlines {
						puts $zit $line
					}
					close $zit
					break
				}
				if {!$OK} {
					if {[file exists $outfnam1]} {
						catch {file delete $outfnam1}
					}
					if {[file exists $outfnam2]} {
						catch {file delete $outfnam2}
					}
					if {[file exists $outfnam3]} {
						catch {file delete $outfnam3}
					}
					DeleteAllTemporaryFiles
					UnBlock
					continue
				}

				FileToWkspace $outfnam1 0 0 0 0 1
				FileToWkspace $outfnam2 0 0 0 0 1
				FileToWkspace $outfnam3 0 0 0 0 1
				FileToWkspace $mixfile 0 0 0 0 1
				Inf "New files are on the workspace"
				UnBlock
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc HelpSliceInSitu {} {
	set msg "Slice for processing in situ\n"
	append msg "\n"
	append msg "Process requires 1 snd file as input (e.g. \"myname\").\n"
	append msg "\n"
	append msg "Mark a segment in sound, which is to be sliced.\n"
	append msg "\n"
	append msg "Alternatively, work with a sound in a mixfile\n"
	append msg "entering three files as input.\n"
	append msg "(1)  A mixfile (e.g. \"mymix\").\n"
	append msg "(2)  Sound output of mix, with Same name (\"mymix\") as mixfile.\n"
	append msg "(3)  Sound, (e.g. \"myname\") used in mix, which is to be sliced.\n"
	append msg "\n"
	append msg "In this case mark a segment in the mix output\n"
	append msg "(from which  segment in sound-in-the-mix can be deduced).\n"
	append msg "\n"
	append msg "Sound \"myname\" is sliced into 3 segments\n"
	append msg "before-marked, marked, and after-marked.\n"
	append msg "and a mixfile (\"numix\") of these 3 segments\n"
	append msg "is created which will regenerate \"myname\".\n"
	append msg "\n"
	append msg "The marked segment (\"marked\") can then be modified\n"
	append msg "by some process (to produce \"mark2\")\n"
	append msg "and \"mark2\" used to replace \"mark\" in \"numix\".\n"
	append msg "\n"
	append msg "On running the modified mix, a sound is produced\n"
	append msg "in which a portion of \"myname\" has beed modified\n"
	append msg "in a way that does not change the file's length,\n"
	append msg "nor alter the placement of other events in the file.\n"
	append msg "\n"
	append msg "Outputs from process, for a soundfile \"myname\", are ...\n"
	append msg "\n"
	append msg "(1) 3 sndfiles called \"myname_stt\", \"myname_mid\" & \"myname_end\".\n"
	append msg "(If the marked segment is very near the start or end of the file\n"
	append msg "\"myname_stt\" or \"myname_end\" may not be produced).\n"
	append msg "(2) a mixfile, \"myname_mix\"\n"
	append msg "from which the original sound can be reconstructed.\n"
	append msg "\n"
	Inf $msg
}


proc VerifyThreeFiles {fnams} {
	global evv pa 
	set OK 1
	foreach fnam $fnams {
		if {[IsAMixfileIncludingMultichan $pa($fnam,$evv(TYP))]} {
			if {[info exists fnam0]} {
				return {}
			}
			set fnam0 $fnam
		} elseif {$pa($fnam,$evv(TYP)) == $evv(SNDFILE)} {
			if {[info exists fnam1]} {
				if {[info exists fnam2]} {
					return {}
				}
				set fnam2 $fnam
			} else {
				set fnam1 $fnam
			}
		}
	}
					;#	ORDER OF INPUTFILES IS 0,1,2   MIX, MIXOUTPUT, SNDINMIX
	if {[string match $fnam1 $fnam2]} {
		return {}							;#	If both input soundfiles are the same; !OK
	}
	if {[string match [file rootname [file tail $fnam2]] [file rootname [file tail $fnam0]]]} {
		set fx $fnam2
		set fnam2 $fnam1					;#	If sndfile2 has same name as mixfile, make it sndfile1
		set fnam1 $fx
	} elseif {![string match [file rootname [file tail $fnam1]] [file rootname [file tail $fnam0]]]} {
		return {}							;#	Else if sndfile1 does not have same name as mixfile, !OK
	}
	return [list $fnam0 $fnam1 $fnam2]
}


proc DoClick {} {
	global chlist wl evv pa wstk pr_doclick doclick_times clik_srate
	global prg_dun prg_abortd simple_program_messages CDPidrun
	catch {unset doclick_times}
	set preclick 0
	set OK 0
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam $chlist
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			if {$pa($fnam,$evv(CHANS)) <= 2} {
				set OK 1
			}
		} elseif {$pa($fnam,$evv(FTYP)) & $evv(IS_A_NUMLIST)} {
			if {($pa($fnam,$evv(MINNUM)) >= 0.0) && ($pa($fnam,$evv(MAXNUM)) < 32767)} { 
				set OK 2
			}
		}
	}
	if {!$OK} {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				if {$pa($fnam,$evv(CHANS)) <= 2} {
					set OK 1
				}
			} elseif {$pa($fnam,$evv(FTYP)) & $evv(IS_A_NUMLIST)} {
				if {($pa($fnam,$evv(MINNUM)) >= 0.0) && ($pa($fnam,$evv(MAXNUM)) < 32767)} { 
					set OK 2
				}
			}
		}
	}
	if {!$OK} {
		Inf "Select a (mono or stereo) soundfile: or a textfile list of (increasing) times"
		return
	}
	if {$OK == 2} {
		if {[catch {open $fnam "r"} zit]} {
			Inf "Cannot open file $fnam"	
			return
		}
		set lasttime -1.0
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			if {[string match [string index $line 0] ";"]} {
				continue
			}
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {![IsNumeric $item]} {
					Inf "Invalid data ($item) in file $fnam"
					set OK 0
					break
				}
				if {$item <= $lasttime} {
					Inf "Times do not advance at ($lasttime $item) in file $fnam"
					set OK 0
					break
				}
				set lasttime $item
				lappend cliktimes $item
			}
			if {!$OK} {
				break
			}
		}
		close $zit
		if {!$OK} {
			return
		}
		if {![info exists cliktimes]} {
			Inf "No data retreived from file $fnam"
			return
		}
		set doclick_times $cliktimes
		set preclick 1
	}
	if {![info exists clik_srate]} {
		set clik_srate 0
	}
	set f .doclick
	if [Dlg_Create $f "Create clicktrack" "set pr_doclick 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Run"  -command "set pr_doclick 1" -width 6
		button $f.0.v -text "Sound View"  -command {} -bg $evv(SNCOLOR) -width 10
		label $f.0.h -text "Mark Sound" -fg $evv(SPECIAL) -width 14
		button $f.0.q -text "Quit" -command "set pr_doclick 0" -width 6
		pack $f.0.s $f.0.v $f.0.h -padx 2 -side left
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		radiobutton $f.1.16 -text 16000 -variable clik_srate -value 16000
		radiobutton $f.1.22 -text 22050 -variable clik_srate -value 22050
		radiobutton $f.1.32 -text 32000 -variable clik_srate -value 32000
		radiobutton $f.1.44 -text 44100 -variable clik_srate -value 44100
		radiobutton $f.1.48 -text 48000 -variable clik_srate -value 48000
		radiobutton $f.1.88 -text 88200 -variable clik_srate -value 88200
		radiobutton $f.1.96 -text 96000 -variable clik_srate -value 96000
		pack $f.1.16 $f.1.22 $f.1.32 $f.1.44 $f.1.48 $f.1.88 $f.1.96 -side left
		pack $f.1 -side top -fill x -expand true
		bind $f <Return> {set pr_doclick 1}
		bind $f <Escape> {set pr_doclick 0}
	}
	if {[info exists doclick_times]} {
		$f.0.v config -text "" -command {} -bd 0 -bg [option get . background {}]
		$f.0.h config -text "Use input list"
	} else {
		$f.0.v config -text "Sound View" -command "ClickView $fnam" -bd 2 -bg $evv(SNCOLOR)
		$f.0.h config -text "Mark Sound"
	}
	set pr_doclick 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_doclick
	while {!$finished} {
		tkwait variable pr_doclick
		switch -- $pr_doclick {
			0 {
				set finished 1
			}
			1 {
				if {![info exists doclick_times] || ([llength $doclick_times] <= 0)} {
					Inf "No click times entered"
					continue
				}
				if {$clik_srate <= 0} {
					Inf "No samplerate entered"
					continue

				}
				set ofnam [file rootname [file tail $fnam]]
				if {$preclick} {
					set ofnamsnd $ofnam
					set clikcnt 0
					append ofnamsnd $evv(SNDFILE_EXT)
					while {[file exists $ofnamsnd]} {
						set ofnamsnd $ofnam
						append ofnamsnd $clikcnt $evv(SNDFILE_EXT)
						incr clikcnt
					}
				} else {
					set clikcnt 0
					set ofnamt $ofnam
					set ofnamsnd $ofnam
					append ofnamt "_clik" $evv(TEXT_EXT)
					append ofnamsnd "_clik" $evv(SNDFILE_EXT)
					while {[file exists $ofnamt] || [file exists $ofnamsnd]} {
						set ofnamt $ofnam
						set ofnamsnd $ofnam
						append ofnamt "_clik" $clikcnt $evv(TEXT_EXT)
						append ofnamsnd "_clik" $clikcnt $evv(SNDFILE_EXT)
						incr clikcnt
					}
					if [catch {open $ofnamt "w"} zit] {
						Inf "Cannot open file $ofnamt to write click data as text : $zit"
						continue
					} else {
						foreach time $doclick_times {
							puts $zit $time
						}
						close $zit
						FileToWkspace $ofnamt 0 0 0 0 1
					}
					Inf "Click textfile output name is $ofnamt"

				}
				set cmd [file join $evv(CDPROGRAM_DIR) clicknew]
				lappend cmd clicks $ofnamsnd
				if {$preclick} {
					lappend cmd $fnam
				} else {
					lappend cmd $ofnamt
				}
				lappend cmd $clik_srate
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				Block "PLEASE WAIT:        Creating click track"
				set OK 1
				while {$OK} {
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run click track creation"
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed to create click track"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnamsnd]} {
						Inf "Click track soundfile was not created"
						set OK 0
						break
					}
					break
				}
				UnBlock
				if {!$OK} {
					continue
				}
				FileToWkspace $ofnamsnd 0 0 0 0 1
				Inf "File $ofnamsnd is on the workspace"
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}	

proc ClickView {fnam} {
	global doclick_times evv
	catch {unset doclick_times}
	SnackDisplay $evv(SN_TIMESLIST) cliklist 0 $fnam
}

#------ Rermove loud peaks in sound

proc CutPeaks {} {
	global chlist wl evv pa pr_cutpeak cutpk prg_dun prg_abortd simple_program_messages CDPidrun
	set OK 0
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam $chlist
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			if {$pa($fnam,$evv(CHANS)) <= 2} {
				set OK 1
			}
		}
	}
	if {!$OK} {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				if {$pa($fnam,$evv(CHANS)) <= 2} {
					set OK 1
				}
			}
		}
	}
	if {!$OK} {
		Inf "Select a (mono or stereo) soundfile"
		return
	}
	set f .cutpeak
	if [Dlg_Create $f "Remove peaks" "set pr_cutpeak 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Run"  -command "set pr_cutpeak 1" -width 6 -bg $evv(EMPH)
		button $f.0.d -text "Default"  -command CutPkDefaults -width 9
		label $f.0.ll	-text "Run More than once" -fg $evv(HELP)
		button $f.0.q -text "Quit" -command "set pr_cutpeak 0" -width 6
		pack $f.0.s $f.0.d $f.0.ll -side left -padx 4
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		entry $f.1.e -textvariable cutpk(level) -width 10
		label $f.1.ll -text "Cutoff level (>0 to <1)"
		pack $f.1.e $f.1.ll -side left -padx 2
		pack $f.1 -side top -pady 2 -fill x -expand true
		frame $f.2
		entry $f.2.e -textvariable cutpk(width) -width 10
		label $f.2.ll -text "Cutsegment width (mS) (7 to 50)"
		pack $f.2.e $f.2.ll -side left -padx 2
		pack $f.2 -side top -pady 2 -fill x -expand true
		frame $f.3
		entry $f.3.e -textvariable cutpk(splice) -width 10
		label $f.3.ll -text "Cutsegment width (mS) (3 to 50)"
		pack $f.3.e $f.3.ll -side left -padx 2
		pack $f.3 -side top -pady 2 -fill x -expand true
		frame $f.4
		entry $f.4.e -textvariable cutpk(ofnam) -width 10
		label $f.4.ll -text "Output Filename"
		pack $f.4.e $f.4.ll -side left -padx 2
		pack $f.4 -side top -pady 2 -fill x -expand true
		bind .cutpeak.1.e <Up> {focus .cutpeak.4.e}
		bind .cutpeak.2.e <Up> {focus .cutpeak.1.e}
		bind .cutpeak.3.e <Up> {focus .cutpeak.2.e}
		bind .cutpeak.4.e <Up> {focus .cutpeak.3.e}
		bind .cutpeak.1.e <Down> {focus .cutpeak.2.e}
		bind .cutpeak.2.e <Down> {focus .cutpeak.3.e}
		bind .cutpeak.3.e <Down> {focus .cutpeak.4.e}
		bind .cutpeak.4.e <Down> {focus .cutpeak.1.e}
		bind $f <Return> {set pr_cutpeak 1}
		bind $f <Escape> {set pr_cutpeak 0}
	}
	set efnam	 $evv(DFLT_OUTNAME)
	set cutsfnam $evv(DFLT_OUTNAME)
	append efnam 0 $evv(TEXT_EXT)
	append cutsfnam 1 $evv(TEXT_EXT)
	if {![info exists cutpk]} {
		set cutpk(level) ""
		set cutpk(width) ""
	}
	set pr_cutpeak 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_cutpeak $f.1.e
	while {!$finished} {
		tkwait variable pr_cutpeak
		switch -- $pr_cutpeak {
			0 {
				set finished 1
			}
			1 {
				DeleteAllTemporaryFiles
				if {([string length $cutpk(level)] <= 0) || ![IsNumeric $cutpk(level)] || ($cutpk(level) <= 0.0) || ($cutpk(level) >= 1.0)} {
					Inf "Invalid cutoff level (range >0 to <1)"
					continue
				}
				if {([string length $cutpk(width)] <= 0) || ![IsNumeric $cutpk(width)] || ($cutpk(width) < 7) || ($cutpk(width) > 50)} {
					Inf "Invalid cut width (range 7 to 50)"
					continue
				}
				if {([string length $cutpk(splice)] <= 0) || ![IsNumeric $cutpk(splice)] || ($cutpk(width) < 3) || ($cutpk(splice) > 50)} {
					Inf "Invalid splice length (range 3 to 50)"
					continue
				}
				set halfwidth [expr $cutpk(width)/2.0]
				set splice $cutpk(splice)
				set splicedur [expr double($splice) * $evv(MS_TO_SECS)]
				set halfwidth [expr $halfwidth * $evv(MS_TO_SECS)]
				if {[string length $cutpk(ofnam)] <= 0} {
					Inf "No output filename entered"
					continue
				}
				set ofnam [string tolower $cutpk(ofnam)]
				if {![ValidCDPRootname $ofnam]} {
					continue
				}
				append ofnam $evv(SNDFILE_EXT)
				if {[file exists $ofnam]} {
					Inf "File $ofnam already exists: please choose a different name"
					continue
				}
				set cmd [file join $evv(CDPROGRAM_DIR) envel]
				lappend cmd extract 2 $fnam $efnam 20
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				Block "PLEASE WAIT:        Extracting envelope of sound"
				set OK 1
				while {$OK} {
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run envelope extraction"
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed to create envelope"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $efnam]} {
						Inf "Envelope was not extracted"
						set OK 0
						break
					}
					break
				}
				if {!$OK} {
					UnBlock
					continue
				}
				wm title .blocker "PLEASE WAIT:        Creating cut-data"
				if [catch {open $efnam "r"} zit] {
					Inf "Cannot open extracted envelope file"
					UnBlock
					continue
				}
				catch {unset nulines}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					catch {unset nuline}
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] <= 0} {
							continue
						}
						lappend nuline $item
					}
					if {[llength $nuline] != 2} {
						Inf "Invalid data in extracted envelope file"
						close $zit
						set OK 0
						break
					}
					lappend nulines $nuline
				}
				close $zit
				if {!$OK} {
					UnBlock
					continue
				}
				catch {unset cuts}
				set lastcutend 0.0
				set alltooloud 1
				foreach line $nulines {
					set time  [lindex $line 0]
					set level [lindex $line 1]
					if {$level > $cutpk(level)} {
						set cutstt [expr $time - $halfwidth - $splicedur]
						set cutend [expr $time + $halfwidth + $splicedur]
						if {$cutstt <= 0.0} {
							set cutstt 0.0
						} elseif {$cutstt > $lastcutend} {
							if {$lastcutend > 0.0} { 
								lappend cuts $lastcutend
							}
							set lastcutend $cutend
							lappend cuts $cutstt
						}
					} else {
						set alltooloud 0
					}
				}
				if {[info exists cutend]} {
					lappend cuts $cutend
				}
				if {![info exists cuts]} {
					Inf "No peaks exceed the input level"
					UnBlock
					continue
				}
				if {$alltooloud || (([llength $cuts] == 2) && ([lindex $cuts 0] <= 0.0) && ([lindex $cuts end] >= $time))} {
					Inf "All peaks exceed the input level : no sound will remain"
					UnBlock
					continue
				}
				if {![IsEven [llength $cuts]]} {
					Inf "Problem in cut prediction logic"
					UnBlock
					continue
				}
				if [catch {open $cutsfnam "w"} zit] {
					Inf "Cannot open cuts data file"
					UnBlock
					continue
				}
				foreach {cutstt cutend} $cuts {
					if {$cutend < $pa($fnam,$evv(DUR))} {
						set line [list $cutstt $cutend]
						puts $zit $line
					} else {
						break
					}
				}
				close $zit
				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd excises 1 $fnam $ofnam $cutsfnam -w$splice
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        Cutting peaks"
				while {$OK} {
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run cutting peaks from sound"
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed to cut peaks from sound"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "Sound with peaks cut out was not created"
						set OK 0
						break
					}
					break
				}
				if {!$OK} {
					UnBlock
					continue
				}
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File $ofnam is on the workspace"
				}
				UnBlock
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}	

proc CutPkDefaults {} {
	global cutpk
	set cutpk(level) .6
	set cutpk(width) 40
	set cutpk(splice) 3
}

#--- In a multichan file with sounds confined to individual channels, show sequence of entries of sounds, as a sequence of channels

proc OnsetSequence {} {
	global chlist wl evv pa wstk pr_onssq onssq prg_dun prg_abortd simple_program_messages CDPidrun
	set OK 1
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam $chlist
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 2)} {
			set OK 0
		}
	}
	if {!$OK} {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set OK 1
			set fnam [$wl get $i]
			if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 2)} {
				set OK 0
			}
		}
	}
	if {!$OK} {
		Inf "Select a multichannel soundfile"
		return
	}
	set f .onsqq
	if [Dlg_Create $f "Display channel onset sequence" "set pr_onssq 0" -height 20 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.s -text "Run"  -command "set pr_onssq 1" -width 6 -bg $evv(EMPH)
		button $f.0.h -text "Help"  -command "OnsetSequenceHelp" -width 4 -bg $evv(HELP)
		button $f.0.q -text "Quit" -command "set pr_onssq 0" -width 6
		pack $f.0.s $f.0.h -side left -padx 4
		pack $f.0.q -side right 
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		entry $f.1.e -textvariable onssq(level) -width 10
		label $f.1.ll -text "Onset level (0.000002 to 0.9)"
		pack $f.1.e $f.1.ll -side left -padx 2
		pack $f.1 -side top -pady 2 -fill x -expand true
		frame $f.2
		checkbutton $f.2.ch -variable onssq(bkwds) -text "At File end"
		set onssq(bkwds) 0
		pack $f.2.ch -side left
		pack $f.2 -side top -pady 2 -fill x -expand true
		bind $f <Return> {set pr_onssq 1}
		bind $f <Escape> {set pr_onssq 0}
	}
	set rfnam	 $evv(DFLT_OUTNAME)
	append rfnam 0 $evv(SNDFILE_EXT)
	set ofnam	 $evv(DFLT_OUTNAME)
	append ofnam 0 $evv(TEXT_EXT)
	set pr_onssq 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_onssq $f.1.e
	while {!$finished} {
		tkwait variable pr_onssq
		switch -- $pr_onssq {
			0 {
				set finished 1
			}
			1 {
				DeleteAllTemporaryFiles
				if {([string length $onssq(level)] <= 0) || ![IsNumeric $onssq(level)] || ($onssq(level) <= $evv(FLTERR)) || ($onssq(level) > 0.9)} {
					Inf "Invalid onset level (Range >0.000002 to 0.9)"
					continue
				}
				set OK 1
				Block "PLEASE WAIT:        Extracting onset information"
				if {$onssq(bkwds)} {
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd radical 1 $fnam $rfnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        Reversing input sound"
					while {$OK} {
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Failed to run reversing of input sound"
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed to reverse input sound"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							set OK 0
							break
						}
						if {![file exists $rfnam]} {
							Inf "No reversed sound was created"
							set OK 0
						}
						break
					}
					if {!$OK} {
						UnBlock
						continue
					}
					set ifnam $rfnam
				} else {
					set ifnam $fnam
				}
				set cmd [file join $evv(CDPROGRAM_DIR) onset]
				lappend cmd onset $ifnam $ofnam $onssq(level)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        Extracting onset information"
				while {$OK} {
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed to run onset information extraction"
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed to extract onset information"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "Onset information was not extracted"
						set OK 0
					}
					break
				}
				if {!$OK} {
					UnBlock
					continue
				}
				catch {unset nulines}
				if [catch {open $ofnam "r"} zit] {
					Inf "Cannot open onset information file"
					UnBlock
					continue
				}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					lappend nulines $line
				}
				close $zit
				if {![info exists nulines]} {
					Inf "No data read from onset information file"
					UnBlock
					continue
				}
				if {([llength $nulines] == 1) && ![IsNumeric $nulines]} {
					set line [StripCurlies $nulines]
				} else {
					if {$onssq(bkwds)} {
						set nulines [ReverseList $nulines]
					}
					catch {unset outline} 
					foreach item $nulines  {
						if {![info exists outline]} {
							set outline [expr $item + 1]
						} else {
							append outline "\t" [expr $item + 1]
						}
					}
					set line $outline
				}
				UnBlock
				if {$onssq(bkwds)} {
					set msg "Channel onset information at file end\n\n$line\n\ntry again ??"				
				} else {
					set msg "Channel onset information\n\n$line\n\ntry again ??"				
				}
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					continue
				}
				set msg "Save channel onset information ??"				
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set chofnamx [file rootname [file tail $fnam]]
					append chofnamx "_onset_seq"
					set chofnam $chofnamx
					set n 0
					append chofnam $n $evv(TEXT_EXT)
					while {[file exists $chofnam]} {
						incr n
						set chofnam $chofnamx
						append chofnam $n $evv(TEXT_EXT)
					}
					if [catch {open $chofnam "w"} zit] {
						Inf "Cannot open file $chofnam to write channel entry sequence data"
					} else {
						puts $zit $line
						close $zit
						FileToWkspace $chofnam 0 0 0 0 1
					}
				}
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc OnsetSequenceHelp {} {
	set msg "
	append msg "Display channel onset sequence\n"
	append msg "\n"
	append msg "For a multichannel file\n"
	append msg "where sounds are located on different channels\n"
	append msg "(no sounds are spread between channels)\n"
	append msg "and begin in different chans at different times.\n"
	append msg "\n"
	append msg "Find the onset order of the events\n"
	append msg "and display the Sequence of Channels\n"
	append msg "in which these time-ordered events play.\n"
	append msg "\n"
	Inf $msg
}
