#
# SOUND LOOM RELEASE mac version 17.0.4E
#

#RWD June 27 2013
# ... resolved button draw problem (use -highlightbackground), trying to condense window size
# ... removed specific width values from most text buttons
# ...  drop-down menu of musical notes: -background is sadly not supported in Cocoa
# ...  Tap time Dialog (DoNuTimer) portable change requires tcltk8.5: multiline bbutton test not supported on Aqua

#################
#	WORKSPACE	#
#################

#------ Create workspace on which files to be used are displayed
#
#	(1)	Each named element, 'filename', in a listbox has a group of (property) elements
#		associated with it in the global array 'pa'
#
#	(2)	Hilited items in the listbox (selected by user) are maintained, in order of selection,
#		in the list 'chlist'
#		To make this work, use '-selectMode multiple' to add/select 1 item at a time.
#

proc Create_Workspace {zz} {
	global evv o_nam destroy_newfile_window workspace ch remlist p_pg ww pr1 fastskip
	global again infstat bombout wksp_dirname dir_dlg_help_actvtd
	global wl toplabel selection_mode wksp_hlp_actv wrksp_actv brk			;# wl = workspace-list
	global wrksp_emph wksp_in_chose_mode pprg mmod do_not_close_wrksp
	global bulk do_redesign	from_chosen do_starthlp	wksp_cnt total_wksp_cnt chcnt renam
	global tw_testing sl_real ch_remem ch_resto w_remem w_resto small_screen w_hich
	global usertype top_user new_tw_testing new_gobo_testing gobo_testing do_subs 
	global new_text_edit_style text_edit_style last_mix chpos diskused is_terminating selcmd
	global cmdline_testing new_cmdline_testing new_bakup_hiding bakup_hiding background_listing gobo_info
	global lastpmfnam showing_pmarks cdparams_testing new_cdparams_testing current_scorename score_loaded
	global is_dummy_history scores_refresh topchpos float_out hidden_dir propfiles_list chkeep
	global was_selected wkspace_newfile pvplaycmd invlist_view
	global show_the_gobo tcl_platform counter_bg readonlyfg readonlybg CDPcolour
	global multiple_file_extensions can_change_environment_variables qikbutton released
	global sfedit_cutmany_broken old_props_protocol old_subpatch_protocol cleav_done development_version
	global snack_enabled tv_active from_shrink equivalents_loaded parse_the_max
	global big_snack ddumm shortwindows macsmall set_thumbnailed main_mix baktowrite data_released couette_released
	global sndcardfault lengthen_screen_menu_index sv_tl submixversion rym newbakup usetype directtoview
	global bigmix big_mixwindows_index grainversion extendversion formantsversion unblocker new_unblocker columnsversion
	global dupl_mix dupl_vbx dupl_txt ch_analy no_parse_questions new_no_parse_questions sfeditversion rotpatches
	global texture_mindur_override fastquitrun new_fastquitrun
#2023
    global pvx pvx_set
#RWD  think we can eliminate this now...?
	if { $::tcl_platform(platform) == "windows" } {    
    	SndCardFault
    }
    
## WARNING, NEXT LINE IS MODIFIED BY sloomset: DO NOT CHANGE IT'S FORMAT
	UpdateInfo 17-0-4
	;# 2023 (RWD)
    ReadPvx
	set texture_mindur_override 0
#RWD
	if { $::tcl_platform(platform) == "windows" } {
		if {($usetype == 2) && [CheckNewBakup]} {
			set newbakup 1
		}
	} 
	if {[info exists released(ness)]} {
		NessInit
		NessMLoad
	}
	if { $::tcl_platform(os) == "Darwin" } {
		SetupMacFix
	}
	LoadSysPlayChans
	set	dupl_mix 0
	set	dupl_vbx 0
	set dupl_txt 0
	set ch_analy 0
	NewWindowShortenMsg
	LoadPlayIconify	
	Release6TestfilesTest
	CheckAnalPlay
	EstablishMaxfiles
	set submixversion 0
	set submixversion [GetVersion submix]
	set grainversion  [GetVersion grain]
	set data_released [GetDataReleased]
	set couette_released [GetCouetteReleased]
	set extendversion [GetVersion extend]
	set formantsversion [GetVersion formants]
	set sfeditversion [GetVersion sfedit]
	set columnsversion [GetVersion columns]
	LoadRotpatches
	LoadSpekData
	LoadTsCmds
	LoadTsSrcFiles
	LoadTsProcesses
	LoadSpecavDflt
	LoadGpFiltPatches
	VariboxInit
	LoadVariboxPatches
	LoadLogiPatches
	LoadRrotPatches
	LoadCouettePatches
	LoadUnknotPatches
	LoadRymPatches
	LoadRymHistories
	LoadTILPfiles
	SetPlayStep
	LoadSvtl
	LoadDirectToView
#	Release13LoomUpdates
	LoadOtherTxtExtensions
	LoadIgnoreProgMsgs
	LoadPchunk
	LoadDoveMix
	CleanArticFileAfterCrash
	LoadBakupLog
	LoadTargetTextfile
	GetWavAmb
	LoadIgnoreBadfiles
	set set_thumbnailed 0
	LoadScience
	if {[info exists evv(DEVICE_DFLT)]} {
		GetPlayDevice
	}
	GetShortWindows 1
	set big_snack [GetBigSnack]
	if { $::tcl_platform(os) == "Darwin" } {
		GetSmallDisplay
	}
	GetParseTheMax
	GetEofTrap
	GetPropsProtocol
	GetPropsSearchProtocol
	GetSubpatchProtocol
	GetFOFSeparator
	GetMixLastVals
	GetParamLastVals
	GetLastMixIO
	GetMainMix
	GetMMLastVals
	GetQikClikVals
	GetThumbnailRecyclingStatus
	GetDontShowWkspaceSave
	GetShowStick
	LoadRestailVals
	LoadMrestailVals
	LoadIdealTag
	LoadIdealOffset
	LoadTasks
	AhfLoadQsets
	LoadBigMixInfo
	set cleav_done 0
	set equivalents_loaded 0
	set tv_active 0
	set from_shrink 0
	set baktowrite 1
	set fnam [file join $evv(CDPRESOURCE_DIR) cutmany_broken$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set sfedit_cutmany_broken 1
	} else {
		set sfedit_cutmany_broken 0
	}
	set counter_bg grey
#RWD 9/24 we can skip this now, as the code will know what machine it is on :-)
#	if {![file exists [file join $evv(CDPRESOURCE_DIR) pctest$evv(CDP_EXT)]]} {
#		switch -- $tcl_platform(platform) {
#			"unix" {}
#			default {
#				set msg "This is a version of the Sound Loom for MAC OSX\n"
#				append msg "If you use it on another platform, it will not work correctly.\n"
#				append msg "Please use a Mac OSX version of the Sound Loom"
#				Inf $msg
#			}
#		}
#	}
	LoadTextfileExtensions
	ListStandalonesWithNoFloatOutputOption
	if {[info exists released(tv)]} {
		if {[LoadTVConstants]} {
			set tv_active 1
		}
	} elseif {![file exists [file join $evv(CDPRESOURCE_DIR) tvannounce$evv(CDP_EXT)]]} {
		TVAnnounce
	}
	set lengthen_screen_menu_index 30
	set big_mixwindows_index [expr $lengthen_screen_menu_index + 1] 
	SetCryptoProgs
	#RWD 9/24: we can remove PC version refs to "CDPnewver" now - always true.
	set invlist_view 0
 	set show_the_gobo 0
 	set wkspace_newfile 0
 #RWD different names used for Mac and Windows
 	if { $::tcl_platform(platform) == "unix" } {
		set pvplaycmd [file join $evv(CDPROGRAM_DIR) pvplay]
	}
	
	set hidden_dir ""
	set float_out [GetFloatStatus]
	GetTestFlags
	SetUpThumbnails
	GetWavesurferCopyright
	LoadPrivateDirs
	LoadBakupDirs
	LoadLastBL
	LoadAlgebra
	LoadPitchMarks
	LoadMtfMarks
	LoadScoreNamesList
	set propfiles_list {}
	LoadPropsDir
	LoadSubpatches
	MixMLoad
	LoadPropTabNotesData
	LoadPositionInProptable
	LoadExtraxtSpecificPitchedMaterialParams
	LoadLastSoundlist
	set scores_refresh 0
	set showing_pmarks 0
	set score_loaded 0
	set was_selected {}
	set is_dummy_history 0
	set topchpos 0
	set current_scorename ""
	set background_listing [file join $evv(URES_DIR) $evv(BKGD)$evv(CDP_EXT)]
	if {[file exists $background_listing]} {
		LoadBL $background_listing
	}
	set lastpmfnam "##"
	set chpos -1
	set do_subs 0
	set gobo_info 0
	set is_terminating 0
	set diskused 0
	set new_tw_testing   $tw_testing
	set new_bakup_hiding  $bakup_hiding
	set new_gobo_testing $gobo_testing
	ForceTextEditOfBrkfiles
	set new_text_edit_style 1
	set text_edit_style 1
	set new_cmdline_testing $cmdline_testing
	set new_cdparams_testing $cdparams_testing
#RWD 9/24 all this seems only active on Windows
    if { $::tcl_platform(platform) == "windows" } {
    	if {[info exists view_with_viewsf]} {
			set new_view_with_viewsf $view_with_viewsf
		} else {
			set new_view_with_viewsf 0
			set view_with_viewsf 0
		}
		if {[info exists unblocker]} {
			set new_unblocker $unblocker
		} else {
			set new_unblocker 0
			set unblocker 0
		}
		if {[info exists no_parse_questions]} {
			set new_no_parse_questions $no_parse_questions
		} else {
			set new_no_parse_questions 0
			set no_parse_questions 0
		}
		catch {set new_fastquitrun $fastquitrun}
    }
	set selection_mode 0
	set wksp_hlp_actv 0
	set wrksp_actv 1
	set wksp_in_chose_mode 0
	set pprg 0
	set mmod 0
	set last_mix ""
	GetColour
#RWD
	if { $::tcl_platform(platform) == "windows" } {
		if {[info exists sau]} {
			set msg "REMEMBER YOU MUST USE A MEMORY STICK AT THE END OF YOUR SESSION\n"
			append msg "TO BACKUP YOUR WORK, OR IT WILL BE LOST.\n\n"
			append msg "(THE DATA ON THIS MACHINE WILL BE OVERWRITTEN BY THE NEXT USER)\n"
			Inf $msg
		}
	}
	set again(0) -1							;# Process-recall values set to impossible values
	set again(1) -1

	set infstat 0
	set ddumm -1
	set o_nam $evv(DFLT_OUTNAME)
	set destroy_newfile_window 0				;#	No need to destroy Instruments-infile-window in 1st call
												;#	to create Instruments, as it doesn't yet exist

	if [Dlg_Create .workspace "Workspace" "DoWkspaceQuit 0 0"	-borderwidth $evv(SBDR)] {
		if {$small_screen} {
			set can [Scrolled_Canvas .workspace.c -width $evv(SMALL_WIDTH) -height $evv(SMALL_HEIGHT) \
								-scrollregion "0 0 $evv(WKSPACE_WIDTH) $evv(SCROLL_HEIGHT)"]
			pack .workspace.c -side top -fill both -expand true
			set f [frame $can.f -bd 0]
			$can create window 0 0 -anchor nw -window $f
			set ww $f
		} else {
			set ww .workspace
		}	
		set w1	 [frame $ww.1 -borderwidth $evv(SBDR)]
		set help [frame $ww.h -borderwidth $evv(SBDR)] 

		set wwa	 [frame $w1.a -borderwidth $evv(SBDR)]
		set wwb  [frame $w1.b -borderwidth $evv(SBDR)]

		set f [frame $wwa.top -borderwidth $evv(SBDR)]	;# creates frame for buttons
#RWD
		if { $::tcl_platform(platform) == "windows" } {
			set f0 [frame $wwa.lin -height 1 -bg [option get . foreground {}]]	;# creates frame for buttons		
		}
		set fz [frame $wwa.mez -borderwidth $evv(SBDR)]	;# creates another frame for buttons
		set fdum [frame $wwa.dum -bg [option get . foreground {}] -height 1]

#RWD 29/9/24 from here, lots of gui diffs between mac/pc, many changes are just removing or changing size values from buttons etc. 
#    Mac uses a lot more space. Also needs the extra highlightbackground setting, otherwise we get white square frame for the very rounded control

		if { $::tcl_platform(platform) == "windows" } {
			button $f.pro    -text "PROCESS"  -width 14 -command "set bulk(run) 0 ; GotoGetAProcess" -bg $evv(EMPH)
			button $f.bulk   -text "BULK PROCESS" 	 -width 14 -command "set bulk(run) 1 ; GotoGetAProcess" 
			button $f.machcr -text "INSTRUMENT" -width 14 -command CreateIns
			menubutton $f.batch -text "BATCHFILES" -menu $f.batch.menu -relief raised -width 14
		} else {		
			#RWD button was width 14		
			button $f.pro    -text "Process"  -command "set bulk(run) 0 ; GotoGetAProcess" -bg $evv(EMPH)  -highlightbackground [option get . background {}]
			if {$macsmall} {
				button $f.bulk   -text "Bulk Proc" 	 -width 9 -command "set bulk(run) 1 ; GotoGetAProcess" -highlightbackground [option get . background {}]
				menubutton $f.batch -text "Batch" -menu $f.batch.menu -relief raised -width 9
				button $f.machcr -text "Make Instr" -width 10 -command CreateIns -highlightbackground [option get . background {}]
			} else {
				#RWD buttons were width 14, Batchfiles was 14
				button $f.bulk   -text "Bulk Process"  -command "set bulk(run) 1 ; GotoGetAProcess" -highlightbackground [option get . background {}] 
				menubutton $f.batch -text "Batchfiles" -menu $f.batch.menu -relief raised 
				button $f.machcr -text "Instrument"  -command CreateIns -highlightbackground [option get . background {}]
			}
		}
		
		set mfb [menu $f.batch.menu -tearoff 0]
		
		if { $::tcl_platform(platform) == "windows" } {
			$mfb add command -label "RUN BATCHFILE" -command {} -background $evv(HELP)
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "RUN SELECTED BATCHFILE" -command "GoToBatchProcessing 1"
			$mfb add separator
			$mfb add command -label "CREATE BATCHFILE" -command "GoToBatchProcessing 0"
			$mfb add command -label "------------ Other Options ------------" -command "BatchTips 0" -foreground $evv(SPECIAL) -background $evv(HELP)
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "EDIT BATCHFILE" -command {} -background $evv(HELP)
			$mfb add command -label "------------ More Information ------------" -command BatchSubstituteTell -foreground $evv(SPECIAL) -background $evv(HELP)
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "SUBSTITUTE CHOSEN SOUNDS AS INPUT" -command "BatchSubstitute" 
			$mfb add separator
			$mfb add command -label "EXTRACT/EDIT FILES USED" -command "BatchGetFiles 1" 
			$mfb add separator
			$mfb add command -label "EXTRACT/EDIT FILES: IGNORE DELETES" -command "BatchGetFiles 0" 
			$mfb add separator
			$mfb add command -label "GLOBAL EDIT PARAMETERS" -command "BatchGlobalParams" 
			$mfb add separator
			$mfb add command -label "RUNNING SAME PROCESS WITH DIFFERENT PARAMS" -command "BatchTips 1"
			$mfb add separator
			$mfb add command -label "SAME PROCESS ON DIFFERENT FILES WITH DIFFERENT PARAMS" -command "BatchTips 2"
			$mfb add separator
			$mfb add command -label "RUNNING SAME SET OF PROCESSES ON DIFFERENT FILES" -command "BatchTips 3"
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "HIGHLIGHT ON WKSPACE FILES USED IN BATCHFILE" -command {} -background $evv(HELP)
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "INPUT FILES" -command "BatchHilite i" 
			$mfb add separator
			if {$CDPnewver} {
				$mfb add command -label "OUTPUT FILES" -command "BatchHilite o" 
				$mfb add separator
			}
			$mfb add command -label "DATA FILES" -command "BatchHilite t" 
			$mfb add separator
			$mfb add command -label "THE BATCHFILE" -command "BatchHilite b" 
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "GET FILES USED IN BATCHFILE TO WORKSPACE" -command {} -background $evv(HELP)
			$mfb add separator -background $evv(HELP)
			$mfb add command -label "GET FILES" -command BatchGrab

			button $f.hist   -text "RECALL ACTION" 	 -width 14 -command {DisplayHistory 1}
			if {[VBoxReleased]} {
				button $f.vbox -text "VBOX"  -command {SegmentSensitive}
			}
		} else {
			$mfb add command -label "RUN BATCHFILE" -command {}  -foreground black
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "Run Batchfile" -command "GoToBatchProcessing 1" -foreground black
			$mfb add command -label "Create Batchfile" -command "GoToBatchProcessing 0" -foreground black
			$mfb add command -label "                          Other Options" -command "BatchTips 0" -foreground $evv(SPECIAL) -background $evv(HELP)
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "EDIT BATCHFILE" -command {}  -foreground black
			$mfb add command -label "~ More Information ~" -command BatchSubstituteTell -foreground $evv(SPECIAL) ;# -background $evv(HELP)
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "Substitute Chosen Sounds As Input" -command "BatchSubstitute"  -foreground black
			$mfb add command -label "Extract/Edit Files Used" -command "BatchGetFiles 1"  -foreground black
			$mfb add command -label "Extract/Edit Files: Ignore Deletes" -command "BatchGetFiles 0"  -foreground black
			$mfb add command -label "Global Edit Parameters" -command "BatchGlobalParams"  -foreground black
			$mfb add command -label "Run Same Process With Different Params" -command "BatchTips 1" -foreground black
			$mfb add command -label "Same Process On Different Files With Different Params" -command "BatchTips 2" -foreground black
			$mfb add command -label "Run Same Set Of Processes On Different Files" -command "BatchTips 3" -foreground black
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "HIGHLIGHT ON WKSPACE FILES USED IN BATCHFILE" -command {}  -foreground black
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "Input Files" -command "BatchHilite i"  -foreground black
			$mfb add command -label "Output Files" -command "BatchHilite o"  -foreground black
			$mfb add command -label "Data Files" -command "BatchHilite t"  -foreground black
			$mfb add command -label "The Batchfile" -command "BatchHilite b"  -foreground black
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "GET FILES USED IN BATCHFILE TO WORKSPACE" -command {}  -foreground black
			$mfb add separator ;# -background $evv(HELP)
			$mfb add command -label "Get Files" -command BatchGrab -foreground black
			if {$macsmall} {
				button $f.hist   -text "Recall Act" 	 -width 10 -command {DisplayHistory 1}  -highlightbackground [option get . background {}]
				menubutton $fz.bkgd -text "Testbed" -menu $fz.bkgd.menu -relief raised -width 9
			} else {
			#RWD button width was 14, menubutton was 17
				button $f.hist   -text "Recall Action"  -command {DisplayHistory 1} -highlightbackground [option get . background {}]
				menubutton $fz.bkgd -text "Music Testbed" -menu $fz.bkgd.menu -relief raised 
			}
			if {[VBoxReleased]} {
				button $f.vbox -text "VBOX"  -command {SegmentSensitive} -highlightbackground [option get . background {}]
			}
		
		}
		
		
		;#	2023/2
		frame $f.pvx
		label $f.pvx.ll -text "PVX output?"
		radiobutton $f.pvx.1 -variable pvx_set -text "Yes" -value 1 -command "PvxFormat 1"
		radiobutton $f.pvx.0 -variable pvx_set -text "No" -value 0  -command "PvxFormat 0"
		pack $f.pvx.ll $f.pvx.0 $f.pvx.1 -side left		
		
		if { $::tcl_platform(platform) == "windows" } {
			button $fz.dum -text "Display"  -command BareText -bg $evv(HELP) -width 7
			menubutton $fz.bkgd -text "MUSIC TESTBED" -menu $fz.bkgd.menu -relief raised -width 19
		} else {
			button $fz.dum -text "Display"  -command BareText -bg $evv(HELP) -width 7 -highlightbackground [option get . background {}]
	    }
		set mfz [menu $fz.bkgd.menu -tearoff 0]
		EstablishMusicTestbedMenu $mfz
#RWD 9/24  This is the section where most differences Mac/PC are in title strings, PC using all-caps virtually everywhere.
# I feel mixed case is much easier to read, so avoiding a lot of duplication  for the time being.
# It can be changed later if PC users (Mac users too?) prefer upper case.
 
		if {$data_released} {
#RWD Mac: width was 8, 12 OK all platforms
			menubutton $fz.data -text "Data(#)" -menu $fz.data.menu -relief raised -width 12
			set mfd [menu $fz.data.menu -tearoff 0]
			$mfd add command -label "Do It Again" -command {} -background $evv(HELP)
			$mfd add separator  -background $evv(HELP)
			$mfd add command -label "" -command {}
			$mfd add separator  -background $evv(HELP)
			$mfd add command -label "TIME SERIES And SPECTRAL SERIES" -command {} -background $evv(HELP)
			$mfd add separator  -background $evv(HELP)
			$mfd add cascade -label "Data Conversion" -menu $mfd.ddd
			$mfd add command -label "------------ More Information ------------" -command {DataConvertHelp} -foreground $evv(SPECIAL)
			set mdd [menu $mfd.ddd -tearoff 0]
			$mdd add command -label "Scientific -> Numeric                      (\"Control e\")" -command {DataConvertor; SetData scinu}
			$mdd add separator
			$mdd add command -label "Amplitude List -> Frq/Amp Pairs (\"Control x\")" -command {CosmicConvertor; SetData ampfrqamp}
			$mdd add separator
			$mdd add command -label "Time Series --> Breakpoint File (\"Control y\")" -command {TimeSeriesConvertor; SetData tstobk}
			$mdd add separator
			$mdd add command -label "------------ More Information ------------" -command {DataConvertHelp} -foreground $evv(SPECIAL)

			$mfd add separator
			$mfd add command -label "Data To Sound" -command {UberData; SetData uber}
			$mfd add command -label "------------ More Information ------------" -command {DataConversionOverview} -foreground $evv(SPECIAL)
			$mfd add separator
			$mfd add command -label "Hear Sounds Generated From Spectra" -command {SpectralDataToSoundCompare; SetData spechear}
			$mfd add separator -background $evv(HELP)
			$mfd add command -label "CHAOS" -command {} -background $evv(HELP)
			$mfd add separator -background $evv(HELP)

			if {[info exists released(logistic)] && [info exists released(iterfof)]} {
				$mfd add command -label "Logistic Eqn Motifs" -command {LogisticMotifs; SetData logisitc}
				$mfd add command -label "------------ More Information ------------" -command {HelpLogistic} -foreground $evv(SPECIAL)
				$mfd add separator
			}
			if {$development_version} {
				$mfd add command -label "Couette Flow" -command {CouetteFlow; SetData couette}
				$mfd add command -label "------------ More Information ------------" -command {CouetteHelp} -foreground $evv(SPECIAL)
				$mfd add separator
			}
			if {[info exists released(newmix)]} {
				$mfd add command -label "RHYTHM PATTERNS" -command {} -background $evv(HELP)
				$mfd add command -label "------------ More Information ------------" -command {RhythmicKnotsHelp} -background $evv(HELP) -foreground $evv(SPECIAL)
				$mfd add separator  -background $evv(HELP)
				$mfd add command -label "Compare Two Rhythm Cells" -command {RhyCompare; SetData rhycompare}
				$mfd add separator
				$mfd add cascade -label "Til Patterns" -menu $mfd.tilpat
				$mfd add command -label "------------ More Information ------------" -command {RhythmicKnotsTILHelp} -foreground $evv(SPECIAL)
				$mfd add separator
				$mfd add cascade -label "Tilp Patterns" -menu $mfd.tilppat
				$mfd add command -label "------------ More Information ------------" -command {RhythmicKnotsTILPHelp} -foreground $evv(SPECIAL)
				$mfd add separator
				$mfd add cascade -label "Rhythm Pattern Sound-Index Modification" -menu $mfd.rhysub
				$mfd add command -label "------------ More Information ------------" -command {RhythmicIndexModHelp} -foreground $evv(SPECIAL)
				$mfd add separator
				$mfd add cascade -label "Sound Indexing Files"  -menu $mfd.rhyiii
				$mfd add command -label "------------ More Information ------------" -command {TilpSindexHelp} -foreground $evv(SPECIAL)
				$mfd add separator
				$mfd add cascade -label "Rhythm To Sound"  -menu $mfd.rhysnd
				$mfd add command -label "------------ More Information ------------" -command {TilpToMixHelp} -foreground $evv(SPECIAL)
				$mfd add separator
				$mfd add command -label "Manage Rhythm Histories" -command {Rhystory; SetData rhymanage}
				$mfd add command -label "------------ More Information ------------" -command {RhythmHistoryHelp} -foreground $evv(SPECIAL)

				set til [menu $mfd.tilpat -tearoff 0]
				$til add command -label "Repeat/Scale A Rhythm Pattern" -command {KnotExtend; SetData knotextend}
				$til add separator
				$til add command -label "Join (abutt) Rhythm Patterns" -command {KnotJoin; SetData knotjoin}
				$til add separator
				$til add command -label "Position Rhythm Pattern In 8-Chan Space" -command {KnotPosition; SetData knotpos}
				$til add separator
				$til add command -label "Count Distinct Sound-Index Vals In Pattern" -command {KnotMidiToMix 1 0; SetData knotcount}

				set tilp [menu $mfd.tilppat -tearoff 0]
				$tilp add command -label "Hilight Tilp Patterns On Workspace" -command {FindTILPfiles 0; SetData tilphi}
				$tilp add separator
				$tilp add command -label "Count Distinct Sound-Index Vals In Pattern" -command {KnotMidiToMix 1 0; SetData knotcount}
				$tilp add separator
				$tilp add command -label "Count Repeats Of Each Sound-Index In Pattern" -command {CountSndIndeces; SetData sindxcount}
				$tilp add separator
				$tilp add command -label "Repeat/Scale A Rhythm Pattern" -command {KnotExtend; SetData knotextend}
				$tilp add separator
				$tilp add command -label "Randomise A Rhythm Pattern" -command {RhythmPatternRand; SetData rhpatrand}
				if {[info exists released(unknot)]} {
					$tilp add separator
					$tilp add command -label "Unknot Rhythm Patterns" -command {UnKnot; SetData knotunknot}
					$tilp add separator
				}
				$tilp add command -label "Overlay Rhythm Patterns" -command {KnotLayer; SetData knotlayer}
				$tilp add separator
				$tilp add command -label "Join (abutt) Rhythm Patterns" -command {KnotJoin; SetData knotjoin}
				$tilp add separator
				$tilp add command -label "Split A Rhythm Pattern" -command {RhythmSplit; SetData rhpatsplit}
				if {[info exists released(rhymorph)] && [info exists released(rhymorph2)]} {
					$tilp add separator
					$tilp add command -label "Morph Between 2 Rhythm Patterns" -command {RhythmMorph; SetData rhpatmorph}
				}

				set rhsu [menu $mfd.rhysub -tearoff 0]

				$rhsu add command -label "Rhythm Pattern Sound-Index Substitution" -command {RhythmSoundSubstitute; SetData rymsub}
				$rhsu add command -label "------------ More Information ------------" -command {RhythmicIndexSubstitionHelp} -foreground $evv(SPECIAL)
				$rhsu add separator -background $evv(HELP)
				$rhsu add command -label "RHYTHM PATTERN SOUND-INDEX TRANSFER" -command {} -background $evv(HELP)
				$rhsu add command -label "------------ More Information ------------" -command {RhySnipHelp} -foreground $evv(SPECIAL) -background $evv(HELP)
				$rhsu add separator
				$rhsu add command -label "Snip-off Last Cell From Rhythm Pattern" -command {RhythmSnip; SetData rhpatsnip}
				$rhsu add separator
				$rhsu add command -label "Squeeze Snipped-off Rhythm Cell" -command {RhySqueeze; SetData rhsqueeze}
				$rhsu add separator
				$rhsu add command -label "Rhythm Pattern Sound-Index Transfer" -command {ForwardRecolorRhythmPattern; SetData rymrecol}

				set rhys [menu $mfd.rhysnd -tearoff 0]

				$rhys add command -label "Convert Rhythm To Mixfile And Mix To Snd" -command {KnotMidiToMix 0 1; SetData knottomidisnd}
				$rhys add separator
				$rhys add command -label "Convert Mixfile To Rhythm Pattern" -command {MmixToRhyCell; SetData knotmmxtorhy}
				$rhys add separator
				$rhys add command -label "Concatenate Rhythm-Pattern Sound-Outputs" -command {RhythmConcat; SetData rhsndconcat}

				set rhii [menu $mfd.rhyiii -tearoff 0]

				$rhii add command -label "Create A Sound Indexing File" -command {CreateSndIndex; SetData sndindexcreate}
				$rhii add separator
				$rhii add command -label "Concatenate Sound Indexing Files" -command {ConcatSndIndex; SetData sndindexconcat}
				$rhii add separator
				$rhii add command -label "Modify A Sound Indexing File" -command {ModifySndIndex; SetData sndindexmodify}
				$rhii add separator
				$rhii add command -label "Change Dir Inside Snd-Indexing File" -command {NewDirSndIndex; SetData sndindexdir}
				$rhii add separator
				$rhii add command -label "Get Sndfiles Inside Snd-Indexing File" -command {GetSndSndIndex; SetData sndindexget}
			}
		}
		
		if { $::tcl_platform(platform) == "windows" } {
			button $fz.tap     -text "Duration" -width 8 -command DoTimetap
			button $fz.taptwo  -text "Tempo" -width 8 -command DoTwoTimetap
			button $fz.taptap  -text "TapRhythm" -width 9 -command DoNuTimer
			menubutton $fz.nns  -text "Notebook" -width 8  -bg $evv(HELP) -menu $fz.nns.sub -relief raised
		} else {
			if {$macsmall} {
				button $fz.tap     -text "Dur" -width 4 -command DoTimetap -highlightbackground [option get . background {}]
			} else {
				#RWD width was 8
				button $fz.tap     -text "Duration"  -command DoTimetap -highlightbackground [option get . background {}]
			}
			#RWD button widths were 6 and 9
			button $fz.taptwo  -text "Tempo"  -command DoTwoTimetap -highlightbackground [option get . background {}]
			button $fz.taptap  -text "TapRhythm"  -command DoNuTimer -highlightbackground [option get . background {}]
			menubutton $fz.nns  -text "Notebook" -width 12  -menu $fz.nns.sub -relief raised ;# -bg $evv(HELP)
		}
		
#RWD 29/9/24 got here: diffs below are wrt foreground black. Can we use this on PC too? L 489 in PC version of file




		set mn [menu $fz.nns.sub -tearoff 0]
		$mn add command -label "VIEW" -command {} -background $evv(HELP) -foreground black
		$mn add separator
		$mn add command -label "See Latest Entry & Tasks (Command n)" -command {ShowReminder} -foreground black
		$mn add separator
		$mn add command -label "READ / WRITE" -command {}  -foreground black
		$mn add separator
		$mn add command -label "Dated Notebook (Cmd N)" -command {NnnSee ~~~$wl~~~} -foreground black
		$mn add command -label "Task List" -command {Tasks} -foreground black
		$mn add separator
		$mn add command -label "ADD LIST OF FILES" -command {}  -foreground black
		$mn add separator
		$mn add command -label "Workspace Selected Files" -command {FilesToNotebook wl} -foreground black
		$mn add command -label "Chosen Files List" -command "FilesToNotebook ch" -foreground black
		$mn add command -label "Directory Selected Files" -command {FilesToNotebook dl} -foreground black
		$mn add separator
		$mn add command -label "ADD CONTENT OF TEXTFILE" -command {}  -foreground black
		$mn add separator
		$mn add command -label "Workspace Selected File" -command {FileContentToNotebook wl} -foreground black
		$mn add command -label "From Chosen Files List" -command {FileContentToNotebook ch} -foreground black
		$mn add command -label "From Directory Listing" -command {FileContentToNotebook dl} -foreground black
		$mn add separator
		$mn add command -label "ADD LISTING NAME" -command {}  -foreground black
		$mn add separator
		$mn add command -label "Add Name Of Chosen Directory" -command {NnnSee ~~~$ww.1.b.de} -foreground black
		$mn add command -label "Selected B-List Name" -command {BlistToNotebook} -foreground black
		$mn add separator
		$mn add command -label "FIND FILE IN NOTEBOOK" -command {}  -foreground black
		$mn add separator
		$mn add command -label "Workspace Selected File" -command {NnnSee ~~~$wl} -foreground black
		$mn add command -label "Chosen File" -command {NnnSee ~~~$ch} -foreground black
		$mn add command -label "Directory List File" -command {NnnSee ~~~$dl} -foreground black
		$mn add separator
		$mn add command -label "CLEAR NOTEBOOK FOR NEW PROJECT" -command {}  -foreground black
		$mn add separator
		$mn add command -label "Clear And Backup Notebook" -command {ClearNotebook} -foreground black
		if { $::tcl_platform(platform) == "windows" } {
			menubutton $fz.ref -text "Reference" -width 8 -bg $evv(HELP) -menu $fz.ref.sub -relief raised
		} else {
			menubutton $fz.ref -text "Reference" -width 14 -menu $fz.ref.sub -relief raised ;# -bg $evv(HELP)
		}
		set mr [menu $fz.ref.sub -tearoff 0]
		$mr add command -label "VIEW" -command {}  -foreground black
		$mr add separator
		$mr add command -label "See Reference Values" -command "RefSee 0" -foreground black
		$mr add separator
		$mr add command -label "CREATE" -command {}  -foreground black
		$mr add separator
		$mr add command -label "Create Reference Value" -command "RefSee 0" -foreground black
		$mr add command -label "Keep Name Of Workspace Selected File" -command {RefStore wl} -foreground black
		$mr add command -label "Keep Name Of File On Chosen Files List" -command {RefStore ch} -foreground black
		$mr add separator
		$mr add command -label "DESTROY" -command {}  -foreground black
		$mr add separator
		$mr add command -label "Remove Reference Value" -command "RefSee 0" -foreground black
		$mr add command -label "Destroy All Reference Values (!!)" -command "DelAllRefs" -foreground black
		if {$macsmall} {
			menubutton $help.syscon -text "System" -menu $help.syscon.menu -relief raised -width 9
		} else {
#RWD -width was 16
			menubutton $help.syscon -text "System State" -menu $help.syscon.menu -relief raised
		}
		button $help.about -text "CDP" -command AboutCDP -bg white -fg $evv(SPECIAL) -highlightbackground [option get . background {}]
		set m [menu $help.syscon.menu -tearoff 0]

		$m add command -label "SYSTEM STATE" -command {}  -foreground black
		$m add separator
		if {!$sl_real} {
			$m add command -label "System Settings" -command TellSystemSettings -foreground black
		} else {
			$m add command -label "See Updates" -command DisplayUpdates -foreground black
			$m add separator
			$m add cascade -label "System Settings 1" -menu $m.sub1 -foreground black
			$m add cascade -label "System Settings 2" -menu $m.sub1a -foreground black
			set m_1 [menu $m.sub1 -tearoff 0]
			set m_1a [menu $m.sub1a -tearoff 0]
			$m_1 add command -label "VIEW" -command {}  -foreground black
			$m_1 add command -label "See System Settings" -command SeeSys -foreground black
			$m_1 add command -label "REINSTALL SYSTEM" -command {}  -foreground black
			$m_1 add command -label "Reinstall System" -command "ReinstallSystem" -foreground black
			$m_1 add command -label "Reinstall Instruments" -command "ReinstallInstruments" -foreground black
			$m_1 add command -label "RESET SYSTEM" -command {}  -foreground black
			$m_1 add command -label "Find Version Number Of CDP Process" -command {GetVersions} -foreground black
			$m_1 add command -label "Colour Style" -command {ChangeColour 0} -foreground black
			$m_1 add command -label "Change MAC Font" -command {ChangeMACFont} -foreground black
			$m_1 add command -label "Change Button_Text Width" -command {SetSmallDisplay} -foreground black
			$m_1 add command -label "Typical Bit Resolution" -command {ChangeSampsize 0} -foreground black
			$m_1 add cascade -label "Sample Rate(s)" -menu $m_1.sub -foreground black
			set m1s [menu $m_1.sub -tearoff 0]
			$m1s add command -label "All Rates" -command "ResetSrate 0 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "96000" -command "ResetSrate 96000 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "88200" -command "ResetSrate 88200 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "48000" -command "ResetSrate 48000 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "44100" -command "ResetSrate 44100 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "32000" -command "ResetSrate 32000 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "24000" -command "ResetSrate 24000 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "22040" -command "ResetSrate 22050 $ww.1.b.labels.msg3" -foreground black
			$m1s add command -label "16000" -command "ResetSrate 16000 $ww.1.b.labels.msg3" -foreground black
			$m_1 add command -label "Float Output On/Off" -command {SetFloatOut} -foreground black
			$m_1 add command -label "Ignore/Check Spurious Files At Startup" -command {IgnoreBadfiles} -foreground black
			$m_1 add command -label "Ignore/Display Routine Program Messages" -command {IgnoreProgMsgs} -foreground black
			$m_1 add command -label "FILE EXTENSIONS FOR SOUND DATA"  -command {} -background $evv(HELP) -foreground black
			$m_1 add command -label "\"wav\" Or \"aiff\" For SOUND Files"  -command {WavAiffFlip} -foreground black
			$m_1 add command -label "\"wav\" Or \"wxyz\" For AMBISONIC WAV Files"  -command {AmbWxyzExt} -foreground black
			$m_1 add command -label "\"amb\" Or \"wav\" For AMBISONIC WAVEX Files" -command {AmbWavExt} -foreground black
			$m_1 add separator
			$m_1 add command -label "Get Maxsample On Loading Sound" -command {SetParseTheMax 1} -foreground black
			$m_1 add command -label "Don't Get Maxsample On Loading Sound" -command {SetParseTheMax 0} -foreground black
			$m_1 add separator
			$m_1 add command -label "Use Large Screen For Sound View" -command {SetBigSnack 1} -foreground black
			$m_1 add command -label "Use Small (Extendable) Screen"   -command {SetBigSnack 0} -foreground black
			if {[info exists sv_tl]} {
				$m_1 add command -label "Don't Force Sound View Display To Top Left"   -command {SetSviewToTopLeft 0} -foreground black
			} else {
				$m_1 add command -label "Force Sound View Display To Top Left"   -command {SetSviewToTopLeft 1} -foreground black
			}
			if {[info exists directtoview]} {
				$m_1 add command -label "\"Play\" (~~NOT~~ \"Snd View\") With Dbl-Clk On Wksp"   -command {SaveDirectToViewStatus 0} -foreground black
			} else {
				$m_1 add command -label "\"Snd View\" With Double-Click On Workspace"   -command {SaveDirectToViewStatus 1} -foreground black
			}
			$m_1 add command -label "Set (Don't Set) Last-Run Vals On Params Page (But ~~NOT~~ Mixes)" -command {SetParamLastVals} -foreground black
			$m_1 add separator
			$m_1 add command -label "Bulk Processes: Trap EOF Call" -command {SetEofTrap 1} -foreground black
			$m_1 add command -label "Bulk Processes: Don't Trap EOF Call" -command {SetEofTrap 0} -foreground black
			$m_1 add command -label "~ More Information ~" -command {EofTrapHelp} -foreground $evv(SPECIAL)
			$m_1 add separator
			$m_1 add command -label "Set (Don't Set) Last-Run Vals On Params Page (but ~~Not~~ Mixes)" -command {SetParamLastVals}
			$m_1 add separator
			if {$multiple_file_extensions && $can_change_environment_variables} {
				$m_1 add command -label "Output Soundfile Extension" -command {ChangeSndfileExtension} -foreground black
				$m_1 add separator
			}
			$m_1a add command -label "Play: Hide (Don't Hide) Main Window During Play" -command {PlayIconify} -foreground black
			$m_1a add command -label "~ More Information ~" -command {PlayIconifyHelp} -foreground black
			$m_1a add separator
			$m_1a add command -label "MIXING" -command {} -background $evv(HELP) -foreground black
			$m_1a add command -label "Set (Don't Set) Last-Run Vals As Dflt" -command {SetMixLastVals} -foreground black
			$m_1a add command -label "Dovetail (Don't Dovetail) Incomplete Mix" -command {SetDoveMix} -foreground black
			$m_1a add separator
			$m_1a add command -label "Option to Backup ALL To External Drive" -command {SetShowStick} -foreground black
			$m_1a add command -label "Keep/Show Log Of All File Changes" -command {SetBakupLog} -foreground black
			$m_1a add separator
;# 2023 DEFAULT SETTING AT SETUP IS SNDSYS EXTENSIONS many :: "new_cdp_extensions" ON : REMOVE USER'S ABILITY TO ALTER THIS			
;#			$m_1a add command -label "Sndsys Extensions: One Or Many" -command {ChangeFileExtensions} -foreground black
;#			$m_1a add command -label "Textfile Extensions: User Defined?" -command {ChangeTextfileExtensions} -foreground black
			
			
			$m_1a add command -label "Property Files: Change Protocol ?" -command {ChangePropfilesProtocol} -foreground black
			$m_1a add command -label "Property Files: Full Parse On/Off" -command {SetPropsSearchProtocol} -foreground black
			$m_1a add command -label "Subpatch Numbering: Change Protocol ?" -command {ChangeSubpatchProtocol} -foreground black
			$m_1a add separator
			$m_1a add command -label "Set Directory for CDP Programs" -command {SetCDPexecsDir 1} -foreground black
			$m_1a add command -label "Set Command To Play soundfiles" -command {SetupPlayProgram 1 0} -foreground black
;# RWD in PC code: extra code here to control buffering in pvplay

			$m_1a add command -label "Set Device To Play soundfiles " -command {SetPlayDevice} -foreground black
			$m_1a add command -label "Reset System Clock" -command ResetSystemClock -foreground black
			$m_1a add command -label "Change Path To Your 'Wish' Program ?" -command {DefineWishPath 1} -foreground black
			$m_1a add command -label "Multi-Playback Setting From Wkspace" -command {SavePlayStep} -foreground black
			$m_1a add command -label "Modify Soundview Facility" -command {GetSnackState 0} -foreground black
			if {$tv_active} {
				$m_1a add command -label "Midi Input Device: Set or Change"   -command SetMidiInputDeviceTV -foreground black
			} else {
				$m_1a add command -label "" -command {}
			}
			$m_1a add separator
			$m_1a add command -label "Set Private Directories" -command {SetPrivate} -foreground black
			$m_1a add separator
			$m_1a add command -label "RESET SYSTEM FOR NEXT SESSION" -command {}  -foreground black
			$m_1a add separator
			$m_1a add command -label "Set Screen Size" -command {EstablishScreenSize 0} -foreground black
	;# NB THIS LINE HAS AN 'entryconfig'
			if {[info exists shortwindows]} {
				$m_1a add command -label "Lengthen Windows" -command {GetShortWindows 0} -foreground black
			} else {
				$m_1a add command -label "Shorten Windows" -command {GetShortWindows 0} -foreground black
			}
    ;# AND THIS LINE IS LINKED TO THAT 'entryconfig'
			if {[info exists bigmix]} {
				$m_1a add command -label "Normal Mix Edit Page" -command {SetExtendableMixEditPage 0}
			} else {
				$m_1a add command -label "Extended Mix Edit Page" -command {SetExtendableMixEditPage 1}
			}
			$m_1a add command -label "Set New User Help" -command {SetNewUserHelp} -foreground black
			$m_1a add command -label "Set Interface Redesign" -command {SetRedesign} -foreground black
		}
		$m add cascade -label "Disk Space" -menu $m.sub2 -foreground black
		set m_2 [menu $m.sub2 -tearoff 0]
		$m_2 add command -label "Available" -command {SeeDiskspace} -foreground black
		$m_2 add separator
		$m_2 add command -label "Used" -command {set diskused 1; SeeDiskspace; set diskused 0} -foreground black
		if {!$sl_real} {
			$m add command -label "Session Logs" -command TellSessionLogs -foreground black
		} else {
			$m add cascade -label "Session Logs" -menu $m.sub3 -foreground black
			set m_3 [menu $m.sub3 -tearoff 0]
			$m_3 add command -label "Search Logs for File or Parameter value" -command {SearchLogs "" 0} -foreground black
			$m_3 add command -label "Sort / Remove Logs of Previous Sessions" -command EditLogs -foreground black
			$m_3 add command -label "Destroy Bad Logs" -command ClearBadLogs -foreground black
			$m_3 add separator
			$m_3 add command -label "Destroy All Logs (!!)" -command ClearLogs -foreground black
		}
		$m add separator
		if {!$sl_real} {
			$m add command -label "Saved Workspace & Chosenfile Listings" -command TellSavedWkspace -foreground black
		} else {
			$m add cascade -label "Saved Workspace & Chosenfile Listings" -menu $m.sub4 -foreground black
			set m_4 [menu $m.sub4 -tearoff 0]
			$m_4 add command -label "Sort / Remove" -command "DelStordFlistings 0" -foreground black
			$m_4 add separator
			$m_4 add command -label "Delete All (!!)" -command "DelStordFlistings -1" -foreground black
		}
		$m add cascade -label "Directory Listings" -menu $m.sub5 -foreground black
		set m_5 [menu $m.sub5 -tearoff 0]
		$m_5 add command -label "SEE/EDIT DIRECTORY LISTING" -command {} -foreground black
		$m_5 add separator
		$m_5 add command -label "Recently Used Directories" -command {EditRecentDirList 1 0} -foreground black
		$m_5 add command -label "File Backup Directories" -command "EditBakupList" -foreground black
		$m_5 add separator
		$m_5 add command -label "Show Backup Dirs At Session Start" -command "SetShowDirs" -foreground black
		$m_5 add separator
		$m_5 add command -label "MANAGE EMPTY DIRECTORIES" -command {}  -foreground black
		$m_5 add separator
		$m_5 add command -label "Forget those in current use" -command "PurgeEmptyDirs" -foreground black
		$m_5 add command -label "Destroy those used recently" -command "RemoveEmptyDirs" -foreground black
		$m_5 add separator
		$m_5 add command -label "COMPARE TWO DIRECTORIES" -command {}  -foreground black
		$m_5 add separator
		$m_5 add command -label "Names Of Files" -command "CompareDirs 0" -foreground black
		$m_5 add command -label "Names Of Files & Subdirectories" -command "CompareDirs 1" -foreground black
		$m_5 add separator
		$m_5 add command -label "To compare Files themselves" -command {} -foreground $evv(SPECIAL)
		$m_5 add command -label "Use SOUND INFO : Compare Files" -command {} -foreground $evv(SPECIAL)

		$m add cascade -label "Multichannel Options" -menu $m.sub5m -foreground black
		set m_5m [menu $m.sub5m -tearoff 0]
		$m_5m add command -label "Always Recycle as Mono"     -command "SetThumbnailRecyclingStatus 1" -foreground black
		$m_5m add command -label "Recycle as Mono on request" -command "SetThumbnailRecyclingStatus 2" -foreground black
		$m_5m add command -label "Recycle as Multichannel"    -command "SetThumbnailRecyclingStatus 0" -foreground black

		$m add command -label "Last Run Message Saved" -command SeeRunMessages -foreground black
		$m add command -label "Table Editor Macros" -command EditTEMacrosList -foreground black
		$m add command -label "Recent File Names Used : Edit" -command EditRecentNamesList -foreground black
		$m add separator
		if {$macsmall} {
			button $f.calc  -text "Calculate" -width 8 -command "MusicUnitConvertor 0 0"  -highlightbackground [option get . background {}]
			button $f.tedit -text "Table Ed" -width 8 -command "set p_pg 0; TableEditor"  -highlightbackground [option get . background {}]
		} else {
#RWD button sizes were 12
			button $f.calc  -text "Calculator"  -command "MusicUnitConvertor 0 0"  -highlightbackground [option get . background {}]
			button $f.tedit -text "Table Editor" -command "set p_pg 0; TableEditor"  -highlightbackground [option get . background {}]
		}
		set wrksp_emph $f.pro
		if {[VBoxReleased]} {
#2023 $f.pvx 
			pack $f.pro $f.bulk $f.machcr $f.batch $f.hist $f.vbox $f.pvx -side left -fill x -padx 1	;#	Pack buttons and entry box into frame
		} else {
			pack $f.pro $f.bulk $f.machcr $f.batch $f.hist $f.pvx -side left -fill x -padx 1	;#	Pack buttons and entry box into frame
		}
#RWD need to change -side assignments?
		pack $f.calc $f.tedit -side right -padx 1
		pack $fz.ref $fz.nns -side right -padx 1		
#RWD just space padding - simplest not to use it at all
#    	pack $fz.dum -side right
		pack $fz.tap $fz.taptwo $fz.taptap -side right -padx 1		
		if {$float_out} {
			label $fz.type -text "Force Floating\nPoint Outfiles" -fg $evv(SPECIAL) -width 15
		} else {
			label $fz.type -text "Out Format Set\nTo Infile Format" -fg $evv(SPECIAL);# -width 15
		}
		pack $fz.type $fz.bkgd -side right -padx 20
		if {$data_released} {
			pack $fz.data -side right -padx 2
		}
		set mez2 [frame $wwa.mez2 -borderwidth $evv(SBDR)]	;#	Create frame for DIRECTORY title
	 	set fend [frame $wwa.endd -borderwidth $evv(SBDR)]	;#	Create frame for actual listboxes

		set fl	[frame $fend.l -borderwidth $evv(SBDR)] ;#	Establish frame for larger listbox
		frame $fl.over  -borderwidth $evv(SBDR)

		label $fl.over.el -text "" -fg $evv(SPECIAL)
		pack $fl.over.el -side right -padx 1						

		label $fl.title -text "WORKSPACE" -fg $evv(SPECIAL)	-bg $evv(EMPH) -font bigfnt ;#	Establish major listbox
	 	frame $fl.cnts  -borderwidth $evv(SBDR)
		entry $fl.cnts.new -width 3 -textvariable wksp_cnt -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $fl.cnts.nl  -text "New Files"
		pack  $fl.cnts.new $fl.cnts.nl -side left
		entry $fl.cnts.all -width 3 -textvariable total_wksp_cnt -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $fl.cnts.al  -text "Total Files"

		checkbutton $fl.cnts.remem -variable w_remem -text "Store" -command {RememberList wl 1}
		checkbutton $fl.cnts.resto -variable w_resto -text "Recall" -command {RecallList wl}

		pack  $fl.cnts.remem $fl.cnts.resto -side left -fill x -expand true
		pack  $fl.cnts.all $fl.cnts.al -side right

		frame $fl.new -borderwidth $evv(SBDR)
		frame $fl.new2 -borderwidth $evv(SBDR)
		set wl [Scrolled_Listbox $fl.l -width 64 -height $evv(WKSPACE_HEIGHT) -selectmode extended -bg $evv(EMPH)]
		frame $fl.sub
		frame $fl.sub.cho
		frame $fl.sub.qik
		frame $fl.sub.qik.qik
		radiobutton $fl.sub.cho.tochos -text "Selected Files to Chosen List" -variable ddumm -command "GetNextToChosen 3" -value 8
		radiobutton $fl.sub.cho.adchos -text "Add Selected Files to Chosen" -variable ddumm -command "GetNextToChosen 4" -value 9
		radiobutton $fl.sub.cho.totop -text "Add Selected Files to Top of Chosen" -variable ddumm -command "GetNextToChosen 5" -value 10
		frame $fl.sub.cho.mix
		radiobutton $fl.sub.cho.mix.lmix -text "Last Mix" -variable ddumm -command "GetLastMixfile 0" -value 11
		radiobutton $fl.sub.cho.mix.mmix -text "Main Mix" -variable ddumm -command "GetMainMixfile" -value 12
		radiobutton $fl.sub.cho.mix.rmix -text "Recent Mixes" -variable ddumm -command "GetRecentMixfiles" -value 13
		pack $fl.sub.cho.mix.lmix $fl.sub.cho.mix.mmix $fl.sub.cho.mix.rmix -side left
		frame $fl.sub.cho.thum
		if {[info exists released(mchanpan)]} {
			checkbutton $fl.sub.cho.thum.bb -variable set_thumbnailed -text "Work with mono thumbnail" -command WorkWithThumbnail
			pack $fl.sub.cho.thum.bb -side right
		}
		pack $fl.sub.cho.tochos $fl.sub.cho.adchos $fl.sub.cho.totop $fl.sub.cho.mix $fl.sub.cho.thum -side top -anchor w

		button $fl.sub.qik.which -text "Which Menu?" -command "WkWhich"  -highlightbackground [option get . background {}] -bg $evv(HELP)
		pack $fl.sub.qik.which -side right
		set qikbutton [button $fl.sub.qik.qik.qik -text "QUICK" -command {Inf "No Quick Command Preset"} -highlightbackground [option get . background {}]]
		button $fl.sub.qik.qik.qset -text "SETUP" -command ActivateQikbutton -highlightbackground [option get . background {}]
		pack $fl.sub.qik.qik.qik $fl.sub.qik.qik.qset -side right -padx 2
		button $fl.sub.qik.refresh -text "Refresh Workspace Data" -command "RefreshWorkspace" -highlightbackground [option get . background {}] -bg $evv(HELP)
		frame $fl.sub.qik.main
		button $fl.sub.qik.main.play -text "Play Main Mix" -command "PlayMainMix" -bg $evv(SNCOLOR) -width 14  -highlightbackground [option get . background {}]
		button $fl.sub.qik.main.kill -text "Not!" -command "DumpMainMixSnd" -highlightbackground [option get . background {}]
		pack $fl.sub.qik.main.play $fl.sub.qik.main.kill -side left -padx 2
		pack $fl.sub.qik.which $fl.sub.qik.qik $fl.sub.qik.refresh -side top -pady 2
		pack $fl.sub.qik.main -side top -padx 2 -pady 2

		pack $fl.sub.cho -side left
		pack $fl.sub.qik -side right
#RWD
		if { $::tcl_platform(os) == "Darwin" } {
			menubutton $fl.new.all -text "Any/All Files"  -menu $fl.new.all.menu -relief raised -highlightbackground [option get . background {}]
		} else {
			menubutton $fl.new.all -text "Any/All Files" -width 16 -menu $fl.new.all.menu -relief raised
		}
		set mall [menu $fl.new.all.menu -tearoff 0]
		$mall add command -label "DO IT AGAIN" -command {} -background $evv(HELP) -foreground black
		$mall add separator
		$mall add command -label "" -command {} -foreground black
		$mall add separator
		$mall add command -label "SORT, REFRESH" -command {}  -foreground black
		$mall add separator
		$mall add cascade -label "Sort Workspace" -menu $mall.sub1 -foreground black
		set mall1 [menu $mall.sub1 -tearoff 0]

		$mall1 add cascade -label "Alphabetical" -menu $mall1.sub0 -foreground black
		set mall1_0 [menu $mall1.sub0 -tearoff 0]
		$mall1_0 add command -label "Alphabetical Order" -command "SortListing $wl 0; SetSel3 aplha" -foreground black
		$mall1_0 add command -label "Reverse Alphabetical Order" -command "SortListing $wl 1; SetSel3 ahpla" -foreground black
		$mall1_0 add command -label "Reverse Spelling Alphabetical" -command "SortListing $wl 2; SetSel3 lleps" -foreground black
		$mall1_0 add separator
		$mall1_0 add command -label "IGNORE DIRECTORY " -command {}  -foreground black
		$mall1_0 add separator
		$mall1_0 add command -label "Alphabetical Order" -command "SortListing $wl 3; SetSel3 alphanodir" -foreground black
		$mall1_0 add command -label "Reverse Alphabetical Order" -command "SortListing $wl 4; SetSel3 ahplanodir" -foreground black
		$mall1_0 add command -label "Reverse Spelling Alphabetical" -command "SortListing $wl 5; SetSel3 llepsnodir" -foreground black
		$mall1 add separator
		$mall1 add cascade -label "BY SPECIFIED STRING"  -menu $mall1.sub1 -foreground black
		set mall1_1 [menu $mall1.sub1 -tearoff 0]
		$mall1_1 add command -label "Start With String, to top" -command "StrSortWl 0; SetSel3 sortstart" -foreground black
		$mall1_1 add command -label "Contain       String, to top" -command "StrSortWl 1; SetSel3 sortcontain" -foreground black
		$mall1_1 add command -label "End With     String, to top" -command "StrSortWl 2; SetSel3 sortend" -foreground black
		$mall1 add separator
		$mall1 add cascade -label "BY TYPE"  -menu $mall1.sub2 -foreground black
		set mall1_2 [menu $mall1.sub2 -tearoff 0]
		$mall1_2 add command -label "Chosen Files to top" -command "SortWl c; SetSel3 sortch" -foreground black
		$mall1_2 add command -label "Soundsystem files to top" -command "SortListingType $wl t; SetSel3 sortsys" -foreground black
		$mall1_2 add command -label "Sound files to top" -command "SortListingType $wl s; SetSel3 sortsnd" -foreground black
		$mall1_2 add command -label "Analysis files to top" -command "SortListingType $wl a; SetSel3 sortanal" -foreground black
		$mall1_2 add command -label "Pitch and transpos files to top" -command "SortListingType $wl p; SetSel3 sortpch" -foreground black
		$mall1_2 add command -label "Formant files to top" -command "SortListingType $wl f; SetSel3 sortfmnt" -foreground black
		$mall1_2 add command -label "Envelope files to top" -command "SortListingType $wl e; SetSel3 sortenv" -foreground black
		$mall1_2 add command -label "Text files to top" -command "SortListingType $wl T; SetSel3 sorttxt" -foreground black
		$mall1_2 add command -label "Breakpoint files to top" -command "SortListingType $wl b; SetSel3 sortbrk" -foreground black
		$mall1_2 add command -label "Mix files to top" -command "SortListingType $wl m; SetSel3 sortmix" -foreground black
		$mall1_2 add command -label "Multichan Mix files to top" -command "SortListingType $wl q; SetSel3 sortmult" -foreground black
		$mall1_2 add command -label "Sound-Listing files to top" -command "SortListingType $wl k; SetSel3 sortsndlist" -foreground black
		$mall1_2 add command -label "Properties files to top" -command "SortListingType $wl P; SetSel3 sortprop" -foreground black
		$mall1 add separator
		$mall1 add cascade -label "BY SIZE"  -menu $mall1.sub3 -foreground black
		set mall1_3 [menu $mall1.sub3 -tearoff 0]
		$mall1_3 add command -label "Largest Soundfiles to top" -command "SortWl bs; SetSel3 sortarge" -foreground black
		$mall1_3 add command -label "Smallest Soundfiles  to top" -command "SortWl ss; SetSel3 sortsmall" -foreground black
		$mall1 add separator
		$mall1 add cascade -label "BY STATUS"   -menu $mall1.sub4 -foreground black
		set mall1_4 [menu $mall1.sub4 -tearoff 0]
		$mall1_4 add command -label "Backed-Up files to top" -command "SortListingNew $wl b; SetSel3 sortbak" -foreground black
		$mall1_4 add command -label "Not-Backed-Up files to top" -command "SortListingNew $wl n; SetSel3 unbak" -foreground black
		$mall1 add separator
		$mall1 add cascade -label "BY DATE (may be slow)"    -menu $mall1.sub5 -foreground black
		set mall1_5 [menu $mall1.sub5 -tearoff 0]
		$mall1_5 add command -label "Newest files to top" -command "SortWl r; SetSel3 sortnew" -foreground black
		$mall1_5 add command -label "Oldest files to top" -command "SortWl o; SetSel3 sortold" -foreground black
		$mall1_5 add command -label "Newest Soundfiles to top" -command "SortWl rs; SetSel3 sortnewsnd" -foreground black
		$mall1_5 add command -label "Oldest Soundfiles to top" -command "SortWl os; SetSel3 sortoldsnd" -foreground black
		$mall1 add separator
		$mall1 add command -label "As Chosen Files Order" -command "SortWl ch; SetSel3 sortchorder" -foreground black
		$mall1 add command -label "As Playlist Order" -command "SortWl ps; SetSel3 sortplorder" -foreground black
		$mall1 add separator
		$mall1 add cascade -label "Move Filetype To TOP"  -menu $mall1.sub22 -foreground black
		set mall1_22 [menu $mall1.sub22 -tearoff 0]
		$mall1_22 add command -label "Soundsystem files to top" -command "MoveListingType $wl t; SetSel3 topsys" -foreground black
		$mall1_22 add command -label "Sound files to top" -command "MoveListingType $wl s; SetSel3 topsnd" -foreground black
		$mall1_22 add command -label "Analysis files to top" -command "MoveListingType $wl a; SetSel3 topanal" -foreground black
		$mall1_22 add command -label "Pitch and transpos files to top" -command "MoveListingType $wl p; SetSel3 toppch" -foreground black
		$mall1_22 add command -label "Formant files to top" -command "MoveListingType $wl f; SetSel3 topfmnt" -foreground black
		$mall1_22 add command -label "Envelope files to top" -command "MoveListingType $wl e; SetSel3 topenv" -foreground black
		$mall1_22 add command -label "Text files to top" -command "MoveListingType $wl T; SetSel3 toptxt" -foreground black
		$mall1_22 add command -label "Breakpoint files to top" -command "MoveListingType $wl b; SetSel3 topbrk" -foreground black
		$mall1_22 add command -label "Mix files to top" -command "MoveListingType $wl m; SetSel3 topmix" -foreground black
		$mall1_22 add command -label "Multichan Mix files to top" -command "MoveListingType $wl q; SetSel3 topmult" -foreground black
		$mall1_22 add command -label "Sound-Listing files to top" -command "MoveListingType $wl k; SetSel3 topsndlist" -foreground black
		$mall add command -label "Update Data On All Workspace Files"    	-command "RefreshWorkspace; SetSel3 update" -foreground black
		$mall add separator
		$mall add command -label "SELECT SPECIFIC FILES" -command {}  -foreground black
		$mall add separator
		$mall add command -label "All Chosen Files"    	-command "ChosSelect; SetSel3 selchos" -foreground black
		$mall add cascade -label "Other Specific Files" -menu $mall.sub13 -foreground black
		set mall13 [menu $mall.sub13 -tearoff 0]
		$mall13 add command -label "RELATED TO CURRENT SELECTION" -command {} -foreground black
		$mall13 add separator
		$mall13 add command -label "Files In Directory Of Selected File"    	-command {SelectType sel; SetSel3 seldir} -foreground black
		$mall13 add command -label "Files In Specified Directory"    	-command {SelectSpecDir; SetSel3 seldirspec} -foreground black
		$mall13 add command -label "All Unselected Files"    	-command "InvertSelect; SetSel3 selundir" -foreground black
		$mall13 add command -label "Higlighted Files Not On Chosenlist"    	-command "InvertSelectChosen; SetSel3 selunseldir"
		$mall13 add separator
		$mall13 add command -label "BACKED UP OR NOT" -command {} -foreground black
		$mall13 add separator
		$mall13 add command -label "All Non Backed-Up Files"    	-command {SelectType nonbak; SetSel3 selunbak} -foreground black
		$mall13 add command -label "All Non Backed-Up Sounds"    	-command {SelectType nonbaksnd; SetSel3 selunbaksnd} -foreground black
		$mall13 add command -label "All Backed-Up Files"    	-command {SelectType bak; SetSel3 selbak} -foreground black
		$mall13 add separator ;# -background $evv(HELP)
		$mall13 add command -label "TYPE OF FILE" -command {}  -foreground black
		$mall13 add separator ;# -background $evv(HELP)
		$mall13 add command -label "Sound Files"    	-command {SelectType snd; SetSel3 selsnd} -foreground black
		$mall13 add command -label "Sound Files With Odd Sample Rates"    -command {SelectType srate; SetSel3 selsrate} -foreground black
		$mall13 add cascade -label "Sound With Specific Channel Count" -menu $mall.sub130		 -foreground black
		set mall130 [menu $mall.sub130 -tearoff 0]
		$mall130 add command -label "Mono"		-command "SelectChans 1; SetSel3 selchan1"  -foreground black
		$mall130 add command -label "Stereo"		-command "SelectChans 2; SetSel3 selchan2"  -foreground black
		$mall130 add command -label "4-channel"  -command "SelectChans 4; SetSel3 selchan4"  -foreground black
		$mall130 add command -label "5-channel"  -command "SelectChans 5; SetSel3 selchan5"  -foreground black
		$mall130 add command -label "7-channel"  -command "SelectChans 7; SetSel3 selchan7"  -foreground black
		$mall130 add command -label "8-channel"  -command "SelectChans 8; SetSel3 selchan8"  -foreground black
		$mall130 add command -label "16-channel" -command "SelectChans 16; SetSel3 selchan16"  -foreground black
		$mall13 add command -label "Sound Files With Pitchmarks"    -command "HilitePmarks $wl; SetSel3 selpmark" -foreground black
		$mall13 add command -label "Soundfile Listings (Text)"  -command {SelectType sndlist; SetSel3 selsndlist} -foreground black
		$mall13 add command -label "Properties Files"  -command {SelectType props; SetSel3 selprop} -foreground black
		$mall13 add separator
		$mall13 add command -label "Analysis Files"    	-command {SelectType anal; SetSel3 selanal} -foreground black
		$mall13 add command -label "Batch Files"    -command {SelectType batch; SetSel3 selbatch} -foreground black
		$mall13 add command -label "Envelope Files (Binary)"    	-command {SelectType envel; SetSel3 selenv} -foreground black
		$mall13 add command -label "Formant Files (Binary)"    	-command {SelectType formant; SetSel3 selfmnt} -foreground black
		$mall13 add command -label "Mix Files"    	-command {SelectType mix; SetSel3 selmix} -foreground black
		$mall13 add command -label "Multichannel Mix Files"    	-command {SelectType multimix; SetSel3 selmulti} -foreground black
		$mall13 add command -label "Sounds In Known Mixfiles"   -command {SelectType inmix; SetSel3 selinmix} -foreground black
		$mall13 add command -label "Non-Backed-Up Snds In Mixfiles"   -command {SelectType inmixun; SetSel3 selinmixun} -foreground black
		$mall13 add command -label "Pitch Files (Binary)"    	-command {SelectType pitch; SetSel3 selpch} -foreground black
		$mall13 add command -label "Transposition Files (Binary)"    	-command {SelectType transpos; SetSel3 seltrans} -foreground black
		$mall13 add command -label "Text Files"    	-command {SelectType text; SetSel3 seltxt} -foreground black
		$mall13 add separator ;# -background $evv(HELP)
		$mall13 add command -label "NAME OF FILE" -command {}  -foreground black
		$mall13 add separator ;# -background $evv(HELP)
		$mall13 add command -label "Files With Segment Value In Name" -command { $wl selection clear 0 end; MassageFilenames hiliteseg 0 $wl; SetSel3 selseg} -foreground black
		$mall13 add command -label "With Segment Value In Specific Segment"  -command { $wl selection clear 0 end; MassageFilenames selfiles 0 $wl; SetSel3 selseghere} -foreground black
		$mall13 add command -label "...ditto, But Sounds Only"  -command {$wl selection clear 0 end; MassageFilenames selfiles 1 $wl; SetSel3 selsegsnd} -foreground black
		$mall13 add command -label "Sounds With Names Ending In ..."  -command {$wl selection clear 0 end; MassageFilenames endnames 2 $wl; SetSel3 selsegend}
		$mall13 add command -label "Sounds With Names Starting With..."  -command {$wl selection clear 0 end; MassageFilenames sttnames 2 $wl; SetSel3 selsegstt}
		$mall13 add separator ;# -background $evv(HELP)
		$mall13 add command -label "POSITION OF FILE" -command {}  -foreground black
		$mall13 add separator ;# -background $evv(HELP)
		$mall13 add command -label "Select By Position In Listing" -command "ListingPosition $wl; SetSel3 selpos" -foreground black
		$mall add command -label "Deselect All Files" -command "$wl selection clear 0 end; SetSel3 unsel" -foreground black
		$mall add command -label "Remember Selection" -command "WkspaceSelectionSave; SetSel3 selmem" -foreground black
		$mall add command -label "Recall Selection" -command "WkspaceSelectionRecall; SetSel3 selrecall" -foreground black
		$mall add separator
		$mall add command -label "CLEAR FILES FROM WORKSPACE" -command {}  -foreground black
		$mall add separator
		$mall add command -label "All Backed-Up Files"     -command {ClearWkspace 0; SetSel3 clearbak} -foreground black
		$mall add command -label "All Except Chosen Files" -command {ClearWkspace 1; SetSel3 clearunchos} -foreground black
		$mall add separator
		$mall add command -label "KEEP INFORMATION ABOUT WORKSPACE" -command {}  -foreground black
		$mall add separator
		$mall add cascade -label "Make A Text Listing Of Files" -menu $mall.sub3 -foreground black
		set mall3 [menu $mall.sub3 -tearoff 0]
		$mall3 add command -label "All Files"	   			-command "WkToFile all 0; SetSel3 txtlist" -foreground black
		$mall3 add command -label "Soundfiles"     			-command "WkToFile snd 0; SetSel3 txtlistsnd" -foreground black
		$mall3 add command -label "Soundfiles & Their Durations"	-command "WkToFile sndur 0; SetSel3 txtlistsndur" -foreground black
		$mall3 add command -label "Sound-System Files"     	-command "WkToFile sys 0; SetSel3 txtlistsys" -foreground black
		$mall3 add command -label "Text Files"     			-command "WkToFile txt 0; SetSel3 txtlistxt" -foreground black
		$mall add separator
		$mall add command -label "PITCH MARKS" -command {}  -foreground black
		$mall add separator
		$mall add command -label "Display Pitch Marks With File Selection" -command "SetShowPmarks; SetSel3 pmarkshow" -foreground black
		$mall add command -label "Hilite All Files With Pitchmarks" -command "HilitePmarks $wl; SetSel3 pmarkhilite" -foreground black
		$mall add separator
		$mall add command -label "CREATE FILES" -command {}  -foreground black
		$mall add separator
		$mall add command -label "Create A Textfile" 		   	-command "Create_Textfile; SetSel3 creatxt" -foreground black
		$mall add command -label "Create A Brkpnt File" 		-command "Create_Brkfile; SetSel3 creabrk" -foreground black
		$mall add separator
		$mall add command -label "DESTROY FILES (!!)" -command {}  -foreground black
		$mall add separator
		$mall add command -label "All Analysis Files On Wkspace (!!)"  -command "DeleteAllAnalFromSystem" -foreground black
		$mall add command -label "Too Short Sounds (!!)" -command "DeleteFromSystem -1" -foreground black
		$mall add command -label "Too Quiet Sounds (!!)" -command "DeleteFromSystem -2" -foreground black
		$mall add separator
		$mall add command -label "NAMED WORKSPACES" -command {}  -foreground black
		$mall add separator
		$mall add command -label "Save Workspace with Name" -command "BakupNamedWkspace" -foreground black
		$mall add command -label "Load Named Workspace" -command "LoadNamedWkspace" -foreground black


		if {$macsmall} {
			menubutton $fl.new.few -text "Selected Files" -width 14 -menu $fl.new.few.menu -relief raised
		} else {
#RWD		menubutton $fl.new.few -text "Selected Files Only" -width 23 -menu $fl.new.few.menu -relief raised
            menubutton $fl.new.few -text "Selected Files Only" -menu $fl.new.few.menu -relief raised
		}
		set mfew [menu $fl.new.few.menu -tearoff 0]
		$mfew add command -label "DO IT AGAIN" -command {}  -foreground black
		$mfew add separator
		$mfew add command -label "" -command {} -foreground black
		$mfew add separator
		$mfew add command -label "PROPERTIES, SORT, UPDATE" -command {}  -foreground black
		$mfew add separator
		$mfew add cascade -label "Properties" -menu $mfew.sub2 -foreground black
		set mfew2 [menu $mfew.sub2 -tearoff 0]
		$mfew2 add command -label "Properties"     			-command "Show_Props workspace 0; SetSel prop" -foreground black
		$mfew2 add command -label "Duration(s)"     			-command "Show_Props workspace dur; SetSel dur" -foreground black
		$mfew2 add command -label "Duration Difference"			-command "Show_Props workspace durdif; SetSel durdif" -foreground black
		$mfew2 add command -label "Duration Sum"				-command "Show_Props workspace dursum; SetSel dursum"
		$mfew2 add command -label "Sample Count"			    -command "Show_Props workspace durdif; SetSel samps" -foreground black
		$mfew2 add command -label "Channel Count(s)"     		-command "Show_Props workspace chans; SetSel chan" -foreground black
		$mfew2 add command -label "Window Size(s)"     			-command "Show_Props workspace winlen; SetSel window" -foreground black
		$mfew2 add command -label "Maximum Sample(s) (Cntrl J)" -command "NewGetMaxsamplesOnWkspace; SetSel maxsamp"
		$mfew2 add command -label "Recalculate Max Sample(s)"   -command "GetMaxsamps 0 1; SetSel recalc" -foreground black
		$mfew2 add command -label "Hilight 0-Level Sounds"		-command "MarkZeroLevelFiles 0; SetSel hizero" -foreground black
		$mfew2 add command -label "Hilight 0-Level Snds (force Recalc)"   -command "MarkZeroLevelFiles 1; SetSel hizerof" -foreground black
		$mfew2 add command -label "Sources of non-sound File(s)" -command "ShowSrcs; SetSel src" -foreground black
		$mfew2 add command -label "Pitch Mark of sound File"     -command "DisplayPmark $wl; SetSel pmarkdis" -foreground black
		$mfew2 add command -label "Background Listings with File" -command "ShowBlistsOfFile $wl; SetSel blshow" -foreground black
		$mfew2 add command -label "How Many Selected ?"     	-command "HowManySel; SetSel howmany" -foreground black
		$mfew2 add command -label "How Many Lines In All Files ?" -command "HowManyLines; SetSel howmanylines"

		$mfew add cascade -label "Sort" -menu $mfew.sub3 -foreground black
		set mfew3 [menu $mfew.sub3 -tearoff 0]
		$mfew3 add command -label "Move Files to Top of List"			-command "TopOfWkspace 0; SetSel top" -foreground black
		$mfew3 add cascade -label "Sort Alphabetically" -menu $mfew3.sub1 -foreground black
		set mfew3x [menu $mfew3.sub1 -tearoff 0]
		$mfew3x add command -label "Alphabetical Order" -command "SortPartListing $wl 0; SetSel aplha_part" -foreground black
		$mfew3x add command -label "Reverse Alphabetical Order" -command "SortPastListing $wl 1; SetSel ahpla_part" -foreground black
		$mfew3x add command -label "Reverse Spelling Alphabetical" -command "SortPartListing $wl 2; SetSel lleps_part" -foreground black
		$mfew3 add command -label "Sort And Move Files to Top of List"	-command "TopOfWkspace 1; SetSel topsort" -foreground black
		$mfew3 add cascade -label "Sort On Number In Name" -menu $mfew3.sub2 -foreground black
		$mfew3 add command -label "Move Sounds To Top Of List"	-command "TopOfWkspace 4; SetSel toptypsort"
		set mfew3y [menu $mfew3.sub2 -tearoff 0]
		$mfew3y add command -label "Sort On Number At End"	-command "TopOfWkspace 2; SetSel topsort2" -foreground black
		$mfew3y add command -label "Reverse Sort On Number At End"	-command "TopOfWkspace -2; SetSel topsort2r" -foreground black
		$mfew3y add command -label "Sort On Number At Start"	-command "TopOfWkspace 3; SetSel topsort3" -foreground black
		$mfew3y add command -label "Reverse Sort On Number At Start"	-command "TopOfWkspace -3; SetSel topsort3r" -foreground black
		$mfew3 add command -label "Sort Files By Duration"			-command "DurSort wl; SetSel dursort" -foreground black
		if {[info exists released(spectune)]} {
			$mfew3 add command -label "Sort Files By Pitch" -command "PitchSort; SetSel pitchsort" -foreground black
		}
		$mfew3 add command -label "Sort Files By Loudness"			-command "LoudSort wl; SetSel loudsort" -foreground black
		$mfew3 add command -label "Move Files to Foot of List"		-command "FootOfWkspace; SetSel foot" -foreground black
		$mfew3 add command -label "Reverse Order Of Files"			-command "ReverseSelListing; SetSel rev" -foreground black
		$mfew3 add command -label "Files In Same Directory to Top"	-command "MoveDirMembersToTop; SetSel movdir" -foreground black
		$mfew3 add command -label "Move Top File To After Marked Position"	-command "FromTopOfWkspace; SetSel fromtop" -foreground black
		$mfew3 add command -label "Add Selected File To A Sortlist"	-command "AddToSortlist; SetSel slistadd" -foreground black
		$mfew3 add command -label "Reorder Files As Per Sortlist"	-command "ReorderAsSortlist; SetSel slistsort" -foreground black

		$mfew add command -label "Update Data"  -command "RefreshFiles; SetSel refresh" -foreground black
		$mfew add separator
		$mfew add command -label "RENAME, MOVE OR CLEAR FILES" -command {}  -foreground black
		$mfew add separator
		$mfew add cascade -label "Rename" -menu $mfew.sub1 -foreground black
		set mfew1 [menu $mfew.sub1 -tearoff 0]
		$mfew1 add command -label "Simple Rename" 	  		   	-command "RenameWkspaceFiles; SetSel name" -foreground black
		$mfew1 add command -label "Play And Rename" 	  		-command "PlayAndRename; SetSel pname" -foreground black
		$mfew1 add command -label "Generically Rename" 	  		-command "GenericRenameWkspaceFiles; SetSel gname" -foreground black
		$mfew1 add command -label "Generically Substitute Names" -command "GenericSubstituteWkspaceFiles; SetSel gsname" -foreground black
		$mfew1 add command -label "Substitute Suffixes"			-command "ReplaceSuffixes 0; SetSel nusuf0"
		$mfew1 add command -label "Transfer Suffixes"			-command "ReplaceSuffixes 1; SetSel nusuf1"
		$mfew1 add command -label "Base Name On Chosen File"	-command "BaseChosName; SetSel basename" -foreground black
		$mfew1 add command -label "As Chosen File + Suffix" -command "BaseChosNamePlusSuffix; SetSel basenamesuf"
		$mfew1 add command -label "As Chosen File: Increment Index" -command "BaseChosNameReindexed; SetSel basnamreind"

		$mfew1 add command -label "Add Prefix" -command "Prefix 0; SetSel prefix" -foreground black
		$mfew1 add command -label "Add Suffix" -command "Prefix 1; SetSel suffix" -foreground black
		$mfew1 add command -label "Add Pitch Suffix" -command "PSuffix; SetSel puffix" -foreground black
		$mfew1 add command -label "Remove End Character(s)" -command "RemoveEndChars 0; SetSel remend" -foreground black
		$mfew1 add command -label "Remove Start Character(s)" -command "RemoveEndChars 1; SetSel remstt" -foreground black
		$mfew1 add command -label "Remove Character(s) After" -command "RemoveCharsAfter 0; SetSel remaft" -foreground black
		$mfew1 add command -label "Remove Character(s) Before" -command "RemoveCharsAfter 1; SetSel rembef" -foreground black
		$mfew1 add command -label "Replace Spaces" -command "ReplaceTheChar space; SetSel repspac" -foreground black
		$mfew1 add command -label "Replace Dots"   -command "ReplaceTheChar dot; SetSel repdots" -foreground black

		$mfew1 add command -label "Add Numbers" -command "AddWkspaceNumbers; SetSel gsnum2" -foreground black
		$mfew1 add command -label "Add Numbers From Character N" -command "AddWkspaceNumbersFrom; SetSel gsrnum2" -foreground black
		$mfew1 add command -label "Renumber" -command "GenericSubstituteWkspaceNumbers; SetSel gsnum" -foreground black
		$mfew1 add cascade -label "Renumber In Creation-date Order" -menu $mfew1.sub1 -foreground black
		set mfew1_1 [menu $mfew1.sub1 -tearoff 0]
		$mfew1_1 add command -label "Prefix" -command "Prefix 2; SetSel prefixdated" -foreground black
		$mfew1_1 add command -label "Suffix" -command "Prefix 3; SetSel suffixdated" -foreground black

		$mfew1 add command -label "Swap Two Filenames" -command "SwapFileNames; SetSel gswap" -foreground black
		$mfew1 add command -label "Swap Selected Names With Chosenfiles" -command "SwapChFileNames; SetSel gswap2" -foreground black
		$mfew1 add cascade -label "Transfer (Part Of) Name To Other" -menu $mfew1.sub2 -foreground black
		set mfew1_2 [menu $mfew1.sub2 -tearoff 0]
		$mfew1_2 add command -label "Transfer Prefix" -command "TransferName 0; SetSel tswap0" -foreground black
		$mfew1_2 add command -label "Transfer Suffix" -command "TransferName 1; SetSel tswap1" -foreground black
		$mfew1_2 add command -label "Sndfile Name -> Txtfile" -command "TransferName 2; SetSel tswap2" -foreground black
		$mfew1_2 add command -label "Txtfile Name -> Sndfile" -command "TransferName 3; SetSel tswap3" -foreground black

		$mfew1 add command -label "Overwrite Chosen File(s)" -command "OverwriteRename; SetSel orename" -foreground black
		$mfew1 add separator
		$mfew1 add command -label "Change Extension -> User Defined" -command "RenameExt 1; SetSel erename1" -foreground black
		$mfew1 add command -label "Change Extension -> Standard Text" -command "RenameExt 0; SetSel erename0" -foreground black
		$mfew1 add command -label "Change Unknown Extension -> .txt" -command "RenameExt 2; SetSel erename2"

		$mfew add command -label "Move To New Directory" -command "MoveDirectory 0; SetSel move" -foreground black
		$mfew add command -label "Move To New Directory & Remove" -command "MoveDirectory 1; SetSel moveremove" -foreground black
		$mfew add command -label "Clear Files Which Are Already Backed-up " -command {RemoveFromWkspace wk; SetSel remove} -foreground black
		$mfew add command -label "Ditto .... Except Chosen List Files " -command {RemoveFromWkspace wkx; SetSel removex}
		$mfew add command -label "Clear Files In Directory Of Selected File" -command {RemoveFromWkspace dir; SetSel remdir} -foreground black
		$mfew add command -label "Hide Non-Backed-Up Files" -command {HideFromWkspace; SetSel hide} -foreground black
		$mfew add separator
		$mfew add command -label "KEEP INFORMATION" -command {}  -foreground black
		$mfew add separator
		if {!$sl_real} {
			$mfew add command -label "List Files In Textfile" -command TellListInTextfile -foreground black
		} else {
			$mfew add cascade -label "List Files In Textfile" -menu $mfew.sub10 -foreground black
			$mfew add cascade -label "Filenames To Targetfile" -menu $mfew.sub192
			set mfew192 [menu $mfew.sub192 -tearoff 0]
			$mfew192 add command -label "Specify Targetfile" -command "TargetTextfile; SetSel target"
			$mfew192 add command -label "Copy Basic Name Only" -command "GrabToTarget 0; SetSel grbtotargt0"
			$mfew192 add command -label "...With Extension" -command "GrabToTarget 1; SetSel grbtotargt1"
			$mfew192 add command -label "...With Path & Extension" -command "GrabToTarget 2; SetSel grbtotargt2"
			$mfew192 add command -label "Search Targetfile For Name" -command "GrabToTarget 3; SetSel grbtotargt3"
			$mfew192 add separator
			$mfew192 add command -label ".... FOR DIRECTORY" -command "GrabToTarget 4; SetSel grbtotargt4"
			$mfew add cascade -label "Grab Filename To Paste Elsewhere" -menu $mfew.sub11 -foreground black
			set mfew11 [menu $mfew.sub11 -tearoff 0]
			$mfew11 add command -label "Basic Name Only" -command "GrabRename 0; SetSel grbnam0" -foreground black
			$mfew11 add separator
			$mfew11 add command -label "...With Extension" -command "GrabRename 1; SetSel grbnam1" -foreground black
			$mfew11 add separator
			$mfew11 add command -label "...With Path & Extension" -command "GrabRename 2; SetSel grbnam2" -foreground black
			set mfew10 [menu $mfew.sub10 -tearoff 0]
			$mfew10 add command -label "LIST FILES IN NEW TEXTFILE" -command {}  -foreground black
			$mfew10 add separator ;# -background $evv(HELP)
			$mfew10 add command -label "Sounds Selected" -command "WkToFile snd 1; SetSel listsnd" -foreground black
			$mfew10 add command -label "Snds(etc) as Comments In Text" -command "WkToFile addtotxt 0; SetSel listsndintxt" -foreground black
			$mfew10 add command -label "Sounds, With Their Durations" 	-command "WkToFile sndur 1; SetSel listdur" -foreground black
			$mfew10 add command -label "Sound-System Files Selected" -command "WkToFile sys 1; SetSel listsys" -foreground black
			$mfew10 add command -label "Mixfiles Selected" -command "WkToFile mix 1; SetSel listmix" -foreground black
			$mfew10 add command -label "Multichan Mixfiles Selected" -command "WkToFile multimix 1; SetSel listmmix" -foreground black
			$mfew10 add command -label "Textfiles Selected" -command "WkToFile txt 1; SetSel listtex" -foreground black
			$mfew10 add command -label "All Files Selected" -command "WkToFile all 1; SetSel listall" -foreground black
			$mfew10 add separator ;# -background $evv(HELP)
			$mfew10 add command -label "ADD FILES TO EXISTING TEXTFILE" -command {}  -foreground black
			$mfew10 add separator ;# -background $evv(HELP)
			$mfew10 add command -label "Add Sounds Selected" -command "WkToFile add 1; SetSel listadd" -foreground black
			$mfew10 add command -label "Add Sounds Selected & Remove From Wkspace" -command "WkToFile adddel 1; SetSel listadddel" -foreground black
			$mfew10 add command -label "Add Textfile Selected" -command "WkToFile addtxt 1; SetSel addtxt" -foreground black
		}
		$mfew add separator
		$mfew add command -label "TO CHOSEN " -command {}  -foreground black
		$mfew add separator
		$mfew add command -label "Put Selected File On Chosen List"	-command "ChoseSel 0; SetSel selch0" -foreground black
		$mfew add command -label "Add Selected File To Chosen List"	-command "ChoseSel 1; SetSel selch1" -foreground black
		$mfew add command -label "Add Selected To Chosen, With Duplicates"	-command "ChoseSel 2; SetSel selch2" -foreground black
		$mfew add separator
		$mfew add command -label "FIND FILE OR DIRECTORY" -command {}  -foreground black
		$mfew add separator
		$mfew add cascade -label "Find File"  -menu $mfew.sub13 -foreground black
		set mfew13 [menu $mfew.sub13 -tearoff 0]
		$mfew13 add command -label "In Logs" -command "SearchLogsForFile $wl;  SetSel find" -foreground black
		$mfew13 add command -label "In Mixfiles" -command "FindWkspaceFileInMixes;  SetSel findm" -foreground black
		$mfew13 add command -label "In B-Lists" -command "FileFind_inBLists 0; SetSel findbl" -foreground black

		$mfew add command -label "List Directory Of File" -command "SetSel listdir; ListDirOfFile" -foreground black
		$mfew add command -label "Load Similar Named Files From Dir" -command "SetSel listsim; LoadSimil" -foreground black
		$mfew add separator
		$mfew add command -label "" -command {} -foreground black
		$mfew add separator
		$mfew add command -label "DESTROY FILES (!!)" -command {}  -foreground black
		$mfew add separator
		$mfew add command -label "Destroy Any Selected Files (!!)" -command "DeleteFromSystem 0" -foreground black
		$mfew add separator
		$mfew add cascade -label "Destroy Some Of Selected Files (!!)" -menu $mfew.sub12 -foreground black
		set mfew12 [menu $mfew.sub12 -tearoff 0]
		$mfew12 add command -label "Too Short Sounds (!!)" -command "DeleteFromSystem 1" -foreground black
		$mfew12 add separator
		$mfew12 add command -label "Too Quiet Sounds (!!)" -command "DeleteFromSystem 2" -foreground black
		if {$macsmall} {
			menubutton $fl.new.cre -text "Files of Type" -width 13 -menu $fl.new.cre.menu -relief raised
		} else {
            menubutton $fl.new.cre -text "Selected Files of Type"  -menu $fl.new.cre.menu -relief raised
		}
		set mcre [menu $fl.new.cre.menu -tearoff 0]
		$mcre add command -label "DO IT AGAIN" -command {}  -foreground black
		$mcre add separator
		$mcre add command -label "" -command {} -foreground black
		$mcre add separator
		$mcre add command -label "SOUNDFILES  (Dbl-Click: Play)" -command {}  -foreground black
		$mcre add separator
		$mcre add command -label "View Sound Or Textfile" -command "ViewOutput; SetSel2 view"
		$mcre add command -label "Play Selected File(s)" -command "PlayOutput 1; SetSel2 play" -foreground black
		$mcre add command -label "Play All Snds Selected" -command "PlayAllChosen 1; SetSel2 playfrlista"
		$mcre add command -label "Play All Snds Individually" -command "PlayAllChosen 4; SetSel2 playfrlistd"
		$mcre add command -label "Play All Snds Selected At Timestep" -command "PlayAllChosen 2; SetSel2 playfrlistb"
		$mcre add command -label "Play One Channel Of Sound" -command "PlayChan; SetSel2 playchan" -foreground black
		$mcre add command -label "View Soundfile In Edit Window" -command "ViewOutput; SetSel2 view" -foreground black
		$mcre add command -label "Play Merged Channels" -command "PlayMerge; SetSel2 playmerge"
		$mcre add separator
		$mcre add cascade -label "Add, Replace or Find Sndfile(s) In Mixfile"	-menu $mcre.sub5 -foreground black
		$mcre add separator
		if [file exists [file join $evv(CDPROGRAM_DIR) wavesurfer$evv(EXEC)]] {
			$mcre add command -label "Permanent Play-Display Of File" -command "PlaySndfileNew 0; SetSel2 playnu" -foreground black
			$mcre add command -label "Permanent Play-Display With Spectrum"	-command "PlaySndfileNew 1; SetSel2 surf" -foreground black
		}
		$mcre add separator
		$mcre add command -label "Is Soundfile In Any Known Mixfile?" -command "SndInMix; SetSel2 sndinmix" -foreground black
		$mcre add command -label "Is Sound In Any Sndlist On Wkspace ?" -command "FindSndInSndlist ; SetSel2 fsinslist" -foreground black
		set mcre5 [menu $mcre.sub5 -tearoff 0]
		$mcre5 add command -label "MIXFILES" -command {}  -foreground black
		$mcre5 add separator
		$mcre5 add command -label "Overlay Sndfile(s) In Mixfile At Zero"	-command "SndToMix 0; SetSel2 sndtomx0" -foreground black
		$mcre5 add command -label "Insert Sndfile(s) At Mixfile Start" -command "SndToMix 1; SetSel2 sndtomx1" -foreground black
		$mcre5 add command -label "Add Sndfile(s) (In Sequence) At Mixfile End"	-command "SndToMix 2; SetSel2 sndtomx2" -foreground black
		$mcre5 add command -label "Add Sndfile(s) (Overlayed) At Mixfile End"	-command "SndToMix 3; SetSel2 sndtomx3" -foreground black
		$mcre5 add command -label "Add Sndfile(s) To Mixfile At Specified Time"	-command "SndToMix 7; SetSel2 sndtomx7" -foreground black
		$mcre5 add command -label "Replace One Sndfile With Other In Mixfile" -command "SndToMix 4; SetSel2 sndtomx4" -foreground black
		$mcre5 add command -label "Replace All Sndfiles In Mixfile" -command "SndToMix 8; SetSel2 sndtomx8" -foreground black
		$mcre5 add command -label "Substitute All (Possibly Duplicated) Snds In Mix" -command "SndToMix 10; SetSel2 sndtomx10" -foreground black
		$mcre5 add separator
		$mcre5 add command -label "Is Soundfile In Any Known Mixfile?" -command "SndInMix; SetSel2 sndinmix" -foreground black
		$mcre add command -label "Is Selected Sound In Selected Mix?" -command "ThisSndInMix; SetSel2 thissndinmix"
		$mcre5 add command -label "Number Of Active Lines In Mixfile" -command "MixActiveCnt; SetSel2 mixactive" -foreground black
		$mcre add separator
		$mcre add command -label "ANY KIND OF TEXTFILE   (Dbl-Click: View)" -command {}  -foreground black
		$mcre add separator
		$mcre add command -label "Read/Edit Selected File" 	-command "Read_Textfile; SetSel2 read" -foreground black
		$mcre add command -label "Compare Selected Files" 	-command "CompareTextfiles; SetSel2 compare" -foreground black
		$mcre add command -label "Make Duplicate Textfiles" -command "DuplicateTextfile; SetSel2 duplitxt" -foreground black
		$mcre add command -label "Duplicate Several Textfiles" -command "DuplicateSeveralTextfiles; SetSel2 duplitxt2" -foreground black
		$mcre add command -label "Merge Textfiles" -command "MergeTextfiles; SetSel2 mergetext"
		$mcre add separator
		$mcre add command -label "Is Textfile A \"Bad\" Mixfile ?" -command "CheckTextfileSyntaxForAMix; SetSel2 synmix"
		$mcre add separator
		$mcre add cascade -label "Post Display Of File(s) On Desktop" -menu $mcre.sub1 -foreground black
		set mcre1 [menu $mcre.sub1 -tearoff 0]
		$mcre1 add command -label "Post Display On Desktop" -command "PostTextfile 0; SetSel2 posttxt" -foreground black
		$mcre1 add command -label "Refresh Display On Desktop" -command "PostRefresh; SetSel2 postref" -foreground black
		$mcre1 add command -label "Remove Display From Desktop" -command "PostTextfile 1; SetSel2 unposttxt" -foreground black
		$mcre1 add command -label "Get Posted File(s) To Chosen List" -command "PostGet; SetSel2 postget" -foreground black

		$mcre add separator
		$mcre add command -label "LISTS OF SOUNDFILES" -command {}  -foreground black
		$mcre add separator
		$mcre add cascade -label "Lists Of Soundfiles" -menu $mcre.sub2 -foreground black
		set mcre2 [menu $mcre.sub2 -tearoff 0]
		$mcre2 add command -label "SOUNDS TO & FROM WORKSPACE" 	-command {}  -foreground black
		$mcre2 add separator
		$mcre2 add command -label "Grab Sounds To Workspace" 	-command "GrabFiles 1 0; SetSel2 grab" -foreground black
		$mcre2 add command -label "Hilight Sounds On Workspace" 	-command "GrabHilite 1; SetSel2 grabh" -foreground black
		$mcre2 add command -label "Sounds To Top Of Workspace" 	-command "GrabHilite 2; SetSel2 grabh2" -foreground black
		$mcre2 add command -label "Remove Sounds From Workspace" -command "RemoveFromWkspace sndlist; SetSel2 sndlsnd" -foreground black
		$mcre2 add separator
		$mcre2 add command -label "SOUNDS TO & FROM CHOSEN LIST" 	-command {}  -foreground black
		$mcre2 add separator
		$mcre2 add command -label "Put Sounds On Chosen List" 	-command "GrabChoose 0 ; SetSel2 grabch0" -foreground black
		$mcre2 add command -label "Add Sounds To Chosen List" 	-command "GrabChoose 1 ; SetSel2 grabch1" -foreground black
		$mcre2 add command -label "Add Sounds Including Duplicates" -command "GrabChoose 2 ; SetSel2 grabch2" -foreground black
		$mcre2 add separator
		$mcre2 add command -label "CHANGE SOUNDS IN LISTING" 	-command {}  -foreground black
		$mcre2 add separator
		$mcre2 add command -label "Add Further Sounds To A Text Listing" -command "AddToFile; SetSel2 addlist" -foreground black
		$mcre2 add command -label "Remove Selected Sounds" -command "RemoveFrmSndlist 0; SetSel2 remlist0" -foreground black
		$mcre2 add command -label "Retain Only Selected Sounds" -command "RemoveFrmSndlist 1; SetSel2 remlist1" -foreground black
		$mcre2 add command -label "Remove Duplicates In Listing Of Snds" -command "RemoveDuplsInFile; SetSel2 dedupllist" -foreground black
		$mcre2 add command -label "Change Directory Of Files Listed" -command "ChangeDirInFile; SetSel2 chdirlist" -foreground black
		$mcre2 add separator
		$mcre2 add command -label "PLAY ALL" 	-command {}  -foreground black
		$mcre2 add separator
		$mcre2 add command -label "Play All Files Listed In Sndlist" -command "PlayAllChosen 1; SetSel2 playfrlist" -foreground black
		$mcre2 add separator
		$mcre2 add command -label "USE SOUNDS IN LISTED ORDER" 	-command {}  -foreground black
		$mcre2 add separator
		$mcre2 add command -label "Next Soundlisting Sound To Chosen List" 	-command "GrabChoose 3 ; SetSel2 grabch3" -foreground black
		$mcre2 add command -label "Next Soundlisting Snd To Chosen & Play" 	-command "GrabChoose 4 ; SetSel2 grabch4" -foreground black
		$mcre2 add command -label "Soundlisting Start Again" 	-command "GrabChoose 5 ; SetSel2 grabch5" -foreground black
		$mcre2 add command -label "Soundlisting Restart From Selected File" -command "GrabChoose 6 ; SetSel2 grabch6" -foreground black
		$mcre2 add separator
		$mcre2 add command -label "SOUNDS IN SNDLISTS" 	-command {}  -foreground black
		$mcre2 add separator
		$mcre2 add command -label "Is Sound In Any Sndlist On Wkspace ?" 	-command "FindSndInSndlist ; SetSel2 fsinslist" -foreground black
		$mcre add cascade -label "Lists Of Any Files" -menu $mcre.sub3 -foreground black
		set mcre3 [menu $mcre.sub3 -tearoff 0]
		$mcre3 add command -label "Grab Files To Workspace" 	-command "GrabFiles 0 0; SetSel2 grabf" -foreground black
		$mcre3 add command -label "Grab Specific Files To Workspace" -command "GrabFiles 0 1; SetSel2 grabfsp" -foreground black
		$mcre3 add command -label "Hilight Files On Workspace" 	-command "GrabHilite 0; SetSel2 grabfh" -foreground black
		$mcre3 add command -label "Find Dirs For Listed Filenames Starting With" -command "GrabFromDir; SetSel2 grabfd" -foreground black
		$mcre add cascade -label "Mixfiles" -menu $mcre.sub4 -foreground black
		set mcre4 [menu $mcre.sub4 -tearoff 0]
		$mcre4 add command -label "Establish As Main Mixfile" -command "Set_MainMix; SetSel2 mixmain" -foreground black
		$mcre4 add separator
		$mcre4 add command -label "Get Sounds In Mix To Wkspace" -command "Get_MixSrcs; SetSel2 mixsrc" -foreground black
		$mcre4 add command -label "Hilight Sounds In Mix Which Are On Wkspace" -command "Hilite_MixSrcs; SetSel2 mixhil" -foreground black
		$mcre4 add command -label "Do Any Sounds In Mix No Longer Exist?" -command "Assess_MixSrcs; SetSel2 mixass" -foreground black
		$mcre4 add command -label "Show End Times Of Files In Mix" -command "Mix_Endtimes; SetSel2 mixend" -foreground black
		$mcre4 add separator
		$mcre4 add command -label "Overlay Sndfile(s) In Mixfile At Zero"	-command "SndToMix 0; SetSel2 sndtomx0" -foreground black
		$mcre4 add command -label "Insert Sndfile(s) At Mixfile Start" -command "SndToMix 1; SetSel2 sndtomx1" -foreground black
		$mcre4 add command -label "Add Sndfile(s) (In Sequence) At Mixfile End"	-command "SndToMix 2; SetSel2 sndtomx2" -foreground black
		$mcre4 add command -label "Add Sndfile(s) (Overlayed) At Mixfile End"	-command "SndToMix 3; SetSel2 sndtomx3" -foreground black
		$mcre4 add command -label "Add Sndfile(s) To Mixfile At Specified Time"	-command "SndToMix 7; SetSel2 sndtomx7" -foreground black
		$mcre4 add command -label "Replace One Sndfile With Other In Mixfile" -command "SndToMix 4; SetSel2 sndtomx4" -foreground black
		$mcre4 add command -label "Replace All Sndfiles In Mixfile" -command "SndToMix 8; SetSel2 sndtomx8" -foreground black
		$mcre4 add command -label "Substitute All (Possibly Duplicated) Snds In Mix" -command "SndToMix 10; SetSel2 sndtomx10" -foreground black
		$mcre4 add separator
		$mcre4 add command -label "Is Soundfile In Any Known Mixfile?" -command "SndInMix; SetSel2 sndinmix" -foreground black
		$mcre4 add command -label "Is Selected Sound In Selected Mix?" -command "ThisSndInMix; SetSel2 thissndinmix"
		$mcre4 add command -label "Mixfile Sounds Moved Or Deleted ?" -command "SndsInTextfileExist; SetSel2 fsinslistexist1"
		$mcre4 add command -label "Number Of Active Lines In Mixfile" -command "MixActiveCnt; SetSel2 mixactive" -foreground black
		$mcre4 add command -label "Number Of Mixlines Using N Channels" -command "MixChanCnt; SetSel2 mixchancnt"
		$mcre4 add separator
		$mcre4 add command -label "Merge Two Mixfiles" -command "MixAdd; SetSel2 mixadd" -foreground black
		$mcre4 add separator
		$mcre4 add command -label "Is Textfile A \"Bad\" Mixfile ?" -command "CheckTextfileSyntaxForAMix; SetSel2 synmix"
		$mcre4 add separator
		$mcre4 add command -label "Are All Files In Mixfile Backed-up ?" -command "MixBakupTest; SetSel2 mixbak"
		$mcre add command  -label "FILTER FILES" -command {} -background $evv(HELP)
		$mcre add command -label "Display Midi Filter-Data Resonance" -command "DisplayResonanceWk 0 0; SetSel2 vfm" -foreground black
		$mcre add command -label "Display Freq Filter-Data Resonance" -command "DisplayResonanceWk 1 0; SetSel2 vff" -foreground black
		$mcre add command -label "Compare Midi Filter-Data Resonance" -command "DisplayResonanceWk 0 1; SetSel2 vfm2" -foreground black
		$mcre add command -label "Compare Freq Filter-Data Resonance" -command "DisplayResonanceWk 1 1; SetSel2 vff2" -foreground black
		$mcre add command  -label "BRKPNT FILES" -command {} -background $evv(HELP)
		$mcre add command -label  "Brkpnt Files Display" -command "GrafDisplayBrkfile 1 0; SetSel2 dispbrk" -foreground black
		$mcre add command -label  "Brkpnt Files Edit" 	 -command "Read_Brkfile; SetSel2 readbrk" -foreground black

		pack $fl.new.all $fl.new.few $fl.new.cre -side left -fill x -expand true -padx 1
													;#	Create lower line of buttons
		button $fl.new2.cs -text "Search" -command "SearchWorkspaceForFile 0" -width 7 -highlightbackground [option get . background {}]
		button $fl.new2.cs2 -text "& Again"  -command "SearchWorkspaceForFile 1" -width 7 -highlightbackground [option get . background {}]

#		button $fl.new2.pla -text "Play Sounds" -command {PlayOutput 0} -width 14 -highlightbackground [option get . background {}]
        button $fl.new2.pla -text "Play Sounds" -command {PlayOutput 0} -foreground black  -highlightbackground [option get . background {}]
		if {!$sl_real} {
			button $fl.new2.ca  -text "A" -bd 4 -command	TellA -width 2 ;# -bg $evv(HELP) -highlightbackground [option get . background {}]
		} else {
#RWD width was 2
			menubutton $fl.new2.ca -text "A" -menu $fl.new2.ca.menu -relief raised -bd 4  -background $evv(HELP)
			set pchmenu [menu $fl.new2.ca.menu -tearoff 0]
#RWD: menu item backgrounds not supported in OS X Cocoa
			$pchmenu add command -label "C"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilec$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "C#" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfiledb$evv(SNDFILE_EXT)] 0" -background white -foreground blue
			$pchmenu add separator
			$pchmenu add command -label "D"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfiled$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "Eb" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileeb$evv(SNDFILE_EXT)] 0" -background white -foreground blue
			$pchmenu add separator
			$pchmenu add command -label "E"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilee$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "F"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilef$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "F#" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilegb$evv(SNDFILE_EXT)] 0" -background white -foreground blue
			$pchmenu add separator
			$pchmenu add command -label "G"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileg$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "Ab" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileab$evv(SNDFILE_EXT)] 0" -background white -foreground blue
			$pchmenu add separator
			$pchmenu add command -label "A"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilea$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "Bb" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilebb$evv(SNDFILE_EXT)] 0" -background white -foreground blue
			$pchmenu add separator
			$pchmenu add command -label "B"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileb$evv(SNDFILE_EXT)]  0" -background white -foreground black
			$pchmenu add separator
			$pchmenu add command -label "C"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilec2$evv(SNDFILE_EXT)] 0" -background white -foreground black
			bind $fl.new2.ca <Shift-ButtonPress-1> {}
			bind $fl.new2.ca <Shift-ButtonRelease-1> {PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfile$evv(SNDFILE_EXT)] 0}
		}
		if {$macsmall} {
			menubutton $fl.new2.b -text "Backup" -width 10  -menu $fl.new2.b.menu -relief raised
		} else {
#RWD		menubutton $fl.new2.b -text "Backup Selected New Files" -width 29 -menu $fl.new2.b.menu -relief raised
            menubutton $fl.new2.b -text "Backup Selected Files"  -menu $fl.new2.b.menu -relief raised
		}
		set mcrb [menu $fl.new2.b.menu -tearoff 0]
		$mcrb add command -label "Store Files" -command "BakupWkspace 0" -foreground black
		$mcrb add separator
		$mcrb add command -label "Store And Clear Files" -command "BakupWkspace 1" -foreground black

		pack $fl.new2.pla $fl.new2.b $fl.new2.cs $fl.new2.cs2 $fl.new2.ca -side left -padx 1 ;# -fill x

		pack $fl.over -side top
		pack $fl.title -side top -pady 2
		pack $fl.cnts $fl.new -side top -fill x
		pack $fl.new2 -side top -anchor center
		pack $fl.l -side top -fill x
		pack $fl.sub -side top -pady 4 -fill x -expand true
		frame $fend.bl -width 1 -bg [option get . foreground {}]
		set fr	[frame $fend.r -borderwidth $evv(SBDR)]	;#	Establish frame for smaller listbox
		frame $fend.bl2 -width 1 -bg [option get . foreground {}]

		frame $fr.over  -borderwidth $evv(SBDR)

		button $fr.over.sel -text "Enter Chosen Files Mode" -command ToSelectionMode -width 20 -bg $evv(EMPH) -highlightbackground [option get . background {}]
		pack $fr.over.sel -side top

		label $fr.l -text "CHOSEN FILES" -font bigfnt ;#	Create its title and the listbox itself

	 	set frrr [frame $fr.rr -borderwidth $evv(SBDR)]
		set frx1 [frame $fr.x1 -borderwidth $evv(SBDR)]
		set frx2 [frame $fr.x2 -borderwidth $evv(SBDR)]

		entry $frrr.cnts -width 3 -textvariable chcnt -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		checkbutton $frrr.remem -variable ch_remem -text "Store" -command {RememberList ch 1}
		checkbutton $frrr.resto -variable ch_resto -text "Recall" -command {RecallList ch}
		checkbutton $frrr.tfile -variable ch_tfile -text "To file" -command "StorChFiles"

		pack $frrr.cnts $frrr.remem -side left -padx 1
		pack $frrr.tfile $frrr.resto -side right -padx 1


		button $frx1.cc -text "Clear" -command ClearAndSaveChoice -width 5 -state disabled -highlightbackground [option get . background {}]
#RWD
		if { $::tcl_platform(os) == "Darwin" } {
			menubutton $frx1.ro -text "Reorder" -width 12 -menu $frx1.ro.menu -relief raised -state disabled
		} else {
			menubutton $frx1.ro -text "REORDER" -width 9 -menu $frx1.ro.menu -relief raised -state disabled
		}
		set rom [menu $frx1.ro.menu -tearoff 0]
		$rom add command -label "CHANGE ORDER" -command {}  -foreground black
		$rom add command -label "Reverse" -command "FlipList process" -foreground black
		$rom add command -label "Rotate"  -command "RotateList -1" -foreground black
		$rom add command -label "Etator"  -command "RotateList 1" -foreground black
		$rom add command -label "Interleave"  -command "InterleaveList 2"
		$rom add command -label "Interleave By N"  -command "InterleaveList 0"
		$rom add command -label "Interleave By Pattern"  -command "InterleavePat"
		$rom add command -label "Interleave By Name"  -command "InterleaveName"
		$rom add command -label "Randomise"  -command "RandomiseList" -foreground black
		$rom add command -label "Sort"  -command "ChoiceSort" -foreground black
		$rom add command -label "Sort By Duration"  -command "DurSort ch" -foreground black
		$rom add command -label "Sort By Loudness"  -command "LoudSort ch" -foreground black
		$rom add command -label "Remove Duplicates"  -command "ChoiceDelDupls" -foreground black
		$rom add command -label "RETAIN SPECIFIED FILES ONLY" -command {}  -foreground black
		$rom add command -label "Chosen File N" -command "Sound_Keep 2" -foreground black
		$rom add command -label "The First N Chosen Files" -command "Sound_Keep 0" -foreground black
		$rom add command -label "The Last N Chosen Files" -command "Sound_Keep 1" -foreground black
		$rom add command -label "N Files At Random" -command "Sound_Keep 3" -foreground black
		$rom add command -label "Next File Selected On Chosen List" -command "set chkeep 1" -foreground black
		$rom add command -label "Particular Selected File(s)" -command "KeepSpecFile 0" -foreground black
		$rom add command -label "Files Starting With..."  -command "KeepSpecFile 4" -foreground black
		$rom add command -label "All Chosen Files Not Yet Backed Up" -command "Sound_Select -1" -foreground black
		$rom add command -label "Remember As Important File" -command "Key_Keep 0" -foreground black
		$rom add command -label "Restore Important File" -command "Key_Keep 1" -foreground black
		$rom add command -label "REMOVE SPECIFIED FILES" -command {}  -foreground black
		$rom add command -label "Files Starting With..."  -command "KeepSpecFile 3" -foreground black
 		$rom add command -label "Selected File & Below"  -command "KeepSpecFile 1" -foreground black
 		$rom add command -label "Selected File & Above"  -command "KeepSpecFile 2" -foreground black
		$rom add command -label "CHANGE AT EVERY Nth FILE" -command {}  -foreground black
 		$rom add command -label "Duplicate All Files"  -command {DuplicateChlist} -foreground black
 		$rom add command -label "Duplicate All Files (N times)"  -command {DuplicateChlistN 0}
  		$rom add command -label "...With Rand Order Perm"  -command {DuplicateChlistN 1} -foreground black
 		$rom add command -label "...Except First And Last"  -command {DuplicateChlistN 2} -foreground black
		$rom add command -label "Remove Every Nth Files"  -command {MassageFilenames delfiles 1 $ch} -foreground black
#RWD
		if { $::tcl_platform(os) == "Darwin" } {
			menubutton $frx1.ch -text "Get/\Mod" -width 12 -menu $frx1.ch.menu -relief raised -state disabled
		} else {
			menubutton $frx1.ch -text "GET/MOD" -width 8 -menu $frx1.ch.menu -relief raised -state disabled
		}
		set ror [menu $frx1.ch.menu -tearoff 0]
		$ror add command -label "GET PARTICULAR FILES" -command {}  -foreground black
		$ror add command -label "Last File Created Or Grabbed" -command "WkspFirstGet" -foreground black
		$ror add command -label "Files With Generic Name" -command "Generic_Select wl 0" -foreground black
		$ror add command -label "All Soundfiles" -command "Sound_Select 0" -foreground black
		$ror add command -label "All Mono Soundfiles" -command "Sound_Select 1" -foreground black
		$ror add command -label "All Stereo Soundfiles" -command "Sound_Select 2" -foreground black
		$ror add command -label  "FILES RELATED TO SOUNDFILES (NAME-TAGGED)" -command {}  -foreground black
		$ror add command -label  "Sequencer Files" -command {FilesRelated seq; SetTestbed relseq} -foreground black
		$ror add command -label  "Filter Files" -command {FilesRelated flt; SetTestbed relflt} -foreground black
		$ror add command -label  "Pitch Files" -command {FilesRelated pch; SetTestbed relpch} -foreground black
		$ror add command -label "MIX FILES" -command {}  -foreground black
		$ror add command -label "Get Last Mixfile Used" -command "GetLastMixfile 0" -foreground black
		$ror add command -label "Get Main Mixfile Used" -command "GetMainMixfile" -foreground black
		$ror add command -label "Add Last Mixfile Used" -command "GetLastMixfile 1" -foreground black
		$ror add command -label "Get Soundfiles From Mixfile" -command "GetFilesFromInsideChosenMixfile 0" -foreground black
		$ror add command -label "Get Specific Sndfile From Mixfile" -command "GetFilesFromInsideChosenMixfile 2" -foreground black
		$ror add command -label "Non Backed-up Sounds From Mix" -command "GetFilesFromInsideChosenMixfile 1" -foreground black
		$ror add command -label "Get Muted Sndfiles From Mixfile" -command "GetFilesFromInsideChosenMixfile 3" -foreground black
		$ror add command -label "Merge Mixfiles" -command MixMerge -foreground black
		$ror add command -label "MIX FILES AND SOUNDFILES" -command {}  -foreground black
		$ror add command -label "Add Sndfiles To Mixfile" -command {SndToMix 6} -foreground black
		$ror add command -label "Replace One Sndfile With Other In Mixfile" -command {SndToMix 5} -foreground black
		$ror add command -label "INSERT/CHANGE AT SPECIFIED POSITION" -command {}  -foreground black
		$ror add command -label "Insert File At Top" -command {Set_Chpos 0} -foreground black
		$ror add command -label "Insert File At Specified Position In List" -command {set chpos [GetChosenPos]} -foreground black
		$ror add command -label "Insert At (Or Change) Every Nth File"  -command {MassageFilenames subfiles 1 $ch} -foreground black
		$ror add command -label  "MODIFY SOUNDFILES" -command {}  -foreground black
		$ror add command -label  "Extend Duration Of All Files" -command {FilesExtend; SetTestbed fextend} -foreground black
		$ror add command -label  "Cut To Duration Of First File" -command {FilesCurtail; SetTestbed fcurtail} -foreground black
		$ror add command -label  "Convert Any Mono Files To Stereo" -command {FilesMono; SetTestbed fmono} -foreground black
		pack $frx1.cc $frx1.ro $frx1.ch -side left -anchor w -padx 1
#RWD
		if { $::tcl_platform(os) == "Darwin" } {
			menubutton $frx2.cp -text "Previous" -width 13 -menu $frx2.cp.menu -relief raised -state disabled
		} else {
			menubutton $frx2.cp -text "PREVIOUS\nCHOICES" -width 11 -menu $frx2.cp.menu -relief raised -state disabled
		}
		set rod2 [menu $frx2.cp.menu -tearoff 0]
		$rod2 add command -label "FILES CHOSEN" -command {} -foreground black
		$rod2 add separator
		$rod2 add command -label "Files Chosen Before Last Deletion" -command GetLastChosenList -foreground black
		$rod2 add command -label "Penultimate Files Chosen" -command GetPreviousChosenList -foreground black
		$rod2 add command -label "Restore Chosen List" -command RestoreChosenList -foreground black
		$rod2 add separator
		$rod2 add command -label "FILES USED" -command {}  -foreground black
		$rod2 add separator
		$rod2 add command -label "Last Files Used" -command "GetPreviousFilesUsed 0" -foreground black
		$rod2 add command -label "Penultimate Files Used" -command "GetPreviousFilesUsed 1" -foreground black
#RWD
		if { $::tcl_platform(os) == "Darwin" } {
			button $frx2.la -text "Last" -command GetLastOutfile -width 6 -state disabled -highlightbackground [option get . background {}]
		} else {
			button $frx2.la -text "LAST\nOUTFILE(S)" -command GetLastOutfile -width 10 -state disabled 
		}
#RWD
        if { $::tcl_platform(os) == "Darwin" } {
			menubutton $frx2.da -text "Play/Props" -width 13 -menu $frx2.da.menu -relief raised -state disabled
		} else {
			menubutton $frx2.da -text "PLAY:READ\nPROPS" -width 8 -menu $frx2.da.menu -relief raised -state disabled
		}
		set rod [menu $frx2.da.menu -tearoff 0]
		$rod add command -label "PLAY OR READ" -command {}  -foreground black
		$rod add separator
		$rod add command -label "Play Soundfiles" -command "set from_chosen 1; PlayOutput 0" -foreground black
		$rod add command -label "Play All Chosen Sounds" -command "PlayAllChosen 0" -foreground black
		if {!$sl_real} {
			$rod add command -label "Read Textfiles" -command "TellReadFile" -foreground black
		} else {
			$rod add command -label "Read Textfiles" -command "set from_chosen 1; ReadFile" -foreground black
		}
		$rod add separator
		$rod add  command -label "Write All Files To Textfile" -command "WriteChosenFiles" -foreground black
		$rod add separator
		$rod add command -label "PROPERTIES" -command {}  -foreground black
		$rod add separator
		$rod add command -label "Properties" -command "Show_Props ch 0" -foreground black
		$rod add command -label "Durations" -command "Show_Props ch dur" -foreground black
		$rod add command -label "Channel Counts" -command "Show_Props ch chans" -foreground black
		$rod add command -label "Window Sizes" -command "Show_Props ch winlen" -foreground black
		$rod add command -label "Max Samples" -command "GetMaxsamps 1 0" -foreground black
		$rod add command -label "Recalc Max Samples" -command "GetMaxsamps 1 1" -foreground black
		$rod add separator
		$rod add command -label "GLOBAL PROPERTIES" -command {}  -foreground black
		$rod add separator
		$rod add command -label "Total Dur All Files" -command "ChTotDur" -foreground black
		$rod add command -label "Maximum Level Amongst Files" -command "MaxLevelOnChlist" -foreground black
		$rod add separator
		$rod add command -label "REFRESH" -command {}  -foreground black
		$rod add separator
		$rod add command -label "Refresh File Data" -command "set renam 1" -foreground black

		pack $frx2.cp $frx2.la $frx2.da -side left -anchor w -padx 1
	
		pack $fr.over -side top
		pack $fr.l -side top -pady 2
		pack $fr.rr $fr.x1 $fr.x2 -side top

		set ch [Scrolled_Listbox $fr.c -width 24 -height $evv(WKSPACE_HEIGHT)]

		pack $fr.c -side top -expand true -fill both  -padx 1 ;#	Place title and listbox, filling the frame
		frame $fr.next 
		radiobutton $fr.next.1 -text "Get Top File" -variable ddumm -command "GetNextToChosen 0" -value 0
		radiobutton $fr.next.2 -text "Add Top File" -variable ddumm -command "GetNextToChosen 1" -value 1
		pack $fr.next.1 $fr.next.2 -side left
		pack $fr.next -side top
		radiobutton $fr.next2 -text "Add Top File to Top of Chosen" -variable ddumm -command "GetNextToChosen 2" -value 2
		pack $fr.next2 -side top
		frame $fr.next3
		radiobutton $fr.next3.lf -text "Last Out" -variable ddumm -command "GetLastOutfile" -value 3
		radiobutton $fr.next3.un -text "Undo Choice" -variable ddumm -command "GetLastChosenList" -value 4
		pack $fr.next3.lf $fr.next3.un -side left
		pack $fr.next3 -side top
		frame $fr.next4
		radiobutton $fr.next4.oa -text "One at a time" -variable ddumm -command "SetupOneAtATime" -value 5
		radiobutton $fr.next4.nn -text "Next" -variable ddumm -command "DoOneAtATime" -value 6
		pack $fr.next4.oa $fr.next4.nn -side left
		pack $fr.next4 -side top

		button $help.ksh -text "K" -command "Shortcuts workspace" -width 2  -highlightbackground [option get . background {}];# -bg $evv(HELP) 
		button $help.hlp -text "Help" -command "ActivateHelp $ww.h" -width 4  -highlightbackground [option get . background {}];# -bg $evv(HELP)
#RWD width reduced from 13 - now showing just "Active" or "Passive"
		label  $help.conn -text "" -width 8 ;# was 13
		button $help.con -text "" -borderwidth 0 -state disabled -width 8 -highlightbackground [option get . background {}]
#RWD width was 84
		label $help.help -width 72 -text "$evv(HELP_DEFAULT)" -fg [option get . foreground {}]
		button $help.q -text "End Session" -command "DoWkspaceQuit 1 0"  -highlightbackground [option get . background {}];# -bg $evv(QUIT_COLOR)
		bind $ww <Control-Command-Escape> "DoWkspaceQuit 1 0"
# MOVED TO LEFT
		pack $help.q -side left -padx 1
		pack $help.about -side left -padx 1
		pack $help.ksh $help.hlp $ww.h.conn $help.con $help.help -side left
# MOVED TO LEFT
#		pack $help.q -side right -padx 1
		pack $help.syscon -side left -ipady 1 -padx 1

		pack $fend.r -side left -expand true -fill both	
		pack $fend.bl -side left -expand true -fill y
		pack $fend.l -side left -expand true -fill both	
		pack $fend.bl2 -side left -expand true -fill y


		pack $f $fz -side top -fill x					
		pack $fdum -side top -fill x -expand true
		pack $fend -side top -fill x					

		pack $w1.a $w1.b -side left
		pack $help $w1 -side top -anchor w -expand true
		bind $ww <Command-=> {ModificationDate ww}
		bind $wl <ButtonRelease-1> {}
		bind $wl <Double-1> {PossiblyPlaySnd %W %y}
		bind $ww <Return> {set bulk(run) 0 ; GotoGetAProcess}
		bind $ww <Control-Key-a> {GetNextToChosen 1}
		bind $ww <Control-Key-A> {GetNextToChosen 1}
		bind $ww <Control-Key-b> {GetFilesFromInsideChosenMixfile 1}	;#	Non backed-up files
		bind $ww <Control-Key-B> {GetFilesFromInsideChosenMixfile 0}	;#	all files
		bind $ww <Command-Control-Key-B> {GetFilesFromInsideChosenMixfile 3};#	muted files
		bind $ww <Control-Key-c> {CopyToWkspace_or_QuickCopy}
		bind $ww <Control-Key-C> {CopyToWkspace_or_QuickCopy}
		bind $ww <Control-Key-d> {ZDeleteFromSystem}
		bind $ww <Control-Key-D> {ZDeleteFromSystem}
		bind $ww <Control-0> {KeyViewWkspaceFile 0}
		bind $ww <Control-e> {KeyViewWkspaceFile 1}
		bind $ww <Control-E> {KeyViewWkspaceFile 1}
		bind $ww <Control-=> {SetShowPmarks}
		bind $ww <Control-Key-8> {KeyMaxsamp}
		bind $ww <Control-Key-f> {Show_Props workspace 0; SetSel prop}
		bind $ww <Control-Key-F> {Show_Props workspace 0; SetSel prop}
		bind $ww <Control-Key-g> {GrabToWkspace_or_GetSndfilesInTxtfile}
		bind $ww <Control-Key-G> {GrabToWkspace_or_GetSndfilesInTxtfile}
		bind $ww <Control-Key-h> {GetNextToChosen 2}
		bind $ww <Control-Key-H> {GetNextToChosen 2}
		bind $ww <Control-Key-j> {NewGetMaxsamplesOnWkspace}
		bind $ww <Control-Key-J> {NewGetMaxsamplesOnWkspace}
		bind $ww <Control-Key-l> {HiliteLastOutfiles}
		bind $ww <Control-Key-L> {HiliteLastOutfiles}
		bind $ww <Control-Key-m> {GetLastMixfile 2}
		bind $ww <Control-Key-M> {GetMainMixfile}
		bind $ww <Control-Key-n> {RenameWkspaceFiles; SetSel name}
		bind $ww <Control-Key-N> {RenameWkspaceFiles; SetSel name}
		bind $ww <Control-Key-p> {PlayAllChosen 3}
		bind $ww <Control-Key-P> {PlayAllChosen 3}
	
		bind $ww <Key-space>	 {UniversalPlay ww 0}
		bind $ww <Shift-Up>		 {FilesMove 1}
		bind $ww <Shift-Down>	 {FilesMove 0}
		bind $ww <Shift-Left>	 {FilesLeft}
		bind $ww <Shift-Right>	 {FilesDeselect}
		bind $ww <Control-Key-r> {RemoveFromWkspace wk}
		bind $ww <Control-Key-R> {RemoveFromWkspace wk}
		bind $ww <Control-Key-s> {SearchWorkspaceForFile 2}
		bind $ww <Control-Key-S> {SearchWorkspaceForFile 0}
		bind $ww <Control-Key-Z> {StrGetDl}
		bind $ww <Control-Key-z> {StrSortWl 1}
		bind $ww <Control-Key-t> {GetNextToChosen 0}
		bind $ww <Control-Key-T> {GetNextToChosen 0}
		bind $ww <Control-Key-u> {RefreshFiles}
		bind $ww <Control-Key-U> {RefreshFiles}
		bind $ww <Escape>		 {LeaveSelectionMode}
		bind $ww <Control-Key-w> {WkspaceToggle}
		bind $ww <Control-Key-W> {WkspaceToggle}
		bind $ww <Control-Down>  {FootOfWkspace; SetSel foot}
		bind $ww <Control-Up>	 {TopOfWkspace 0; SetSel top}
		bind $ww <Control-Left>	 {ArrowLeftFileToChos}
		bind $ww <Control-Right> {RemoveFromWkspace wk}
		bind $ww <Control-Delete> {DeleteFromSystem 0}
		bind $ww <Command-Down>  {$wl yview moveto 1.0}
		bind $ww <Command-Up>  {$wl yview moveto 0.0}
		bind $ww <Shift-Key-c> {SomewhereOnWkspace}
		bind $ww <Shift-Key-C> {SomewhereOnWkspace}
		bind $ww <Shift-Key-p> {PossiblyPut %y}
		bind $ww <Shift-Key-P> {PossiblyPut %y}

		bind $ww <Command-Key-a> {SelectType anal}
		bind $ww <Command-Key-b> {SelectType batch}
		bind $ww <Command-Key-e> {SelectType envel}
		bind $ww <Command-Key-f> {SelectType formant}
		bind $ww <Command-Key-m> {SelectType mix}
		bind $ww <Command-Key-u> {SelectType multimix}
		bind $ww <Command-Key-n> {ShowReminder}
		bind $ww <Command-Key-N> {NnnSee ~~~$wl~~~}
		bind $ww <Command-Key-p> {SelectType props}
		bind $ww <Command-Key-P> {SelectType props}
		bind $ww <Command-Key-o> {SelectType sndlist}
		bind $ww <Command-Key-s> {SelectType snd}
		bind $ww <Command-Key-t> {SelectType text}
		bind $ww <Command-Key-v> {Varibox; SetTestbed varibox}
		bind $ww <Command-Key-z> {MarkZeroLevelFiles 0}
;# 2023
		bind $ww <Command-Key-A> {GetDirExt [string range $evv(ANALFILE_EXT) 1 end]}
		bind $ww <Command-Key-B> {GetDirExt bat}
		bind $ww <Command-Key-E> {GetDirExt evl}
		bind $ww <Command-Key-F> {GetDirExt for}
		bind $ww <Command-Key-M> {GetDirExt mix}
		bind $ww <Command-Key-U> {GetDirExt mmx}
		bind $ww <Command-Key-Q> {GetDirExt prp}
		bind $ww <Command-Key-O> {GetDirExt orc}
		bind $ww <Command-Key-S> {GetDirExt snd}
		bind $ww <Command-Key-T> {GetDirExt txt}
		bind $ww <Command-Key-V> {Varibox; SetTestbed varibox}
		bind $ww <Command-Key-Z> {MarkZeroLevelFiles 1}

		bind $ww <Command-Key-L> {SelectType sel}
		bind $ww <Command-Key-l> {SelectType sel}

		bind $ww <Control-Command-m> {SndInMix}
		bind $ww <Control-Command-T> {MakeThumbnail 0}
		bind $ww <Command-Left>  {ToSelectionMode}	
		bind $ww <Command-Right> {ToSelectionMode}	
		bind $wl <Command-ButtonRelease-1> {ToPlayWindow %y}
		bind $ww <Control-Key-i> {InterleaveFile}
		bind $ww <Control-Key-I> {InterleaveFile}
		bind $ch <Double-1> {PossiblyPlaySnd $ch %y}
		bind $ww <Key-BackSpace> {ClearWkspaceSelectedFiles}
		bind $ww <Key-Tab> {HilightChosen 0}
		bind $ww <Shift-Key-Tab> {HilightChosen 1}
		bind $ww <Command-l> "GetFilesToSrcDirListing $ww.1.b.de $ww.1.b"
		bind $ww <Command-L> "GetFilesToSrcDirListing $ww.1.b.de $ww.1.b"
		bind $ww <Command-W> {GetSubdirNames}
		bind $ww <Command-w> {GetSubdirNames}

		bind $ww <Control-q> {DoWkspaceQuit 1 0}
		bind $ww <Control-Q> {DoWkspaceQuit 1 0}

		if {$data_released} {
			bind $ww <Key-#> {UberData}
			bind $ww <Control-Key-e> {DataConvertor}
			bind $ww <Control-Key-E> {DataConvertor}
			bind $ww <Control-Key-x> {CosmicConvertor}
			bind $ww <Control-Key-X> {CosmicConvertor}
			bind $ww <Control-Key-y> {TimeSeriesConvertor}
			bind $ww <Control-Key-Y> {TimeSeriesConvertor}
		}
		if {[info exists released(specav)] && [info exists released(specanal)]} {
			bind $ww <Key-$> {SpecAverageMaster; SetTestbed specav}
		}

		bind $ww <Control-Key-4> {ViewMixFromSnd}
		bind $ww <Control-Key-5> {GetFilesToDir 0}
		bind $ww <Control-Key-6> {GetFilesToDir 1}

		lappend wrksp_emph $fr.over.sel	;# NB NB MUST BE LAST ON LIST

		set dir_dlg_help_actvtd 0

		if {$top_user && $evv(REDESIGN)} {
			set do_redesign 1		
		}
		if {[info exists main_mix(fnam)]} {
			MainMixButton 0
		} else {
			MainMixButton 1
		}

#FEB6_2001: THIS LINE DOES NOTHING ????
		set dirname [pwd]										;#	Default directory (shown) to current working directory

		catch {wm withdraw .workspace}

		if {!$tw_testing && $sl_real} {
			if {[LoadWkspace $evv(WORKSPACE_FILE) 1] == 0} {	 ;#	Load any existing workspace data
				destroy $zz
				ErrShow "Loading Workspace Failed Or Abandoned."
				BombOut
				return
			}
			if {![info exists fastskip]} {
				ShowReminder
			}
		}
		destroy $zz
	}
;# 2023
	set pvx_set 0
	if {[info exists pvx]} {
		set pvx_set 1
	}	
	if {![DealwithCleaningFiles]} {
		BombOut
		return
	}
	FindTILPfiles 1
	LoadQikbutton
	DisableRestoreChosenList
	wm resizable .workspace 1 1
	set w_hich 0
	set pr1 0
	Setup_DirDisplay
	ShowDirListingOnWkspace
	ChlistDupls
	DuplFilesMsg
	foreach zpropfile [ScanForPropFiles] {
		AddToPropfilesList $zpropfile
	}
	LoadLastMix
	MixMUpgrade
	wm deiconify .workspace
	raise .workspace
	update idletasks
	StandardPosition2 .workspace
	My_Grab 0 .workspace pr1 $wwa
	if {[info exists rym(subedit)]} {
		.workspace selection set $rym(subedit)
		unset rym(subedit)
	}
	MACMessage 1
	tkwait variable pr1
	if [info exists do_not_close_wrksp] {
		tkwait variable pr1
	}
	catch {My_Release_to_Dialog .workspace}
	return
}

proc SeeDiskspace {} {
	global pr_diskvu dvu_srate diskvu_got CDPdsk sl_real diskused evv

	if {!$sl_real} {
		if {$diskused} {
			Inf "You Can See What Duration Of Sound You Have So Far Stored On Your Disk."
		} else {
			Inf "You Can See What Duration Of Sound You Could Store On Your Disk, At The Moment,\nAt Various Sampling Rates."
		}
		return
	}
	set f .diskvu
	if [Dlg_Create $f "Available Diskspace" "set pr_diskvu 0" -borderwidth $evv(SBDR)] {
		set b0  [frame $f.b0 -borderwidth $evv(SBDR)]
		set b1  [frame $f.b1 -borderwidth $evv(SBDR)]
		set b2 [frame $f.b2 -borderwidth $evv(SBDR)]
		listbox $f.ll -width 60 -height 10
		button $b0.q  -text "Close"	-command "set pr_diskvu 0" -highlightbackground [option get . background {}]
		button $b1.16 -text "16000" -command "set dvu_srate 16000 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.22 -text "22050" -command "set dvu_srate 22050 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.24 -text "24000" -command "set dvu_srate 24000 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.32 -text "32000" -command "set dvu_srate 32000 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.44 -text "44100" -command "set dvu_srate 44100 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.48 -text "48000" -command "set dvu_srate 48000 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.88 -text "88200" -command "set dvu_srate 88200 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		button $b1.96 -text "96000" -command "set dvu_srate 96000 ; set pr_diskvu 1" -highlightbackground [option get . background {}]
		label $b2.l -text "Sample Rate"
		pack $b0.q -side top -pady 1
		pack $b2.l -side top -pady 1
		pack $b1.16 $b1.22 $b1.24 $b1.32 $b1.44 $b1.48 $b1.88 $b1.96 -side left -padx 1
		pack $f.b0 $f.b2 $f.b1 $f.ll -side top -pady 1
		bind $f <Escape>  {set pr_diskvu 0}
		bind $f <Return>  {Inf "Select Sample Rate"}
	}
	$f.ll delete 0 end
	set pr_diskvu 0
	set finished 0
	if {$diskused}  {
		wm title $f "Diskspace Used"
	} else {
		wm title $f "Available Diskspace"
	}
	My_Grab 0 $f pr_diskvu
	while {!$finished} {
		tkwait variable pr_diskvu
		if {$pr_diskvu} {
			if {$diskused}  {
				DiskSpaceUsed
			} else {
				set diskvu_got 0
				$f.ll delete 0 end

				set cmd [file join $evv(CDPROGRAM_DIR) diskspace]
				if [ProgMissing $cmd "Cannot find  the amount of space on the disk."] {
					My_Release_to_Dialog $f
					Dlg_Dismiss $f
					return
				}				
				lappend cmd $dvu_srate
				if [catch {open "|$cmd"} CDPdsk] {
					ErrShow "CANNOT RUN THE DISKSPACE UTILITY"
					catch {unset CDPdsk}
					set finished 1
				} else {
					fileevent $CDPdsk readable WriteDiskData
					fconfigure $CDPdsk -buffering line
					if {!$diskvu_got} {
						vwait diskvu_got
					}
				}
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Write Disk Data

proc WriteDiskData {} {
	global CDPdsk diskvu_got evv
	if [eof $CDPdsk] {
		set diskvu_got 1
		catch {close $CDPdsk}
		return
	} else {
		while {[gets $CDPdsk line] >= 0} {
			set line [string trim $line]
			set thislen [string length $line]
			if {$thislen > 0} {
				if [string match INFO:* $line] {
					set line [string range $line 6 end] 
					.diskvu.ll insert end "$line"
				} elseif [string match ERROR:* $line] {
					.diskvu.ll insert end "$line"
					set diskvu_got 1
					catch {close $CDPdsk}
				}
			}
		}
	}
}			

#------ Edit or Create TextFiles from Wkspace Menu

proc Create_Textfile {} {
	global brk sl_real
	if {!$sl_real} {
		Inf "You Can Create New Textfiles"
		return
	}
	set brk(from_wkspace) 1
	Dlg_MakeTextfile -1 0
	set brk(from_wkspace) 0
}

proc Read_Textfile {} {
	global brk sl_real
	if {!$sl_real} {
		Inf "You Can Read And Edit A Selected Textfile"
		return
	}
	set brk(from_wkspace) 1
	ReadFile
	set brk(from_wkspace) 0
}

proc Create_Brkfile {} {
	global brk sl_real
	if {!$sl_real} {
		Inf "You Can Create New Breakpoint Textfiles"
		return
	}
	set brk(from_wkspace) 1
	Dlg_MakeBrkfile 0 -1
	set brk(from_wkspace) 0
}

proc Read_Brkfile {} {
	global brk sl_real
	if {!$sl_real} {
		Inf "You Can Read And Edit A Selected Breakpoint Textfile"
		return
	}
	set brk(from_wkspace) 1
	Dlg_GetTextfile 0 -1 allbrk_wk
	set brk(from_wkspace) 0
}

#------ Put last created outfile on chlist

proc GetLastOutfile {} {
	global last_ch last_outfile chlist ch chcnt wl

	if {![info exists last_outfile]} {
		return
	} else {
		foreach ffnam $last_outfile {
			if {![file isfile $ffnam]} {
				return
			}
		}
	}
	set allmatch 0
	if {[info exists chlist] && ([llength $chlist] == [llength $last_outfile])} {
		set allmatch 1
		foreach ffnam $last_outfile {
			if {[lsearch $chlist $ffnam] < 0} {
				set allmatch 0
				break
			}
		}
	}
	if {!$allmatch} {
		DoChoiceBak
	}
	ClearWkspaceSelectedFiles
	UnsetThumbnail
	foreach ffnam $last_outfile {
		lappend chlist $ffnam		;#	add to end of list
		$ch insert end $ffnam		;#	add to end of display
		incr chcnt
	}
	ChlistDupls
	$wl selection clear 0 end
	foreach fnam $chlist {
		$wl selection set [LstIndx $fnam $wl]
	}
	LastChoiceRedundancy
}

#------ Abandon the workspace

proc DoWkspaceQuit {outval force} {
	global ww evv
	global pr_v pr_clist pr_log pr_textfile pr_textfile pr_maketext pr_brkfile pr_brkdurin pr_wrkbrk
	global pr_design pr_descrip pr_history pr_chooselog pr_missing pr_complete pr_zeehis
	global pr_hod pr_newrootname pr_showprops pr_block pr_user pr_newmach pr_newfile
	global pr_destroymach pr_ins pr100 pr11 pr10 pr9 pr8 pr_5 pr4 pr_mu
	global pr3 pr2 pr1 CDPidview CDPidplay
	global pr_brkname pr_brkfile getout viewcnt do_not_close_wrksp
	global is_terminating pim papag icp pr_datosnd pr_uberdata pr_ts

#
#	KILL is NOT WORKING : if it did, we wouldn't need to requests to user
#		the pid exists, but is not being terminated
#

	if {$force || [AreYouSure]} {

		set is_terminating 1

		if {![catch {pid $CDPidplay} pids]} {
			foreach pid $pids {
				catch {exec $killcmd $pid}				;#	Terminate any processes associated with the pipe
			}
		}
		catch {close $CDPidplay} 					;#	Close the pipe
		catch {unset CDPidplay}

		if {$viewcnt} {											;#	Close any Sound View calls
			set i 0
			while {$i < $viewcnt} {
				if {![catch {pid $CDPidview($i)} pids]} {
					foreach pid $pids {
						DoKill $pid
					}
				}
				catch {close $CDPidview($i)} 					;#	Close the pipe
				catch {unset CDPidview($i)}
				incr i
			}
		}

		catch {unset do_not_close_wrksp}
		catch {destroy $bfw.help.quit}
		catch {destroy $icp.help.quit}
		catch {destroy $papag.help.quit}
		catch {destroy $pim.help.quit}
		catch {destroy  $ww.h.q}
		catch {destroy .ted}
		catch {destroy  $ww.1.b.db0.starthelp}
		catch {destroy $pim.help.starthelp}
		catch {destroy $papag.help.starthelp}
		catch {destroy $icp.help.starthelp}
		catch {destroy $bfw.help.starthelp}
		catch {destroy .running.t.starthelp}
		set pr_datosnd 0
		set pr_ts 0
		set pr_uberdata 0
		set pr_log 0
		set pr_te 0
		set pr_colorder 0
		set pr_cc 0
		set pr_mu 0
		set pr_maketext 0
		set pr_brkname 0 
		set getout 1
		set pr_brkfile 0
		set pr_textfile 0
		set pr_brkdurin 0
		set pr_design 0
		set pr_descrip 0
		set pr_history 0
		set pr_chooselog 0
		set pr_missing 0
		set pr_complete 0
		set pr_zeehis 0
		set pr_hod 0
		set pr_newrootname 0
		set pr_showprops 0
		set pr_block 0
		set pr_user 0
		set pr_newmach 0
		set pr_newfile 0
		set pr_destroymach 0
		set pr_ins $evv(INS_ABORTED)
		set pr_v 0
		set pr_clist 0
		set pr_ref 0
		set pr_refs 0
		set pr_rfg 0
		set pr11_11 0
		set prsys 0
		set pr100 0
		set pr11 0
		set pr10 0
		set pr9	0
		set pr8 0
		set pr_5 -1
		set pr4 0
		set pr3 0
		set pr_wrkbrk 0
		set pr2 0
		raise .cdphello
		set pr1 $outval
	}
}

#------ Remove the currently cursor-selected item from the chlist (or keep it, if chkeep exists)

proc ModSlist {y} {
	global ch chlist chcnt chkeep

	if [info exists chlist] {
		set i [$ch nearest $y]						;#	Get list-index nearest to mouse-cursor
		set fnam [$ch get $i]						;#	Get filename at that index
		if {[info exists chkeep]} {
			DoChoiceBak
			set chlist $fnam
			set chcnt 1
			$ch delete 0 end
			$ch insert end $fnam
			unset chkeep
		} else {
			DoChoiceBak
			$ch delete $i		
			incr chcnt -1
			catch {unset chlist}
			foreach fnm [$ch get 0 end] {
				lappend chlist $fnm
			}
		}
		ChlistDupls
		UnsetThumbnail
	}
}

#------ Reconfig button to return to wkspace mode

proc ToWkspaceMode {} {
	global ww wl ch chlist selection_mode wksp_hlp_actv wksp_in_chose_mode
	global wrksp_emph saved_wrksp_emph showing_pmarks macsmall evv

	$ww.1.a.endd.l.over.el config -text "" -bg [option get . background {}] 

	$ww.1.a.endd.l.title config -fg $evv(SPECIAL) -bg $evv(EMPH)
	$ww.1.a.endd.r.l config -fg [option get . foreground {}] -bg [option get . background {}]
	$ww.1.a.endd.r.over.sel config -text "Enter Chosen Files Mode" -command ToSelectionMode
	bind $ww <Command-Left> {}
	bind $ww <Command-Right> {}
	bind $ww <Command-Left> {ToSelectionMode}
	bind $ww <Command-Right> {ToSelectionMode}

	$ww.1.a.endd.r.c.list config -bg [option get . background {}]
	$ww.1.a.endd.r.x1.cc config -state disabled
	$ww.1.a.endd.r.x1.ro config -state disabled
	$ww.1.a.endd.r.x2.la config -state disabled
	$ww.1.a.endd.r.x2.cp config -state disabled
	$ww.1.a.endd.r.x1.ch config -state disabled
	$ww.1.a.endd.r.x2.da config -state disabled

	$ww.1.a.endd.l.new2.cs  config -state normal
	$ww.1.a.endd.l.new2.cs2 config -state normal
	$ww.1.a.endd.l.new2.pla config -state normal
	if {$macsmall} {
		$ww.1.a.endd.l.new2.b   config -state normal -text "Backup"
	} else {
		$ww.1.a.endd.l.new2.b   config -state normal -text "Backup Selected Files"
	}
	$ww.1.a.endd.l.new.all config -state normal -text "Any/All Files"
	if {$macsmall} {
		$ww.1.a.endd.l.new.few config -state normal -text "Selected Files"
		$ww.1.a.endd.l.new.cre config -state normal -text "Files of Type"
	} else {
		$ww.1.a.endd.l.new.few config -state normal -text "Selected Files Only"
		$ww.1.a.endd.l.new.cre config -state normal -text "Selected Files of Type"
	}

	if {[info exists saved_wrksp_emph]} {
		set wrksp_emph $saved_wrksp_emph
	}

	set selection_mode 0
	bind $wl <ButtonRelease-1> {}
	bind $ch <ButtonRelease-1> {}
	bind $wl <Shift-ButtonRelease-1> {}
	bind $ww <Shift-Key-c> {SomewhereOnWkspace}
	bind $ww <Shift-Key-C> {SomewhereOnWkspace}
	bind $ww <Shift-Key-p> {PossiblyPut %y}
	bind $ww <Shift-Key-P> {PossiblyPut %y}

	bind $ww <Command-Key-a> {SelectType anal}
	bind $ww <Command-Key-b> {SelectType batch}
	bind $ww <Command-Key-e> {SelectType envel}
	bind $ww <Command-Key-f> {SelectType formant}
	bind $ww <Command-Key-m> {SelectType mix}
	bind $ww <Command-Key-c> {SelectType multimix}
	bind $ww <Command-Key-p> {SelectType props}
	bind $ww <Command-Key-P> {SelectType props}
	bind $ww <Command-Key-o> {SelectType sndlist}
	bind $ww <Command-Key-s> {SelectType snd}
	bind $ww <Command-Key-t> {SelectType text}

	bind $ww <Control-Command-m> {SndInMix}
	bind $ww <Control-Command-T> {MakeThumbnail 0}

	if {$wksp_hlp_actv} {
		bind $wl <ButtonRelease-1> {WkH MainListbox; ShowPitchmark %y}
		bind $ch <ButtonRelease-1> {WkH ChoiceListing}
	} else {
		bind $wl <ButtonRelease-1> {ShowPitchmark %y}
	}
	set wksp_in_chose_mode 0
	$wl config -selectmode extended
	$wl selection clear 0 end
	if {[info exists chlist]} {
		foreach fnam $chlist {
			set i [LstIndx $fnam $wl]
			if {$i >= 0} {
				$wl selection set $i
			}
		}
	}
	$wl xview moveto 0
}

#------ Reconfig button to return to selection mode

proc ToSelectionMode {} {
	global ww wl ch selection_mode wksp_hlp_actv wksp_in_chose_mode evv
	global saved_wrksp_emph wrksp_emph chpos showing_pmarks tosomewhere

	set chpos -1

	$ww.1.a.endd.l.over.el config -text "CLICK ON WORKSPACE FILE TO PUT IT IN CHOSEN FILES LIST" -bg $evv(EMPH)

	$ww.1.a.endd.l.title config -fg [option get . foreground {}] -bg [option get . background {}]
	$ww.1.a.endd.r.l config -fg $evv(SPECIAL) -bg $evv(EMPH)	;#	Mark by color
	$ww.1.a.endd.r.over.sel config -text "Return to Wkspace Mode" -command ToWkspaceMode
	bind $ww <Command-Left> {}
	bind $ww <Command-Right> {}
	bind $ww <Command-Left> {ToWkspaceMode}
	bind $ww <Command-Right> {ToWkspaceMode}
								  
	$ww.1.a.endd.r.c.list config -bg $evv(EMPH)
 	$ww.1.a.endd.r.x1.cc config -state normal
	$ww.1.a.endd.r.x1.ro config -state normal -text "Reorder"
	$ww.1.a.endd.r.x2.la config -state normal
	$ww.1.a.endd.r.x2.cp config -state normal -text "Previous"
	$ww.1.a.endd.r.x1.ch config -state normal -text "Get/Mod"
	$ww.1.a.endd.r.x2.da config -state normal -text "Play:Props"

	$ww.1.a.endd.l.new2.cs  config -state disabled
	$ww.1.a.endd.l.new2.cs2 config -state disabled
	$ww.1.a.endd.l.new2.pla config -state disabled
	$ww.1.a.endd.l.new2.b   config -state disabled

	$ww.1.a.endd.l.new.all config -state disabled 
	$ww.1.a.endd.l.new.few config -state disabled
	$ww.1.a.endd.l.new.cre config -state disabled

	set saved_wrksp_emph $wrksp_emph
	set len [llength $wrksp_emph]
	incr len -2
	set wrksp_emph [lrange $wrksp_emph 0 $len]

	set selection_mode 1
	bind $wl <ButtonRelease-1> {}
	bind $ch <ButtonRelease-1> {}
	bind $ww <Shift-Key-c> {}
	bind $ww <Shift-Key-C> {}
	bind $ww <Shift-Key-p> {}
	bind $ww <Shift-Key-P> {}
	bind $ww <Command-Key-a> {}
	bind $ww <Command-Key-b> {}
	bind $ww <Command-Key-e> {}
	bind $ww <Command-Key-f> {}
	bind $ww <Command-Key-m> {}
	bind $ww <Command-Key-c> {}
	bind $ww <Command-Key-p> {}
	bind $ww <Command-Key-P> {}
	bind $ww <Command-Key-o> {}
	bind $ww <Command-Key-s> {}
	bind $ww <Command-Key-t> {}

	bind $ww <Control-Command-m> {}
	bind $ww <Control-Command-T> {}
	catch {unset tosomewhere}
	if {$wksp_hlp_actv} {
		bind $wl <Shift-ButtonRelease-1> {set topchpos 1; ModChlist %y; set topchpos 0; WkH MainListbox; ShowPitchmark %y} ;#	Bind the mouse-button(1)-release to list selection
		bind $wl <ButtonRelease-1> {ModChlist %y; WkH MainListbox; ShowPitchmark %y}
		bind $ch <ButtonRelease-1> {ModSlist %y; WkH ChoiceListing}
	} else {
		bind $wl <Shift-ButtonRelease-1> {set topchpos 1; ModChlist %y; set topchpos 0; ShowPitchmark %y} ;#	Bind the mouse-button(1)-release to list selection
		bind $wl <ButtonRelease-1> {ModChlist %y; ShowPitchmark %y} ;#	Bind the mouse-button(1)-release to list selection
		bind $ch <ButtonRelease-1> {ModSlist %y}
	}
	set wksp_in_chose_mode 1
	$wl config -selectmode single
	$wl selection clear 0 end
	$ch xview moveto 0
}

#------ Clear list of selected files

proc ClearWkspaceSelectedFiles {} {
	global chlist ch chcnt dupl_mix dupl_vbx dupl_txt
	if [info exists chlist] {
		unset chlist
		$ch delete 0 end
	}
	set chcnt 0
	set dupl_mix 0
	set dupl_vbx 0
	set dupl_txt 0
}

#------ Refresh workspace: i.e. reparse and check existence of files in list & load any newfiles in wkspace directory

proc RefreshWorkspace {} {
	global wl wstk pa last_ch lalast_ch rememd wstk do_parse_report renam evv mixmanage tosomewhere refrwksp nesstype

	set thumkill -1
	catch {unset tosomewhere}
	set save_mixmanage 0
	set nessupdate 0
	set refrwksp 1
	Block "Updating the Workspace"
	set i 0
	foreach fnam [$wl get 0 end] {
		incr i
	}
	incr i -1
	while {$i >= 0} { 
		set fnam [$wl get $i]
		switch -- $thumkill {
			"-1" {
				set ftyp [FindFileType $fnam]	
				if {($ftyp== $evv(SNDFILE)) || ($ftyp < 0)} {
					set msg "Delete All Associated Thumbnails ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						set thumkill 1
						ThumbKill $fnam
					} else {
						set thumkill 0
					}
				}
			}
			1 {
				set ftyp [FindFileType $fnam]	
				if {($ftyp== $evv(SNDFILE)) || ($ftyp < 0)} {
					ThumbKill $fnam
				}
			}
		}
		if {![file exists $fnam]} {			;#	DELETE non-existent files
			DataManage delete $fnam
			lappend couettelist $fnam
			RemoveAllRefsToFile $fnam $i
			if {[info exists mixmanage($fnam)]} {
				unset mixmanage($fnam)
				set save_mixmanage 1
			}
			if {[info exists nesstype($fnam)]} {
				PurgeNessData $fnam
				set nessupdate 1
			}
			if {[IsInAMixfile $fnam]} {
				lappend delete_mixmanage $fnam
			}
		} else {							;#		Reparse existing files
			set do_parse_report 1
			if {[DoParse $fnam $wl 0 0] <= 0} {
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] \
					-message "Spurious File '$fnam' On Workspace: Delete It ?"]
				if {$choice == "yes"} {
					if [catch {file delete $fnam} xx] {
						Inf "$xx\nCannot Remove File '$fnam' : Ignoring It"
					} else {
						DataManage delete $fnam
						lappend couettelist $fnam
						DummyHistory $fnam "DESTROYED"
						RemoveAllRefsToFile $fnam $i
						if {[info exists mixmanage($fnam)]} {
							unset mixmanage($fnam)
							set save_mixmanage 1
						}
						if {[info exists nesstype($fnam)]} {
							PurgeNessData $fnam
							set nessupdate 1
						}
						if {[IsInAMixfile $fnam]} {
							lappend delete_mixmanage $fnam
						}
					}
				}
			}
		}
		incr i -1
	}
	if {[info exists couettelist]} {
		CouettePatchesDelete $couettelist
	}

	foreach fnam [glob -nocomplain -- *] {
#JUNE 30 UC-LC FIX
		set fnam [string tolower $fnam]
		set ftail [file tail $fnam]
#NOV 2011 More rigorous name check
		if [IgnoreSoundloomxxxFilenames $ftail] {
			continue
		} else {
			if {[string match $evv(DFLT_OUTNAME)* $ftail] \
			 || [string match $evv(MACH_OUTFNAME)* $ftail] \
			 || [string match $evv(DFLT_TMPFNAME)* $ftail]} {
				if [catch {file delete $fnam} xx] {
					Inf "Cannot Remove Temporary File '$fnam' : Ignoring It"
				} else {
					DeleteFileFromSrcLists $fnam
				}
				continue
			}
		}
		if [file isdirectory $fnam] {
			continue
		}
		set is_newfile 0
		if {[LstIndx $fnam $wl] < 0} {
			set is_newfile 1
		}
		set fnam $ftail
		catch {PurgeArray $fnam}
		set do_parse_report 1
		if {[DoParse $fnam $wl 0 0] <= 0} {
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] \
				-message "Spurious File '$fnam' In Workspace Directory : Delete It ?"]
			if {$choice == "yes"} {
				if [catch {file delete $fnam} xx] {
					Inf "$xx\nCannot Remove File '$fnam' : Ignoring It"
				} else {
					DataManage delete $fnam
					lappend couettelist $fnam
					DummyHistory $fnam "DESTROYED"
					if {[info exists mixmanage($fnam)]} {
						unset mixmanage($fnam)
						set save_mixmanage 1
					}
					if {[info exists nesstype($fnam)]} {
						PurgeNessData $fnam
						set nessupdate 1
					}
					if {[IsInAMixfile $fnam]} {
						lappend delete_mixmanage $fnam
					}
					DeleteFileFromSrcLists $fnam
				}
			}
		} else { 
			set ftyp $pa($fnam,$evv(FTYP))
			DataManage update $fnam
			if {[IsAMixfileIncludingMultichan $ftyp]} {
				MixfileSndfilesOnWkspace $fnam 1
				if {[MixMUpdate $fnam 0]} {
					set save_mixmanage 1
				}
			} elseif {[UpdatedIfANessFull $fnam]} {
				set nessupdate 1
			}
		}
		if {$is_newfile} {
			$wl insert 0 $fnam
			WkspCnt $fnam 1
		}
	}
	if {[info exists couettelist]} {
		CouettePatchesDelete $couettelist
	}
	if [info exists last_ch] {
		set i [llength $last_ch]
		incr i -1
		while {$i >= 0} {
			set fnam [lindex $last_ch $i]
			if {[LstIndx $fnam $wl] < 0} {
				set last_ch [lreplace $last_ch $i $i]
			}
			incr i -1		
		}
		if {[llength $last_ch] <= 0} {
			catch {unset last_ch}
		}
	}
	if [info exists lalast_ch] {
		set i [llength $lalast_ch]
		incr i -1
		while {$i >= 0} {
			set fnam [lindex $lalast_ch $i]
			if {[LstIndx $fnam $wl] < 0} {
				set lalast_ch [lreplace $lalast_ch $i $i]
			}
			incr i -1		
		}
		if {[llength $lalast_ch] <= 0} {
			catch {unset lalast_ch}
		}
	}
	catch {unset rememd}
	if {[info exists delete_mixmanage]} {
		if {[MixM_ManagedDeletion $delete_mixmanage]} {		;#	IF ANY FILES ARE USED IN MIXFILES, BUT NO LONGER EXIST
			set save_mixmanage 1
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	UnBlock
	set renam 1
	return 1
}

#------ Refresh selected files on workspace

proc RefreshFiles {} {
	global wl wstk pa rememd do_parse_report renam mixmanage evv chlist nesstype chpos

	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		if {[info exists chlist] && ([llength $chlist] > 0)} {
			foreach fnam $chlist {
				set k [LstIndx $fnam $wl]
				if {$k >= 0} {
					$wl selection set $k
				}
			}
			set ilist [$wl curselection]
		}
		if {[llength $ilist] <= 0} {
			Inf "No Files Selected"
			return
		}
	}
	set save_mixmanage 0
	set nessupdate 0
	Block "Updating Selected Files on Workspace"

	set ilist [ReverseList $ilist]
	foreach i $ilist {
		set fnam [$wl get $i]				  ;#	DELETE non-existent files
		set ftyp [FindFileType $fnam]	
		if {($ftyp== $evv(SNDFILE)) || ($ftyp < 0)} {
			ThumbKill $fnam
		}
		if {![file exists $fnam]} {
			DataManage delete $fnam
			lappend couettelist $fnam
			RemoveAllRefsToFile $fnam $i
			if {[info exists mixmanage($fnam)]}  {
				unset mixmanage($fnam)
				set save_mixmanage 1
			}
			if {[info exists nesstype($fnam)]}  {
				PurgeNessData $fnam
				set nessupdate 1
			}
			if {[IsInAMixfile $fnam]} {
				lappend delete_mixmanage $fnam
			}
		} else {							;#		Reparse existing files
			set do_parse_report 1
			if {[DoParse $fnam $wl 0 0] <= 0} {
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] \
					-message "Spurious File '$fnam' On Workspace: Delete It ?"]
				if {$choice == "yes"} {
					if [catch {file delete $fnam} xx] {
						Inf "$xx\nCannot Remove File '$fnam' : Ignoring It"
					} else {
						DataManage delete $fnam
						lappend couettelist $fnam
						DummyHistory $fnam "DESTROYED"
						RemoveAllRefsToFile $fnam $i
						if {[info exists mixmanage($fnam)]}  {
							unset mixmanage($fnam)
							set save_mixmanage 1
						}
						if {[info exists nesstype($fnam)]}  {
							PurgeNessData $fnam
							set nessupdate 1
						}
						if {[IsInAMixfile $fnam]} {
							lappend delete_mixmanage $fnam
						}
					}
				}
			} else { 
				set ftyp $pa($fnam,$evv(FTYP))
				DataManage update $fnam
				if {[IsAMixfileIncludingMultichan $ftyp]} {
					MixfileSndfilesOnWkspace $fnam 1
					if {[MixMUpdate $fnam 0]} {
						set save_mixmanage 1
					}
					set this_ext [AssignTextfileExtension $ftyp]
					if {![string match $this_ext [file extension $fnam]]} {
						FixMixfileExtension $fnam $this_ext
					}
				} elseif {[UpdatedIfANessFull $fnam]} {
					set nessupdate 1
				}
				if {[info exists chlist]} {
					set exch [lsearch $chlist $fnam]
					if {$exch >= 0} {
						RemoveFromChosenlist $fnam
						set chpos $exch
						PutItOnChlist $fnam
					}
				}
			}
		}
	}
	if {[info exists couettelist]} {
		CouettePatchesDelete $couettelist
	}
	if {[info exists delete_mixmanage]} {
		if {[MixM_ManagedDeletion $delete_mixmanage]} {
			set save_mixmanage 1
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	set renam 1
	catch {unset rememd}
	UnBlock
}

#------ Load subdirectory into directory listing on wkspace

proc LoadSubDirectory {dirname} {
	global wksp_dirname ww 

	set dirname [CheckDirectoryName $dirname "directory name" 0 1]
	if {[string length $dirname] <= 0} {
		return
	}
	set wksp_dirname $dirname
	UpdateRecentDirs $dirname

	ForceVal $ww.1.b.de $dirname

	Dlg_Showdir $dirname $ww.1.b 0

}

#------ Load subdirectory into directory listing on wkspace

proc LoadHomeDirectory {} {
	global pr_5 wksp_dirname dl ww hidden_dir is_subdirlist wlilist wl

	set wksp_dirname ""
	ForceVal $ww.1.b.de ""
	if {![info exists pr_5]} {
		LoadDir
		return
	}
	$dl delete 0 end
	$dl xview moveto 0.0
	Block "Listing Directory"
	foreach fnam [lsort -dictionary [glob -nocomplain *]] {
		if [IsListableHomeDirFile $fnam] {
#JUNE 30 UC-LC FIX
			set fnam [string tolower $fnam]
			$dl insert end $fnam		;#	and place them in the listing window
		} else {
			if {![file isdirectory $fnam]} {
				lappend badnames $fnam
			}
		}
	}
	if {[info exists badnames]} {
		ListAcceptableBadnames $badnames
	}
	set hidden_dir ""
	catch {unset is_subdirlist}
	if {[info exists wlilist]} {
		$wl selection clear 0 end
		foreach i $wlilist {
			$wl selection set $i
		}
		unset wlilist
	}
	UnBlock
}

#------ Parse file and add it to workspace

proc FileToWkspace {fnam chosenmode docopy bottom isgrab iscreated} {
	global pa wl ch wksp_in_chose_mode chlist wstk evv
	global do_parse_report chcnt rememd propfiles_list wkspace_newfile parse_the_max search_for_propsfiles

# 	0  = Continue without loading file 
#	-1 = Conclude file loading, major error
#	else Continues after loading file

	if {![file isfile $fnam]} {
		Inf "'$fnam' Is Not A File"
		return 0
#NOV 2011 More rigorous name check
	} elseif [IgnoreSoundloomxxxFilenames $fnam] {
		return 0
	} elseif {[ExcludedFiletype $fnam]} {
		return 0
	}
	set do_parse_report 1
	if {$isgrab} {
		set test [DoParse $fnam $wl 1 $docopy]
	} else {
		set test [DoParse $fnam $wl 2 $docopy]
	}
	switch -- $test {
		0		{return $evv(PARSE_FAILED)}						
		-1		{return -1}						
		default	{
			set origfnam $fnam
			if {$docopy} {
				set fnam [file tail $fnam]
			}
			set filetype $pa($fnam,$evv(FTYP))
			if {$evv(DFLT_SR) > 0} {
				if {($filetype & $evv(IS_A_SNDSYSTEM_FILE)) && ($filetype != $evv(ENVFILE))} {
					if {$filetype == $evv(SNDFILE)} {
						if {$pa($fnam,$evv(SRATE)) != $evv(DFLT_SR)} {
  							PurgeArray $fnam
							Inf "File '$fnam' Is Not At The Specified Sample Rate Of $evv(DFLT_SR)"
							return 0
						} elseif {$isgrab > 1} {
							if {$isgrab == 10000} {
								if {$pa($fnam,$evv(CHANS)) != 1} {
  									PurgeArray $fnam
									return 0
								}
							} elseif {$pa($fnam,$evv(CHANS)) != $isgrab} {
  								PurgeArray $fnam
								return 0
							}
						}
					} elseif {$isgrab > 1} {
						PurgeArray $fnam
						return 0
					} elseif {$pa($fnam,$evv(ORIGRATE)) != $evv(DFLT_SR)} {
						PurgeArray $fnam
						Inf "File '$fnam' Is Not At The Specified Sample Rate OF $evv(DFLT_SR)"
						return 0
					}
				} elseif {$isgrab > 1} {
					PurgeArray $fnam
					return 0
				} elseif {$filetype == $evv(PSEUDO_SND)} {
					if {$pa($fnam,$evv(SRATE)) != $evv(DFLT_SR)} {
						PurgeArray $fnam
						Inf "File '$fnam' Is Not At The Specified Sample Rate OF $evv(DFLT_SR)"
						return 0
					}
				}			
			} elseif {$isgrab > 1} {
				if {$filetype != $evv(SNDFILE)} {
  					PurgeArray $fnam
					return 0
				} elseif {$isgrab == 10000} {
					if {$pa($fnam,$evv(CHANS)) != 1} {
  						PurgeArray $fnam
						return 0
					}
				} elseif {$pa($fnam,$evv(CHANS)) != $isgrab} {
  					PurgeArray $fnam
					return 0
				}
			}
			if {$isgrab && $search_for_propsfiles} {
				set is_propfile 0
				if {($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)) && [ThisIsAPropsFile $origfnam 0 0]} {
					set is_propfile 1
				}
			}
			if {$docopy} {
				set fnam $origfnam
				set haspmark [HasPmark $fnam]
				set hasmmark [HasMmark $fnam]
				set nufnam [file tail $fnam]
				if [catch {file copy $fnam $nufnam} in] {
					Inf "$in"
					Inf "Cannot Copy '$nufnam' To Workspace"
					PurgeArray $nufnam
					return 0
				} else {
					DummyHistory $nufnam "CREATED"
					if {$haspmark} {
						CopyPmark $fnam $nufnam
					}
					if {$hasmmark} {
						CopyMmark $fnam $nufnam
					}
				}
				if {$isgrab && $search_for_propsfiles} {
					if {$is_propfile} {
						AddToPropfilesList $nufnam
					}
				} else {
					if {[info exists propfiles_list]} {
						if {[lsearch $propfiles_list $fnam] >= 0} {
							AddToPropfilesList $nufnam
						}
					}
				}
				set fnam $nufnam
			} else {
				if {$isgrab && $search_for_propsfiles} {
					if {$is_propfile} {
						AddToPropfilesList $fnam
					}
				} elseif {[HasUserDefinedPropfileExtension $fnam]} {
					AddToPropfilesList $fnam
				}
			}
			if {$bottom} {
				$wl insert end $fnam
			} else {
				$wl insert 0 $fnam
			}
			WkspCnt $fnam 1
			catch {unset rememd}

			#	IF FileToWkspace SHOULD RESPOND TO choosefiles MODE OF WKSPACE (chosenmode set)
			#	AND IF WKSPACE IS IN choosefiles MODE  (wksp_in_chose_mode set)

			if {$chosenmode && $wksp_in_chose_mode} {	;#	NB FileToWkspace Listing is Reversed ... so REreverse here
				if {[info exists chlist]} {
					set chlist [concat $fnam $chlist]
				} else {
					set chlist $fnam
				}
				$ch insert 0 $fnam
				incr chcnt
			}
			if {$isgrab && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
				if {![info exists pa($fnam,$evv(MAXREP))] && $parse_the_max} {	;#	Otherwise it's already known
					GetMaxsampOnInput $fnam
				}
			}
		}
	}
	if {$iscreated}  {
		set wkspace_newfile 1
	}
	return 1
}

#------ Parse the file (using cdparse) and, if a valid file, save its data in pa

proc DoParse {fnam listing checklisting docopy} {
	global evv CDPid parse_error is_input_parse infile_rejected infile_dicey parse_the_max wl
	global pa propslist props_got pprg mmod wstk wl_finds is_initial_parse
	set parse_error 0
	set props_got 0
	set is_input_parse 1
	set infile_rejected 0
	set infile_dicey 0

	if {$docopy} {
		set nufnam [file tail $fnam]
		set test [LstIndx $nufnam $listing]
		if {$test >= 0} {
			$listing selection clear 0 end
			$listing selection set $test
			Inf "File '$nufnam' Already On Workspace"
			return 0											;#	No need to abort calling routine
		} elseif [file exists $nufnam] {						;#	File exists but not currently listed on wkspace
			if {![CouetteAllowsDelete $nufnam]} {
				return 0
			}
			set choice [tk_messageBox -type yesno -default yes \
				-message "File '$nufnam' Already Exists : Overwrite It?" -parent [lindex $wstk end]]
			if {$choice == "no"} {
				return 0					   ;#	No need to abort calling routine
			} else {
				if [catch {file delete $nufnam} in] {
					Inf "Cannot Delete The Existing File."
					return 0
				} else {											;# Copy only takes place from Dirlist to Wkspace.
					DataManage delete $nufnam
					DeleteFileFromSrcLists $nufnam					;# File created is a wkspace file.
					set ftyp $pa($nufnam,$evv(FTYP))
					RemoveFromChosenlist $nufnam
					if {[HasPmark $nufnam]} {
						DelPmark $nufnam
					}
					if {[HasMmark $nufnam]} {
						DelMmark $nufnam
					}
					PurgeArray $nufnam
					DummyHistory $nufnam "OVERWRITTEN"
				}
			}
		}
	} elseif {$checklisting} {
		set test [LstIndx $fnam $listing]
		if {$test >= 0} {
			$listing selection set $test
			Inf "File '$fnam' Already On Workspace"
			if {$checklisting == 1} {
				$wl selection set $test
				lappend wl_finds $test
			}
			return 0											;#	No need to abort calling routine
		}
	}
	set CDPid 0
	set cmd [file join $evv(CDPROGRAM_DIR) cdparse]
	set zzfnam [OmitSpaces $fnam]
	if [catch {open "|$cmd $zzfnam $parse_the_max"} CDPid] {
		ErrShow "CDPARSE PROGRAM FAILED TO RUN"
		catch {unset CDPid}
		return -1
	} else {
		set propslist ""
		fileevent $CDPid readable AccumulateFileProps
	}
	vwait props_got

	if {$parse_error} {
		return -1
	}
	if {$infile_rejected} {
		return 0
	}
	if [info exists propslist] {
		if {[llength $propslist] != ($evv(CDP_PROPS_CNT) + $evv(CDP_MAXSAMP_CNT))} {
			if {![info exists is_initial_parse]} {
				set msg "Wrong Number Of Props ([llength $propslist])\n"
				append msg "Returned by CDPARSE from file '$fnam'\n"
				append msg "\n"
				append msg "PROPSLIST = \n"
				append msg "$propslist\n"
				append msg "************************************************\n"
				append msg "If You Are Just Starting To Use The Soundloom\n"
				append msg "You May Have Failed To Set the Environment Variables\n"
				append msg "\n"
				append msg "You May Also Want To Halt The Soundloom"
				append msg "(Apple menu -> 'Force Quit'"
				append msg " then select 'Wish' and Force Quit)"
				ErrShow $msg
			}
			if {$infile_dicey} {
				return 0
			}
			return -1
		}
 																		;#	Trap pseudo_sndfiles
		set propno 0

		if {$docopy} {
			set fnam $nufnam
		}
		foreach prop $propslist {
			set pa($fnam,$propno) $prop
			incr propno
		}
		if {[info exists pa($fnam,$evv(MAXREP))]} {
			if {($pa($fnam,$evv(MAXREP)) < 0) || ($pa($fnam,$evv(FTYP)) != $evv(SNDFILE))} {
				unset pa($fnam,$evv(MAXREP))
			}
		}
	} else {
		ErrShow "FAILED TO GET PROPERTIES OF FILE $fnam"
		if {$infile_dicey} {
			return 0
		}
		return -1
	}
	return 1
}

#------ Parse the file (using cdparse) merely to find the filetype

proc DoMinParse {fnam} {
	global CDPid parse_error infile_rejected pa propslist props_got is_input_parse evv
	set parse_error 0
	set props_got 0
	set infile_rejected 0
	set is_input_parse 0

	set CDPid 0
	set cmd [file join $evv(CDPROGRAM_DIR) cdparse]
	set zzfnam [OmitSpaces $fnam]
	lappend cmd $zzfnam 0
	if [catch {open "|$cmd"} CDPid] {
		catch {unset CDPid}
		return 0
	} else {
		set propslist ""
		fileevent $CDPid readable AccumulateFileProps
	}
	vwait props_got
	if {$parse_error || $infile_rejected || ![info exists propslist] || ([llength $propslist] < 1)} {
		return 0
	}
	set pa($fnam,$evv(FTYP)) [lindex $propslist 0]
	return 1
}

#------ Read data output from CDParse

proc AccumulateFileProps {} {
	global CDPid parse_error infile_dicey infile_rejected propslist wstk evv
	global is_input_parse props_got do_parse_report is_initial_parse new_no_parse_questions
	if [eof $CDPid] {						
		catch {close $CDPid}
		set props_got 1
		return
	} else {
		gets $CDPid str
		set str [string trim $str]
		if {[llength $str] <= 0} {
			return
		}
		if [string match ERROR:* $str] {
			if {![info exists is_initial_parse]} {
				ErrShow $str
			}
			set parse_error 1
			catch {close $CDPid}				 
			set props_got 1
			return
		} elseif [string match INFO:* $str] {
			Inf $str
			catch {close $CDPid}				 
			set props_got 1
			return
		} elseif [string match WARNING:* $str] {
			if {$is_input_parse} {
				if {![info exists is_initial_parse]} {
					if {!$new_no_parse_questions} {
						ErrShow $str
					}
				}
				if {$do_parse_report} {
					if {$new_no_parse_questions} {
						set infile_rejected 1
					} else {
						set choice [tk_messageBox -type yesno -default yes \
							-message "Put File On Workspace?" -parent [lindex $wstk end]]
						if {$choice == "no"} {
							set infile_rejected 1
						} else {
							set infile_dicey 1
						}
					}
				}
				catch {close $CDPid}
				set props_got 1
				return
			} 
			# ELSE, when parsing outfiles, IGNORE WARNINGS
		} elseif [string match END* $str] {
			catch {close $CDPid}
			set props_got 1
			return
		} else {
			append propslist $str
			return
		}
	}
}

#------ Check if new filename is already in the list, and if so get its index.

proc LstIndx {fnam listing} {
	set i 0
	foreach fnm [$listing get 0 end] {
		if [string match [string tolower $fnm] [string tolower $fnam]] {
			return $i
		}
		incr i
	}
	return -1
}


#------ Add the currently cursor-selected file to end of chlist
#
#	or delete the currently cursor-deselected file from chlist
#

proc ModChlist {y} {
	global wl ch chlist chcnt chpos topchpos wstk dupl_mix dupl_vbx dupl_txt ch_analy pa evv released ww
	set i [$wl nearest $y]								;#	Get list-index nearest to mouse-cursor
	set fnam [$wl get $i]								;#	Get filename at that index
	if {![info exists chlist]} {
		set chlist $fnam
		set chcnt 1
		$ch insert end $fnam
		set chpos -1
		$ch yview moveto 0.0
		$ch xview moveto 0.0
		return
	}
	set i [lsearch $chlist $fnam]
	if {$i < 0} {										;#	not already on list
		set added 0
		set ftyp $pa($fnam,$evv(FTYP))
		if {[VBoxReleased]} {
			if {$dupl_vbx} {
				if {$ftyp == $evv(ANALFILE)} {
					set dupl_mix 0
					PutItOnChlist $fnam
					set ch_analy 1
					set added 1
				} elseif {($ftyp == $evv(SNDFILE)) && ($pa($fnam,$evv(CHANS)) == 1)} {
					PutItOnChlist $fnam
					set added 1
				}
			} 
		}
		if {!$added} {
			if {$dupl_mix} {					;#	NOT a dupl_txt listing, could still be dbl_vbx
				if {$ftyp == $evv(SNDFILE)} {
					PutItOnChlist $fnam
					if {$pa($fnam,$evv(CHANS)) > 1} {
						set dupl_vbx 0
					}
				} else {
					Inf "Can't Choose This Sound For A Mix, Join Or Texture Process: Not A Soundfile"
				}
			} elseif {$dupl_txt} {
				if {$ftyp == $evv(TEXTFILE)} {
					PutItOnChlist $fnam
					set dupl_mix 0
					set dupl_vbx 0
				} else {
					Inf "Can't Choose This Sound For A Rhythmic Knot Process Or Data Manipulation"
				}
			} else {
				set rejected 0
				if {$ftyp ==$evv(SNDFILE)} {
					if {$pa($fnam,$evv(CHANS)) > 1} {
						if {$dupl_vbx} {
							Inf "Can't Choose This Sound For Voicebox (Must Be Mono)"
							set rejected 1
						}
						set dupl_txt 0
					}
				} elseif {$ftyp == $evv(ANALFILE)} {
					set dupl_mix 0
					set dupl_txt 0
				} elseif {$ftyp & $evv(IS_A_TEXTFILE)} {
					set dupl_mix 0
					set dupl_vbx 0
				}
				if {!$rejected} {
					PutItOnChlist $fnam
				}
			}
		}
	} else {												;#	sound already on list
		set added 0
		if {[info exists released(newmix)]} {				;#	Implies textfile on list already: therefore not dupl_mix or dupl_vbx
			if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)} {
				if {!$dupl_txt} {
					set msg "File Is Already On Chosen Files List\n\nYou Can Add A Further Copy Only For Rhythmic Knots Option On Music Testbed, And Data Processes\n"
					append msg "\nContinue ?"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						PutItOnChlist $fnam
						set dupl_txt 1
						$ww.1.a.endd.r.rr.cnts config -readonlybackground green
						set added 1
					}
				} else {
					PutItOnChlist $fnam
					set added 1
				}
			}
		}
		if {!$added} {
			if {[VBoxReleased]} {
				if {(($pa($fnam,$evv(FTYP)) == $evv(SNDFILE)) && ($pa($fnam,$evv(CHANS)) == 1)) || ($pa($fnam,$evv(FTYP)) == $evv(ANALFILE))} {
					if {!$dupl_vbx} {
						set msg "File Is Already On Chosen Files List\n\nYou Can Add A Further Copy Only For \n"
						if {!$ch_analy && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
							append msg "\n1) Making Mixfiles\n2) Joining Files Together\n3) Texture Processes\n4) MULTICHANNEL INTERLEAVING\n"
						}
						append msg "\nThe Voicebox\n\nContinue ?"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							set dupl_vbx 1 
							if {$dupl_mix && ($pa($fnam,$evv(FTYP)) == $evv(ANALFILE))} {
								set ch_analy 1
								set dupl_mix 0
							}
							PutItOnChlist $fnam
							$ww.1.a.endd.r.rr.cnts config -readonlybackground green
							set added 1
						}
					} else {
						if {$dupl_mix && ($pa($fnam,$evv(FTYP)) == $evv(ANALFILE))} {
							set ch_analy 1
							set dupl_mix 0
						}
						PutItOnChlist $fnam
						set added 1
					}
				}
			}
			if {!$added} {
				if {($pa($fnam,$evv(FTYP)) == $evv(SNDFILE)) && !$ch_analy} {	;#	NOT mono (mono dealt with above) and no analysis file in chlist
					if {!$dupl_mix} {
						set msg "File Is Already On Chosen Files List\n\nYou Can Add A Further Copy Only For\n\n1) Making Mixfiles\n2) Joining Files Together\n3) Texture Processes\n4) Multichannel Interleaving\n"
						append msg "\nContinue ?"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							set dupl_mix 1
							$ww.1.a.endd.r.rr.cnts config -readonlybackground green
							PutItOnChlist $fnam
						}
					} else {
						PutItOnChlist $fnam
					}
				}
			}
		}
	}
	set chpos -1
	$ch yview moveto 0.0
	$ch xview moveto 0.0
}

#------ 
#	Delete a file (listed on workspace) from the Hard Disk
#

proc DeleteFromSystem {type} {
	global wl ch rememd files_deleted wstk blist_change background_listing new_user_text_extensions user_text_extensions nesstype

	set ilist [$wl curselection]
	if {$type >= 0} {	;# NEED SELECTED FILES
		if {[llength $ilist] <= 0} {
			Inf "No Item Selected"
			return
		}
	}
	if {$type != 0} {	;# CRITERIA TO BE APPLIED -- NOT MERELY THE SELECTED FILES
		set ilist [WhichFilesToDelete $ilist $type]
		if {[llength $ilist] <= 0} {
			return
		}
		
	}
	if {[llength $ilist] == 1} {
		set fnam [$wl get $ilist]
		set msg "Are You Sure You Want To Destroy File '$fnam' ?"
	} else {
		set msg "Are You Sure You Want To Destroy These\n\n[llength $ilist]\n\nFiles ?"
	}
	set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
	if {$choice == "no"} {
		return
	}
	foreach i $ilist {
		set ext [file extension [$wl get $i]]
		if {[info exists new_user_text_extensions] || [info exists user_text_extensions]} {
			if {[string match $ext [GetTextfileExtension props]]} {

				set msg "*****************************\n\nTHERE IS AT LEAST ONE PROPERTY FILE HERE\n\nARE YOU SURE YOU WANT TO DELETE THIS ?"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					return
				}
				break
			}	
		}
	}
	set save_mixmanage 0
	set nessupdate 0
	set blist_change 0
	foreach i $ilist {							;#	returns list of indices of cursor-selected list-items
		set fnam [$wl get $i]				;#	returns fnam at index
		if [DeleteFileFromSystem $fnam 0 1] {
			lappend couettedelete $fnam
			lappend deleted_files $i			;#	save the listing-index of each ACTUALLY deleted file
			DummyHistory $fnam "DESTROYED"
			if {[MixMDelete $fnam 0]} {
				set save_mixmanage 1
			} elseif {[IsInAMixfile $fnam]} {
				lappend delete_mixmanage $fnam
			} elseif {[info exists nesstype($fnam)]} {
				PurgeNessData $fnam
				set nessupdate 1
			}
		}
	}											;#	remove from listing the ACTUALLY deleted files

	if {[info exists couettedelete]} {
		CouettePatchesDelete $couettedelete
	}
	if [info exists deleted_files] {
		if {$blist_change} {
			SaveBL $background_listing
		}
		foreach i [lsort -integer -decreasing $deleted_files] {
			WkspCnt [$wl get $i] -1
			$wl delete $i
		}
		set files_deleted 1
		catch {unset rememd}
		if {[info exists delete_mixmanage]} {
			if {[MixM_ManagedDeletion $delete_mixmanage]} {
				set save_mixmanage 1
			}
		}
		if {$save_mixmanage} {
			MixMStore
		}
		if {$nessupdate} {
			NessMStore
		}
	}
}

#------ 
#	Delete all analysis file (listed on workspace) from the Hard Disk
#

proc DeleteAllAnalFromSystem {} {
	global wl rememd files_deleted blist_change background_listing pa evv

	if {[AreYouSure] == 0} {
		return
	}
	set i 0
	set blist_change 0
	foreach fnam [$wl get 0 end]  {
		if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(ANALFILE))} {
			if [DeleteFileFromSystem $fnam 0 1] {
				lappend deleted_files $i	;#	save the listing-index of each ACTUALLY deleted file
				DummyHistory $fnam "DESTROYED"
			}
		}
		incr i
	}											;#	remove from listing the ACTUALLY deleted files

	if [info exists deleted_files] {
		if {$blist_change} {
			SaveBL $background_listing
		}
		foreach i [lsort -integer -decreasing $deleted_files] {
			WkspCnt [$wl get $i] -1
			$wl delete $i
		}
		set files_deleted 1
		catch {unset rememd}
	}
}

#------ Remove a named file from the system.

proc DeleteFileFromSystem {fnam backnow sure} {
	global wstk pa background_listing blist_change scores_refresh ideas_create main_mix evv

	if {[info exists ideas_create] && [string match [file rootname [file tail $fnam]] "ideas"]} {
		unset ideas_create
		if [catch {file delete $fnam} q] {
			set msg "Cannot Delete File $fnam.\n"
			return 0
		}
		UpdateBakupLog $fnam delete 1
		return 1
	}
	if {![CouetteAllowsDelete $fnam]} {
		return 0
	}
	set haspmark 0
	set hasmmark 0
	if [IgnoreSoundloomxxxFilenames $fnam] { 
		return 0
	}
	if [info exists pa($fnam,$evv(FTYP))] {				
		set is_on_workspace 1
	} else {
		set is_on_workspace 0
	}
	if [catch {file stat $fnam filestatus} in] {
		Inf "Cannot Determine Status Of File $fnam: If It Is Open, Deletion May Fail"
	} elseif {$filestatus(ino) >= 0} {
		catch {close $filestatus(ino)}
	}
	if {!$is_on_workspace} {							;#	If file is NOT logged as on workspace
		set ftyp [FindFileType $fnam]					;#	find filetype ONLY
		if {$ftyp == $evv(SNDFILE)} {
			if {!$sure} {
				if [IsOnScore $fnam] {
					set msg "The Overwritten File '$fnam' Is In Use In The Current Sketch Score\n\nRemove It ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						RemoveFromScore $fnam
						set scores_refresh 1
					}
				} else {
					set scores_refresh 1
				}
			} else {
				if [IsOnScore $fnam] {
					RemoveFromScore $fnam
				}
				set scores_refresh 1
			}
			set pa($fnam,$evv(FTYP)) $ftyp
			set haspmark [HasPmark $fnam]
			set hasmmark [HasMmark $fnam]
			unset pa($fnam,$evv(FTYP))
		} elseif {$ftyp & $evv(IS_A_TEXTFILE)} {
			PurgePropfilesList $fnam
		}
	} else {
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]
	}
	if [catch {file delete $fnam} q] {
		set msg "Cannot Delete File $fnam.\n"
		append msg "If It Is Open For Play Or Viewing, Close Play/View Program(s) Now.\n"
		Inf $msg
		if [catch {file delete $fnam} q] {
			set msg "Still Cannot Delete File $fnam: Removing It From The Workspace For Now.\n"
			append msg "To Use This Filename Again, You May Need To Restart Your Session."
			Inf $msg
		} else {
			DataManage delete $fnam
		}
	} else {
		DataManage delete $fnam
		UpdateBakupLog $fnam delete 1
	}
	if {[info exists main_mix(fnam)] && [string match $fnam $main_mix(fnam)]} {
		catch {unset main_mix}
		MainMixButton 1
	}
	DeleteFileFromSrcLists $fnam						;# Delete any info re source of sound
	if {$haspmark} {									;# Remove any pmark
		DelPmark $fnam
	}
	if {$hasmmark} {									;# Remove any pmark
		DelMmark $fnam
	}
	if {[IsInBlists $fnam]} {							;# Check if mentioned in background listings, and if so
		set OK 1
		if {!$sure} {									;# NOT SURE implies Deleted file is being overwritten in context
														;# where user might be intending to modify an existing file
														;# and keep it in the same Blists
			set msg "The Overwritten File '$fnam' Was In One Or More Background Listings\n\nRemove Those Mentions ?"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if {$choice == "no"} {
				set OK 0
			}
		}
		if {$OK} {
			if {[RemoveFromBLists $fnam]} {
				if {$backnow} {							;# There is only one file to deal with: backup blist info to Blists-file NOW
					SaveBL $background_listing
				} else {								;# May be dealing with list of files.
					set blist_change 1					;# flag that a Blist has been modified, so that Blists-file can be modified
				}										;# once complete list of files has been processed
			}
		}
	}

	if {$is_on_workspace} {								;#	If file is on workspace,
		set ftyp $pa($fnam,$evv(FTYP))
		if {$ftyp == $evv(SNDFILE)} {
			if {!$sure} {
				if [IsOnScore $fnam] {
					set msg "The Overwritten File '$fnam' Is In Use In The Current Sketch Score\n\nRemove It ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						RemoveFromScore $fnam
						set scores_refresh 1
					}
				} else {
					set scores_refresh 1
				}
			} else {
				if [IsOnScore $fnam] {
					RemoveFromScore $fnam
				}
				set scores_refresh 1
			}
		} elseif {$ftyp & $evv(IS_A_TEXTFILE)} {
			PurgePropfilesList $fnam
		}
		PurgeArray $fnam			 					;#	remove the array-data on that file
		RemoveFromChosenlist $fnam	 					;#	remove the file from the chosen list (if on it)
	}
	RemoveFromChoiceBakup $fnam
	RemoveFromDirlist $fnam	 	 						;#	remove the file from the directory list (if on it)
	return 1
}

#------ Remove details of a file from the properties array

proc PurgeArray {fnam} {
	global evv pa
	set propno 0
	if {![info exists pa($fnam,$propno)]} {	;#	Don't try to delete non-existent props
		return
	}
	while {$propno < ($evv(CDP_PROPS_CNT) + $evv(CDP_MAXSAMP_CNT))} {
		catch {unset pa($fnam,$propno)}		;#	Delete all props
		incr propno
	}
}

#------ Remove a named file from the chlist

proc RemoveFromChosenlist {fnam} {
	global chlist ch chcnt dupl_mix dupl_vbx dupl_txt
	if [info exists chlist] {
		set len [llength $chlist]
		set i 0
		while {$i < $len} {
			set fnm [lindex $chlist $i]
			if [string match $fnm $fnam] {
				set chlist [lreplace $chlist $i $i]
				incr len -1
			} else {
				incr i
			}
		}
		$ch delete 0 end
		set chcnt 0
		if {[llength $chlist] == 0} {
			set dupl_mix 0
			set dupl_vbx 0
			set dupl_txt 0
		} else {
			foreach fnm $chlist {
				$ch insert end $fnm
				incr chcnt
			}
			ChlistDupls
		}
	}
}

#------ Remove a named file from the directory listing

proc RemoveFromDirlist {fnam} {
	global dl hidden_dir
	if {[info exists dl] && ![catch {set firstname [$dl get 0]}]} { 
		if {[string length $hidden_dir] > 0} {
			set firstname [file join $hidden_dir $firstname]
		}
		if [string match [file dirname $fnam] [file dirname $firstname]] {
			set j [LstIndx $fnam $dl]
			if {$j >= 0} {
				$dl delete $j
			}
		}
		if {[$dl index end] < 0} {
			set hidden_dir ""
		}
	}
}

#------ Add a named file to the directory listing

proc AddToDirlist {fnam} {
	global dl hidden_dir
	if {[info exists dl] && ![catch {set firstname [$dl get 0]}]} { 
		if {[string length $hidden_dir] > 0} {
			set firstname [file join $hidden_dir $firstname]
		}
		if {[string match [file dirname $fnam] [file dirname $firstname]]} {
			if {[string length $hidden_dir] > 0} {
				foreach dfnam [$dl get 0 end] {
					set dfnam [file join $hidden_dir $dfnam]
					if {[string match $fnam $dfnam]} {
						return
					}
				}
				$dl insert end [file tail $fnam]
			} else {
				foreach dfnam [$dl get 0 end] {
					if {[string match $fnam $dfnam]} {
						return
					}
				}
				$dl insert end $fnam
			}
		}
	}
}

#------ Remove a selection of files from the workspace (but DON'T DELETE from the hard-disk)

proc RemoveFromWkspace {where} {
	global wl ch total_wksp_cnt rememd last_b_l last_bl_name last_bl_name2 b_l bln_var ww sl_real pa evv
	global files_to_wkspace_from_tabed chlist
	switch -- $where {
		"bkgd" {
			if {![info exists last_b_l]} {
				return
			}
			foreach fnam $last_b_l {
				set i [LstIndx $fnam $wl]
				if {$i >= 0}  {
					lappend ilist $i
				}
			}
			if {![info exists ilist] || ([llength $ilist] <= 0)} {
				Inf "No Items Remain On The Workspace Which Are Unique To The Last Background List Loaded."
				return
			}
		} 
		"bkgdall" {
			if {![info exists last_bl_name] || ![info exists b_l($last_bl_name)]} {
				return
			}
			foreach fnam $b_l($last_bl_name) {
				set i [LstIndx $fnam $wl]
				if {$i >= 0}  {
					lappend ilist $i
				}
			}
			if {![info exists ilist] || ([llength $ilist] <= 0)} {
				Inf "No Items Remain On The Workspace Which Are In Background List '$last_bl_name'"
				return
			}
		}
		"bkgdall2" {
			if {![info exists last_bl_name2] || ![info exists b_l($last_bl_name2)]} {
				return
			}
			foreach fnam $b_l($last_bl_name2) {
				set i [LstIndx $fnam $wl]
				if {$i >= 0}  {
					lappend ilist $i
				}
			}
			if {![info exists ilist] || ([llength $ilist] <= 0)} {
				Inf "No Items Remain On The Workspace Which Are In Background List '$last_bl_name2'"
				return
			}
		} 
		"bkgdthis" {
			GetBLName 8
			if {[string length $bln_var] > 0} {
				foreach fnam $b_l($bln_var) {
					set i [LstIndx $fnam $wl]
					if {$i >= 0}  {
						lappend ilist $i
					}
				}
				if {![info exists ilist] || ([llength $ilist] <= 0)} {
					Inf "No Items Remain On The Workspace Which Are In Background List '$last_bl_name2'"
					return
				}
			} else {
				return
			}
		} 
		"tabed" {
			if {![info exists files_to_wkspace_from_tabed]} {
				return
			}
			foreach fnam $files_to_wkspace_from_tabed {
				set i [LstIndx $fnam $wl]
				if {$i >= 0}  {
					lappend ilist $i
				}
			}
			unset files_to_wkspace_from_tabed
			if {![info exists ilist] || ([llength $ilist] <= 0)} {
				return
			}
		} 
		"sndlist" {
			set i [$wl curselection]
			if {![info exists i] || ([llength $i] <= 0)} {
				Inf "No File Selected"
				return
			}
			if {[llength $i] > 1} {
				Inf "Select A Single Textfile"
				return
			}
			set fnam [$wl get $i]
			if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
				Inf "Select A Single Textfile"
				return
			}
			if [catch {open $fnam "r"} zit] {
				Inf "Cannot Open File $fnam"
				return
			}
			catch {unset ilist}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[llength $line] <= 0} {
					continue
				}
				if {[string match ";" [string index $line 0]]} {
					continue
				}
				set line [RegulariseDirectoryRepresentation $line]
				if {[file exists $line]} {
					set i [LstIndx $line $wl]
					if {$i >= 0} {
						lappend ilist $i
					}
				}
			}
			close $zit
			if {![info exists ilist]} {
				Inf "None Of The Sounds Listed In File '$fnam' Is On The Workspace"
				return
			}
		} 
		default {
			set ilist [$wl curselection]
			if {![info exists ilist] || ([llength $ilist] <= 0)} {
				Inf "No Item Selected"
				return
			}
			if {($where == "wkx") && [info exists chlist] && ([llength $chlist] > 0)} {
				set nuilist {}
				foreach i $ilist {
					set fnam [$wl get $i]
					if {[lsearch $chlist $fnam] < 0} {
						lappend nuilist $i
					}
				}
				if {[llength $nuilist] <= 0} {
					Inf "All Selected Files Are On The Chosen List"
					return
				}
				set ilist $nuilist

			}
			if {$where == "dir"} {
				if {!$sl_real} {
					Inf "All Files In The Same Directory As The Selected File\nCan Be Removed From The Workspace Listing"
					return
				}
				foreach i $ilist {
					set fnam [$wl get $i]
					set zzz [file dirname $fnam]
					if {[string length $zzz] > 1} {
						if {[info exists thisdir]} {
							if {![string match $zzz $thisdir]} {
								Inf "Files Selected From More Than One Directory"
								return
							}
						} else {
							set thisdir $zzz
						}
					}
				}
				if {![info exists thisdir]} {
					Inf "Selected Files Are In Home Directory"
					return
				}
				unset ilist
				set i 0
				foreach fnam [$wl get 0 end] {
					set zzz [file dirname $fnam]
					if {[string match $zzz $thisdir]} {
						lappend ilist $i
					}
					incr i
				}
			} elseif {!$sl_real} {
				Inf "Selected Files Can Be Removed From The Workspace Listing\n\n(They Are Not Deleted From Your Disk)"
				return
			}
		}
	}
	foreach i [lsort -integer -decreasing $ilist] {	;#	get listing indices in reverse order
		set fnam [$wl get $i] 						;#	get name associated with index
		set ff [file tail $fnam]					;#	get name without directory path

		if {![string match $ff $fnam]} {	 		;#	IF no directory path, it's not bakdup
			PurgeArray $fnam						;#	can't remove unbakdup files!!
			RemoveFromChosenlist $fnam				;#	Otherwise, remove it
			incr total_wksp_cnt -1
			$wl delete $i
		}
	}
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	catch {unset rememd}
}				

#------ Move a selection of files on workspace to a new directory

proc MoveDirectory {remove} {
	global wl dl ch chlist wksp_dirname pa rememd renam wstk evv hidden_dir total_wksp_cnt nesstype nessorig
	global file_overwrite background_listing scores_refresh sl_real dupl_mix dupl_vbx dupl_txt
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "There Are Duplicate Files On The Chosen Files List: Remove Them Before Proceeding"
		return
	}
	catch {unset nessorig}
	if {!$sl_real} {
		Inf "Files Can Be Moved From One Directory To Another"
		return
	}

	set file_overwrite 0
	set ren_blist 0
	set ilist [$wl curselection]						;#	Check files have been selected
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 1]
	if {[string length $dirname] <= 0} {
		return											;#	Check existence & validity of filename
	}
	set save_mixmanage 0
	set nessupdate 0
	Block "Moving files to new directory"
														;#	Check existence of a listed directory
	if {[info exists dl] && ![catch {set firstname [$dl get 0]}]} {
		if {[string length $hidden_dir] > 0} {
			set ldirname $hidden_dir
		} else {
			set ldirname [file dirname $firstname]
		}
	}
	set to_listed_directory 0							;#	Check if directory exists & if so
	set to_existing_directory 0							;#	if it is listed on workspace
	if {[file exists $dirname] && [file isdirectory $dirname]} {
		set to_existing_directory 1
		if [info exists ldirname] {
			if [string match $dirname $ldirname] {
				set to_listed_directory 1
			}
		}
	} else {
		if [catch {file mkdir $dirname} zorg] {
			Inf "Cannot Create Directory '$dirname'"
			return
		}
	}
	set bakd_files 0
	set are_snds 0
	foreach i [lsort -integer -decreasing $ilist] {		;#	get listing indices in reverse order
		set fnam [$wl get $i] 						;#	get name associated with index
		if {[IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
			lappend mlist $fnam
			continue
		}
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]
		set nufnam [file join $dirname [file tail $fnam]]
		if [string match $fnam $nufnam] {
			continue
		}
		set	from_listed_directory 0
		if [info exists ldirname] {
			set last_dirname [file dirname $fnam]
			if {([string length $last_dirname] > 0) && [string match $last_dirname $ldirname]} {
				set	from_listed_directory 1
			}
		}
		set file_overwrite 0
		set nessupdate 0
		if {$to_existing_directory} {
			if [file exists $nufnam] {
				if {![CouetteAllowsDelete $nufnam]} {
					continue
				}
				set choice [tk_messageBox -type yesno -default yes -message "File '$nufnam' Already Exists: Overwrite It???" \
					-icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					continue
				} else {
					if [catch {file delete $nufnam} zorg] {
						Inf "Cannot Delete Existing File '$nufnam'"
						continue			   				;#	If existing file is to be overwritten,
					} else {								;#	Remove existing duplicate file
						DataManage delete $nufnam
						lappend couettedelete $nufnam
						UpdateBakupLog $nufnam delete 1
						DeleteFileFromSrcLists $nufnam
						if {[IsInAMixfile $nufnam]} {
							lappend delete_mixmanage $nufnam
						}
						set ftyp $pa($nufnam,$evv(FTYP))
						PurgeArray $nufnam					;#	but no need to remove from any workspace listed directory
						if [IsInBlists $nufnam] {
							set msg "The Overwritten File '$nufnam' Was Mentioned In Background Listings\n\nRemove Those Mentions ??"
							set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
							if {$choice == "yes"} {
								if [RemoveFromBLists $nufnam] {
									set ren_blist 1
								}
							}
						}
						if [IsOnScore $nufnam] {
							set msg "The Overwritten File '$nufnam' Is In Use In The Current Sketch Score\n\nRemove It ??"
							set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
							if {$choice == "yes"} {
								RemoveFromScore $nufnam
								set scores_refresh 1
							}
						} elseif {$ftyp == $evv(SNDFILE)} {
							set scores_refresh 1
						}

						DummyHistory $nufnam "OVERWRITTEN"
						if [info exists chlist] {
							set j [lsearch -exact $chlist $nufnam]
							if {$j >= 0} {
								set renam 1
							}
						}
						set file_overwrite 1
					}
				}										;#	as old file will be replaced by new file, in that listing

			} elseif {$to_listed_directory} {			;#	If new directory is the workspace listed directory
				set znufnam $nufnam
				if {[string length $hidden_dir] > 0} {
					set znufnam [file tail $znufnam]
				}
				$dl insert end $znufnam					;#	and file with new name does NOT already exist
			}											;#	add new filename to workspace listed directory
		}
		if {$from_listed_directory} {
			set zzfnam $fnam
			if {[string length $hidden_dir] > 0} {
				set zzfnam [file tail $zzfnam]
			}
			set j [LstIndx $zzfnam $dl]
			if {$j >= 0} {
				$dl delete $j
			}
		}
		if [catch {file rename -force $fnam $nufnam} zorg] {
			ErrShow "$zorg"
			ErrShow "Failed To Rename File $fnam"
			continue
		}
		UpdateBakupLog $fnam delete 0
		UpdateBakupLog $nufnam create 1
		CheckMainmixSnd $fnam $nufnam
		$wl delete $i
		if {[LstIndx $nufnam $wl] < 0} {
			$wl insert $i $nufnam
			catch {unset rememd}
		}
		RenameProps $fnam $nufnam 1
		DummyHistory $fnam "RENAMED_$nufnam"
		DataManage rename $fnam $nufnam
		lappend couettelist $fnam $nufnam
		if {[MixMRename $fnam $nufnam 0]} {
			set save_mixmanage 1
		} elseif {[NessMRename $fnam $nufnam 0]} {
			set nessupdate 1
		}
		if {$haspmark} {
			MovePmark $fnam $nufnam
		}
		if {$hasmmark} {
			MoveMmark $fnam $nufnam
		}
		if [IsInBlists $fnam] {
			if [RenameInBlists $fnam $nufnam] {
				set ren_blist 1
			}
		}
		if [IsOnScore $fnam] {
			RenameOnScore $fnam $nufnam
		}
		AddToDirlist $nufnam
		if [info exists chlist] {
			set j [lsearch -exact $chlist $fnam]
			if {$j >= 0} {
				set jjj [lsearch -exact $chlist $nufnam]
				if {$jjj >= 0} {
					set chlist [lreplace $chlist $j $j]
				} else {
					set chlist [lreplace $chlist $j $j $nufnam]
				}
				$ch delete 0 end
				foreach ff $chlist {
					$ch insert end $ff
				}
			}
		}
		if {!$are_snds} {
			if {$pa($nufnam,$evv(FTYP)) == $evv(SNDFILE)} {
				set are_snds 1
			}
		}
		set bakd_files 1
		if {$remove} {
			set ff [file tail $nufnam]					;#	get name without directory path
			if {![string match $ff $nufnam]} {	 		;#	IF no directory path, it's not bakdup
				lappend remove_fnams $nufnam
			}
		}
	}						 
	if {[info exists couettedelete]} {
		CouettePatchesDelete $couettedelete
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	if {[info exists mlist]} {
		catch {unset ilist}
		foreach fnam $mlist {
			set i [LstIndx $fnam $wl]
			if {$i >= 0} {
				lappend ilist $i
			}
		}
		foreach i [lsort -integer -decreasing $ilist] {
			set fnam [$wl get $i] 						;#	get name associated with index
			set nufnam [file join $dirname [file tail $fnam]]
			if [string match $fnam $nufnam] {
				continue
			}
			set	from_listed_directory 0
			if [info exists ldirname] {
				set last_dirname [file dirname $fnam]
				if {([string length $last_dirname] > 0) && [string match $last_dirname $ldirname]} {
					set	from_listed_directory 1
				}
			}
			set file_overwrite 0
			if {$to_existing_directory} {
				if [file exists $nufnam] {
					set choice [tk_messageBox -type yesno -default yes -message "FILE $nufnam ALREADY EXISTS: OVERWRITE IT???" \
						-icon question -parent [lindex $wstk end]]
					if {$choice == "no"} {
						continue
					} else {
						if [catch {file delete -force $nufnam} zorg] {
							Inf "Cannot Delete Existing File '$nufnam'"
							continue			   				;#	If existing file is to be overwritten,
						} else {								;#	Remove existing duplicate file
							DataManage delete $nufnam
							UpdateBakupLog $nufnam delete 1
							DeleteFileFromSrcLists $nufnam
							set ftyp $pa($nufnam,$evv(FTYP))
							PurgeArray $nufnam					;#	but no need to remove from any workspace listed directory
							DummyHistory $nufnam "OVERWRITTEN"
							if [info exists chlist] {
								set j [lsearch -exact $chlist $nufnam]
								if {$j >= 0} {
									set renam 1
								}
							}
							set file_overwrite 1
						}
					}										;#	as old file will be replaced by new file, in that listing

				} elseif {$to_listed_directory} {			;#	If new directory is the workspace listed directory
					set znufnam $nufnam
					if {[string length $hidden_dir] > 0} {
						set znufnam [file tail $znufnam]
					}
					$dl insert end $znufnam					;#	and file with new name does NOT already exist
				}											;#	add new filename to workspace listed directory
			}
			if {$from_listed_directory} {
				set zzfnam $fnam
				if {[string length $hidden_dir] > 0} {
					set zzfnam [file tail $zzfnam]
				}
				set j [LstIndx $zzfnam $dl]
				if {$j >= 0} {
					$dl delete $j
				}
			}
			if [catch {file rename -force $fnam $nufnam} zorg] {
				ErrShow "$zorg"
				ErrShow "Failed To Rename File '$fnam'"
				continue
			}
			DataManage rename $fnam $nufnam
			lappend couettelist $fnam $nufnam
			UpdateBakupLog $fnam delete 0
			UpdateBakupLog $nufnam create 1
			CheckMainmix $fnam $nufnam
			$wl delete $i
			if {[LstIndx $nufnam $wl] < 0} {
				$wl insert $i $nufnam
				catch {unset rememd}
			}
			RenameProps $fnam $nufnam 1
			DummyHistory $fnam "RENAMED_$nufnam"
			if {[MixMRename $fnam $nufnam 0]} {
				set save_mixmanage 1
			}
			AddToDirlist $nufnam
			if [info exists chlist] {
				set j [lsearch -exact $chlist $fnam]
				if {$j >= 0} {
					set jjj [lsearch -exact $chlist $nufnam]
					if {$jjj >= 0} {
						set chlist [lreplace $chlist $j $j]
					} else {
						set chlist [lreplace $chlist $j $j $nufnam]
					}
					$ch delete 0 end
					foreach ff $chlist {
						$ch insert end $ff
					}
				}
			}
			set bakd_files 1
			if {$remove} {
				set ff [file tail $nufnam]					;#	get name without directory path
				if {![string match $ff $nufnam]} {	 		;#	IF no directory path, it's not bakdup
					lappend remove_fnams $nufnam
				}
			}
		}
	}
	if {[info exists delete_mixmanage]} {	;#	DEAL WITH DELETED FILES, 
		foreach fnam $delete_mixmanage {
			if {![file exists $fnam]} {		;#	WHERE THE RENAMING (CREATION OF NEW FILE WITH SAME NAME) FAILED
				lappend xfiles $fnam
			}
		}
		if {[info exists xfiles]} {
			if {[MixMPurge 0]} {			;#	DEAL WITH DELETED MIXFILES
				set save_mixmanage 1
			}								;#	DEAL WITH DELETED SNDFILES LISTED IN MIXFILES
			if {[MixM_ManagedDeletion $xfiles]} {
				set save_mixmanage 1
			}
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$bakd_files} {
		if {$are_snds} {
			set scores_refresh 1
		}
		UpdateBakupDirs $dirname
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	catch {unset rememd}
	if {[info exists remove_fnams]} {
		catch {unset ilist}
		foreach fnam $remove_fnams {
			set i [LstIndx $fnam $wl]
			if {$i >= 0} {
				lappend ilist $i
			}
		}
		if [info exists ilist] {
			foreach i [lsort -integer -decreasing $ilist] {
				set fnam [$wl get $i]
				PurgeArray $fnam
				RemoveFromChosenlist $fnam
				incr total_wksp_cnt -1
				$wl delete $i
			}
		}
	} else {
		foreach i $ilist {
			$wl selection set $i
		}
	}
	UnBlock
}

#------ Sort listing (e.g. workspace) into alphabetical order
	
proc SortListing {listing typ} {
	global rememd wl tosomewhere

	if {[string match $listing $wl]} {
		catch {unset tosomewhere}
	}
	foreach fnam [$listing get 0 end] {
		lappend tl $fnam
	}
	if {![info exists tl]} {
		return
	}
	set listlen [llength $tl]

	switch -- $typ {
		0 {
			foreach fnam [lsort -dictionary $tl] {
				lappend newlist $fnam
			}
		}
		1 {
			foreach fnam [lsort -dictionary -decreasing $tl] {
				lappend newlist $fnam
			}
		}
		2 {
			foreach fnam $tl {
				set tla [file rootname [file tail $fnam]]
				set tla [ReverseString $tla]
				lappend tla $fnam
				lappend tlas $tla
			}
			set len [llength $tlas]
			set len_less_one [expr $len - 1]
			set n 0
			while {$n < $len_less_one} {
				set tlan [lindex $tlas $n]
				set thisn [lindex $tlan 0]
				set m $n
				incr m
				while {$m < $len} {
					set tlam [lindex $tlas $m]
					set thism [lindex $tlam 0]
					if {[string compare $thism $thisn] < 0} {
						set tlas [lreplace $tlas $m $m $tlan]
						set tlas [lreplace $tlas $n $n $tlam]
						set tlan $tlam
						set thisn $thism
					}
					incr m
				}
				incr n
			}
			foreach tla $tlas {
				lappend newlist [lindex $tla 1]
			}
		}
		3 -
		4 - 
		5 {
			set cnt 0
			foreach val $tl {
				set thistail [file tail $val]
				if {$typ == 5} {
					set thistail [file rootname $thistail]
					set thistail [ReverseString $thistail]
				}
				lappend tails [list $thistail $val]
				incr cnt
			}
			set n 0 
			set cnt_less_one [expr $cnt - 1]
			while {$n < $cnt_less_one} {
				set thisitem [lindex $tails $n]
				set thisname [lindex $thisitem 0]
				set m [expr $n + 1]
				while {$m < $cnt} {
					set thatitem [lindex $tails $m]
					set thatname [lindex $thatitem 0]
					if {$typ == 4} {		;#	REVERSE ALPHA
						if {[string compare $thatname $thisname] > 0} {
							set tails [lreplace $tails $n $n $thatitem]
							set tails [lreplace $tails $m $m $thisitem]
							set thisname $thatname
							set thisitem $thatitem
						}					;#	ALPHA, EITHER ON TAIL or REVERSED ROOTNAME
					} elseif {[string compare $thatname $thisname] < 0} {
						set tails [lreplace $tails $n $n $thatitem]
						set tails [lreplace $tails $m $m $thisitem]
						set thisname $thatname
						set thisitem $thatitem
					}
					incr m
				}					
				incr n
			}
			foreach item $tails {
				lappend newlist [lindex $item 1]
			}
		}
	}
	$listing delete 0 end
	for {set i 0} {$i < $listlen} {incr i} {
		$listing insert end [lindex $newlist $i]
	}
	if [string match $listing $wl] {
		catch {unset rememd}
	}
}

#------ Sort listing (e.g. workspace) into date order

proc SortListingNew {listing typ} {
	global rememd evv tosomewhere wl

	if {[string match $listing $wl]} {
		catch {unset tosomewhere}
	}
	set listlen 0
	foreach fnam [$listing get 0 end] {
		if [regexp {/} $fnam] {		;#	Allows directory separator '/'
			lappend oldlist $fnam
		} else {
			lappend newlist $fnam
		}
		incr listlen
	}
	switch -- $typ {
		n {
			if [info exists newlist] {
				if [info exists oldlist] {
					set newlist [concat $newlist $oldlist]
				}
			} elseif [info exists oldlist] {
				set newlist $oldlist
			}
		}
		b {
			if [info exists oldlist] {
				if [info exists newlist] {
					set newlist [concat $oldlist $newlist]
				} else {
					set newlist $oldlist
				}
			}
		}
	}
	$listing delete 0 end
	if [info exists newlist] {
		for {set i 0} {$i < $listlen} {incr i} {
			$listing insert end [lindex $newlist $i]
		}
	}
	catch {unset rememd}
}

#------ Sort listing (e.g. workspace) into filetype (and then alphabetical) order
	
proc SortListingType {listing typ} {
	global pa rememd evv tosomewhere propfiles_list wl

	if {[string match $listing $wl]} {
		catch {unset tosomewhere}
	}
	foreach fnam [$listing get 0 end] {			;# Sort files into types
		if {![info exists pa($fnam,$evv(FTYP))]} {
			lappend badlist $fnam
		} else {
			set ftype $pa($fnam,$evv(FTYP))
			switch -regexp -- $ftype \
				^$evv(SNDFILE)$		  	{ lappend sndlist $fnam } \
				^$evv(ANALFILE)$ 	 	{ lappend analist $fnam } \
				^$evv(PITCHFILE)$    	{ lappend pchlist $fnam } \
				^$evv(TRANSPOSFILE)$ 	{ lappend trnlist $fnam } \
				^$evv(FORMANTFILE)$  	{ lappend fmtlist $fnam } \
				^$evv(ENVFILE)$ 	 	{ lappend envlist $fnam } \
				^$evv(PSEUDO_SND)$		{ lappend pseudo  $fnam } \
				default 			 	{ lappend txtlist $fnam }

		}
	}
	if [regexp {^[bpekmqzP]$} $typ] {				;# Sort out special types of textfiles, where necessary
		if {[info exists txtlist]} {
			foreach fnam $txtlist {
				set got 0
				switch -- $typ {
					"b" {
						if {[IsABrkfile $pa($fnam,$evv(FTYP))]} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"p" {
						if {($pa($fnam,$evv(FTYP)) != $evv(MIX_MULTI)) && ($pa($fnam,$evv(FTYP)) & $evv(IS_A_P_OR_T_BRK))} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"P" {
						if {[info exists propfiles_list] && ([lsearch $propfiles_list $fnam] >= 0)} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"e" {
						if {[IsANormdBrkfile $pa($fnam,$evv(FTYP))] \
						 || ($pa($fnam,$evv(FTYP)) & $evv(IS_A_DB_BRKFILE))} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"m" {
						set ftyp $pa($fnam,$evv(FTYP))
						if {[IsAMixfile $ftyp]} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"q" {
						set ftyp $pa($fnam,$evv(FTYP))
						if {$ftyp == $evv(MIX_MULTI)} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"k" {
						set ftyp $pa($fnam,$evv(FTYP))
						if {[IsASndlist $ftyp]} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
				}
			}
			if [info exists subtext] {
				set txtlist $subtext
			} else {
	 			catch {unset txtlist}
			}
		}
	}											;#	establish sorting order (& check if sort necessary)
	switch -- $typ {							
		"t" {
			if {![info exists sndlist] && ![info exists analist] && ![info exists pchlist] && ![info exists trnlist] \
			&& ![info exists fmtlist] && ![info exists envlist] && ![info exists pseudo]} {
				Inf "There Are No Soundsystem Files On The Workspace"
			} else {
				set sortstr saptfezT
			}
		}
		"s" {
			if {![info exists sndlist]} {
				Inf "There Are No Sound Files On The Workspace"
			} else {
				set sortstr saptfezT
			}
		}
		"T" {
			if {![info exists txtlist]} {
				Inf "There Are No Text Files On The Workspace"
			} else {
				set sortstr Tsaptfez
			}
		}
		"a" {
			if {![info exists analist]} {
				Inf "There Are No Analysis Files On The Workspace"
			} else {
				set sortstr asptfezT
			}
		}
		"f" {
			if {![info exists fmtlist]} {
				Inf "There Are No Formant Files On The Workspace"
			} else {
				set sortstr fsaptezT
			}
		}
		"p" {
			if {![info exists pchlist] && ![info exists trnlist] && ![info exists sublist]} {
				Inf "There Are No Pitch Or Transposition Files On The Workspace"
			} else {
				set sortstr ptxsafezT
			}
		}
		"e" {
			if {![info exists envlist] && ![info exists sublist]} {
				Inf "There Are No Envelope Files On The Workspace"
			} else {
				set sortstr exsaptfzT
			}
		}
		"m" {
			if {![info exists sublist]} {
				Inf "There Are No Mix Files On The Workspace"
			} else {
				set sortstr xsaptfezT
			}
		}
		"q" {
			if {![info exists sublist]} {
				Inf "There Are No Multichannel Mix Files On The Workspace"
			} else {
				set sortstr xsaptfezT
			}
		}
		"P" {
			if {![info exists sublist]} {
				Inf "There Are No Known Properties Files On The Workspace"
			} else {
				set nu_list $sublist
				foreach fnam [$listing get 0 end] {
					if {[lsearch $sublist $fnam] < 0} {
						lappend nu_list $fnam
					}
				}
				$listing delete 0 end
				foreach fnam $nu_list {
					$listing insert end $fnam
				}
			}
			return
		}
		"k" {
			if {![info exists sublist]} {
				Inf "THERE ARE NO SOUND-LISTING FILES ON THE WORKSPACE"
			} else {
				set sortstr xsaptfezT
			}
		}
		"b" {
			if {![info exists sublist]} {
				Inf "There Are No Breakpoint Files On The Workspace"
			} else {
				set sortstr xsaptfezT
			}
		}
	}
	if {![info exists sortstr]} {
		return
	}
	$listing delete 0 end

	set len [string length $sortstr]
	set i 0
	while {$i < $len} {						   	;#	Reassemble listing, sorted
		switch -- [string index $sortstr $i] {
			"s" {
				if [info exists sndlist] {
					foreach fnam [lsort -dictionary $sndlist] {
						$listing insert end $fnam
					}
				}
			}
			"z" {
				if [info exists pseudo] {
					foreach fnam [lsort -dictionary $pseudo] {
						$listing insert end $fnam
					}
				}
			}
			"a" {
				if [info exists analist] {
					foreach fnam [lsort -dictionary $analist] {
						$listing insert end $fnam
					}
				}
			}
			"p" {
				if [info exists pchlist] {
					foreach fnam [lsort -dictionary $pchlist] {
						$listing insert end $fnam
					}
				}
			}
			"t" {
				if [info exists trnlist] {
					foreach fnam [lsort -dictionary $trnlist] {
						$listing insert end $fnam
					}
				}
			}
			"f" {
				if [info exists fmtlist] {
					foreach fnam [lsort -dictionary $fmtlist] {
						$listing insert end	$fnam
					}
				}
			}
			"e" {
				if [info exists envlist] {
					foreach fnam [lsort -dictionary $envlist] {
						$listing insert end $fnam
					}
				}
			}
			"T" {
				if [info exists txtlist] {
					foreach fnam [lsort -dictionary $txtlist] {
						$listing insert end $fnam
					}
				}
			}
			"x" {
				if [info exists sublist] {
					foreach fnam [lsort -dictionary $sublist] {
						$listing insert end $fnam
					}
				}
			}
		}
		incr i
	}
	if [info exists badlist] {
		foreach fnam [lsort -dictionary $badlist] {
			$listing insert end $fnam
		}
	}
	catch {unset rememd}
}

#------ Completely clear the workspace: EXCEPT for unbakdup files

proc ClearWkspace {keepchosen} {
	global wl ch chlist pa ww total_wksp_cnt chcnt rememd evv

	if {$keepchosen && (![info exists chlist] || ([llength $chlist] <= 0))} {
		set keepchosen 0
	}
	set unbakdupfiles 0
	foreach fnam [$wl get 0 end] {					;#	Check for files that are not backed up
		set shrtname [file tail $fnam]				;#	by removing any directory path, and comparing orig
		if [string match $shrtname $fnam] {			;#	Look for filenames with NO directory part 
			set unbakdupfiles 1				
			break
		}
	}
	if {$unbakdupfiles == 1} {						;#	If unbakdup files exist,
		set tl [$wl get 0 end]						;#	Use routine which does NOT clear those files
		set listlen [llength $tl]
		incr listlen -1								;#	in reverse order, so indexing continues to work
		for {set i $listlen} {$i >= 0} {incr i -1} {
			set fnam [lindex $tl $i]
			set shrtname [file tail $fnam]			;#	remove directory path
			if {![string match $shrtname $fnam]} {	;#	Look for filenames with (non-local) directory part
				if {$keepchosen && ([LstIndx $fnam $ch] >= 0)} {
					continue						;#  if keeping chosen files, & file is on chosen list, don't remove
				}
				PurgeArray $fnam					;#	remove file from list, chlist, and pa
				RemoveFromChosenlist $fnam
				$wl delete $i
				incr total_wksp_cnt -1
			}
		}
	} elseif {$keepchosen} {						;#  No unbakdup files, but keep chosen files
		set tl [$wl get 0 end]
		set listlen [llength $tl]
		incr listlen -1
		for {set i $listlen} {$i >= 0} {incr i -1} {
			set fnam [lindex $tl $i]
			if {$keepchosen && ([LstIndx $fnam $ch] >= 0)} {
				continue							;#  if file is on chosen list, don't remove
			}
			PurgeArray $fnam
			$wl delete $i
			incr total_wksp_cnt -1
		}
	} else {										;#	If no unbakdup files & no keepchosen: remove ALL files
		$wl delete 0 end
		set total_wksp_cnt 0
		catch {unset chlist}
		set chcnt 0
		$ch delete 0 end
		catch {unset pa}
		if {[info exists evv(THUMDIR)]} {
			RestoreThumbnailProps
		}
	}
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	catch {unset rememd}
}	

#------ Save the workspace

proc SaveWorkspace {} {
	global wl fileWkspId fileChosId chlist pa evv
	if [catch {open $evv(DFLT_TMPFNAME) w} fileId] {
		Inf "Cannot Open Temporary File To Backup Workspace"
		return
	} else {
		foreach fnam [$wl get 0 end] {
			if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(PSEUDO_SND))} {
				if [catch {file delete $fnam} in] {
					Inf "Cannot Delete Pseudo_Sndfile '$fnam'"
				} else {
					DummyHistory $fnam "DESTROYED"
				}
			} else {
				lappend palist $fnam
				puts $fileId $fnam			;#	save workspace
			}
		} 
		close $fileId
	}
# JULY 2007
#	catch {close $fileWkspId}
#
	if {[info exists palist]} {
		QikLoadSave $palist
	}
	if [file exists $evv(WORKSPACE_FILE)] {
		if [catch {file delete $evv(WORKSPACE_FILE)} zorg] {
			Inf "Cannot Delete Existing Workspace File, To Write Current Workspace"
			return
		}
	}
	if [catch {file rename $evv(DFLT_TMPFNAME) $evv(WORKSPACE_FILE)}] {
		ErrShow "FAILED TO SAVE WORKSPACE"
	}

	set are_chosen 0
	if {[info exists chlist] && ([llength $chlist] > 0)} {
		if [catch {open $evv(DFLT_TMPFNAME) w} fileId] {
			Inf "Cannot Open Temporary File To Backup Chosen-Files List"
			return
		} else {
			foreach fnam $chlist {
				puts $fileId $fnam			;#	save chosen list
			} 
			close $fileId
		}
		set are_chosen 1
	}
# JULY 2007
#	catch {close $fileChosId}
#
	if [file exists $evv(CHOSEN_FILE)] {
		if [catch {file delete $evv(CHOSEN_FILE)} zorg] {
			Inf "Cannot Delete Existing Chosen-Files File, To Write Current Chosen-Files List"
			return
		}
	}
	if $are_chosen {
		if [catch {file rename $evv(DFLT_TMPFNAME) $evv(CHOSEN_FILE)}] {
			ErrShow "FAILED TO SAVE CHOSEN-FILES LIST"
		}
	}
	return
}

#------ Backup any newly made files.
#
#	These files exist in the current directory, and need to be copied to other directories.
#

proc BakupWkspace {clear} {
	global wl ch chlist wksp_dirname wstk pa evv
	global file_overwrite rememd blist_change background_listing
	global ww wksp_cnt total_wksp_cnt scores_refresh sl_real dupl_mix dupl_vbx dupl_txt main_mix nesstype nessorig

	catch {unset nessorig}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	if {!$sl_real} {
		set msg "Put The (Newly Created) Files\nInto The Directory Specified\nIn The Directory Name Box\nAt The Top Right."
		if {$clear} {
			append msg "\n\nAnd Remove Them From The Workspace."
		}
		Inf $msg
		return
	}
	set m $ww.1.b.de
	set unbakd_files 0
	set wksp_dirname [CheckDirectoryName $wksp_dirname "directory name" 1 1]

	set dirlen [string length $wksp_dirname]
	set pwd [string tolower [pwd]]
	set pwdlen [string length $pwd]
	if [string match $pwd* $wksp_dirname] {
		if {$pwdlen == $dirlen} {
			Inf "You Are Already In This Directory!!: Specify Another Directory For Backing Up"
			set wksp_dirname ""
		} else {
			incr pwdlen
			set wksp_dirname [string range $wksp_dirname $pwdlen end]
		}
	}
	ForceVal $m $wksp_dirname
	if {[string length $wksp_dirname] <= 0} {
		return
	}
	if { ![file isdirectory $wksp_dirname]} {						;#	checkout entered directoryname
		set choice [tk_messageBox -type yesno -default yes -message "Create New Directory?" \
					-icon question -parent [lindex $wstk end]]
		if [string match yes $choice] {
			if [catch {file mkdir $wksp_dirname} result] {
				Inf "Cannot Create This Directory"
				return
			} else {
				UpdateRecentDirs $wksp_dirname
			}
		} else {
			return
		}
	}
	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		if {[info exists chlist] && ([llength $chlist] > 0)} {
			set msg "Store Non-Backed-Up Items On Chosen List ??"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if [string match no $choice] {
				return
			} else {
				catch {unset ilist}
				foreach item $chlist {
					if {[string match $item [file tail $item]]} {
						lappend ilist [LstIndx $item $wl]
					}
				}
			}
			if {![info exists ilist]} {
				Inf "No Non-Backed-Up Items On Chosen Files List"	
				return
			}
			set ilist [lsort -integer -increasing $ilist]
		} else {
			Inf "No Item Selected"
			return
		}
	}
	set bakd_files 0
	Block "Backing up files"
	set blist_change 0
	set are_snds 0
	set save_mixmanage 0
	set nessupdate 0


	foreach i $ilist {			;#	Separate out all mixfiles
		set fnam [$wl get $i]
		if {[IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
			lappend mix_files $i
			lappend mix_filenames $fnam
		}
	}
	if {[info exists mix_files]} {
		foreach i $mix_files {
			set fnam [$wl get $i]
			set k [lsearch $ilist $i]
			set ilist [lreplace $ilist $k $k]
		}
	}
	foreach i [lsort -integer -decreasing $ilist] {		;#	get indices of selected files
		set fnam [$wl get $i] 							;#	get name at each index
		set shrtname [file tail $fnam]					;#	remove directory path
		if [string match $shrtname $fnam] {				;#	if file has no directory path 
														;#	it's in current directory
			set nufnam [file join $wksp_dirname $fnam]	;#	add NEW directory path to filename
														;#	attempting to bakup file, user may change name
			set nufnam [BakupFile $fnam $nufnam $wksp_dirname]
			if {[string length $nufnam] <= 0} {			;#	or even decide against it (namelen == 0)
				incr unbakd_files
			} else {
				lappend couettelist $fnam $nufnam
				UpdateBakupLog $nufnam create 1
				DummyHistory $fnam "RENAMED_$nufnam"
				if {[MixMRename $fnam $nufnam 0]} {
					set save_mixmanage 1
				} elseif {[NessMRename $fnam $nufnam 0]} {
					set nessupdate 1
				}
				$wl delete $i							
				incr wksp_cnt -1
				incr total_wksp_cnt -1
				if {!$are_snds} {
					if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
						set are_snds 1
					}
				}
				if {$clear} {
					PurgeArray $fnam
					RemoveFromChosenlist $fnam			;# if orig filename was on chosen list, remove it
					set j [LstIndx $nufnam $wl]
					if {$j >= 0} {						;# if newfilename was name of file already on wkspace
						$wl delete $j					;# remove it from wkspace
						incr wksp_cnt -1
						incr total_wksp_cnt -1
						PurgeArray $nufnam
						RemoveFromChosenlist $nufnam	;# if newfilename was on chosen list, remove it
					}
					UpdatePropfilesList $fnam $nufnam
				} else {
					if {[LstIndx $nufnam $wl] < 0} {	;#	rename listing item
						$wl insert $i $nufnam			;#	(but if already on workspace, don't add it!!)
						incr total_wksp_cnt
					}
					if {[info exists chlist]} {
						set jjj [lsearch -exact $chlist $nufnam]
						if {$jjj >= 0} {
							set chlist [lreplace $chlist $jjj $jjj]
						}
						$ch delete 0 end
						foreach ff $chlist {
							$ch insert end $ff
						}
					}
					RenameChosenFile $fnam $nufnam		;#	rename the associated data
					RenameProps $fnam $nufnam 1
					if [IsOnScore $fnam] {
						RenameOnScore $fnam $nufnam
					}
				}
				file stat $fnam filestatus
				if {$filestatus(ino) >= 0} {
					catch {close $filestatus(ino)}
				}
				if [catch {file delete $fnam} result] {	;#	delete original copy from current dir
					Inf "List Cannot Delete File '$fnam' From Current Directory"
				}										;# 	If this fails, no need to exit
				ChangeSrcName $fnam $nufnam
				incr bakd_files
				AddToDirlist $nufnam
			}
		} else {
			Inf "File '$fnam' Is Already Backed Up."
		}
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	set save_mixmanage 0
	catch {unset ilist}
	if {[info exists mix_filenames]} {						;#	BAKUP MIXFILES AFTER OTHER FILES, TO ENSURE MIX-MANAGEMENT WORKS!!
		foreach fnam $mix_filenames {
			set i [LstIndx $fnam $wl]
			lappend ilist $i
		}
		foreach i [lsort -integer -decreasing $ilist] {		;#	get indices of selected files
			set fnam [$wl get $i] 							;#	get name at each index
			set shrtname [file tail $fnam]					;#	remove directory path
			if [string match $shrtname $fnam] {				;#	if file has no directory path 
															;#	it's in current directory
				set nufnam [file join $wksp_dirname $fnam]	;#	add NEW directory path to filename
															;#	attempting to bakup file, user may change name
				set nufnam [BakupFile $fnam $nufnam $wksp_dirname]
				if {[string length $nufnam] <= 0} {			;#	or even decide against it (namelen == 0)
					incr unbakd_files
				} else {
					UpdateBakupLog $nufnam create 1
					if {[info exists main_mix(fnam)] && [string match $fnam $main_mix(fnam)]} {
						set main_mix(fnam) $nufnam
					}
					DummyHistory $fnam "RENAMED_$nufnam"
					if {[MixMRename $fnam $nufnam 0]} {
						set save_mixmanage 1
					}
					$wl delete $i							
					incr wksp_cnt -1
					incr total_wksp_cnt -1
					if {$clear} {
						PurgeArray $fnam
						RemoveFromChosenlist $fnam			;# if orig filename was on chosen list, remove it
						set j [LstIndx $nufnam $wl]
						if {$j >= 0} {						;# if newfilename was name of file already on wkspace
							$wl delete $j					;# remove it from wkspace
							incr wksp_cnt -1
							incr total_wksp_cnt -1
							PurgeArray $nufnam
							RemoveFromChosenlist $nufnam	;# if newfilename was on chosen list, remove it
						}
					} else {
						if {[LstIndx $nufnam $wl] < 0} {	;#	rename listing item
							$wl insert $i $nufnam			;#	(but if already on workspace, don't add it!!)
							incr total_wksp_cnt
						}
						if {[info exists chlist]} {
							set jjj [lsearch -exact $chlist $nufnam]
							if {$jjj >= 0} {
								set chlist [lreplace $chlist $jjj $jjj]
							}
							$ch delete 0 end
							foreach ff $chlist {
								$ch insert end $ff
							}
						}
						RenameChosenFile $fnam $nufnam		;#	rename the associated data
						RenameProps $fnam $nufnam 1
					}
					file stat $fnam filestatus
					if {$filestatus(ino) >= 0} {
						catch {close $filestatus(ino)}
					}
					if [catch {file delete $fnam} result] {	;#	delete original copy from current dir
						Inf "List Cannot Delete File $fnam From Current Directory"
					}										;# 	If this fails, no need to exit
					incr bakd_files
					AddToDirlist $nufnam
				}
			} else {
				Inf "File $fnam Is Already Backed Up."
			}
		}
	}
	UnBlock
	if {$save_mixmanage} {
		MixMStore
	}
	if {$bakd_files} {
		if {$are_snds} {
			set scores_refresh 1
		}
		if {$blist_change} {
			SaveBL $background_listing
		}
		if {$unbakd_files > 0} {
			if {$bakd_files > 1} {
				Inf "$bakd_files Files Backed Up: Not Every File Has Been Backed Up"
			} else {
				Inf "1 File Backed Up: Not Every File Has Been Backed Up"
			}
		} else {
			if {$bakd_files > 1} {
				Inf "$bakd_files Files Backed Up"
			} else {
				Inf "1 File Backed Up"
			}
			UpdateBakupDirs $wksp_dirname
 		}
		catch {unset rememd}
	} else {
		Inf "No Files Were Backed Up"
	}
	$ch delete 0 end
	if [info exists chlist] {
		foreach fnam $chlist {
			$ch insert end $fnam
		}
	}
	ForceVal $ww.1.a.endd.l.cnts.new $wksp_cnt
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	ReMarkWkspaceCount
}

#------ Copy an existing current-directory file into a new location: return the newname (no extension)

proc BakupFile {fnam nufnam dirname} {
	global file_overwrite zebedee wstk blist_change scores_refresh pa evv

	set file_overwrite 0
	set file_write_complete 0
	set haspmark [HasPmark $fnam]
	set hasmmark [HasMmark $fnam]
	set ftyp $pa($fnam,$evv(FTYP))
	if [catch {file copy $fnam $nufnam} k ] {	;#	attempt to write file, overwrite disallowed
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] \
			-message "If Disk Is Not Full, File '$nufnam' Already Exists : Overwrite It ?"]
		if {$choice == "yes"} {
			if [catch {file copy -force $fnam $nufnam}] { 
				Inf "Cannot Overwrite Existing File"
			} else {
				DataManage rename $fnam $nufnam
				UpdateBakupLog $nufnam modify 1
				DummyHistory $nufnam "OVERWRITTEN"
				if {$haspmark} {
					MovePmark $fnam $nufnam
				}
				if {$hasmmark} {
					MoveMmark $fnam $nufnam
				}
				if [IsInBlists $nufnam] {
					set msg "The Overwritten File '$nufnam' Was Mentioned In Background Listings\n\nRemove Those Mentions ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						if [RemoveFromBLists $nufnam] {
							set blist_change 1
						}
					}
				}
				if [IsOnScore $nufnam] {
					set msg "The Overwritten File '$nufnam' Was In Use In The Current Score\n\nRemove It ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						RemoveFromScore $nufnam
						set scores_refresh 1
					}
				} elseif {$ftyp == $evv(SNDFILE)} {
					set scores_refresh 1
				}

				set file_overwrite 1
				return $nufnam
			}
		}
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] \
			-message "Choose A New Name ?"]
		if {$choice == "no"} {
			return ""
		}
		set file_rename_valid 0
		while {$file_rename_valid == 0} {
			set fextens [file extension $nufnam]
			set newname [file rootname [file tail $nufnam]]
			set thisnewname [Dlg_Rootname_Change $newname 0]
			set newname $thisnewname
			set nufnam [file join $dirname $newname$fextens]
			if {$zebedee <= 0} {									;#	"Skip" pressed
				return ""
			} elseif {[string length $nufnam] > 0} {
				if [catch {file copy $fnam $nufnam}] { 
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] \
						-message "If Disk Is Not Full, File '$nufnam' Already Exists : Overwrite It ?"]
					if {$choice == "yes"} {
						if [catch {file copy -force $fnam $nufnam}] { 
							Inf "Cannot Overwrite Existing File"
						} else {
							DataManage rename $fnam $nufnam
							UpdateBakupLog $nufnam modify 1
							DummyHistory $nufnam "OVERWRITTEN"
							set file_overwrite 1
							set file_rename_valid 1
							if [IsInBlists $nufnam] {
								set msg "The Overwritten File '$nufnam' Was Mentioned In Background Listings\n\nRemove Those Mentions ??"
								set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
								if {$choice == "yes"} {
									if [RemoveFromBLists $nufnam] {
										set blist_change 1
									}
								}
							}
							if [IsOnScore $nufnam] {
								set msg "The Overwritten File '$nufnam' Was In Use In The Current Score\n\nRemove It ??"
								set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
								if {$choice == "yes"} {
									RemoveFromScore $nufnam
									set scores_refresh 1
								}
							} elseif {$ftyp == $evv(SNDFILE)} {
								set scores_refresh 1
							}
						}
					} 
				} else {
					set file_rename_valid 1
				}
			}
		}
	} else {
		DataManage rename $fnam $nufnam
		UpdateBakupLog $nufnam create 1
	}
	if {$haspmark} {
		MovePmark $fnam $nufnam
	}
	if {$hasmmark} {
		MoveMmark $fnam $nufnam
	}
	return $nufnam
}

#------ Dialog box to deal with cases where filename already exists, or is invalid, or is to be renamed
#
#						NEW FILENAME
#
#			New Filename || File Exists || Invalid Filename
#
#		SKIP	OVERWRITE	 RENAME	   newname ______________
#
#	DANGER: does this really work (not convinced it grabs focus!!)
#

proc Dlg_Rootname_Change {filerootname matchOK} {
	global  pr_newrootname zebedee file_overwrite renamefile nu_names ins chlist sysname evv

	set renamefile(result) $filerootname
	set f .renamefile

	if [catch {eval {toplevel $f} -borderwidth $evv(SBDR)} zorg] {
		Inf $zorg
	}
	wm title $f "Rename File"
	wm protocol $f WM_DELETE_WINDOW PreventExit
	wm resizable $f 1 1

	switch -- $file_overwrite {
		1  { message $f.msg -text "File Exists: overwrite it ?" -aspect 1000 }
		0  { message $f.msg -text "New Filename"     -aspect 1000 }
	}
	set b [frame $f.buttons]
	set bo [frame $f.other]
	label $bo.laba -text "Recent Names"
	Scrolled_Listbox $bo.lbox -height $evv(NSTORLEN) -selectmode single
	label $bo.labb -text "Recent Source Names"
	Scrolled_Listbox $bo.lboxb -height $evv(NSTORLEN) -selectmode single -height 3
	label $bo.bbb -text "standard names"
	set ku [frame $bo.bbbb]
	button $ku.bb1 -text "$sysname(1)" -command "PutName .renamefile.buttons.entry $sysname(1)" -highlightbackground [option get . background {}]
	button $ku.bb2 -text "$sysname(2)" -command "PutName .renamefile.buttons.entry $sysname(2)" -highlightbackground [option get . background {}]
	button $ku.bb3 -text "$sysname(3)" -command "PutName .renamefile.buttons.entry $sysname(3)" -highlightbackground [option get . background {}]
	button $ku.bb4 -text "$sysname(4)" -command "PutName .renamefile.buttons.entry $sysname(4)" -highlightbackground [option get . background {}]
	button $ku.bb5 -text "$sysname(5)" -command "PutName .renamefile.buttons.entry $sysname(5)" -highlightbackground [option get . background {}]
	bind $bo.lbox.list <ButtonRelease-1> "NameListChoose $bo.lbox.list .renamefile.buttons.entry"
	bind $bo.lboxb.list <ButtonRelease-1> "NameListChoose $bo.lboxb.list .renamefile.buttons.entry"
	pack $bo.bbb $bo.bbbb -side top -pady 1
	pack $ku.bb1 $ku.bb2 $ku.bb3 $ku.bb4 $ku.bb5 -side left -padx 1
	pack $bo.labb $bo.lboxb $bo.laba $bo.lbox -side top -fill x
	if [info exists nu_names] { 
		$bo.lbox.list delete 0 end
		foreach nname $nu_names {	;#	Post recent names
			$bo.lbox.list insert end $nname
		}
		$bo.lbox.list xview moveto 0.0	
	}
	$bo.lboxb.list delete 0 end
	$bo.lboxb.list xview moveto 0.0	

	if {[info exists ins(chlist)] && ([llength $ins(chlist)] > 0)} {
		set thisl $ins(chlist)
	} elseif {[info exists chlist] && ([llength $chlist] > 0)} {
		set thisl $chlist
	}
	if [info exists thisl] {
		set i 0
		foreach nname $thisl {	;#	Post source names
			$bo.lboxb.list insert end [file rootname $nname]
			incr i
			if {$i >= 2} {
				break
			}
		}					
	}
	pack $f.msg $f.buttons $f.other -side top -fill x
	button $b.skip   -text Skip      	  -command "set pr_newrootname 0" -highlightbackground [option get . background {}]
	button $b.aban   -text Exit      	  -command "set pr_newrootname -1" -highlightbackground [option get . background {}]
	switch -- $file_overwrite {
		1 {
			button $b.zz -text Overwrite  -command "set pr_newrootname 1" -highlightbackground [option get . background {}]
		}
		0 {
			button $b.zz -text Rename 	  -command "set pr_newrootname 1" -highlightbackground [option get . background {}]
		}
	}
	label $b.lab	 -text newname
	entry  $b.entry  -width 20 -textvariable renamefile(result)
	pack $b.aban $b.skip -side left
	pack $b.zz $b.lab $b.entry -side right -fill x

	bind $b.entry <Return> "set pr_newrootname 1"
	bind $b.entry <Escape> "set pr_newrootname -1"
	bind .renamefile <ButtonRelease-1> {RaiseWindow %W %x %y}

	set pr_newrootname 0
	set finished 0

	bind .renamefile.buttons.entry  <Up> "AdvanceNameIndex 1 renamefile(result) 0"
	bind .renamefile.buttons.entry  <Down> "AdvanceNameIndex 0 renamefile(result) 0"
	bind .renamefile.buttons.entry  <Control-Up> "AdvanceNameIndex 1 renamefile(result) 1"
	bind .renamefile.buttons.entry  <Control-Down> "AdvanceNameIndex 0 renamefile(result) 1"
	raise $f
	.renamefile.buttons.entry icursor end
	Simple_Grab 0 $f pr_newrootname $f.buttons.entry

	while {$finished == 0} {
		focus -force $f
		tkwait variable pr_newrootname								;#	wait for variable to be set
		if {$pr_newrootname <= 0} {
			break
		}
#JUNE 30 UC-LC FIX
		set renamefile(result) [string tolower $renamefile(result)]
		set renamefile(result) [FixTxt $renamefile(result) "new filename"]
		if {[string length $renamefile(result)] <= 0} {
			continue
		}
		if {!$file_overwrite && [string match $renamefile(result) $filerootname]} {
			if {!$matchOK} {
				continue
			}
		}
		ForceVal $b.entry $renamefile(result)
	 	if {[ValidCdpFilename $renamefile(result) 1] != 0} {
			set finished 1
		}
	}
	Simple_Release_to_Dialog $f										;#	Return focus to calling dialog
	set zebedee $pr_newrootname
	destroy $f														;#	and destroy dialogbox
	if {$zebedee > 0} {
		return $renamefile(result)

	} else {
		set file_overwrite 0
		return ""
	}
}

#------ Rename a file in the chlist

proc RenameChosenFile {fnam newname} {
	global chlist
	set i 0
	if [info exists chlist] {
		foreach fnm $chlist {
			if [string match $fnm $fnam] {						;#	if the original filename is in chlist
				set chlist "[lreplace $chlist $i $i $newname]"	;#	replace it by new name
				return											;#	and quit
			}
			incr i	
		}
	}
}

#------ Rename properties in pa, and update other data stores of named files

proc RenameProps {fnam newname existing} {
	global pa last_mix last_outfile evv
	set propno 0

	while {$propno < ($evv(CDP_PROPS_CNT) + $evv(CDP_MAXSAMP_CNT))} {
		if {[info exists pa($fnam,$propno)]} {
			set pa($newname,$propno) $pa($fnam,$propno)
			unset pa($fnam,$propno)
		}
		incr propno
	}
	if {$existing} {
		if {[info exists last_mix] && [string match $fnam $last_mix]} {
			set last_mix $newname
		}
		if {[info exists last_outfile]} {
			set ii [lsearch -exact $last_outfile $fnam]
			if {$ii >= 0} {
				set last_outfile [lreplace $last_outfile $ii $ii $newname]
			}
		}
	 	ChangeSrcName $fnam $newname			;#	If file has a src-list, or is in src-list for some other file
												;#	alter these entries
		set ftyp $pa($newname,$evv(FTYP))
		if {$ftyp & $evv(IS_A_TEXTFILE)} {
			UpdatePropfilesList $fnam $newname
		}
	}
}

#------ Get files from specified directory onto the workspace Directory Listing

proc GetFilesToSrcDirListing {m dirframe} {
	global wksp_dirname ww evv wl

	set ilist [$wl curselection]
	if {[info exists ilist] && (([llength $ilist] <= 0) || ([lindex $ilist 0] == -1))} {
		unset ilist
	}
	set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
	if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
	 	return
	}
	set dirlen [string length $dirname]
	set pwd [string tolower [pwd]]
	set pwdlen [string length $pwd]
	if [string match $pwd* $dirname] {
		if {$pwdlen == $dirlen} {
			set dirname ""
		} else {
			incr pwdlen
			set dirname [string range $dirname $pwdlen end]
		}
	}
	ForceVal $m $dirname
	$ww.1.b.buttons2.lis config -bg [option get . background {}]
	if {[string length $dirname] <= 0} {
		Dlg_Showdir $dirname $dirframe 1				;#	Displays workspace directory,
	} elseif [file isdirectory $dirname] {
		UpdateRecentDirs $dirname
		Dlg_Showdir $dirname $dirframe 0				;#	Displays named directory,
														;#	and allows files to be transferred to workspace
	} else {
		Inf "Directory Does Not Exist"
	}
	if {[info exists ilist]} {
		$wl selection clear 0 end
		foreach i $ilist {
			$wl selection set $i
		}
	}
}

#------ Reset Working srate

proc ResetSrate {srate f} {
	global evv
	set evv(DFLT_SR) $srate 
	if {$srate <= 0} {
		$f config -text "ALL Srates"
	} else {
		$f config -text "(Srate $evv(DFLT_SR) only)"
	}
}

#------ Rename workspace files that are cursor-selected

proc RenameWkspaceFiles {} {
	global wl ch zebedee file_overwrite origrootname chlist evv
	global pa chcnt rememd background_listing wstk scores_refresh sl_real dupl_mix dupl_vbx dupl_txt nesstype nessorig

	catch {unset nessorig}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	if {!$sl_real} {
		Inf "Selected Files On The Workspace Can Be Renamed"
		return
	}
	set ren_blist 0
	set file_overwrite 0
	set ilist [$wl curselection]								;#	get indices of selected files in reverse order
	if {[llength $ilist] <= 0} {								;#	so that deletiones, substitutions, don't mess up
		Inf "No Item Selected"
		return
	}
	set oilist $ilist
	set save_mixmanage 0
	set nessupdate 0
	set are_snds 0
	set ilist [lsort -integer -decreasing $ilist]
	set ilistlen [llength $ilist]
	set kk 0
	while {$kk < $ilistlen} {
		set i [lindex $ilist $kk]
		set fnam [$wl get $i]									;#	get filename at index
		set is_snd 0
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set is_snd 1
		}
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]
		set file_overwrite 0									;#	Default dialog caption for next file
		set fextens	 [file extension $fnam]
		set thisname [file tail $fnam]
		if [string match $thisname $fnam] {
			set dirname ""
		} else {
			set dirname [file dirname $fnam]
		}
		set thisrootname [file rootname $thisname]
		set origrootname $thisrootname
		set is_completed 0
		while {!$is_completed} {
			set newrootname [Dlg_Rootname_Change $thisrootname 0]
			set	nufnam [file join $dirname $newrootname$fextens]
			set oldname_pos_on_chosen [LstIndx $fnam $ch]
			if {$file_overwrite} {
				set OK 1
				set newname_pos_on_wkspce [LstIndx $nufnam $wl]
				set newname_pos_on_chosen [LstIndx $nufnam $ch]
				if {$newname_pos_on_wkspce >= 0} {									;#	If new filename was already on workspace
					foreach indx $ilist {				
						if {$newname_pos_on_wkspce == $indx} {
							Inf "You Cannot Overwrite A Cursor-Selected File."
							set thisrootname $origrootname 
							set file_overwrite 0
							set OK 0
							break
						}
					}
					if {!$OK} {							
						continue
					}
				}
				if {[info exists nesstype($nufnam)]} {
					set nessorig $nesstype($nufnam)
				}
				if [catch {file rename -force $fnam $nufnam} zorg] { ;#	Force existing file to be OVERWRITTEN
					Inf "Cannot Remove Existing Workspace File '$nufnam'"
					set thisrootname $newrootname							 	;#	retain failed name in entry box
					set file_overwrite 0
					continue
				} else {
					DataManage rename $fnam $nufnam
					lappend couettelist $fnam $nufnam
					UpdateBakupLog $fnam delete 0
					UpdateBakupLog $nufnam modify 1
					CheckMainmix $fnam $nufnam
					CheckMainmixSnd $fnam $nufnam
					DummyHistory $nufnam "OVERWRITTEN"
					AddNameToNameslist [file tail $nufnam] 0
					if [IsInBlists $nufnam] {
						set msg "The Overwritten File '$nufnam' Was Mentioned In Background Listings\n\nRemove Those Mentions ??"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							if [RemoveFromBLists $nufnam] {
								set ren_blist 1
							}
						}
					}
					if [IsOnScore $nufnam] {
						set msg "The Overwritten File '$nufnam' Is In Use On Current Score\n\nRemove It ??"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							RemoveFromScore $nufnam
							set scores_refresh 1
						}
					} elseif {$is_snd} {
						set scores_refresh 1
					}
				}
				if {$newname_pos_on_wkspce >= 0} {				;#	If new filename was already on workspace
					$wl delete $i								;#	Just delete old filename from workspace
					set kkk 0
					while {$kkk < $ilistlen} {
						set ki [lindex $ilist $kkk]
						if {$ki == $i} {						;# remove deleted item from list of wkspace indeces we're dealing with
							set ilist [lreplace $ilist $kkk $kkk]	
							incr ilistlen -1					;# shorten length of list-of-wkspace-indices
							incr kkk -1							;# decrement counter in this loop, which is stepping thro list if wkspace indeces
							incr kk -1							;# decrement counter in outer loop, which is also stepping thro .....
						} elseif {$ki > $i} {
							incr ki -1							;# any wkspace index higher than deleted item gets decremented by 1
							set ilist [lreplace $ilist $kkk $kkk $ki]
						}
						incr kkk	
					}
																;#	(Later rename props of old to newname)
					WkspCnt $nufnam -1							;# 	File overwritten, but origname file disappears!
					set k [LstIndx $nufnam $wl]
					$wl delete $k
					$wl insert $i $nufnam
					UpdateChosenFileMemory $fnam $nufnam
					if {$oldname_pos_on_chosen >= 0} {
						if {$newname_pos_on_chosen >= 0} {			
							RemoveFromChosenlist $nufnam
							set oldname_pos_on_chosen [LstIndx $fnam $ch]
						}
						RemoveFromChosenlist $fnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $nufnam
					} elseif {$newname_pos_on_chosen >= 0} {			
						RemoveFromChosenlist $nufnam
					}
				} else {
					$wl delete $i								
					$wl insert $i $nufnam					;#	rename workspace item
					UpdateChosenFileMemory $fnam $nufnam
					if {$oldname_pos_on_chosen >= 0} {
						RemoveFromChosenlist $fnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $nufnam
					}
				}												;#	Rename props,
				RenameProps	$fnam $nufnam 1				;#	thus deleting props of any overwritten file
				DummyHistory $fnam "RENAMED_$nufnam"
				if {[MixMRename $fnam $nufnam 0]} {
					set save_mixmanage 1
				} elseif {[NessMRename $fnam $nufnam 0]} {
					set nessupdate 1
				}
				if {$haspmark} {
					MovePmark $fnam $nufnam
				}
				if {$hasmmark} {
					MoveMmark $fnam $nufnam
				}
				if [IsInBlists $fnam] {
					if [RenameInBlists $fnam $nufnam] {
						set ren_blist 1
					}
				}
				if [IsOnScore $fnam] {
					RenameOnScore $fnam $nufnam
				}
				if {$is_snd} {
					set are_snds 1
				}
				AddNameToNameslist [file tail $nufnam] 0
				set file_overwrite 0
			} elseif {$zebedee <= 0} {					;# renaming of file was SKIPPED						
				set OK 1
				set is_completed 1
			} else {
				set OK 1
				if [catch {file rename $fnam $nufnam} k] {	
					if {[string length [file rootname [file tail $fnam]]] == 8 \
					|| [string length [file rootname [file tail $nufnam]]] == 8} {
						Inf "Tk/Tcl May Give An Anomalous 'Overwrite' Request With 8 Character Names\nIf In Doubt, Check Whether An Overwrite Will Truly Happen!!"
					}
					set thisrootname $newrootname					;#	retain failed name in entry box
					set file_overwrite 1
					continue
				} else {						  					;#	Valid name, and file doesn't exist
					DataManage rename $fnam $nufnam
					lappend couettelist $fnam $nufnam
					UpdateBakupLog $fnam delete 0
					UpdateBakupLog $nufnam create 1
					CheckMainmix $fnam $nufnam
					CheckMainmixSnd $fnam $nufnam
					$wl delete $i								
					$wl insert $i $nufnam						;#	rename workspace item
					if {$haspmark} {
						MovePmark $fnam $nufnam
					}
					if {$hasmmark} {
						MoveMmark $fnam $nufnam
					}
					if [IsInBlists $fnam] {
						if [RenameInBlists $fnam $nufnam] {
							set ren_blist 1
						}
					}
					if [IsOnScore $fnam] {
						RenameOnScore $fnam $nufnam
					}
					if {$is_snd} {
						set are_snds 1
					}
					UpdateChosenFileMemory $fnam $nufnam
					if {$oldname_pos_on_chosen >= 0} {
						RemoveFromChosenlist $fnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $nufnam
					}
					RenameProps	$fnam $nufnam 1				;#	rename props
					DummyHistory $fnam "RENAMED_$nufnam"
					if {[MixMRename $fnam $nufnam 0]} {
						set save_mixmanage 1
					} elseif {[NessMRename $fnam $nufnam 0]} {
						set nessupdate 1
					}
					AddNameToNameslist [file tail $nufnam] 0
					RenameOnDirlist $fnam $nufnam
				}
			}
			set is_completed 1												;#	Go on to next selected file
		}
		if {$zebedee < 0} {
			break
		}
		incr kk
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}		
	if {$are_snds} {
		set scores_refresh 1
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	foreach i $oilist {
		$wl selection set $i
	}
	catch {unset rememd}
}

#------ Display properties of cursor-selected files on workspace

proc Show_Props {where what} {
	global pr_showprops wl chlist pa fileprops_page fprops_display evv 
	global wl remlist ins_file_lst nfm_fll ins sl_real mu testzog4 origmixbak

	if {!$sl_real} {
		switch -- $where {
			workspace 	 	{ set dum "THE FILES SELECTED ON THE WORKSPACE" }
			ch 			 	{ set dum "THE FILES IN THE CHOSEN FILES LIST"	}
			ins_file_lst -
			newfile_for_ins { set dum "THE FILES IN THE CHOSEN FILES LIST FOR AN INSTRUMENT" }
			from_parampage 	{ set dum " THE OUTPUT FILE(S)" }
			inputfile_props { set dum " THE INPUT FILE(S)"  }
		}
		switch -- $what {
			chans	{ set da "CHANNEL COUNT"	}
			dur		{ set da "DURATIONS"	}
			winlen	{ set da "ANALYSIS-WINDOW LENGTH"	}
			maxsamp	{ set da "MAXIMUM SAMPLE VALUE"	}
			default	{ set da "PROPERTIES"	}
		}
		Inf "The Soundloom Displays A List Of The $da\nOF $dum"
		return
	}
	switch -- $where {
		workspace {
			set remlist [$wl curselection]
			if {[llength $remlist] <= 0} {
				Inf "No Items Selected"
				return
			}
			foreach i $remlist {
				set fnam [$wl get $i]
				if {$what == "durdif"} {
					set ftype $pa($fnam,$evv(FTYP))
					if { ($ftype != $evv(SNDFILE)) \
					&&   ($ftype != $evv(PSEUDO_SND)) \
					&&   ($ftype != $evv(ANALFILE)) \
					&&   ($ftype != $evv(PITCHFILE)) \
					&&   ($ftype != $evv(TRANSPOSFILE)) \
					&&   ($ftype != $evv(FORMANTFILE)) \
					&&   ($ftype != $evv(ENVFILE)) \
					&&   (!($ftype & $evv(IS_A_BRKFILE))) \
					&&   ![IsAMixfileIncludingMultichan $ftype]} {
						Inf "This Option Only Works With Files Which Have A Duration"
						return
					}
				} elseif {$what == "dursum"} {
					if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
						Inf "This Option Only Works With Sound Files"
						return
					}
				}
				lappend tl $fnam $pa($fnam,$evv(FTYP))
				if {[info exists testzog4] && $testzog4} {
					break
				}
			}
			if {($what == "durdif") && ([llength $remlist] != 2)} {
				Inf "This Option Only Works With Two Files"
				return
			}
		}
		processpage -
		ch {
			if {![info exists chlist]} {
				return
			}
			set nulist [RemoveDupls $chlist]
			foreach fnam $nulist {
				lappend tl $fnam $pa($fnam,$evv(FTYP))
			}
		}
		ins_file_lst {
			if {![info exists ins_file_lst]} {
				return
			}
			foreach fnam [$ins_file_lst get 0 end] {
				lappend tl $fnam $pa($fnam,$evv(FTYP))
			}
			if {![info exists tl]} {
				return
			}
		}
		newfile_for_ins {
			set remlist [$nfm_fll curselection]
			if {[llength $remlist] <= 0} {
				return
			}
			foreach i $remlist {
				set fnam [$nfm_fll get $i]
				lappend tl $fnam $pa($fnam,$evv(FTYP))
			}
		}
		from_parampage {
			set i 0
			set z_thislist ""
			while {$i < 2} {
				switch -- $i {
					"0" {set outfname $evv(DFLT_OUTNAME) }
					"1" {set outfname $evv(MACH_OUTFNAME) }
				}
				set z_thislist [concat $z_thislist [glob -nocomplain "$outfname*"]]
				incr i
			}
			foreach otherfnam [glob -nocomplain "$evv(DFLT_OUTNAME)00*"] {	;#	Exclude temporary thumbnails etc, from list
				lappend otherfnams $otherfnam
			}
			if {[info exists otherfnams]} {
				foreach otherfnam $otherfnams {
					set kk [lsearch $z_thislist $otherfnam]
					if {$kk >= 0} {
						set z_thislist [lreplace $z_thislist $kk $kk]
					}
				}
			}
			foreach fnam $z_thislist {
				lappend tl $fnam $pa($fnam,$evv(FTYP))
			}
			if {![info exists tl]} {
				Inf "No Output Files Exist"
				return
			}
		}
		inputfile_props {
			if {$ins(create)} {
				if [info exists ins(chlist)] {
					foreach fnam $ins(chlist) {
						lappend tl $fnam $pa($fnam,$evv(FTYP))
					}
				}
			} else {
				if [info exists chlist] {
					set nulist [RemoveDupls $chlist]
					foreach fnam $nulist {
						lappend tl $fnam $pa($fnam,$evv(FTYP))
					}
				}
			}
			if {![info exists tl]} {
				return
			}
			if {(($what == "maxsamp") || ($what == "dur")) && ([llength $tl] == 2)} {
				set fnam [lindex $tl 0]
				set ftyp [lindex $tl 1]
				if {[IsAMixfileIncludingMultichan $ftyp]} {
					if [catch {open $fnam "r"} fId] {
						Inf "Cannot Open Mixfile To Get Data On Soundfiles It Uses."
					} else {
						if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
							set multichan 1
							set gotoutch 0
						} else {
							set multichan 0
						}
					 	set OK 0
						while {[gets $fId line] >= 0} {			;#	Look inside mixfile
							set line [split $line]
							set item [lindex $line 0]
							if [string length $item] {
								if {![string match \;* $item]} {
									if {$multichan && !$gotoutch} {
										set gotoutch 1
										continue
									}
									set item [string tolower $item]
									set item [RegulariseDirectoryRepresentation $item]
									set ftype [FindFileType $item]
									if {$ftype == $evv(SNDFILE)} {
										if {[LstIndx $item $wl] < 0} {
											lappend badfiles $item
										} else {
											lappend tl $item $ftype
										}
									}
								}
							}
						}
						close $fId
						if {($what == "maxsamp") && [llength $tl] > 2} {
							set tl [lrange $tl 2 end]
						}
					}
				} elseif {!($ftyp & $evv(IS_A_SNDSYSTEM_FILE))} {
					Inf "This Is Not A Sound-System File"					
					return
				}
			}
		}
	}
	if {$what == "winlen"} {
		foreach {fnam ftype} $tl {
			if { ($ftype == $evv(ANALFILE)) \
			||   ($ftype == $evv(PITCHFILE)) \
			||   ($ftype == $evv(TRANSPOSFILE)) \
			||   ($ftype == $evv(FORMANTFILE)) \
			||   ($ftype == $evv(ENVFILE)) } {
				lappend nutl $fnam
			}
		}
		if {![info exists nutl]} {
			Inf "No Analysis, Pitch, Formant Or Binary Envelope Files Selected."
			return
		}
	}
	if {[info exists badfiles]} {
		set msg "The Following Files Are Not On The Workspace: Do Not Know Their Properties\n\n"
		set cnt 0
		foreach item $badfiles {
			incr cnt
			if {$cnt > 20} {
				append msg "\n\nAnd More"
				break
			}
			append msg $item "  "
		}
		Inf $msg
	}
	if {[info exists testzog4] && $testzog4} {
		set msg "PROPERTIES OF FILE $fnam"
		switch -regexp -- $pa($fnam,$evv(FTYP)) \
			^$evv(SNDFILE)$	 {
				append msg  "\nFTYPE ....... SOUND FILE"
			} \
			^$evv(PSEUDO_SND)$	{
				append msg  "\nFTYPE ....... PSEUDO_SNDFILE"
			} \
			^$evv(ANALFILE)$	{
				append msg  "\nFTYPE ....... ANALYSIS FILE"
			} \
			^$evv(PITCHFILE)$	{
				append msg  "\nFTYPE ....... BINARY PITCH FILE"
			} \
			^$evv(TRANSPOSFILE)$	{
				append msg  "\nFTYPE ....... BINARY TRANSPOSITION DATA FILE"
			} \
			^$evv(FORMANTFILE)$	{
				append msg  "\nFTYPE ....... BINARY FORMANT FILE"
			} \
			^$evv(ENVFILE)$	{
				append msg  "\nFTYPE ....... BINARY ENVELOPE FILE"
			} \
			^$evv(MIX_MULTI)$	{
				append msg  "\nFTYPE ....... MULTICHANNEL MIXFILE"
			} \
			default {
				append msg  "\nFTYPE ....... TEXTFILE ($pa($fnam,$evv(FTYP)))"
			}

		append msg  "\nFSIZE ....... $pa($fnam,$evv(FSIZ))"
		append msg  "\nINSAMS ....... $pa($fnam,$evv(INSAMS))        SRATE ....... $pa($fnam,$evv(SRATE))"
		append msg  "\nCHANS ....... $pa($fnam,$evv(CHANS))        WANTED ....... $pa($fnam,$evv(WANTED))"
		append msg  "\nWLENGTH ....... $pa($fnam,$evv(WLENGTH))        LINECNT ....... $pa($fnam,$evv(LINECNT))"
		append msg  "\nARATE ....... $pa($fnam,$evv(ARATE))        FRAMETIME ....... $pa($fnam,$evv(FRAMETIME))"
		append msg  "\nNYQUIST ....... $pa($fnam,$evv(NYQUIST))        DUR ....... $pa($fnam,$evv(DUR))"
		append msg  "\nSTYPE ....... $pa($fnam,$evv(STYPE))        ORIGSTYPE ....... $pa($fnam,$evv(ORIGSTYPE))"
		append msg  "\nORIGRATE ....... $pa($fnam,$evv(ORIGRATE))        MLEN ....... $pa($fnam,$evv(MLEN))"
		append msg  "\nDFAC ....... $pa($fnam,$evv(DFAC))        ORIGCHANS ....... $pa($fnam,$evv(ORIGCHANS))"
		append msg  "\nSPECENVCNT ....... $pa($fnam,$evv(SPECENVCNT))        OUT_CHANS ....... $pa($fnam,$evv(OUT_CHANS))"
		append msg  "\nDESCRIPTOR_BYTES ....... $pa($fnam,$evv(DESCRIPTOR_BYTES))        IS_TRANSPOS ....... $pa($fnam,$evv(IS_TRANSPOS))"
		append msg  "\nCOULD_BE_TRANSPOS ....... $pa($fnam,$evv(COULD_BE_TRANSPOS))        COULD_BE_PITCH ....... $pa($fnam,$evv(COULD_BE_PITCH))"
		append msg  "\nDIFFERENT_SRATES ....... $pa($fnam,$evv(DIFFERENT_SRATES))        DUPLICATE_SNDS ....... $pa($fnam,$evv(DUPLICATE_SNDS))"
		append msg  "\nBRKSIZE ....... $pa($fnam,$evv(BRKSIZE))        NUMSIZE ....... $pa($fnam,$evv(NUMSIZE))"
		append msg  "\nALL_WORDS ....... $pa($fnam,$evv(ALL_WORDS))        WINDOW_SIZE ....... $pa($fnam,$evv(WINDOW_SIZE))"
		append msg  "\nMINBRK ....... $pa($fnam,$evv(MINBRK))        MAXBRK ....... $pa($fnam,$evv(MAXBRK))"
		append msg  "\nMINNUM ....... $pa($fnam,$evv(MINNUM))        MAXNUM ....... $pa($fnam,$evv(MAXNUM))"
		if {[info exists pa($fnam,$evv(MAXSAMP))]} {
			append msg  "\nMAXSAMP ....... $pa($fnam,$evv(MAXSAMP))"
		} else {
			append msg  "\nMAXSAMP ....... Unknown"
		}
		if {[info exists pa($fnam,$evv(MAXLOC))]} {
			append msg  "\nMAXLOC ....... $pa($fnam,$evv(MAXLOC))"
		} else {
			append msg  "\nMAXLOC ....... Unknown"
		}
		if {[info exists pa($fnam,$evv(MAXREP))]} {
			append msg  "\nMAXREP ....... $pa($fnam,$evv(MAXREP))"
		} else {
			append msg  "\nMAXREP ....... Unknown"
		}
		Inf $msg
		return
	}
	if {$what == "dursum"} {
		set dur_sum 0.0
		foreach {zfnam typ} $tl {
			set dur_sum [expr $dur_sum + $pa($zfnam,$evv(DUR))]
		}
		set mins [expr int(floor($dur_sum/60.0))]
		set secs [expr $dur_sum - ($mins * 60)]
		set hrs [expr int(floor($mins/60))]
		set mins [expr $mins - ($hrs * 60)]
		set msgttt "Total Duration = $dur_sum secs"
		if {$mins > 60} {
			append msgttt " = $hrs hrs $mins mins $secs secs"
		} elseif {$mins > 0} {
			append msgttt " = $mins mins $secs secs"
		}
		Inf $msgttt
		return
	}
	set f .fileprops_page

	if [Dlg_Create $f "File Properties" "set pr_showprops 1" -borderwidth $evv(SBDR)] {
		set b [frame $f.buttons -borderwidth $evv(SBDR)]
		set fprops_display [Scrolled_Listbox $f.props -width 44 -height 20]
		pack $f.buttons $f.props -side top -fill x
		button $b.ok -text Close -command {set pr_showprops 1} -highlightbackground [option get . background {}]
		button $b.tref -text "Keep Value" -command PropAsRef -width 18 -highlightbackground [option get . background {}]
		entry $b.e -textvariable ref(text) -width 32 -state disabled -bd 0
		pack $b.tref $b.e -side left

		pack $b.ok -side right
		bind .fileprops_page <ButtonRelease-1> {HideWindow %W %x %y pr_showprops}
		wm resizable $f 1 1
		bind $f <Return> {set pr_showprops 1}
		bind $f <Escape> {set pr_showprops 1}
		bind $f <Key-space> {set pr_showprops 1}
	}
	$fprops_display delete 0 end
	set pr_showprops 0

	switch -- $what {
		"chans" {
			$f.buttons.tref config -text "" -command {} -bd 0
			wm title $f "FILE CHANNEL COUNT"
			foreach {fnam ftype} $tl {
				if { ($ftype == $evv(SNDFILE)) \
				||   ($ftype == $evv(PSEUDO_SND)) \
				||   ($ftype == $evv(ANALFILE)) \
				||   ($ftype == $evv(PITCHFILE)) \
				||   ($ftype == $evv(TRANSPOSFILE)) \
				||   ($ftype == $evv(FORMANTFILE)) \
				||   ($ftype == $evv(ENVFILE)) } {
					$fprops_display insert end "$pa($fnam,$evv(CHANS))        $fnam"
				} elseif {[IsAMixfileIncludingMultichan $ftype]} {
					$fprops_display insert end "$pa($fnam,$evv(OUT_CHANS))        $fnam"
				} else {
					$fprops_display insert end "-------------        $fnam"
				}
			}
		}
		"dur" {
			$f.buttons.tref config -text "Hrs:Mins:Secs" -command {DurConv} -bd 2
			wm title $f "FILE DURATION"
			foreach {fnam ftype} $tl {
				if { ($ftype == $evv(SNDFILE)) \
				||   ($ftype == $evv(PSEUDO_SND)) \
				||   ($ftype == $evv(ANALFILE)) \
				||   ($ftype == $evv(PITCHFILE)) \
				||   ($ftype == $evv(TRANSPOSFILE)) \
				||   ($ftype == $evv(FORMANTFILE)) \
				||   ($ftype == $evv(ENVFILE)) \
				||   ($ftype == $evv(MIX_MULTI)) \
				||   ($ftype & $evv(IS_A_BRKFILE)) \
				||   [IsAMixfileIncludingMultichan $ftype]} {
					$fprops_display insert end "$pa($fnam,$evv(DUR))        $fnam"
				} else {
					$fprops_display insert end "-------------        $fnam"
				}
			}
		}
		"durdif" {
			$f.buttons.tref config -text "Keep Value" -command PropAsRef -bd 2
			wm title $f "FILE DURATION DIFFERENCE"
			set knt 0
			foreach {fnam ftype} $tl {
				set kdur($knt) $pa($fnam,$evv(DUR))
				incr knt
			}
			set kdurdif [expr $kdur(1) - $kdur(0)]
			if {$kdurdif < 0.0} {
				set kdurdif [expr -$kdurdif]
			}
			if {$kdurdif == 0.0} {
				$fprops_display insert end "Files have the SAME duration"
			} else {
				$fprops_display insert end "Duration Difference = $kdurdif secs"
			}
		}
		"samps" {
			$f.buttons.tref config -text "" -command {} -bd 0
			wm title $f "FILE SAMPLE COUNT"
			foreach {fnam ftype} $tl {
				if { ($ftype == $evv(SNDFILE)) \
				||   ($ftype == $evv(PSEUDO_SND)) \
				||   ($ftype == $evv(ANALFILE)) \
				||   ($ftype == $evv(PITCHFILE)) \
				||   ($ftype == $evv(TRANSPOSFILE)) \
				||   ($ftype == $evv(FORMANTFILE)) \
				||   ($ftype == $evv(ENVFILE)) } {
					$fprops_display insert end "$pa($fnam,$evv(INSAMS))        $fnam"
				} else {
					$fprops_display insert end "-------------        $fnam"
				}
			}
		}
		"winlen" {
			$f.buttons.tref config -text "" -command {} -bd 0
			wm title $f "WINDOW SIZE"
			foreach {fnam ftype} $tl {
				if { ($ftype == $evv(ANALFILE)) \
				||   ($ftype == $evv(PITCHFILE)) \
				||   ($ftype == $evv(TRANSPOSFILE)) \
				||   ($ftype == $evv(FORMANTFILE)) } {
					$fprops_display insert end "[expr 1000.0/$pa($fnam,$evv(ARATE))] ms        $fnam"
				} elseif { $ftype == $evv(ENVFILE) } {
					$fprops_display insert end "$pa($fnam,$evv(WINDOW_SIZE)) ms        $fnam"
				} else {
					$fprops_display insert end "-------------        $fnam"
				}
			}
		} 
		
		"maxsamp" {
			$f.buttons.tref config -text "" -command {} -bd 0
			wm title $f "MAX SAMPLE (if known)"
			foreach {fnam ftype} $tl {
				if { ($ftype == $evv(SNDFILE))} {
					if {[info exists pa($fnam,$evv(MAXREP))]} {
						set secs [expr double($pa($fnam,$evv(MAXLOC))) / double($pa($fnam,$evv(SRATE)))]
						set secs [expr double(round($secs * 1000.0)) / 1000.0]
						set lev [expr double($pa($fnam,$evv(MAXSAMP)))/$mu(MAXFSAMPVAL)]
						set lev [expr double(round($lev * 1000.0)) / 1000.0]
						$fprops_display insert end "$fnam    $lev at $secs"
					} elseif [info exists pa($fnam,$evv(FTYP))] {
 						$fprops_display insert end "$fnam    (NOT KNOWN: use 'Src MaxSamp')"
					} else {
 						$fprops_display insert end "$fnam    NOT ON THE WORKSPACE"
					}
				} else {
					$fprops_display insert end "$fnam    NOT A SOUNDFILE"
				}
			}
		}
		default {
			$f.buttons.tref config -text "Keep Value" -command PropAsRef -bd 2
			wm title $f "FILE PROPERTIES"

			if {[llength $tl] == 2} {										;#	Special case: single mixfile
				set fnam [lindex $tl 0]
				set ftype [lindex $tl 1]
				if {[IsAMixfileIncludingMultichan $ftype]} {
					if [catch {open $fnam "r"} fId] {
						Inf "Cannot Open Mixfile To Check Properties Of Files Inside It."
					} else {
					if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
							set multichan 1
							set gotoutch 0
						} else {
							set multichan 0
						}
						while {[gets $fId line] >= 0} {					;#	Look inside mixfile
							set line [split $line]
							foreach item $line {
								if {[string length $item] > 0} {				;#	Ignoring spaces, get first item on line.
									if {![string match \;* $item]} {	;#	If not a comment,
										if {$multichan && !$gotoutch} {
											set gotoutch 1
											continue
										}
										set item [RegulariseDirectoryRepresentation $item]
										if {[info exists pa($item,$evv(FTYP))] \
										&& ($pa($item,$evv(FTYP)) == $evv(SNDFILE))} {
											lappend tl $item $pa($item,$evv(FTYP))
										} else {						;#	If it's a sndfile on wkspace, add to list of files
											lappend unknown_files $item
										}
									}
									break								;#	Whether a comment or not, ignore rest of line
								}
							}
						}
						close $fId
					}
				}
			}
			foreach {fnam ftype} $tl {
				set is_a_textfile 0
				$fprops_display insert end "____________________________________________"
				$fprops_display insert end "FILE: $fnam"
				$fprops_display insert end ""
				switch -regexp -- $ftype \
					^$evv(SNDFILE)$			{$fprops_display insert end "A Sound file."} \
					^$evv(PSEUDO_SND)$		{$fprops_display insert end "A pseudo Sound file (view but not play)."} \
					^$evv(ANALFILE)$		{$fprops_display insert end "An Analysis file."} \
					^$evv(PITCHFILE)$		{$fprops_display insert end "A binary Pitch file."} \
					^$evv(TRANSPOSFILE)$	{$fprops_display insert end "A binary Transposition file."} \
					^$evv(FORMANTFILE)$		{$fprops_display insert end "A Formant data file."} \
					^$evv(ENVFILE)$			{$fprops_display insert end "A binary Envelope file."} \
					default					{
												set is_a_textfile 1
									 			$fprops_display insert end "A Text data file."
											}				

				if [string match 1 $is_a_textfile] {
					set thisline [list Contains $pa($fnam,$evv(LINECNT)) LINES]
					$fprops_display insert end "$thisline"			
					set thisline [list Contains $pa($fnam,$evv(ALL_WORDS)) WORDS]
					$fprops_display insert end "$thisline"			
					if {[IsAMixfileIncludingMultichan $ftype]} {
						if {[IsAMixfile $ftype]} {
							set thisline [list Could be a MIXFILE with output channel cnt $pa($fnam,$evv(OUT_CHANS))]
						} else {
							set thisline [list Could be a MULTICHANNEL MIXFILE with output channel cnt $pa($fnam,$evv(OUT_CHANS))]
						}
						$fprops_display insert end "$thisline"
						set thisline [MixfileSndfilesOnWkspace $fnam 0]
						if {[string length $thisline] > 0} {
							$fprops_display insert end "$thisline"
						}
					} elseif {$ftype & $evv(SYNCLIST)} {
						$fprops_display insert end "Could be a list of Soundfiles to synchronise."
					} elseif {$ftype & $evv(SNDLIST)} {
						$fprops_display insert end "Could be a list of Soundfiles."
					} else {
						$fprops_display insert end ""
					}
					if {[IsABrkfile $ftype]} {
						$fprops_display insert end "Could be a Breakpoint file:"
						set numsize [expr round($pa($fnam,$evv(NUMSIZE)) / 2)]
						set thisline [list length $numsize]
						$fprops_display insert end "$thisline"			
						set thisline [list minval $pa($fnam,$evv(MINBRK))]
						$fprops_display insert end "$thisline"			
						set thisline [list maxval $pa($fnam,$evv(MAXBRK))]
						$fprops_display insert end "$thisline"			
						set thisline [list duration $pa($fnam,$evv(DUR))]
						$fprops_display insert end "$thisline"			
					} elseif {$pa($fnam,$evv(NUMSIZE)) > 0}	{
						$fprops_display insert end "Could be a Number List:"
						set thisline [list length $pa($fnam,$evv(NUMSIZE))]
						$fprops_display insert end "$thisline"			
						set thisline [list minval $pa($fnam,$evv(MINNUM))]
						$fprops_display insert end "$thisline"			
						set thisline [list maxval $pa($fnam,$evv(MAXNUM))]
						$fprops_display insert end "$thisline"			
					}
				} else {
					set thisline [list samples: .............. $pa($fnam,$evv(INSAMS))]
					$fprops_display insert end "$thisline"			
					set thisline [list sample rate: ......... $pa($fnam,$evv(SRATE))]
					$fprops_display insert end $thisline			
					set thisline [list channels: ............ $pa($fnam,$evv(CHANS))]
					$fprops_display insert end $thisline			
					if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
						if {$ftype == $evv(ENVFILE) } {
							set thisline [list window size: ......... $pa($fnam,$evv(WINDOW_SIZE)) ms]
							$fprops_display insert end $thisline			
							set thisline [list channels: ............ $pa($fnam,$evv(CHANS))]
							$fprops_display insert end $thisline			
							set thisline [list duration: ............ $pa($fnam,$evv(DUR))]
							$fprops_display insert end $thisline			
							continue
						} elseif {$ftype == $evv(FORMANTFILE) } {
							set thisline [list formant envelope cnt: $pa($fnam,$evv(SPECENVCNT))]
							$fprops_display insert end $thisline			
						}
						set thisline [list original sample rate: $pa($fnam,$evv(ORIGRATE))]
						$fprops_display insert end $thisline			
						set thisline [list analysis rate: ....... $pa($fnam,$evv(ARATE))]
						$fprops_display insert end $thisline			
						set thisline [list analysis window len: .. $pa($fnam,$evv(MLEN))]
						$fprops_display insert end $thisline			
						set thisline [list decimation factor: ... $pa($fnam,$evv(DFAC))]
						$fprops_display insert end $thisline			
						if { $ftype == $evv(PITCHFILE) || $ftype == $evv(TRANSPOSFILE) || $ftype == $evv(FORMANTFILE)} {
							set thisline [list original channels: ...  $pa($fnam,$evv(ORIGCHANS))]
							$fprops_display insert end "$thisline"			
						}
					}
					set thisline [list duration: ............ $pa($fnam,$evv(DUR))]
					$fprops_display insert end "$thisline"			
					if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
						if {[info exists pa($fnam,$evv(MAXREP))]} {
							set thisline [list maxsamp: ............. $pa($fnam,$evv(MAXSAMP))]
							$fprops_display insert end "$thisline"			
							set secs [expr double($pa($fnam,$evv(MAXLOC))) / double($pa($fnam,$evv(SRATE)))]
							set mins [expr floor($secs / 60)]															  
							set secs [expr ($secs - ($mins * 60))]
							if {$mins > 0} {
								set thisline [list location: ............ $mins mins $secs secs]
							} else {
								set thisline [list location: ............ $secs secs]
							}
							$fprops_display insert end "$thisline"			
							if {$pa($fnam,$evv(MAXREP)) > 0.0} {
								set thisline [list repeated: ............ $pa($fnam,$evv(MAXREP)) times]
								$fprops_display insert end "$thisline"			
							}
						} else {
							set thisline "MAXIMUM SAMPLE NOT KNOWN"
							$fprops_display insert end "$thisline"			
						}
					}
				}
			}
			if {[info exists unknown_files]} {
				$fprops_display insert end "____________________________________________"
				$fprops_display insert end "THE FOLLOWING FILES ARE NOT ON THE WORKSPACE"
				foreach fnam $unknown_files {
					$fprops_display insert end $fnam
				}
			}
		}			
	}
	raise $f
	My_Grab 0 $f pr_showprops $fprops_display
	tkwait variable pr_showprops
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	if [info exists remlist] {
		foreach item $remlist {
			$wl selection set $item
		}
	}
}

#------ Save a file property as a reference value

proc PropAsRef {} {
	global pr_gotname fprops_display propref pr_showprops ref wstk evv
	
	set f .fileprops_page

	set i [$fprops_display curselection]
	if {![info exists i] || ($i < 0)} {
		Inf "No Property Selected."
		return
	}
	set line [split [$fprops_display get $i]]
	set i 0
	foreach item $line {			 	;#	Get rid of blank spaces
		if {[string length $item] > 0} {
			lappend newline $item
			incr i
		}
	}
	incr i -1
	if {$i < 0} {
		Inf "No Numeric Property Selected."
		return
	}
	set val	[lindex $newline $i]	 	;#	Property value usually last item on line
	if {![IsNumeric $val]} {
		incr i -1						;#	But, can be 2nd to last
		if {$i < 0} {					
			Inf "No Numeric Property Selected."
			return
		}
		set val	[lindex $newline $i]
	}
	if {![IsNumeric $val]} {
		Inf "No Numeric Property Selected."
		return
	}
	$f.buttons.ok config -text OK -command {set pr_gotname 1}
	$f.buttons.tref config -text "Enter reference text" -state disabled -bg $evv(EMPH)
	$f.buttons.e config -bd 2 -state normal
	set pr_gotname 0
	set finished 0
	focus $f.buttons.e
	while {!$finished} {
		tkwait variable pr_gotname
		if {[string length $ref(text)] <= 0} {
			set choice [tk_messageBox -type ok -icon question -parent [lindex $wstk end] \
				-message "No Reference Text Entered. Have You Decided Not To Save A Reference Value?"]
			if {$choice == "yes"} {
				set finished 1
			}
		} else {
			lappend ref(name) $ref(text)
			lappend ref(val)  $val
			incr ref(cnt)
			set finished 1
		}
	}
	set ref(text) ""
	$f.buttons.e config -state disabled -bd 0
	$f.buttons.ok config -text Close -command {set pr_showprops 1}
	$f.buttons.tref config -text "Keep value" -command PropAsRef -state normal -bg [option get . background {}]
}

#------ Check if a file is on chosen list

proc IsChosen {fnam} {
	global chlist
	if [info exists chlist] {
		foreach fnm $chlist {
			if [string match $fnm $fnam] {
				return 1
			}
		}
	}
	return 0
}

#------ Check for both valid rootname, and valid extension

proc IsListableFile {fnam} {
#JAN 2006
	global checkspace
	set tempname [file tail $fnam]

	if [file isdirectory $tempname] {
		set dirname [CheckDirectoryName $tempname "directory name" 0 1]
		if {[string length $dirname] <= 0} {
			return 0
		}
	}
	set tempext [file extension $tempname]
	set tempname [file rootname $tempname]
#JAN 2006
	set checkspace 1
	if {[ValidCdpFilename $tempname 0] && ![is_CDP_Reserved_Extension $tempext]} {
		return 1
	}
#JAN 2006
	unset checkspace
	return 0
}

#------ Check for both valid rootname, and valid extension

proc IsListableHomeDirFile {fnam} {
	set tempname [file tail $fnam]

	set fnam [file join [pwd] $tempname]
	if [file isdirectory $fnam] {
		set dirname [CheckDirectoryName $fnam "directory name" 0 1]
		if {[string length $dirname] <= 0} {
			return 0
		}
	}
	set tempext [file extension $tempname]
	set tempname [file rootname $tempname]
	if {[ValidCdpFilename $tempname 0] && ![is_CDP_Reserved_Extension $tempext]} {
		return 1
	}
	return 0
}

#------ Make a textlisting of workspace files

proc WkToFile {typ sel} {
	global wl pr_wtxt wl_wtxt wl_cols pa wstk total_wksp_cnt evv readonlyfg readonlybg nu_names

	foreach i [$wl curselection] {
		lappend zfs [$wl get $i]
	}
	if {![info exists zfs]} {
		Inf "No Files Selected"
		return
	}
	if {[info exists zfs] && [GappedNameWarning $zfs]} {
		set msg "Names (or Directory Names) Of Some Selected Files Contain Spaces.\n\n"
		append msg "A List Of Soundfiles Containing Such Names\n"
		append msg "Will Not Be Recognised As A Soundfile Listing\n"
		append msg "By The Soundloom\n"
		WarningShow $msg
	}
	if {($typ == "add") || ($typ == "adddel") || ($typ == "snd")} {
		set flcnt 0
		foreach fnam $zfs {
			if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
				lappend flst $fnam
				lappend remlist $i
				incr flcnt
			}
		}
		if {$flcnt == 0} {
			Inf "No Soundfiles Selected"
			return
		}
		if {$typ != "snd"} {
			foreach fnam [$wl get 0 end] {
				set ftyp [FindFileType $fnam]
				if {$ftyp >=0} {
					if {[IsASndlist $ftyp]} {
						lappend sndfile_listings $fnam
					}
				}
			}
			if {![info exists sndfile_listings]} {
				Inf "There Are No Textfile Listings Of Soundfiles On The Workspace"
				return
			}
		}
	} elseif {$typ == "addtotxt"} {
		if {[llength $zfs] < 2} {
			Inf "Too Few Files Selected: Select Textfile, And Some Non-Text File"
			return
		}
		set gotext 0
		foreach fnam $zfs {
			if {[info exists pa($fnam,$evv(FTYP))]} {
				if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)} {
					if {$gotext} {
						Inf "Too Many Textfiles Selected"
						return
					}
					set txt_file $fnam
					set gotext 1
				} else {
					set thistxt ";"
					append thistxt $fnam
					lappend remlist $thistxt
				}
			}		
		}
		if {!$gotext} {
			Inf "No Textfiles Selected"
			return
		}
		if [catch {open $txt_file "r"} zit] {
			Inf "Cannot Read From File [file tail $txt_file]"
			return
		}
		while {[gets $zit line] >= 0} {
			lappend remlist $line
		}
		close $zit
		if [catch {open $txt_file "w"} zit] {
			Inf "Cannot Reopen File [file tail $txt_file] To Write New Data"
			return
		}
		foreach line $remlist {
			puts $zit $line
		}
		Inf "Commented Lines Added To Textfile"
		close $zit
		return
	} elseif {$typ == "addtxt"} {
		set flcnt 0
		foreach fnam $zfs {
			if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
				lappend flst $fnam
				lappend remlist $i
				incr flcnt
			}
		}
		if {$flcnt == 0} {
			Inf "No Textfiles Selected"
			return
		}
		foreach fnam [$wl get 0 end] {
			set ftyp [FindFileType $fnam]
			if {$ftyp >=0} {
				if {($ftyp & $evv(IS_A_TEXTFILE)) && ![IsAMixfile $ftyp] && ![IsASndlist $ftyp] && ($ftyp != $evv(MIX_MULTI))} {
					set k [lsearch $zfs $fnam]
					if {$k < 0} {
						lappend textfile_listings $fnam
					}
				}
			}
		}
		if {![info exists textfile_listings]} {
			Inf "There Are No (Unselected) Textfile Listings On The Workspace"
			return
		}
	}
	set f .wtxt
	if [Dlg_Create $f "Textfile Name" "set pr_wtxt 0" -borderwidth $evv(BBDR)] {
		set b  [frame $f.b -borderwidth $evv(SBDR)]
		button $b.ok -text "OK" -width 5 -command "set pr_wtxt 1" -highlightbackground [option get . background {}]
		button $b.q  -text "Close" -width 5 -command "set pr_wtxt 0" -highlightbackground [option get . background {}]
		pack $b.ok -side left
		pack $b.q -side right
		set e  [frame $f.e -borderwidth $evv(SBDR)]
 		label $e.l -text "Textfile Name" -width 11
		entry $e.e -width 20 -textvariable wl_wtxt
		set e2 [frame $f.e2 -borderwidth $evv(SBDR)]
 		label $e2.l -text "No of Columns"  -width 11
		entry $e2.e -width 20 -textvariable wl_cols
		pack $e.l $e.e -side left -padx 1
		pack $e2.l $e2.e -side left -padx 1
		set e2a [frame $f.e2a -borderwidth $evv(SBDR)]
		label $e2a.laba -text "Recent Names"
		Scrolled_Listbox $e2a.nunames -height $evv(NSTORLEN) -selectmode single
		bind $e2a.nunames.list <ButtonRelease-1> {NameListChoose .wtxt.e2a.nunames.list .wtxt.e.e}
		pack $e2a.laba $e2a.nunames -side top -fill x
		set e3 [frame $f.e3 -borderwidth $evv(SBDR)]
		label $e3.ex -text "SOUNDFILE LISTINGS ON WORKSPACE"
		label $e3.ck -text "Select with Mouse"
		Scrolled_Listbox $e3.ll -width 48 -height 12 -selectmode single
		pack $e3.ex $e3.ck $e3.ll -side top -pady 2
		pack $f.b $f.e $f.e2 $f.e2a $f.e3 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f.e3.ll.list <ButtonRelease-1> {GetSndListingOnWkspace}
		bind $f <Return> {set pr_wtxt 1}
		bind $f <Escape> {set pr_wtxt 0}
	}
	if [info exists nu_names] { 
		.wtxt.e2a.nunames.list delete 0 end
		foreach nname $nu_names {							;#	Post recent names
			.wtxt.e2a.nunames.list insert end $nname
		}					
	}
	$f.e.e config -state normal
	$f.e2.e config -state normal
	$f.e3.ex config -text ""
	$f.e3.ck config -text ""
	$f.e3.ll.list delete 0 end
	$f.e3.ll config -bd 0
	if {($typ == "add") || ($typ == "adddel")} {
		$f.e3.ex config -text "SOUNDFILE LISTINGS ON WORKSPACE"
		$f.e3.ck config -text "Select with Mouse"
		$f.e3.ll config -bd 2
		foreach fnam $sndfile_listings {
			$f.e3.ll.list insert end $fnam
		}
		ForceVal $f.e.e ""
		ForceVal $f.e2.e 1
		$f.e.e config -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		$f.e2.e config -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
	} elseif {($typ == "addtxt")} {
		$f.e3.ex config -text "OTHER TEXTFILES ON WORKSPACE"
		$f.e3.ck config -text "Select with Mouse"
		$f.e3.ll config -bd 2
		foreach fnam $textfile_listings {
			$f.e3.ll.list insert end $fnam
		}
		ForceVal $f.e.e ""
		ForceVal $f.e2.e 1
		$f.e.e config -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		$f.e2.e config -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
	} elseif {$typ == "sndur"} {
		set wl_cols 2
		.wtxt.e2.e config -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
	} else {
		set wl_cols "as is"
	}
	set wl_wtxt ""
	set pr_wtxt 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_wtxt $f.e.e
	while {!$finished} {
		tkwait variable pr_wtxt
		if {$pr_wtxt} {
			if {[string length $wl_wtxt] <= 0} {
				Inf "No Filename Entered."
				continue
			} else {
				set wl_wtxt [string tolower $wl_wtxt]				
				if {![ValidCdpFilename $wl_wtxt 1]} {
					continue
				}
			}
			if {[string match "as is" $wl_cols]  || ([string length $wl_cols] <= 0)} {
				set wl_cols 1
			} elseif {![IsNumeric $wl_cols] || ($wl_cols < 1)} {
				Inf "Invalid Column Count Entered."
				continue
			} elseif {$wl_cols > 8} {
				Inf "Column Count Too Large (Maximum  8)."
				continue
			}
			if {($typ == "add") || ($typ == "adddel") || ($typ == "addtxt")} {
				set zfnam $wl_wtxt
# COULD BE NEW FORMAT OR OLD FORMAT TEXTFILE
				if {$typ != "addtxt"} {
					set this_ext [GetTextfileExtension sndlist]
					append zfnam $this_ext
					if {![file exists $zfnam]} {
						set zfnam $wl_wtxt
						set this_ext $evv(TEXT_EXT)
						append zfnam $this_ext
					} else {
						set qfnam $wl_wtxt
						append qfnam $evv(TEXT_EXT)
						if {[file exists $qfnam]} {
							if {![string match $zfnam $qfnam]} {
								Inf "Mix File Name Is Ambiguous, Could Be '$zfnam' Or '$qfnam'"
								continue
							}
						}
					}
				} else {
					set this_ext $evv(TEXT_EXT)
					append zfnam $this_ext
				}
				if [catch {open $zfnam "r"} fId] {
					Inf "Cannot Open File '$zfnam' To Read Existing Entries"
					continue
				}
				catch {unset oldfnams}
				while {[gets $fId oldfnam] >= 0} {
					lappend oldfnams $oldfnam
				}
				close $fId
				if {[info exists oldfnams]} {
					set len [llength $flst]
					set cnt 0
					while {$cnt < $len} {
						set item [lindex $flst $cnt]
						if {[lsearch $oldfnams $item] >= 0} {
							set flst [lreplace $flst $cnt $cnt]
							incr len -1
						} else {
							incr cnt
						}
					}
					if {[llength $flst] <= 0} {
						Inf "The Chosen Soundfiles Are Already Listed"
						continue
					}
				}
				set flst [concat $oldfnams $flst]
			} elseif {$typ == "snd"} {
				set this_ext [GetTextfileExtension sndlist]
			}
			if {![info exists flst]} {
				set flcnt 0
				catch {unset preflst}
				if {$sel} {
					foreach j [$wl curselection] {
						lappend preflst [$wl get $j]
					}
				} else {
					foreach fnam [$wl get 0 end] {
						lappend preflst $fnam
					}
				}
				catch {unset this_ext}
				if {[info exists preflst]} {
					switch -- $typ {
						"all" {
							foreach fnam $preflst {
								if {![info exists this_ext]} {
									if {![info exists pa($fnam,$evv(FTYP))] || ($pa($fnam,$evv(FTYP)) !=  $evv(SNDFILE))} {
										set this_ext $evv(TEXT_EXT)
									}
								}
								lappend flst $fnam
								incr flcnt
							}
							if {![info exists this_ext]} {
								set this_ext [GetTextfileExtension sndlist]
							}
						}
						"snd" {
							foreach fnam $preflst {
								if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
									lappend flst $fnam
									incr flcnt
								}
			 				}
							set this_ext [GetTextfileExtension sndlist]
						}
						"sndur" {
							foreach fnam $preflst {
								if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
									lappend flst $fnam
									incr flcnt
								}
			 				}
							foreach fnam $flst {
								lappend flst2 $pa($fnam,$evv(DUR))
								incr flcnt
			 				}
							set flst [concat $flst $flst2]
							set this_ext $evv(TEXT_EXT)
						}
						"sys" {
							foreach fnam $preflst {
								if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE))} {
									if {![info exists this_ext] && ($pa($fnam,$evv(FTYP)) !=  $evv(SNDFILE))} {
										set this_ext $evv(TEXT_EXT)
									}
									lappend flst $fnam
									incr flcnt
								}
							}
							if {![info exists this_ext]} {
								set this_ext [GetTextfileExtension sndlist]
							}
						}
						"txt" {
							foreach fnam $preflst {
								if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
									lappend flst $fnam
									incr flcnt
								}
							}
							set this_ext $evv(TEXT_EXT)
						}
						"mix" {
							foreach fnam $preflst {
								if {[info exists pa($fnam,$evv(FTYP))] && [IsAMixfile $pa($fnam,$evv(FTYP))]} {
									lappend flst $fnam
									incr flcnt
								}
							}
							set this_ext $evv(TEXT_EXT)
						}
						"multimix" {
							foreach fnam $preflst {
								if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI))} {
									lappend flst $fnam
									incr flcnt
								}
							}
							set this_ext $evv(TEXT_EXT)
						}
					}
				}
			}
			if [info exists flst] {
				set ofnam $wl_wtxt
				append ofnam $this_ext
				if {($typ != "add") && ($typ != "adddel")&& ($typ != "addtxt")} {
					if {[LstIndx $ofnam $wl] >= 0} {
						Inf "This File Already Exists On The Workspace. You Cannot Overwrite It Here."
						continue
					}
					if [file exists $ofnam] {
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] \
							-message "File '$ofnam' Already Exists. Overwrite It?"]
						if {$choice == "no"} {
							continue
						} else {
							if [catch {file delete $ofnam} in] {
								Inf "Cannot Delete The Existing File '$ofnam' : Please Choose A Different Name."
								continue
							} else {
								set it_exists 1
							}
						}
					}
				}
				if [catch {open $ofnam "w"} fId] {
					Inf "Cannot Open File '$ofnam' To Write The List"
					catch {unset it_exists}
					continue
				}
				if {$wl_cols == 1} {
					foreach item $flst {
						puts $fId $item
					}
				} else {
					set colbas 0
					set colpos $colbas
					set colstep [expr $flcnt / $wl_cols]
					set colfidl [expr $flcnt % $wl_cols]
					set i 0
					set coladju $colfidl
					while {$i < $flcnt} {
						if {$colpos >= $flcnt} {
							set line [Tabulate $line]
							puts $fId $line
							incr colbas
							set colpos $colbas
							set coladju $colfidl
							unset line
						}
						lappend line [lindex $flst $colpos]
						incr colpos $colstep
						if {$coladju > 0} {
							incr colpos
							incr coladju -1
						}
						incr i
					}
					set line [Tabulate $line]
					puts $fId $line
				}
				close $fId
				if {$typ == "adddel"} {
					foreach i [lsort -integer -decreasing $remlist] {
						set fnam [$wl get $i]
						set ff [file tail $fnam]
						if {![string match $ff $fnam]} {
							PurgeArray $fnam
							RemoveFromChosenlist $fnam
							incr total_wksp_cnt -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				if {($typ == "add") || ($typ == "adddel") || ($typ == "addtxt")} {
					if {[string match $ofnam $zfnam]} {
						DummyHistory $ofnam "UPDATES"
						DoParse $ofnam $wl 0 0
					} else {
						DummyHistory $ofnam "CREATED"
						if {[FileToWkspace $ofnam 0 0 0 0 1] <= 0} {
							Inf "Cannot Put The Listfile On The Workspace, But It Is In The Home Directory."
						}
					}
				} elseif {[info exists it_exists]} {
					DummyHistory $ofnam "OVERWRITTEN"
					if {[FileToWkspace $ofnam 0 0 0 0 1] <= 0} {
						Inf "Cannot Put The Listfile On The Workspace, But It Is In The Home Directory."
						catch {unset rememd}
					}
					unset it_exists
				} else {
					DummyHistory $ofnam "CREATED"
					if {[FileToWkspace $ofnam 0 0 0 0 1] <= 0} {
						Inf "Cannot Put The Listfile On The Workspace, But It Is In The Home Directory."
					}
				}
				if {[info exists pa($ofnam,$evv(FTYP))]} {
					if {[IsASndlist $pa($ofnam,$evv(FTYP))]} {
						set this_ext [GetTextfileExtension sndlist]
						if {![string match [file extension $ofnam] $this_ext]} {
							set zfnam [file rootname $ofnam]
							append zfnam $this_ext
							RenameTextWkspaceFile $ofnam $zfnam
						}
					}
				}
				Inf "Completed"
			} else {
				if {$sel} {
					Inf "No Files Of This Type Are Currently Selected."
				} else {
					Inf "No Files Of This Type Are Currently On The Workspace."
				}
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc GetSndListingOnWkspace {} {
	global pr_wtxt
	set i [.wtxt.e3.ll.list curselection]
	if {$i >= 0} {
		set thisname [file rootname [.wtxt.e3.ll.list get $i]]
		ForceVal .wtxt.e.e $thisname
		ForceVal .wtxt.e2.e 1
		set pr_wtxt 1
	}
}

#------ Convert a list into a line of words-separated-by-tabs

proc Tabulate {line} {
	set oline ""
	foreach word $line {
		append oline $word "\t"
	}
	set len [string length $oline]
	incr len -2
	set oline [string range $oline 0 $len]
	return $oline
}

#------ sort workspace files 
#
# r  = most recent to top
# o  = oldest to top
# c  = chosen files to top
# rs = most recent sound to top
# os = oldest sound to top
# bs = biggest sound to top
# ss = smallest sound to top
# ch = chosen files order
#

proc SortWl {typ} {
	global wl ch pa play_new evv tosomewhere

	catch {unset tosomewhere}
	set cnt 0
	set file_access 0

	if {[string match $typ "ps"] && ![info exists play_new]} {
		Inf "No Play Sort Has Been Made"
		return
	}
	if {[string match $typ "ch"]} { 
		if {([$ch index end] < 0)} {
			Inf "No Files Have Been Chosen"
			return
		}
		foreach fnam [$ch get 0 end] {
			set i [LstIndx $fnam $wl]
			if {$i >= 0} {
				if {![info exists ilist] || ([lsearch $ilist $i] < 0)} {
					lappend ilist $i
					lappend fnams $fnam
				}
			}
		}
		if {[info exists ilist]} {
			set ilist [lsort -integer -decreasing $ilist]
			foreach i $ilist {
				$wl delete $i
			}	
			set fnams [ReverseList $fnams]
			foreach fnam $fnams {
				$wl insert 0 $fnam
			}
		}
		return
	}
	foreach fnam [$wl get 0 end] {
		if {![info exists pa($fnam,$evv(FTYP))]} {
			lappend badlist $fnam
		} else {
			lappend lol $fnam
		}
		incr cnt
	}
	if {![info exists lol]} {
		Inf "No (Valid) Files On Workspace"
		return
	}
	if [string match $typ "c"] {
		foreach fnam $lol {
			if {[LstIndx $fnam $ch] >= 0} {
				lappend ll $fnam
			} else {
				lappend ll2 $fnam
			}
		}
		$wl delete 0 end
		if [info exists ll] {
			foreach fnam $ll {
				$wl insert end $fnam
			}
		}
		if [info exists ll2] {
			foreach fnam $ll2 {
				$wl insert end $fnam
			}
		}
		if [info exists badlist] {
			foreach fnam $badlist {
				$wl insert end $fnam
			}
		}
		return
	} elseif {([string length $typ] > 1) && ([string index $typ 1] == "s")} {
		foreach fnam $lol {
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				lappend ll $fnam
			} else {
				lappend ll2 $fnam
			}
		}
	} else {
		set ll $lol
	}
	set tyyp [string index $typ 0]

	if [info exists ll] {
		if [string match $typ "ps"] {
			if {[llength $play_new] != [llength $ll]} {
				Inf "The Current Workspace Was Not The Last To Be Play-Sorted"
				catch {unset play_new}
				return
			}
			foreach item $ll {
				if {[lsearch -exact $play_new $item] < 0} {
					Inf "The Current Workspace Was Not The Last To Be Play-Sorted"
					catch {unset play_new}
					return
				}
			}
			set ll $play_new
		} else {
			if [string match {[ro]} $tyyp] {	;#	If sort on properties requiring file-access
				set file_access 1
				catch {unset lol}				;#	wrap-up file prop with file name, in a pair of vals
				foreach fnam $ll {				;#	(i.e. do it here to avoid accessing file props repeatedly, during search)
					set k [list [file mtime $fnam] $fnam]
					lappend lol $k				;#	reconstruct list as list of pairs
				}
				set ll $lol
			}
			set len [llength $ll]
			incr len -1
			set i 0
			while {$i < $len} {
				set j $i
				incr j
				set fnami [lindex $ll $i]
				while {$j <= $len} {
					set fnamj [lindex $ll $j]
					set swap [IsSwap $fnami $fnamj $tyyp]
					if {$swap} {
						set ll [lreplace $ll $i $i $fnamj] 
						set ll [lreplace $ll $j $j $fnami] 
						set fnami [lindex $ll $i]
					}
					incr j
				}
				incr i
			}
		}
	}
	$wl delete 0 end
	if {$file_access} {						
		catch {unset lol}					;#	If it was sort on properties requiring file-access
		foreach item $ll {					;#	Unwrap the paired items
			lappend lol [lindex $item 1]
		}
		set ll $lol
	}
	if [info exists ll] {
		foreach fnam $ll {
			$wl insert end $fnam
		}
	}
	if [info exists ll2] {
		foreach fnam $ll2 {
			$wl insert end $fnam
		}
	}
	if [info exists badlist] {
		foreach fnam $badlist {
			$wl insert end $fnam
		}
	}
}

#------ swap elements ??

proc IsSwap {fnami fnamj typ} {
	global pa evv
	
	switch -- [string index $typ 0] {
		r {							   ;#	most recent to top
			if {[lindex $fnamj 0] > [lindex $fnami 0]} {
				return 1
			}
		}
		o {							   ;#	oldest to top
			if {[lindex $fnamj 0] < [lindex $fnami 0]} {
				return 1
			}
		}
		b {								;#	largest to top
			if {$pa($fnamj,$evv(DUR)) > $pa($fnami,$evv(DUR))} {
				return 1
			}
		}
		s {								;#	smallest to top
			if {$pa($fnamj,$evv(DUR)) < $pa($fnami,$evv(DUR))} {
				return 1
			}
		}
	}
	return 0
}

#------ sort workspace files using an entered search-string

proc StrSortWl {typ} {
	global wl pr_ss wl_sstr evv tosomewhere

	catch {unset tosomewhere}
	set f .ss
	if [Dlg_Create $f "Search String" "set pr_ss 0" -borderwidth $evv(BBDR)] {
		set b  [frame $f.b -borderwidth $evv(SBDR)]
		button $b.ok -text "Search" -width 5 -command "set pr_ss 1" -highlightbackground [option get . background {}]
		button $b.q  -text "Close" -width 5 -command "set pr_ss 0" -highlightbackground [option get . background {}]
		pack $b.ok -side left
		pack $b.q -side right
		set e  [frame $f.e -borderwidth $evv(SBDR)]
 		label $e.l -text "Search String"
		entry $e.e -width 20 -textvariable wl_sstr
		pack $e.l $e.e -side left -padx 1
		pack $f.b $f.e -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_ss 1}
		bind $f <Escape> {set pr_ss 0}
	}
	set wl_sstr ""
	set pr_ss 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_ss $f.e.e
	while {!$finished} {
		tkwait variable pr_ss
		if {$pr_ss} {
			if {[string length $wl_sstr] <= 0} {
				Inf "No (Valid) Search String Entered."
				continue
			}
			set wl_sstr [string tolower $wl_sstr]
			foreach fnam [$wl get 0 end] {
				set rfnam [file rootname [file tail $fnam]]
				switch -- $typ {
					0 {
						if [string match $wl_sstr* $rfnam] {
							lappend ll $fnam
						} else {
							lappend ll2 $fnam
						}
					}
					1 {
						if [string match *$wl_sstr* $rfnam] {
							lappend ll $fnam
						} else {
							lappend ll2 $fnam
						}
					}
					2 {
						if [string match *$wl_sstr $rfnam] {
							lappend ll $fnam
						} else {
							lappend ll2 $fnam
						}
					}
				}
			}
			$wl delete 0 end
			if [info exists ll] {
				foreach fnam [lsort -dictionary $ll] {
					$wl insert end $fnam
				}	
			} else {
				switch -- $typ {
					0 {
						Inf "No Files Whose Name Starts With '$wl_sstr' Are On The Workspace."
					}
					1 {
						Inf "No Files Whose Name Contains '$wl_sstr' Are On The Workspace."
					}
					2 {
						Inf "No Files Whose Name Ends With '$wl_sstr' Are On The Workspace."
					}
				}
			}
			if [info exists ll2] {
				foreach fnam $ll2 {
					$wl insert end $fnam
				}
			}
			set finished 1
		} else {
			set finished 1
		}
	} 
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Store chosenfiles list in new textfile

proc StorChFiles {} {
	global ch_tfile	pr_chf zfq ins chlist sl_real evv pa wstk wl

	if {!$sl_real} {
		Inf "The Names Of The Files Currently Listed In The 'chosen' List, Below\nCan Be Written To A Text File"
		return
	}
	set ch_tfile 0
	if {$ins(create) && [info exists ins(chlist)] && ([llength $ins(chlist)] > 0)} {
		set flist $ins(chlist)
	} elseif {[info exists chlist] && ([llength $chlist] > 0)} {
		set flist $chlist
	} else {
		Inf "No Files Chosen"
		return
	}
	set f .stchf
	if [Dlg_Create $f "Name Textfile"  "set pr_chf 0" -borderwidth $evv(BBDR)] {
		frame $f.b -borderwidth $evv(SBDR)
		frame $f.e -borderwidth $evv(SBDR)
		button $f.b.b1 -text "Save"  -width 6 -command "set pr_chf 1" -highlightbackground [option get . background {}]
		button $f.b.b2 -text "Abandon" -width 6 -command "set pr_chf 0" -highlightbackground [option get . background {}]
		label $f.e.l -text "filename"
		entry $f.e.e -textvariable zfq -width 24
		pack $f.b.b1 -side left
		pack $f.b.b2 -side right
		pack $f.e.l $f.e.e -side left -padx 1 -pady 1
		pack $f.b $f.e -side top -fill x -expand true
		bind $f <Return> {set pr_chf 1}
		bind $f <Escape> {set pr_chf 0}
	}
	wm resizable $f 1 1
	raise $f
	set pr_chf 0
	set finished 0
	My_Grab 0 $f pr_chf $f.e.e
	while {!$finished} {
		tkwait variable pr_chf
		if {$pr_chf} {
			if {[string length $zfq] < 0} {
				Inf "No Filename Entered"
				continue
			}
#JUNE 30 UC-LC FIX
			set zfq [string tolower $zfq]
			set zfq2 [file rootname [file tail $zfq]]
			if {![string match $zfq2 $zfq]} {
				Inf "Extensions Or Pathnames Cannot Be Used Here"
				continue
			}
			set zfq [FixTxt $zfq "new filename"]
			if {[string length $zfq] <= 0} {
				continue
			}
			ForceVal $f.e.e $zfq
		 	if {![ValidCdpFilename $zfq 1]} {
				continue
			}
			foreach zfnam $flist {
				if {![info exists pa($zfnam,$evv(FTYP))] || ($pa($zfnam,$evv(FTYP)) != $evv(SNDFILE))} {
					set this_ext $evv(TEXT_EXT)
					break
				}
			}
			if {![info exists this_ext]} {
				set this_ext [GetTextfileExtension sndlist]
			}						
			set zfqxx $zfq$this_ext
			set orig_file_on_wksp 0
			if {[file exists $zfqxx]} {
				if {([lsearch $flist $zfqxx] >= 0)} {
					Inf "File $zfqxx Is One Of The Files On The Chosen Files List: You Cannot Use This As The Output Filename Here"
					continue
				}
				set msg "FILE $zfqxx ALREADY EXISTS: OVERWRITE IT?"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					continue
				}
				if {[DeleteFileFromSystem $zfqxx 0 1] <= 0} {
					continue
				}
				set i [LstIndx $zfqxx $wl]
				if {$i >= 0} {
					WkspCnt [$wl get $i] -1
					$wl delete $i
					set orig_file_on_wksp 1
				}
			}
			if [catch {open $zfqxx "w"} ffqId] {
				Inf "Cannot Open File '$zfqxx' To Write Data."
				if {$orig_file_on_wksp} {
					catch {unset rememd}
				}
				continue
			}
			foreach fgg $flist {
				puts $ffqId $fgg
			}
			close $ffqId
			if {[FileToWkspace $zfqxx 0 0 0 0 1] <= 0} {
				if {$orig_file_on_wksp} {
					catch {unset rememd}
				}
				continue
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	destroy .stchf
}

#------ See your system constants

proc SeeSys {} {
	global prsys small_screen playcmd new_text_edit_style evv
	global new_cdp_extensions new_user_text_extensions user_text_extensions float_out private_directories
	set f .seesys
	if [Dlg_Create $f "System Configuration" "set prsys 1" -borderwidth $evv(BBDR)] {
		set b [frame $f.button -borderwidth $evv(SBDR)]
		set zz_sl [Scrolled_Listbox $f.sys -height $evv(NSTORLEN) -selectmode single -width 80 -height 20]
		button $b.ok -text "OK" -command "set prsys 1" -highlightbackground [option get . background {}]
		pack $b.ok -side top
		pack $f.button $f.sys -side top
		.seesys.sys.list insert end "PLATFORM/OPERATING-SYSTEM    :    $evv(SYSTEM)"
		if {$small_screen} {
			set x "small screen"
		} else {
			set x "large screen"
		}
		.seesys.sys.list insert end "SCREEN SIZE BEING USED               :    $x"
		if {[string match $evv(BITRES) "1.0"]} {
			set x "32 or 64bit FLOAT"
		} else {
			set x "$evv(BITRES)"
		}
		.seesys.sys.list insert end "TYPICAL BIT RESOLUTION             :    $x"
		if {$evv(DFLT_SR) == 0} {
			set x "all rates"
		} else {
			set x $evv(DFLT_SR)
		}
		.seesys.sys.list insert end "DEFAULT SAMPLING RATE USED     :    $x"
		if {$float_out} {
			set x "floating point"
		} else {
			set x "outfile type = infile type"
		}
		.seesys.sys.list insert end "OUTFILE TYPE (16bit;float etc)       :    $x"
		set x '
		append x $evv(SNDFILE_EXT)
		append x '
		.seesys.sys.list insert end "SOUNDFILE EXTENSION (TYPE)      :    $x"
		if {$new_cdp_extensions} {
			set x "multiple"
		} else {
			set x $evv(SNDFILE_EXT)
			append x "  only"
		}
		.seesys.sys.list insert end "SNDSYS EXTENSION(S) IN USE       :    $x"
		if {[info exists new_user_text_extensions] || [info exists user_text_extensions]} {
			set x "user defined"
		} else {
			set x $evv(TEXT_EXT)
		}
		.seesys.sys.list insert end "TEXTFILE EXTENSION(S)                 :    $x"
		.seesys.sys.list insert end "--------------------------------------------------------------------"
		.seesys.sys.list insert end "DIRECTORY FOR CDP PROGRAMS  :    $evv(CDPROGRAM_DIR)"
		.seesys.sys.list insert end "COMMAND TO PLAY SNDFDILES      :    $playcmd"
		.seesys.sys.list insert end "--------------------------------------------------------------------"
#		switch -- $new_text_edit_style {
#			0 { set x "Edit Text or Draw Graphs" }
#			1 { set x "Edit Text only" }
#			2 { set x "Draw Graphs only" }
#		}
#		.seesys.sys.list insert end "BREAKPOINT FILE EDIT STYLE         :    $x"
		if {$evv(NEWUSER_HELP)} {
			set x "On"
		} else {
			set x "Off"
		}	
		.seesys.sys.list insert end "NEW USER HELP                               :    $x"
		if {[info exists private_directories]} {
			set x "Private directories defined"
		} else {
			set x "None"
		}
		.seesys.sys.list insert end "PRIVATE DIRECTORIES                    :    $x"
		bind $f <Return> {set prsys 1}
		bind $f <Escape> {set prsys 1}
		bind $f <Key-space> {set prsys 1}
	}
	wm resizable $f 1 1
	set prsys 0
	My_Grab 0 $f prsys
	tkwait variable prsys
	My_Release_to_Dialog $f
	destroy $f
}
#------ Display directory listing from previous session

proc ShowDirListingOnWkspace {} {
	global wksp_dirname sl_real ww evv

	if {!$sl_real} {
		return
	}
	set fnam [file join $evv(URES_DIR) $evv(DIRLISTING)$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam r} fileId] {
		Inf "Cannot Open Directory Listing File, To Read It."
		return		
	}
	if { [gets $fileId line] < 0} {
		Inf "Cannot Read Data In Directory Listing File."
		close $fileId
		return		
	}
	close $fileId
	set old_dirname $line
	if {[string length $old_dirname] <= 0} {
		Inf "Cannot Read Data In Directory Listing File."
		return
	}
	if {![file exists $old_dirname] || ![file isdirectory $old_dirname]} {
		Inf "Directory '$old_dirname' No Longer Exists"								
		return
	}
	set wksp_dirname $old_dirname
	UpdateRecentDirs $old_dirname
	ForceVal $ww.1.b.de $wksp_dirname
}

#------ Save directory listing from workspace

proc SaveDirListingFromWkspace {} {
	global active_dir sl_real evv

	if {!$sl_real} {
		return
	}
	set fnam [file join $evv(URES_DIR) $evv(DIRLISTING)$evv(CDP_EXT)]

	if {![info exists active_dir] || ([string length $active_dir] <= 0)} {
		catch {file delete $fnam}
		return
	}
	if [catch {open $fnam w} fileId] {
		Inf "Cannot Open Directory Listing File, To Write To It."
		return		
	}

	set active_dir [RegulariseDirectoryRepresentation $active_dir]
	puts $fileId $active_dir
	close $fileId
}

#------ Dialogbox to show files in named directory and allow transfer to workspace
#
#					DIRECTORY LISTING
#				   Grab Selected Files
#				OK					CANCEL
#				--------------------------
#						Listbox
#

proc Dlg_Showdir {dirname f wkspacedir} {
	global pr_5 dir_dlg_help_actvtd wksp_hlp_actv dl wl wstk active_dir rememd sl_real wksp_dirname evv
	global is_terminating ww background_listing blist_change total_wksp_cnt hidden_dir ww wksp_in_chose_mode
	global ch chlist chcnt previous_dirlisting previous_active_dir mixmanage wl_finds grabchans
	global checkspace allow_numeric_filenames is_subdirlist wlilist nesstype ww_lastdir

	if {[info exists active_dir]} {
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	} else {
		set presetting 1
	}
	if {$wkspacedir} {
		set dirname ""
	}
	set active_dir $dirname

	$dl delete 0 end
	$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
	Block "Listing Directory"
	set y_cnt 0
	set x_max 0
	foreach fnam [lsort -dictionary [glob -nocomplain [file join $dirname *]]] {
		if [IsListableFile $fnam] {
			set fnam [string tolower $fnam]
			set show_len [string length $fnam]
			if {$show_len > $x_max} {
				set x_max $show_len
			}
			$dl insert end $fnam		;#	and place them in the listing window
			incr y_cnt
		} else {
			lappend badfiles $fnam
		}
	}
	;#	DEALS WITH MAC FILES COPIED TO PC ENVIRONMENT, AND SCIENTIFIC DATA FILES

	if {[info exists badfiles]} {
		set nubadfiles {}
		foreach fnam $badfiles {
			if {[SubCheck $fnam]} {												;#	Ignore CDP system files and directories
				lappend nubadfiles $fnam
			}
		}
		set badfiles $nubadfiles
		set len [llength $badfiles]
		if {$len <= 0} {		
			unset badfiles
		}
		set n 0
		while {$n < $len} {
			set badf [lindex $badfiles $n]
			if {[string length [file rootname [file tail $badf]]] <= 0} {		;#	Catches MAC Files like ".DStore"
				set badfiles [lreplace $badfiles $n $n]							;#	and ignores them
				if {[llength $badfiles] <= 0} {
					unset badfiles
					break
				}
				incr len -1
			} else {
				incr n
			}
		}
	}																			;#	CDP incompatible names ("." within name, or unknown extensions)
	if {[info exists badfiles]} {
		set msg "Directory Contains Unlistable Files: View These Files ??"
		set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
		if {$choice == "yes"} {
			set show 1
			set msg ""
			set ubercnt 0
			set cnt 0
			set len [llength $badfiles]
			foreach badf $badfiles {
				append msg [file tail $badf] "\n"
				incr cnt
				incr ubercnt
				if {$cnt >= 20} {
					append msg "\n\nFilenames Must Use Characters a-z,A-Z,underscore,hyphen"
					if {[info exists checkspace]} {
						append msg ",space"
					}
					append msg " and 0-9, ONLY.\n"
					append msg "Accents In Filenames Cannot Be Read, Nor \".\" Within The Body Of The Filename.\n"
					append msg "Filenames Must Also Not Begin With A Hyphen"
					if {!$allow_numeric_filenames} {
						append msg " Or A Number"
					}
					append msg ".\n"
					Inf $msg
					if {$ubercnt >= $len} {
						set show 0
						break
					} else {
						set msg "View more files ??"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							set msg ""
							set cnt 0
						} else {
							set show 0
							break
						}
					}
				}
			}
			if {$show} {
				append msg "\n\nFilenames Must Use Characters a-z,A-Z,underscore,hyphen"
				if {[info exists checkspace]} {
					append msg ",space"
				}
				append msg " and 0-9, ONLY.\n"
				append msg "Accents In Filenames Cannot Be Read, Nor \".\" Within The Body Of The Filename.\n"
				append msg "Filenames Must Also Not Begin With A Hyphen"
				if {!$allow_numeric_filenames} {
					append msg " Or A Number"
				}
				append msg ".\n"
				Inf $msg
			}
			set msg "If Your Directory Contains Only Textfiles,\n"
			append msg "You Can Change The Names Of The Textfiles Systematically Here.\n\n"
			append msg "This Replaces \".\" Within The Body Of Filenames, And/Or Forces A \".txt\" Extension.\n"
			append msg "(for example, Textfiles from the MAC with \".\" in the filename body can be converted here).\n\n"
			append msg "Change Text-File Names Systematically ??"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if {$choice == "yes"} {
				set msg "You Might Want To Make A Bakup Copy Of This Directory In A New Subdirectory.\n\n"
				append msg "Bakup To A New Subdirectory, Before Renaming ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				set newsubdir ""
				if {$choice == "yes"} {
					set newsubdir [CopyDirToSubdir $dirname]
				}
				if {[string length $newsubdir] > 0} {
					set msg "You Can Change File Names In The Original Directory Or In The Subdirectory.\n\n"
					append msg "Modify Names In The New Subdirectory ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						if {[CompatibleRename [file join $dirname $newsubdir]]} {
							Inf "You Can Now Display The Files In The Subdirectory $newsubdir"
						}
					} else {
						set msg "Modify Names In The Original Directory ??"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							if {[CompatibleRename $dirname]} {
								Inf "You Can Now Re-Display The Files In This Directory"
							}
						}
					}
				} else {
					set msg "Modify Names In The Original Directory ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						if {[CompatibleRename $dirname]} {
							Inf "You Can Now Re-Display The Files In This Directory"
						}
					}
				}
			}
		}
	}
	if [info exists presetting] {
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	if {$y_cnt > 0} {
		Scrollbars_Reset $dl $ww.1.b.dirlist.yscroll $ww.1.b.dirlist.xscroll $y_cnt $x_max
	}
	UnBlock
	$ww.1.b.msgx config -text "" -background [option get . background {}]
	set hidden_dir ""
	set pr_5  0
	set finished 0
	if {[info exists wl] && [info exists wlilist]} {
		$wl selection clear 0 end
		foreach i $wlilist {
			$wl selection set $i
		}
		unset wlilist
	}
	if {[info exists ww_lastdir]} {
		HilightLastSubdirUsed $ww_lastdir
		unset ww_lastdir
	}
	catch {unset is_subdirlist}
	while {$finished == 0} {				;#	allows FURTHER file selection, till CANCEL pressed
		tkwait variable pr_5				;#	wait for pr_5 to be set by button-press
		if {$pr_5 > 0} {					;#	means grab the selected files
			if {!$sl_real} {
				continue
			}
			if {$pr_5 == $evv(GRAB_ALL)} {
				$wl selection clear 0 end
				catch {unset wl_finds}
				if {[info exists grabchans]} {
					if {$grabchans == 10000} {
						Block "Searching For All Mono Soundfiles"
					} else {
						Block "Searching For All Soundfiles with $grabchans channels"
					}
				} else {
					set grabchans 1
					Block "Grabbing All Files"
				}
				set zqh 0
				catch {unset temp_list}
				foreach newfile [$dl get 0 end] {
					if {[string length $hidden_dir] > 0} {
						set newfile [file join $hidden_dir $newfile]
					}
				 	if {![file isdirectory $newfile]} {
						lappend temp_list $newfile
					}
				}
				if  {[info exists temp_list]} {
					set temp_list [ReverseList $temp_list]
					set save_mixmanage 0
					set nessupdate 0
					foreach newfile $temp_list {
						wm title .blocker  "PLEASE WAIT:      PARSING AND LOADING FILE [file rootname [file tail $newfile]]"
						if {[FileToWkspace $newfile 1 0 0 $grabchans 0] > 0} {
							if {[UpdatedIfAMix $newfile 0]} {
								set save_mixmanage 1
							} elseif {[UpdatedIfANessFull $newfile]} {
								set nessupdate 1
							}
							incr zqh
						}
					}
				}
				unset grabchans
				if {!$zqh} {
					Inf "There Were No Files To Grab\n\nListed Items May Be Subdirectories"
				} else {
					if {$save_mixmanage} {
						MixMStore
					}
					if {$nessupdate} {
						NessMStore
					}
					$wl yview moveto 0.0
					set iii 0
					while {$iii < $zqh} {
						$wl selection set $iii
						incr iii
					}
				}
				set save_mixmanage 0
				set nessupdate 0
				if {[info exists wl_finds]} {
					AdjustWkspaceView [lindex $wl_finds end]
				}
			} elseif {$pr_5 == $evv(DELETE_ALL)} {
				set cnt 0
				foreach zzz1 [$dl get 0 end] {
					incr cnt
				}
				if {$cnt == 0} {
					set choice [tk_messageBox -type yesno -default yes \
					-message "Directory Is Empty: Delete Directory '$wksp_dirname' ?" -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						if [catch {file delete -force $wksp_dirname} zib] {
							Inf "Cannot Delete Directory '$wksp_dirname'"
							PurgeDirs $wksp_dirname 0
						} else {
							PurgeDirs $wksp_dirname 1
						}
					} else {
						PurgeDirs $wksp_dirname 0
					}
					GetSuperdir
					Block "Deleted Directory"
				} else {
					set zzz1 [$dl get 0]
					if {[string length $hidden_dir] > 0} {
						set zzz1 [file join $hidden_dir $zzz1]
					}
					set zzz2 [file tail $zzz1]
					if {[string match $zzz1 $zzz2]} {
						Inf "You Cannot Delete The Home Directory"
						continue
					}
					set this_dirname [file dirname $zzz1]
					if {![string match $this_dirname $wksp_dirname]} {
						set msg "The Listed Directory '$this_dirname'\n\n"
						append msg "Is Not The Same As The Named Directory '$wksp_dirname'\n\n"
						append msg "Delete Files In Listed Directory '$this_dirname' ?" 
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							set wksp_dirname $this_dirname
						} else {
							continue
						}
					}
					$dl delete 0 end	;#	get uptodate listing!!
					set file_cnt 0
					set file_and_dir_cnt 0
					set total_file_cnt 0
					foreach fnam [lsort -dictionary [glob -nocomplain [file join $wksp_dirname *]]] {
						incr total_file_cnt
						if [IsListableFile $fnam] {
							set fnam [string tolower $fnam]
							$dl insert end $fnam
							if {![file isdirectory $fnam]} {
								incr file_cnt
							}
							incr file_and_dir_cnt
						}
					}
					set listed_files 0
					if {$file_cnt > 0} {
						if [AreYouSure] {
							Block "Deleting All Files"
							set qq [expr $file_and_dir_cnt - 1]
							set deleted_file_cnt 0
							set blist_change 0
							set save_mixmanage 0
							set nessupdate 0
							catch {unset delete_mixmanage}
							while {$qq >= 0} {
								set newfile [$dl get $qq] 
								if {[string length $hidden_dir] > 0} {
									set newfile [file join $hidden_dir $newfile]
								}
						 		if {![file isdirectory $newfile]} {
									if {![DeleteFileFromSystem $newfile 0 1]} {
										Inf "Cannot Delete File '$newfile'"
									} else {
										DummyHistory $newfile "DESTROYED"
										if {[info exists mixmanage($newfile)]} {
											unset mixmanage($newfile)
											set save_mixmanage 1
										}
										if {[info exists nesstype($newfile)]} {
											PurgeNessData $newfile
											set nessupdate 1
										}
										if {[IsInAMixfile $newfile]} {
											lappend delete_mixmanage $newfile
										}
										incr deleted_file_cnt
										set i [LstIndx $newfile $wl]	;#	remove from workspace listing, if there
										if {$i >= 0} {
											$wl delete $i
											WkspCnt $newfile -1
											catch {unset rememd}
										}
									}
								}
								incr qq -1
							}
							if {[info exists delete_mixmanage]} {
								MixM_ManagedDeletion $delete_mixmanage
								set save_mixmanage 1
							}
							if {$save_mixmanage} {
								MixMStore
							}
							if {$nessupdate} {
								NessMStore
							}
							catch {unset delete_mixmanage}
							set save_mixmanage 0
							set nessupdate 0
							if {$deleted_file_cnt && $blist_change} {
								SaveBL $background_listing
							}
							if {($file_cnt == $deleted_file_cnt) && ($file_and_dir_cnt == $file_cnt) && ([string length $wksp_dirname] > 0)} {
								if {$total_file_cnt > $file_cnt} {
									Inf "WARNING: There Are non-CDP Files OR CDP-system Files In The Directory!!!!"
								}
								set choice [tk_messageBox -type yesno -default yes \
								-message "Delete Directory '$wksp_dirname' ?" -icon question -parent [lindex $wstk end]]
								if {$choice == "yes"} {
									if [catch {file delete -force $wksp_dirname} zib] {
										Inf "Cannot Delete Directory '$wksp_dirname'"
										PurgeDirs $wksp_dirname 0
									} else {
										PurgeDirs $wksp_dirname 1
									}
								} else {
									PurgeDirs $wksp_dirname 0
								}
								UnBlock
								GetSuperdir
								Block "Deleted All Files in Directory"
							}
						} else {
							continue
						}
					} else {
						if {$file_and_dir_cnt > $file_cnt} {
							Inf "No Files To Delete: Subdirectories Only."
							continue
						} else {
							if {$total_file_cnt > $file_cnt} {
								Inf "WARNING: There Are non-CDP Files Or CDP-system Files In The Directory!!!!"
							}
							Block "Deleting Directory ??"
							set choice [tk_messageBox -type yesno -default yes \
							-message "Delete Directory '$wksp_dirname' ?" -icon question -parent [lindex $wstk end]]
							if {$choice == "yes"} {
								if [catch {file delete -force $wksp_dirname} zib] {
									Inf "Cannot Delete Directory '$wksp_dirname'"
									PurgeDirs $wksp_dirname 0
								} else {
									PurgeDirs $wksp_dirname 1
								}
							} else {
								PurgeDirs $wksp_dirname 0 
							}
							UnBlock
							GetSuperdir
							Block "Deleted All Files"
						}
					}
				}
			} elseif {$pr_5 == $evv(DELETE_SOME)} {
				set ilist [$dl curselection]
				if {[llength $ilist] <= 0} {
					Inf "No Items Selected"
					continue
				}
				set zzz1 [$dl get 0]
				if {[string length $hidden_dir] > 0} {
					set zzz1 [file join $hidden_dir $zzz1]
				}
				set zzz2 [file tail $zzz1]
				if {[string match $zzz1 $zzz2]} {
					Inf "You Cannot Delete Files In The Home Directory"
					continue
				}
				set wksp_dirname [file dirname $zzz1]
				catch {unset deletables}
				foreach i [lsort -integer -decreasing $ilist] {
					set z_fnam [$dl get $i]
					if {[string length $hidden_dir] > 0} {
						set z_fnam [file join $hidden_dir $z_fnam]
					}
					if [file isdirectory $z_fnam] {
						Inf "'$z_fnam' Is A Subdirectory"
					} else {
						lappend deletables $i
					}
				}
				if {![info exists deletables]} {
					Inf "No Items To Delete"
					continue
				}
				set ilist $deletables
				if {[llength $ilist] == 1} {
					set msg "Are You Sure You Want To Destroy This File ?"
				} else {
					set msg "Are You Sure You Want To Destroy These Files ?"
				}
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					continue
				}
				Block "Deleting Selected Files"
				set blist_change 0
				set save_mixmanage 0
				set nessupdate 0
				catch {unset delete_mixmanage}
				foreach i $ilist {
					set newfile [$dl get $i] 
					if {[string length $hidden_dir] > 0} {
						set newfile [file join $hidden_dir $newfile]
					}
					if {![DeleteFileFromSystem $newfile 0 1]} {
						Inf "Cannot Delete File '$newfile'"
					} else {
						DummyHistory $newfile "DESTROYED"
						if {[info exists mixmanage($newfile)]} {
							unset mixmanage($newfile)
							set save_mixmanage 1
						}
						if {[info exists nesstype($newfile)]} {
							PurgeNessData $newfile
							set nessupdate 1
						}
						if {[IsInAMixfile $newfile]} {
							lappend delete_mixmanage $newfile
						}
						set i [LstIndx $newfile $wl]	;#	remove from workspace listing, if there
						if {$i >= 0} {
							$wl delete $i
							WkspCnt $newfile -1
							catch {unset rememd}
						}
					}
				}
				if {$blist_change} {
					SaveBL $background_listing
				}
				if {[info exists delete_mixmanage]} {
					MixM_ManagedDeletion $delete_mixmanage
					set save_mixmanage 1
				}
				if {$save_mixmanage} {
					MixMStore
				}
				if {$nessupdate} {
					NessMStore
				}
				catch {unset delete_mixmanage}
				set save_mixmanage 0
				set nessupdate 0
				set cnt 0
				set total_file_cnt 0
				foreach fnam [lsort -dictionary [glob -nocomplain [file join $wksp_dirname *]]] {
					incr total_file_cnt
					if [IsListableFile $fnam] {
						incr cnt
					}
				}
				if {$cnt == 0} {
					if {$total_file_cnt > 0} {
						Inf "WARNING: There Are non-CDP Files Or CDP-system Files In The Directory!!!!"
					}
					set choice [tk_messageBox -type yesno -default yes \
					-message "Delete Directory '$wksp_dirname' ?" -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						if [catch {file delete -force $wksp_dirname} zib] {
							Inf "Cannot Delete Directory '$wksp_dirname'"
							PurgeDirs $wksp_dirname 0 
						} else {
							PurgeDirs $wksp_dirname 1
						}
					} else {
						PurgeDirs $wksp_dirname 0 
					}
					UnBlock
					GetSuperdir
					Block "Deleted All Files"
				}
			} elseif {$pr_5 == $evv(DO_FIND)} {
				set ilist [$dl curselection]
				if {[llength $ilist] <= 0} {
					Inf "No Items Selected"
					continue
				}
				set zaqclear 0
				foreach i $ilist {
					set thisfnam [$dl get $i]
					if {[string length $hidden_dir] > 0} {
						set thisfnam [file join $hidden_dir $thisfnam]
					}
					set zaq [LstIndx $thisfnam $wl]
					if {$zaq >= 0} {
						if {!$zaqclear} {
							$wl selection clear 0 end
							set zaqclear 1
						}
						$wl selection set $zaq
					}
				}
				if {$zaqclear && ($total_wksp_cnt > 0)} {
					$wl yview moveto [expr double($zaq)/double($total_wksp_cnt)]
				} else {
					Inf "File(s) Not Found On Worskapce"
				}
				Block "Found Files"
			} else {		;# DO_GRAB or DO_COPY
				$wl selection clear 0 end
				catch {unset wl_finds}
				set ilist [$dl curselection]
				if {[llength $ilist] <= 0} {
					if {[$dl index end] == 1} {
						set ilist 0
					} else {
						Inf "No Item Selected"
						continue
					}
				}
				Block "Grabbing Selected Files"
				if {[llength $ilist] == 1} {
					set newfile	[$dl get [lindex $ilist 0]]
					if {[string length $hidden_dir] > 0} {
						set newfile [file join $hidden_dir $newfile]
					}
				 	if [file isdirectory $newfile] {
						Inf "'$newfile' Is A Subdirectory, Not A File"
						UnBlock
						continue
					}
				}
				set zqhh 0
				catch {unset zqh}
				catch {unset zzzqh}
				foreach indx $ilist {					;#	checks to see if each newfile already on workspace 
					set newfile [$dl get $indx]			;#	[if so, returns 0, merely skips it]
					if {[string length $hidden_dir] > 0} {
						set newfile [file join $hidden_dir $newfile]
					}
					incr zqhh
				 	if [file isdirectory $newfile] {
						lappend zqh $newfile
						continue
# FIX ENSURES FILES ARE COPIED TO BOTH Wkspace AND Chlist (WHERE NESS) IN SAME ORDER AS ON DIRECTORY LISTING
					} else {
						lappend zzzqh $newfile
					}
				}
				if {[info exists zzzqh]} {
					set zzzqh [ReverseList $zzzqh]
					catch {unset chnulist}
					foreach newfile $zzzqh {
						wm title .blocker  "PLEASE WAIT:      PARSING AND LOADING FILE [file rootname [file tail $newfile]]"
						if {$pr_5 == $evv(DO_COPY)} {
							if {[FileToWkspace $newfile 0 1 0 1 1] > 0} {
								lappend chnulist [file tail $newfile]
							}
						} elseif {$pr_5 == $evv(DO_SPECIAL_COPY)} {
							set newfile [CopyToStandardFormat $newfile]
							if {[string length $newfile] > 0} {
								if {[FileToWkspace $newfile 0 0 0 1 0] > 0} {
									lappend chnulist $newfile
								}
							}
						} else {
							if {[FileToWkspace $newfile 0 0 0 1 0] > 0} {
								lappend chnulist $newfile
							}
						}
					}
					if {$wksp_in_chose_mode && [info exists chnulist]} {
						set zzzqh [ReverseList $chnulist]
						foreach	fnam $zzzqh {
							lappend chlist $fnam
			 				$ch insert end $fnam
							incr chcnt
						}
					}
					if {[info exists chnulist]} {
						set save_mixmanage 0
						set nessupdate 0
						foreach zfnam $chnulist {
							if {[UpdatedIfAMix $zfnam 0]} {
								set save_mixmanage 1
							} elseif {[UpdatedIfANessFull $zfnam]} {	;#	If NESS initiated, checks for ness data files, and stores in (or checks) management list
								set nessupdate 1
							}
						}
						if {$save_mixmanage} {
							MixMStore
						}
						if {$nessupdate} {
							NessMStore
						}
						set save_mixmanage 0
						set nessupdate 0
						$wl selection clear 0 end
						set xlen [llength $chnulist]
						set kg 0
						while {$kg < $xlen} {
							$wl selection set $kg
							incr kg
						}
					}
				}
				if {[info exists zqh] && ([llength $zqh] == $zqhh)} {
					Inf "All The Items You Selected Were Subdirectories"
				} else {
					$wl yview moveto 0.0
				}
				if {[info exists wl_finds]} {
					AdjustWkspaceView [lindex $wl_finds end]
				}
			}
			UnBlock
			if {$is_terminating} {
				set finished 1
			}
		} elseif {$pr_5 == 0} {
			set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
			if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
				continue
			} elseif {([string length $dirname] > 0) && (![file isdirectory $dirname])} {
			 	Inf "Invalid Directory Name Given"
				continue
			}
			UpdateRecentDirs $dirname
			$dl delete 0 end
			foreach fnam [lsort -dictionary [glob -nocomplain [file join $dirname *]]] {
				if [IsListableFile $fnam] {
#JUNE 30 UC-LC FIX
					set fnam [string tolower $fnam]
					$dl insert end $fnam		;#	and place them in the listing window
				}
			}
			set hidden_dir ""
		} else {
			set finished 1
		}
	}
	$dl xview moveto 0.0
}

#############
# WORKSPACE #
#############

#------ Move selected files to top of workspace

proc TopOfWkspace {sorted} {
	global wl tosomewhere

	catch {unset tosomewhere}
	set ilist [$wl curselection]		
	if {[llength $ilist] <= 0} {		
		Inf "No Items Selected"
		return
	}
	if {$sorted < 0} {
		set reverse 1
		set sorted [expr -$sorted]
	} else {
		set reverse 0
	}
	if {($sorted == 2) || ($sorted == 3)} {
		set cnt 0
		foreach i $ilist {
			set fnam [file rootname [file tail [$wl get $i]]]
			if {![regexp {[0-9]+} $fnam]} {
				Inf "Not All The Files Have Numeric Parts To Their Names"
				return
			} 
			if {$sorted == 2} {
				set numends [GetNumericEndPart $fnam]
			} else {
				set numends [GetNumericStartPart $fnam]
			}
			set num [string range $fnam [lindex $numends 0] [lindex $numends 1]]
			lappend dlist [list $i $num]
			incr cnt
		}
		set cnt_less_one [expr $cnt - 1]
		set n 0
		while {$n < $cnt_less_one} {
			set dlist_n [lindex $dlist $n]
			set num_n [lindex $dlist_n 1]
			set m [expr $n + 1]
			while {$m < $cnt} {
				set dlist_m [lindex $dlist $m]
				set num_m [lindex $dlist_m 1]
				if {$num_m < $num_n} {
					set dlist [lreplace $dlist $m $m $dlist_n]
					set dlist [lreplace $dlist $n $n $dlist_m]
					set dlist_n $dlist_m
					set num_n $num_m
				}
				incr m
			}
			incr n
		}
		set ilist {}
		foreach dd $dlist {
			lappend ilist [lindex $dd 0]
		}
	} elseif {$sorted == 4} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				lappend s_list $i
			}
		}
		if {![info exists s_list]} {
			Inf "No Sound Files Selected"
			return
		}
		set ilist $s_list
	}	
	foreach i $ilist {
		lappend newlist [$wl get $i]
	}
	if {$sorted == 1} {
		set newlist [lsort -dictionary $newlist]
	}
	set j 0 
	foreach fnam [$wl get 0 end] {
		if {[lsearch -exact $ilist $j] < 0} {
			lappend newlist [$wl get $j]
		}
		incr j
	}
	if {$reverse} {
		set newlist [ReverseList $newlist]
	}
	$wl delete 0 end
	foreach fnam $newlist {
		$wl insert end $fnam
	}
}

#------ Move selected files from top of workspace

proc FromTopOfWkspace {} {
	global wl tosomewhere

	catch {unset tosomewhere}
	set ilist [$wl curselection]		
	if {[llength $ilist] <= 0} {		
		Inf "No Position Selected"
		return
	}
	if {[llength $ilist] > 1} {
		Inf "More Than One Position Selected"
		return
	}
	set i [lindex $ilist 0]
	if {$i == 0} {
		set fnam0 [$wl get 0]
		set fnam1 [$wl get 1]
		$wl delete 0
		$wl insert 0 $fnam1
		$wl delete 1
		$wl insert 1 $fnam0
	} else {
		set newlist [$wl get 1 $i]
		lappend newlist [$wl get 0]
		if {$i < [$wl index end]} {
			incr i
			foreach item [$wl get $i end] {
				lappend newlist $item
			}
		}
		$wl delete 0 end
		foreach fnam $newlist {
			$wl insert end $fnam
		}
	}
}

#------ Move selected files to foot of workspace

proc FootOfWkspace {} {
	global wl tosomewhere

	catch {unset tosomewhere}
	set ilist [$wl curselection]		
	if {[llength $ilist] <= 0} {		
		Inf "No Items Selected"
		return
	}
	set j 0 
	foreach fnam [$wl get 0 end] {
		if {[lsearch -exact $ilist $j] < 0} {
			lappend newlist [$wl get $j]
		}
		incr j
	}
	foreach i $ilist {
		lappend newlist [$wl get $i]
	}
	$wl delete 0 end
	foreach fnam $newlist {
		$wl insert end $fnam
	}
}

#------ If filename changed, update names in memory stores, if ness

proc UpdateChosenFileMemory {fnam nufnam} {
	global last_outfile last_ch lalast_ch 

	if [info exists last_outfile] {
		set ii [lsearch -exact $last_outfile $fnam]
		if {$ii >= 0} {
			set last_outfile [lreplace $last_outfile $ii $ii $nufnam]
		}
	}
	if [info exists last_ch] {
		set ii [lsearch -exact $last_ch $fnam]
		if {$ii >= 0} {
			set last_ch [lreplace $last_ch $ii $ii $nufnam]
		}
	}
	if [info exists lalast_ch] {
		set ii [lsearch -exact $lalast_ch $fnam]
		if {$ii >= 0} {
			set lalast_ch [lreplace $lalast_ch $ii $ii $nufnam]
		}
	}
}

#------ Get last set of files used

proc GetLastChosenList {} {
	global last_ch lalast_ch chlist ch chcnt previous_ch

	if {![info exists last_ch] || ([llength $last_ch] <= 0)} {
		return
	}
	if {![info exists previous_ch]} {
		set previous_ch {}
		if {[info exists chlist] && ([llength $chlist] > 0)} {
			set previous_ch $chlist
		}
		EnableRestoreChosenList
	}
	if {[info exists chlist] && ([llength $chlist] == [llength $last_ch])} {
		if {[info exists lalast_ch] && ([llength $lalast_ch] > 0)} {
			set ok 1
			foreach fnam $chlist lastname $last_ch {
				if {![string match $fnam $lastname]} {
					set ok 0
					break
				}
			}
			if {$ok} {									;#	IF chosen list has not changed, get last_last_list
				ClearWkspaceSelectedFiles
				UnsetThumbnail
				foreach fnam $lalast_ch {
					if [file exists $fnam] {
						lappend chlist $fnam		;#	add to end of list
						$ch insert end $fnam		;#	add to end of display
						incr chcnt
					} else {
						lappend bumlist $fnam
					}
				}
				if {[info exists bumlist]} {
					if {[llength $bumlist] == 1} {
						Inf "File [lindex $bumlist 0] No Longer Exists"
					} else {
						set msg "The Following Files No Longer Exist"
						set cnt 0
						foreach fnam $bumlist {
							if {$cnt >= 20} {
								append msg "\nAND MORE"
								break
							}
							append msg "\n$fnam"
							incr cnt
						}
						Inf $msg
					}
				}
				return
			}
		}
	}
	ClearWkspaceSelectedFiles
	UnsetThumbnail
	foreach fnam $last_ch {
		if [file exists $fnam] {
			lappend chlist $fnam		;#	add to end of list
			$ch insert end $fnam		;#	add to end of display
			incr chcnt
		} else {
			Inf "File $fnam No Longer Exists"
		}
	}
	ChlistDupls
}

#------ Get last set of files used

proc ClearAndSaveChoice {} {
	global chlist sl_real ww

	if {!$sl_real} {
		Inf "This Button Clears The Window Below (So No Files Are 'Chosen'),\n\nBut The List Of Files Is Remembered\nAnd Can Be Restored With The 'Previous' Button."
		return
	}
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		return
	}
	UnsetThumbnail
	DoChoiceBak
	$ww.1.a.endd.r.rr.cnts config -readonlybackground [option get . readonlybackground {}]
	ClearWkspaceSelectedFiles
}

#------ Get Max sample in binary sndsystem OUTPUT  (or Chosen files list) file

proc GetMaxsamps {fromsrc force} {
	global smpsout from_runpage ins ins_concluding pa prompt77 origmixbak bulksplit
	global o_nam ins_file_lst wl ch bulk chlist sl_real evv pprg prm keptgain evv

	if {!$sl_real} {
		if {$fromsrc} {
			Inf "The Soundloom Finds The Maximum Sample In Any Source Files Input To This Process."
		} else {
			Inf "The Soundloom Searches The Output File To Find The Maximum Sample\nAnd Puts This Information In The File Header\nSo That It Can Be Found Instantly If You Ask Again."
		}
		return
	}
	set is_mix 0
	if {!($from_runpage || $ins_concluding)} {	;#	i.e. from workspace
		if {$fromsrc} {
			set ilist {}
			if {[info exists chlist]} {
				set jj [llength $chlist]
				set q 0
				while {$q < $jj} {
					lappend ilist $q
					incr q
				}
			}
		} else {
			set ilist [$wl curselection]
		}
		set lenn [llength $ilist]
		if {$lenn <= 0} {
			return
		} elseif {$lenn == 1} {
			if {$fromsrc} {
				set fnam [$ch get [lindex $ilist 0]]
			} else {
				set fnam [$wl get [lindex $ilist 0]]
			}
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				GetMaxsamp $fnam $force
				return
			} elseif {[IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
				if [catch {open $fnam "r"} fId] {
					Inf "Cannot Open Mixfile To Get Data On Soundfiles It Uses."
					return
				} else {
					if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
						set multichan 1
						set gotoutch 0
					} else {
						set multichan 0
					}
					set OK 0
					while {[gets $fId line] >= 0} {			;#	Look inside mixfile
						set line [split $line]
						set item [lindex $line 0]
						if [string length $item] {
							if {![string match \;* $item]} {
								if {$multichan && !$gotoutch} {
									set gotoutch 1
									continue
								}
								set item [string tolower $item]
								set item [RegulariseDirectoryRepresentation $item]
								set ftype [FindFileType $item]
								if {$ftype == $evv(SNDFILE)} {
									lappend smpoutlist $item
								}
							}
						}
					}
					close $fId
					if {[info exists smpoutlist]} {
						set force 1
					}
				}
			} else {
				Inf "'$fnam' Is Not A Soundfile."
				return
			}
		} else {
			foreach item $ilist {
				if {$fromsrc} {
					set fnam [$ch get $item]
				} else {
					set fnam [$wl get $item]
				}
				if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE)} {
					lappend smpoutlist $fnam
				}
			}
		}
	} elseif {$from_runpage && $fromsrc} {
		set ilist {}
		if {$ins(create)} {
			if {[info exists ins(chlist)]} {
				set jj [llength $ins(chlist)]
				set q 0
				while {$q < $jj} {
					lappend ilist $q
					incr q
				}
				set ll $ins(chlist)
			}
		} else {
			if {[info exists chlist]} {
				set jj [llength $chlist]
				set q 0
				while {$q < $jj} {
					lappend ilist $q
					incr q
				}
				set ll $chlist
			}
		}
		set lenn [llength $ilist]
		if {$lenn <= 0} {
			return
		} elseif {$lenn == 1} {
			set fnam [lindex $ll [lindex $ilist 0]]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				GetMaxsamp $fnam $force
				return
			} elseif {[IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
				if [catch {open $fnam "r"} fId] {
					Inf "Cannot Open Mixfile To Get Data On Soundfiles It Uses."
					return
				} else {
					if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
						set multichan 1
						set gotoutch 0
					} else {
						set multichan 0
					}
					set OK 0
					while {[gets $fId line] >= 0} {			;#	Look inside mixfile
						set line [split $line]
						set item [lindex $line 0]
						if [string length $item] {
							if {![string match \;* $item]} {
								if {$multichan && !$gotoutch} {
									set gotoutch 1
									continue
								}
								set item [string tolower $item]
								set item [RegulariseDirectoryRepresentation $item]
								if [info exists pa($item,$evv(FTYP))] {
									if {$pa($item,$evv(FTYP)) == $evv(SNDFILE)} {
										lappend tl $item	;#	If it's a sndfile on wkspace, 
										set OK 1			;#	add to list of files
									}		
								} else {
									lappend unknown_files $item
								}
							}
						}
					}
					close $fId
					if {$OK && [info exists tl]} {			;#	If none of snds in mixfile are on wkspace, discard data.
						set	smpoutlist $tl					;# 	Otherwise, replace filelist (=mixfile)
					} elseif [info exists unknown_files] {
						Inf "No File In The Mixfile '$fnam' Is On The Workspace"
						return
					}
					if [info exists unknown_files] {
						set msg "These Files Are Not On The Workspace\n\n"
						set i 0
						foreach item $unknown_files {
							append msg "$item\n"
							incr i
							if {$i > 10} {
								append msg "AND MORE"
								break
							}
						}
						Inf "$msg"
					}
					if {[info exists smpoutlist]} {
						set force 1
					}
				}
			} else {
				Inf "'$fnam' Is Not A Soundfile."
				return
			}
		} else {
			foreach item $ilist {
				set fnam [lindex $ll $item]
				if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE)} {
					lappend smpoutlist $fnam
				}
			}
		}
	} elseif {[info exists smpsout] && $smpsout <= 0} {
		return
	} else {
	 	if {$from_runpage} {
			if [info exists chlist] {
				if {$fromsrc} {
					if {$ins(create)} {
						set smpoutlist $ins(chlist)
					} else {
						set smpoutlist $chlist
					}
					if {[llength $smpoutlist] == 1} {
						set zwx [lindex $smpoutlist 0]
						if [info exists pa($zwx,$evv(FTYP))] {
							set ftyp $pa($zwx,$evv(FTYP))
							if {[IsAMixfileIncludingMultichan $ftyp]} {
								if [catch {open $zwx "r"} fId] {
									Inf "Cannot Open Mixfile To Get Data On Soundfiles It Uses."
								} else {
									if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
										set multichan 1
										set gotoutch 0
									} else {
										set multichan 0
									}
					 				set OK 0
									while {[gets $fId line] >= 0} {			;#	Look inside mixfile
										set line [split $line]
										set item [lindex $line 0]
										if [string length $item] {		;#	Ignoring spaces:comments,get 1st item on line.
											if {![string match \;* $item]} {	;# Ignore comment lines
												if {$multichan && !$gotoutch} {
													set gotoutch 1
													continue
												}
												set item [string tolower $item]
												set item [RegulariseDirectoryRepresentation $item]
												if [info exists pa($item,$evv(FTYP))] {
													if {$pa($item,$evv(FTYP)) == $evv(SNDFILE)} {
														lappend tl $item	;#	If it's a sndfile on wkspace, 
														set OK 1			;#	add to list of files
													}		
												} else {
													lappend unknown_files $item
												}
											}
										}
									}
									close $fId
									if {$OK && [info exists tl]} {			;#	If none of snds in mixfile are on wkspace, discard data.
										set	smpoutlist $tl					;# 	Otherwise, replace filelist (=mixfile)
										set is_mix 1						;# 	by list of files in mix which are on wkspace.
									} elseif [info exists unknown_files] {
										Inf "No File In The Mixfile '$zwx' Is On The Workspace"
										return
									}
								}
							}
						}
					}
					if {!$is_mix} {
						foreach fnam $smpoutlist {
							if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE)} {
								lappend tl $fnam
							}
						}
						if [info exists tl] {
							set smpoutlist $tl
						}
					}					
				} else {
					if {$ins(run) || $bulk(run)} {
						set namegroup $evv(MACH_OUTFNAME)  ;#	Collects outputs from ALL ins-processes
					} else {
						set namegroup $o_nam				 ;#	Collects normal outs, or current Instrumentcreateprocess outs
					}
					foreach fnam [lsort -dictionary [glob -nocomplain $namegroup*]] {
						if {[info exists origmixbak] && [string match $fnam $origmixbak]} {
							continue
						}
						if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE)} {
							lappend smpoutlist $fnam
						}
					}					
				}
			} elseif {!$fromsrc} {
#NEW OPTION FOR PROCESSES TAKING NO INPUT FILES BUT GENERATING OUTPUT!!
				if {$ins(run)} {
					set namegroup $evv(MACH_OUTFNAME)  ;#	Collects outputs from ALL ins-processes
				} else {
					set namegroup $o_nam				 ;#	Collects normal outs, or current Instrumentcreateprocess outs
				}
				foreach fnam [lsort -dictionary [glob -nocomplain $namegroup*]] {
					if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE)} {
						lappend smpoutlist $fnam
					}
				}					
			}
		} elseif {$ins_concluding} {
			foreach fnam [$ins_file_lst get 0 end] {
				if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_SNDSYSTEM_FILE)} {
					lappend smpoutlist $fnam
				}
			}
		}
		if [info exists unknown_files] {
			set msg "These Files Are Not On The Workspace\n\n"
			set i 0
			foreach item $unknown_files {
				append msg "$item\n"
				incr i
				if {$i > 10} {
					append msg "And More"
					break
				}
			}
			Inf "$msg"
		}
		if {[info exists smpoutlist] && ([llength $smpoutlist] == 1)} {
			set fffnam [lindex $smpoutlist 0]
			if {$pa($fffnam,$evv(FTYP)) != $evv(SNDFILE)} {
				Inf "No Soundfiles Here"
				return
			}
			GetMaxsamp $fffnam $force
			if {[info exists keptgain] && [IsNumeric $keptgain]} {
				ResetMasterGain $keptgain $fffnam
			}
			return
		}
	}
	if [info exists smpoutlist] {
		if {[info exists bulksplit]} {
			GetMaxsampBulksplit $smpoutlist
			return
		}
		catch {unset sfsysexlist}
		set k_k 0
		foreach fffnam $smpoutlist {
			set fftyp [FindFileType $fffnam]
			if {$fftyp == $evv(SNDFILE)} {
				if {[string match $fffnam cdptest000$evv(SNDFILE_EXT)]} {
					set thumbhere $k_k
				}
				lappend sfsysexlist $fffnam
			}
			incr k_k
		}
		if {![info exists sfsysexlist]} {
			Inf "No Soundfiles Here"
			return
		} else {
			set smpoutlist $sfsysexlist
		}
		if {[llength $smpoutlist] > 1} {
			if {[info exists thumbhere]} {
				set smpoutlist [lreplace $smpoutlist $thumbhere $thumbhere]
			}
		}
		if {[llength $smpoutlist] == 1} {
			set fffnam [lindex $smpoutlist 0]
			GetMaxsamp $fffnam $force
			return
		}
		set f .maxsamplist
		if [Dlg_Create $f "Get Maximum Sample from File" "set prompt77 0" -borderwidth $evv(BBDR)] {
			button $f.quit -text "Close" -command "set prompt77 0" -highlightbackground [option get . background {}]
			Scrolled_Listbox $f.list -width 48 -height 12 -selectmode single
			pack $f.quit $f.list -side top
			bind $f <Escape>  {set prompt77 0}
			bind $f <Return>  {set prompt77 0}
			bind $f <Key-space> {set prompt77 0}
		}
		wm resizable $f 1 1
		bind $f.list.list <ButtonRelease-1> "Get_Maxsamp %W $force"
		$f.list.list delete 0 end
		foreach fnam $smpoutlist {
			$f.list.list insert end $fnam
		}
		raise $f
		set prompt77 0
		My_Grab 0 $f prompt77 $f.list.list
		tkwait variable prompt77
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
	} elseif {$from_runpage || $ins_concluding} {	;#	i.e. not from workspace
		if {$fromsrc} {
			Inf "No Appropriate Input Files Exist."
		} else {
			Inf "No Appropriate Output Files Exist."
		}
	} elseif {$fromsrc} {
		Inf "No Appropriate Chosen Files Exist."
	} else {
		Inf "No Appropriate Workspace Files Selected."
	}
}

#------ Get max sample of file selected from list

proc Get_Maxsamp {w force} {
	set hindx [$w curselection]
	if {[string length $hindx] <= 0} {
		return
	}
	set fnam [$w get $hindx]
	GetMaxsamp $fnam $force
}

#------ Get max sample in file

proc GetMaxsamp {fnam force} {
	global CDPmaxId pr_maxsamp done_maxsamp maxsamp_display pa maxsamp_line mu maxsamp_missing pprg evv
	global keptgain

	catch {unset keptgain}
	set f .maxsamp
	if [Dlg_Create $f "Maximum sample" "set pr_maxsamp 1" -borderwidth $evv(SBDR)] {
		button $f.ok -text "OK" -command "set pr_maxsamp 1" -highlightbackground [option get . background {}]
		set maxsamp_display [Scrolled_Listbox $f.listing -width 60 -height 12]
		pack $f.ok $f.listing -side top
		wm resizable $f 1 1
		bind .maxsamp <Escape> {set pr_maxsamp 1}
		bind .maxsamp <Return> {set pr_maxsamp 1}
		bind .maxsamp <Key-space> {set pr_maxsamp 1}
	}
	catch {unset maxsamp_line}
	raise $f
	set pr_maxsamp 0
	My_Grab 0 $f pr_maxsamp
	.maxsamp.listing.list delete 0 end
	.maxsamp.listing.list insert end "FILE: $fnam"
	.maxsamp.listing.list insert end ""

	if {!$force && [info exists pa($fnam,$evv(MAXREP))]} {						;#	MAxval NOT forced to be recalcd AND maxval known
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {	;#	Sound file
			.maxsamp.listing.list insert end "Maximum ABSOLUTE sample:      $pa($fnam,$evv(MAXSAMP))"
			set secs [expr double($pa($fnam,$evv(MAXLOC))) / double($pa($fnam,$evv(SRATE)))]
			if {$secs < 60.0} {
				.maxsamp.listing.list insert end "Location of maximum sample:      $secs sec"
			} else {
				set mins [expr floor($secs / 60.0)]
				set secs [expr $secs - ($mins * 60.0)]
				if {$mins < 60.0} {
					.maxsamp.listing.list insert end "Location of maximum sample:      $mins mins $secs sec"
				} else {
					set hrs [expr floor($mins / 60.0)]
					set mins [expr $mins - ($hrs * 60.0)]
					.maxsamp.listing.list insert end "Location of maximum sample:      $hrs hrs $mins mins $secs sec"
				}
			}
			set chans $pa($fnam,$evv(CHANS))
			.maxsamp.listing.list insert end "Location as sample count:            [expr $pa($fnam,$evv(MAXLOC)) * $chans]"
			if { $chans > 1} {
				set str $pa($fnam,$evv(CHANS))
				append str "-sample count"
				.maxsamp.listing.list insert end "Location as $str:       $pa($fnam,$evv(MAXLOC))"
			}
			if {$pa($fnam,$evv(MAXSAMP)) <= 0.0} {
				set gain "NO GAIN POSSIBLE"
				set dbgain $gain
			} else {
				set gain [expr double($mu(MAXFSAMPVAL)) / $pa($fnam,$evv(MAXSAMP))]
				set dbgain [expr 20.0 * log10($gain)]
			}
			if {$pa($fnam,$evv(MAXREP)) > 0} {
				.maxsamp.listing.list insert end "Number of times found:            $pa($fnam,$evv(MAXREP))"
			}
			.maxsamp.listing.list insert end "Maximum possible dB gain:        $dbgain"
			.maxsamp.listing.list insert end "Maximum possible gain factor:    $gain"
			set keptgain [DecPlaces $gain 2]
		}
	} else {				;#	Need to get maxval
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			My_Release_to_Dialog $f
			Dlg_Dismiss $f
			return
		} else {
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			if [info exists maxsamp_missing] {
				Inf "maxsamp2$evv(EXEC) Is Not On Your System.\nCannot Search File For Maximum Sample In File."
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return
			} elseif [ProgMissing $cmd "Cannot search file for maximum sample in file."] {
				set maxsamp_missing 1
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return
			}
			lappend cmd $fnam
			if {$force} {
				lappend cmd 1		;#	1 flag added to FORCE read of maxsample
			}
			if [catch {open "|$cmd"} CDPmaxId] {
				ErrShow "$CDPmaxId"
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				return
	   		} else {
				if {$force} {
					Block "Calculating maximum"
				}
	   			fileevent $CDPmaxId readable "Display_Maxsamp_Info"
			}
	 		vwait done_maxsamp
			if {$force} {
				UnBlock
			}
			if {[info exists maxsamp_line]} {
				set pa($fnam,$evv(MAXSAMP)) [lindex $maxsamp_line 0]
				set pa($fnam,$evv(MAXLOC))  [lindex $maxsamp_line 1]
				set pa($fnam,$evv(MAXREP))  [lindex $maxsamp_line 2]
				if {$pa($fnam,$evv(MAXSAMP)) > 0.0} {
					set keptgain [DecPlaces [expr 1.0 / $pa($fnam,$evv(MAXSAMP))] 2]
	                   
					if {$keptgain > 1.0} {
							set keptgain [DecPlaces [expr 0.95 / $pa($fnam,$evv(MAXSAMP))] 2]
					} else {
						set keptgain [DecPlaces [expr $keptgain - 0.01] 2]
					}
				}
			} else {
				Inf "No Maximum Sample Information Retrieved"
			}
		}
	}
	tkwait variable pr_maxsamp
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Get max sample in file input to workspace

proc GetMaxsampOnInput {fnam} {
	global CDPmaxId pr_maxsamp done_maxsamp maxsamp_display pa maxsamp_line maxsamp_missing maxsamp2_version evv

	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		return
	}
	catch {unset maxsamp_line}
	set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
	if {[info exists maxsamp_missing] || [ProgMissing $cmd "Cannot search file for maximum sample."]} {
		set maxsamp_missing 1
		return
	}
	lappend cmd $fnam
	if {$maxsamp2_version >= 6} {
		lappend cmd 2
	}
	if [catch {open "|$cmd"} CDPmaxId] {
		ErrShow "$CDPmaxId"
		return
   	} else {
   		fileevent $CDPmaxId readable "Maxsamp_Info"
	}
 	vwait done_maxsamp
	if [info exists maxsamp_line] {
		set pa($fnam,$evv(MAXSAMP)) [lindex $maxsamp_line 0]
		set pa($fnam,$evv(MAXLOC))  [lindex $maxsamp_line 1]
		set pa($fnam,$evv(MAXREP))  [lindex $maxsamp_line 2]
	} elseif {![string match [file extension $fnam] ".amb"]} {
		Inf "No Maximum Sample Information Found : File $fnam""
	}
}

#------ Display info returned by maxsamp

proc Display_Maxsamp_Info {} {
	global CDPmaxId done_maxsamp maxsamp_display maxsamp_line

	if [eof $CDPmaxId] {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		}
		if [string match KEEP:* $line] {
#			set maxsamp_line $line
			set maxsamp_line [string range $line 6 end] 
		} elseif [string match INFO:* $line] {
			set line [string range $line 6 end] 
			.maxsamp.listing.list insert end "$line"
		} elseif [string match WARNING:* $line] {
			set line [string range $line 9 end] 
			.maxsamp.listing.list insert end "$line" {warning}
		} elseif [string match ERROR:* $line] {
			set line [string range $line 7 end] 
			.maxsamp.listing.list insert end "$line" {error}
			return
		} else {
			ErrShow "INVALID MESSAGE ($line) RECEIVED FROM PROGRAM."
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		}
	}
	update idletasks
}			

#------ Store info returned by maxsamp

proc Maxsamp_Info {} {
	global CDPmaxId done_maxsamp maxsamp_line

	if [eof $CDPmaxId] {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		}
		if [string match KEEP:* $line] {
			set maxsamp_line $line
		}
	}
	update idletasks
}			

#------ Invert chosen list

proc FlipList {tl} {
	global ch chlist ins_file_lst

	switch -- $tl {
		process {
			if [info exists chlist] {
				set k [llength $chlist]
				if {$k > 1} {
					while {$k > 0} {
						incr k -1
						lappend newlist [lindex $chlist $k]
					}
					DoChoiceBak
					set chlist $newlist
					$ch delete 0 end
					foreach item $chlist {
						$ch insert end $item
					}		
				}
			}
		}
		ins {
			if {[$ins_file_lst index end] > 0} {
				foreach fnam [$ins_file_lst get 0 end] {
					lappend newlist $fnam
				}
				$ins_file_lst delete 0 end
				foreach fnam $newlist {
					$ins_file_lst insert 0 $fnam
				}
			}
		}
	}
}

#------ Rotate chosen list

proc RotateList {z} {
	global ch chlist ins_file_lst

	if [info exists chlist] {
		set k [llength $chlist]
		if {$k > 1} {
			if {$z > 0} {
				set n 1
				while {$n < $k} {
					lappend newlist [lindex $chlist $n]
					incr n
				}
				lappend newlist [lindex $chlist 0]
			} else {
				lappend newlist [lindex $chlist end]
				incr k -1
				set n 0
				while {$n < $k} {
					lappend newlist [lindex $chlist $n]
					incr n
				}
			}
			DoChoiceBak
			set chlist $newlist
			$ch delete 0 end
			foreach item $chlist {
				$ch insert end $item
			}		
		}
	}
}

#------ Randomise list

proc RandomiseList {} {
	global mix_perm ch chlist sl_real

	if {!$sl_real} {
		return
	}
	if {![info exists chlist]} {
		return
	}
	set i 0
	foreach item $chlist {
		set mix_perm($i) $i
		incr i
	}
	set setlen $i
	RandomiseOrder $setlen
	set i 0
	while {$i < $setlen} {
		lappend newlist [lindex $chlist $mix_perm($i)]
		incr i
	}
	DoChoiceBak
	set chlist $newlist
	$ch delete 0 end
	foreach item $chlist {
		$ch insert end $item
	}		
}

#------ Interleave chosen list

proc InterleaveList {fact} {
	global ch chlist chcnt ins_file_lst pr_interlef interlef_n interlef_lim readonlyfg evv

	if {![info exists chlist] || ([llength $chlist] < 3)} {
		return
	}
	if {$fact == 2} {
		set k [llength $chlist]
		if {$k < 3} {
			return
		}
		DoChoiceBak
		set kh [expr int(floor($k / 2))]
		set kk [expr int($kh * 2)]
		if {$kk != $k} {
			incr kh
		}
		set jh 0
		set kk $kh
		while {$kh < $k} {
			lappend newlist [lindex $chlist $jh]				
			lappend newlist [lindex $chlist $kh]				
			incr jh
			incr kh
		}
		while {$jh < $kk} {
			lappend newlist [lindex $chlist $jh]				
			incr jh
		}			
		set chlist $newlist
		$ch delete 0 end
		set chcnt 0
		foreach item $chlist {
			$ch insert end $item
			incr chcnt
		}		
	} else {
		set f .interlef
		if [Dlg_Create $f "" "set pr_interlef 0" -borderwidth $evv(SBDR)] {
			frame $f.0
			button $f.0.ok -text "Interleave" -command "set pr_interlef 1"
			button $f.0.qu -text "Abandon" -command "set pr_interlef 0"
			pack $f.0.ok -side left
			pack $f.0.qu -side right
			pack $f.0 -side top -fill x -expand true

			frame $f.1
			label $f.1.ll -text "Gather every Nth item (N >= 2)"
			entry $f.1.e -textvariable interlef_n -width 8 -state readonly -foreground $readonlyfg
			set interlef_n 2
			pack $f.1.e $f.1.ll -side left
			pack $f.1 -side top -fill x -expand true

			label $f.2 -text "Use \"Up\" and \"Down\" Arrows to change value" -fg $evv(SPECIAL)
			pack $f.2 -side top -fill x -expand true

			wm resizable $f 0 0
			bind $f <Up>	{IncrInterlef 0}
			bind $f <Down>	{IncrInterlef 1}
			bind $f <Return> {set pr_interlef 1}
			bind $f <Escape> {set pr_interlef 0}
		}
		set len [llength $chlist]
		set interlef_lim $len
		incr interlef_lim -1
		raise $f
		update idletasks
		StandardPosition $f
		set pr_interlef 0
		My_Grab 0 $f pr_interlef $f.1.e
		set finished 0
		while {!$finished} {
			tkwait variable pr_interlef
			if {$pr_interlef} {
				if {[string length $interlef_n] <= 0} {
					Inf "No Interleaving Value Entered"
					continue
				}
				if {![IsNumeric $interlef_n] || ![regexp {^[0-9]+$} $interlef_n] || ($interlef_n < 2)} {
					Inf "Invalid Interleaving Value (integer >= 2)"
					continue
				}
				if {$interlef_n >= $len} {
					Inf "Interleaving Value Too Large For Number Of Chosen Sounds ($len)"
					continue
				}
				set nbas 0
				while {$nbas < $interlef_n} {
					set n $nbas
					while {$n < $len} {
						lappend newlist [lindex $chlist $n]
						incr n $interlef_n
					}
					incr nbas
				}
				DoChoiceBak
				set chlist $newlist
				$ch delete 0 end
				set chcnt 0
				foreach item $chlist {
					$ch insert end $item
					incr chcnt
				}		
				set finished 1
			} else {
				set finished 1
			}
		}
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
	}
}

proc IncrInterlef {down} {
	global interlef_n interlef_lim chlist

	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		return
	}
	if {([string length $interlef_n] <= 0) || ![IsNumeric $interlef_n] || ![regexp {^[0-9]+$} $interlef_n]} {
		return
	}
	if {$down} {
		if {$interlef_n > 2} {
			incr interlef_n -1
		}
	} else {
		if {$interlef_n < $interlef_lim} {
			incr interlef_n
		}
	}
}

#------ Interleave chosen list

proc InterleavePat {} {
	global ch chlist chcnt pr_interlfp interlfpat1 interlfpat2 evv

	if {![info exists chlist] || ([llength $chlist] < 2)} {
		return
	}

	set f .interlfp
	if [Dlg_Create $f "INTERLEAVE BY PATTERN" "set pr_interlfp 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.ok -text "Interleave" -command "set pr_interlfp 1" -highlightbackground [option get . background {}]
		button $f.0.qu -text "Abandon" -command "set pr_interlfp 0" -highlightbackground [option get . background {}]
		pack $f.0.ok -side left
		pack $f.0.qu -side right
		pack $f.0 -side top -fill x -expand true

		frame $f.1
		label $f.1.ll -text "Pattern" -width 10
		entry $f.1.e -textvariable interlfpat1 -width 120
		set interlfpat ""
		pack $f.1.ll $f.1.e -side left -pady 4
		pack $f.1 -side top -fill x -expand true

		frame $f.2
		label $f.2.ll -text "Replace by" -width 10
		entry $f.2.e -textvariable interlfpat2 -width 120
		set interlfpat ""
		pack $f.2.ll $f.2.e -side left -pady 4
		pack $f.2 -side top -fill x -expand true

		wm resizable $f 0 0
		bind $f.1.e <Down> {focus .interlfp.2.e}
		bind $f.2.e <Down> {focus .interlfp.1.e}
		bind $f.1.e <Up>   {focus .interlfp.2.e}
		bind $f.2.e <Up>   {focus .interlfp.1.e}
		bind $f <Return> {set pr_interlfp 1}
		bind $f <Escape> {set pr_interlfp 0}
	}
	raise $f
	update idletasks
	StandardPosition $f
	set pr_interlfp 0
	My_Grab 0 $f pr_interlfp $f.1.e
	set finished 0
	while {!$finished} {
		tkwait variable pr_interlfp
		if {$pr_interlfp} {
			set OK 1
			set interlfpat1 [string trim $interlfpat1]
			if {[string length $interlfpat1] <= 0} {
				Inf "No interleaving pattern entered"
				continue
			}
			set n 0 
			catch {unset inpattern}
			catch {unset outpattern}
			catch {unset nuindeces}
			set qqq [split $interlfpat1]
			foreach item $qqq {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				set len [string length $item]
				set k 0
				while {$k < $len} {
					set c [string index $item $k]
					if {![regexp {[a-zA-Z]} $c]} {
						Inf "Non alphabetic character \"$c\" in pattern"
						set OK 0
						break
					}
					incr k
				}
				if {!$OK} {
					break
				}
				if {[info exists inpattern] && ([lsearch -exact $inpattern $item] >= 0)} {
					Inf "Repeated item \"$item\" in pattern"
					set OK 0
					break
				}
				lappend inpattern $item
				incr n
			}
			if {!$OK} {
				continue
			}
			set inlen $n

			set kk [expr $chcnt/$inlen]
			if {[expr $kk * $inlen] != $chcnt} {
				Inf "Length of pattern ($inlen) is not an integral divisor of number of chosen files ($chcnt)"
				continue
			}
			set interlfpat2 [string trim $interlfpat2]
			if {[string length $interlfpat2] <= 0} {
				Inf "No replacement pattern entered"
				continue
			}
			set n 0 
			set qqq [split $interlfpat2]
			foreach item $qqq {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				set len [string length $item]
				set k 0
				while {$k < $len} {
					set c [string index $item $k]
					if {![regexp {[a-zA-Z]} $c]} {
						Inf "Non alphabetic character \"$c\" in replacement pattern"
						set OK 0
						break
					}
					incr k
				}
				if {!$OK} {
					break
				}
				if {[info exists outpattern] && ([lsearch -exact $outpattern $item] >= 0)} {
					Inf "Repeated item \"$item\" in replacement-pattern"
					set OK 0
					break
				}
				if {[lsearch -exact $inpattern $item] < 0} {
					Inf "Item \"$item\" in replacement-pattern is not in the original pattern"
					set OK 0
					break
				}
				lappend outpattern $item
				incr n
			}
			if {!$OK} {
				continue
			}
			if {$inlen != $n} {
				Inf "Pattern length ($inlen) and replacement-pattern length ($n) are not the same"
				continue
			}
			set n 0
			foreach item $outpattern {				;#	REPLACE PATTERN ITEMS BY NUMBERS
				set k [lsearch -exact $inpattern $item]
				lappend nuindeces $k
				incr n
			}
			set nuchlist {}
			set n 0
			set m $n
			incr m $inlen
			incr m -1
			while {$n < $chcnt} {
				set outlist {}
				set inlist [lrange $chlist $n $m]
				set k 0
				while {$k < $inlen} {
					set item [lindex $inlist [lindex $nuindeces $k]]
					lappend outlist $item
					incr k
				}
				set nuchlist [concat $nuchlist $outlist]
				incr n $inlen
				incr m $inlen
			}
			set chlist $nuchlist
			$ch delete 0 end
			foreach item $chlist {
				$ch insert end $item
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Interleave chosen list using a sequence of namings

proc InterleaveName {} {
	global ch chlist chcnt pr_interlnam interlnam1 interlnam2 evv

	if {![info exists chlist] || ([llength $chlist] < 2)} {
		return
	}
	set chnams $chlist
	set f .interlnam
	if [Dlg_Create $f "INTERLEAVE BY NAME" "set pr_interlnam 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.ok -text "Interleave" -command "set pr_interlnam 1" -highlightbackground [option get . background {}]
		button $f.0.qu -text "Abandon" -command "set pr_interlnam 0" -highlightbackground [option get . background {}]
		pack $f.0.ok -side left
		pack $f.0.qu -side right
		pack $f.0 -side top -fill x -expand true

		frame $f.1
		label $f.1.ll -text "Names" -width 10
		entry $f.1.e -textvariable interlnam1 -width 120
		set interlnam ""
		pack $f.1.ll $f.1.e -side left -pady 4
		pack $f.1 -side top -fill x -expand true

		wm resizable $f 0 0
		bind $f <Return> {set pr_interlnam 1}
		bind $f <Escape> {set pr_interlnam 0}
	}
	raise $f
	update idletasks
	StandardPosition $f
	set pr_interlnam 0
	My_Grab 0 $f pr_interlnam $f.1.e
	set finished 0
	while {!$finished} {
		tkwait variable pr_interlnam
		if {$pr_interlnam} {
			set OK 1
			set interlnam1 [string trim $interlnam1]
			if {[string length $interlnam1] <= 0} {
				Inf "No names list entered"
				continue
			}
			set n 0 
			catch {unset inpattern}
			catch {unset outpattern}
			catch {unset nuindeces}
			set qqq [string tolower $interlnam1]
			set qqq [split $qqq]
			foreach item $qqq {
				set item [string trim $item]
				set len [string length $item]
				if {$len <= 0} {
					continue
				}
				set k 0
				while {$k < $len} {
					set c [string index $item $k]
					if {![regexp {[a-z_]} $c]} {
						Inf "Character \"$c\" not alphabetic, or an underscore, in wordlist"
						set OK 0
						break
					}
					incr k
				}
				if {!$OK} {
					break
				}
				if {[info exists inpattern]} {
					foreach pat $inpattern {
						if {([string first $item $pat] >= 0) || ([string first $pat $item] >= 0)} {
							Inf "Items \"$item\" and  \"$pat\" in wordlist cause ambiguity"
							set OK 0
							break
						}
					}
					if {!$OK} {
						break
					}
				}
				lappend inpattern $item				
				incr n
			}
			if {!$OK} {
				continue
			}
			set inlen $n
			if {$n < 2} {
				Inf "Less than two words entered : cannot re-order"
				continue
			}

			foreach fnam $chnams {					;#	CHECK THAT ALL FILENAMES CONTAIN (ONLY) ONE OF LISTED WORDS
				set zfnam [file rootname [file tail $fnam]]
				set got 0
				foreach innam $inpattern {
					if {[string first $innam $zfnam] >= 0} {
						incr got
					}
				}
				if {$got == 0} {
					Inf "Filename $zfnam does not contain any of the words in the wordlist"
					set OK 0
					break
				} elseif {$got > 1} {
					Inf "Filename $zfnam contains more than one of the words in the wordlist"
					set OK 0
					break
				}
			}
			if {!$OK} {
				continue
			}
			set n 0
			while {$n < $inlen} {					;#	INITIALISE FLAGS WHICH MARK IF THE WORD IS FOUND
				set gott($n) 0
				incr n
			}

			;#	CHECK THAT THE FILES ARE GROUPED CORRECTLY : ALL NAMES MUST APPEAR BEFORE FIRST-NAME-FOUND IS REPEATED

			set lastk -1
			foreach fnam $chnams {
				set k 0
				foreach innam $inpattern {
					if {[string first $innam $fnam] >= 0} {
						break
					}
					incr k							;#	k INDEXES WHICH WORD HAS BEEN FOUND FOUND WITHIN THE CURRENT FILENAME
				}
				if {$k != $lastk} {					;#	IF THE WORD FOUND IS DIFFERENT TO THAT FOUND IN THE LAST FILENAME
					if {$gott($k)} {				;#	IF  CURRENT FOUND-WORD HAS PREVIOUSLY BEEN FOUND
						set j 0						;#	CHECK THAT ALL THE WORDS IN WORDLIST HAVE ALREADY BEEN FOUND
						set found 0
						while {$j < $inlen} {
							if {$gott($j)} {
								incr found
							}
							incr j
						}
						if {$found != $inlen} {
							Inf "Input names are not grouped in sets based on the input wordlist"
							set OK 0
							break
						}
						set n 0
						while {$n < $inlen} {		;#	REINITIALISE FLAGS WHICH MARK IF THE WORD IS FOUND
							set gott($n) 0
							incr n
						}
						set gott($k) 1				;#	MAKE THIS WORD AS FOUND
						set lastk $k				;#	SET THE LAST-WORD-FOUND VALUE
					}
				} else {
					;# gott(k) is already set
				}
			}
			if {!$OK} {
				continue
			}

			set j 0							;#	CHECK THAT REMAINING WORDS CONFORM TO PATTERN
			set found 0
			while {$j < $inlen} {
				if {$gott($j)} {
					incr found
				}
				incr j
			}
			if {$found  && ($found != $inlen)} {
				Inf "Last group of input names are not grouped in sets based on the input wordlist"
				continue
			}

			catch {unset inlists}
			set n 0
			while {$n < $inlen} {					;#	INITIALISE FLAGS WHICH MARK IF THE WORD IS FOUND
				set gott($n) 0
				catch {unset inlist($n)}
				incr n
			}
			set lastk -1
			foreach fnam $chnams {
				set k 0
				foreach innam $inpattern {
					if {[string first $innam $fnam] >= 0} {
						break
					}
					incr k							;#	k INDEXES WHICH WORD HAS BEEN FOUND FOUND WITHIN THE CURRENT FILENAME
				}
				if {$k != $lastk} {					;#	IF THE WORD FOUND IS DIFFERENT TO THAT FOUND IN THE LAST FILENAME
					if {$gott($k)} {				;#	IF  CURRENT FOUND-WORD HAS PREVIOUSLY BEEN FOUND
						set j 0						;#	CHECK WHETHER ALL THE WORDS IN WORDLIST HAVE BEEN FOUND
						set found 0
						while {$j < $inlen} {
							if {$gott($j)} {
								incr found
							}
							incr j
						}
						if {$found == $inlen} {		;#	IF AT LEAST ONE EXAMPLE OF EACH WORD IN LIST HAS BEEN FOUND

							set n 0
							while {$n < $inlen} {
								lappend inlists $inlist($n)	;#	LIST THE INPUT-LISTS IN THE ORIGINAL ORDER OF FOUND-WORDS
								incr n
							}

							;#	REINITIALISE FLAGS WHICH MARK THAT THE WORD IS FOUND, AND EMPTY WORDSTORES inlist(n)

							set n 0
							while {$n < $inlen} {
								set gott($n) 0
								unset inlist($n)
								incr n
							}
						}
					}
				}
				lappend inlist($k) $fnam					;#	STORE fnam IN APPRORPRIATE LIST
				set gott($k) 1								;#	MARK THIS WORD AS FOUND
				set lastk $k								;#	REMEMBER INDEX OF WORD, FOR COMPARISON ON NEXT PASS
			}

			;#	DEAL WITH REMAINING ITEMS

			if {[info exists inlist(0)]} {
				set n 0
				while {$n < $inlen} {
					lappend inlists $inlist($n)	;#	LIST THE INPUT LISTS IN THE ORIGINAL ORDER OF FOUND-WORDS
					incr n
				}
			}
			set nuchlist {}
			foreach in_list $inlists {
				set nuchlist [concat $nuchlist $in_list]
			}
			set chlist $nuchlist
			$ch delete 0 end
			foreach item $chlist {
				$ch insert end $item
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

###############
# DIRECTORIES #
###############

#------ List All Directories

proc DoListingOfDirectories {e} {
	global ww curdrive active_dir bytetyb_nudir bytetyb_dir alternativedir test_on_pc env

	if {[string match $e $ww.1.b.de]} {
		SaveWkstate		
	}
	if [info exists curdrive] {
		set drive $curdrive
	} else {
		if {[info exists test_on_pc]} {
			set drive [string tolower [lindex [file split [pwd]] 0]]
		} else {
			set drive $env(HOME)
		}
	}	
	set dirname [tk_getDirectory $drive]
	if {[string length $dirname] > 0} {
		if {[string match $e $ww.1.b.de]} {
			set dirname [StripHomeDir $dirname]
		}
		if [CDP_Restricted_Directory $dirname 1] {
			Inf "This Is A Sound Loom System-Directory And Cannot Be Accessed"
			return
		}
		if {$e == "br1"} {
			set bytetyb_dir $dirname
		} elseif {$e == "br2"} {
			set bytetyb_nudir $dirname
		} elseif {$e == "alternative"} {
			set alternativedir $dirname
			return ""
		} elseif {$e == "datalist"} {
			return $dirname
		} else {
			ForceVal $e $dirname
		}
		if [string match $e $ww.1.b.de] {
			LoadDir
		}
	}
	if {[string match $e $ww.1.b.de]} {
		RestoreWkstate		
	}
}


#########################################
# KEEP TALLY OF ITEMS ON WORKSPACE		#
#########################################                                                       

proc WkspCnt {fnam by} {
	global  wksp_cnt total_wksp_cnt ww evv
	if [string match $fnam [file tail $fnam]] {
		incr wksp_cnt $by
		ForceVal $ww.1.a.endd.l.cnts.new $wksp_cnt
	}
	incr total_wksp_cnt $by
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	ReMarkWkspaceCount
}

proc WkspCntSimple {by} {
	global  wksp_cnt total_wksp_cnt ww evv
	incr wksp_cnt $by
	incr total_wksp_cnt $by
	ForceVal $ww.1.a.endd.l.cnts.new $wksp_cnt
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	ReMarkWkspaceCount
}

proc ReMarkWkspaceCount {}  {
	global wksp_cnt total_wksp_cnt counter_bg CDPcolour readonlyfg readonlybg ww evv
	if {$wksp_cnt < $evv(MAX_NEWFILES)} {
		$ww.1.a.endd.l.cnts.new config -readonlybackground $counter_bg
		if {$CDPcolour == 1} {
			$ww.1.a.endd.l.cnts.new config -foreground $readonlyfg -readonlybackground $readonlybg
		}
	} else  {
		$ww.1.a.endd.l.cnts.new config -readonlybackground $evv(QUIT_COLOR)
		if {$CDPcolour == 1} {
			$ww.1.a.endd.l.cnts.new config -foreground [option get . foreground {}]
		}
	}
	if {$total_wksp_cnt < $evv(MAX_WKSPFILES)} {
		$ww.1.a.endd.l.cnts.all config -readonlybackground $counter_bg
		if {$CDPcolour == 1} {
			$ww.1.a.endd.l.cnts.all config -foreground $readonlyfg -readonlybackground $readonlybg
		}
	} else {
		$ww.1.a.endd.l.cnts.all config -readonlybackground $evv(QUIT_COLOR)
		if {$CDPcolour == 1} {
			$ww.1.a.endd.l.cnts.all config -foreground [option get . foreground {}]
		}
	}
}

###############################################################
# REMEMBERING AND RESTORING OTHER WORKSPACES AND CHOSEN LISTS #
###############################################################

#------ Delete irrelevant lists (after 21 days if its a query date call)

proc DelStordFlistings {query_datedness} {
	global CDPid stlist logname logname_got pr_ood flcnt wltxt sl_real fallback_progfuncs superlog evv
	
	if {!$sl_real} {
		Inf "You Can Remove Any Previously Stored Workspace Listing Of Files."
		return
	}
	catch {unset stlist}
	catch {unset logname}

	if {$query_datedness < 0} {
		if {![AreYouSure]} {
			return
		}
	} 
	if {$query_datedness > 0} {	;# START-UP
		if {$fallback_progfuncs} {
			set cmd [file join $evv(CDPROGRAM_DIR) listdate]
			if [ProgMissing $cmd "Cannot check stored workspace listings for their expiry date."] {
				return
			}
			set logname_got 0
			if [catch {open "|$cmd"} CDPid] {
				ErrShow "The Program 'listdate' Is Not Functioning.\nCannot Generate Date-Stamped Names For Stored Workspace Listings."
				catch {unset CDPid}
				return
			} else {
				fileevent $CDPid readable SetLogname		;#	Display info from program
				fconfigure $CDPid -buffering line
				vwait logname_got
			}
		}
#LISTINGS EMERGENCY MAY 2007
		if {![info exists logname]} {
			set msg "Your System Is Not Generating A Time-Stamp Correctly\n\n"
			append msg "This May Be Due To Loss Of Power On The Chip Battery, Or Some Other Hardware Malfunction.\n\n"
			append msg "The Ensuing Window Will Allow You To Set A Date And Time For Your Sound Loom Session.\n\n"
			append msg "But You Should Fix The Hardware Problem As Soon As Possible!!!!.\n"
			Inf $msg
			DateByHand
		}
		set superlog $logname
		if {[string length $logname] <= 0} {
			ErrShow "Cannot Get Today's Date"
			unset logname
			return
		}
		OutofDateThumbnails $superlog 1
	}
	if {$query_datedness > 0} {
		set now [GetDayCnt $logname]
		set prefix w_
		foreach fnam [glob -nocomplain [file join $evv(URES_DIR) $prefix*]] {	
			set partfilename [string range [file tail $fnam] 2 end]
	 		set then [GetDayCnt $partfilename]
			if {$now - $then > $evv(OUTOFDATE_LIST)} {
				lappend stlist $fnam
			}
		}			
		set prefix c_
		foreach fnam [glob -nocomplain [file join $evv(URES_DIR) $prefix*]] {	
			set partfilename [string range [file tail $fnam] 2 end]
	 		set then [GetDayCnt $partfilename]
			if {[expr $now - $then] > $evv(OUTOFDATE_LIST)} {
				lappend stlist $fnam
			}
		}			
		unset logname
	} else {
		set prefix w_
		foreach fnam [glob -nocomplain [file join $evv(URES_DIR) $prefix*]] {	
			lappend stlist $fnam
		}			
		set prefix c_
		foreach fnam [glob -nocomplain [file join $evv(URES_DIR) $prefix*]] {	
			lappend stlist $fnam
		}
	}
	if [info exists stlist] {
		if {$query_datedness < 0} {
			DelAllFlistings 0
			return
		}
		set f .ood
		if [Dlg_Create $f "" "set pr_ood 0" -borderwidth $evv(SBDR)] {
			set b [frame $f.b -borderwidth $evv(SBDR)]
			set b2 [frame $f.b2 -borderwidth $evv(SBDR)]
			message $f.msg -justify left -aspect 1000 -text $wltxt
			set flistings [Scrolled_Listbox $f.l -height 10 -width 48]
			button $b.quit -text Close -command {set pr_ood 0} -highlightbackground [option get . background {}]
			button $b.som -text "Delete Selected" -width 14 -command {DelSomeFlistings .ood.l.list} -highlightbackground [option get . background {}]
			button $b.see -text "See Selected" -width 14 -command {SeeSomeFlistings .ood.l.list} -highlightbackground [option get . background {}]
			button $b.repr -text "Change Shelf Life" -width 14 -command {ExtendLife} -highlightbackground [option get . background {}]
			entry $b2.cnt -textvariable flcnt -width 3 -state disabled
			label $b2.lab -text "Items in list"
			button $b2.all -text "Delete All"  -width 12 -command {DelAllFlistings 1} -highlightbackground [option get . background {}]
			pack $b.see $b.som $b.repr -side left
			pack $b.quit -side right
			pack $b2.cnt $b2.lab -side left -padx 1
			pack $b2.all -side right
			pack $f.b $f.msg $f.b2 $f.l -side top -fill x
			wm resizable $f 1 1
			bind $f <Return> {set pr_ood 0}
			bind $f <Escape> {set pr_ood 0}
			bind $f <Key-space> {set pr_ood 0}
		}
		set flcnt 0
		if {$query_datedness} {
			wm title $f "File listings over $evv(OUTOFDATE_LIST) days old"
		} else {
			wm title $f "File listings"
		}
		.ood.l.list delete 0 end
		set i 0
		foreach item $stlist {
			.ood.l.list insert 0 [file tail $item]
			incr i
		}
		set flcnt $i 
		raise $f
		set pr_ood 0
		My_Grab 0 $f pr_ood .ood.l.list
		tkwait variable pr_ood
		My_Release_to_Dialog $f
		destroy $f
	}
}

#------ Delete all file-listings older than a time-limit, or on user command

proc DelAllFlistings {check} {
	global stlist pr_ood pr_clist

	if {$check && ![AreYouSure]} {
		return
	}
	foreach fnam $stlist {
		if [catch {file delete $fnam} in] {
			ErrShow "CANNOT DELETE FILE $fnam"
		}
	}
	set pr_ood 0
	set pr_clist 0
}

#------ Delete selected file-listings

proc DelSomeFlistings {listing} {
	global flcnt pr_ood pr_clist evv

	if [AreYouSure] {
		if {[$listing index end] == 1} {
			set ilist 0
		} else {
			set ilist [$listing curselection]
		}
		if {![info exists ilist] || ([llength $ilist] <= 0)} {
			Inf "No Item(s) Selected."
			return
		}
		foreach i $ilist {
			set fnam [$listing get $i]
			if [catch {file delete [file join $evv(URES_DIR) $fnam]} in] {
				ErrShow "$in"
				ErrShow "CANNOT DELETE FILE $fnam"
				continue
			}
			$listing delete $i
			catch {incr flcnt -1}
		}
	}
	if {[$listing index end] == 0} {
		set pr_ood 0
		set pr_clist 0
	}
}
			
#------ See selected file-listing

proc SeeSomeFlistings {listing} {
	global pr_fflist flno evv

	if {[$listing index end] == 1} {
		set ilist 0
	} else {
		set ilist [$listing curselection]
	}
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Item(s) Selected."
		return
	}
	set f .fflist
	if [Dlg_Create $f "Files in listing" "set pr_fflist 0" -borderwidth $evv(SBDR)] {
		set b [frame $f.buttons -borderwidth $evv(SBDR)]
		set flistings [Scrolled_Listbox $f.l -height 10 -width 48 -selectmode single -height 40]
		button $b.ok -text OK -command {set pr_fflist 0} -highlightbackground [option get . background {}]
		entry $b.e -textvariable flno -width 3
		label $b.l -text "Files in list"
		pack $b.ok -side right
		pack $b.e $b.l -side left -padx 1
		pack $f.buttons $f.l -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_fflist 0}
		bind $f <Escape> {set pr_fflist 0}
		bind $f <Key-space> {set pr_fflist 0}
	}
	set flno 0
	raise $f
	set pr_fflist 0
	My_Grab 0 $f pr_fflist .fflist.l.list
	foreach i $ilist {
		catch {unset fflist}
		set fnam [$listing get $i]
		if [catch {open [file join $evv(URES_DIR) $fnam] "r"} zfileId] {
			ErrShow "CANNOT OPEN FILE $fnam"
			continue
		}
		while {[gets $zfileId fnam] >= 0} {
			set fnam [string trim $fnam]
			if {[string length $fnam] > 0} {
				lappend fflist $fnam
			}
		}
		if [info exists fflist] {
			.fflist.l.list delete 0 end
			set i 0
			foreach item $fflist {
				.fflist.l.list insert 0 [file tail $item]
				incr i
			}
			set flno $i
			tkwait variable pr_fflist
		}
	}
	close $zfileId
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}
			
#------ Get day as a daycount from jan 1st, 2000

proc GetDayCnt {fnam} {
	set z 15
	set m	[string range $fnam 0 2]			
	set d	[string range $fnam 3 4]			
	set k 0
	while {[string match 0 [string index $d $k]] == 1} {
		incr k
	}
	set d [string range $d $k end]
	if {[string match [string index $d 1] "_"]} {
		set d [string range $d 0 0]
		incr z -1
	}
	set y [string range $fnam $z end]

	switch -- [string tolower $m] {
		jan { set m 0}
		feb { set m 1}
		mar { set m 2}
		apr { set m 3}
		may { set m 4}
		jun { set m 5}
		jul { set m 6}
		aug { set m 7}
		sep { set m 8}
		oct { set m 9}
		nov { set m 10}
		dec { set m 11}
	}
	set daycnt [expr ((($y - 2000) * 366) + ($m * 31) + $d)]
	return $daycnt
}

#------ Remember files in chosen files, or workspace

proc RememberList {name tell} {
	global chcnt total_wksp_cnt ch wl ch_remem w_remem logname_got logname CDPid rememd pa sl_real superlog evv

	if {!$sl_real} {
		switch -- $name {
			wl	{
				Inf "You Can Remember The Current Workspace Listing, Before Changing It.\nYou Can Recall The Saved Listing Later."
				set w_remem 0
			}
			ch	{
				Inf "You Can Remember The Current Chosen Files, Before Changing Them.\nYou Can Recall The Saved Listing Later."
				set ch_remem 0
			}
		}
		return
	}
	catch {unset logname}
	set cmd [file join $evv(CDPROGRAM_DIR) listdate]
	if [ProgMissing $cmd "Cannot remember listing."] {
		return
	}
	set ch_remem 0
	set w_remem 0
	set warned 0
	switch -- $name {
		ch	{
			if {$chcnt <= 0} {
				return
			}
			set namename "chosen files"
		}
		wl {
			if [info exists rememd] {
				Inf "Workspace Already Stored"
				return
			}
			if {$total_wksp_cnt <= 0} {
				return
			}
			set namename workspace
		}
	}
	set logname_got 0
	if [catch {open "|$cmd"} CDPid] {
		ErrShow "CANNOT GET $namename NAME"
		catch {unset CDPid}
		return
	} else {
		fileevent $CDPid readable SetLogname		;#	Display info from program
		fconfigure $CDPid -buffering line
		if {!$logname_got} {
			vwait logname_got
		}
	}
#LISTINGS EMERGENCY MAY 2007
	if {![info exists logname]} {
		set logname $superlog
		set emergency 1
	}
#TO HERE
	if {[string length $logname] <= 0} {
		ErrShow "CANNOT GET $namename NAME"
		return
	} else {
		switch -- $name {
			ch { set zname c_ }
			wl { set zname w_ }
		}
		append zname $logname
		unset logname
#LISTINGS EMERGENCY MAY 2007
		if {[info exists emergency]} {
			set zname [CheckListingNameSecs $zname]
		}
#TO HERE
		set zname [file join $evv(URES_DIR) $zname]
		if [catch {open $zname a} zfileId] {
			Inf "Cannot Open File To Store '$namename'"
			return
		}
	}
	switch -- $name {
		ch {
			set i 0 
			foreach ff [$ch get 0 end] {
				if {[info exists pa($ff,$evv(FTYP))] && ($pa($ff,$evv(FTYP)) == $evv(PSEUDO_SND))} {
					if {!$warned} {
						Inf "Cannot Store Pseudo_sndfiles Like '$ff'"
						set warned 1
					}
				} else {
					puts $zfileId $ff
					incr i
				}
			}
			close $zfileId
			if {$i <= 0} {
				if [catch {file delete $zname} in] {
					Inf "Cannot Delete Empty List Store File '$zname'"
				}
			} elseif {$tell} {
				Inf "Stored Chosen Files List '[file tail $zname]'"
			}
		}
		wl {
			set i 0 
			foreach ff [$wl get 0 end] {
				if {[info exists pa($ff,$evv(FTYP))] && ($pa($ff,$evv(FTYP)) == $evv(PSEUDO_SND))} {
					if {!$warned} {
						Inf "Cannot Store Pseudo_Sndfiles Like $ff"
						set warned 1
					}
				} else {
					puts $zfileId $ff
					incr i
				}
			}
			close $zfileId
			if {$i > 0} {
				set rememd $zname
				Inf "Stored Workspace '[file tail $zname]'"
			} else {
				if [catch {file delete $zname} in] {
					Inf "Cannot Delete Empty List Store File '$zname'"
				}
			}
		}
	}
}

#------ Restore a previous file-listing of chosen files, or workspace

proc RecallList {name} {
	global wl chlist ch ch_resto w_resto chcnt f_lstng pr_clist wltxt
	global wksp_cnt wstk sl_real evv

	if {!$sl_real} {
		switch -- $name {
			wl	{
				Inf "You Can Recall A Previously Stored Workspace Listing."
				set w_resto 0
			}
			ch	{
				Inf "You Can Recall A Previously Stored Chosen Files Listing."
				set ch_resto 0
			}
		}
		return
	}
	switch -- $name {
		wl	{ set prefix w_ ; set namename Workspace 	 }
		ch	{ set prefix c_ ; set namename "Chosen Files"}
	}

	set ch_resto 0
	set w_resto 0
	catch {unset f_lstng}
	foreach fnm [glob -nocomplain [file join $evv(URES_DIR) $prefix*]] {	
		lappend flist $fnm
	}
	if {![info exists flist]} {
		return
	}
	if {[llength $flist] == 1} {
		set f_lstng [lindex $flist 0]
	} else {
		set flist [SortFlistByDate $flist]
		set f .flist
		if [Dlg_Create $f "" "set pr_clist 0" -borderwidth $evv(SBDR)] {
			set b [frame $f.buttons -borderwidth $evv(SBDR)]
			set msg $wltxt
			append msg "\n\nTo change shelf-life of listings, see 'System' menu"
			message $f.msg -justify left -aspect 1000 -text $msg
			set flistings [Scrolled_Listbox $f.l -height 10 -width 48 -selectmode single]
			button $b.quit -text Close -command {set pr_clist 0} -highlightbackground [option get . background {}]
			button $b.see -text See -command {SeeLFile .flist.l.list} -highlightbackground [option get . background {}]
			button $b.use -text Use -command {UseLFile .flist.l.list} -highlightbackground [option get . background {}]
			button $b.del -text Delete -command {DelSomeFlistings .flist.l.list} -highlightbackground [option get . background {}]
			pack $b.see $b.use -side left -padx 1
			pack $b.del -side left -padx 40
			pack $b.quit -side right
			pack $f.buttons $f.msg $f.l -side top -fill x
			wm resizable $f 1 1
			bind $f <Escape>  {set pr_clist 0}
			bind $f <Return>  {UseLFile .flist.l.list}
		}
		wm title $f "$namename Listings"
		.flist.l.list delete 0 end
		foreach item $flist {
			.flist.l.list insert 0 [file tail $item]
		}
		raise $f
		set pr_clist 0
		My_Grab 0 $f pr_clist .flist.l.list
		tkwait variable pr_clist
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
		if {!$pr_clist} {
			return
		}
	}
	switch -- $name {
		ch {
			if [catch {open $f_lstng "r"} zfileId] {
				Inf "Cannot Open File '$f_lstng' To Read $namename List"
				return
			}
			while {[gets $zfileId fnam] >= 0} {
				set fnam [string trim $fnam]
				if {[string length $fnam] > 0} {
					if {![file exists $fnam]} {
						set choice [tk_messageBox -type yesno -default yes \
						-message "File '$fnam' No Longer Exists : Do You Wish To Continue With Restoring List ?" \
						-icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							continue
						} else {
							close $zfileId
							return
						}
					}
					lappend fflist $fnam
				}
			}
			close $zfileId
			if {![info exists fflist] || ([llength $fflist] <= 0)} {
				return
			}
			set chlist $fflist
			$ch delete 0 end
			set chcnt 0
			foreach fnam $fflist {
				$ch insert end $fnam
				incr chcnt
			}
			ChlistDupls
		} 
		wl {
			LoadWkspace $f_lstng 0
		} 
	}
}

#------ See stored wkspace or Chosenfilelist

proc SeeLFile {ll} {
	global pr_v evv

	set i [$ll curselection]
	if {![info exists i] || ![IsNumeric $i]} {
		Inf "No File Selected"
		return
	}
	set fnam [$ll get $i]
	set f .vdisplay
	if [Dlg_Create $f $fnam "set pr_v 0" -borderwidth $evv(BBDR)] {
		set b  [frame $f.button -borderwidth $evv(SBDR)]
		set s  [frame $f.see -borderwidth $evv(SBDR)]
		button $b.ok -text "OK" -command "set pr_v 0" -highlightbackground [option get . background {}]
		pack $b.ok -side top -padx 1
		Scrolled_Listbox $s.l -height 20 -width 48 -selectmode single
		pack $s.l -side top -fill both -expand true
		pack $f.button $f.see -side top
		wm resizable $f 1 1
		bind $f <Escape>  {set pr_v 0}
		bind $f <Return>  {set pr_v 0}
		bind $f <Key-space> {set pr_v 0}
	}
	wm title $f $fnam
	.vdisplay.see.l.list delete 0 end								;#	Clear the filelist window

	if [catch {open [file join $evv(URES_DIR) $fnam] r} fileId] {
		Inf $fileId							;#	If textfile cannot be opened
		Dlg_Dismiss $f							;#	Hide the dialog
		return		
	}
	while { [gets $fileId thisline] >= 0} {			;#	Read lines from textfile into text-listing
		.vdisplay.see.l.list insert end	"$thisline"
	}
	close $fileId
	set pr_v 0
	My_Grab 0 $f pr_v
	tkwait variable pr_v
	My_Release_to_Dialog $f
	destroy $f
}

#------ Use stored wkspace or Chosenfilelist

proc UseLFile {ll} {
	global f_lstng pr_clist evv

	set i [$ll curselection]
	if {![info exists i] || ![IsNumeric $i]} {
		Inf "No File Selected"
		return
	}
	set fnam [$ll get $i]
	set f_lstng [file join $evv(URES_DIR) $fnam]
	set pr_clist 1
}

#------ Extend shelf-life of stored data

proc ExtendLife {} {
	global pr_el shlf uv evv

	set f .el
	if [Dlg_Create $f "Change Shelf-Life" "set pr_el 0" -borderwidth $evv(BBDR)] {
		set b  [frame $f.b -borderwidth $evv(SBDR)]
		button $b.ok -text "Change" -width 5 -command "set pr_el 1" -highlightbackground [option get . background {}]
		button $b.q  -text "Close" -width 5 -command "set pr_el 0" -highlightbackground [option get . background {}]
		pack $b.ok -side left
		pack $b.q -side right
		set e1  [frame $f.e1 -borderwidth $evv(SBDR)]
 		label $e1.l -text "" -width	30
		pack $e1.l -side top
		set e  [frame $f.e -borderwidth $evv(SBDR)]
 		label $e.l -text "Shelf Life"
		entry $e.e -width 20 -textvariable shlf
		pack $e.l $e.e -side left -padx 1
		pack $f.b $f.e1 $f.e -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_el 1}
		bind $f <Escape> {set pr_el 0}
	}
	$f.e.l config -text "Current Shelf Life : $evv(OUTOFDATE_LIST) days"
	set shlf ""
	set pr_el 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_el $f.e.e
	while {!$finished} {
		tkwait variable pr_el
		if {$pr_el} {
			if {![IsNumeric $shlf]} {
				Inf "No (Valid) Value Entered."
				continue
			 } else {
			 	if {$shlf != $evv(OUTOFDATE_LIST)} {
					set evv(OUTOFDATE_LIST) $shlf
					set uv(ofd_lst) $evv(OUTOFDATE_LIST)
					SaveUserEnvironment
				}
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#############################
#	DEMO VERSION FUNCTIONS	#
#############################

proc ExplanNewUserHelp {} {
	global do_starthlp sl_real

	if {!$sl_real} {
		Inf "You Can Switch Off Or On The New-User-Help Facility, Here"
		set	do_starthlp 1
	}
}

#########################
#	TYPICAL SAMPLE SIZE	#
#########################

#--- Interface to change typical size of samples being used

proc ChangeSampsize {initialising} {
	global sampsize_convertor orig_sampsize_convertor system_initialisation pr_ssize sc_sc evv

	if {$initialising} {
		if {$system_initialisation} {
			set sampsize_convertor 32767
			set	orig_sampsize_convertor $sampsize_convertor
			SaveSamplesize
			return
		}
		set got_ss 0
		set filename [file join $evv(CDPRESOURCE_DIR) $evv(SAMPSIZE)$evv(CDP_EXT)]
		if [file exists $filename] {
			set got_ss 1
			if [catch {open $filename "r"} zab] {
				Inf "Cannot Read Default Sample Size:\n\nPlease Re-Enter This Information"
				set got_ss 0
			} else {
				if {[gets $zab line] < 0} {
					Inf "Cannot Read Default Sample Size:\n\nPlease Re-Enter This Information"
					set got_ss 0
				} else {
					set line [string trim $line]
					switch -- $line {
						255   -
						32767	-
						524287	-
						8388607	-
						1.0		{
							set	sampsize_convertor $line
							set	orig_sampsize_convertor $sampsize_convertor
						}
						default {
							Inf "Invalid Sample Size:\n\nPlease Re-Enter This Information"
							set got_ss 0
						}
					}
				}
			}
			catch {close $zab}
		}
		if {$got_ss} {
			EstablishBitResolution
			return
		}
		set sampsize_convertor 0
	}
	set f .ssize
	set sc_sc 0
	if [Dlg_Create $f "TYPICAL SAMPLE SIZE (FOR CALCULATOR)" "set pr_ssize 0" -borderwidth 10] {
		set a [frame $f.a -borderwidth 2 -width 250 -height 50]
		label $a.x1 -text "1) Value Entered doesn't prevent use of other file types."
		label $a.x2 -text "2) Use: Calculator + a few Parameter display value convertors: sampleval <-> gain."
		label $a.x3 -text "3) Value can be changed later (System Menu)."
		pack $a.x1 $a.x2 $a.x3 -side top
		set b [frame $f.b -borderwidth 2 -width 250 -height 50]
		pack propagate $f.b false
		button $b.0 -text "Close" -command "set pr_ssize 0" -width 5 -highlightbackground [option get . background {}]
		button $b.1 -text "Reset" -command "set pr_ssize 1" -width 5 -highlightbackground [option get . background {}]
		pack $b.0 -side left
		pack $b.1 -side right
		frame $f.b1 -height 1 -bg [option get . foreground {}]
		set b2 [frame $f.b2 -borderwidth 2]										
		button $b2.z -text "8-bit: 255"   -width 15 -command "SetSampsize 255" -highlightbackground [option get . background {}]
		button $b2.0 -text "16-bit: 32767"   -width 15 -command "SetSampsize 32767" -highlightbackground [option get . background {}]
		button $b2.1 -text "20-bit: 524287"  -width 15 -command "SetSampsize 524287" -highlightbackground [option get . background {}]
		button $b2.2 -text "24-bit: 8388607" -width 15 -command "SetSampsize 8388607" -highlightbackground [option get . background {}]
		button $b2.3 -text "float: 1.0"      -width 15 -command "SetSampsize 1.0" -highlightbackground [option get . background {}]
		pack $b2.z $b2.0 $b2.1 $b2.2 $b2.3 -side top
		pack $f.a $f.b $f.b1 $f.b2 -side top -fill x -expand true
		bind $f <Escape> {set pr_ssize 0}
		bind $f <Return> {set pr_ssize 1}
	}
	if {$initialising} {
		$f.b.1 config -text "Set"
		set sampsize_convertor $evv(SAMPSIZE_DEFAULT)
		set sc_sc 32767
	} else {
		$f.b.1 config -text "Reset"
	}
	switch -- $sampsize_convertor {
		"255"   {
			.ssize.b2.z config -text "8-BIT**255" 
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"32767"   {
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-BIT**32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"524287"  {
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-BIT**524287" 
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"8388607" {
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-BIT**8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"1.0"     {
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "FLOAT**1.0" 
		}
	}
	wm resizable $f 1 1
	set pr_ssize 0
	raise $f
	My_Grab 0 $f pr_ssize
	set finished 0
	while {!$finished} {
		tkwait variable pr_ssize
		switch -- $pr_ssize {
			0 {
				if {$initialising} {
					set	sampsize_convertor $evv(SAMPSIZE_DEFAULT)
					set	orig_sampsize_convertor $sampsize_convertor
					SaveSamplesize
				}
				set finished 1
			}
			1 {
				if {$sc_sc > 0} {
					set sampsize_convertor $sc_sc	
					if {$initialising} {
						set	orig_sampsize_convertor $sampsize_convertor
					}
					SaveSamplesize
					set finished 1
				} else {
					if {$sampsize_convertor <= 0} {
						Inf "Sample Size Not Set"
					} else {
						set finished 1
					}
				}
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return
}

#--- Save typical size of samples being used by system

proc SaveSamplesize {} {
	global sampsize_convertor orig_sampsize_convertor evv
	
	EstablishBitResolution
	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(SAMPSIZE)$evv(CDP_EXT)]
	if [catch {open $fnam "w"} fId] {
		Inf "Cannot Save New Sample Size Information"
		return
	}
	puts $fId $sampsize_convertor
	close $fId
}

#--- Change typical size of samples being used, and highlight on interface

proc SetSampsize {inval} {
	global sc_sc evv
	switch -- $inval {
		"255"   {
			set sc_sc 255
			.ssize.b2.z config -text "8-BIT**255" 
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"32767"   {
			set sc_sc 32767
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-BIT**32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"524287"  {
			set sc_sc 524287
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-BIT**524287" 
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"8388607" {
			set sc_sc 8388607
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-BIT**8388607" 
			.ssize.b2.3 config -text "float: 1.0" 
		}
		"1.0"     {
			set sc_sc 1.0
			.ssize.b2.z config -text "8-bit: 255"
			.ssize.b2.0 config -text "16-bit: 32767"
			.ssize.b2.1 config -text "20-bit: 524287"
			.ssize.b2.2 config -text "24-bit: 8388607" 
			.ssize.b2.3 config -text "FLOAT**1.0" 
		}
		default {
			Inf "Unknown Value Sent From Sample Size Interface"
			set sc_sc $sampsize_convertor
		}
	}
}

#--- Set bit-resolution of soundfiles, and various value convertors

proc EstablishBitResolution {} {
	global sampsize_convertor mu evv

	switch -- $sampsize_convertor {
		 255 	 { set evv(BITRES) 8 }
		 32767 	 { set evv(BITRES) 16 }
		 524287  { set evv(BITRES) 20 }
		 8388607 { set evv(BITRES) 24 }
		 1.0 	 { set evv(BITRES) float }
	}
	set mu(MAXFSAMPVAL) 1.0
	set mu(MAXSAMPVAL)	$sampsize_convertor
}

#------ Play selected sound(s) and be able to rename them.

proc PlayAndRename {} {
	global pr4 play_pll2 nuuname global pa wl ch playcnt2 evv sl_real playname_i dupl_mix dupl_vbx dupl_txt

	if {!$sl_real} {
		Inf "Selected Files On The Workspace Can Be Played And Then Renamed"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set playname_i -1
	set playcnt2 0
	set rlist [$wl curselection]
	if {[llength $rlist] <= 0} {
		Inf "No Items Selected"
		return
	}
	foreach i $rlist {
		lappend tl [$wl get $i]
	}
	foreach fnam $tl {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} { 
			lappend playables $fnam
			incr playcnt2
		}
	}
	if {$playcnt2 <= 0} {
		Inf "No Playable Items Selected"
		return
	}
	set f .playlist2
	if [Dlg_Create $f "Playlist" "set pr4 1" -borderwidth $evv(BBDR)] {
		set b [frame $f.button -borderwidth $evv(SBDR)]
		set n [frame $f.newname -borderwidth $evv(SBDR)]
		set player [frame $f.play -borderwidth $evv(SBDR)]
		set play_pll2 [Scrolled_Listbox $player.playlist -width 48 -height 32 -selectmode single]
		button $b.play -text "Play" -command "PlaySelectedSndfile $play_pll2" -highlightbackground [option get . background {}]
		button $b.rena -text "Rename" -command "RenameFile $play_pll2" -highlightbackground [option get . background {}]
		button $b.next -text "Play Next" -command {PlayNext 0 play_pll2} -highlightbackground [option get . background {}]
		button $b.quit -text "Close" -command "set pr4 1" -highlightbackground [option get . background {}]
		pack $b.play $b.rena $b.next -side left -padx 1
		pack $b.quit -side right
	 	label $n.lab -text "New Name"
	 	entry $n.newname -textvariable nuuname -width 48
		pack $n.lab $n.newname -side left -fill x -expand true
		pack $player.playlist -side top -fill both
		pack $f.button $f.newname $f.play -side top -fill x
		bind $play_pll2 <ButtonRelease-1> {GetPlayName}
		bind $n.newname <ButtonRelease-1> {KeepPlayNameHilite}
		bind .playlist2 <Control-Key-p> {UniversalPlay list $play_pll2}
		bind .playlist2 <Control-Key-P> {UniversalPlay list $play_pll2}
		bind .playlist2 <Key-space> {UniversalPlay list $play_pll2}
		bind .playlist2 <Double-1> {UniversalPlay list $play_pll2}
		bind $f <Return> {set pr4 1}
		bind $f <Escape> {set pr4 1}
	}
	wm resizable $f 1 1
	set nuuname ""
	$play_pll2 delete 0 end
	foreach fnam $playables {
		$play_pll2 insert end $fnam
	}
	set pr4 0
	raise $f
	My_Grab 0 $f pr4 $f.play.playlist
	wm geometry $f [ToRightThird .workspace $f]
	tkwait variable pr4
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	foreach i $rlist {
		$wl selection set $i
	}
}

#------ Rename sndfile previously selected from playlist

proc RenameFile {pll} {
	global wl chlist ch nuuname background_listing scores_refresh pa evv

	set i [$pll curselection]
	if {[string length $i] <= 0} {
		Inf "No Item Selected"
		return
	}
	set fnam [$pll get $i]
	if {[string length $nuuname] <= 0} {
		Inf "No Name Specified"
		return
	} elseif {![ValidCDPRootname $nuuname]} {
		return
	}
	if {[string match $nuuname [file rootname [file tail $fnam]]]} {
		Inf "Filename Has Not Been Changed"
		return
	}
	set haspmark [HasPmark $fnam]
	set hasmmark [HasMmark $fnam]
	set exxt [file extension $fnam]
	set newname $nuuname$exxt
	if [file exists $newname] {
		Inf "This File Already Exists: Please Choose A Different Name"
		return
	}
	set fdir [file dirname $fnam]
	if {[string length $fdir] > 1} {
	set newname [file join $fdir $newname]
	}
	if [catch {file rename $fnam $newname} zig] {
		Inf "Cannot Rename The File"
		return
	}
	DataManage rename $fnam $newname
	UpdateBakupLog $fnam delete 0
	UpdateBakupLog $newname create 1
	CheckMainmixSnd $fnam $newname
	set save_mixmanage 0
	set k 0
	foreach wfnam [$wl get 0 end] {
		if [string match $fnam $wfnam] {			;#	Find the file on the workspace
			$wl delete $k							;#	Rename it there
			$wl insert $k $newname

			RenameProps	$fnam $newname 1			;#	Rename associated props
			DummyHistory $fnam "RENAMED_$newname"
			if {[MixMRename $fnam $newname 0]} {
				set save_mixmanage 1
			}
			catch {unset rememd}
			if [info exists chlist] {
				set j [lsearch -exact $chlist $fnam]
				if {$j >= 0} {						;#	if file is on chosen-files-list, update this data
					set chlist [lreplace $chlist $j $j $newname]
					$ch delete 0 end
					foreach ff $chlist {
						$ch insert end $ff
					}
				}
			}
			UpdateChosenFileMemory $fnam $newname	;#	Update memory of which files 'chosen' last time, etc.
			AddNameToNameslist $newname 0			;#	Add the new name to list of recent names used

			RenameOnDirlist $fnam $newname
			break
		}
		incr k
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$haspmark} {
		MovePmark $fnam $newname
	}
	if {$hasmmark} {
		MoveMmark $fnam $newname
	}
	if [IsInBlists $fnam] {
		if [RenameInBlists $fnam $newname] {
			SaveBL $background_listing
		}
	}
	if [IsOnScore $fnam] {
		RenameOnScore $fnam $newname
	} 
	if {($pa($newname,$evv(FTYP)) == $evv(SNDFILE)) || ($pa($newname,$evv(FTYP)) == $evv(FLTT_SNDFILE))} {
		set scores_refresh 1
	}
	$pll delete $i									;#	Rename it in curent list
	$pll insert $i $newname
	$pll selection set $i $i
}

#---- Move hiliting from current item to next item, cyclically

proc HiliteNext {pll listlen vset} {
	global wl ch playcnt2 nuuname

	set i [$pll curselection]
	if {[string length $i] <= 0} {
		set i -1
	}
	incr i
	if {$i >= $listlen} {
		set i 0
	}
	$pll selection clear 0 end
	$pll selection set $i $i
	if {[string match $vset nuuname]} {
		set nuuname [file rootname [file tail [$pll get $i]]]
	}
}

#---- Move hiliting from current item to previous item, cyclically

proc HilitePrevious {pll} {
	global wl ch playcnt2

	set i [$pll curselection]
	if {[string length $i] <= 0} {
		$pll selection clear 0 end
		$pll selection set end end
	} else {
		incr i -1
		if {$i < 0} {
			set i "end"
		}
		$pll selection clear 0 end
		$pll selection set $i $i
	}
}

#---- Select a lot of files with similar names

proc Generic_Select {from copy} {
	global wl dl chlist ch chcnt pr_gensel genselstr ignore_ext ignore_dir gensel_sort gensel_add evv
	global gensel_notend genselendstr sl_real gensel_typ pa hidden_dir

	if {!$sl_real && [string match $from "dl"]} {
		set msg "Select Files With (Specified) Similar Names From The Directory Listing\n"
		if {$copy} {
			append msg "Copy Them To The Home Directory,\n"
		} 
		append msg "And Grab Them Onto The Workspace Window"
		Inf $msg
		return
	}
	set save_mixmanage 0
	set nessupdate 0
	set f .genselect
	if [Dlg_Create .genselect "SELECT FILES" "set pr_gensel 0" -borderwidth $evv(BBDR)] {
		button $f.quit -text "Close" -command "set pr_gensel 0" -highlightbackground [option get . background {}]
		label $f.ll -text "CHOOSE FILENAMES"
		set b [frame $f.button -borderwidth $evv(SBDR)]
		button $b.start -text "starting with" -command "set pr_gensel 1" -highlightbackground [option get . background {}]
		button $b.mid   -text "including" 	  -command "set pr_gensel 2" -highlightbackground [option get . background {}]
		button $b.end   -text "ending with"   -command "set pr_gensel 3" -highlightbackground [option get . background {}]
		pack $b.start $b.mid $b.end -side left -padx 1
		set b2 [frame $f.butto2 -borderwidth $evv(SBDR)]
		checkbutton $b2.ext -variable ignore_ext -text "ignore file extension"
		checkbutton $b2.dir -variable ignore_dir -text "ignore directory path"
		pack $b2.ext $b2.dir -side left -padx 1
		set b3 [frame $f.butto3 -borderwidth $evv(SBDR)]
		checkbutton $b3.add -variable gensel_add -text "" -width 48 -bd 0 -state disabled
		pack $b3.add -side top
		set b4 [frame $f.butto4 -borderwidth $evv(SBDR)]
		radiobutton $b4.xxx -variable gensel_notend -text "" -command EnabEnd -value 0
		label $b4.not -text "BUT NOT" 
		radiobutton $b4.inc -variable gensel_notend -text "including" -command EnabEnd -value 1
		radiobutton $b4.end -variable gensel_notend -text "ending with" -command EnabEnd -value 2
		entry $b4.e  -textvariable genselendstr -width 30 -state disabled -bd 0
		pack $b4.xxx $b4.not $b4.inc $b4.end $b4.e -side left -pady 1
		set b4a [frame $f.butto4a -borderwidth $evv(SBDR)]
		label $b4a.commas -text "(For more than one value, separate by commas)"
		pack $b4a.commas -side top
		set b5 [frame $f.butto5 -borderwidth $evv(SBDR)]
		checkbutton $b5.srt -variable gensel_sort -text "numeric sort" -width 12
		pack $b5.srt -side top
		set b6 [frame $f.butto6 -borderwidth $evv(SBDR)]
		radiobutton $b6.snd -variable gensel_typ -text "sndfiles only" -width 12 -value $evv(SNDFILE)
		radiobutton $b6.ana -variable gensel_typ -text "analysis files" -width 12 -value $evv(ANALFILE)
		radiobutton $b6.all -variable gensel_typ -text "all files" -width 12 -value 0
		pack $b6.snd $b6.ana $b6.all -side left
		entry $f.e -textvariable genselstr -width 48
		pack $f.quit $f.ll $f.button $f.butto2 $f.e $f.butto4a $f.butto4 $f.butto3 $f.butto5 $f.butto6 -side top -expand true -pady 1
		bind $f <Escape> {set pr_gensel 0}
	}
	if [string match "wl" $from] {
		$b3.add config -text "add to list, if not on list (default, replace list)"  -bd  $evv(SBDR) -state normal
		$f.butto6.snd config -state normal
		$f.butto6.ana config -state normal
		$f.butto6.all config -state normal
	} else {
		$b3.add config -text ""  -bd  0 -state disabled
		$f.butto6.snd config -state disabled
		$f.butto6.ana config -state disabled
		$f.butto6.all config -state disabled
	}
	set genselstr ""
	set genselendstr ""
	set ignore_ext 1
	set ignore_dir 1
	set gensel_sort 0
	if {$from == "wl"} {
		set gensel_typ $evv(SNDFILE)
	} else {
		set gensel_typ 0
	}
	set gensel_add 0
	set gensel_notend 0
	set pr_gensel 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_gensel $f.e
	while {!$finished} {
		tkwait variable pr_gensel
		if {$pr_gensel == 0} {
			break
		}
		if {[string length $genselstr] <= 0} {
			Inf "No Text Entered"
			continue
		}
		set genselstr [string tolower $genselstr]
		catch {unset genselstrx}
		foreach item [split $genselstr ","] {
			set item [string trim $item]
			if {[string length $item] > 0} {
				lappend genselstrx $item
			}
		}
		if {![info exists genselstrx]} {
			Inf "No Valid Text Entered"
			continue
		}
		set is_hidden_dir 0
		switch -- $from {
			"wl" {
				set listt $wl
			}
			"dl" {
				set listt $dl
				if {[string length $hidden_dir] > 0} {
					set is_hidden_dir 1
				}
			}
		}
		catch {unset goodfiles}
		foreach ffnam [$listt get 0 end] {
			if {$is_hidden_dir} {
				set ffnam [file join $hidden_dir $ffnam]
			}
			switch -regexp -- $gensel_typ \
				^$evv(SNDFILE)$		 {
					if {$pa($ffnam,$evv(FTYP)) != $evv(SNDFILE)} {
						continue
					}

				} \
				^$evv(ANALFILE)$	 {
					if {$pa($ffnam,$evv(FTYP)) != $evv(ANALFILE)} {
						continue
					}
				}

			set orig_ffnam $ffnam
			if {$ignore_dir} {
				set ffnam [file tail $ffnam]
			}
			if {$ignore_ext} {
				set ffnam [file rootname $ffnam]
			}
			switch -- $pr_gensel {
				1 {
					foreach item $genselstrx {
						if [string match $item* $ffnam] {
							if {[info exists goodfiles]} {
								if {[lsearch -exact $goodfiles $orig_ffnam] < 0} {
									lappend goodfiles $orig_ffnam
								}
							} else {
								lappend goodfiles $orig_ffnam
							}
						}
					}
				}
				2 {
					foreach item $genselstrx {
						if [string match *$item* $ffnam] {
							if {[info exists goodfiles]} {
								if {[lsearch -exact $goodfiles $orig_ffnam] < 0} {
									lappend goodfiles $orig_ffnam
								}
							} else {
								lappend goodfiles $orig_ffnam
							}
						}
					}
				}
				3 {
					foreach item $genselstrx {
						if [string match *$item $ffnam] {
							if {[info exists goodfiles]} {
								if {[lsearch -exact $goodfiles $orig_ffnam] < 0} {
									lappend goodfiles $orig_ffnam
								}
							} else {
								lappend goodfiles $orig_ffnam
							}
						}
					}
				}
			}
		}
		if [info exists goodfiles] {
			if {($gensel_notend > 0) && ([string length $genselendstr] > 0)} {
				catch {unset zurp}
				switch -- $gensel_notend {
					1 {
						foreach item $goodfiles {
							set ffnam [file tail $item]
							set ffnam [file rootname $ffnam]
							if {![regexp $genselendstr $ffnam]} {
								lappend zurp $item
							}
						}
					}
					2 {
						foreach item $goodfiles {
							set ffnam [file tail $item]
							set ffnam [file rootname $ffnam]
							if {![string match *$genselendstr $ffnam]} {
								lappend zurp $item
							}
						}
					}
				}
				if [info exists zurp] {
					set goodfiles $zurp
				} else {
					catch {unset goodfiles}
				}
			}
		}
		if [info exists goodfiles] {
			if {$gensel_sort} {
				foreach ffnam [lsort -dictionary $goodfiles] {
					lappend newgoodfiles $ffnam
				}
				set goodfiles $newgoodfiles
			}
			switch -- $from {
				"wl" {
					DoChoiceBak
					if {!$gensel_add} {
						ClearWkspaceSelectedFiles
						foreach ffnam $goodfiles {
							lappend chlist $ffnam		;#	add to end of list
							$ch insert end $ffnam		;#	add to end of display
							incr chcnt
						}
					} else {
						foreach ffnam $goodfiles {
							if {[LstIndx $ffnam $ch] < 0} {
								lappend chlist $ffnam		;#	add to end of list
								$ch insert end $ffnam		;#	add to end of display
								incr chcnt
							}
						}
					}
					set finished 1
				}
				"dl" {
					set zqhh 0
					catch {unset zqh}
					Block "Grabbing Selected Files"
					set goodfiles [ReverseList $goodfiles]
					foreach newfile $goodfiles {
						incr zqhh
					 	if [file isdirectory $newfile] {
							lappend zqh $newfile
							continue
						}
						if {$copy} {
							FileToWkspace $newfile 1 1 0 1 1
							set zfnam [file tail $newfile]
						} else {
							FileToWkspace $newfile 1 0 0 1 0
							set zfnam $newfile
						}
						if {[UpdatedIfAMix $zfnam 0]} {
							set save_mixmanage 1
						} elseif {[UpdatedIfANessFull $zfnam]} {
							set nessupdate 1
						}
					}										
					if {[info exists zqh] && ([llength $zqh] == $zqhh)} {
						Inf "All The Items You Selected Were Subdirectories"
					}
					UnBlock
					set finished 1
				}
			} 
		} else {
			switch -- $from {
				"wl" {
					Inf "No Matching Files On Workspace"
				}
				"dl" {
					Inf "No Matching Files On Source Directory Listing"
				}
			}
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy .genselect
}

#-------

proc EnabEnd {} {
	global gensel_notend genselendstr

	switch -- $gensel_notend {
		1 -
		2 {
			.genselect.butto4.e config -state normal -bd 2
		}	
		0 {
			.genselect.butto4.e config -state disabled -bd 0
			set genselendstr ""
		}
	}
}

#------ Attempt to rename several selected workspace files with a generic name

proc GenericRenameWkspaceFiles {} {
	global wl pr_gr o_nam hst ins gnuname generic chlist ch chcnt sysname evv
	global pa nu_names nunames_g keepgenno genrindex genrindexbak nessinit
	global wksp_cnt total_wksp_cnt ww background_listing pa scores_refresh sl_real dupl_mix dupl_vbx dupl_txt

	if {!$sl_real} {
		Inf "A Selected Set Of Files On The Workspace\nCan Be Given A Generic Name\n\nThe Name Of Individuals File Are Numbered\n\ne.g.Generic Name mysound\n\nFilenames mysound0, mysound1, mysound2 etc,"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0
	set save_mixmanage 0
	set g .genericnu
	if [Dlg_Create $g "GENERIC RENAME" "set pr_gr 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gi [frame $g.indx -borderwidth $evv(SBDR)]
		set go [frame $g.other -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_gr 0" -highlightbackground [option get . background {}]
		label $gn.l -text "Generic Name" -width 12
		button $gn.ok -text OK -width 6 -command "set pr_gr 1" -highlightbackground [option get . background {}]
		entry $gn.e -width 20 -textvariable gnuname
		pack $gn.ok $gn.l $gn.e -side left
		pack $gn.b -side right
		checkbutton	$gi.check -variable keepgenno -text "Keep existing numbering" -state disabled -command GRSwapIndex
		label $gi.ll -text "Number From"
		entry $gi.from -textvariable genrindex -width 5
		pack $gi.check -side left
		pack $gi.from $gi.ll -side right
		label $go.laba -text "Recent Names"
		set nunames_g [Scrolled_Listbox $go.nunames -height $evv(NSTORLEN) -selectmode single]
		label $go.bbb -text "standard names"
		set ku [frame $go.bbbb]
		button $ku.bb1 -text "$sysname(1)" -command "PutName .genericnu.name.e $sysname(1)" -highlightbackground [option get . background {}]
		button $ku.bb2 -text "$sysname(2)" -command "PutName .genericnu.name.e $sysname(2)" -highlightbackground [option get . background {}]
		button $ku.bb3 -text "$sysname(3)" -command "PutName .genericnu.name.e $sysname(3)" -highlightbackground [option get . background {}]
		button $ku.bb4 -text "$sysname(4)" -command "PutName .genericnu.name.e $sysname(4)" -highlightbackground [option get . background {}]
		button $ku.bb5 -text "$sysname(5)" -command "PutName .genericnu.name.e $sysname(5)" -highlightbackground [option get . background {}]
		pack $ku.bb1 $ku.bb2 $ku.bb3 $ku.bb4 $ku.bb5 -side left -padx 1
		bind .genericnu.other.nunames.list <ButtonRelease-1> {NameListChoose .genericnu.other.nunames.list .genericnu.name.e}
		pack $go.bbb $go.bbbb -side top -pady 1
		pack $go.laba $go.nunames -side top -fill x
		pack $g.name $g.indx $g.other -side top
		bind $g <Up> {IncrGenrindex 1}
		bind $g <Down> {IncrGenrindex -1}
		wm resizable $g 1 1
		bind $g <Return> {set pr_gr 1}
		bind $g <Escape> {set pr_gr 0}
	}
	set keepgenno 0
	set genrindex "0"
	set genrindexbak "0"

	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		destroy $g
		return
	}
	if {[info exists nessinit]} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Generic Name Substitions With Physical Modelling Files"
				return
			}
		}
	}
	if [info exists nu_names] { 
		.genericnu.other.nunames.list delete 0 end
		foreach nname $nu_names {							;#	Post recent names
			.genericnu.other.nunames.list insert end $nname
		}					
	}

	set gnuname ""
	set gn_dirname ""
	set is_numbered 1
	set rename_cnt 0 
	foreach i $ilist {
		set fnam [$wl get $i]								;#	get each selected file
		set basfnam [ExtractPreNumberName $fnam]			;#	check if it already has a generic-name-number
		if {$is_numbered} {									
			if {[string length $basfnam] <= 0} {
				set is_numbered 0
				catch {unset fno}
			} elseif {$rename_cnt == 0} {					;#	if files are generic-numbered
				set bas_basfnam $basfnam					;#	store generic-name root and list numberings used
				set bas_len [string length $bas_basfnam]
				lappend fno [ExtractGenericNumber $fnam $bas_len]
			} elseif {![string match $basfnam $bas_basfnam]} {
				set is_numbered 0							;#	check that generic-name root is same for all files
				catch {unset fno}
			} else {
				lappend fno [ExtractGenericNumber $fnam $bas_len]
			}
		}
		set gn_dirname [SameDirSameExt $fnam $rename_cnt $gn_dirname]

		if {[string length $gn_dirname] <= 0} {				;#	Also check all selected files in same directory
			destroy $g										;#	and have same name-extension
			return
		}
		lappend thisl $fnam
		incr rename_cnt
	}
	if [string match "." $gn_dirname] {
		set gn_dirname ""
	}
	if {$is_numbered} {										;#	If files already generic-name-numbered
		set keepgenno 1										;#	Enable ability to retain existing numbering
		set genrindex ""
		.genericnu.indx.from config -state disabled
		.genericnu.indx.check config -state normal
	} else {
		set keepgenno 0										;#	Otherwise disable that
		.genericnu.indx.from config -state normal
		.genericnu.indx.check config -state disabled
		set genrindex 0
	}

	set finished 0
	set pr_gr 0
	raise $g
	My_Grab 0 $g pr_gr $g.name.e
	while {!$finished} {
		tkwait variable pr_gr
		if {!$pr_gr} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			if {!$keepgenno} {								;#	If files are to be specifically re-numbered
				if {![regexp {^[0-9]+$} $genrindex]} {
					Inf "Value To 'number From' Must Be An Integer  >= 0"
					continue
				}
				set genrtop [expr $genrindex + $rename_cnt]	;#	Note top number for numbering files
			}
			set gnuname [string tolower $gnuname]
			set gnuname [FixTxt $gnuname "generic name"]	;#	massage name,
			if {[string length $gnuname] <= 0} {
				ForceVal .genericnu.name.e $gnuname
				continue
			}
			if [ValidCDPRootname $gnuname] {				;#	check its validity,
				if [regexp {[0-9]+$} $gnuname] {
					Inf "No Numerals Allowed At The End Of A Generic Name"
					continue
				} else {
					set OK 1								;#	and test its not already in use
					set basename $gn_dirname$gnuname
					set baselen [string length $basename]
					foreach fnam [glob -nocomplain $basename*] { 		;#	Find all names starting with new genericname
						if {![file isdirectory $fnam]} {
							if {[string length $fnam] > $baselen} {
								set zstr [string range $fnam $baselen end]	;#	Look at characters beyond genericname string
								if [regexp {^[0-9]+\.*} $zstr] {			;#	If numeric, followed by file extension
									set zstr [file rootname $zstr]			;#	extract the numeric string
									if {$keepgenno} {
										foreach zno $fno {					;#	If retaining existing generic numbering
											if [string match $zno $zstr] {
												set OK 0					;#	Test if any of those numbers
												break						;#	match the numeric string just found
											}
										}
										if {!$OK} {
											break
										}									;#	If using new automatic(new)numbering
									} elseif {($zstr >= $genrindex) && ($zstr < $genrtop)} {
										set OK 0							;#	check numeric string just found
										break								;#	lies outside range being used
									}
								}
							}
						}
					}
				}
                if {$OK} {
					set finished 1
				} else {
					Inf "Files Already Exist With The Generic Name '$fnam' Within The Numeric Range Specified"
				}				
			}
		}
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g

	if {$keepgenno} {
		set baslen [string length $basfnam]					;#	If files selected already have a generic-name,
	} else {												;#	note its length.
		set n $genrindex									;#	Else, set counter to start index for file numbering
	}
	set are_snds 0
	foreach i $ilist fnam $thisl {							;#	Find selected files and assocd indeces in wkspace list
		set is_snd 0
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set is_snd 1
		}
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]
		set extname [file extension $fnam]					;#	save filename extension
		set thisname [file tail $fnam]
		set thisrootname [file rootname $thisname]
		if {$keepgenno} {							  		;#	If orig nos retained, extract orig no
			set no [string range $thisrootname $baslen end]
		} else {
			set no $n										;#	Else, number consecutively
		}
		set nufnam $gnuname$no$extname			  			;#	Generate new name
		set nufnam [file join $gn_dirname $nufnam] 

		if [catch {file rename $fnam $nufnam}] {
			ErrShow "Cannot Rename File '$fnam'\nIt May Be Open For Play, Read or View\nClose It, To Rename From Item %d (Original Name '$fnam') Onwards\n"
			if {$ren_blist} {
				SaveBL $background_listing
			}
			return
		}
		DataManage rename $fnam $nufnam
		lappend couettelist $fnam $nufnam
		UpdateBakupLog $fnam delete 0
		UpdateBakupLog $nufnam create 1
		if {$haspmark} {
			MovePmark $fnam $nufnam
		}
		if {$hasmmark} {
			MoveMmark $fnam $nufnam
		}
		if [IsInBlists $fnam] {
			if [RenameInBlists $fnam $nufnam] {
				set ren_blist 1
			}
		}
		if [IsOnScore $fnam] {
			RenameOnScore $fnam $nufnam
		}
		$wl delete $i								
		$wl insert $i $nufnam
		catch {unset rememd}

		UpdateChosenFileMemory $fnam $nufnam
		set oldname_pos_on_chosen [LstIndx $fnam $ch]
		if {$oldname_pos_on_chosen >= 0} {
			RemoveFromChosenlist $fnam
			set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
			incr chcnt
			$ch insert $oldname_pos_on_chosen $nufnam
		}
		RenameProps	$fnam $nufnam 1
		DummyHistory $fnam "RENAMED_$nufnam"
		if {[MixMRename $fnam $nufnam 0]} {
			set save_mixmanage 1
		}
		RenameOnDirlist $fnam $nufnam
		if {!$keepgenno} {							  		;#	If not using orig nos, advance filename-index-counter
			incr n
		}
		if {$is_snd} {
			CheckMainmixSnd $fnam $nufnam
			set are_snds 1
		} else {	
			CheckMainmix $fnam $nufnam
		}	
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$are_snds} {
		set scores_refresh 1
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	foreach i $ilist {
		$wl selection set $i
	}
	return 1
}

#----- Enable or Disable start-index for generic numbering, depending on whether original numbering is being kept or not

proc GRSwapIndex {} {
	global genrindexbak genrindex keepgenno

	switch -- $keepgenno {
		0 {
			set genrindex $genrindexbak
			.genericnu.indx.from config -state normal
		}
		1 {
			set genrindexbak $genrindex
			set genrindex ""
			.genericnu.indx.from config -state disabled
		}
	}
}

#----- extract the existing genericname (before the final digits)

proc ExtractPreNumberName {fnam} {

	set fnam [file tail $fnam]
	set fnam [file rootname $fnam]

	if {![regexp {.+[0-9]+$} $fnam]} {
		return ""
	} else {
		regsub {[0-9]+$} $fnam {} fout
	}
	return $fout
}

#----- extract the existing generic-number

proc ExtractGenericNumber {fnam len} {

	set fnam [file tail $fnam]
	set fnam [file rootname $fnam]
	return [string range $fnam $len end]
}


#----- Check all selected files are in same directory and have same extension

proc SameDirSameExt {fnam cnt gn_dirname} {
	global gn_ext

	set thisname [file tail $fnam]
	if {$cnt == 0} {
		set gn_ext [file extension $fnam]
		set gn_dirname [file dirname $fnam]
	} elseif {![string match $gn_dirname [file dirname $fnam]]} {
		Inf "Cannot Use Generic Rename On Files From Different Directories"
		return ""
	} elseif {![string match $gn_ext [file extension $fnam]]} {
		Inf "Cannot Use Generic Rename On Files Of Different Types"
		return ""
	}
	return $gn_dirname
}

#----- Check all selected files are in same directory and have same extension

proc IncrGenrindex {n} {
	global genrindex

	if [string match "normal" [lindex [.genericnu.indx.from configure -state] end]] {
		set q $genrindex
		incr q $n
		if {$q < 0} {
			set q 0
		} elseif {$q > 10000} {
			set q 10000
		}
		set genrindex $q
	}
}

#--- Establish Listbox on Workspace for Displaying Directory

proc Setup_DirDisplay {} {
	global pr_5 ww dir_dlg_help_actvtd wksp_hlp_actv dl from_dirl sl_real wksp_dirname evv dobakuplog
	global new_user_text_extensions user_text_extensions version_number macsmall grabchans
	global released nessinit

	set f $ww.1.b
	set b0 [frame $f.labels -borderwidth $evv(BBDR)]
	set b [frame $f.buttons -borderwidth $evv(BBDR)]
	set b2 [frame $f.buttons2 -borderwidth $evv(BBDR)]
	set dl [Scrolled_Listbox $f.dirlist -width 20 -height $evv(WKSPACE_HEIGHT) -selectmode extended]

	frame $f.db -borderwidth $evv(BBDR)
	frame $f.db0 -borderwidth $evv(BBDR)
	frame $f.db0.z -borderwidth $evv(BBDR)
	label $f.db0.z.version -text "Version $version_number   " -font bigfnt -fg $evv(SPECIAL)
	pack $f.db0.z.version -side left
	if {$evv(NEWUSER_HELP)} {
		button $f.db0.z.starthelp -text "New User Help" -command "GetNewUserHelp workspace"  -highlightbackground [option get . background {}];# -bg $evv(HELP)
		pack $f.db0.z.starthelp -side top
	}
	pack $f.db0.z -side top -fill both -expand true
	label $f.db.ll -text "FIND" 
	if {$macsmall} {
		menubutton $f.db.db1 -text "Dir" -width 9 -menu $f.db.db1.sub -relief raised
	} else {
#RWD width was 18
		menubutton $f.db.db1 -text "Dir"  -menu $f.db.db1.sub -relief raised
	}
	set fd [menu $f.db.db1.sub -tearoff 0]
	$fd add command -label "Recent Directory" -command {ListRecentDirs workspace} -foreground black
	$fd add separator
	$fd add command -label "Any Directory" -command {DoListingOfDirectories $ww.1.b.de} -foreground black
#RWD width was 9
	menubutton $f.db.db2 -text "File"  -menu $f.db.db2.sub -relief raised
	set fd2 [menu $f.db.db2.sub -tearoff 0]
	$fd2 add command -label "Find A File On Your System" -command "FileFind 0 0 0" -foreground black
	$fd2 add separator
	$fd2 add command -label "Find A Soundfile On Your System" -command "FileFind 2 0 0" -foreground black
	$fd2 add separator
	$fd2 add command -label "Find A Soundfile In Mixfiles" -command "FileFind 1 0 0" -foreground black
	$fd2 add separator
	$fd2 add command -label "Find A File In B-Lists" -command "FileFind_inBLists 1" -foreground black

	pack $f.db.ll $f.db.db1 $f.db.db2 -side left -padx 1
	label $f.dm -text "Directory for Sources or Back-Ups" 
	entry $f.de -width 26 -textvariable wksp_dirname
	frame $f.bl -height 1 -bg [option get . foreground {}]

	label $f.msg -text "Source Directory" -font bigfnt
	label $f.msgx -text "Activate From 'List'" -background $evv(EMPH)
	label $b0.msg2 -text "Sndfile extension '$evv(SNDFILE_EXT)'"
	if {$evv(DFLT_SR) > 0} {
		label $b0.msg3 -text "(Srate $evv(DFLT_SR) only)"
	} else {
		label $b0.msg3 -text "ALL Srates"
	}
	pack $b0.msg2 $b0.msg3 -side left -fill x -expand true

	button $b2.up -text "Up" -width 2 -command {GetSuperdir} -highlightbackground [option get . background {}]
#RWD need to see all text!
#	menubutton $b2.lis -text "List" -width 5 -menu $b2.lis.menu -relief raised -bg $evv(EMPH)
    menubutton $b2.lis -text "List"  -menu $b2.lis.menu -relief raised -bg $evv(EMPH)
	set mx [menu $b2.lis.menu -tearoff 0]
	$mx add command -label "Do It Again" -command {}  -foreground black
	$mx add separator
	$mx add command -label "" -command {} -foreground black
	$mx add separator
	$mx add command -label "LIST FROM SPECIFIED DIRECTORY" -command {}  -foreground black
	$mx add separator
	$mx add command -label "List Named Directory" -command {GetFilesToSrcDirListing $ww.1.b.de $ww.1.b; SetSel4 list} -foreground black
	$mx add command -label "List Previous Directory" -command {GetLastDir; SetSel4 lastdir} -foreground black
	$mx add command -label "Previous Listing" -command {GetPreviousDir; SetSel4 lastlist} -foreground black
	$mx add separator
	$mx add command -label "Subdirectories Only" -command "GetSubdirNames; SetSel4 subdirs" -foreground black
	$mx add command -label "Other Subdirectories" -command "GetThisLevelSubdirNames; SetSel4 subtldirs" -foreground black
	$mx add command -label "List Without Subdirectories" -command "NoSubdirNames; SetSel4 nosubs" -foreground black
	$mx add cascade -label "Specified Extension to filenames, Only"  -menu $mx.sub1 -foreground black
	set mxx [menu $mx.sub1 -tearoff 0]
	set extension_list [list aif aiff ana bat evl for frq trn txt wav]
	if {[info exists new_user_text_extensions]} {
		foreach item $new_user_text_extensions {
			set thistxtu [string range $item 1 end]
			lappend extension_list $thistxtu
		}
	} elseif {[info exists user_text_extensions]} {
		foreach item $user_text_extensions {
			set thistxtu [string range $item 1 end]
			lappend extension_list $thistxtu
		}
	}
	if {[info exists nessinit]} {
		lappend extension_list [string range $evv(NESS_EXT) 1 end]
	}
	set extension_list [lsort -ascii $extension_list]
	foreach item $extension_list {
		set thistxtu [string tolower $item]
		set thistxtl [string tolower $item]
		$mxx add command -label "$thistxtu" 	-command "GetDirExt $thistxtl; SetSel4 $thistxtl" -foreground black
	}
	$mx add command -label "Search By Specified String"  -command "StrGetDl; SetSel4 search" -foreground black
	$mx add cascade -label "List Without Directory Path"  -command "HiddenDirname; SetSel4 nodir" -foreground black
	$mx add cascade -label "Specified Channel Count"  -menu $mx.sub2
	set mxx2 [menu $mx.sub2 -tearoff 0]
	set chancnt_list [list 1 2 4 5 7 8 16]
	foreach item $chancnt_list {
		$mxx2 add command -label "$item" 	-command "GetDirChan $item; SetSel4 $item"
	}
	$mx add cascade -label "SORT LISTING ON ..."  -command {} ;# -background $evv(HELP) -foreground black
	$mx add cascade -label "Number At End Of Name"  -command "SortDir 1 0; SetSel4 endnum" -foreground black
	$mx add cascade -label "Number At End Of Name: In Reverse"  -command "SortDir 1 1; SetSel4 endnumr" -foreground black
	$mx add cascade -label "Number At Start Of Name"  -command "SortDir 0 0; SetSel4 sttnum" -foreground black
	$mx add cascade -label "Number At Start Of Name: In Reverse"  -command "SortDir 0 1; SetSel4 sttnumr" -foreground black
	$mx add cascade -label "Date Of Production: Oldest To Top"  -command "SortDirDate 0; SetSel4 srtdate" -foreground black
	$mx add cascade -label "Date Of Production: Newest To Top"  -command "SortDirDate 1; SetSel4 srtetad" -foreground black
	$mx add separator
	$mx add command -label "HOME DIRECTORY" -command {}  -foreground black
	$mx add separator
	$mx add command -label "List Home Directory" -command "LoadHomeDirectory; SetSel4 home" -foreground black
	button $b2.play -text "Play:Read" -command {Inf "Double Click On Item In List -OR- Select It And Use Space Bar"} -width 9 -highlightbackground [option get . background {}]
#	menubutton $b2.get -text "Grab" -width 5 -menu $b2.get.menu -relief raised
    menubutton $b2.get -text "Grab" -menu $b2.get.menu -relief raised
	set mg [menu $b2.get.menu -tearoff 0]
	$mg add command -label "GRAB CURSOR SELECTED FILES" -command {}  -foreground black
	$mg add separator
	if {!$sl_real} {
		$mg add command -label "Use on Workspace" -command TellDoGrab -foreground black
		$mg add command -label "Copy and Use Copies" -command TellDoCopy -foreground black
		$mg add command -label "Find on Workspace" -command TellDoFind -foreground black
		$mg add separator
		$mg add command -label "GRAB ALL FILES" -command {}  -foreground black
		$mg add separator
		$mg add command -label "Use All Files" -command TellGrabAll -foreground black
	} else {
		$mg add command -label "Use on Workspace" -command {set pr_5 $evv(DO_GRAB)} -foreground black
		$mg add command -label "Copy and Use Copies" -command {set pr_5 $evv(DO_COPY)} -foreground black
		if {[info exists released(copysfx)]} {
			$mg add command -label "COPY to Standard Format" -command {set pr_5 $evv(DO_SPECIAL_COPY)} -foreground black
		}
		$mg add command -label "Find on Workspace" -command {set pr_5 $evv(DO_FIND)} -foreground black
		$mg add separator
		$mg add command -label "GRAB ALL FILES" -command {} ;# -background $evv(HELP) -foreground black
		$mg add separator
		$mg add command -label "Use All Files" -command {set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add separator
		$mg add command -label "GRAB N-CHANNEL SNDFILES" -command {} -foreground black
		$mg add separator
		$mg add command -label "Mono" -command {set grabchans 10000; set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add command -label "Stereo" -command {set grabchans 2; set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add command -label "4 channel" -command {set grabchans 4; set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add command -label "5 channel" -command {set grabchans 5; set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add command -label "7 channel" -command {set grabchans 7; set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add command -label "8 channel" -command {set grabchans 8; set pr_5 $evv(GRAB_ALL)} -foreground black
		$mg add command -label "16 channel" -command {set grabchans 16; set pr_5 $evv(GRAB_ALL)} -foreground black
	}
	$mg add separator
	$mg add command -label "GRAB FILES WITH GENERIC NAME" -command {}  -foreground black
	$mg add separator
	$mg add command -label "Use on Workspace" -command "Generic_Select dl 0" -foreground black
	$mg add command -label "Copy and Use Copies" -command "Generic_Select dl 1" -foreground black
	$mg add separator
	$mg add command -label "SEARCH FOR A FILE" -command {}  -foreground black
	$mg add separator
	$mg add command -label "Search Directory Listing" -command {SearchDirectoryListing} -foreground black
	$mg add command -label "Find File On Workspace" -command {SearchWorkspaceForDirFile} -foreground black
	$mg add command -label "Find File In Logs" -command {SearchLogsForFile $dl} -foreground black
	$mg add separator
	$mg add command -label "PITCH MARKS" -command {}  -foreground black
	$mg add separator
	$mg add command -label "Create, View Or Edit" -command {Do_Pitchmark $dl 0} -foreground black
	$mg add command -label "Delete (!!)" -command {Do_Pitchmark $dl 1} -foreground black

	pack $b2.lis $b2.up $b2.play $b2.get -side left -expand true -padx 1

	button $b.refr -text "Refresh" -command {set pr_5 0} -width 6 -highlightbackground [option get . background {}]
#RWD width was 9
	menubutton $b.dest -text "Destroy"  -menu $b.dest.menu -relief raised
	set m [menu $b.dest.menu -tearoff 0]
	$m add command -label "FILES" -command {}  -foreground black
	$m add separator
	if {!$sl_real} {
		$m add command -label "Selected Files" -command TellDestroyDirFiles -foreground black
	} else {
		$m add command -label "Selected Files" -command {set pr_5 $evv(DELETE_SOME)}  -foreground black
	}
	$m add separator
	$m add command -label "DIRECTORY (!!!)" -command {}  -foreground black
	$m add separator
	if {!$sl_real} {
		$m add command -label "All Files In Listed Directory (!!!)" -command TellDestroyDir -foreground black
	} else {
		$m add command -label "All Files In Listed Directory (!!!)" -command {set pr_5 $evv(DELETE_ALL)} -foreground black
		$m add command -label "And (Optionally) The Directory"      -command {set pr_5 $evv(DELETE_ALL)} -foreground black
	}
#RWD width was 7
	menubutton $b.srate -text "Srate"  -menu $b.srate.menu -relief raised
	set m [menu $b.srate.menu -tearoff 0]
	$m add command -label "All"   -command "ResetSrate 0 	 $f.labels.msg3" -foreground black
	$m add command -label "96000" -command "ResetSrate 96000 $f.labels.msg3" -foreground black
	$m add command -label "88200" -command "ResetSrate 88200 $f.labels.msg3" -foreground black
	$m add command -label "48000" -command "ResetSrate 48000 $f.labels.msg3" -foreground black
	$m add command -label "44100" -command "ResetSrate 44100 $f.labels.msg3" -foreground black
	$m add command -label "32000" -command "ResetSrate 32000 $f.labels.msg3" -foreground black
	$m add command -label "24000" -command "ResetSrate 24000 $f.labels.msg3" -foreground black
	$m add command -label "22040" -command "ResetSrate 22050 $f.labels.msg3" -foreground black
	$m add command -label "16000" -command "ResetSrate 16000 $f.labels.msg3" -foreground black

	pack $b.srate $b.refr $b.dest -side left -padx 1 -expand true
	pack $f.db0 -side top -pady 1
	pack $f.db $f.dm $f.de -side top -pady 2
	pack $f.bl -side top -fill x -expand true

	frame $f.sesst
	label $f.sesst.ss -text "Session Start" -width 13 -foreground $evv(SPECIAL)
	button $f.sesst.ul -text "" -command {} -bd 0 -highlightbackground [option get . background {}]
	pack $f.sesst.ss -side left
	pack $f.sesst.ul -side right
 
	frame $f.daydate
	label $f.daydate.dd -text "[EstablishSessionDateDisplay]" -font bigfnt -foreground $evv(SPECIAL)
	button $f.daydate.th -text "ManageThumbs" -width 13 -command {ThumbSee 0} -highlightbackground [option get . background {}]

	pack $f.msg $f.msgx $f.labels $f.buttons $f.buttons2 $f.dirlist -side top -fill x -expand true
	pack $f.sesst -side top -pady 8 -fill x -expand true
	pack $f.daydate.dd -side left
	pack $f.daydate.th -side right

	pack $f.daydate -side top -fill x -expand true

	if {$wksp_hlp_actv && !$dir_dlg_help_actvtd} {
		ActivateDirDialogHelp	
	}
	set wksp_dirname ""
	bind $dl <ButtonPress-1> {PossiblySaveWkspaceSelection}
	bind $dl <ButtonRelease-1> {PossiblyGetSubdir}
	bind $dl <Double-1> {PossiblyPlaySnd %W %y}

	if {$dobakuplog} {
		$f.sesst.ul config -text "See Update Log" -command "WarnBakupLog 2" -bd 2
	} else {
		$f.sesst.ul config -text "" -command {} -bd 0
	}
	if {[info exists released(mchanpan)]} {
		$f.daydate.th config -text "ManageThumbs" -command {ThumbSee 0} -bd 2
	} else {
		$f.daydate.th config -text "" -command {} -bd 0
	}
}

#--- List contents of subdirectory selected on Source Directory Listing

proc GetSubdir {} {
	global dl hidden_dir

	set ilist [$dl curselection]
	if {![info exists ilist] || ([llength $ilist] <=0)} {
		Inf "No Item Selected."
		return
	}
	set gotdir ""
	foreach item $ilist {
		set fnam [$dl get $item]
		if {[string length $hidden_dir] > 0} {
			set fnam [file join $hidden_dir $fnam]
		}
		if [file isdirectory $fnam] {
			if {[string length $gotdir] > 0} {
				Inf "More Than One Subdirectory Selected."
				return
			}
			set gotdir $fnam
		}
	}
	if {[string length $gotdir] <= 0} {
		Inf "The Selected Item Is Not A Subdirectory"
		return
	}
	LoadSubDirectory $gotdir
}

#--- List contents of directory which contains the directory listed on Source Directory Listing

proc GetSuperdir {} {
	global ww wksp_dirname evv is_subdirlist dl ww_lastdir
	if {[info exists is_subdirlist]} {
		set ww_lastdir [$ww.1.b.de get]
		if {[info exists wksp_dirname]} {
			if {[string length $wksp_dirname] <= 0} {
				GetFilesToSrcDirListing $ww.1.b.de $ww.1.b
			} else {
				LoadSubDirectory $wksp_dirname
			}
		}
		catch {unset is_subdirlist}
		return
	}
	if {[string length $wksp_dirname] <= 0} {
		return
	}
	set ww_lastdir [$ww.1.b.de get]

	set temp [split $wksp_dirname "/"]
	set len [llength $temp]
	if {$len < 1} {
		return
	} elseif {$len == 1} {
		set wksp_dirname ""
		GetFilesToSrcDirListing $ww.1.b.de $ww.1.b
		return
	}

	incr len -2
	set temp [lrange $temp 0 $len]
	set filename [lindex $temp 0]
	foreach item [lrange $temp 1 $len] {
		set filename [file join $filename $item]
	}
	if {$evv(SYSTEM) == "PC"} {
		set k [string first ":" $filename]
		if {$k > 0} {
			set kk $k
			incr kk
			if {![string match "/" [string index $filename $kk]]} {
				set zurb [string range $filename 0 $k]
				append zurb	"/"
				append zurb [string range $filename $kk end]
				set filename $zurb
			}
		}
	}
	LoadSubDirectory $filename
}

proc AboutCDP {} {
	global pr_about evv
	set f .about
	if [Dlg_Create  $f "About the CDP" "set pr_about 0"	-borderwidth $evv(SBDR) -bg $evv(ABOUT)] {
		button $f.ok -text "OK" -command "set pr_about 0" -highlightbackground [option get . background {}]
		label $f.0 -text ""
		label $f.1 -text "The COMPOSERS' DESKTOP PROJECT" -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.2 -text "was established in York, UK, in 1986," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.3 -text "by Martin Atkins, Andrew Bentley, Archer Endrich," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.4 -text "David Malham, Richard Orton, and Trevor Wishart." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.5 -text ""
		label $f.6 -text "It was the first organisation to port serious sound" -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.7 -text "processing software onto desktop computers," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.8 -text "and to operate as a cooperative network, sharing " -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.9 -text "both the use and development of music software tools." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.10 -text ""
		label $f.11 -text "Contributors have included..." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.12 -text "Adrian Armstrong, Mark Bilton, Peter Bowcott," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.13 -text "Michael Clarke, Richard Dobson, Florian Eidenbanz," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.14 -text "Rajmil Fischman, John Fitch, Robert Fraser," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.15 -text "Mark Grimshaw, Oyvind Hammer, David Humpage, Andy Hunt" -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.16 -text "Celeste Hutchins, Leigh Landy, Nick Laviers, Bertrand Melier," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.17 -text "Manuel Op de Coul, Richard Polfreman, Melvyn Poore," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.18 -text "David Rossiter, Hans Strasburger, Philippos Theocharidis," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.19 -text "Rob Waring, Tom Williams and Loisa Yong." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.20 -text ""
		label $f.21 -text "The soundfiling system was the work of Martin Atkins." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.22 -text "The majority of the Sound Processing Tools were developed" -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.23 -text "by Trevor Wishart, who continues to maintain them." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.24 -text "The main system programmer and developer is Richard Dobson." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.25 -text "The reference documentation has been written by Archer Endrich" -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.26 -text "who has administered the project since its outset." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.27 -text ""
		label $f.28 -text "The Sound Loom graphic interface was created by Trevor Wishart," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.29 -text "with special thanks to Folkmar Hein and the DAAD in Berlin," -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.30 -text "and the AHRB UK." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.31 -text "The 'Leeds' colour scheme is the work of Dale Perkins." -fg $evv(SPECIAL) -bg $evv(ABOUT)
		label $f.32 -text ""
		pack $f.ok -side top
		pack $f.0 $f.1 $f.2 $f.3 $f.4 $f.5 $f.6 $f.7 $f.8 $f.9 $f.10 $f.11 $f.12 -side top -fill x -expand true
		pack $f.13 $f.14 $f.15 $f.16 $f.17 $f.18 $f.19 $f.20 $f.21 $f.22 $f.23 -side top -fill x -expand true
		pack $f.24 $f.25 $f.26 $f.27 $f.28 $f.29 $f.30 $f.31 $f.32 -side top -fill x -anchor w
		bind $f <Return> {set pr_about 0}
		bind $f <Escape> {set pr_about 0}
		bind $f <Key-space> {set pr_about 0}
	}
	set pr_about 0
	raise $f
	My_Grab 0 $f pr_about
	tkwait variable pr_about
	My_Release_to_Dialog $f
	destroy $f
}

proc DoTimetap {} {
	global tap_on tap_t evv

	set tap_t($tap_on) [clock clicks]
	incr tap_on
	if {$tap_on > 1} {
		.workspace.1.a.mez.tap config -state disabled -bg [option get . background {}]
		set tap_on 0
		set secs [expr (double($tap_t(1) - $tap_t(0))) / $evv(CLOCK_TICK)]
		set tempo [expr int(round(60.0 / $secs))]
		Inf "$secs Seconds : MM = $tempo"
		.workspace.1.a.mez.tap config -state normal
		.workspace.1.a.mez.taptwo config -state normal
	} else {
		.workspace.1.a.mez.tap config -bg $evv(EMPH)
		.workspace.1.a.mez.taptwo config -state disabled
	}
}

proc DoTwoTimetap {} {
	global twotap twotap_t tap_on evv

	set twotap_t($twotap) [clock clicks]
	if {!$twotap} {
		.workspace.1.a.mez.tap config -text "Stop" -command TapCalc -bg $evv(EMPH)
		.workspace.1.a.mez.taptwo config -bg $evv(EMPH)
		set tap_on 0
	}	
	incr twotap
}

proc TapCalc {} {
	global twotap twotap_t evv

	if {$twotap < 3} {
		Inf "Not Enough Taps Made"
		set twotap 0
		.workspace.1.a.mez.tap config -text "Dur" -command DoTimetap -bg [option get . background {}]
		.workspace.1.a.mez.taptwo config -bg [option get . background {}]
		return
	}
	.workspace.1.a.mez.tap config -state disabled -bg [option get . background {}]
	.workspace.1.a.mez.taptwo config -state disabled -bg [option get . background {}]
	set n 0 
	set m 1
	set total_secs 0
	while {$m < $twotap} {
		set secs [expr (double($twotap_t($m) - $twotap_t($n))) / $evv(CLOCK_TICK)]
		set total_secs [expr $total_secs + $secs]
		incr m
		incr n
	}
	set twotap 0
	set secs [expr $total_secs / double($n)]
	set tempo [expr int(round(60.0 / $secs))]
	Inf "$secs Seconds : MM = $tempo"
	.workspace.1.a.mez.tap config -text "Dur" -command DoTimetap -state normal
	.workspace.1.a.mez.taptwo config -state normal
}

#---------

proc ListRecentDirs {towhere} {
	global recent_dirs pr_rdirs rdirlist sl_real evv

	if {!$sl_real} {
		Inf "You Can See A List Of Recently Used Directories,\nAnd Select One Of These With The Mouse\nFor Use As The Current Directory On The\nWorkspace Directory Listing"
		return
	}
	if {![info exists recent_dirs]} {
		return
	}
	if {$towhere == "workspace"} {
		SaveWkstate
	}
	set f .rdirs
	if [Dlg_Create  $f "Recent Directories" "set pr_rdirs 0" -borderwidth $evv(SBDR)] {
		button $f.quit -text "Close" -command "set pr_rdirs 0" -highlightbackground [option get . background {}]
		set rdirlist [Scrolled_Listbox $f.l -width 64 -height 24 -selectmode single -bg $evv(EMPH)]
		pack $f.quit $f.l -side top
		bind $f <Return> {set pr_rdirs 0}
		bind $f <Escape> {set pr_rdirs 0}
		bind $f <Key-space> {set pr_rdirs 0}
	}
	bind $rdirlist <ButtonRelease-1> "DoRdirSelect $towhere"

	$rdirlist delete 0 end
	foreach rd $recent_dirs {
		$rdirlist insert end $rd 
	}
	raise $f
	update idletasks
	StandardPosition2 $f
	set pr_rdirs 0
	set finished 0
	My_Grab 0 $f pr_rdirs $rdirlist
	while {!$finished} {
		tkwait variable pr_rdirs
		if {$pr_rdirs == 0} {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	if {$towhere == "workspace"} {
		RestoreWkstate		
	}
}

#---- Select item from Recent Directories List

proc DoRdirSelect {towhere} {
	global rdirlist pr_rdirs wksp_dirname active_dir dl recent_dirs ww
	if {![info exists rdirlist]} {
		return
	}
	set i [$rdirlist curselection]
	if {$i >= 0} {
		if {[string match $towhere "workspace"]} {
			set wksp_dirname [$rdirlist get $i]
			set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
			if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
				return
			} elseif {([string length $dirname] > 0) && (![file isdirectory $dirname])} {
				 Inf "Invalid Directory Name Given"
				return
			}
			if {[info exists active_dir]} {
				$dl delete 0 end
				foreach fnam [lsort -dictionary [glob -nocomplain [file join $dirname *]]] {
					if [IsListableFile $fnam] {
						set fnam [string tolower $fnam]
						$dl insert end $fnam		;#	and place them in the listing window
					}
				}
				set recent_dirs [lreplace $recent_dirs $i $i]
				set recent_dirs [linsert $recent_dirs 0 $dirname]
			}
		} else {
			ForceVal $towhere [$rdirlist get $i]
		}
		set pr_rdirs 0
	} else {
		set pr_rdirs 1
	}
}

#----

proc UpdateRecentDirs {dirname} {
	global recent_dirs

	if {[string length $dirname] <= 0} {
		return
	}
	if [info exists recent_dirs] {
		set OK 1
		set i 0
		foreach rd $recent_dirs {
			if [string match $rd $dirname] {
				set OK 0
				break
			}
			incr i
		}
		if {$OK} {
			set recent_dirs [linsert $recent_dirs 0 $dirname]
			if {[llength $recent_dirs] > 40} {
				set recent_dirs [lrange $recent_dirs 0 39]
			}
		} elseif {$i > 0} {
			set q [lindex $recent_dirs $i]
			set recent_dirs [lreplace $recent_dirs $i $i]
			set recent_dirs [linsert $recent_dirs 0 $q]
		}
	} else {
		lappend recent_dirs $dirname
	}
}

#------ Get listing of Recently USed Directories from listing file

proc GetRecentDirsFromFile {} {
	global recent_dirs evv 

	set rd_file [file join $evv(URES_DIR) $evv(RECDIRS)$evv(CDP_EXT)]

	if {![file exists $rd_file]} {
		return
	}
	if [catch {open $rd_file r} fileId] {
		Inf $fileId							;#	If srcs file cannot be opened
		return		
	}
	catch {unset recent_dirs}
	while { [gets $fileId dir_name] >= 0} {			;#	Read lines from srcs file into text-listing
		if {[file exists $dir_name] && [file isdirectory $dir_name]} {
			lappend recent_dirs $dir_name
		}
	}
	close $fileId
}

#------ Read state of system-testing flags

proc GetTestFlags {} {
	global tw_testing gobo_testing text_edit_style cmdline_testing bakup_hiding cdparams_testing evv

	set cmdline_testing 0
	set bakup_hiding 0
	set cdparams_testing 0
	set tw_testing 0
	set gobo_testing 0
	set text_edit_style 0

	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(CDP_TESTS)$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} testId] {
		Inf "Cannot Open The Testflags File '$fnam': Setting The CDP Defaults"
		return
	}
	set n 0
	while {[gets $testId line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			set test($n) $line
		    incr n
		}
	}
	close $testId
	if {$n < 1} {
		Inf "Anomaly In Reading The Testflags In File '$fnam': Setting The Cdp Defaults"
		return
	}
	if {![string match "0" $test(0)] && ![string match "1" $test(0)]} {
		Inf "Anomalous Value ($test(0)) For 1st (Workspace_Load) Test Flag In File '$fnam' (Must Be 0 Or 1)\n\nSetting The CDP Default"
		set tw_testing 0
	} else {
		set tw_testing $test(0)	
	}
	if {$n > 1} {
		if {![string match "0" $test(1)] && ![string match "1" $test(1)]} {
			Inf "Anomalous Value ($test(1)) For 2nd (Gobo_Test) Test Flag In File '$fnam' (Must Be 0 Or 1)\n\nSetting The CDP Defaults For All Testflags"
			set gobo_testing 0
		} else {
			set gobo_testing $test(1)
		}
	}
	if {$n > 2} {
		if {!([string match "0" $test(2)] || [string match "1" $test(2)] || [string match "2" $test(2)])} {
			Inf "Anomalous Value ($test(2)) For 3rd (Text_Edit_Style) Test Flag In File '$fnam' (Must Be 0, 1 Or 2)\n\nSetting The CDP Defaults For All Testflags"
			set text_edit_style 0
		} else {
			set text_edit_style $test(2)
		}
	}
	if {$n > 3} {
		if {!([string match "0" $test(3)] || [string match "1" $test(3)])} {
			Inf "Anomalous Value ($test(3)) For 4th (Show_Cmdlines) Test Flag In File '$fnam' (Must Be 0, 1)\n\nSetting The CDP Default (0)"
			set cmdline_testing 0
		} else {
			set cmdline_testing $test(3)
		}
	}
	if {$n > 4} {
		if {!([string match "0" $test(4)] || [string match "1" $test(4)])} {
			Inf "Anomalous Value ($test(4)) For 5th (Hide_Bakup_Dirs) Test Flag In File '$fnam' (Must Be 0, 1)\n\nSetting The CDP Default (0)"
			set bakup_hiding 0
		} else {
			set bakup_hiding $test(4)
		}
	}
	if {$n > 5} {
		if {!([string match "0" $test(5)] || [string match "1" $test(5)])} {
			Inf "Anomalous Value ($test(5)) For 6th (Show_Cdparams_Cmd) Test Flag In File $fnam (Must Be 0, 1)\n\nSetting The CDP Default (0)"
			set cdparams_testing 0
		} else {
			set cdparams_testing $test(5)
		}
	}
}

#------ Save state of system-testing flags

proc SaveTestFlags {} {
	global new_tw_testing new_gobo_testing new_text_edit_style tw_testing gobo_testing text_edit_style evv
	global cmdline_testing new_cmdline_testing new_bakup_hiding bakup_hiding cdparams_testing new_cdparams_testing
	global orig_text_edit_style

	if {[info exists orig_text_edit_style]} {
		set text_edit_style $orig_text_edit_style 
	}

	if {($new_tw_testing == $tw_testing) \
	&& ($new_bakup_hiding == $bakup_hiding) \
	&& ($new_gobo_testing == $gobo_testing) \
	&& ($new_cmdline_testing == $cmdline_testing) \
	&& ($new_cdparams_testing == $cdparams_testing) \
	&& ($new_text_edit_style == $text_edit_style)} {
		return
	}
	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(CDP_TESTS)$evv(CDP_EXT)]

	if [catch {open $evv(DFLT_TMPFNAME) w} fileId] {
		Inf "Cannot Open File '$evv(DFLT_TMPFNAME)' To Save State Of System Testflags"
		if [catch {file delete $fnam}] {
			ErrShow "CANNOT DELETE EXISTING TESTVALUES FILE $fnam:\n\nSYSTEM WILL AUTOMATICALLY RESET TO CURRENT TEST-STATE AT NEXT SESSION.\n\nTO AVOID THIS, DELETE THE FILE $fnam FROM YOUR SYSTEM."
		}
		return
	}	
	puts $fileId $new_tw_testing
	puts $fileId $new_gobo_testing
	puts $fileId $new_text_edit_style
	puts $fileId $new_cmdline_testing
	puts $fileId $new_bakup_hiding
	puts $fileId $new_cdparams_testing
	close $fileId
	if [file exists $fnam] {
		if [catch {file delete $fnam}] {
			ErrShow "CANNOT DELETE EXISTING TESTVALUES FILE $fnam:\n\nSYSTEM WILL AUTOMATICALLY RESET TO ITS CURRENT TEST-STATE AT NEXT SESSION.\n\nTO AVOID THIS, DELETE THE FILE $fnam FROM YOUR SYSTEM."
			if [catch {file delete $evv(DFLT_TMPFNAME)}] {
				ErrShow "CANNOT DELETE TEMPORARY FILE $evv(DFLT_TMPFNAME)"
			}
			return
		}
	}
	if [catch {file rename $evv(DFLT_TMPFNAME) $fnam}] {
		ErrShow "FAILED TO SAVE NEW TESTFLAGS DATA IN FILE $fnam\n\nSYSTEM WILL REVERT TO CDP DEFAULTS AT NEXT SESSION"
		if [catch {file delete $evv(DFLT_TMPFNAME)}] {
			ErrShow "CANNOT DELETE TEMPORARY FILE $evv(DFLT_TMPFNAME)"
		}
	}
	return
}

#------ Change Test-State of System

proc SetTestFlags {} {
	global new_tw_testing new_gobo_testing pr_tests new_cmdline_testing new_bakup_hiding gobo_info valz development_version evv 
	global new_cdparams_testing show_the_gobo testzog testzog2 testzog4 testzog5 skipp

	set f .testflags
	if [Dlg_Create  $f "System Tests" "set pr_tests 0" -borderwidth $evv(SBDR)] {
		button $f.ok -text "OK" -command "set pr_tests 0" -highlightbackground [option get . background {}]
		if {$development_version} {
			frame $f.f0 -bg [option get . foreground {}] -height 1
			label $f.la -text "FOR NEXT SESSION"
			frame $f.f1 -bg [option get . foreground {}] -height 1
		}
		label $f.ll -text "Set Up Test Routines" -fg $evv(SPECIAL)
		if {$development_version} {
			checkbutton	$f.skip -variable skipp -text "SKIP CHECKS AND DISPLAYS AT STARTUP" -command {SetSkip $skipp}
			checkbutton	$f.see  -variable valz -text "SEE RESTRICTIONS IMPOSED BY GOBO\nFrom 'INFO process' on Process Page" -command {set gobo_info $valz}
			checkbutton	$f.tw   -variable new_tw_testing   -text "DO NOT LOAD WORKSPACE AT SESSION START\nnor Save Workspace at Session End"
			checkbutton	$f.bakup -variable new_bakup_hiding -text "DO NOT SAVE BACKUP DIRECTORIES\nor display them at Session start and end"
			checkbutton	$f.gobo2 -variable show_the_gobo -text "SHOW THE GOBO\nON GOING TO PROCESS PAGE"
			checkbutton	$f.gobo -variable new_gobo_testing -text "PRINT GOBO COMMANDS\nON GOING TO PROCESS PAGE"
			checkbutton	$f.cdpar -variable new_cdparams_testing -text "SHOW CDPARAMS COMMAND\nWHEN SELECTING A PROCESS"
			checkbutton	$f.newp3 -variable testzog4 -text "SHOW ALL FILE PROPERTIES\nFROM WORKSPACE SELECTED FILE BUTTON"
			checkbutton	$f.newp5 -variable testzog5 -text "SHOW STATUS OF WORKSPACE FILES" -command "FileStatus"
		} else {
			label $f.skip -text ""
			label $f.see -text "\n"
			label $f.tw -text "\n"
			label $f.bakup -text "\n"
			label $f.gobo -text "\n"
			label $f.gobo2 -text "\n"
			label $f.cdpar -text "\n"
			label $f.cdbm -text "\n"
			label $f.newp3 -text ""
			label $f.newp5 -text ""
		}
		checkbutton	$f.cmdl -variable new_cmdline_testing -text "SHOW COMMANDLINE\nON RUNNING A PROCESS"
		pack $f.ok -side top -pady 4
		pack $f.skip $f.ll $f.cmdl $f.cdpar $f.gobo2 $f.gobo $f.see $f.newp3 $f.newp5 -side top -pady 4
		if {$development_version} {
			pack $f.f0 -side top -fill x -expand true -pady 2
			pack $f.la -side top -pady 4
			pack $f.f1 -side top -fill x -expand true -pady 2
		}
		pack $f.ll $f.tw $f.bakup -side top -pady 4
	}
	raise $f
	set pr_tests 0
	My_Grab 0 $f pr_tests
	tkwait variable pr_tests
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc SetSkip {skip} {
	global evv
	set fnam [file join $evv(URES_DIR) skipfast$evv(CDP_EXT)]
	switch -- $skip {
		0 {
			if {[file exists $fnam]} {
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Forget To Skip Preliminaries, As Cannot Destroy File $fnam"
				}
			}
		}
		1 {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Remember To Skip Preliminaries, As Cannot Create File $fnam"
			} else {
				close $zit
			}
		}
	}
}

#------ Change Brkpnt Edit Style

proc SetEditStyle {} {
	global text_edit_style new_text_edit_style orig_text_edit_style pr_tests2 evv

	if {![info exists orig_text_edit_style]} {
		set orig_text_edit_style $text_edit_style
	}
	set f .testflags2
	if [Dlg_Create  $f "Edit Style" "set pr_tests2 0" -borderwidth $evv(SBDR)] {
		button $f.ok -text "OK" -command "set pr_tests2 0" -highlightbackground [option get . background {}]
		frame $f.f0 -bg [option get . foreground {}] -height 1
		label $f.la -text "FOR NEXT SESSION"
		frame $f.f1 -bg [option get . foreground {}] -height 1
		label $f.l -text "Set up Breakpoint Edit Style" -fg $evv(SPECIAL)
		radiobutton $f.0 -variable new_text_edit_style -text "RETAIN A CHOICE    " -value 0
		radiobutton $f.1 -variable new_text_edit_style -text "ALWAYS EDIT TEXT  "  -value 1
		radiobutton $f.2 -variable new_text_edit_style -text "ALWAYS EDIT GRAPH"   -value 2
		pack $f.ok -side top -pady 4
		pack $f.f0 -side top -fill x -expand true -pady 2
		pack $f.la -side top -pady 4
		pack $f.f1 -side top -fill x -expand true -pady 2
		pack $f.l $f.1 $f.2 $f.0 -side top -pady 1
	}
	raise $f
	set pr_tests2 0
	My_Grab 0 $f pr_tests2
	tkwait variable pr_tests2
	set text_edit_style $new_text_edit_style
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-----

proc Copy_Textfile {} {
	global wl pa evv

	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
			set tfile $fnam
			break
		}
	}
	if {![info exists tfile]} {
		Inf "No Textfile Has Been Selected"
		return
	}
	set newfnam "copy"
	set indx 0
	set in_ext [file extension $tfile]
	while {[file exists $newfnam$indx$in_ext]} {
		incr indx
	}
	set newfnam $newfnam$indx$in_ext
	if [catch {file copy $tfile $newfnam} zib] {
		Inf "Cannot Copy The Textfile '$fnam'"
	} else {
		if {[FileToWkspace $newfnam 0 0 0 0 1] <= 0} {
			Inf "Copied File, Named '$newfnam' Cannot Be Placed On Workspace"
		} else {
			Inf "File Copy Created, Named '$newfnam'"
		}
	}
}

#--- List contents of subdirectory selected on Source Directory Listing

proc GetSubdirNames {} {
	global dl wksp_dirname active_dir previous_dirlisting previous_active_dir is_subdirlist ww evv

	if {[info exists active_dir] && [info exists previous_active_dir]} {
		set xx $previous_active_dir
		set yy $previous_dirlisting
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	set subdirlist {}
	set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
	if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
		if {[info exists xx]} {
			set previous_active_dir $xx
			set previous_dirlisting $yy
		}
	 	return
	}
	set dirlen [string length $dirname]
	set pwd [string tolower [pwd]]
	set pwdlen [string length $pwd]
	if [string match $pwd* $dirname] {
		if {$pwdlen == $dirlen} {
			set dirname ""
		} else {
			incr pwdlen
			set dirname [string range $dirname $pwdlen end]
		}
	}
	set active_dir $dirname
	Block "Listing SubDirectories"
	foreach fnam [lsort -dictionary [glob -nocomplain [file join $dirname *]]] {
		if [file isdirectory $fnam] {
			if {[string match $fnam soundloom$evv(EXEC)]} {
				continue
			}
			set fnam [CheckDirectoryName $fnam "directory name" 0 1]
			if {[string length $fnam] <= 0} {
				continue
			} else {
				set fnam [string tolower $fnam]
				lappend subdirlist $fnam
			}
		}
	}
	UnBlock
	set len [llength $subdirlist]
	switch -- $len {
		0 {
			Inf "There Are No Subdirectories In This Directory"
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
				return
			}
		}
		1 {
			set the_subdir [lindex $subdirlist 0]
			set wksp_dirname $the_subdir
			$dl delete 0 end
			foreach fnam [lsort -dictionary [glob -nocomplain [file join $wksp_dirname *]]] {
				$dl insert end $fnam
			}
		}
		default {
			$dl delete 0 end
			foreach item $subdirlist {
				$dl insert end $item
			}
			set is_subdirlist 1
		}
	}
	$dl xview moveto 0.0
	$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
}

#----- Grab any soundsources in mixfile which are not on wkspace, onto wkspace

proc Get_MixSrcs {} {
	global wl pa sl_real evv

	if {!$sl_real} {
		Inf "If You Have Highlighted A Mixfile On The Workspace Window,\nYou Can Grab All The Soundfiles It Uses\nOnto The Workspace Window."
		return
	}

	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
			if {[info exists pa($fnam,$evv(FTYP))] && [IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
			set mfile $fnam
			break
		}
	}
	if {![info exists mfile]} {
		Inf "No Mixfile Has Been Selected"
		return
	}
	if [catch {open $mfile "r"} Ifd] {
		Inf "Cannot Open File '$mfile'"
		return
	}
	set files_grabbed 0
	set cnt 0
	while {[gets $Ifd line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if [string match [string index $line 0] ";"] {
			continue
		}
		set line [split $line]
		foreach item $line {
			if {[string length $item] > 0} {
				if {($cnt == 0) && ($pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI))} {
					break
				}
				set item [RegulariseDirectoryRepresentation $item]
				if {[LstIndx $item $wl] < 0} {
					if {[FileToWkspace $item 0 0 0 1 0] <= 0} {
						Inf "Cannot Put The File '$item' On The Workspace."
					} else {
						incr files_grabbed
					}
				}
				break					
			}
		}
		incr cnt
	}
	catch {close $Ifd}
	if {$files_grabbed == 0} {
		Inf "All Valid Soundfiles In '$mfile' Are Already On The Workspace"
	} 
}

#------ Put last mixfile used onto chosenfile list

proc GetLastMixfile {add} {
	global chlist ch chcnt last_mix wl bulk pa evv

	if {$add == 2} {
		if {[info exists chlist] && ([llength $chlist] == 1) && [IsAMixfileIncludingMultichan $pa([lindex $chlist 0],$evv(FTYP))]} {
			UnsetThumbnail
			set bulk(run) 0
			GotoGetAProcess
			return
		}
	}
	if {![info exists last_mix]} {
		Inf "No Previous Mixfile Used In This Session"
		return
	}
	if {[string length $last_mix] <= 0} {
		return
	}
	if {(![file isfile $last_mix]) || [file isdirectory $last_mix]} {
		Inf "The Last Mixfile Used No Longer Exists"
		set last_mix ""
		return
	}
	set pos [LstIndx $last_mix $wl]
	if {$pos < 0} {
		FileToWkspace $last_mix 0 0 0 0 0
	} else {
		$wl delete $pos
		$wl insert 0 $last_mix
		$wl yview moveto 0
	}
	UnsetThumbnail
	DoChoiceBak
	if {$add != 1} {
		ClearWkspaceSelectedFiles
		set chcnt 0
	}
	lappend chlist $last_mix		;#	add to end of list
	$ch insert end $last_mix		;#	add to end of display
	incr chcnt
	$ch xview moveto 0.0
	if {$add == 2} {
		set bulk(run) 0
		GotoGetAProcess
	}
}

#------ Put all the sndfiles in a chosen mixfile, onto the chosen files list.

proc GetFilesFromInsideChosenMixfile {nonbakdup} {
	global last_outfile smtoch_keepmix chlist ch chcnt wl pa wstk evv

	set smtoch_keepmix 0
	if {![info exists chlist] || ([llength $chlist] != 1)} {
		return
	}
	set fnam [lindex $chlist 0]
	if {![IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
		Inf "Chosen File Is Not A (Valid) Mixfile"
		return
	}
	if [catch {open $fnam "r"} Ifd] {
		Inf "Cannot Open Mixfile '$fnam'"
		return
	}
	while {[gets $Ifd line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if [string match [string index $line 0] ";"] {
			if {$nonbakdup == 3} {
				set line [split $line]
				set fnam [string range [lindex $line 0] 1 end]
				if {[file exists $fnam]} {
					lappend nulist $fnam
				}
			}
			continue
		} elseif {$nonbakdup != 3} {
			set line [split $line]
			set itemcnt 0
			foreach item $line {
				if {[string length $item] > 0} {
					if {$itemcnt == 0} {
						set item [RegulariseDirectoryRepresentation $item]
						if [file exists $item] {
							if {($nonbakdup == 1) && ![string match [file tail $item] $item]} {		;#	Looking for non-bkdup files, and this IS bakdup
								break																;#	Go to next line	
							}
							if {[LstIndx $item $wl] < 0} {
								lappend badfiles1 $item
							} elseif {![info exists pa($item,$evv(FTYP))]} {
								lappend badfiles2 $item
							} else {
								lappend nulist $item												;#	List all files (that are not badfiles)
							}
						}
						if {$nonbakdup == 4} {														;#	If we need times as well, go to next item
							incr itemcnt
						} else {																	;#	Normally we need only filenames, so break								
							break					
						}
					} else {
						lappend tim_ings $item														;#	If we need times, collect times, then go to next line
						break					
					}
				}
			}
		}
	}
	catch {close $Ifd}
	if {[info exists nulist]} {
		if {$nonbakdup == 4} {
			if [DuplicatesInList $nulist] {
				Inf "Duplicated Files In Mix: Sorting In Order Of First Occurence Of Files"
			}
			set nulist [SortOnTimesInList $nulist $tim_ings]
		}
		set nulist [RemoveDuplicatesInList $nulist]
	}
	if {[info exists badfiles1]} {
		set badfiles1 [RemoveDuplicatesInList $badfiles1]
	}
	if {[info exists badfiles2]} {
		set badfiles2 [RemoveDuplicatesInList $badfiles2]
	}
	if {[info exists badfiles1] || [info exists badfiles2]} {
		set msg ""
		if {[info exists badfiles1]} {
			set len [llength $badfiles1]
			append msg "These Files Are Not On The Workspace\n\n"
			set n -1
			while {$n < $len} {
				incr n
				if {$n >= 20} {
					append msg "\nAnd More\n\n"
					break
				}
				append msg "[lindex $badfiles1 $n]  "
			}
		}
		if {[info exists badfiles2]} {
			set len [llength $badfiles2]
			append msg "File Data Does Not Exist For These Files\n\n"
			set n -1
			while {$n < $len} {
				incr n
				if {$n >= 20} {
					append msg "\nAnd More"
					break
				}
				append msg "[lindex $badfiles2 $n]  "
			}
		}
		Inf $msg
		if {[info exists badfiles1] && ![info exists badfiles2]} {
			set msg "Grab Files To Workspace ??"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if {$choice == "yes"} {
				foreach fznam $badfiles1 {
					FileToWkspace $fznam 0 0 0 0 1
					lappend nulist $fznam
				}
			}
		}
	}
	if {![info exists nulist]} {
		if {$nonbakdup == 1} {
			Inf "There Are No (Valid) Non-Backed-Up Files In This Mix"
		} else {
			Inf "No Files In The Mixfile Are On The Workspace"
		}
		return
	}
	if {$nonbakdup == 2} {
		if {([llength $nulist] == 1) && ([info exists badfiles1] || [info exists badfiles2])} {
			set msg "Only File [lindex $nulist 0] Exists And Is On The Workspace:\n\nSelect This File ?"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if {$choice == "no"} {
				return
			}
		}
		if {[llength $nulist] > 1} {
			set nulist [SelectMixfileToChlist $nulist]
			if {$smtoch_keepmix} {
				lappend nulist $fnam
				set nulist [ReverseList $nulist]
			}
		}
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	foreach fnam $nulist {
		lappend chlist $fnam		;#	add to end of list
		$ch insert end $fnam		;#	add to end of display
		incr chcnt
	}
	if {$nonbakdup == 3} {
		Inf "Files Muted In Mixfile Are Listed In 'Chosen Files' List"
	}
}

#--- List only files with specified extension on Source Directory Listing

proc GetDirExt {str} {
	global dl active_dir wksp_dirname previous_dirlisting previous_active_dir wstk ww evv is_subdirlist

	if {[info exists active_dir] && [info exists previous_active_dir]} {
		set xx $previous_active_dir
		set yy $previous_dirlisting
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	if {![info exists active_dir]} {
		Inf "No Directory Listed Yet: Use 'List : List Named Directory'"
	} else {
		if {[string length $str] <= 0} {
			Inf "No File Extension Name Entered"
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
			}
			return
		}
		foreach f_nam [glob -nocomplain [file join $wksp_dirname *]] { 
			if {![string match "__" [string range [file tail $f_nam] 0 1]]} {
				lappend fnamlist $f_nam
			}
		}
		set local_fnamlist [$dl get 0 end]
		foreach f_nam $fnamlist {
			if {[lsearch $local_fnamlist $f_nam] < 0} {
				set msg "Search Entire Directory '$wksp_dirname' ?"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					set fnamlist $local_fnamlist
					set local 1
				}
				break
			}
		}
		foreach fnam $fnamlist {
			if [file isdirectory $fnam] {
				continue
			}
			if {$str == "snd"} {
				if {[string match [file extension $fnam] ".wav"] \
				||  [string match [file extension $fnam] ".aif"] \
				||  [string match [file extension $fnam] ".aiff"]} {
					lappend nuflist $fnam
				}
			} else {
				set z "."
				append z $str
				if {[string match [file extension $fnam] $z]} {
					lappend nuflist $fnam
				}
			}
		}
		if {![info exists nuflist]} {
			if [info exists local] {
				Inf "No Files With This Extension Are Listed"
			} else {
				Inf "No Files With This Extension Exist In This Directory"
			}
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
			}
			return
		} else {
			$dl delete 0 end
			foreach fnam $nuflist {
				$dl insert end $fnam
			}
			$dl xview moveto 0.0
			if {[string match $str "wav"] || [string match $str "aif"] || [string match $str "aiff"]} {
				$ww.1.b.labels.msg2 config -text "Sndfile extension  '.$str'"
			} else {
				$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
			}
		}
		catch {unset is_subdirlist}
	}
}

#------ Attempt to rename several selected workspace files with a generic name

proc GenericSubstituteWkspaceFiles {} {
	global wl pr_su hst ins subname osubname generic chlist ch chcnt nu_names nunames_gs evv
	global pa subname_g background_listing wstk nessinit
	global wksp_cnt total_wksp_cnt ww sl_real dupl_mix dupl_vbx dupl_txt

	if {!$sl_real} {
		Inf "Selected Files With Similar Names\nCan Have Their Names Altered In A Generic Way\n\ne.g. mysound0, mysound1, mysound2\nMight Become\nmy_intro0, my_intro1, my_intro2"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0

	set g .genericsub
	if [Dlg_Create $g "GENERICALLY SUBSTITUTE NAME" "set pr_su 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gi [frame $g.indx -borderwidth $evv(SBDR)]
		set g2 [frame $g.2 -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_su 0" -highlightbackground [option get . background {}]
		label $gn.l -text "Old Generic String" -width 16
		button $gn.ok -text OK -width 6 -command "set pr_su 1" -highlightbackground [option get . background {}]
		entry $gn.e -width 20 -textvariable osubname
		pack $gn.ok $gn.l $gn.e -side left
		pack $gn.b -side right
		label $gi.l -text "New Generic String" -width 16
		entry $gi.e -width 20 -textvariable subname
		pack $gi.l $gi.e -side left
		label $g2.laba -text "Recent Names"
		set nunames_gs [Scrolled_Listbox $g2.nunames -height $evv(NSTORLEN) -selectmode single]
		bind $g2.nunames.list <ButtonRelease-1> {NameListChoose .genericsub.2.nunames.list .genericsub.indx.e}
		pack $g2.laba $g2.nunames -side top -fill x
		pack $g.name $g.indx $g.2 -side top
		bind $gn.e <Down> "focus $g.indx.e"
		bind $gn.e <Up>   "focus $g.indx.e"
		bind $gi.e <Up>   "focus $g.name.e"
		bind $gi.e <Down> "focus $g.name.e"
		wm resizable $g 1 1
		bind $g <Return> {set pr_su 1}
		bind $g <Escape> {set pr_su 0}
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		destroy $g
		return
	}
	if {[info exists nessinit]} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Generic Name Substitions With Physical Modelling Files"
				return
			}
		}
	}
	if [info exists nu_names] { 
		.genericsub.2.nunames.list delete 0 end
		foreach nname $nu_names {							;#	Post recent names
			.genericsub.2.nunames.list insert end $nname
		}					
	}
	set subname ""
	set osubname [file rootname [file tail [$wl get [lindex $ilist 0]]]]
	set rename_cnt 0 
	set finished 0
	set pr_su 0
	set save_mixmanage 0
	raise $g
	My_Grab 0 $g pr_su $g.name.e
	while {!$finished} {
		tkwait variable pr_su
		if {!$pr_su} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			set osubname [string tolower $osubname]
			set osubname [FixTxt $osubname "old generic name"]	;#	massage name,
			if {[string length $osubname] <= 0} {
				ForceVal .genericsub.name.e $osubname
				continue
			}
			set subname [string tolower $subname]
			set subname [FixTxt $subname "new generic name"]	;#	massage name,
			if {[string length $subname] <= 0} {
				set msg "Did you really want to simply delete the text entered ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					ForceVal .genericsub.indx.e $subname
					continue
				}
			} elseif {![ValidCDPRootname $subname]} {				;#	check its validity,
				continue
			}
			set OK 1								;#	and test its not already in use
			foreach i $ilist {
				set origfnam [$wl get $i]								;#	get each selected file
				set fnam $origfnam
				set fext [file extension $fnam]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				set fnam [file rootname [file tail $fnam]]
				if {[set k [string first $osubname $fnam]] < 0} {
					continue
				}
				set kk [expr $k + [string length $osubname]]
				if {$k > 0} {
					incr k -1
					set nustr [string range $fnam 0 $k]
				} else {
					set nustr ""
				}
				append nustr $subname
				if {$kk < [string length $fnam]} {
					append nustr [string range $fnam $kk end]
				}
				if {[string length $nustr] <= 0} {
					Inf "A Zero Length Filename Would Be Created"
					set OK 0
					break
				}
				set fnam $nustr$fext
				set fnam [file join $fdir $fnam]
				if {[file exists $fnam] && ![file isdirectory $fnam]} {
					Inf "A File With The Name '$fnam' Already Exists"
					set OK 0
					break
				}
			}
			if {!$OK} {
				continue
			}

			set rename_cnt 0
			foreach i $ilist {
				set origfnam [$wl get $i]								;#	get each selected file
				set haspmark [HasPmark $origfnam]
				set hasmmark [HasMmark $origfnam]
				set fnam $origfnam
				set fext [file extension $fnam]
				if {[string length $fnam] > [string length [file tail $fnam]]} {
					set fdir [file dirname $fnam]
				} else {
					set fdir ""
				}
				set fnam [file rootname [file tail $fnam]]
				if {[set k [string first $osubname $fnam]] < 0} {
					continue
				}
				set kk [expr $k + [string length $osubname]]
				if {$k > 0} {
					incr k -1
					set nustr [string range $fnam 0 $k]
				} else {
					set nustr ""
				}
				append nustr $subname
				if {$kk < [string length $fnam]} {
					append nustr [string range $fnam $kk end]
				}
				set fnam $nustr$fext
				set fnam [file join $fdir $fnam]
				lappend thisl $fnam
				if [catch {file rename $origfnam $fnam} zub] {
					Inf "Cannot Rename File '$origfnam' To '$fnam'"
				} else {
					DataManage rename $origfnam $fnam
					lappend couettelist $origfnam $fnam
					UpdateBakupLog $origfnam delete 0
					UpdateBakupLog $fnam create 1
					CheckMainmix $origfnam $fnam
					CheckMainmixSnd $origfnam $fnam
					$wl delete $i								
					$wl insert $i $fnam
					catch {unset rememd}
					UpdateChosenFileMemory $origfnam $fnam
					set oldname_pos_on_chosen [LstIndx $origfnam $ch]
					if {$oldname_pos_on_chosen >= 0} {
						RemoveFromChosenlist $origfnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $fnam]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $fnam
					}
					RenameProps	$origfnam $fnam 1				
					DummyHistory $origfnam "RENAMED_$fnam"
					if {[MixMRename $origfnam $fnam 0]} {
						set save_mixmanage 1
					}
					if {$haspmark} {
						MovePmark $origfnam $fnam
					}
					if {$hasmmark} {
						MoveMmark $origfnam $fnam
					}
					if [IsInBlists $origfnam] {
						if [RenameInBlists $origfnam $fnam] {
							set ren_blist 1
						}
					}
					if [IsOnScore $origfnam] {
						RenameInScore $origfnam $fnam
					}
					RenameOnDirlist $origfnam $fnam
					incr rename_cnt
				}
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			if {$rename_cnt} {
				if {$save_mixmanage} {
					MixMStore
				}
				if {[string length $subname] > 0} {
					AddNameToNameslist $subname 0
				}
				set finished 1
			} else {
				Inf "No Files Have Been Renamed"
			}
		}
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
	return 1
}

proc WkspFirstGet {} {
	global wl chlist ch chcnt 

	set nufnam [$wl get 0]
	if {[string length $nufnam] <= 0} {
		return
	} 
	DoChoiceBak
	ClearWkspaceSelectedFiles
	lappend chlist $nufnam		;#	add to end of list
	$ch insert end $nufnam		;#	add to end of display
	incr chcnt
}

#------ Grab all soundfiles to Chosen Files list

proc Sound_Select {flag} {
	global wl evv pa chlist ch chcnt

	if {$flag == -1} {
		foreach fnam [$ch get 0 end] {
			if {[string match [file tail $fnam] $fnam]} {
				lappend fileslist $fnam
			}
		}
		if {![info exists fileslist]} {
			Inf "There Are No Such Files Are On The Chosen Files List"
			return
		}
	} else {
		foreach fnam [$wl get 0 end] {
			if {$pa($fnam,$evv(FTYP)) == $evv(IS_A_SNDFILE)} {
				switch -- $flag {
					"0" {
						lappend fileslist $fnam
					}
					default {
						if {$pa($fnam,$evv(CHANS)) == $flag} {
							lappend fileslist $fnam
						}
					}
				}
			}
		}
		if {![info exists fileslist]} {
			Inf "There Are No Such Files Are On The Workspace"
			return
		}
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	foreach fnam $fileslist {
		lappend chlist $fnam		;#	add to end of list
		$ch insert end $fnam		;#	add to end of display
		incr chcnt
	}
}

#---- Get file to position N in chosen list

proc GetChosenPos {} {
	global evv pr_chpos chchpos chlist

	if {![info exists chlist] || ([llength $chlist] < 1)} {
		return
	}
	set g .chpos
	if [Dlg_Create $g "BEFORE WHICH POSITION?" "set pr_chpos 0" -borderwidth $evv(BBDR)] {
		set g1 [frame $g.1 -borderwidth $evv(SBDR)]
		set g2 [frame $g.2 -borderwidth $evv(SBDR)]
		button $g1.ok -text OK -width 3 -command "set pr_chpos 1" -highlightbackground [option get . background {}]
		button $g1.qu -text Close -width 3 -command "set pr_chpos 0" -highlightbackground [option get . background {}]
		label $g1.l -text " Position in list (1 - end)"
		entry $g1.e -width 20 -textvariable chchpos
		pack $g1.ok $g1.l $g1.e $g1.qu -side left -padx 2
		Scrolled_Listbox $g2.li -width 20 -height 24 -selectmode single
		pack $g2.li -side top -fill x
		pack $g.1 $g.2 -side top -fill both -expand true
		wm resizable $g 1 1
		bind $g.2.li.list <ButtonRelease-1> {GetChlNo .chpos.2.li.list %y}
		bind $g <Return> {set pr_chpos 1}
		bind $g <Escape> {set pr_chpos 0}
	}
	$g.2.li.list delete 0 end
	set i 1
	foreach item $chlist {
		set line $i
		if {$i < 10} {
			append line ":   "
		} elseif {$i < 100} {
			append line ":  "
		} else { 
			append line ": "
		}
		append line $item
		$g.2.li.list insert end $line
		incr i
	}
	set pr_chpos 0
	set finished 0
	set maxval [llength $chlist]
	$g.1.l config -text " Position in list (1 - $maxval)"
	raise $g
	My_Grab 0 $g pr_chpos $g.1.e
	while {!$finished} {
		set chchpos ""
		tkwait variable pr_chpos
		if {!$pr_chpos} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		}
		if {[string length $chchpos] <= 0} {
			Inf "No Position Entered"
			continue
		} elseif {![regexp {^[0-9]+$} $chchpos] || ($chchpos < 0) || ($chchpos > $maxval)} {
			Inf "Invalid Position Entered: Range Is 1 To $maxval"
			continue
		}
		set finished 1
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	return $chchpos
}	

proc GetChlNo {ll y} {
	global chchpos
	set i [$ll curselection]		;#	Get list-index nearest to mouse-cursor
	incr i
	set chchpos $i
}

###########

proc DiskSpaceUsed {} {
	global dvu_srate evv

	set sc_sc $evv(BITRES)
	set dirname [pwd]
	set sum [SumFilesizes $dirname]
	switch -- $sc_sc {
		"8"   {
			set xx 1.0
		}
		"16"   {
			set xx 2.0
		}
		"20"  {
			set xx 2.5
		}
		"24" {
			set xx 3.0
		}
		"1.0"     {
			set xx 4.0
		}
	}
	if {[info exists xx]} {
		set units [expr round($sum/$xx)]
		set stunits [expr round($units/2.0)]
		set mttts  [expr $units/$dvu_srate]
		set mtttm  [expr floor($mttts/60.0)]
		set mttts [expr round($mttts - ($mtttm * 60.0))]
		set mttth  [expr floor($mtttm/60.0)]
		set mtttm [expr round($mtttm - ($mttth * 60.0))]
		set ttts  [expr $stunits/$dvu_srate]
		set tttm  [expr floor($ttts/60.0)]
		set ttts [expr round($ttts - ($tttm * 60.0))]
		set ttth  [expr floor($tttm/60.0)]
		set tttm [expr round($tttm - ($ttth * 60.0))]
		if {$mttth > 0.0} {
			set mmsgttt "IN MONO :       $mttth hours : $mtttm mins : $mttts secs"
		} elseif {$mtttm > 0.0} {
			set mmsgttt "IN MONO :       $mtttm mins : $mttts secs"
		} else {
			set mmsgttt "IN MONO :       $mttts secs"
		}
		if {$ttth > 0.0} {
			set msgttt "IN STEREO :   $ttth hours : $tttm mins : $ttts secs"
		} elseif {$tttm > 0.0} {
			set msgttt "IN STEREO :   $tttm mins : $ttts secs"
		} else {
			set msgttt "IN STEREO :   $ttts secs"
		}
		.diskvu.ll delete 0 end
		.diskvu.ll insert end "Diskspace used for sound and sound-related files"
		.diskvu.ll insert end "in your working directory and subdirectories"
		.diskvu.ll insert end ""
		.diskvu.ll insert end "$sum   bytes"
		.diskvu.ll insert end "$mmsgttt"
		.diskvu.ll insert end "$msgttt"
		if {$xx == 4.0} {
			.diskvu.ll insert end ""
			.diskvu.ll insert end "OR HALF THIS, if using 64bit FLOAT Format"
			.diskvu.ll insert end ""
		}
	} else {
		.diskvu.ll delete 0 end
		set msgttt "Unknown bit resolution: Can't calculate disk space"
		.diskvu.ll insert end "$msgttt"
	}
}

proc SumFilesizes {dirname} {
	global evv
	set sum 0
	foreach fnam [glob -nocomplain [file join $dirname *]] {
		if [file isdirectory $fnam] {
			set thissum [SumFilesizes $fnam]
			incr sum $thissum
		} else {
			set done 0
			if {[string match [file extension $fnam] $evv(SNDFILE_EXT)]} {
				file stat $fnam stat
				set filesize $stat(size)
				incr sum $filesize
				set done 1
			}
			if {!$done} {
				if {[string match [file extension $fnam] $evv(ANALFILE_EXT)] \
				|| [string match [file extension $fnam] $evv(PITCHFILE_EXT)] \
				|| [string match [file extension $fnam] $evv(TRANSPOSFILE_EXT)] \
				|| [string match [file extension $fnam] $evv(FORMANTFILE_EXT)] \
				|| [string match [file extension $fnam] $evv(ENVFILE_EXT)]} {
					file stat $fnam stat
					set filesize $stat(size)
					incr sum $filesize
				}
			}
		}
	}	
	return $sum
}

#---- Keep specific files on Chosen List

proc KeepSpecFile {keep} {
	global evv pr_specposf specposf specp_name chlist

	if {![info exists chlist] || ([llength $chlist] < 1)} {
		return
	}
	set g .specpos
	set specposf -1
	if [Dlg_Create $g "KEEP WHICH FILE(S)?" "set pr_specposf 0" -borderwidth $evv(BBDR)] {
		set g1 [frame $g.1 -borderwidth $evv(SBDR)]
		set g2 [frame $g.2 -borderwidth $evv(SBDR)]
		set g3 [frame $g.3 -borderwidth $evv(SBDR)]
		button $g1.ok -text Select -width 5 -command "set pr_specposf 1" -highlightbackground [option get . background {}]
		label  $g1.dum -text "Select files to keep\nwith mouse" -width 35
		button $g1.qu -text Close -width 5 -command "set pr_specposf 0" -highlightbackground [option get . background {}]
		pack $g1.ok $g1.dum -side left -padx 1
		pack $g1.qu -side right -padx 1
		Scrolled_Listbox $g2.li -width 20 -height 24 -selectmode multiple
		pack $g2.li -side top -fill x
		entry $g3.e -textvariable specp_name -width 16
		pack $g3.e -side top
		pack $g.1 $g.3 $g.2 -side top -fill both -expand true
		wm resizable $g 1 1
		bind $g.2.li.list <ButtonRelease-1> {set specposf [.specpos.2.li.list curselection]}
		bind $g <Return> {set pr_specposf 1}
		bind $g <Escape> {set pr_specposf 0}
	}
	switch -- $keep {
		0 {
			wm title $g "KEEP WHICH FILE(S)?"
			.specpos.1.dum config -text "Select files to keep,\nby clicking on list below"
			.specpos.2.li.list config -selectmode multiple
			.specpos.3.e config -bd 0 -state disabled
		}
		1 {
			wm title $g "REMOVE FILE & THOSE BEYOND"
			.specpos.1.dum config -text "Select file with mouse,\nto delete it & those Below"
			.specpos.2.li.list config -selectmode single
			.specpos.3.e config -bd 0 -state disabled
		}
		2 {
			wm title $g "REMOVE FILE & THOSE ABOVE"
			.specpos.1.dum config -text "Select file with mouse,\nto delete it & those Above"
			.specpos.2.li.list config -selectmode single
			.specpos.3.e config -bd 0 -state disabled
		}
		3 {
			wm title $g "REMOVE FILES STARTING WITH...."
			.specpos.1.dum config -text "Enter string which starts\nall files to Remove.."
			.specpos.2.li.list config -selectmode single
			.specpos.3.e config -bd 2 -state normal
		}
		4 {
			wm title $g "KEEP FILES STARTING WITH...."
			.specpos.1.dum config -text "Enter string which starts\nall files to Keep..."
			.specpos.2.li.list config -selectmode single
			.specpos.3.e config -bd 2 -state normal
		}
	}
	set specp_name ""
	$g.2.li.list delete 0 end
	set i 1
	foreach item $chlist {
		$g.2.li.list insert end $item
	}
	set pr_specposf 0
	set finished 0
	raise $g
	My_Grab 0 $g pr_specposf $g.2.li.list
	while {!$finished} {
		tkwait variable pr_specposf
		if {$pr_specposf} {
			if {$keep > 2} {
				set fnam [CheckDirectoryName $specp_name "string" 1 0]
				if {[string length $fnam] <= 0} {
					Inf "No (Valid) String Entered"
					set specp_name ""
					continue
				}
				set finished [RemakeChosenList $specposf $keep $fnam]
			} elseif {![string match $specposf "-1"]} {
				RemakeChosenList $specposf $keep ""
				set finished 1
			} else {
				Inf "No Files Selected"
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
}	

#----- Select or Delete selected files from Chosen List

proc RemakeChosenList {k keep fnam} {
	global ch chlist last_ch lalast_ch chcnt

	switch -- $keep {
		0 {
			foreach item $k {
				lappend nufiles [lindex $chlist $item]
			}
		}
		1 {
			set fnam [lindex $chlist [lindex $k 0]]
			foreach item $chlist {
				if {[string match $item $fnam]} {
					break
				} 
				lappend nufiles $item
			}
		}
		2 {
			set fnam [lindex $chlist [lindex $k 0]]
			set dodelete 1
			foreach item $chlist {
				if {$dodelete} {
					if {[string match $item $fnam]} {
						set dodelete 0
					}
				} else {
					lappend nufiles $item
				}
			}
		}
		3 {
			set nucnt 0
			foreach item $chlist {
				if {[string first $fnam $item] != 0} {
					lappend nufiles $item
					incr nucnt
				}
			}
			if {$nucnt == $chcnt} {
				Inf "There Are No Files Starting With '$fnam'"
				return 0
			}
			if {![info exists nufiles]} {
				Inf "All Files Start With '$fnam'"
				return 0
			}
		}
		4 {
			set nucnt 0
			foreach item $chlist {
				if {[string first $fnam $item] == 0} {
					lappend nufiles $item
					incr nucnt
				}
			}
			if {$nucnt== $chcnt} {
				Inf "All Files Start With '$fnam'"
				return 0
			}
			if {![info exists nufiles]} {
				Inf "There Are No Files Starting With '$fnam'"
				return 0
			}
		}
	}
	if {[info exists last_ch]} {
		set lalast_ch $last_ch
	}
	set last_ch $chlist
	ClearWkspaceSelectedFiles
	foreach nufile $nufiles {
		lappend chlist $nufile
		$ch insert end $nufile
		incr chcnt
	}
	ChlistDupls
	return 1
}

#----- Sort Choicelist files

proc ChoiceSort {} {
	global ch chlist chcnt

	if {$chcnt == 0} {
		return
	}
	DoChoiceBak

	ListSort $ch
	catch {unset chlist}
	foreach fnam [$ch get 0 end] {
		lappend chlist $fnam
	}
}

#----- Remember Choicelist files
	
proc DoChoiceBak {} {
	global chlist chcnt last_ch lalast_ch ch

	if {[info exists chlist] && ([llength $chlist] > 0)} {
		if {[info exists last_ch] && ([llength $last_ch] > 0)} {
			catch {unset lalast_ch}
			foreach fnam $last_ch {
				lappend lalast_ch $fnam
			}
		}
		catch {unset last_ch}
		foreach fnam $chlist {
			lappend last_ch $fnam
		}
	}
	$ch xview moveto 0.0
}

#----- Read or Play a file on Directory Listing

proc ReadPlay {} {
	global dl from_dirl evv

	set i [$dl curselection]
	if {![info exists i] || ([llength $i] <= 0)} {
		Inf "No File Selected"
		set from_dirl 0
		return
	}
	if {[llength $i] > 1} {
		Inf "Select A Single File"
		set from_dirl 0
		return
	}
	set fnam [$dl get $i]
	if {[IsATextfileExtension [file extension $fnam]]} {
		ReadFile
	} else {
		set canplay 0
		set ftyp [file extension $fnam]
		if {[string match $ftyp $evv(SNDFILE_EXT)] || [string match $ftyp $evv(ANALFILE_EXT)]} {
			set canplay 1
			PlayOutput 0
		}
		if {!$canplay} {
			Inf "This File Cannot Be Played Or Read"
		}
	}
	set from_dirl 0
	return
}

#----- Remember which bakup directories used in session

proc UpdateBakupDirs {dirname} {
	global new_bakup_dirs bakup_hiding
	if {$bakup_hiding} {
		return
	}
	if {(![info exists new_bakup_dirs]) || ([lsearch $new_bakup_dirs $dirname] < 0)} {
		lappend new_bakup_dirs $dirname
	}
}

#----- Show which bakup directories used in recent sessions

proc ShowBakupDirs {when} {
	global new_bakup_dirs bakup_dirs wstk bakup_hiding sl_real wkspace_newfile wstk dobakuplog evv

	if {!$sl_real} {
		if {[string match "mid" $when]} {
			Inf "You Can View A List Of Directories Recently Use For Backing Up Newly Created Files"
		}
		return
	}
	if {$bakup_hiding} {
		return
	}
	switch -- $when {
		"mid" -
		"end" {
			if {$when == "end"} {
				if {$dobakuplog} {
					return
				}
			}
			set zcnt 0
			if {[info exists new_bakup_dirs]} {
				set msg "In This Session: Files Have Been Backed Up To The Following Directories\n\n"
				foreach item $new_bakup_dirs {
					if {$zcnt > 25} {
						append msg "and more"
						break
					}
					append msg $item "\n"
					incr zcnt
				}
			}
			if {[info exists bakup_dirs]} {
				if [info exists new_bakup_dirs] {
					append msg "\n\nIn Recent Sessions: Files Have Also Been Backed Up To The Following Directories\n\n"
					set bakup_listing $new_bakup_dirs
				} else {
					set msg "No Files Have Been Backed Up In This Session\n\n"
					append msg "In Recent Sessions: Files Have Been Backed Up To The Following Directories\n\n"
				}
				foreach item $bakup_dirs {
					if [info exists new_bakup_dirs] {
						if {[lsearch -exact $new_bakup_dirs $item] < 0} {
							lappend bakup_listing $item
						}
					} else {
						lappend bakup_listing $item
					}
					incr zcnt
					if {$zcnt <= 33} {
						append msg $item "\n"
					} elseif {$zcnt == 34} {
						append msg "AND MORE"
					}
				}
				if {[string match $when "end"]} {
					set msg2 $msg
					append msg2 "\n\nRetain This Information ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg2]
					if {$choice == "no"} {
						catch {unset bakup_listing}
						if {[info exists new_bakup_dirs]} {
							set bakup_listing $new_bakup_dirs
						}
					}
					set wkspace_newfile 0
				}
			} elseif {[info exists new_bakup_dirs]} {
				set bakup_listing $new_bakup_dirs
			} else {
				set msg "No Files Have Been Backed Up In Recent Sessions"
			}
			set fnam [file join $evv(URES_DIR) $evv(BAKUP_DATA)$evv(CDP_EXT)]
			if [info exists bakup_listing] {
				if {$when == "end"} {
					if [catch {open $fnam "w"} fId] {
						Inf "Failed To Open File '$fnam' To Save File-Backup Data"
						return
					}
					foreach fnam $bakup_listing {
						puts $fId $fnam
					}
					catch {close $fId}
				}
			} elseif [file exists $fnam] {
				if [catch {file delete $fnam} zit] {
					Inf "Failed To Delete File '$fnam' Containing Backup-Files Information "
				}
			}
			if {$wkspace_newfile} {
				Inf $msg
			}
		}
		"start" {
			if {[info exists bakup_dirs]} {
				set msg "In Recent Sessions: Files Have Been Backed Up To The Following Directories\n\n"
				set zcnt 0
				foreach item $bakup_dirs {
					if {$zcnt > 25} {
						append msg "AND MORE"
						break
					}
					append msg $item "\n"
					incr zcnt
				}
				append msg "\nThis List Can Be Edited From\nThe 'System -> Directory Listings' Menu\n"
				append msg "\n" "Do You Want To See This Information At The Start Of Your Sessions ?"
				set choice [tk_messageBox -type yesno -icon warning -message $msg]
				if {$choice == "no"} {
					set fnam [file join $evv(CDPRESOURCE_DIR) $evv(NODIRS)$evv(CDP_EXT)]
					if {![file exists $fnam]} {
						if [catch {open $fnam "w"} zit] {
							Inf "Cannot Create File '$fnam' To Prevent This Display At Start Of Your Sessions"
						} else {
							close $zit
							Inf "You Can Reinstate The Session Start Directory Display From\nThe 'System -> Directory Listings' Menu"
						}
					}
				}
			}
		}
	}
}

#----- Load bakup directories used in last session(s)

proc LoadBakupDirs {} {
	global bakup_dirs bakup_hiding evv

	if {$bakup_hiding} {
		return
	}
	set fnam [file join $evv(URES_DIR) $evv(BAKUP_DATA)$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {open $fnam "r"} fId] {
			Inf "Failed To Open File '$fnam' To Find Existing File-Backup Data"
			return
		}
		while {[gets $fId line] >= 0} {
			set line [string trim $line]
			if {[string length $line] > 0} {
				lappend bakup_dirs $line
			}
		}
	}
	catch {close $fId}
	if {![file exists [file join $evv(CDPRESOURCE_DIR) $evv(NODIRS)$evv(CDP_EXT)]]} {
		ShowBakupDirs start
	}
}

#---- Delete unwanted Bakup-directory names(s)

proc EditBakupList {} {
	global pr_bakdel bakup_dirs new_bakup_dirs wstk sl_real evv

	if {!$sl_real} {
		Inf "You Can Edit The List Of Directories Recently Used For Backing Up Files"
		return
	}
	if {![info exists new_bakup_dirs] && ![info exists bakup_dirs]} {
		Inf "No Files Have Been Backed Up In Recent Sessions: Or The Listing Has Recently Been Deleted"
		return
	}
	set f .bakdel
	if [Dlg_Create $f "EDIT LIST OF BACKUP DIRECTORIES" "set pr_bakdel 0" -width 80 -borderwidth $evv(SBDR)] {
		set b [frame $f.b -borderwidth $evv(SBDR)]
		button $b.d -text "Delete Chosen Only" -command "set pr_bakdel 1" -width 18 -highlightbackground [option get . background {}]
		button $b.d1 -text "Delete From Chosen" -command "set pr_bakdel 2" -width 18 -highlightbackground [option get . background {}]
		button $b.d2 -text "Delete All" -command "set pr_bakdel 3" -width 18 -highlightbackground [option get . background {}]
		button $b.q -text "Close" -command "set pr_bakdel 0" -highlightbackground [option get . background {}]
		pack $b.d $b.d1 $b.d2 -side left
		pack $b.q -side right
		Scrolled_Listbox $f.ll -width 60 -height 20 -selectmode extended
		pack $f.b $f.ll -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape>  {set pr_bakdel 0}
	}
	$f.ll.list delete 0 end
	if {[info exists bakup_dirs]} {
		foreach dirnam $bakup_dirs {
			$f.ll.list insert end $dirnam
		}
	}
	if {[info exists new_bakup_dirs]} {
		foreach dirnam $new_bakup_dirs {
			if {[info exists bakup_dirs]} {
				if {[lsearch $bakup_dirs $dirnam] < 0} {
					$f.ll.list insert end $dirnam
				}
			} else {		
				$f.ll.list insert end $dirnam
			}
		}
	}
	raise $f
	set pr_bakdel 0
	set finished 0
	My_Grab 0 $f pr_bakdel $f.ll.list
	while {!$finished} {
		tkwait variable pr_bakdel
		switch -- $pr_bakdel {
			1 {
				set ilist [$f.ll.list curselection]
				if {![info exists ilist] || (([llength $ilist] == 1) && ($ilist < 0))} {
					Inf "No Directory Name Selected"
					continue
				}
				set choice [tk_messageBox -message "Delete All The Selected Directory Names ?" \
					-type yesno -parent [lindex $wstk end] -icon question]
				if {$choice == "no"} {
					continue
				}
				set ilist [ReverseList $ilist]
				foreach i $ilist {
					set dn [$f.ll.list get $i]
					$f.ll.list delete $i
					if {[info exists bakup_dirs]} {
						set j [lsearch -exact $bakup_dirs $dn]
						if {$j >= 0} {
							set bakup_dirs [lreplace $bakup_dirs $j $j]
						}
						if {[llength $bakup_dirs] <= 0} {
							unset bakup_dirs
						}
					}
					if {[info exists new_bakup_dirs]} {
						set j [lsearch -exact $new_bakup_dirs $dn]
						if {$j >= 0} {
							set new_bakup_dirs [lreplace $new_bakup_dirs $j $j]
						}
						if {[llength $new_bakup_dirs] <= 0} {
							unset new_bakup_dirs
						}
					}
				}
			}
			2 {
				set ilist [$f.ll.list curselection]
				if {![info exists ilist] || (([llength $ilist] == 1) && ($ilist < 0))} {
					Inf "No Directory Name Selected"
					continue
				}
				if {[llength $ilist] > 1} {
					Inf "Select Just One Directory Name, For This Option"
					continue
				}
				set choice [tk_messageBox -message "Delete All The Selected Directory Names After The Selected File?" \
					-type yesno -parent [lindex $wstk end] -icon question]
				if {$choice == "no"} {
					continue
				}
				set start [lindex $ilist 0]
				set i [$f.ll.list index end]
				incr  i -1
				while {$i >= $start} {
					set dn [$f.ll.list get $i]
					$f.ll.list delete $i
					if {[info exists bakup_dirs]} {
						set j [lsearch -exact $bakup_dirs $dn]
						if {$j >= 0} {
							set bakup_dirs [lreplace $bakup_dirs $j $j]
						}
						if {[llength $bakup_dirs] <= 0} {
							unset bakup_dirs
						}
					}
					if {[info exists new_bakup_dirs]} {
						set j [lsearch -exact $new_bakup_dirs $dn]
						if {$j >= 0} {
							set new_bakup_dirs [lreplace $new_bakup_dirs $j $j]
						}
						if {[llength $new_bakup_dirs] <= 0} {
							unset new_bakup_dirs
						}
					}
					incr i -1
				}
			}
			3 {
				if {[AreYouSure]} {
					catch {unset bakup_dirs}
					catch {unset new_bakup_dirs}
					set finished 1
				}
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------- Remove directory name from internal listings, when directory deleted

proc PurgeDirs {dirname deleted} {
	global recent_dirs new_bakup_dirs

	if {[info exists new_bakup_dirs]} {
		set i [lsearch -exact $new_bakup_dirs $dirname]
		if {$i >= 0} {
			set new_bakup_dirs [lreplace $new_bakup_dirs $i $i]
		}
		if {[llength $new_bakup_dirs] <= 0} {
			unset new_bakup_dirs
		}
	}
	if {$deleted && [info exists recent_dirs]} {
		set i [lsearch -exact $recent_dirs $dirname]
		if {$i >= 0} {
			set recent_dirs [lreplace $recent_dirs $i $i]
		}
		if {[llength $recent_dirs] <= 0} {
			unset recent_dirs
		}
	}
}

#------- Remove directory name from internal listings, when directory deleted

proc PurgeEmptyDirs {} {
	global recent_dirs new_bakup_dirs empty_dirs wksp_dirname sl_real dl hidden_dir

	if {!$sl_real} {
		Inf "If Any Directory Has Been Deleted, This Button Will Remove All References To It Within The Sound Loom\ne.g.It Will Remove It From The Recently Accessed Directories List"
		return
	}
	Block "PURGING EMPTY DIRECTORIES"
	if {[info exists recent_dirs]} {
		foreach dirname $recent_dirs {
			set OK 1
			if {![file exists $dirname] || ![file isdirectory $dirname]} {
				if {[info exists wksp_dirname] && [string match $wksp_dirname $dirname]} {
					set wksp_dirname ""
					$dl delete 0 end
					set hidden_dir ""
				}
				set OK 0
			} else {
				set cnt 0
				foreach item [glob -nocomplain [file join $dirname *]] {
					incr cnt
					break
				}
				if {$cnt <= 0} {
					if {[info exists wksp_dirname] && [string match $wksp_dirname $dirname]} {
						set wksp_dirname ""
						$dl delete 0 end
						set hidden_dir ""
					}
					set OK 0
				}
			}
			if {$OK} {
				lappend newlist $dirname
			}
		}
	}
	if {[info exists newlist]} {
		set recent_dirs $newlist
	} else {
		catch {unset recent_dirs}
	}
	catch {unset newlist}
	if {[info exists new_bakup_dirs]} {
		foreach dirname $new_bakup_dirs {
			set OK 1
			if {![file exists $dirname] || ![file isdirectory $dirname]} {
				if {[info exists wksp_dirname] && [string match $wksp_dirname $dirname]} {
					set wksp_dirname ""
					$dl delete 0 end
					set hidden_dir ""
				}
				set OK 0
			} else {
				set cnt 0
				foreach item [glob -nocomplain [file join $dirname *]] {
					incr cnt
					break
				}
				if {$cnt <= 0} {
					if {[info exists wksp_dirname] && [string match $wksp_dirname $dirname]} {
						set wksp_dirname ""
						$dl delete 0 end
						set hidden_dir ""
					}
					set OK 0
				}
			}
			if {$OK} {
				lappend newlist $dirname
			}
		}
	}
	if {[info exists newlist]} {
		set new_bakup_dirs $newlist
	} else {
		catch {unset new_bakup_dirs}
	}
	UnBlock
}

#---- Delete unwanted Bakup-directories

proc RemoveEmptyDirs {} {
	global empty_dirs new_bakup_dirs bakup_dirs recent_dirs pr_dirdel wstk wksp_dirname dl sl_real evv

	if {!$sl_real} {
		Inf "Currently Empty Directories Can Be Listed\nAnd Individually Selected For Deletion"
		return
	}
	FindEmptyDirs
	if {![info exists empty_dirs]} {
		Inf "There Are No Recently Used Empty Directories"
		return
	}
	set f .dirdel
	if [Dlg_Create $f "EDIT LIST OF BACKUP DIRECTORIES" "set pr_dirdel 0" -width 80 -borderwidth $evv(SBDR)] {
		set b [frame $f.b -borderwidth $evv(SBDR)]
		button $b.d -text "Delete" -command "set pr_dirdel 1" -highlightbackground [option get . background {}]
		button $b.q -text "Close" -command "set pr_dirdel 0" -highlightbackground [option get . background {}]
		pack $b.d -side left
		pack $b.q -side right
		Scrolled_Listbox $f.ll -width 60 -height 20 -selectmode single
		pack $f.b $f.ll -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_dirdel 1}
		bind $f <Escape> {set pr_dirdel 0}
	}
	$f.ll.list delete 0 end
	foreach dirnam $empty_dirs {
		$f.ll.list insert end $dirnam
	}
	raise $f
	set pr_dirdel 0
	set finished 0
	My_Grab 0 $f pr_dirdel $f.ll.list
	while {!$finished} {
		tkwait variable pr_dirdel
		if {$pr_dirdel} {
			set i [$f.ll.list curselection]
			if {![info exists i] || ($i < 0)} {
				Inf "No Directory Name Selected"
				continue
			}
			set dirnam [$f.ll.list get $i]
			if {[string length $dirnam] <= 0} {
				Inf "No Directory Name Selected"
				continue
			}
			if {[file exists $dirnam]} {
				set choice [tk_messageBox -message "Are You Sure You Want To Delete The Empty Directory '$dirnam' ?" \
					-type yesno -parent [lindex $wstk end] -icon question]
				if {$choice == "no"} {
					continue
				} else {
					if [catch {file delete -force $dirnam} zit] {
						Inf "Cannot Delete Directory $dirnam"
						continue
					}
				}
			}
			$f.ll.list delete $i
			if {[info exists bakup_dirs]} {
				set jj [lsearch $bakup_dirs $dirnam]
				if {$jj >= 0} {
					set bakup_dirs [lreplace $bakup_dirs $jj $jj]
					if {[llength $bakup_dirs] <= 0} {
						unset bakup_dirs 
					}
				}
			}
			if {[info exists new_bakup_dirs]} {
				set jj [lsearch $new_bakup_dirs $dirnam]
				if {$jj >= 0} {
					set new_bakup_dirs [lreplace $new_bakup_dirs $jj $jj]
					if {[llength $new_bakup_dirs] <= 0} {
						unset new_bakup_dirs
					}
				}
			}
			if {[info exists recent_dirs]} {
				set jj [lsearch $recent_dirs $dirnam]
				if {$jj >= 0} {
					set recent_dirs [lreplace $recent_dirs $jj $jj]
					if {[llength $recent_dirs] <= 0} {
						unset recent_dirs
					}
				}
			}
			if {[info exists wksp_dirname] && [string match $wksp_dirname $dirnam]} {
				set wksp_dirname ""
				$dl delete 0 end
			} 
			set rr 0
			foreach item [$dl get 0 end] {
				if [string match $item $dirnam] {
					$dl delete $rr
					break
				}
				incr rr
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#---- Search for empty directories mentioned in recent directry or backup directory listings

proc FindEmptyDirs {} {
	global recent_dirs new_bakup_dirs bakup_dirs empty_dirs dl evv hidden_dir

	Block "FINDING EMPTY DIRECTORIES"
	catch {unset empty_dirs}
	set i 0
	foreach dirname [$dl get 0 end] {
		if {[string length $hidden_dir] > 0} {
			set dirname [file join $hidden_dir $dirname]
		}
		if {[file isdirectory $dirname]} {
			lappend ilist $i
		}
		incr i
	}
	if {[info exists ilist]} {
		foreach i [lsort -integer -decreasing $ilist] {
			set dirname [$dl get $i]
			if {[string length $hidden_dir] > 0} {
				set dirname [file join $hidden_dir $dirname]
			}
			set cnt 0
			foreach item [glob -nocomplain [file join $dirname *]] {
				incr cnt
				break
			}
			if {$cnt <= 0} {
				$dl delete $i
			}
		}
	}
	if {[info exists recent_dirs]} {
		foreach dirname $recent_dirs {
			set OK 1
			if {![file exists $dirname]} {
				lappend empty_dirs $dirname
			} elseif {[file isdirectory $dirname]} {
				set cnt 0
				foreach item [glob -nocomplain [file join $dirname *]] {
					incr cnt
					break
				}
				if {$cnt <= 0} {
					lappend empty_dirs $dirname
				}
			}
		}
	}
	if {[info exists new_bakup_dirs]} {
		foreach dirname $new_bakup_dirs {
			set OK 1
			if {![file exists $dirname]} {
				if {[info exists empty_dirs]} {
					if {[lsearch $empty_dirs $dirname] < 0} {
						lappend empty_dirs $dirname
					}
				} else {
					lappend empty_dirs $dirname
				}
			} elseif {[file isdirectory $dirname]} {
				set cnt 0
				foreach item [glob -nocomplain [file join $dirname *]] {
					incr cnt
					break
				}
				if {$cnt <= 0} {
					if {[info exists empty_dirs]} {
						if {[lsearch $empty_dirs $dirname] < 0} {
							lappend empty_dirs $dirname
						}
					} else {
						lappend empty_dirs $dirname
					}
				}
			}
		}
	}
	if {[info exists bakup_dirs]} {
		foreach dirname $bakup_dirs {
			set OK 1
			if {![file exists $dirname]} {
				if {[info exists empty_dirs]} {
					if {[lsearch $empty_dirs $dirname] < 0} {
						lappend empty_dirs $dirname
					}
				} else {
					lappend empty_dirs $dirname
				}
			} elseif {[file isdirectory $dirname]} {
				set cnt 0
				foreach item [glob -nocomplain [file join $dirname *]] {
					incr cnt
					break
				}
				if {$cnt <= 0} {
					if {[info exists empty_dirs]} {
						if {[lsearch $empty_dirs $dirname] < 0} {
							lappend empty_dirs $dirname
						}
					} else {
						lappend empty_dirs $dirname
					}
				}
			}
		}
	}
	UnBlock
}

proc EditRecentNamesList {} {
	global nu_names pr_recnam wstk sl_real evv

	if {!$sl_real} { 
		Inf "The Soundloom Keeps A List Of The Names Most Recently Used\nFor Newly Created Files.\n\nThis List Can Be Edited Here."
		return
	}
	if {![info exists nu_names]} { 
		Inf "There Is No List Of Recent Names"
		return
	}
	set is_changed 0

	set f .recnam
	if [Dlg_Create $f "EDIT LIST OF RECENT NAMES" "set pr_recnam 0" -width 40 -borderwidth $evv(SBDR)] {
		set b [frame $f.b -borderwidth $evv(SBDR)]
		label $b.l -text "TO DELETE ONE NAME:\n\nSELECT NAME from list\nand CONFIRM deletion"
		button $b.b -text "Close" -command "set pr_recnam 0" -highlightbackground [option get . background {}]
		button $b.b2 -text "Delete All" -command "set pr_recnam 2" -highlightbackground [option get . background {}]
		pack $b.b2 $b.l -side left -pady 2 -padx 8
		pack $b.b -side right
		Scrolled_Listbox $f.ll -width 40 -height 20
		pack $f.b $f.ll -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f.ll.list <ButtonRelease-1> "set pr_recnam 1"
		bind $f <Escape>  {set pr_recnam 0}
	}
	$f.ll.list delete 0 end
	foreach name $nu_names {
		$f.ll.list insert end $name
	}	
	raise $f
	set pr_recnam 0
	set finished 0
	My_Grab 0 $f pr_recnam $f.ll.list
	while {!$finished} {
		tkwait variable pr_recnam
		switch -- $pr_recnam {
			0 {
				set finished 1
			}
			1 {
				set i [$f.ll.list curselection]
				if {![info exists i] || ($i < 0)} {
					Inf "No Name Selected"
					continue
				}
				set mnam [$f.ll.list get $i]
				if {[string length $mnam] <= 0} {
					Inf "No Name Selected"
					continue
				}
				set choice [tk_messageBox -message "Delete The Name '$mnam' ?" \
					-type yesno -parent [lindex $wstk end] -icon question]
				if {$choice == "no"} {
					continue
				}
				$f.ll.list delete $i
				set is_changed 1
			}
			2 {
				if {[AreYouSure]} {
					catch {unset nu_names}
					$f.ll.list delete 0 end
					set is_changed 1
					set finished 1
				}
			}
		}
	}
	if {$is_changed} {
		foreach name [$f.ll.list get 0 end] {
			lappend newlist $name
		}
		if {![info exists newlist]} {
			catch {unset nu_names}
			set fnam [file join $evv(URES_DIR) $evv(NUNAMES)$evv(CDP_EXT)]
			if {[file exists $fnam]} {
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Delete Existing File Listing Of Recent Names"
					return
				}
			}
		} else {
			set nu_names $newlist
			SaveRecentNames
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Compare filenames

#----- Compare filenames

proc CompareTextfiles {} {
	global wl ch pr_tc pa evv sl_real compare_fils shc_ilist0 shc_ilist1
	if {!$sl_real} {
		Inf "If You Select A Pair Of Textfiles\nYou Can Compare Their Contents"
		return
	}
	set ilist [$wl curselection]
	if {[llength $ilist] != 2} {
		Inf "This Option Only Works With A Pair Of Files"
		return
	}
	set fnam1 [$wl get [lindex $ilist 0]]
	set fnam2 [$wl get [lindex $ilist 1]]
	if {![info exists pa($fnam1,$evv(FTYP))] || ![info exists pa($fnam2,$evv(FTYP))] } {
		Inf "File Data Missing"
		return
	}
	if {!($pa($fnam1,$evv(FTYP)) & $evv(IS_A_TEXTFILE)) || !($pa($fnam2,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
		Inf "These Are Not Two Textfiles"
		return
	}
	if [catch {open $fnam1 r} zit1] {
		Inf "Cannot Open File '$fnam1'"
		return
	}
	if [catch {open $fnam2 r} zit2] {
		Inf "Cannot Open File '$fnam1'"
		catch {close $zit1}
		return
	}
	while {[gets $zit1 line] >= 0} {
		lappend lines0 $line
	}
	catch {close $zit1}
	while {[gets $zit2 line] >= 0} {
		lappend lines1 $line
	}
	catch {close $zit2}
	set cnt 0
	foreach line0 $lines0 {
		catch {unset nuline}
		set line0 [string trim $line0]
		set line0 [split $line0]
		foreach item $line0 {
			set item [string trim $item]
			if {[string length $item] > 0} {
				lappend nuline $item
			}
		}
		if [info exists nuline] {
			set line0 [join $nuline]
			lappend nulines0 $line0
		}
	}
	set lines0 $nulines0
	set len_0 [llength $lines0]
	foreach line1 $lines1 {
		catch {unset nuline}
		set line1 [string trim $line1]
		set line1 [split $line1]
		foreach item $line1 {
			set item [string trim $item]
			if {[string length $item] > 0} {
				lappend nuline $item
			}
		}
		if [info exists nuline] {
			set line1 [join $nuline]
			lappend nulines1 $line1
		}
	}
	set lines1 $nulines1
	set len_1 [llength $lines1]
	catch {unset shc_ilist0}
	set cnt 0
	foreach line0 $lines0 {
		if {[lsearch $lines1 $line0] < 0} {
			lappend shc_ilist0 $cnt
		}
		incr cnt
	}
	catch {unset shc_ilist1}
	set cnt 0
	foreach line1 $lines1 {
		if {[lsearch $lines0 $line1] < 0} {
			lappend shc_ilist1 $cnt
		}
		incr cnt
	}
	catch {unset sfilnams0}
	foreach line0 $lines0 {
		lappend sfilnams0 [lindex $line0 0]
	}
	catch {unset sfilnams1}
	foreach line1 $lines1 {
		lappend sfilnams1 [lindex $line1 0]
	}
	catch {unset shc_ilist0m}
	set cnt 0
	foreach sfilnam0 $sfilnams0 {
		if {[lsearch $sfilnams1 $sfilnam0] < 0} {
			lappend shc_ilist0m $cnt
		}
		incr cnt
	}
	catch {unset shc_ilist1m}
	set cnt 0
	foreach sfilnam1 $sfilnams1 {
		if {[lsearch $sfilnams0 $sfilnam1] < 0} {
			lappend shc_ilist1m $cnt
		}
		incr cnt
	}
	if {(![info exists shc_ilist0] && ![info exists shc_ilist1]) && ($len_0 == $len_1)} {
		Inf "Files\n$fnam1\n$fnam2\nAre Identical"
		return
	}
	set min_ct_lines $len_0
	if {$len_1 < $min_ct_lines} {
		set min_ct_lines $len_1
	}
	set f .textcomp
	if [Dlg_Create $f "COMPARE TWO TEXTFILES" "set pr_ct 0" -width 40 -borderwidth $evv(SBDR)] {
		set a [frame $f.a -borderwidth $evv(SBDR)]
		set aa [frame $f.aa -borderwidth $evv(SBDR)]
		set aaa [frame $f.aaa -borderwidth $evv(SBDR)]
		set b [frame $f.b -borderwidth $evv(SBDR)]
		set bb [frame $b.b -borderwidth $evv(SBDR)]
		set cc [frame $b.c -borderwidth $evv(SBDR)]
		button $a.ok -text OK -command "set pr_ct 0" -highlightbackground [option get . background {}]
		pack $a.ok -side top -pady 2
		label $aa.la -text "Differences in Display on "
		radiobutton $aa.ll -variable compare_fils -text "Left " -value 0 -command ShowComp
		radiobutton $aa.rr -variable compare_fils -text "Right " -value 1 -command ShowComp
		label $aa.lam -text "Differences in Soundfiles in Display on "
		radiobutton $aa.llm -variable compare_filsm -text "Left "  -value 0 -command ShowCompMix
		radiobutton $aa.rrm -variable compare_filsm -text "Right " -value 1 -command ShowCompMix
		pack $aa.la $aa.ll $aa.rr $aa.lam $aa.llm $aa.rrm -side left
		label $aaa.ll -text "Hilite Line-pair : Left/Right  Keys : Delete = delete line-number display  " -fg $evv(SPECIAL)
		label $aaa.ll2 -text "  Line-pair "
		entry $aaa.ee -textvariable ct_line -width 4 -state readonly
		label $aaa.ll3 -text "                    Hilited File  \"Control P\" Play    \"Control G\" Grab to Workspace" -fg $evv(SPECIAL)
		pack $aaa.ll $aaa.ll2 $aaa.ee $aaa.ll3 -side left
		label $bb.l -text "" -width 55
		label $cc.l -text "" -width 55
		Scrolled_Listbox $bb.ll -width 100 -height 48
		Scrolled_Listbox $cc.ll -width 100 -height 48
		pack $bb.l $bb.ll -side top -fill x -expand true -pady 2
		pack $cc.l $cc.ll -side top -fill x -expand true -pady 2
		pack $bb $cc -side left -fill x -expand true -pady 2
		pack $a $aa $aaa $b -side top
		wm resizable $f 0 0
		bind $f <Left> {Show_Linepair 0}
		bind $f <Right> {Show_Linepair 0}
		bind $f <Delete> {Show_Linepair 1}
		bind $f <Return> {set pr_ct 0}
		bind $f <Escape> {set pr_ct 0}
		bind $f <Key-space> {set pr_ct 0}
		bind $f <Control-g> CompareGrab
		bind $f <Control-G> CompareGrab
		bind $f <Control-p> ComparePlay
		bind $f <Control-P> ComparePlay
	}
	set ct_line ""
	ForceVal .textcomp.aaa.ee $ct_line
	set compare_fils -1
	set compare_filsm -1
	if {[IsAMixfile $pa($fnam1,$evv(FTYP))] && [IsAMixfile $pa($fnam2,$evv(FTYP))]} {
		.textcomp.aa.lam config -text "Differences in Soundfiles in Display on "
		.textcomp.aa.llm config -text "Left "  -command ShowCompMix -state normal
		.textcomp.aa.rrm config -text "Right " -command ShowCompMix -state normal
	} elseif {![IsAMixfile $pa($fnam1,$evv(FTYP))] && ![IsAMixfile $pa($fnam2,$evv(FTYP))] \
			&& [IsAMixfileIncludingMultichan $pa($fnam1,$evv(FTYP))] && [IsAMixfileIncludingMultichan $pa($fnam2,$evv(FTYP))]} {
		.textcomp.aa.lam config -text "Differences in Soundfiles in Display on "
		.textcomp.aa.llm config -text "Left "  -value 0 -command ShowCompMix -state normal
		.textcomp.aa.rrm config -text "Right " -value 1 -command ShowCompMix -state normal
	} else {
		.textcomp.aa.lam config -text ""
		.textcomp.aa.llm config -text "" -command {} -state disabled
		.textcomp.aa.rrm config -text "" -command {} -state disabled
	}
	$f.b.b.l config -text $fnam1
	$f.b.c.l config -text $fnam2
	$f.b.b.ll.list delete 0 end
	$f.b.c.ll.list delete 0 end
	foreach line $lines0 {
		$f.b.b.ll.list insert end $line
	}
	foreach line $lines1 {
		$f.b.c.ll.list insert end $line
	}
	ShowComp
	raise $f
	set pr_ct 0
	set finished 0
	My_Grab 0 $f pr_ct
	tkwait variable pr_ct
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----------

proc RenameOnDirlist {fnam nufname} {
	global dl hidden_dir
	if {[info exists dl]} {
		if {[string length $hidden_dir] > 0} {
			set thisdir $hidden_dir
		} else {
			set thisdir [file dirname [$dl get 0]]
			if {[string length thisdir] <= 1} {
				set thisdir ""
			}
		}
		if {[string match [file dirname $fnam] $thisdir] && [string match [file dirname $nufname] $thisdir]} {
			if {[string length $hidden_dir] > 0} {
				set jj [LstIndx [file tail $fnam] $dl]
				if {$jj >= 0} {
					$dl delete $jj
					$dl insert $jj [file tail $nufname]
				}
			} else {
				set jj [LstIndx $fnam $dl]
				if {$jj >= 0} {
					$dl delete $jj
					$dl insert $jj $nufname
				}
			}
		}
	}
}

#---- Edit list of Recently Used Directories

proc EditRecentDirList {edit var} {
	global pr_recdel recent_dirs wstk fildir compdir1 compdir2 sl_real evv

	if {!$sl_real} {
		if {$edit} {
			Inf "You Can Edit The List Of Recently Visited Directories"
		} else {
			Inf "You Can Get A Directory Name From The List Of Recently Visited Directories"
		}
		return
	}
	if {![info exists recent_dirs]} {
		return
	}
	set f .recdel
	if [Dlg_Create $f "EDIT LIST OF RECENT DIRECTORIES" "set pr_recdel 0" -width 80 -borderwidth $evv(SBDR)] {
		set b [frame $f.b -borderwidth $evv(SBDR)]
		button $b.d -text "Delete" -command "set pr_recdel 1" -width 7 -highlightbackground [option get . background {}]
		button $b.q -text "Close" -command "set pr_recdel 0" -highlightbackground [option get . background {}]
		pack $b.d -side left
		pack $b.q -side right
		Scrolled_Listbox $f.ll -width 60 -height 20 -selectmode single
		pack $f.b $f.ll -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_recdel 1}
		bind $f <Escape> {set pr_recdel 0}
	}
	$f.ll.list delete 0 end
	foreach dirnam $recent_dirs {
		$f.ll.list insert end $dirnam
	}
	if {$edit == 1} {
		.recdel.b.d config -text "Delete"
	} else {
		.recdel.b.d config -text "Use"
	}
	raise $f
	set pr_recdel 0
	set finished 0
	My_Grab 0 $f pr_recdel $f.ll.list
	while {!$finished} {
		tkwait variable pr_recdel
		if {$pr_recdel} {
			set i [$f.ll.list curselection]
			if {![info exists i] || ($i < 0)} {
				Inf "No Directory Name Selected"
				continue
			}
			set dirnam [$f.ll.list get $i]
			if {[string length $dirnam] <= 0} {
				Inf "No Directory Name Selected"
				continue
			}
			if {$edit} {
				set choice [tk_messageBox -message "Delete The Directory Name '$dirnam' ?" \
					-type yesno -parent [lindex $wstk end] -icon question]
				if {$choice == "no"} {
					continue
				}
				set dn [$f.ll.list get $i]
				$f.ll.list delete $i
				set j [lsearch -exact $recent_dirs $dn]
				if {$j >= 0} {
					set recent_dirs [lreplace $recent_dirs $j $j]
				}
				if {[llength $recent_dirs] <= 0} {
					unset recent_dirs 
				}
			} else {
				set dn [$f.ll.list get $i]
				if {[string match $var "fildir"] && [string match [pwd] $dn]} {
					Inf "Current Directory Is Home Directory.\nUse File Finder On Workspace 'Any/All Files' Menu"
					continue
				}
				set $var $dn
				set finished 1
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Dialog to Find file contanining specified string

proc FileFind {inmix frombl all} {
	global do_subs pr_filfnd filstr fildir evv wl dl ch

	set ext_ok 0
	set f .file_find
	if [Dlg_Create $f "FIND FILE" "set pr_filfnd 0" -width 80 -borderwidth $evv(SBDR)] {
		set b0 [frame $f.b0 -borderwidth $evv(SBDR)]
		set b00 [frame $f.b00 -height 1 -bg [option get . foreground {}]]
		set b1 [frame $f.b1 -borderwidth $evv(SBDR)]
		set b2 [frame $f.b2 -borderwidth $evv(SBDR)]
		set b3 [frame $f.b3 -borderwidth $evv(SBDR)]
		set b4 [frame $f.b4 -borderwidth $evv(SBDR)]
		set b01 [frame $f.b01 -height 1 -bg [option get . foreground {}]]
		set b5 [frame $f.b5 -borderwidth $evv(SBDR)]
		set b6 [frame $f.b6 -borderwidth $evv(SBDR)]
		button $b0.ff -text "Find File" -command {set pr_filfnd 1} -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $b0.qu -text "Close" -command {set pr_filfnd 0} -highlightbackground [option get . background {}]
		pack $b0.ff -side left
		pack $b0.qu -side right

		label $b1.l -text "DIRECTORY TO SEARCH"
		pack $b1.l -side top -pady 1

		button $b2.fd -text "Find Any Dir" -command {DoListingOfDirectories .file_find.b3.e} -highlightbackground [option get . background {}]
		button $b2.rd -text " Find Recent Dir" -command {EditRecentDirList 0 fildir} -highlightbackground [option get . background {}]
		button $b2.cd -text "Get Current Dir" -command {set fildir [GetCurDir]} -highlightbackground [option get . background {}]
		button $b2.hd -text "Get Home Dir" -command {set fildir [string tolower [pwd]]} -highlightbackground [option get . background {}]
		pack $b2.fd $b2.rd $b2.cd $b2.hd -side left -padx 5 -expand true -fill x

		entry $b3.e -textvariable fildir -width 60
		pack $b3.e -side top -pady 1

		checkbutton $b3.sub -variable do_subs -text "SEARCH SUBDIRECTORIES"
		pack $b3.sub -side top -pady 2

		label $b5.l -text "STRING TO MATCH"
		pack $b5.l -side top -pady 1
		entry $b6.e -textvariable filstr -width 24
		pack $b6.e -side top -pady 1

		pack $b0 -side top -fill x -expand true
		pack $b01 -side top -fill x -expand true -pady 2
		pack $b5 $b6 -side top -fill x -expand true
		pack $b00 -side top -fill x -expand true -pady 2
		pack $b1 $b2 $b3 $b4 -side top -fill x -expand true -anchor center
		bind .file_find.b3.e <Up> "focus .file_find.b6.e"
		bind .file_find.b3.e <Down> "focus .file_find.b6.e"
		bind .file_find.b6.e <Up> "focus .file_find.b3.e"
		bind .file_find.b6.e <Down> "focus .file_find.b3.e"
		wm resizable $f 1 1
		bind $f <Return> {set pr_filfnd 1}
		bind $f <Escape> {set pr_filfnd 0}
	}
	set filstr [file rootname [file tail [GetFirstOfAnySelectedFileOnWkspacePage]]]
	switch -- $inmix {
		0 { wm title $f "FIND FILES" }
		1 { wm title $f "FIND FILE IN MIXFILES (This may be VERY SLOW!)" } 
		2 { wm title $f "FIND SOUNDFILES (This may be SLOW)"} 
	}
	set do_subs 0
	raise $f
	set pr_filfnd 0
	set finished 0
	My_Grab 0 $f pr_filfnd $f.b6.e
	while {!$finished} {
		tkwait variable pr_filfnd
		if {$pr_filfnd} {
			if {!$all} {			;# SEARCH FOR ALL files in given dirs (where no search str would be needed) not permitted
				if {[string length $filstr] <= 0} {
					Inf "No Search String Entered"
					continue
				}
				if {$inmix == 0} {
					set ext_ok 1	;# If searching for ANY files, rather than sound or mixfiles, ok to use file extensions

				} elseif {[regexp {[^A-Za-z0-9\-\_]+} $filstr]} {
					Inf "Invalid Characters In Search String '$filstr'\n\nYou cannot use directory paths or file extensions here."
					continue
				}
			} elseif {[regexp {[^A-Za-z0-9\-\_]+} $filstr]} {
				Inf "Invalid Characters In Search String '$filstr'\n\nYou cannot use directory paths or file extensions here."
				continue
			}
			set dirname [CheckDirectoryName $fildir "DIRECTORY NAME" 1 1]
			if {[string length $dirname] <= 0} {
	 			continue
			} elseif {![file isdirectory $dirname]} {
				Inf "directory '$dirname' Does Not Exist"
				continue
			}
			set fildir $dirname
			if [FindFile $inmix $fildir $filstr $do_subs $frombl $ext_ok] {
				set finished 1
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Find file containing specified string

proc FindFile {inmix dirname str do_subs frombl ext_ok} {
	global filedir pr_fndfil dl ww wl wksp_dirname wksp_in_chose_mode pa b_l_name same_b_l background_listing evv
	global score_files grabbed_bln hidden_dir mixmanage
	
	set fdir {}
	if {$inmix == 1} {
		Block "SEARCHING MIXFILES FOR FILENAMES CONTAINING $str"
	} else {
		Block "SEARCHING FOR FILENAMES CONTAINING $str"
	}
	if {$inmix == 1} {
		if {[info exists mixmanage]} {
			foreach name [array names mixmanage] {
				foreach fnam $mixmanage($name) {
					set rfnam [file rootname [file tail $fnam]]
					if {[string first [string tolower $str] [string tolower $rfnam]] >= 0} {
						lappend fdir $name
						break
					}
				}
			}
		} else {
			set fdir {}
		}
	} else {
		set fdir [SearchDirectoriesForFile $inmix $dirname $str $fdir $do_subs $ext_ok]
	}

	UnBlock
	if {[llength $fdir] <= 0} {
		switch -- $inmix {
			0 { Inf "cannot Find Any Filenames Containing '$str'" }
			1 { Inf "Cannot Find Any Mixfiles Using Filenames Containing '$str'" } 
			2 { Inf "Cannot Find Any Soundfile Names Containing '$str'" }
		}
		return 0
	}
	set i 0
	set j -1
	foreach fnam $fdir {
		set drn [file dirname $fnam]
		if {([string match -nocase $drn [pwd]] || ([string length $drn] <= 1)) \
		&& [string match *$evv(GUI_NAME)$evv(TCL_EXT) $fnam]} {
			set j $i
			break
		}
		incr i
	}
	if {$j >= 0} {
		set fdir [lreplace $fdir $j $j]
	}
	if {[llength $fdir] <= 0} {
		if {[string length $str] > 0} {
			Inf "Cannot Find Any Filename Containing '$str'"
		} else {
			Inf "Cannot Find Any Files"
		}
		return 0
	}
	set fdir [lsort $fdir]
	
	set f .find_file
	if [Dlg_Create $f "POSSIBLE FILES" "set pr_fndfil 0" -width 80 -borderwidth $evv(SBDR)] {
		set b [frame $f.b -borderwidth $evv(SBDR)]
		button $b.p -text "Play" -command "set pr_fndfil 3" -width 8 -highlightbackground [option get . background {}]
		button $b.d -text "to Wkspace" -command "set pr_fndfil 1" -highlightbackground [option get . background {}]
		button $b.f -text "to Blist" -command "set pr_fndfil 4" -highlightbackground [option get . background {}]
		button $b.z -text "to Sketch Score" -command "set pr_fndfil 5" -highlightbackground [option get . background {}]
		button $b.e -text "Dir to Wkspace" -command "set pr_fndfil 2" -highlightbackground [option get . background {}]
		button $b.q -text "Close" -command "set pr_fndfil 0" -highlightbackground [option get . background {}]
		pack $b.p $b.d $b.f $b.z $b.e -side left -padx 2
		pack $b.q -side right
		Scrolled_Listbox $f.ll -width 60 -height 20 -selectmode extended
		pack $f.b $f.ll -side top -fill x -expand true
		wm resizable $f 1 1
		bind .find_file <Control-Key-p> {UniversalPlay list .find_file.ll.list}
		bind .find_file <Control-Key-P> {UniversalPlay list .find_file.ll.list}
		bind .find_file <Key-space>		{UniversalPlay list .find_file.ll.list}
		bind .find_file <Double-1> {PossiblyPlaySnd %W %y}
		bind .find_file <Control-Key-g> {set pr_fndfil 1}
		bind .find_file <Control-Key-G> {set pr_fndfil 1}
		bind .find_file <Escape>	{set pr_fndfil 0}
	} 
	switch -- $inmix {
		0 { $f.b.p config -text "Play:Read" }
		1 { $f.b.p config -text "Read File" }
		2 { $f.b.p config -text "Play File" }
	}
	if {$frombl} {
		.find_file.b.d config -text "to Blist" -command "set pr_fndfil 6" -state normal -bd 2
		.find_file.b.e config -text "" -command {} -state disabled -bd 0
		.find_file.b.f config -text "" -command {} -state disabled -bd 0
		.find_file.b.z config -text "" -command {} -state disabled -bd 0
	} else {
		.find_file.b.d config -text "to Wkspace" -command "set pr_fndfil 1" -state normal -bd 2
		.find_file.b.e config -text "Dir to Wkspace" -command "set pr_fndfil 2" -state normal -bd 2
		.find_file.b.f config -text "to Blist" -command "set pr_fndfil 4" -state normal -bd 2
		.find_file.b.z config -text "to Sketch Score" -command "set pr_fndfil 5" -state normal -bd 2
	}
	$f.ll.list delete 0 end
	foreach fnam $fdir {
		$f.ll.list insert end $fnam
	}
	raise $f
	set pr_fndfil 0
	set finished 0
	My_Grab 0 $f pr_fndfil $f.ll.list
	while {!$finished} {
		tkwait variable pr_fndfil
		if {$pr_fndfil == 0} {
			set finished 1
			break
		}
		set ilist [$f.ll.list curselection]
		if {![info exists ilist] || ([llength $ilist] <= 0)} {
			Inf "No Files Selected"
			continue
		}
		switch -- $pr_fndfil {
			1 -
			4 -
			6 {
				catch {unset homef}
				catch {unset alreadyf}
				catch {unset failedf}
				catch {unset goodf}
				foreach i $ilist {			;# IGNORE HOME DIRECTORY FILES
					set fnam [$f.ll.list get $i]
					if {[string match -nocase [file dirname $fnam] [pwd]]} {
						lappend homef $fnam
					} else {
						lappend nulist $i
					}
				}
				if [info exists nulist] {
					set ilist $nulist
					switch -- $pr_fndfil {
						1 {					;# FILES TO WORKSPACE
							foreach i $ilist {
								set fnam [$f.ll.list get $i]
								if {[LstIndx $fnam $wl] >= 0} {
									lappend alreadyf $fnam
								} else {
									if {[FileToWkspace $fnam $wksp_in_chose_mode 0 0 1 0] <= 0} {
										lappend failedf $fnam
									} else {
										lappend goodf $fnam
									}
								}
							}
						}
						4 {					;# FILES TO BACKGROUND LISTING TO BE SPECIFIED
							GetBLName 0
							if {[string length $b_l_name] > 0} {
								set same_b_l $b_l_name
								set blfile_preexisted 0
								if {[file exists $background_listing]} {
									set blfile_preexisted 1
								}
								GetMoreBL $b_l_name $ilist $f.ll.list $blfile_preexisted $background_listing
							} else {
								catch {unset homef}
							}
						}
						6 {					;# FILES TO BACKGROUND LISTING SPECIFIED ELSEWHERE
							catch {unset grabbed_bln}
							foreach i $ilist {
								lappend grabbed_bln [$f.ll.list get $i]
							}
							Inf "Quit The 'Find Files' Display And Use 'Put Files'"
							set finished 1
						}
					}
				}
				if {[info exists alreadyf] || [info exists goodf]} {
					$wl selection clear 0 end
				}
				set msg ""
				if {[info exists homef]} {
					append msg  "Files"
					set zcnt 0
					foreach fnam $homef {
						if {$zcnt > 57} {
							append msg "  AND MORE"
							break
						}
						append msg "  $fnam"
						incr zcnt
					}
					if {$pr_fndfil == 1} {
						append msg "\n\nAre Home Directory Files.\nThese Are Always Listed On The Workspace\nIf They Are Valid CDP Files\n\n"
					} else {
						append msg "\n\nAre Home Directory Files.\nAnd Cannot Be Included In Background Listings\n\n"
					}
				}
				if {[info exists alreadyf]} {
					append msg  "Files"
					set zcnt 0
					foreach fnam $alreadyf {
						set k [LstIndx $fnam $wl]
						if {$k >= 0} {
							$wl selection set $k
						}
						if {$zcnt > 58} {
							append msg "  AND MORE"
							break
						}
						append msg "  $fnam"
						incr zcnt
					}
					set k [LstIndx [lindex $alreadyf 0] $wl]
					set k [expr double($k) / double([$wl index end])]
					$wl yview moveto $k
					append msg "\n\nAre Already On The Workspace\n\n"
				}
				if {[info exists failedf]} {
					append msg  "Files"
					set zcnt 0
					foreach fnam $failedf {
						if {$zcnt > 59} {
							append msg "  AND MORE"
							break
						}
						append msg "  $fnam"
						incr zcnt
					}
					append msg "\n\nWere Not Added To The Workspace\n\n"
				}
				if {[info exists goodf]} {
					append msg  "Files"
					set zcnt 0
					foreach fnam $goodf {
						set k [LstIndx $fnam $wl]
						if {$k >= 0} {
							$wl selection set $k
						}
						if {$zcnt > 60} {
							append msg "  AND MORE"
							break
						}
						append msg "  $fnam"
						incr zcnt
					}
					set k [LstIndx [lindex $goodf 0] $wl]
					set k [expr double($k) / double([$wl index end])]
					$wl yview moveto $k
					append msg "\n\nHave Been Added To The Workspace"
				}
				if {[string length $msg] > 0} {
					Inf "$msg"
				}
			}

			2 {					;# GET DIRECTORY OF SELECTED FILES TO WORKSPACE DIRECTORY LISTING

				if {[string length [$ww.1.b.msgx cget -text]] > 0} {
					Inf "YOU MUST LIST A DIRECTORY on the WORKSPACE\n\nBEFORE THIS OPTION BECOMES ACTIVE"
					continue
				}
				catch {unset dnam}
				catch {unset dnam0}
				foreach i $ilist {
					set fnam [$f.ll.list get $i]
					set dnam [file dirname $fnam]
					if {![info exists dnam0]} {
						set dnam0 $dnam
					} elseif {![string match $dnam $dnam0]} {
						Inf "You Have Selected Files From More Than One Directory"
						set dnam0 ""
						break
					}
				}
				if {[string length $dnam0] <= 0} {
					continue
				}
				set zfnam [$dl get 0]
				if {[info exists zfnam] && ([string length $zfnam] > 0)} {
					if {[string length $hidden_dir] > 0} {
						set zfnam [file join $hidden_dir $zfnam]
					}
					set zdir [file dirname $zfnam]
				}
				if {![info exists zdir] || ([string length $zdir] <= 1)} {
					set zdir ""
				}
				set dirlen [string length $dnam]
				set pwd [string tolower [pwd]]
				set pwdlen [string length $pwd]
				if [string match $pwd* $dnam] {
					if {$pwdlen == $dirlen} {
						set dnam ""
					} else {
						incr pwdlen
						set dnam [string range $dnam $pwdlen end]
					}
				}
				if {[string match $zdir $dnam]} {
					Inf "This Directory Is Already Listed\nIn The Workspace Directory Listing"
					HiliteFoundFilesOnDirList $ilist
					continue
				}
				set wksp_dirname $dnam
				UpdateRecentDirs $wksp_dirname
				$dl delete 0 end
				foreach fnam [lsort -dictionary [glob -nocomplain [file join $wksp_dirname *]]] {
					if [IsListableFile $fnam] {
						set fnam [string tolower $fnam]
						$dl insert end $fnam
					}
				}
				HiliteFoundFilesOnDirList $ilist
				if {[string length $wksp_dirname] > 0} {
					Inf "The Directory '$wksp_dirname' Has Been Listed\nOn The Workspace Directory Listing"
				} else {
					Inf "The Home Directory Has Been Listed\nOn The Workspace Directory Listing"
				}
				set finished 1
			}

			3 {					;# PLAY SELECTED FILE
				if {[llength $ilist] > 1} {
					Inf "more Than One File Selected"
					continue
				}
				set fnam [$f.ll.list get [lindex $ilist 0]]
				switch -- $inmix {
					0 {
						set fnam [StripHomeDir $fnam]
						set ftyp [FindFileType $fnam]
						if {$ftyp == $evv(SNDFILE)} {
							PlaySndfile $fnam 0
						} elseif {$ftyp == $evv(ANALFILE)} {
							PlaySndfile $fnam 1
						} elseif {$ftyp & $evv(IS_A_TEXTFILE)} {
							SimpleDisplayTextfile $fnam
						} else {
							Inf "'$fnam' Is Not Playable or Readable"
						}
					}
					1 { SimpleDisplayTextfile $fnam  }
					2 { PlaySndfile $fnam 0}
				}
			}
			5 {					;# SOUNDFILE TO SKETCH SCORE
				catch {unset score_files}
				catch {unset bad_files}
				foreach i $ilist {
					set fnam [$f.ll.list get $i]
					set fnam [StripHomeDir $fnam]
					switch -- $inmix {
						0 {
							set ftyp [FindFileType $fnam]
							if {$ftyp == $evv(SNDFILE)} {
								lappend score_files $fnam
							} else {
								lappend bad_files $fnam
							}
						}
						1 { lappend bad_files $fnam}
						2 { lappend score_files $fnam }
					}
				}
				if [info exists bad_files] {
					if {![info exists score_files]} {
						Inf "None Of These Files Are Soundfiles"
					} else {
						Inf "Some Of These Files Are Not Soundfiles"
					}
				}
				if [info exists score_files] {
					Inf "Soundfiles Are Ready For Insertion On The Sketch Score"
				}
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Search Directories for filename containing given searchstring

proc SearchDirectoriesForFile {inmix dirname str fdir do_sub ext_ok} {
	global pa evv
	
	foreach fnam [glob -nocomplain [file join $dirname *]] {
		if {[file isdirectory $fnam]} {
			if {$do_sub && ![CDP_Restricted_Directory $fnam 1]} {
				set fdir [SearchDirectoriesForFile $inmix $fnam $str $fdir $do_sub $ext_ok]
			}
			continue
		}
		if [IgnoreSoundloomxxxFilenames $fnam] { 
			continue
		}
		switch -- $inmix {
			0 {
				if {[string length $str] <= 0} {
					lappend fdir $fnam
				} else {
					set rfnam [file tail $fnam]
					if {!$ext_ok} {
						set rfnam [file rootname $rfnam]
					}
					if {[string first [string tolower $str] [string tolower $rfnam]] >= 0} {
						lappend fdir $fnam
					}
				}
			}
			1 {
				set ftyp [FindFileType $fnam]
				if {($ftyp < 0) || ![IsAMixfileIncludingMultichan $ftyp]} {
					continue
				}
				if [catch {open $fnam r} zit] {
					continue
				}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					if {[llength $line] <= 0} {
						continue
					}
					set zfnam [lindex $line 0]
					if {[string match $evv(COMMENT)* $zfnam]} {
						continue
					}
					set rfnam [file rootname [file tail $zfnam]]
					if {[string first [string tolower $str] [string tolower $rfnam]] >= 0} {
						lappend fdir $fnam
						break
					}
				}
				catch {close $zit}
			} 
			2 {
				set ftyp [FindFileType $fnam]
				if {[string length $str] <= 0} {
					if {$ftyp != $evv(SNDFILE)} {
						continue
					}
					lappend fdir $fnam
				} else {
					set rfnam [file rootname [file tail $fnam]]
					if {[string first [string tolower $str] [string tolower $rfnam]] >= 0} {
						if {$ftyp != $evv(SNDFILE)} {
							continue
						}
						lappend fdir $fnam
					}
				}
			}
		}
	}
	return $fdir
}

#---- Get name of Directory currently listed on wkspace

proc GetCurDir {} {
	global ww dl hidden_dir fildir compdir1 compdir2

	if {[string length [$ww.1.b.msgx cget -text]] > 0} {
		Inf "NO DIRECTORY LISTED"
		return
	}
	if {![info exists dl]} {
		Inf "No Directory Listed"
		return
	}
	set fnam [$dl get 0]
	if {![info exists fnam] || ([string length $fnam] <= 0)} {
		Inf "No Directory Listed"
		return
	}
	if {[string length $hidden_dir] > 0} {
		return $hidden_dir
	} else {
		set curdir [file dirname $fnam]
		if {[string length $curdir] <= 1} {
			Inf "The Home Directory Is Curently Listed"
			return
		}
	}
	return $curdir
}

#---- Remove any path of Home Directory from filename

proc StripHomeDir {fnam} {
	set pwd [pwd]
	set k [string first [string tolower $pwd] [string tolower $fnam]]
	if {$k >= 0} {
		incr k [string length $pwd]
		incr k
		set fnam [string range $fnam $k end]
	}
	return $fnam
}

#--- Search Directories for filename containing given searchstring

proc SearchWorkspaceForFile {again} {
	global wl pr_wfilfnd wfilstr wfilig total_wksp_cnt wfilrr wfilww evv

	if {$again} {
		if {[info exists wfilstr] && ([string length $wfilstr] > 0)} {
			WkspaceFileSearch $wfilstr
			return
		} elseif {$again == 1} {
			Inf "No Previous Search Made"
			return
		} else {
			set again 0
		}
	} 
	if {!$again} {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set wfilstr [file rootname [file tail [$wl get $i]]]
		}
	}
	set wfilig 1
	set f .wfile_find
	if [Dlg_Create $f "FIND FILE" "set pr_wfilfnd 0" -width 80 -borderwidth $evv(SBDR)] {
		set b1 [frame $f.b1 -borderwidth $evv(SBDR)]
		set b0 [frame $f.b0 -borderwidth $evv(SBDR)]
		set b2 [frame $f.b2 -borderwidth $evv(SBDR)]
		set b3 [frame $f.b3 -borderwidth $evv(SBDR)]
		set b4 [frame $f.b4 -borderwidth $evv(SBDR)]
		button $b1.se -text Search -command {set pr_wfilfnd 1} -highlightbackground [option get . background {}]
		button $b1.cl -text Clear -command  {set wfilstr ""} -highlightbackground [option get . background {}]
		button $b1.dum -text "" -command {} -bd 0 -width 20 -highlightbackground [option get . background {}]
		button $b1.qu -text Close -command {set pr_wfilfnd 0} -highlightbackground [option get . background {}]
		pack $b1.se $b1.cl $b1.dum -side left -pady 2
		pack $b1.qu -side right -pady 1
		label $b0.l -text "STRING TO MATCH"
		pack $b0.l -side top -pady 1
		entry $b0.e -textvariable wfilstr -width 16
		pack $b0.e -side top -pady 1
		checkbutton $b2.ig -variable wfilig -text "Ignore directory pathname"
		pack $b2.ig -side top -pady 2
		checkbutton $b3.rr -variable wfilrr -text "Reverse Search"
		pack $b3.rr -side top -pady 2
		checkbutton $b4.rr -variable wfilww -text "Whole Name Only"
		pack $b4.rr -side top -pady 2
		pack $b1 $b0 $b2 $b3 $b4 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_wfilfnd 1}
		bind $f <Escape> {set pr_wfilfnd 0}
	}
	raise $f
	set wfilrr 0
	set pr_wfilfnd 0
	set finished 0
	My_Grab 0 $f pr_wfilfnd $f.b0.e
	while {!$finished} {
		tkwait variable pr_wfilfnd
		if {$pr_wfilfnd} {
			if {[WkspaceFileSearch $wfilstr]} {
				set finished 1
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Search for a file on the Workspace listing

proc WkspaceFileSearch {str} {
	global wl total_wksp_cnt dl_sstr_zz wfilig wfilrr wfilww

	if {[string length $str] <= 0} {
		Inf "No Search String Entered"
		return 0
	} elseif {[regexp {[^A-Za-z0-9\-\_]+} $str]} {
		Inf "Invalid Characters In Search String '$str'\n\nYou cannot use directory paths or file extensions here."
		return 0
	}
	set str [string tolower $str]
	set dl_sstr_zz $str
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		set start 0
	} else {
		set start [lindex $ilist end]
	}
	if {$wfilrr} {
		incr start -1
		if {$start <= 0} {
			set start [expr $total_wksp_cnt - 1] 
		}
		set revlist [ReverseList [$wl get 0 end]]
		if {$start != 0} {
			set start [expr ($total_wksp_cnt - 1) - $start]
		}
		set i $start
		foreach fnam [lrange $revlist $start end] {
			if {$wfilig} {
				set fnam [file tail $fnam]
			}
			if {$wfilww} {
				if {[string match [string tolower $str] [string tolower [file rootname $fnam]]]} {
					set i [expr ($total_wksp_cnt - 1) - $i]
					$wl selection clear 0 end
					$wl selection set $i
					$wl yview moveto [expr double($i)/double([$wl index end])]
					return 1
				}
			} elseif {[string first [string tolower $str] [string tolower $fnam]] >= 0} {
				set i [expr ($total_wksp_cnt - 1) - $i]
				$wl selection clear 0 end
				$wl selection set $i
				$wl yview moveto [expr double($i)/double([$wl index end])]
				return 1
			}
			incr i
		}
		if {$start != 0} {
			set end $start
			set i 0
			foreach fnam [lrange $revlist 0 $end] {
				if {$wfilig} {
					set fnam [file tail $fnam]
				}
				if {$wfilww} {
					if {[string match [string tolower $str] [string tolower [file rootname $fnam]]]} {
						set i [expr ($total_wksp_cnt - 1) - $i]
						$wl selection clear 0 end
						$wl selection set $i
						$wl yview moveto [expr double($i)/double([$wl index end])]
						return 1
					}
				} elseif {[string first $str [string tolower $fnam]] >= 0} {
					set i [expr ($total_wksp_cnt - 1) - $i]
					$wl selection clear 0 end
					$wl selection set $i
					$wl yview moveto [expr double($i)/double([$wl index end])]
					return 1
				}
				incr i
			}
		}
	} else {
		incr start
		if {$start >=  $total_wksp_cnt} {
			set start 0 
		}
		set i $start
		foreach fnam [$wl get $start end] {
			if {$wfilig} {
				set fnam [file tail $fnam]
			}
			if {$wfilww} {
				if {[string match [string tolower $str] [string tolower [file rootname $fnam]]]} {
					$wl selection clear 0 end
					$wl selection set $i
					$wl yview moveto [expr double($i)/double([$wl index end])]
					return 1
				}
			} elseif {[string first [string tolower $str] [string tolower $fnam]] >= 0} {
				$wl selection clear 0 end
				$wl selection set $i
				$wl yview moveto [expr double($i)/double([$wl index end])]
				return 1
			}
			incr i
		}
		if {$start != 0} {
			set end $start
			set i 0
			foreach fnam [$wl get 0 $end] {
				if {$wfilig} {
					set fnam [file tail $fnam]
				}
				if {$wfilww} {
					if {[string match [string tolower $str] [string tolower [file rootname $fnam]]]} {
						$wl selection clear 0 end
						$wl selection set $i
						$wl yview moveto [expr double($i)/double([$wl index end])]
						return 1
					}
				} elseif {[string first $str [string tolower $fnam]] >= 0} {
					$wl selection clear 0 end
					$wl selection set $i
					$wl yview moveto [expr double($i)/double([$wl index end])]
					return 1
				}
				incr i
			}
		}
	}
	if {$wfilww} {
		Inf "Cannot Find Any File With The Name $str"
	} else {
		Inf "Cannot Find Any File Whose Name Contains The String $str"
	}
	return  0
}

#--- Repeat previous action from  SELECTED Files menu on Wkspace

proc WkspaceAgain {} {
	global selcmd wl

	if {![info exists selcmd]} {
		Inf "No Previous Command Used"
		return
	}
	switch -- $selcmd {
		blshow  { ShowBlistsOfFile $wl }
		chan	{ Show_Props workspace chans }
		dur		{ Show_Props workspace dur }
		durdif	{ Show_Props workspace durdif }
		dursum	{ Show_Props workspace dursum }
		find	{ SearchLogsForFile $wl }
		findbl	{ FileFind_inBLists 0 }
		findm	{ FindWkspaceFileInMixes }
		foot	{ FootOfWkspace }
		somew	{ SomewhereOnWkspace }
		gname	{ GenericRenameWkspaceFiles }
		gsname	{ GenericSubstituteWkspaceFiles }
		nusuf0	{ ReplaceSuffixes 0}
		nusuf1	{ ReplaceSuffixes 1}
		gswap	{ SwapFileNames}
		gswap2	{ SwapChFileNames}
		tswap0	{TransferName 0}
		tswap1	{TransferName 1}
		tswap2	{TransferName 2}
		tswap3	{TransferName 3}
		basename { BaseChosName}
		basenamesuf { BaseChosNamePlusSuffix }
		basnamreind { BaseChosNameReindexed }
		gsnum	{ GenericSubstituteWkspaceNumbers }
		gsnum2	{ AddWkspaceNumbers }
		gsrnum2	{ AddWkspaceNumbersFrom }
		orename	{ OverwriteRename }
		grbnam0 { GrabRename 0}
		grbnam1 { GrabRename 1}
		grbnam2 { GrabRename 2}
		target { TargetTextfile}
		grbtotargt0 { GrabToTarget 0}
		grbtotargt1 { GrabToTarget 1}
		grbtotargt2 { GrabToTarget 2}
		grbtotargt3 { GrabToTarget 3}
		grbtotargt4 { GrabToTarget 4}
		erename0 { RenameExt 0}
		erename1 { RenameExt 1}
		erename2 { RenameExt 2}
		listall { WkToFile all 1 }
		listdir { ListDirOfFile }
		listsim { LoadSimil }
		listdur { WkToFile sndur 1 }
		listmix { WkToFile mix 1 }
		listmmix { WkToFile multimix 1 }
		listsnd { WkToFile snd 1 }
		listsndintxt { WkToFile addtotxt 0 }
		listadd { WkToFile add 1 }
		addtxt  { WkToFile addtxt 1 }
		listadddel { WkToFile adddel 1 }
		listsys { WkToFile sys 1 }
		listtex { WkToFile txt 1 }
		movdir	{ MoveDirMembersToTop }
		move	{ MoveDirectory 0}
		moveremove	{ MoveDirectory 1}
		maxsamp	{ NewGetMaxsamplesOnWkspace}
		name	{ RenameWkspaceFiles }
		pmarkdis { DisplayPmark $wl}
		pname	{ PlayAndRename }
		prop	{ Show_Props workspace 0 }
		recalc	{ GetMaxsamps 0 1 }
		hizero	{ MarkZeroLevelFiles 0}
		hizerof	{ MarkZeroLevelFiles 1}
		refresh	{ RefreshFiles }
		remend	{ RemoveEndChars 0 }
		remstt	{ RemoveEndChars 1 }
		remaft	{ RemoveCharsAfter 0 }
		rembef	{ RemoveCharsAfter 1 }
		repspac	{ ReplaceTheChar space }
		repdots	{ ReplaceTheChar dot }
		prefix	{ Prefix 0 }
		suffix	{ Prefix 1 }
		puffix	{ Prefix 4 }
		prefixdated	{ Prefix 2 }
		suffixdated	{ Prefix 3 }
		remove	{ RemoveFromWkspace wk }
		removex	{ RemoveFromWkspace wkx }
		remdir	{ RemoveFromWkspace dir }
		rev		{ ReverseSelListing }
		samps	{ Show_Props workspace samps }
		selch0	{ ChoseSel 0 }
		selch1	{ ChoseSel 1 }
		selch2	{ ChoseSel 2 }
		src		{ ShowSrcs }
		top		{ TopOfWkspace 0 }
		topsort	{ TopOfWkspace 1 }
		topsort2 { TopOfWkspace 2 }
		topsort3 { TopOfWkspace 3 }
		topsort2r { TopOfWkspace -2 }
		topsort3r { TopOfWkspace -3 }
		toptypsort {TopOfWkspace 4}
		window	{ Show_Props workspace winlen }
		fromtop	{ FromTopOfWkspace }
		slistadd  { AddToSortlist }
		slistsort { ReorderAsSortlist }
		dursort { DurSort wl }
		pitchsort { PitchSort }
		loudsort { LoudSort wl }
		howmany { HowManySel }
		howmanylines { HowManyLines }
		hide	{ HideFromWkspace }
		aplha_part { SortPartListing $wl 0 }
		ahpla_part { SortPastListing $wl 1 }
		lleps_part { SortPartListing $wl 2 }
		default { Inf "Unknown Command" }
	}
}

#--- Repeat previous action from  FILE TYPE menu on Wkspace

proc WkspaceAgain2 {} {
	global selcmd2 wl evv

	if {![info exists selcmd2]} {
		Inf "No Previous Command Used"
		return
	}
	switch -- $selcmd2 {

		addlist { AddToFile }
		chdirlist {ChangeDirInFile}
		playfrlist {PlayAllChosen 1}
		playfrlista {PlayAllChosen 1}
		playfrlistb {PlayAllChosen 2}
		playfrlistd {PlayAllChosen 4}
		compare { CompareTextfiles }
		crebrk  { Create_Brkfile }
		cretxt  { Create_Textfile }
		dedupllist {RemoveDuplsInFile}
		remlist0 {RemoveFrmSndlist 0}
		remlist1 {RemoveFrmSndlist 1}
		duplitxt { DuplicateTextfile }
		duplitxt2 { DuplicateSeveralTextfiles }
		posttxt { PostTextfile 0 }
		postref { PostRefresh }
		postget { PostGet }
		unposttxt { PostTextfile 1 }
		grab	{ GrabFiles 1 0}
		grabh	{ GrabHilite 1}
		grabh2	{ GrabHilite 2}
		sndlsnd	{ RemoveFromWkspace sndlist}
		grabf	{ GrabFiles 0 0}
		grabfsp	{ GrabFiles 0 1}
		grabfh	{ GrabHilite 0}
		grabfd	{ GrabFromDir}
		grabch0	{ GrabChoose 0 }
		grabch1	{ GrabChoose 1 }
		grabch2	{ GrabChoose 2 }
		grabch3	{ GrabChoose 3 }
		grabch4	{ GrabChoose 4 }
		grabch5	{ GrabChoose 5 }
		grabch6	{ GrabChoose 6 }
		mixass	{ Assess_MixSrcs }
		mixend	{ Mix_Endtimes }
		mixsrc	{ Get_MixSrcs }
		mixmain	{ Set_MainMix }
		mixhil	{ Hilite_MixSrcs }
		play	{ PlayOutput 1 }
		playchan { PlayChan }
		playmerge { PlayMerge }
		playnu	{ PlaySndfileNew 0 }
		read	{ Read_Textfile }
		readbrk	{ Read_Brkfile }
		dispbrk	{ GrafDisplayBrkfile 1 0}
		surf	{ PlaySndfileNew 1 }
		sndtomx0 { SndToMix 0 }
		sndtomx1 { SndToMix 1 }
		sndtomx2 { SndToMix 2 }
		sndtomx3 { SndToMix 3 }
		sndtomx4 { SndToMix 4 }
		sndtomx7 { SndToMix 7 }
		sndtomx8 { SndToMix 8 }
		sndtomx10 { SndToMix 10 }
		sndinmix { SndInMix }
		thissndinmix { ThisSndInMix }
		mixactive { MixActiveCnt }
		mixchancnt { MixChanCnt }
		mixadd { MixAdd }
		view	{ ViewOutput }
		vfm { DisplayResonanceWk 0 0 }
		vff { DisplayResonanceWk 1 0 }
		vfm2 { DisplayResonanceWk 0 1 }
		vff2 { DisplayResonanceWk 1 1 }
		fsinslist { FindSndInSndlist }
		fsinslistexist0 { SndsInTextfileExist }
		fsinslistexist1 { SndsInTextfileExist }
		mergetext {MergeTextfiles}
		synmix {CheckTextfileSyntaxForAMix}
		mixbak  {MixBakupTest}
		default { Inf "Unknown Command" }
	}
}

#--- Set up the current Selected-Files menu command as the REPEAT ACTION command at top of menu

proc SetSel {str} {
	global selcmd ww

	set selcmd $str

	switch -- $selcmd {
		blshow	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Show Background Lists With File" }
		chan	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Channel Count(s)" }
		dur		{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Duration(s)" }
		durdif	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Duration Difference" }
		dursum	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Duration Sum" }
		find	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Find File In Logs" }
		findbl	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Find File In B-Lists" }
		findm	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Find File In Mixfiles" }
		foot	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Move Files to Foot of List" }
		somew	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Files To Next Selected Position" }
		gname	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Generically Rename" }
		gsname	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Generically Substitute Names" }
		nusuf0	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Substitute Suffixes" }
		nusuf1	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Transfer Suffixes" }
		gswap	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Swap Two Filenames" }
		gswap2	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Swap Selected Names With Chosenfiles" }
		tswap0	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Transfer Prefix" }
		tswap1	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Transfer Suffix" }
		tswap2	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sndfile Name -> Txtfile" }
		tswap3	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Txtfile Name -> Sndfile" }
		basename { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Base Name On Chosen File" }
		basenamesuf { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "As Chosen File + Suffix" }
		basnamreind { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "As Chosen File: Increment Index" }
		gsnum	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Renumber" }
		gsnum2	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Numbers" }
		gsrnum2	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Numbers From Character N" }
		orename	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Overwrite Chosen File(s)" }
		grbnam0 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Grab Filename: Basic Name Only" }
		grbnam1 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Grab Filename: Basic Name & Extension" }
		grbnam2 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Grab Filename With Path & Extension" }
		target	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Specify Targetfile" }
		grbtotargt0 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Basic Filenames To Targetfile" }
		grbtotargt1 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Filenames+Extensions To Targetfile" }
		grbtotargt2 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Full Filenames To Targetfile" }
		grbtotargt3 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Search Targetfile For Name" }
		grbtotargt4 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Search Targetfile For Directory" }
		erename2 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Change Unknown Extension -> .txt" }
		erename1 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Change Extension -> User Defined" }
		erename0 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Change Extension -> Standard Text" }

		listall { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List All Files In Textfile" }
		listdir { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Directory Of File" }
		listsim { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Load Similar Named Files From Dir" }
		listdur { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Snds ,with Durs, in Textfile" }
		listmix { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Mixfiles In Textfile" }
		listmmix { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Multichan Mixfiles In Textfile" }

		listsnd { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Sndfiles In Textfile" }
		listsndintxt { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Snds (etc) As Comments In Text" }
		listadd { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Sndfiles To List In Textfile" }
		addtxt  { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "ADD TEXTFILE NAME TO LIST IN TEXTFILE" }
		listadddel { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Sndfiles To Textfile & Remove" }
		listsys { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Sndsystem Files In Textfile" }
		listtex { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "List Textfiles In Textfile" }
		movdir  { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Move Files In Directory To Top" }
		move	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Move To New Directory" }
		moveremove	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Move To New Directory & Remove" }
		maxsamp	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Maximum Sample(s)" }
		name	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Simple Rename" }
		pmarkdis { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Show Pitch Mark" }
		pname	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Play & Rename" }
		prop	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Show Properties" }
		recalc	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Recalculate Max Sample(s)" }
		hizero	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Hilight Zero-Level Sounds" }
		hizerof	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Hilight 0-Level Snds (Recalc)" }
		refresh	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Update Data" }
		remend	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Remove End Character(s) From Name" }
		remstt	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Remove Start Character(s) From Name" }
		remaft	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Remove Character(s) After" }
		rembef	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Remove Character(s) Before" }
		repspac	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Replace Spaces" }
		repdots	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Replace Dots" }
		prefix	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Prefix" }
		suffix	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Suffix" }
		puffix	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Pitch Suffix" }
		prefixdated { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Numeric Prefix In Creation Order" }
		suffixdated { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Numeric Suffix In Creation Order" }
		remove	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Clear Backed-up File(s)" }
		removex	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "CLEAR BACKED-UP FILE(S) EXCEPT CHOSEN FILES" }
		remdir	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Clear File(s) In Same Directory" }
		rev		{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Reverse Order Of Files" }
		samps	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sample Count" }
		selch0	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Put Selected Files On Chosen List" }
		selch1	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Selected Files To Chosen List" }
		selch2	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Selectd Files to Chosen (with Duplicates)" }
		src		{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Show Sources of non-sound file(s)" }
		top		{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Move Files to Top of List" }
		topsort	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sort & Move Files to Top of List" }
		topsort2 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sort On Number At End of Name"}
		topsort3 { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sort On Number At Start of Name"}
		topsort2r { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Reverse Sort On Number At End Of Name"}
		topsort3r { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Reverse Sort On Number At Start Of Name"}
		window	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Window Size"}
		fromtop	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Move Top File To After Marked Position" }
		slistadd	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Add Selected File To A Sortlist" }
		slistsort	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Reorder Files As Per Sortlist" }
		dursort	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sort By Duration" }
		pitchsort { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sort Files By Pitch" }
		loudsort { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Sort By Loudness" }
		howmany	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "How Many Selected ?" }
		howmanylines	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "How Many Lines In All Files" }
		hide	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Hide Non-Backed-Up Files" }
		aplha_part	{ $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Alphabetical Order" }
		ahpla_part  { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Reverse Alphabetical Order" }
		lleps_part  { $ww.1.a.endd.l.new.few.menu entryconfig 2 -label "Reverse Spelling Alphabetical" }
	}
	$ww.1.a.endd.l.new.few.menu entryconfig 2 -command WkspaceAgain
}

#--- Set up the current File-Types menu command as the REPEAT ACTION command at top of menu

proc SetSel2 {str} {
	global selcmd2 ww

	set selcmd2 $str

	switch -- $selcmd2 {
		addlist { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Add Further Sounds To Listing" }
		chdirlist { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Change Dir Of Files Listed In Textfile" }
		playfrlist { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play All Files Listed In Sndlist" }
		playfrlista { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play All Snds Selected" }
		playfrlistb { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play All Snds Selected At Timestep" }
		playfrlistd { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play All Snds Individually" }
		compare { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Compare Selected Textfiles" }
		crebrk	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Create Brkpnt File" }
		cretxt	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Create Textfile"}
		dedupllist { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Remove Duplicates In Listing Of Snds"}
		remlist0 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Remove Selected Snds From Sndlist"}
		remlist1 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Retain In Sndlist Only Selected Snds"}
		duplitxt { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Make Duplicate Textfiles"}
		duplitxt2 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Duplicate Several Textfile"}
		posttxt { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Post Display Of Files On Desktop"}
		postref { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Refresh Display Of Files On Desktop"}
		postget { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Get Posted File(s) To Chosen List"}
		unposttxt { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Remove Displayed Textfile From Desktop"}
		grab	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Grab Sounds In Textfile To Workspace"}
		grabh	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Hilight Sounds Listed In Textfile"}
		grabh2	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Snds In Textfile To Top Of Workspace"}
		sndlsnd	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Snds In Textfile Remove From Wkspace"}
		grabf	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Grab Files To Workspace"}
		grabfsp	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Grab Specific Files To Workspace"}
		grabfh	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Hilight Files Listed In Textfile"}
		grabfd	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Find Dirs For Listed Filenames Starting With"}
		grabch0	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Put Sounds In Textfile On Chosen List"}
		grabch1	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Add Sounds In Textfile To Chosen List"}
		grabch2	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Add Snds In Txtfil To Chosen (incl Duplicates)"}
		grabch3	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Next Soundlisting Sound To Chosen List"}
		grabch4	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Next Soundlisting Snd To Chosen & Play"}
		grabch5	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Soundlisting Start Again"}
		grabch6	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Soundlisting Restart From Selected File"}
		mixass	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label  "Which Sounds In  Mix Don't Exist ?" }
		mixend	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label  "Show End Times Of Files In Mix" }
		mixsrc	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label  "Sounds In Selected Mix To Wkspace" }
		mixmain	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label  "Establish As Main Mixfile" }
		mixhil	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label  "Hilight Sounds In Mix Which Are On Wkspace" }
		play	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play Selected File" }
		playchan { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play One Channel Of Sound" }
		playmerge { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Play Merged Channels" }
		playnu	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Permanent Play-display Of File" }
		read	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Read/Edit Selected Textfile" }
		readbrk	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Edit Selected Brkpnt File" }
		dispbrk	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Display Selected Brkpnt File" }
		surf	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Permanent Play-Display With Spectrum" }
		sndtomx0 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Overlay Sndfile(s) In Mixfile At Zero" }
		sndtomx1 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Insert Sndfile(s) At Mixfile Start" }
		sndtomx2 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Add Sndfile(s) (In Sequence) At Mixfile End" }
		sndtomx3 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Add Sndfile(s) (Overlayed) At Mixfile End" }
		sndtomx4 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Replace One Sndfile With Other In Mixfile" }
		sndtomx7 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Add Sndfile(s) To Mixfile At Specified Time" }
		sndtomx8 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Replace All Sndfiles In Mixfile" }
		sndtomx10 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Substitute All (Possibly Duplicated) Snds In Mix" }
		sndinmix { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Is Soundfile In Any Known Mixfile?" }
		thissndinmix { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Is Selected Sound In Selected Mix?" }
		mixactive { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Number Of Active Lines In Mixfile" }
		mixchancnt { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Number Of Mixlines Using N Channels" }
		mixadd { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Merge Two Mixfiles" }
		view	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "View Soundfile In Edit Window" }
		vfm		{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Display Midi Filter-Data Resonance" }
		vff		{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Display Freq Filter-Data Resonance" }
		vfm2	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Compare Midi Filter-Data Resonance" }
		vff2	{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Compare Freq Filter-Data Resonance" }
		fsinslist { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Is Sound In Any Sndlist On Wkspace ?" }
		fsinslistexist0 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Sndlist Sounds Moved Or Deleted ?" }
		fsinslistexist1 { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Mixfile Sounds Moved Or Deleted ?" }
		mergetext		{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Merge Textfiles"}
		synmix		{ $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Is Textfile A \"Bad\" Mixfile ?"}
		mixbak      { $ww.1.a.endd.l.new.cre.menu entryconfig 2 -label "Are All Files In Mixfile Backed-Up ?"}
	}
	$ww.1.a.endd.l.new.cre.menu entryconfig 2 -command WkspaceAgain2
}

#----- Search Logs for File selected on Wkspace

proc SearchLogsForFile {ll} {
	global sl_real 
	if {!$sl_real} {
		Inf "You Can Search All The Logs Of Previous Sessions\nTo Find References To The Selected File"
		return
	}
	set ilist [$ll curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Items Selected"
		return
	} elseif {[llength $ilist] > 1} {
		Inf "Select Just One Item"
		return
	}
	set i [lindex $ilist 0]
	set fnam [$ll get $i]	
	set fnam [string tolower [file tail $fnam]]
	SearchLogs $fnam 0
}

#----- Get previously used directory

proc GetLastDir {} {
	global ww wksp_dirname pr_5 recent_dirs

	if [info exists pr_5] {
		if {![info exists recent_dirs] || ([llength $recent_dirs] <= 1)} {
			Inf "No Previous Directory Listed (other than Home Directory)"
			return
		} 
		set wksp_dirname [lindex $recent_dirs 1]
	} else {
		if {![info exists recent_dirs] || ([llength $recent_dirs] <= 0)} {
			Inf "No Previous Directory Listed (other than Home Directory)"
			return
		} 
		set wksp_dirname [lindex $recent_dirs 0]
	}
	GetFilesToSrcDirListing $ww.1.b.de $ww.1.b
	return
}

#----- Display contents of subdirectory, if item is a subdirectory name.

proc PossiblyGetSubdir {} {
	global dl hidden_dir

	set ilist [$dl curselection]
	if {![info exists ilist] || ([llength $ilist] <=0)} {
		return
	}
	set i [lindex $ilist 0]
	set fnam [$dl get $i]
	if {[string length $hidden_dir] > 0} {
		set fnam [file join $hidden_dir $fnam]
	}
	if [file isdirectory $fnam] {
		set fnam [StripHomeDir $fnam]
		if {[string length $fnam] > 0} {
			LoadSubDirectory $fnam
		} else {
			LoadHomeDirectory
		}
	}
}

#----- Compare contents of 2 directories

proc CompareDirs {andsubdirs} {
	global compdir1 compdir2 pr_compdir evv

	set f .compdir
	if [Dlg_Create $f "COMPARE DIRECTORIES" "set pr_compdir 0" -width 80 -borderwidth $evv(SBDR)] {
		set b0 [frame $f.b0 -borderwidth $evv(SBDR)]
		set b00 [frame $f.b00 -height 1 -bg [option get . foreground {}]]
		set b1 [frame $f.b1 -borderwidth $evv(SBDR)]
		set b2 [frame $f.b2 -borderwidth $evv(SBDR)]
		set b3 [frame $f.b3 -borderwidth $evv(SBDR)]
		set b01 [frame $f.b01 -height 1 -bg [option get . foreground {}]]
		set b4 [frame $f.b4 -borderwidth $evv(SBDR)]
		set b5 [frame $f.b5 -borderwidth $evv(SBDR)]
		set b6 [frame $f.b6 -borderwidth $evv(SBDR)]
		button $b0.ff -text "Compare Dirs" -command {set pr_compdir 1} -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $b0.qu -text "Close" -command {set pr_compdir 0} -highlightbackground [option get . background {}]
		pack $b0.ff -side left
		pack $b0.qu -side right

		label $b1.l -text "1st DIRECTORY TO SEARCH"
		pack $b1.l -side top -pady 1

		entry $b3.e -textvariable compdir1 -width 60
		pack $b3.e -side top -pady 1

		button $b2.fd -text "Find Any Dir" -command {DoListingOfDirectories .compdir.b3.e} -highlightbackground [option get . background {}]
		button $b2.rd -text "Recent Dir" -command {EditRecentDirList 0 compdir1} -highlightbackground [option get . background {}]
		button $b2.cd -text "Current Dir" -command {set compdir1 [GetCurDir]} -highlightbackground [option get . background {}]
		button $b2.hd -text "Home Dir" -command {set compdir1 [string tolower [pwd]]} -highlightbackground [option get . background {}]
		pack $b2.fd $b2.rd $b2.cd $b2.hd -side left -padx 5 -expand true -fill x

		label $b4.l -text "2nd DIRECTORY TO SEARCH"
		pack $b4.l -side top -pady 1

		entry $b6.e -textvariable compdir2 -width 60
		pack $b6.e -side top -pady 1

		button $b5.fd -text "Find Any Dir" -command {DoListingOfDirectories .compdir.b6.e} -highlightbackground [option get . background {}]
		button $b5.rd -text " Recent  Dir" -command {EditRecentDirList 0 compdir2} -highlightbackground [option get . background {}]
		button $b5.cd -text "Current Dir" -command {set compdir2 [GetCurDir]} -highlightbackground [option get . background {}]
		button $b5.hd -text "Home Dir" -command {set compdir2 [string tolower [pwd]]} -highlightbackground [option get . background {}]
		pack $b5.fd $b5.rd $b5.cd $b5.hd -side left -padx 5 -expand true -fill x

		pack $b0 -side top -fill x -expand true
		pack $b00 -side top -fill x -expand true -pady 2
		pack $b1 $b2 $b3 -side top -fill x -expand true -anchor center
		pack $b01 -side top -fill x -expand true -pady 2
		pack $b4 $b5 $b6 -side top -fill x -expand true
		bind .compdir.b3.e <Up> "focus .compdir.b6.e"
		bind .compdir.b3.e <Down> "focus .compdir.b6.e"
		bind .compdir.b6.e <Up> "focus .compdir.b3.e"
		bind .compdir.b6.e <Down> "focus .compdir.b3.e"
		wm resizable $f 1 1
		bind $f <Return> {set pr_compdir 1}
		bind $f <Escape> {set pr_compdir 0}
	}
	raise $f
	set pr_compdir 0
	set finished 0
	My_Grab 0 $f pr_compdir $f.b3.e
	while {!$finished} {
		tkwait variable pr_compdir
		if {$pr_compdir} {
			if {[string length $compdir1] <= 0} {
				Inf "No Name Entered For First Directory"
				continue
			}
			set dirname [CheckDirectoryName $compdir1 "DIRECTORY NAME" 1 1]
			if {[string length $dirname] <= 0} {
	 			continue
			}
			if {![file isdirectory $compdir1]} {
				Inf "Directory '$dirname' Does Not Exist"
				continue
			}
			set compdir1 $dirname

			if {[string length $compdir2] <= 0} {
				Inf "No Name Entered For Second Directory"
				continue
			}
			set dirname [CheckDirectoryName $compdir2 "DIRECTORY NAME" 1 1]
			if {[string length $dirname] <= 0} {
	 			continue
			}
			if {![file isdirectory $compdir2]} {
				Inf "Directory '$dirname' Does Not Exist"
				continue
			}
			set compdir2 $dirname
			catch {unset flist1}
			catch {unset flist2}
			set cnt1 0
			foreach fnam [glob -nocomplain [file join $compdir1 *]] {
				if {$andsubdirs} {
					lappend flist1 [file tail $fnam]
					incr cnt1
				} elseif {![file isdirectory $fnam]} {
					lappend flist1 [file tail $fnam]
					incr cnt1
				}
			}
			set cnt2 0
			foreach fnam [glob -nocomplain [file join $compdir2 *]] {
				if {$andsubdirs} {
					lappend flist2 [file tail $fnam]
					incr cnt2
				} elseif {![file isdirectory $fnam]} {
					lappend flist2 [file tail $fnam]
					incr cnt2
				}
			}
			set n 0 
			while {$n < $cnt1} {
				set fnam1 [lindex $flist1 $n]
				set k [lsearch -exact $flist2 $fnam1]
				if {$k >= 0} {
					set flist2 [lreplace $flist2 $k $k]
					set flist1 [lreplace $flist1 $n $n]
					incr cnt1 -1
					incr n -1
				}
				incr n
			}
			set msg ""
			if {[llength $flist1] > 20} {
				if {$andsubdirs} {
					append msg "More Than 20 File (Or Subdirectory) Names Only Occur In Directory '$compdir1'\n\n"
				} else {
					append msg "More Than 20 File Names Only Occur In Directory '$compdir1'\n\n"
				}
			} elseif {[llength $flist1] > 0} {
				if {$andsubdirs} {
					append msg "The Following File (Or Subdirectory) Names Only Occur In Directory '$compdir1'\n\n"
				} else {
					append msg "The Following File Names Only Occur In Directory '$compdir1'\n\n"
				}
				foreach fnam $flist1 {
					append msg "$fnam     "
				}
			}
			if {[llength $flist2] > 20} {
				if {[string length $msg] > 0} {
					append msg "\n\n"
				}
				if {$andsubdirs} {
					append msg "More Than 20 File (Or Subdirectory) Names Only Occur In Directory '$compdir1'\n\n"
				} else {
					append msg "More Than 20 File Names Only Occur In Directory '$compdir1'\n\n"
				}
			} elseif {[llength $flist2] > 0} {
				if {[string length $msg] > 0} {
					append msg "\n\n"
				}
				if {$andsubdirs} {
					append msg "The Following File (Or Subdirectory) Names Only Occur In Directory '$compdir2'\n\n"
				} else {
					append msg "The Following File Names Only Occur In Directory '$compdir2'\n\n"
				}
				foreach fnam $flist2 {
					append msg "$fnam     "
				}
			}
			if {[string length $msg] <= 0} {
				if {$andsubdirs} {
					Inf "The Directories Contain The Same Filenames And Subdirectory Names"
				} else {
					Inf "The Directories Contain The Same Filenames"
				}
			} else {
				Inf "$msg"
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Set criterion for deletability of files, and choose files.

proc WhichFilesToDelete {ilist type} {
	global wl pa pr_delwhich del_limit sampsize_convertor wstk home_only evv

	if {$type < 0} {	;#	CALL FROM ALL FILES MENU -- SELECTION LIST IGNORED
		set i 0
		foreach fnam [$wl get 0 end] {
			lappend nuilist $i
			incr i
		}
		if {![info exists nuilist]} {
			Inf "There Are No Files On The Workspace"
			return {}
		}
		set ilist $nuilist
		set type [expr int(abs($type))]
	}

	set f .delwhich
	if [Dlg_Create $f "MINIMUM LENGTH" "set pr_delwhich 0" -width 80 -borderwidth $evv(SBDR)] {
		set b0 [frame $f.b0 -borderwidth $evv(SBDR)]
		set b1 [frame $f.b1 -borderwidth $evv(SBDR)]
		button $b0.ff -text "Delete" -command {set pr_delwhich 1} -highlightbackground [option get . background {}]
		button $b0.qu -text "Close" -command {set pr_delwhich 0} -highlightbackground [option get . background {}]
		pack $b0.ff -side left
		pack $b0.qu -side right

		label $b1.l -text "MINIMUM ACCEPTABLE LENGTH (seconds)" -width 40
		entry $b1.e -textvariable del_limit -width 60
		checkbutton $b1.r -variable home_only -text "DO NOT DELETE ANY BACKED-UP FILES"
		pack $b1.l $b1.e $b1.r -side top -pady 2

		pack $b0 -side top -fill x -expand true
		pack $b1 -fill x -expand true -anchor center
		wm resizable $f 1 1
		bind $f <Return> {set pr_delwhich 1}
		bind $f <Escape> {set pr_delwhich 0}
	}
	set home_only 1
	switch -- $type {
		1 { 
			wm title $f "MINIMUM LENGTH"
			$f.b1.l config -text "MINIMUM ACCEPTABLE LENGTH (secs)" 
		}
		2 { 
			wm title $f "MINIMUM LEVEL"
			$f.b1.l config -text "MINIMUM ACCEPTABLE LEVEL (0.0 to 1.0)" 
		}
	}
	raise $f
	set nuilist {}
	set pr_delwhich 0
	set finished 0
	My_Grab 0 $f pr_delwhich $f.b1.e
	while {!$finished} {
		tkwait variable pr_delwhich
		set nuilist {} 
		if {$pr_delwhich} {
			if {[string length $del_limit] <= 0} {
				Inf "No Limit Value Entered"
				continue
			} 
			if {![IsPositiveNumber $del_limit]} {
				Inf "Invalid Value Entered"
				continue
			} 
			switch -- $type {
				1 {							;#	MINIMUM DURATION
					foreach i $ilist {
						set fnam [$wl get $i]
						if {$home_only && (![string match $fnam [file tail $fnam]])} {
							continue
						}
						if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
							if {$pa($fnam,$evv(DUR)) < $del_limit} {
								lappend nuilist $i
							}
						}
					}
				}
				2 {							;#	MINIMUM LEVEL

					if {$del_limit > 1.0 || $del_limit < 0.0} {
						Inf "Invalid Value Entered (Range 0 - 1)"
						continue
					} 
					Block "Checking File Levels"
					foreach i $ilist {
						set fnam [$wl get $i]
						if {$home_only && (![string match $fnam [file tail $fnam]])} {
							continue
						}
						if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
							wm title .blocker "PLEASE WAIT:        CHECKING LEVEL FILE [file rootname [file tail $fnam]]"
							if {[IndependentMaxsample $fnam]} {
								if {([string first "#INF" $pa($fnam,$evv(MAXSAMP))] >= 0) || ([expr abs($pa($fnam,$evv(MAXSAMP)))] < $del_limit)} {
									lappend nuilist $i
								}
							}
						}
					}
					UnBlock
				}
			}
			if {[llength $nuilist] <= 0} {
				Inf "No Files Meet This Criterion"
				continue
			}
			set msg "The Files\n\n"
			foreach i $nuilist {
				append msg "[$wl get $i]    "
			}
			append msg "\n\nWould Be Deleted: OK?"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				continue
			}
			set finished 1
		} else {
			set finished 1
		}
	}	
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return $nuilist 
}

#------ Switch On/Off New User Help

proc SetNewUserHelp {} {
	global do_starthlp pr_nuh evv

	set f .testflags3
	if [Dlg_Create  $f "" "set pr_nuh 0" -borderwidth $evv(SBDR)] {
		button $f.ok -text "OK" -command "set pr_nuh 0" -highlightbackground [option get . background {}]
		frame $f.f0 -bg [option get . foreground {}] -height 1
		label $f.la -text "FOR NEXT SESSION"
		frame $f.f1 -bg [option get . foreground {}] -height 1
		checkbutton $f.starthlp  -variable do_starthlp -text "NEW USER HELP ?" -command ExplanNewUserHelp
		pack $f.ok -side top -pady 2
		pack $f.f0 -side top -fill x -expand true -pady 2
		pack $f.la -side top -pady 4
		pack $f.f1 -side top -fill x -expand true -pady 2
		pack $f.starthlp -side top -pady 1
		wm resizable .testflags3 1 1
		bind $f <Return> {set pr_nuh 0}
		bind $f <Escape> {set pr_nuh 0}
		bind $f <Key-space> {set pr_nuh 0}
	}
	raise $f
	set pr_nuh 0
	My_Grab 0 $f pr_nuh
	tkwait variable pr_nuh
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Switch On/Off Interface Redesign

proc SetRedesign {} {
	global do_redesign pr_redesign wstk colorable evv

	set msg ""
	if {!$colorable} {
		append msg "At Present, Colour-Coding Of Buttons And Menus Does Not Function On The MAC.\n"
		append msg "Changing Button Colours Will Therefore Have No Effect.\n\n"
	}
	append msg "Choosing a larger font may truncate some button-texts, making them puzzling to read.\n\n"
	append msg "Do you still want to Redesign ?\n\n"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		return
	}
	set f .testflags4
	if [Dlg_Create  $f "" "set pr_redesign 0" -borderwidth $evv(SBDR)] {
		button $f.ok -text "OK" -command "set pr_redesign 0" -highlightbackground [option get . background {}]
		frame $f.f0 -bg [option get . foreground {}] -height 1
		label $f.la -text "FOR NEXT SESSION"
		frame $f.f1 -bg [option get . foreground {}] -height 1
		checkbutton $f.starthlp  -variable do_redesign -text "REDESIGN INTERFACE ?"
		pack $f.ok -side top -pady 2
		pack $f.f0 -side top -fill x -expand true -pady 2
		pack $f.la -side top -pady 4
		pack $f.f1 -side top -fill x -expand true -pady 2
		pack $f.starthlp -side top -pady 1
		wm resizable .testflags4 1 1
		bind $f <Return> {set pr_redesign 0}
		bind $f <Escape> {set pr_redesign 0}
		bind $f <Key-space> {set pr_redesign 0}
	}
	raise $f
	set pr_redesign 0
	My_Grab 0 $f pr_redesign
	tkwait variable pr_redesign
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Reverse Order of list

proc ReverseList {llist} {

	if {![info exists llist]} {
		return {}
	}
	set len [llength $llist]
	switch -- $len {
		0 { set nullist {}		}
		1 { set nullist $llist	}
		default {
			set n [expr $len - 1]
			while {$n >= 0} {
				lappend nullist [lindex $llist $n]
				incr n -1
			}
		}
	}
	return $nullist
}

#----- Dilaog to set up Search Directory Listing

proc SearchDirectoryListing {} {
	global dl dir_src pr_dirsrch sl_real dirsch_wh evv

	if {!$sl_real} {
		Inf "Specify A Search-string\nAnd Use It To Find A File\nIn The Directory Listing"
		return
	}
	if {![info exists dl]} {
		Inf "No Files Listed"
		return
	}
	set len 0
	foreach item [$dl get 0 end] {
		incr len
	}
	if {$len == 0} {
		Inf "No Files Listed"
		return
	}
	set f .dirsrch
	if [Dlg_Create  $f "SEARCH FOR FILE" "set pr_dirsrch 0" -borderwidth $evv(SBDR)] {
		set f1 [frame $f.1 -bd $evv(SBDR)]
		set f2 [frame $f.2 -bd $evv(SBDR)]
		button $f1.qu -text "Close" -command {set pr_dirsrch 0}  -width 3 -highlightbackground [option get . background {}]
		button $f1.ok -text "OK" -command {set pr_dirsrch 1}  -width 3 -highlightbackground [option get . background {}]
		checkbutton $f1.whole -text "Complete Name Only" -variable dirsch_wh
		label $f2.sr -text "Search for" 
		entry $f2.ee -textvariable dir_src -width 20
		pack $f1.ok $f1.whole -side left -pady 2
		pack $f1.qu -side right -pady 2
		pack $f2.sr $f2.ee  -side left -fill x -expand true -pady 2
		pack $f1 $f2 -side top -fill x -expand true
		wm resizable .dirsrch 1 1
		bind $f <Return> {set pr_dirsrch 1}
		bind $f <Escape> {set pr_dirsrch 0}
	}
	set dir_srch ""
	raise $f
	set pr_dirsrch 0
	set finished 0
	My_Grab 0 $f pr_dirsrch $f.2.ee
	while {!$finished} {
		tkwait variable pr_dirsrch
		if {$pr_dirsrch} {
			if {[string length $dir_src] <= 0} {
				Inf "No Search String Given"
				continue
			}
			if [regexp {[^A-Za-z0-9\-_]} $dir_src] {
				Inf "Invalid Characters In Search String"
				continue
			}
			if {[SearchDirList $dir_src $len]}  {
				set finished 1
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Search the Directory Listing

proc SearchDirList {str len} {
	global dl last_dir_src dir_src lastdirstart dirsch_wh evv

	$dl selection clear 0 end
	if {[info exists last_dir_src] && [string match $last_dir_src $str]} {
		set i $lastdirstart
		set gotit 0
		foreach item [$dl get $lastdirstart end] {
			set item [file rootname [file tail $item]]
			if {$dirsch_wh} {
				if {[string match $str $item]} {
					set gotit 1
				}
			} else {
				if {[string first $str $item] >= 0} {
					set gotit 1
				}
			}
			if {$gotit} {
				$dl selection set $i
				$dl yview moveto [expr double($i)/double($len)]
				incr i
				if {$i >= $len} {
					set i 0
				}
				set lastdirstart $i	
				set last_dir_src $str
				return 1
			}
			incr i
		}
	} else {
		set lastdirstart "end"
	}
	set i 0
	set gotit 0
	foreach item [$dl get 0 $lastdirstart] {
		set item [file rootname [file tail $item]]
		if {$dirsch_wh} {
			if {[string match $str $item]} {
				set gotit 1
			}
		} else {
			if {[string first $str $item] >= 0} {
				set gotit 1
			}
		}
		if {$gotit} {
			$dl selection set $i
			$dl yview moveto [expr double($i)/double($len)]
			incr i
			if {$i >= $len} {
				set i 0
			}		
			set lastdirstart $i
			set last_dir_src $str
			return 1
		}
		incr i
	}
	catch {unset last_dir_src}
	catch {unset lastdirstart}
	Inf "No Match Found"
	return 0
}

#---- Search mixfiles on your system ,for a particular file 

proc FindWkspaceFileInMixes {} {
	global wl filstr sl_real

	if {!$sl_real} {
		Inf "You Can Search All The Mixfiles On Your System\nTo See If Any Of Them Use The Selected File."
		return
	}

	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No File Selected"
		return
	}
	if {[llength $ilist] > 1} {
		Inf "Select A Single File"
		return
	}
	set filstr [file rootname [file tail [$wl get [lindex $ilist 0]]]]
	FileFind 1 0 0
}

#------ Sort listing (e.g. workspace) into alphabetical order
	
proc ReverseSelListing {} {
	global wl tosomewhere

	catch {unset tosomewhere}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Files Selected"
		return
	}
	if {[llength $ilist] == 1} {
		Inf "Only One File Selected"
		return
	}
	foreach i $ilist {
		lappend selfnam [$wl get $i]
	}
	foreach i [lsort -integer -decreasing $ilist] fnam $selfnam {
		$wl delete $i
		$wl insert $i $fnam
	}
	foreach i $ilist {
		$wl selection set $i
	}
}

#----- Asess files in mixfile : do any NOT exist

proc Assess_MixSrcs {} {
	global wl pa evv sl_real wstk
	if {!$sl_real} {
		Inf "If You Have Highlighted A Mixfile On The Workspace Window,\nYou Can Check Whether All The Soundfiles It Uses\nStill Exist."
		return
	}
	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[info exists pa($fnam,$evv(FTYP))]} {
			set ftyp $pa($fnam,$evv(FTYP))
			if {[IsAMixfileIncludingMultichan $ftyp]} {
				set mfile $fnam
				if {$ftyp == $evv(MIX_MULTI)} {
					set gotchans 0
				} else {
					set gotchans 1
				}
				break
			}
		}
	}
	if {![info exists mfile]} {
		Inf "No Mixfile Has Been Selected"
		return
	}
	if [catch {open $mfile "r"} Ifd] {
		Inf "Cannot Open File '$mfile'"
		return
	}
	set files_grabbed 0
	set active_lines 0
	while {[gets $Ifd line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if [string match [string index $line 0] ";"] {
			lappend nulines $line
			continue
		}
		if {!$gotchans} {
			lappend nulines $line
			set gotchans 1
			continue
		}
		set line [split $line]
		foreach item $line {
			if {[string length $item] > 0} {
				set item [RegulariseDirectoryRepresentation $item]
				if {![file exists $item]} {
					lappend badfiles $item
				} else {
					catch {unset nuline}
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] > 0} {
							lappend nuline $item
						}
					}
					if {[info exists nuline]} {
						lappend nulines $nuline
						incr active_lines
					}
				}
				break
			}
		}
	}
	catch {close $Ifd}
	if {[info exists badfiles]} {
		set msg "The Following Files No Longer Exist\n\n"
		set i 0
		foreach fnam $badfiles {
			append msg "$fnam  "
			incr i
			if {$i > 20} {
				break
			}
		}
		if {$i > 20} {
			append msg " And Others"
		}
		Inf $msg
		if {$active_lines > 0} {
			set msg "Do You Wish To Remove The Non-Existent Files ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				set tempfnam $evv(DFLT_OUTNAME)
				append tempfnam 0 $evv(TEXT_EXT)
				if [catch {open $tempfnam "w"} zit] {
					Inf "Cannot Open Temporary File To Write Edited Mix Data"
					return
				}
				foreach line $nulines {
					puts $zit $line
				}
				close $zit
				if [catch {file delete $mfile} zit] {
					Inf "Cannot Delete Original Mixfile"
				} elseif [catch {file rename $tempfnam $mfile} zit] {
					Inf "Cannot Create New Mixfile: Original Mixfile Lost"
				}
			}
		} else {
			set msg "Delete The Mixfile ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				if {[AreYouSure]} {
					if {[DeleteFileFromSystem $mfile 0 1]} {
						MixMDelete $mfile 1
						set i [LstIndx $mfile $wl]
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
						}
					}
				}
			}
		}
		return
	}
	Inf "All Soundfiles In '$mfile' Are Valid"
}

#--- List directory with NO subdirs listed

proc NoSubdirNames {} {
	global dl wksp_dirname active_dir previous_dirlisting previous_active_dir ww evv is_subdirlist

	if {[info exists active_dir] && [info exists previous_active_dir]} {
		set xx $previous_active_dir
		set yy $previous_dirlisting
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	set notsubdir_list {}
	set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
	if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
		if {[info exists xx]} {
			set previous_active_dir $xx
			set previous_dirlisting $yy
		}
	 	return
	}
	catch {unset is_subdirlist}
	set dirlen [string length $dirname]
	set pwd [string tolower [pwd]]
	set pwdlen [string length $pwd]
	if [string match $pwd* $dirname] {
		if {$pwdlen == $dirlen} {
			set dirname ""
		} else {
			incr pwdlen
			set dirname [string range $dirname $pwdlen end]
		}
	}
	set active_dir $dirname
	Block "Listing without Subdirectories"
	foreach fnam [lsort -dictionary [glob -nocomplain [file join $dirname *]]] {
		if {![file isdirectory $fnam]} {
			if {[string length $fnam] <= 0} {
				continue
			} else {
				set fnam [string tolower $fnam]
				if {[IsListableFile $fnam]} {
					lappend notsubdir_list $fnam
				}
			}
		}
	}
	UnBlock
	if {[llength $notsubdir_list] <= 0} {
		Inf "There Are No Files In This Directory"
		if {[info exists xx]} {
			set previous_active_dir $xx
			set previous_dirlisting $yy
		}
		return
	}
	$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
	$dl delete 0 end
	foreach item $notsubdir_list {
		$dl insert end $item
	}
	$dl xview moveto 0.0
}

#----- List DIrectory of Wkspace Selected File

proc ListDirOfFile {} {
	global wl wksp_dirname sl_real dl

	if {!$sl_real} {
		Inf "Get The Directory Of The Selected File\nAnd List Its Contents\nIn The Directory Display Window"
		return
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No File Selected"
		return
	}
	foreach i $ilist {
		if {![info exists thedir]} {
			set thedir [file dirname [$wl get $i]]
			if {[string length $thedir] <= 1} {
				unset thedir
			}
		} elseif {![string match $thedir [file dirname [$wl get $i]]]} {
			Inf "Files From More Than One Directory Have Been Selected"
			return
		}
	}
	if {![info exists thedir]} {
		Inf "Only Home Directory Files Have Been Selected"
		return
	}
	set wksp_dirname $thedir
	LoadDir
	$dl selection clear 0 end
	foreach i $ilist {
		set k [LstIndx [$wl get $i] $dl]
		if {$k >= 0} {
			$dl selection set $k
		}
	}
}

#--- Play or Read a sound on Double-Click

proc PossiblyPlaySnd {ll y} {
	global dl pa evv dl hidden_dir propfiles_list directtoview

	set is_hidden_dir 0
	set i [$ll nearest $y]								;#	Get list-index nearest to mouse-cursor
	if {$i < 0} {
		return
	}
	if {[string match $dl $ll] & ([string length $hidden_dir] > 0)} {
		set is_hidden_dir 1
	}
	set fnam [$ll get $i]								;#	Get filename at that index
	if {$is_hidden_dir} {
		set fnam [file join $hidden_dir $fnam]
	}
	if {[file isdirectory $fnam]} {
		Inf "'$fnam' Is A Directory"
		return
	}
	set ftyp [FindFileType $fnam]	
	if {$ftyp < 0} {
		return
	}
	switch -regexp -- $ftyp \
		^$evv(SNDFILE)$		 {
			if {[info exists directtoview] && [info exists pa($fnam,$evv(CHANS))]} {
				if {$pa($fnam,$evv(CHANS)) <= 2} {
					if {$pa($fnam,$evv(DUR)) * $pa($fnam,$evv(CHANS)) > 300} {
						Block "Creating Waveform Display"
					}
					SnackDisplay 0 $evv(SN_FILE_PRMPAGE_NO_OUTPUT) 0 $fnam
					if {[winfo exists .blocker]} {
						UnBlock
					}
				} else {
					PlaySndfile $fnam 0
				}
			} else {
				PlaySndfile $fnam 0
			}
		} \
		^$evv(ANALFILE)$	 {PlaySndfile $fnam 1} \
		^$evv(PSEUDO_SND)$	 {Inf "PSEUDO-SOUNDFILE: FOR VIEWING ONLY"} \
		^$evv(PITCHFILE)$	 {Inf "BINARY PITCH DATA"} \
		^$evv(TRANSPOSFILE)$ {Inf "BINARY TRANSPOSITION DATA"} \
		^$evv(FORMANTFILE)$	 {Inf "BINARY FORMANT DATA"} \
		^$evv(ENVFILE)$		 {Inf "BINARY ENVELOPE DATA"} \
		default {
			if {$ftyp & $evv(IS_A_TEXTFILE)} {
				if {[info exists propfiles_list] && ([lsearch $propfiles_list $fnam] >= 0)} {
					TabProps 0
					return
				}
				SimpleDisplayTextfile $fnam
			} 
		}
}

#------ Move files in same directory as selected file, to top of workspace listing

proc MoveDirMembersToTop {} {
	global wl tosomewhere

	catch {unset tosomewhere}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Item Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		set zzz [file dirname $fnam]
		if {[info exists thisdir]} {
			if {![string match $zzz $thisdir]} {
				Inf "Files Selected From More Than One Directory"
				return
			}
		} else {
			set thisdir $zzz
		}
	}
	foreach fnam [$wl get 0 end] {
		set zzz [file dirname $fnam]
		if {[string match $zzz $thisdir]} {
			lappend ll $fnam
		} else {
			lappend ll2 $fnam
		}
	}
	$wl delete 0 end
	if [info exists ll] {
		foreach fnam $ll {
			$wl insert end $fnam
		}
	}
	if [info exists ll2] {
		foreach fnam $ll2 {
			$wl insert end $fnam
		}
	}
}

#--- Find type of file (even if not already on workspace)

proc FindFileType {fnam} {
	global pa do_parse_report evv

	if [info exists pa($fnam,$evv(FTYP))] {
		return $pa($fnam,$evv(FTYP))
	}
	if [info exists do_parse_report] {
		set report_preexists 1
		set orig_report $do_parse_report
	}
	set do_parse_report 0
	set test [DoMinParse $fnam]
	if [info exists report_preexists] {
		set do_parse_report $orig_report
	}
	if {$test <= 0} {
		return -1
	}
	set ftyp $pa($fnam,$evv(FTYP))
	unset pa($fnam,$evv(FTYP))
	return $ftyp
}

#--- Load Directory, includeing activating DIrectory Listing, if not already done

proc LoadDir {} {
	global pr_5 small_screen ww dl wksp_dirname hidden_dir
	if {![info exists pr_5]} {
		if {![info exists ww]} {
			if {$small_screen} {
				set ww .workspace.c.f
			} else {
				set ww .workspace
			}	
		}
		GetFilesToSrcDirListing $ww.1.b.de $ww.1.b
	} else {
		Block "Listing Directory"
		$dl delete 0 end
		foreach fnam [lsort -dictionary [glob -nocomplain [file join $wksp_dirname *]]] {
			if [IsListableFile $fnam] {
				set fnam [string tolower $fnam]
				$dl insert end $fnam
			}
		}
		$dl xview moveto 0.0
		UpdateRecentDirs $wksp_dirname
		set hidden_dir ""
		UnBlock
	}
}

#--- Clear SoundLoom of all refs to a deleted file

proc RemoveAllRefsToFile {fnam i} {
	global wl pa background_listing evv
	$wl delete $i
	catch {unset rememd}
	WkspCnt $fnam -1
	RemoveFromChosenlist $fnam
	RemoveFromDirlist $fnam
	DeleteFileFromSrcLists $fnam
	if {[IsInBlists $fnam] && [RemoveFromBLists $fnam]} {
		SaveBL $background_listing
	}
	if [info exists pa($fnam,$evv(FTYP))] {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			if [HasPmark $fnam] {
				DelPmark $fnam
			}
			if [HasMmark $fnam] {
				DelMmark $fnam
			}
		}
		PurgeArray $fnam
	}
}

proc DurConv {} {
	global fprops_display

	set ishrs 0
	if {[string match "Hrs:Mins:Secs" [.fileprops_page.buttons.tref cget -text]]} {
		set ishrs 1
	}
	foreach line [$fprops_display get 0 end] {
		set line [split $line]
		catch {unset nuline}
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] > 0} {
				lappend nuline $item
			}
		}
		if {[info exists nuline]} {
			if {[llength $nuline] != 2} {
				Inf "Data Anomaly in Durations Listing"
				return
			}
			catch {unset nutime}
			if {$ishrs} {
				if {[IsNumeric [lindex $nuline 0]]} {
					set nutime [ConvDurToHrs [lindex $nuline 0]]
				}
			} else {
				if {[regexp "secs" [lindex $nuline 0]]} {
					set nutime [ConvDurToSecs [lindex $nuline 0]]
				}
			}
			if [info exists nutime] {
				set nuline [lreplace $nuline 0 0 $nutime]
				lappend nulines $nuline
			} else {
				lappend nulines $nuline
			}
		}
	}
	$fprops_display delete 0 end
	foreach nuline $nulines {
		set outline [lindex $nuline 0]
		append outline "     "
		append outline [lindex $nuline 1]
		$fprops_display insert end $outline
	}
	if {$ishrs} {
		.fileprops_page.buttons.tref config -text "Seconds"
	} else {
		.fileprops_page.buttons.tref config -text "Hrs:Mins:Secs"
	}
}

proc ConvDurToHrs {secs} {

	set hrs [expr int(floor($secs / 3600.0))]
	set secs [expr $secs - ($hrs * 3600.0)]
	set mins [expr int(floor($secs / 60.0))]
	set secs [expr $secs - ($mins * 60.0)]
	set outval ""
	if {$hrs > 0} {
		append outval $hrs
		append outval "hrs::"
		append outval $mins
		append outval "mins::"
		append outval $secs
		append outval "secs"
	} elseif {$mins > 0} {
		append outval $mins
		append outval "mins::"
		append outval $secs
		append outval "secs"
	} else {
		append outval $secs
		append outval "secs"
	}
	return $outval
}

proc ConvDurToSecs {hrstring} {

	set sum 0.0
	set k [string first "hrs::" $hrstring]
	if {$k >= 0} {
		incr k -1
		set hrs [string range $hrstring 0 $k]
		incr k 6
		set hrstring [string range $hrstring $k end]
		set sum [expr $hrs * 3600.0]
	}
	set k [string first "mins::" $hrstring]
	if {$k >= 0} {
		incr k -1
		set mins [string range $hrstring 0 $k]
		incr k 7
		set hrstring [string range $hrstring $k end]
		set sum [expr $sum + ($mins * 60.0)]
	}
	set k [string first "secs" $hrstring]
	incr k -1
	set secs [string range $hrstring 0 $k]
	set secs [expr $secs + $sum]
	return $secs
}

proc TellSystemSettings {} {
	Inf "from This Submenu You Can\n\n1) See The Type And State Of Your System.\n2) Reset The Configuration Of Your CDP System.\n3) Set Up Various System Test-States."
	return
}

proc TellSessionLogs {} {
	Inf "From This Submenu You Can\n\n1) Search Logs Of Past Sessions For A Particular File Or Parameter Value.\n2) Edit The List Of Logs.\n3) Sort Or Remove Logs."
	return
}

proc TellSavedWkspace {} {
	Inf "From This Submenu You Can Sort Or Remove Stored Listings Of Previous States Of The Workspace."
	return
}

proc TellBlists {} {
	Inf "You Can See, Edit, Rename Or Delete B-Lists\nAnd Play Sounds Held In B-Lists."	
	return
}

proc TellPropFiles {} {
	Inf "Lists Sounds In A Textfile Together With Properties Of Your Own Choosing, Organise And Select Sounds Using Those Properties."	
	return
}

proc TellPitchmarks {} {
	set msg "Sounds May Be Assigned Pitchmarks (Indicating Their Pitch Or Pitches)\n\n"	
	append msg "and sorted, compared, assembled, on this basis.\n"	
	append msg "The notes in a pitchmark are NOT time-ordered (unlike those in Pitch Sequence Markers).\n"	
	append msg "The pitch data might be used to describe the harmonic field of a sound.\n"
	Inf $msg	
	return
}

proc TellPartition {} {
	Inf "Sounds May Be Played And Assigned To Different Lists."	
	return
}

proc TellSketchScore {} {
	Inf "Transfer Soundfiles To A Page Where Sound Ordering Can Be Tested And Shuffled Simply By Dragging Soundfile Names."	
	return
}

proc TellInterp {} {
	Inf "Making Sounds Which Interpolate Between Two Input Sounds: Hear, Modify And Change The Sequence Of Intervening Sounds Generated."	
	return
}

proc TellNameGames {} {
	set msg    "File Names May Contain Segments Which Can Be Sorted On\n"	
	append msg "Or Moved Around, In Various Ways.\n"	
	append msg "Two Segments In A Name Must Be Separated\n"
	append msg "By A Single Underscore.\n"
	append msg "\n"
	append msg "Underscores May Not Occur\n"
	append msg "At The Start Or End Of Such Names.\n"
	append msg "\n"
	append msg "Two Or More Adjacent Underscores\n"
	append msg "Also Prevent Name-games From Working.\n"
	append msg "\n"
    append msg "As CDP Filenames Can Only Contain\n"
    append msg "Alphabetic And Numeric Characters,\n"
    append msg "There Is A Special Representation For Numbers\n"
    append msg "In Filename Segments.\n"
    append msg "the Decimal Point Is Replaced By A Hyphen,\n"
    append msg "but An Initial Hyphen Is Always A Minus Sign :\n"
    append msg "Thus....\n"
    append msg "3-4  =  3.4        -34  = -34         --34  = -.34\n"
	Inf $msg
	return
}

proc TellReadFile {} {
	Inf "Read Any Textfiles In The Chosen File List Below"
	return
}

proc TellListInTextfile {} {
	Inf "You Can Create A Textfile Containing A List Of...\n\n1) Names Of All Files Selected\n2) Names Of All Sound-System Files Selected\n3) Names Of All Sound Files Selected\n4) Names Of Selected Sound Files, With Their Durations \n5) Names Of Text Files Selected\n6) Names Of Mix Files Selected"
	return
}

proc TellA {} {
	Inf "Play Concert A"
	return
}

proc TellDestroyDirFiles {} {
	Inf "Destroy The Files Highlighted In The Directory Listing"
	return
}

proc TellDestroyDir {} {
	Inf "Destroy The Entire Contents Of The Directory Listed Here"
	return
}

proc TellDoGrab {} {
	Inf "Files From Anywhere On Your System, Listed Below, Can Be Highlighted\nAnd 'Grabbed' Onto The Workspace.\nThe Soundloom Parses These Grabbed Files To Discover What Type Of Files They Are.\nYou Can Then Work On Them With Any Of The Soundloom Processes."
	return
}
proc TellDoCopy {} {
	Inf "Files From Anywhere On Your System Can Be\nCopied Into The Home Directory and Hence Onto The Workspace.\n\nThe Soundloom Parses These Grabbed Files To Discover What Type Of Files They Are.\nYou Can Work On These Copies With Any Of The Soundloom Processes."
	return
}

proc TellDoFind {} {
	Inf "If The File Highlighted On The Directory Listing\nIs On The Workspace,\nFind The File In The Workspace Window, Highlight It\n And If Necessary, Scroll The Window, So It Can Be Seen"
	return
}

proc TellGrabAll {} {
	Inf "Grab All The Files In The Directory Listing\nOnto The Workspace Listing"
	return
}

proc GrabFiles {sounds_only numbered} {
	global wl evv chlist ch chcnt pa pr_speclistdir speclist_dir nudir wstk readonlyfg readonlybg propfiles_list
	global pr_grnum grnumend grnumstt readonlyfg readonlybg grnumquit
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] <= 0)} {
		Inf "No File Selected"
		return
	}
	if {[llength $i] > 1} {
		Inf "Select a Single textfile"
		return
	}
	set fnam [$wl get $i]
	if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
		Inf "Select a single Textfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File $fnam"
		return
	}
	set grnumquit 0
	if {$numbered} {
		set f .grnum
		if [Dlg_Create $f "GRAB WHICH FILES" "set pr_grnum 0" -borderwidth 2 -width 84] {
			frame $f.0
			button $f.0.qu -text "Abandon" -command "set pr_grnum 0" -highlightbackground [option get . background {}]
			button $f.0.pp -text "Get Line Numbers" -command "set pr_grnum 1" -highlightbackground [option get . background {}]
			pack $f.0.pp -side left
			pack $f.0.qu -side right
			pack  $f.0 -side top -fill x -expand true
			frame $f.1
			label $f.1.ll -text "Start-file Number (Up/Dn Arrows)"
			entry $f.1.e -textvariable grnumstt -width 4 -fg $readonlyfg -readonlybackground $readonlybg -state readonly
			set grnumstt 1
			label $f.1.ll2 -text "End-file Number (Left/Right Arrows)"
			entry $f.1.e2 -textvariable grnumend -width 4 -fg $readonlyfg -readonlybackground $readonlybg -state readonly
			set grnumend 1
			pack $f.1.ll $f.1.e $f.1.ll2 $f.1.e2 -side left -padx 2
			pack $f.1 -side top
			wm resizable $f 1 1
			bind $f <Return> {set pr_grnum 1}
			bind $f <Escape> {set pr_grnum 0}
			bind $f <Up>    {IncrGrab 0 0}
			bind $f <Down>  {IncrGrab 0 1}
			bind $f <Right> {IncrGrab 1 0}
			bind $f <Left>  {IncrGrab 1 1}
		}
		set pr_grnum 0
		update idletasks
		raise $f
		My_Grab 0 $f pr_grnum $f.1.e
		update idletasks
		tkwait variable pr_grnum
		if {!$pr_grnum} {
			set grnumquit 1
		}
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
	}
	if {$grnumquit} {
		return
	}
	Block "Grabbing Files to Workspace"
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			continue
		}
		set line [RegulariseDirectoryRepresentation $line]
		if {![file exists $line]} {
			lappend badfiles $line
		} elseif {$sounds_only} {
			set ftyp [FindFileType $line]
			if {!($ftyp == $evv(SNDFILE))} {
				lappend badfiles $line
			} else {
				lappend fnams $line
			}
		} else {
			lappend fnams $line
		}
	}
	close $zit
	if {$sounds_only} {
		set zits "Soundfiles"
	} else {
		set zits "Files"
	}
	if {![info exists fnams]} {
		set msg "File $fnam Is Not (purely) A List Of Existing $zits"
		if {[info exists badfiles]} {
			set hasdir 0
			foreach badfile $badfiles {
				if {![string match $badfile [file tail $badfile]]} {
					set hasdir 1
					break
				}
			}
			if {$hasdir} {
				append msg "\n\nSpecify A Different Directory For The Files ??"
			} else {
				append msg "\n\nSpecify A Directory For The Files ??"
			}
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				if {$sounds_only} {
					if {![string match [file extension $fnam] $evv(TEXT_EXT)]} {
						set msg "Revert To Normal Textfile Extension (Rather Than Soundfile Listing) ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "yes"} {
							set nufnam [file rootname $fnam]
							append nufnam $evv(TEXT_EXT)
							if {[file exists $nufnam]} {
								Inf "Cannot Rename The File (file '$nufnam' Already Exists)"
							} else {
								set i [LstIndx $fnam $wl]
								$wl selection clear 0 end
								$wl selection set $i
								RenameTextWkspaceFile $fnam $nufnam
							}
						}
					}
					UnBlock
					return
				}
			} else {
				set nudir ""
				set f .speclistdir
				if [Dlg_Create  $f "SPECIFY DIRECTORY" "set pr_speclistdir 0" -borderwidth $evv(SBDR)] {
					set f1 [frame $f.1 -bd $evv(SBDR)]
					set f2 [frame $f.2 -bd $evv(SBDR)]
					button $f1.qu -text "Abandon" -command {set pr_speclistdir 0} -highlightbackground [option get . background {}]
					label $f1.ll -text "Use 'Get Directory' button or 'Return' to find Dir"
					button $f1.ok -text "Get Directory" -command {set pr_speclistdir 1} -highlightbackground [option get . background {}]
					entry $f2.ee -textvariable speclist_dir -width 0 -bd 0		;#	UNSEEN ENTRY BOX
					pack $f1.ok -side left -pady 2
					pack $f1.ll -side left -pady 20
					pack $f1.qu -side right -pady 2
					pack $f2.ee  -side left
					pack $f1 $f2 -side top -fill x -expand true
					wm resizable .speclistdir 1 1
					bind $f <Return> {set pr_speclistdir 1}
					bind $f <Escape> {set pr_speclistdir 0}
				}
				set speclist_dir ""
				raise $f
				set pr_speclistdir 0
				set finished 0
				My_Grab 0 $f pr_speclistdir
				while {!$finished} {
					tkwait variable pr_speclistdir
					if {$pr_speclistdir} {
						DoListingOfDirectories .speclistdir.2.ee
						if {([string length $speclist_dir] <= 0) || ![file isdirectory $speclist_dir]} {
							Inf "No Valid Directory Name Entered"
							continue
						}
						set nudir $speclist_dir
						break
					} else {
						break
					}
				}
				My_Release_to_Dialog $f
				Dlg_Dismiss $f
				if {[string length $nudir] <= 0} {
					UnBlock
					return
				}
				set testnudir [string tolower $nudir]
				set thisdir [string tolower [pwd]]
				if {[string first $thisdir $testnudir] == 0} {
					set k [string length $thisdir]
					incr k
					set nudir [string range $nudir $k end]
				}
				foreach badfile $badfiles {
					set nufnam [file join $nudir [file tail $badfile]]
					if {![file exists $nufnam]} {
						Inf "FILE '$nufnam' DOES NOT EXIST"
						UnBlock
						return
					}
					lappend fnams $nufnam
				}
				unset badfiles
			}
			set msg "Rewrite The Sound-Listing File ?"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				if [catch {open $fnam "w"} zit] {
					Inf "Cannot Open File '$fnam' To Rewrite The Data"
					UnBlock
					return
				}
				foreach nufnam $fnams {
					puts $zit $nufnam
				}
				close $zit
			}
		} else {
			Inf $msg
			UnBlock
			return
		}
	} elseif {[info exists badfiles]} {
		set msg "The Following Items In File $fnam Are Not Existing $zits\n\n"
		set ccnt 0
		foreach fnam $badfiles {
			if {$ccnt >= 20} {
				append msg "\nAnd More"
				break
			}
			append msg $fnam "   "
			incr ccnt
		}
		Inf $msg
	}
	if {$numbered} {
		set len [llength $fnams]
		if {$grnumstt > $len} {
			Inf "Insufficient Files In Listing ($len In Total) To Start At $grnumstt"
			return
		}
		if {$grnumend > $len} {
			Inf "Only $len Files In Listing"
		}
		set grstt [expr $len - ($grnumstt - 1)]		;#	Because file listing is reversed
		set grend [expr $len - ($grnumend - 1)]		;#	Files to be grabbed are at other end of list
		set temp $grend								;#	and start/end-of-grabbing numbers are reversed	
		set grend $grstt							
		set grstt $temp
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	set fnams [ReverseList $fnams]
	set chlist {}
	set kk 0
	set addedfiles 0
	foreach fnam $fnams {
		incr kk
		if {$numbered} {
			if {$kk < $grstt} {
				continue
			} elseif {$kk > $grend} {
				break
			}
		}
		set i [LstIndx $fnam $wl]
		if {$i < 0} {
			wm title .blocker  "PLEASE WAIT:      PARSING AND LOADING FILE [file rootname [file tail $fnam]]"
			if {[FileToWkspace $fnam 0 0 0 1 0] <= 0} {
				Inf "Cannot Put The Listed File $fnam On The Workspace"
			} elseif {$pa($fnam,$evv(FTYP))} {
				incr addedfiles
				if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)} {
					if {[info exists propfiles_list]} {
						set is_a_known_propfile [lsearch $propfiles_list $fnam]
					} else {
						set is_a_known_propfile -1
					}
					if {$is_a_known_propfile <= 0} {
						if {![info exists look_for_propfiles]} {
							set msg "Check For Property Files ??"
							set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set look_for_propfiles 1
							} else {
								set look_for_propfiles 0
							}
						}
						if {$look_for_propfiles} {
							if {[IsThisAPropsFile $fnam]} {
								lappend propfiles_list $fnam
							}
						}
					}
				}
			}
		}
		set chlist [concat $fnam $chlist]	;#	add to start of list
		$ch insert 0 $fnam					;#	add to start of display
		incr chcnt
	}
	if {[llength $chlist] <= 0} {
		unset chlist
	}
	$wl selection clear 0 end
	if {$addedfiles > 0} {
		set i 0
		while {$i < $addedfiles} {
			$wl selection set $i
			incr i
		}
	}
	UnBlock
}

proc IncrGrab {end down} {
	global grnumstt grnumend
	if {$end} {
		if {$down} {
			if {$grnumend > $grnumstt} {
				incr grnumend -1
			} elseif {$grnumstt > 1} {
				Inf "(Click On Window And) Change Start Count"
				return
			}
		} else {
			incr grnumend
		}
	} else {
		if {$down} {
			if {$grnumstt > 1} {
				incr grnumstt -1
			}
		} elseif {$grnumstt < $grnumend} {
			incr grnumstt
		} else {
			Inf "(Click On Window And) Change End Count"
		}
	}
}

proc LoadPropsDir {} {
	global propdir propfiles_list evv
	set propfiles_list {}
	set propdir ""
	set fil [file join $evv(URES_DIR) $evv(PROPDIR)$evv(CDP_EXT)] 
	if {![file exists $fil]} {
		return
	}
	if [catch {open $fil "r"} zit] {
		Inf "Cannot Open File '$fil' to read special-properties file-directory"
		return
	}
	gets $zit line
	close $zit
	set line [string trim $line]
	if {[string length $line] <= 0} {
		return
	}
	if {![file isdirectory $line]} {
		Inf "'$line' (retrieved name of special-properties file-directory) is not a currently existing directory"
		if [catch {file delete $fil} zit] {
			Inf "Cannot Delete File '$fil'"
		}
		return
	}
	set propdir $line

	set fil [file join $evv(URES_DIR) $evv(PROPFILES_LIST)$evv(CDP_EXT)] 
	if {![file exists $fil]} {
		return
	}
	if [catch {open $fil "r"} zit] {
		Inf "Cannot Open File '$fil' to read list of current known properties files."
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			if {[file exists $line] && ![file isdirectory $line] && ([lsearch $propfiles_list $line] < 0)} {
				lappend propfiles_list $line
			}
		}
	}
	close $zit
	if {[llength $propfiles_list] <= 0} {
		unset propfiles_list 
	}
}

proc Set_Chpos {end} {
	global chpos topchpos ww
	if {$end} {
		set chpos -1
		set topchpos 0
		$ww.1.a.endd.r.x1.ch.menu entryconfig 16 -label "Top (rather than bottom)" -command {Set_Chpos 0}
	} else {
		set topchpos 1
		$ww.1.a.endd.r.x1.ch.menu entryconfig 16 -label "Bottom (rather than top)" -command {Set_Chpos 1}
	}
}

#------ Attempt to renumber several selected workspace files

proc GenericSubstituteWkspaceNumbers {} {
	global wl pr_snum genericnumlo genericnumstep chlist ch chcnt gennum_atend gennum_samename evv
	global sl_real background_listing only_for_mix nessinit

	if {!$sl_real} {
		Inf "Selected Files With Similar Names Ending In Numbers\nCan Have Their Numbering Altered"
		return
	}
	if {[info exists only_for_mix]} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		return
	}
	if {[info exists nessinit]} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Generic Name Substitions With Physical Modelling Files"
				return
			}
		}
	}
	set ren_blist 0

	set g .genericnum
	if [Dlg_Create $g "RENUMBER FILES" "set pr_snum 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gn2 [frame $g.name2 -borderwidth $evv(SBDR)]
		set gn3 [frame $g.name3 -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_snum 0" -highlightbackground [option get . background {}]
		label $gn.l1 -text "Renumber FROM  "
		entry $gn.e1 -width 4 -textvariable genericnumlo
		label $gn.l2 -text "with STEP  "
		entry $gn.e2 -width 4 -textvariable genericnumstep
		button $gn.ok -text OK -width 6 -command "set pr_snum 1" -highlightbackground [option get . background {}]
		pack $gn.ok $gn.l1 $gn.e1 $gn.l2 $gn.e2 -side left
		pack $gn.b -side right
		pack $g.name -side top
		radiobutton $gn2.a -variable gennum_atend -text "Number at END of name" -value 1
		radiobutton $gn2.b -variable gennum_atend -text "Number at START of name" -value 0
		pack $gn2.a $gn2.b -side left -padx 4
		checkbutton $gn3.c -variable gennum_samename -text "All files have SAME NAME (except for numbering)"
		pack $gn3.c -side top
		pack $gn $gn2 $gn3 -side top -pady 2
		wm resizable $g 1 1
		bind .genericnum <Up> "incr genericnumlo"
		bind .genericnum <Down> DecrGenericnumlo
		bind $g <Return> {set pr_snum 1}
		bind $g <Escape> {set pr_snum 0}
	}
	set genericnumlo 0
	set genericnumstep 1
	set gennum_atend 1
	set gennum_samename 1
	set finished 0
	set pr_snum 0
	raise $g
	My_Grab 0 $g pr_snum $g.name.e1
	set save_mixmanage 0
	while {!$finished} {
		tkwait variable pr_snum
		if {!$pr_snum} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			if {[string length $genericnumlo] <= 0} {
				Inf "No start number has been entered"
				continue
			}
			if {![regexp {^[0-9]+$} $genericnumlo]} {
				Inf "Invalid start number entered"
				continue
			}
			set genericnumlo [StripLeadingZerosFromInteger $genericnumlo]

			set isneg 0
			if {[IsNumeric $genericnumstep] && $genericnumstep < 0.0} {
				set isneg 1
				set genericnumstep [expr -$genericnumstep]
			}
			if {![regexp {^[0-9]+$} $genericnumstep]} {
				Inf "Invalid step value entered"
				continue
			}
			set genericnumstep [StripLeadingZerosFromInteger $genericnumstep]
			if {$isneg} {
				set genericnumstep [expr -$genericnumstep]
				set len [llength $ilist]
				if {($genericnumlo + ($genericnumstep * ($len - 1))) < 0} { 
					Inf "Numbering Will Reach Below Zero"
					continue
				}
			}
			set cnt 0
			set OK 1
			foreach i $ilist {										;# check for valid (set of) files
				lappend innames [$wl get $i]
				set fnam [file rootname [$wl get $i]]
				if {$gennum_samename} {
					if {$gennum_atend} {
						if {$cnt == 0} {
							set baseext [file extension [$wl get $i]]
							set len [string length $fnam]
							incr len -1
							set strcnt 0
							while {$len >= 0} {
								set val [string index $fnam $len]
								if {![regexp {[0-9]} $val]} {
									break
								}
								incr strcnt
								incr len -1
							}
							if {$strcnt == 0} {
								Inf "File '$fnam' is not a file with number at end."
								set OK 0
								break
							}
							set basefnam [string range $fnam 0 $len]
							set numstt $len
							incr numstt
						} else {
							if {[string first $basefnam $fnam] != 0} {
								Inf "Filename '$fnam' does not start with '$basefnam'"
								set OK 0
								break
							}
							if {![string match [file extension [$wl get $i]] $baseext]} {
								Inf "Files '$fnam' is not of the same type as the first file"
								My_Release_to_Dialog $g
								Dlg_Dismiss $g
								return
							}
							if {![regexp {^[0-9]+$} [string range $fnam $numstt end]]} {
								Inf "File '$fnam' is not an already numbered file"
								My_Release_to_Dialog $g
								Dlg_Dismiss $g
								return
							}
						}
					} else {
						if {$cnt == 0} {
							set baseext [file extension [$wl get $i]]
							set ffnam [file tail $fnam]
							set len [string length $ffnam]
							set k 0
							set strcnt 0
							while {$k < $len} {
								set val [string index $ffnam $k]
								if {![regexp {[0-9]} $val]} {
									break
								}
								incr strcnt
								incr k
							}
							if {$strcnt == 0} {
								Inf "File '$ffnam' is not a file with number at start."
								set OK 0
								break
							}
							set basefnam [string range $ffnam $k $len]
							set baselen [string length $basefnam]
						} else {
							if {![string match *$basefnam $fnam] != 0} {
								Inf "Filename '$fnam' does not end with '$basefnam'"
								set OK 0
								break
							}
							if {![string match [file extension [$wl get $i]] $baseext]} {
								Inf "Files '$fnam' is not of the same type as the first file"
								My_Release_to_Dialog $g
								Dlg_Dismiss $g
								return
							}
							set k [expr int([string length $fnam] - $baselen)]
							if {$k <= 0} {
								Inf "File '$fnam' is not an already numbered file"
								My_Release_to_Dialog $g
								Dlg_Dismiss $g
								return
							}
							incr k -1
							if {![regexp {^[0-9]+$} [string range [file tail $fnam] 0 $k]]} {
								Inf "File '$fnam' is not an already numbered file"
								My_Release_to_Dialog $g
								Dlg_Dismiss $g
								return
							}
						}
					}
				} else {
					if {$cnt == 0} {
						set baseext [file extension [$wl get $i]]
					} elseif {![string match [file extension [$wl get $i]] $baseext]} {
						Inf "Files '$fnam' is not of the same type as the first file"
						My_Release_to_Dialog $g
						Dlg_Dismiss $g
						return
					}
					set strcnt 0
					if {$gennum_atend} {
						set len [string length $fnam]
						incr len -1
						while {$len >= 0} {
							set val [string index $fnam $len]
							if {![regexp {[0-9]} $val]} {
								break
							}
							incr strcnt
							incr len -1
						}
						if {$strcnt == 0} {
							Inf "File '$fnam' is not a file with number at end."
							set OK 0
							break
						}
					} else {
						set k 0
						set ffnam [file tail $fnam]
						set len [string length $ffnam]
						while {$k < $len} {
							set val [string index $ffnam $k]
							if {![regexp {[0-9]} $val]} {
								break
							}
							incr strcnt
							incr k
						}
						if {$strcnt == 0} {
							Inf "File '$ffnam' is not a file with number at start."
							set OK 0
							break
						}
					}
				}
				incr cnt
			}
			if {!$OK} {
				continue
			}
			set OK 1								;#	and test its not already in use
			set j $genericnumlo
			foreach i $ilist {
				if {$gennum_samename} {
					if {$gennum_atend} {
						set nuname $basefnam
						append nuname $j $baseext
					} else {
						set nuname $j
						append nuname $basefnam $baseext
					}
				} else {
					set fnam [$wl get $i]
					set fdir [file dirname $fnam]
					if {[string length $fdir] <= 1} {
						set fdir ""
					}
					set ffnam [file tail $fnam]
					set basefnam [file rootname $ffnam]
					set len [string length $basefnam]
					if {$gennum_atend} {
						set k $len
						incr k -1
						while {[regexp {^[0-9]+$} [string index $ffnam $k]]} {
							incr k -1
						}
						set nuname [file join $fdir [string range $basefnam 0 $k]]
						append nuname $j $baseext
					} else {
						set k 0
						while {[regexp {^[0-9]+$} [string index $ffnam $k]]} {
							incr k
						}
						set basefnam [string range $basefnam $k $len]
						set nuname [file join $fdir $j]
						append nuname $basefnam $baseext
					}
				}
				if {[file exists $nuname] && ([lsearch -exact $innames $nuname] < 0)} {
					Inf "A File (Not Among The Chosen Files) With The Name '$nuname' Already Exists"
					My_Release_to_Dialog $g
					Dlg_Dismiss $g
					return
				}
				lappend notyetdone $i $j
				incr j $genericnumstep
			}
			set OK 1
			while {$OK} {
				foreach {i j} $notyetdone {
					if {$gennum_samename} {
						if {$gennum_atend} {
							set nuname $basefnam
							append nuname $j $baseext
						} else {
							set nuname $j
							append nuname $basefnam $baseext
						}
					} else {
						set fnam [$wl get $i]
						set fdir [file dirname $fnam]
						if {[string length $fdir] <= 1} {
							set fdir ""
						}
						if {$gennum_atend} {
							set basefnam [file tail [file rootname $fnam]]
							set len [string length $basefnam]
							set k $len
							incr k -1
							while {[regexp {^[0-9]+$} [string index $basefnam $k]]} {
								incr k -1
							}
							set nuname [file join $fdir [string range $basefnam 0 $k]]
							append nuname $j $baseext
						} else {
							set ffnam [file tail $fnam]
							set basefnam [file rootname $ffnam]
							set len [string length $basefnam]
							set k 0
							while {[regexp {^[0-9]+$} [string index $ffnam $k]]} {
								incr k
							}
							set basefnam [string range $basefnam $k $len]
							set nuname [file join $fdir $j]
							append nuname $basefnam $baseext
						}
					}
					set origfnam [$wl get $i]
					if {[file exists $nuname]} {
						lappend stillnotyetdone $i $j
						continue
					}
					set haspmark [HasPmark $origfnam]
					set hasmmark [HasMmark $origfnam]
					if [catch {file rename $origfnam $nuname} zub] {
						Inf "Cannot rename file\n$origfnam\nTO\n$nuname"
						continue
					}
					DataManage rename $origfnam $nuname
					lappend couettelist $origfnam $nuname
					UpdateBakupLog $origfnam delete 0
					UpdateBakupLog $nuname create 1
					CheckMainmix $origfnam $nuname
					CheckMainmixSnd $origfnam $nuname
					$wl delete $i								
					$wl insert $i $nuname
					catch {unset rememd}
					UpdateChosenFileMemory $origfnam $nuname
					set oldname_pos_on_chosen [LstIndx $origfnam $ch]
					if {$oldname_pos_on_chosen >= 0} {
						RemoveFromChosenlist $origfnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $nuname]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $nuname
					}
					RenameProps	$origfnam $nuname 1				
					DummyHistory $origfnam "RENAMED_$nuname"
					if {[MixMRename $origfnam $nuname 0]} {
						set save_mixmanage 1
					}
					if {$haspmark} {
						MovePmark $origfnam $nuname
					}
					if {$hasmmark} {
						MoveMmark $origfnam $nuname
					}
					if [IsInBlists $origfnam] {
						if [RenameInBlists $origfnam $nuname] {
							set ren_blist 1
						}
					}
					RenameOnDirlist $origfnam $nuname
				}
				if {[info exists couettelist]} {
					CouetteManage rename $couettelist
				}
				if {![info exists stillnotyetdone] || ([llength $stillnotyetdone] <= 0)} {
					break
				} elseif {[llength $stillnotyetdone] == [llength $notyetdone]} {
					set OK 0
				} else {
					set notyetdone $stillnotyetdone
					unset stillnotyetdone
				}
			}
			if {!$OK} {
				if {[expr [llength $notyetdone]/2] == [llength $innames]} {
					Inf "No Files Have Been Renumbered\n\nYou Could Try A Name Swap (Which Might Allow Renumbering To Start)"
				} else {
					set cnt 0
					foreach {i j} $stillnotyetdone {
						if {$cnt > 30} {
							append msg "And More"
							break
						}
						if {$gennum_samename} {
							if {$gennum_atend} {
								set nuname $basefnam
								append nuname $j $baseext
							} else {
								set nuname $j
								append nuname $basefnam $baseext
							}
						} else {
							set fnam [$wl get $i]
							set fdir [file dirname $fnam]
							if {[string length $fdir] <= 1} {
								set fdir ""
							}
							if {$gennum_atend} {
								set basefnam [file rootname $fnam]
								set len [string length $basefnam]
								set k $len
								incr k -1
								while {[regexp {^[0-9]+$} [string index $fnam $k]]} {
									incr k -1
								}
								set nuname [file join $fdir [string range $basefnam 0 $k]]
								append nuname $j $baseext
							} else {
								set ffnam [file tail $fnam]
								set basefnam [file rootname $ffnam]
								set len [string length $basefnam]
								set k 0
								while {[regexp {^[0-9]+$} [string index $ffnam $k]]} {
									incr k
								}
								set basefnam [string range $basefnam $k $len]
								set nuname [file join $fdir $j]
								append nuname $basefnam $baseext
							}
						}
						set origfnam [$wl get $i]
						if {![string match $origfnam $nuname]} {
							if {$cnt == 0} {
								set msg "Failed To Renumber The Following Files\n"
							}
							append msg "'$origfnam' ( To '$nuname' )\n"
							incr cnt
						}
					}
					if {$cnt > 0} {
						Inf $msg
					}
				}
			}
			break
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}		
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
}

#------ Attempt to swap names of two files

proc SwapFileNames {} {
	global wl chlist ch chcnt last_mix evv
	global sl_real background_listing dupl_mix dupl_vbx dupl_txt nessinit

	if {!$sl_real} {
		Inf "Swap Names Of Selected Files"
		return
	}
	if {$dupl_mix || $dupl_vbx  || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0

	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] != 2} {							
		Inf "A Pair Of Files Must Be Selected"
		return
	}
	if [info exists nessinit] {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Name Swaps With Physical Modelling Files"
				return
			}
		}
	}
	set cnt 0
	foreach i $ilist {										;# check for valid (set of) files
		lappend innames [$wl get $i]
		if {$cnt == 0} {
			set baseext [file extension [$wl get $i]]
		} else {
			if {![string match [file extension [$wl get $i]] $baseext]} {
				Inf "File '[$wl get $i]' Is Not Of The Same Type As The First File"
				return
			}
		}
		incr cnt
	}
	if {[info exists last_mix]} {
		if {[string match $last_mix [lindex $innames 0]]} {
			set nulastmix [lindex $innames 1]
		} elseif {[string match $last_mix [lindex $innames 1]]} {
			set nulastmix [lindex $innames 0]
		}
	}
	set tempfnam $evv(DFLT_OUTNAME)
	append tempfnam $baseext
	if [catch {file rename [lindex $innames 0] $tempfnam} zot] {
		Inf "Cannot Swap Filename"
		catch {unset nulastmix}
		return
	}
	if [catch {file rename [lindex $innames 1] [lindex $innames 0]} zot] {
		file rename $tempfnam [lindex $innames 0]
		Inf "Cannot Swap Filenames"
		catch {unset nulastmix}
		return
	}
	if [catch {file rename $tempfnam [lindex $innames 1]} zot] {
		file rename [lindex $innames 0] [lindex $innames 1]
		file rename $tempfnam [lindex $innames 0]
		Inf "Cannot Swap Filenames"
		catch {unset nulastmix}
		return
	}
	UpdateBakupLog [lindex $innames 0] modify 0
	UpdateBakupLog [lindex $innames 1] modify 1
	
	DataManage swap [lindex $innames 0] [lindex $innames 1]
	set couettelist [list [lindex $innames 0] [lindex $innames 1]]
	CouetteManage swap $couettelist
	CheckSwapMainmix [lindex $innames 0] [lindex $innames 1]
	CheckSwapMainmixSnd [lindex $innames 0] [lindex $innames 1]

	set haspmark0 [HasPmark [lindex $innames 0]]
	set haspmark1 [HasPmark [lindex $innames 1]]
	set hasmmark0 [HasMmark [lindex $innames 0]]
	set hasmmark1 [HasMmark [lindex $innames 1]]

	if {$haspmark0 && $haspmark1} {
		MovePmark [lindex $innames 0] $tempfnam
		MovePmark [lindex $innames 1] [lindex $innames 0]
		MovePmark $tempfnam [lindex $innames 1]
	} elseif {$haspmark0} {
		MovePmark [lindex $innames 0] [lindex $innames 1]
	} elseif {$haspmark1} {
		MovePmark [lindex $innames 1] [lindex $innames 0]
	}		
	if {$hasmmark0 && $hasmmark1} {
		MoveMmark [lindex $innames 0] $tempfnam
		MoveMmark [lindex $innames 1] [lindex $innames 0]
		MoveMmark $tempfnam [lindex $innames 1]
	} elseif {$hasmmark0} {
		MoveMmark [lindex $innames 0] [lindex $innames 1]
	} elseif {$hasmmark1} {
		MoveMmark [lindex $innames 1] [lindex $innames 0]
	}		
	if {([LstIndx [lindex $innames 0] $ch] >= 0) && ([LstIndx [lindex $innames 1] $ch] >= 0)} {
		UpdateChosenFileMemory [lindex $innames 0] $tempfnam
		UpdateChosenFileMemory [lindex $innames 1] [lindex $innames 0]
		UpdateChosenFileMemory $tempfnam [lindex $innames 1]
		set oldname_pos_on_chosen0 [LstIndx [lindex $innames 0] $ch]
		set oldname_pos_on_chosen1 [LstIndx [lindex $innames 1] $ch]
		RemoveFromChosenlist [lindex $innames 0]
		set chlist [linsert $chlist $oldname_pos_on_chosen0 $tempfnam]
		incr chcnt
		$ch insert $oldname_pos_on_chosen0 $tempfnam
		RemoveFromChosenlist [lindex $innames 1]
		set chlist [linsert $chlist $oldname_pos_on_chosen1 [lindex $innames 0]]
		incr chcnt
		$ch insert $oldname_pos_on_chosen1 [lindex $innames 0]
		RemoveFromChosenlist $tempfnam
		set chlist [linsert $chlist $oldname_pos_on_chosen0 [lindex $innames 1]]
		incr chcnt
		$ch insert $oldname_pos_on_chosen0 [lindex $innames 1]
	} elseif {[LstIndx [lindex $innames 0] $ch] >= 0} {
		UpdateChosenFileMemory [lindex $innames 0] [lindex $innames 1]
		set oldname_pos_on_chosen [LstIndx [lindex $innames 0] $ch]
		RemoveFromChosenlist [lindex $innames 0]
		set chlist [linsert $chlist $oldname_pos_on_chosen [lindex $innames 1]]
		incr chcnt
		$ch insert $oldname_pos_on_chosen [lindex $innames 1]
	} elseif {[LstIndx [lindex $innames 1] $ch] >= 0} {
		UpdateChosenFileMemory [lindex $innames 1] [lindex $innames 0]
		set oldname_pos_on_chosen [LstIndx [lindex $innames 1] $ch]
		RemoveFromChosenlist [lindex $innames 1]
		set chlist [linsert $chlist $oldname_pos_on_chosen [lindex $innames 0]]
		incr chcnt
		$ch insert $oldname_pos_on_chosen [lindex $innames 0]
	}
	RenameProps	[lindex $innames 0] $tempfnam 1				
	RenameProps	[lindex $innames 1] [lindex $innames 0] 1				
	RenameProps	$tempfnam [lindex $innames 1] 1				
	DummyHistory [lindex $innames 0] "RENAMED_[lindex $innames 1]"
	DummyHistory [lindex $innames 1] "RENAMED_[lindex $innames 0]"

	if {[IsInBlists [lindex $innames 0]] && [IsInBlists [lindex $innames 1]]} {
		if [RenameInBlists [lindex $innames 0] $tempfnam] {
			set ren_blist 1
		}
		if [RenameInBlists [lindex $innames 1] [lindex $innames 0]] {
			set ren_blist 1
		}
		if [RenameInBlists $tempfnam [lindex $innames 1]] {
			set ren_blist 1
		}
	} elseif {[IsInBlists [lindex $innames 0]]} {
		if [RenameInBlists [lindex $innames 0] [lindex $innames 1]] {
			set ren_blist 1
		}
	} elseif {[IsInBlists [lindex $innames 1]]} {
		if [RenameInBlists [lindex $innames 1] [lindex $innames 0]] {
			set ren_blist 1
		}
	}
	RenameOnDirlist [lindex $innames 0] $tempfnam
	RenameOnDirlist [lindex $innames 1] [lindex $innames 0]
	RenameOnDirlist $tempfnam [lindex $innames 1]
	if {$ren_blist} {
		SaveBL $background_listing
	}		
	if {[info exists nulastmix]} {
		set last_mix $nulastmix
	}
	DataManage swap [lindex $innames 0] [lindex $innames 1] 
	set couettelist [list [lindex $innames 0] [lindex $innames 1]]
	CouetteManage swap $couettelist
	MixMSwap [lindex $innames 0] [lindex $innames 1] 1
	foreach i $ilist {
		$wl selection set $i
	}
}

#------ Add files to a textlisting of workspace files

proc AddToFile {} {
	global wl pa wstk evv

	set got_list 0
	set bigmsg "Select An Existing Textfile Listing Of Sounds, And Some Further Soundfiles To Add To It"
	set ilist [$wl curselection]
	if {[llength $ilist] < 2} {
		Inf $bigmsg
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[IsASndlist $pa($fnam,$evv(FTYP))]} {
			if {$got_list} {
				Inf $bigmsg
				return
			}
			set got_list 1
			set lfnam $fnam
		} elseif {$pa($fnam,$evv(FTYP)) != $evv(IS_A_SNDFILE)} {
			Inf $bigmsg
			return
		} else {
			lappend in_snds $fnam
		}
	}
	if {!$got_list} {
		Inf $bigmsg
		return
	}			
	set orig_in_snds $in_snds
	if [catch {open $lfnam "r"} zit] {
		Inf "Cannot Open File '$lfnam' To Read Soundfile Names Already Listed"
		return
	}
	while {[gets $zit line] >= 0} {
		set fnam [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set k [lsearch $in_snds $fnam]
		if {$k >= 0} {
			lappend already $fnam
			set in_snds [lreplace $in_snds $k $k]
		}
	}
	close $zit
	if {![info exists in_snds] || ([llength $in_snds] <= 0)} {
		set msg "All The Selected Soundfiles Are Already Listed In The Textfile $lfnam: Add Them Anyway ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set in_snds $orig_in_snds
	} elseif {[info exists already]} {
		set msg "The Following Sounds Are Already Listed In The Textfile\n"
		set cnt 0
		foreach fnam $already {
			append msg $fnam "\n"
			incr cnt
			if {$cnt >= 20} {
				append msg "And More"
				break
			}
		}
		append msg "\n\nAdd Them Anyway ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set in_snds $orig_in_snds
	}
	set tempfnam $evv(DFLT_TMPFNAME)$evv(TEXT_EXT)
	if [catch {file copy $lfnam $tempfnam} zat] {
		Inf "Cannot Make Back-Up Copy Of File '$lfnam'"
		return
	}
	if [catch {open $lfnam "a"} zit] {
		Inf "Cannot Open File '$lfnam' To Add Further Soundfile Names"
		return
	}
	foreach fnam $in_snds {
		puts $zit $fnam
	}
	close $zit
	set origlfnam $lfnam
	set this_ext [GetTextfileExtension sndlist]
	if {![string match [file extension $lfnam] $this_ext]} {
		set zfnam [file rootname $lfnam]
		append zfnam $this_ext
		if {[RenameTextWkspaceFile $lfnam $zfnam]} {
			set lfnam $zfnam
		}
	}
	if {[DoParse $lfnam 0 0 0] <= 0} {
		Inf "Restoring Original File"
		if [catch {file delete $lfnam} zat] {
			Inf "Cannot Delete Corrupted File: Original data is in file '$tempfnam'\n\nRetrieve This Outside The Sound Loom (without closing the Loom!), Before Proceeding"
			return
		}
		if [catch {file rename $tempfnam $origlfnam} zat] {
			Inf "Cannot Restore Original Filename: Original data is in file '$tempfnam'\n\nRename This Outside The Sound Loom (without closing the Loom!), Before Proceeding"
			return
		}
		return
	}
	if [catch {file delete $tempfnam} zat] {
		Inf "Cannot Delete Temporary File '$tempfnam'"
	}
	if {![string match $origlfnam $lfnam]} {
		Inf "Soundfile Names Have Been Added To File '$origlfnam', Now Renamed '$lfnam'"
	} else  {
		Inf "Soundfile Names Have Been Added To File '$lfnam'"
	}
}

proc InvertSelect {} {
	global wl
	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		$wl selection set 0 end
		return
	}
	set k [$wl index end]
	set n 0
	while {$n < $k} {
		if {[lsearch $ilist $n] < 0} {
			lappend nulist $n
		}
		incr n
	}
	$wl selection clear 0 end
	foreach n $nulist {
		$wl selection set $n
	}
}

proc ReverseString {str} {
	set len [string length $str]
	if {$len <= 1} {
		return $str
	}
	set outstr ""
	set m [expr $len - 1]
	while {$m >= 0} { 
		append outstr [string index $str $m]
		incr m -1
	}
	return $outstr
}

proc GrabHilite {sounds_only} {
	global wl evv ch chcnt pa
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] <= 0)} {
		Inf "No File Selected"
		return
	}
	if {[llength $i] > 1} {
		Inf "Select a Single Textfile"
		return
	}
	set fnam [$wl get $i]
	if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
		Inf "Select a Single Textfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			continue
		}
		set line [RegulariseDirectoryRepresentation $line]
		if {![file exists $line]} {
			lappend badfiles $line
		} elseif {$sounds_only > 0} {
			set ftyp [FindFileType $line]
			if {!($ftyp == $evv(SNDFILE))} {
				lappend badfiles $line
			} else {
				lappend fnams $line
			}
		} else {
			lappend fnams $line
		}
	}
	close $zit
	if {$sounds_only > 0} {
		set zits "SOUNDFILES"
	} else {
		set zits "FILES"
	}
	if {![info exists fnams]} {
		Inf "File '$fnam' Is Not (purely) A List Of Existing $zits"
		return
	} elseif {[info exists badfiles]} {
		set msg "The Following Items In File '$fnam' Are Not Existing $zits\n\n"
		set ccnt 0
		foreach fnam $badfiles {
			if {$ccnt >= 20} {
				append msg "\nAnd More"
				break
			}
			append msg $fnam "   "
			incr ccnt
		}
		Inf $msg
	}
	catch {unset badfiles}
	foreach fnam $fnams {
		set i [LstIndx $fnam $wl]
		if {$i < 0} {
			lappend badfiles $fnam
		} else {
			lappend ilist $i
		}
	}
	if {$sounds_only == 2} {
		set kk [$wl curselection]
		$wl selection clear 0 end
		if [info exists ilist] {
			set len [llength $ilist]
			set k 0
			foreach fnam [$wl get 0 end] {
				if {[lsearch $ilist $k] >= 0} {
					lappend topfiles $fnam
				} else {
					lappend botfiles $fnam
				}
				incr k
			}
			set nulist [concat $topfiles $botfiles]
			$wl delete 0 end
			set k 0
			foreach fnam $nulist {
				$wl insert end $fnam
				if {$k < $len} {
					set isset 1
					$wl selection set $k
				}
				incr k
			}
		}
		if [info exists badfiles] {
			foreach fnam $badfiles {
				if {[FileToWkspace $fnam 0 0 0 1 0] <= 0} {
					Inf "Cannot Put The Listed File '$fnam' On The Workspace"
				} else {
					set isset 1
					$wl selection set 0
				}
			}
		}
		if {![info exists isset]} {
			$wl selection set $kk
		}
	} else {
		if {![info exists ilist]} {
			Inf "None Of These Files Is On The Workspace"
			return
		}
		if {[info exists badfiles]} {
			set msg "The Following Items In File '$fnam' Are Not On The Workspace\n\n"
			set ccnt 0
			foreach fnam $badfiles {
				if {$ccnt >= 20} {
					append msg "\nAnd More"
					break
				}
				append msg $fnam "   "
				incr ccnt
			}
			Inf $msg
		}
		$wl selection clear 0 end
		foreach i $ilist {
			$wl selection set $i
		}
	}
}

proc GrabChoose {add} {
	global wl evv chlist ch chcnt pa dupl_mix dupl_vbx dupl_txt lastgrab lastgrabfil wstk
	switch -- $add {
		3 -
		4 {
			if {[info exists lastgrabfil] && [info exists pa($lastgrabfil,$evv(FTYP))]} {
				set i [$wl curselection]
				if {!([info exists i] && ([llength $i] == 1) && [IsASndlist $pa([$wl get $i],$evv(FTYP))])} {
					set i [LstIndx $lastgrabfil $wl]
					if {$i >= 0} {
						$wl selection clear 0 end
						$wl selection set $i
					}
				}
			}
		}
		5 {
			catch {unset lastgrabfil}
			catch {unset lastgrab}
			return
		}
		6 {
			if {[info exists lastgrabfil] && [info exists pa($lastgrabfil,$evv(FTYP))]} {
				set i [$wl curselection]
				if {![info exists i] || ([llength $i] != 1) || ($pa([$wl get $i],$evv(FTYP)) != $evv(SNDFILE))} {
					Inf "No Workspace Soundfile Selected"
					return
				}
				set possgrabfil [$wl get $i]
				set i [LstIndx $lastgrabfil $wl]
				if {$i >= 0} {
					$wl selection clear 0 end
					$wl selection set $i
				}
			} else {
				return
			}
		}
	}
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] <= 0)} {
		Inf "No File Selected"
		return
	}
	if {[llength $i] > 1} {
		Inf "Select a Single Textfile"
		return
	}
	set fnam [$wl get $i]
	if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
		Inf "Select a Single Textfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			continue
		}
		set line [RegulariseDirectoryRepresentation $line]
		if {![file exists $line]} {
			lappend badfiles $line
		} else {
			lappend fnams $line
		}
	}
	close $zit
	if {![info exists fnams]} {
		Inf "File '$fnam' Is Not (purely) A List Of Existing Soundfiles"
		return
	} elseif {[info exists badfiles]} {
		set msg "The Following Items In File '$fnam' Are Not Existing Soundfiles\n\n"
		set ccnt 0
		foreach fnam $badfiles {
			if {$ccnt >= 20} {
				append msg "\nAnd More"
				break
			}
			append msg $fnam "   "
			incr ccnt
		}
		Inf $msg
		return
	}
	set listfnam $fnam
	set orclen [llength $fnams]
	foreach fnam $fnams {
		set i [LstIndx $fnam $wl]
		if {$i < 0} {
			if {$add < 3} {
				if {![file exists $fnam]} {
					Inf "File '$fnam' No Longer Exists"
					return
				}
				if {[FileToWkspace $fnam 1 0 0 1 0] <= 0} {
					Inf "Cannot Grab  '$fnam' To The Workspace"
					return
				}
			} else {
				Inf "File '$fnam' Is Not On The Workspace"
				return
			}
		}
	}
	if {($add == 3) || ($add == 4) || ($add == 6)} {
		switch -- $add {
			3 -
			4 {
				if {[info exists lastgrabfil] && [string match $listfnam $lastgrabfil]} {
					incr lastgrab
				} else {
					set lastgrab 0
					set lastgrabfil $listfnam
				}
				if {$lastgrab >= $orclen} {
					set msg "All Sounds In Soundlist File Have Been Grabbed: Start Again At First ?"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						set lastgrab 0
					} else {
						catch [unset lastgrabfil]
						return
					}
				}
			}
			6 {
				set k [lsearch $fnams $possgrabfil]
				if {$k < 0} {
					Inf "File '$possgrabfil' Is Not In The Current Soundfile-Textlisting Being Used"
					return
				} else {
					incr k -1
					set lastgrab $k
				}
				return
			}
		}
		DoChoiceBak
		ClearWkspaceSelectedFiles
		set zfnam [lindex $fnams $lastgrab]
		lappend chlist $zfnam
		$ch insert end $zfnam
		incr chcnt
		if {$add == 4} {
			PlaySndfile $zfnam 0
		}
		return	
	}
	if {$add} {
		if {[info exists chlist] && ($add == 1)} {
			set do_it 0
			foreach fnam $fnams {
				if {[lsearch $chlist $fnam] < 0} {
					set do_it 1
					break
				}
			}
			if {!$do_it} {
				Inf "All The Files Are Already On The Chosen Files List"
				return
			}
		}
		DoChoiceBak
		if {![info exists chlist] || ($add == 2)} {
			foreach fnam $fnams {
				lappend chlist $fnam		;#	add to end of list
				$ch insert end $fnam		;#	add to end of display
				incr chcnt
			}
		} else {
			foreach fnam $fnams {
				if {[lsearch $chlist $fnam] < 0} {
					lappend chlist $fnam		;#	add to end of list
					$ch insert end $fnam		;#	add to end of display
					incr chcnt
				}
			}
		}
	} else {
		DoChoiceBak
		ClearWkspaceSelectedFiles
		foreach fnam $fnams {
			lappend chlist $fnam		;#	add to end of list
			$ch insert end $fnam		;#	add to end of display
			incr chcnt
		}
	}
	set was_dupl_mix 0
	set was_dupl_vbx 0
	set was_dupl_txt 0
	if {$dupl_mix} {
		set was_dupl_mix 1
	}
	if {$dupl_vbx} {
		set was_dupl_vbx 1
	}
	if {$dupl_txt} {
		set was_dupl_txt 1
	}
	ChlistDupls
	set domsg 0
	if {!$was_dupl_mix && $dupl_mix} {
		set domsg 1
	}
	if {!$was_dupl_vbx && $dupl_vbx} {
		set domsg 1
	}
	if {!$was_dupl_txt && $dupl_txt} {
		set domsg 1
	}
	if {$domsg} {
		DuplFilesMsg
	}
}

proc ChoseSel {add} {
	global wl chlist ch chcnt dupl_mix dupl_vbx dupl_txt
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Files Selected"
		return
	}
	if {$add} {
		if {[info exists chlist] && ($add == 1)} {
			set do_it 0
			foreach i $ilist {
				set fnam [$wl get $i]
				if {[lsearch $chlist $fnam] < 0} {
					set do_it 1
					break
				}
			}
			if {!$do_it} {
				Inf "All The Files Are Already On The Chosen Files List"
				return
			}
		}
		DoChoiceBak
		if {![info exists chlist] || ($add == 2)} {
			foreach i $ilist {
				set fnam [$wl get $i]
				lappend chlist $fnam		;#	add to end of list
				$ch insert end $fnam		;#	add to end of display
				incr chcnt
			}
		} else {
			foreach i $ilist {
				set fnam [$wl get $i]
				if {[lsearch $chlist $fnam] < 0} {
					lappend chlist $fnam		;#	add to end of list
					$ch insert end $fnam		;#	add to end of display
					incr chcnt
				}
			}
		}
	} else {
		DoChoiceBak
		ClearWkspaceSelectedFiles
		foreach i $ilist {
			set fnam [$wl get $i]
			lappend chlist $fnam		;#	add to end of list
			$ch insert end $fnam		;#	add to end of display
			incr chcnt
		}
	}
	set was_dupl_mix 0
	set was_dupl_vbx 0
	set was_dupl_txt 0
	if {$dupl_mix} {
		set was_dupl_mix 1
	}
	if {$dupl_vbx} {
		set was_dupl_vbx 1
	}
	if {$dupl_txt} {
		set was_dupl_txt 1
	}
	ChlistDupls
	set domsg 0
	if {!$was_dupl_mix && $dupl_mix} {
		set domsg 1
	}
	if {!$was_dupl_vbx && $dupl_vbx} {
		set domsg 1
	}
	if {!$was_dupl_txt && $dupl_txt} {
		set domsg 1
	}
	if {$domsg} {
		DuplFilesMsg
	}
	$ch xview moveto 0.0
}

proc SetFloatOut {} {
	global float_out evv ww nofloat_standalones
	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(FLOAT)$evv(CDP_EXT)]
	if {$float_out} {
		set float_out 0
		$ww.1.a.mez.type config -text "OUT FORMAT SET\nTO INFILE FORMAT" -width 16
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				set msg "Cannot Delete File '$fnam' To Tell System Not To Use float Output In Future Sessions.\n"
				append msg "Delete This File Outside The Sound Loom."
				Inf $msg
			}
		}
	} else {
		set float_out 1
		if {[info exists nofloat_standalones]} {
			set msg "The Following Standalone Programs Do Not Have A Floating Point Output Option\n"
			append msg "Or Have A Floating Point Output Option Built In As A Parameter.\n\n"
			append msg "They Will Therefore Not Be Affected By This Operation.....\n\n"
			set zcnt 0
			foreach p_rg $nofloat_standalones {
				if {$zcnt > 60} {
					append msg "AND MORE"	
					break
				}
				append msg "$p_rg   "
				incr zcnt
			}
			Inf $msg
		}
		$ww.1.a.mez.type config -text "FORCE FLOATING\nPOINT OUTFILES" -width 16
		if [catch {open $fnam "w"} zit] {
			set msg "Cannot Open File '$fnam' To Tell System To Use float Output In Future Sessions.\n"
		} else {
			close $zit
		}
	}
}

proc HiddenDirname {} {
	global dl hidden_dir
	if {[$dl index end] < 0} {
		return
	}
	set hidden_dir [file dirname [$dl get 0]]
	if {[string length $hidden_dir] <= 1} {
		return
	}
	foreach fnam [$dl get 0 end] {
		lappend nulist [file tail $fnam]
	}
	$dl delete 0 end
	foreach fnam $nulist {
		$dl insert end $fnam
	}
	$dl xview moveto 0.0
}

#------ Select workspace files of specific type

proc SelectType {typ} {
	global wl propfiles_list pa evv
	switch -- $typ {
		"inmix" {
			ShowSoundsInMixfiles 0
			return
		}
		"inmixun" {
			ShowSoundsInMixfiles 1
			return
		}
		"sel" {
			set ilist [$wl curselection]
			if {[llength $ilist] > 1} {
				Inf "Select A Single File"
				return
			}
			set i [lindex $ilist 0]
			if {$i < 0} {
				Inf "No File Selected"
				return
			}
			set dir [file dirname [$wl get $i]]
			set ilist {}
			set i 0
			foreach fnam [$wl get 0 end] {
				if {[string match $dir [file dirname $fnam]]} {
					lappend ilist $i
				}
				incr i
			}
			$wl selection clear 0 end
			foreach i $ilist {
				$wl selection set $i
			}
			AdjustWkspaceView [lindex $ilist 0]
			return
		}
		"bak"    -
		"nonbaksnd" -
		"nonbak" {
			set i 0
			foreach fnam [$wl get 0 end]  {
				if {[string match $fnam [file tail $fnam]]} {
					lappend nilist $i
				} else {
					lappend ilist $i
				}
				incr i
			}
			if {($typ == "nonbak") || ($typ == "nonbaksnd")} {
				if {![info exists nilist]} {
					Inf "All Workspace Files Are Backed Up"
					return
				}
				if {$typ == "nonbaksnd"} {
					catch {unset nuilist}
					foreach i $nilist {
						set fnam [$wl get $i]
						if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
							lappend nuilist $i
						}
					}
					if {![info exists nuilist]} {
						Inf "All Workspace Sounds Are Backed Up"
						return
					} else {
						set nilist $nuilist
					}
				}
				set ilist $nilist
			} else {
				if {![info exists ilist]} {
					Inf "No Workspace Files Are Backed Up"
					return
				}
			}
			$wl selection clear 0 end
			foreach i $ilist {
				$wl selection set $i
			}
			AdjustWkspaceView [lindex $ilist 0]
			return
		}
		"props" {
			set checkext 1
			set ext [GetTextfileExtension props]
			if {[string match $ext $evv(TEXT_EXT)]} {
				set checkext 0
			}
			set i 0
			foreach fnam [$wl get 0 end]  {
				if {$checkext && [string match [file extension $fnam] $ext]} {
					lappend ilist $i
				} elseif {[info exists propfiles_list] && ([lsearch $propfiles_list $fnam] >= 0)} {
					lappend ilist $i
				}
				incr i
			}
			if {![info exists ilist]} {
				Inf "No Known Properties Files On The Workspace"
				return
			}
			$wl selection clear 0 end
			foreach i $ilist {
				$wl selection set $i
			}
			AdjustWkspaceView [lindex $ilist 0]
			return
		}
	}
	switch -- $typ {
		"srate"		-
		"snd"		{ set gettyp $evv(SNDFILE)  }
		"anal"		{ set gettyp $evv(ANALFILE) } 
		"pitch"		{ set gettyp $evv(PITCHFILE) } 
		"transpos"	{ set gettyp $evv(TRANSPOSFILE) } 
		"formant"	{ set gettyp $evv(FORMANTFILE) } 
		"envel"		{ set gettyp $evv(ENVFILE) } 
		"sndlist"	{ set gettyp $evv(ENVFILE) } 
	}
	set i 0
	foreach fnam [$wl get 0 end] {
		set thistyp $pa($fnam,$evv(FTYP))
		switch -- $typ {
			"text" {
				if {$thistyp & $evv(IS_A_TEXTFILE)} {
					lappend ilist $i
				}
			}
			"mix" {
				if {[IsAMixfile $thistyp]} {
					lappend ilist $i
				}
			}
			"multimix" {
				if {$thistyp == $evv(MIX_MULTI)} {
					lappend ilist $i
				}
			}
			"batch" {
				if {[string match [file extension $fnam] ".bat"]} {
					lappend ilist $i
				}
			}
			"sndlist" {
				if {[IsASndlist $thistyp]} {
					lappend ilist $i
				}
			}
			default {
				if {[string match $thistyp $gettyp]} {
					lappend ilist $i
				}
			}
		}
		incr i
	}
	if {$typ == "srate"} {
		if {![info exists ilist]} {
			return
		}
		foreach i $ilist {
			set fnam [$wl get $i]
			set srate $pa($fnam,$evv(SRATE))
			lappend jlist $srate
		}
		set srate [lindex $jlist 0]
		set srates($srate) 1
		foreach srate [lrange $jlist 1 end] {
			set got 0
			foreach sr [array names srates] {
				if {$srate == $sr} {
					incr srates($sr) 
					set got 1
					break
				}

			}
			if {!$got} {
				set srates($srate) 1
			}
		}
		set cnt 0
		foreach sr [array names srates] {
			incr cnt
		}
		if {$cnt == 1} {
			Inf "No Anomalous Sample Rate Files"
			return
		}
		set max -1
		foreach sr [array names srates] {
			if {$srates($sr) > $max} {
				set max $srates($sr)
				set commonest_srate $sr
			} elseif {$srates($sr) == $max} {
				lappend commonest_srate $sr
			}
		}
		set k [llength $commonest_srate]
		if {$k > 1} {
			set msg "Sample Rates\n"
			foreach srate $commonest_srate {
				append msg "$srate  "
			}
			append msg "\nAre Equally Common"
			Inf $msg
			return
		}
		$wl selection clear 0 end
		foreach i $ilist j $jlist {
			if {$j != $commonest_srate} {
				$wl selection set $i
				if {![info exists jkjk]} {
					set jkjk $i
				}
			}
		}
		set msg "Sample Rate $commonest_srate Is Standard\n\nBut Files With Srate"
		if {$cnt > 2} {
			append msg "S"
		}
		append msg "\n\n"
		foreach sr [array names srates] {
			if {$sr != $commonest_srate} {
				append msg "$sr  "
			}
		}
		append msg "\n\nAre Also Present, As Highlighted"
		Inf $msg
		AdjustWkspaceView $jkjk
		return
	}
	if {[info exists ilist]} {
		$wl selection clear 0 end
		foreach i $ilist {
			$wl selection set $i
		}
		AdjustWkspaceView [lindex $ilist 0]
	} else {
		set msg "There Are No "
		switch -- $typ {
			"snd"		{ append msg "Sound " }
			"anal"		{ append msg "Analysis " } 
			"pitch"		{ append msg "Binary Pitch " } 
			"transpos"	{ append msg "Binary Transposition " } 
			"formant"	{ append msg "Formant " } 
			"text"		{ append msg "Text" } 
			"mix"		{ append msg "Mix" } 
			"multimix"	{ append msg "Multichannel Mix" } 
			"sndlist"	{ append msg "Soundlisting " } 
		}
		append msg "Files On The Workspace"
		Inf $msg
	}
}

#------ Attempt to swap names of several files

proc SwapChFileNames {} {
	global wl chlist ch chcnt pa last_mix evv
	global sl_real background_listing dupl_mix dupl_vbx dupl_txt nessinit

	if {!$sl_real} {
		Inf "Swap Names Of Several Selected Files"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0
	set save_mixmanage 0
	set ilist [$wl curselection]							;#	get indices of selected files
	if {$ilist < 0} {
		Inf "No Files Selected On Workspace"
		return
	}
	if {[info exists nessinit]} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Name Swaps With Physical Modelling Files"
				return
			}
		}
	}
	if {![info exists chlist] || ([llength $ilist] <= 0)} {							
		Inf "No Chosen Files To Swap Names With"
		return
	}
	if {[llength $ilist] != [llength $chlist]} {							
		Inf "Must Have Same Number Of Selected Files As Files On Chosen List"
		return
	}
	foreach i $ilist {
		set fnamw [$wl get $i]
		lappend innames $fnamw
		foreach fnamch $chlist {
			if {[string match $fnamw $fnamch]} {
				Inf "The Selected Files Must All Be Different From The Files On The Chosen List"
				return
			}
		}
	}
	foreach fnamw $innames fnamch $chlist {

		if {$pa($fnamw,$evv(FTYP)) != $pa($fnamch,$evv(FTYP))} {
			if {!($pa($fnamw,$evv(FTYP)) & $evv(IS_A_TEXTFILE)) && ($pa($fnamch,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
				Inf "Files '$fnamw' And '$fnamch' Are Not Of The Same Type"
				return
			}
		}
	}
	set tempfnam $evv(DFLT_OUTNAME)
	foreach fnamw $innames fnamch $chlist {

		set haspmark0 [HasPmark $fnamw]
		set haspmark1 [HasPmark $fnamch]
		set hasmmark0 [HasMmark $fnamw]
		set hasmmark1 [HasMmark $fnamch]

		if {[info exists last_mix]} {
			if {[string match $fnamw $last_mix]} {
				set nulastmix $fnamch 
			} elseif {[string match $fnamch $last_mix]} {
				set nulastmix $fnamw
			}
		}
		if [catch {file rename $fnamw $tempfnam} zot] {
			Inf "Cannot Swap Filename '$fnamw'"
			catch {unset nulastmix}
			continue
		}
		if [catch {file rename $fnamch $fnamw} zot] {
			file rename $tempfnam $fnamw
			Inf "Cannot Swap Filenames '$fnamw' And '$fnamch'"
			catch {unset nulastmix}
			continue
		}
		if [catch {file rename $tempfnam $fnamch} zot] {
			file rename $fnamw $fnamch
			file rename $tempfnam $fnamw
			Inf "Cannot Swap Filenames '$fnamw' And '$fnamch'"
			catch {unset nulastmix}
			return
		}
		DataManage swap $fnamw $fnamch
		lappend couettelist $fnamw $fnamch
		UpdateBakupLog $fnamw modify 0
		UpdateBakupLog $fnamch modify 1
		CheckSwapMainmix $fnamw $fnamch
		CheckSwapMainmixSnd $fnamw $fnamch
		if {$haspmark0 && $haspmark1} {
			MovePmark $fnamw $tempfnam
			MovePmark $fnamch $fnamw 
			MovePmark $tempfnam $fnamch 
		} elseif {$haspmark0} {
			MovePmark $fnamw $fnamch
		} elseif {$haspmark1} {
			MovePmark $fnamch $fnamw
		}		
		if {$hasmmark0 && $hasmmark1} {
			MoveMmark $fnamw $tempfnam
			MoveMmark $fnamch $fnamw 
			MoveMmark $tempfnam $fnamch 
		} elseif {$hasmmark0} {
			MoveMmark $fnamw $fnamch
		} elseif {$hasmmark1} {
			MoveMmark $fnamch $fnamw
		}		
		UpdateChosenFileMemory $fnamch $fnamw
		set oldname_pos_on_chosen [LstIndx $fnamch $ch]
		RemoveFromChosenlist $fnamch
		set chlist [linsert $chlist $oldname_pos_on_chosen $fnamw]
		incr chcnt
		$ch insert $oldname_pos_on_chosen $fnamw
		set k [LstIndx $fnamw $wl]
		$wl delete $k
		$wl insert $k $fnamch
		set k [LstIndx $fnamch $wl]
		$wl delete $k
		$wl insert $k $fnamw

		RenameProps	$fnamw $tempfnam 1				
		RenameProps	$fnamch $fnamw 1				
		RenameProps	$tempfnam $fnamch  1				
		DummyHistory $fnamw "RENAMED_$fnamch"
		DummyHistory $fnamch "RENAMED_$fnamw"

		if {[IsInBlists $fnamw] && [IsInBlists $fnamch]} {
			if [RenameInBlists $fnamw $tempfnam] {
				set ren_blist 1
			}
			if [RenameInBlists $fnamch $fnamw] {
				set ren_blist 1
			}
			if [RenameInBlists $tempfnam $fnamch] {
				set ren_blist 1
			}
		} elseif {[IsInBlists $fnamw]} {
			if [RenameInBlists $fnamw $fnamch] {
				set ren_blist 1
			}
		} elseif {[IsInBlists $fnamch]} {
			if [RenameInBlists $fnamch $fnamw] {
				set ren_blist 1
			}
		}
		RenameOnDirlist $fnamw $tempfnam
		RenameOnDirlist $fnamch $fnamw
		RenameOnDirlist $tempfnam $fnamch
		if {$ren_blist} {
			SaveBL $background_listing
		}		
		if {[MixMSwap $fnamw $fnamch 0]} {
			set save_mixmanage 1
		}
	}
	if {[info exists couettelist]} {
		CouetteManage swap $couettelist
	}
	if {[info exists nulastmix]} {
		set last_mix $nulastmix
	}
	if {$save_mixmanage} {
		MixMStore
	}
	foreach i $ilist {
		$wl selection set $i
	}
}

proc GetPlayName {} {
	global play_pll2 nuuname playname_i

	set i [$play_pll2 curselection]
	if {$i < 0} {
		return
	}
	set playname_i $i
	set nuuname [file rootname [file tail [$play_pll2 get $i]]]
}

#--- If listing length changes, force scroll-bar length to adjust appropriately
#--- Params are text or scrolled_listbox, yscrollbar, xscrollbar + y and x dimensions
#--- Where there is no y(x) scrollbar, replace value by "0"

proc Scrollbars_Reset {ll yscr xscr y_cnt x_max} {
	global dl ww

#	RESET COORDINATES ON WHICH SCROLLING TAKES PLACE

	set listshown_height [$ll cget -height] 
	set listshown_width  [$ll cget -width] 
	set yfrac [expr double($listshown_height) / double($y_cnt)]
	set xfrac [expr double($listshown_width) / double($x_max)]
	if {![string match $yscr "0"]} {
		$yscr set 0.0 $yfrac
	}
	if {![string match $xscr "0"]} {
		$xscr set 0.0 $xfrac
	}

#	FORCE SCROLLBAR TO RECALC ITS POSITION
#	Using 2 different yview command Forcs yview to recalc.
#	It would seem that a single cmd won't do this, if yview already at position specified in command,
#	vwait command is necessary to ensure that both calcs are made!!

	if {![string match $xscr "0"]} {
		$ll xview moveto 1.0
		set x 0
		after 1 {set x 1}
		vwait x
		$ll xview moveto 0.0
	}
	if {![string match $yscr "0"]} {
		$ll yview moveto 1.0
		set x 0
		after 1 {set x 1}
		vwait x
		$ll yview moveto 0.0
	}
}

#-----Rename by overwriting Chosen file(s)

proc OverwriteRename {} {
	global wl ch chlist chcnt pa scores_refresh rememd wstk evv
	global background_listing wstk scores_refresh renam dupl_mix dupl_vbx dupl_txt nessinit

	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set scores_refresh 0
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Workspace Files Selected"
		return
	}
	if [info exists nessinit] {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Name Overwrites With Physical Modelling Files"
				return
			}
		}
	}
	if {[llength $ilist] != $chcnt} {
		Inf "Number Of Selected Files Not Same As Number Of Chosen-List Files"
		return
	}
	if [info exists nessinit] {
		foreach fnam $chlist {
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Name Overwrites With Physical Modelling Files"
				return
			}
		}
	}
	set queried 0
	foreach i $ilist chfnam $chlist {
		set fnam [$wl get $i]
		if {$pa($chfnam,$evv(FTYP)) != $pa($fnam,$evv(FTYP))} {
			set OK 0
			if {[IsAMixfile $pa($chfnam,$evv(FTYP))] && [IsAMixfile $pa($fnam,$evv(FTYP))]} {
				set OK 1
			}
			if {[IsASndlist $pa($chfnam,$evv(FTYP))] && [IsASndlist $pa($fnam,$evv(FTYP))]} {
				set OK 1
			}
			if {[IsANormdBrkfile $pa($chfnam,$evv(FTYP))] && [IsANormdBrkfile $pa($fnam,$evv(FTYP))]} {
				set OK 1
			}
			if {!$OK && !$queried} {
				set msg "Data-Type Of Selected File '$fnam' Does Not Tally With That Of '$chfnam'.\n\n"
				append msg "Force Rename Anyway ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					return
				} else {
					if {[llength $chlist] > 1} {
						set msg "Force Rename Of All Files ??\n"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							set queried 1
						} else {
							return
						}
					} else {
						set msg "Are You Sure ??\n"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							set queried 1
						} else {
							return
						}
					}
				}
			}
		}
		lappend nufnams $chfnam
		lappend origfnams $fnam
	}
	foreach fnam $origfnams {
		foreach nufnam $nufnams {
			if {[string match $fnam $nufnam]} {
				Inf "Some Selected Files Are The Same As Some Of The Chosen Files: Cannot Proceed."
				return
			}
		}
	}
	set save_mixmanage 0
	set ren_blist 0
	set are_snds 0
	foreach nufnam $nufnams fnam $origfnams {
		set is_snd 0
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set is_snd 1
		}
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]
		set newname_pos_on_chosen [LstIndx $nufnam $ch]
		if [catch {file rename -force $fnam $nufnam} zorg] { ;#	Force existing file to be OVERWRITTEN
			Inf "Cannot Remove Existing Workspace File '$nufnam'"
			continue
		} else {
			DataManage rename $fnam $nufnam
			lappend couettelist $fnam $nufnam
			UpdateBakupLog $fnam delete 0
			UpdateBakupLog $nufnam modify 1
			CheckMainmix $fnam $nufnam
			CheckMainmixSnd $fnam $nufnam
			DummyHistory $nufnam "OVERWRITTEN"
			if {[info exists mixmanage($nufnam)]} {
				unset mixmanage($nufnam)
				set save_mixmanage 1
			}
			catch {unset rememd}
			AddNameToNameslist [file tail $nufnam] 0
			if [IsInBlists $nufnam] {
				set msg "The Overwritten File '$nufnam' Was Mentioned In Background Listings\n\nRemove Those Mentions ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "yes"} {
					if [RemoveFromBLists $nufnam] {
						set ren_blist 1
					}
				}
			}
			if [IsOnScore $nufnam] {
				set msg "The Overwritten File '$nufnam' Is In Use On Current Score\n\nRemove It ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "yes"} {
					RemoveFromScore $nufnam
					set scores_refresh 1
				}
			} elseif {$is_snd} {
				set scores_refresh 1
			}
		}
		set i [LstIndx $fnam $wl]
		$wl delete $i								;#	Just delete old filename from workspace
													;#	(Later rename props of old to newname)
		WkspCnt $nufnam -1							;# 	File overwritten, but origname file disappears!
		RenameProps	$fnam $nufnam 1				;#	thus deleting props of any overwritten file
		DummyHistory $fnam "RENAMED_$nufnam"
		if {[MixMRename $fnam $nufnam 0]} {
			set save_mixmanage 1
		}
		if {$haspmark} {
			MovePmark $fnam $nufnam
		}
		if {$hasmmark} {
			MoveMmark $fnam $nufnam
		}
		if [IsInBlists $fnam] {
			if [RenameInBlists $fnam $nufnam] {
				set ren_blist 1
			}
		}
		if [IsOnScore $fnam] {
			RenameOnScore $fnam $nufnam
		}
		if {$is_snd} {
			set are_snds 1
		}
		AddNameToNameslist [file tail $nufnam] 0
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}		
	if {$are_snds} {
		set scores_refresh 1
	}
	catch {unset rememd}
	foreach fnam $nufnams {
		set i [LstIndx $fnam $wl]
		if {$i >= 0} {
			lappend xxlist $i
		}
	}
	if {[info exists xxlist]} {
		$wl selection clear 0 end
		foreach i $xxlist {
			$wl selection set $i
		}
	}
	set renam 1
	foreach i $ilist {
		$wl selection set $i
	}
}

#------ Sort listing (e.g. workspace) into filetype (and then alphabetical) order
	
proc MoveListingType {listing typ} {
	global pa rememd evv tosomewhere wl

	if {[string match $listing $wl]} {
		catch {unset tosomewhere}
	}
	foreach fnam [$listing get 0 end] {			;# Sort files into types
		if {![info exists pa($fnam,$evv(FTYP))]} {
			continue
		} else {
			set ftype $pa($fnam,$evv(FTYP))
			switch -regexp -- $ftype \
				^$evv(SNDFILE)$		  	{ lappend sndlist $fnam } \
				^$evv(ANALFILE)$ 	 	{ lappend analist $fnam } \
				^$evv(PITCHFILE)$    	{ lappend pchlist $fnam } \
				^$evv(TRANSPOSFILE)$ 	{ lappend trnlist $fnam } \
				^$evv(FORMANTFILE)$  	{ lappend fmtlist $fnam } \
				^$evv(ENVFILE)$ 	 	{ lappend envlist $fnam } \
				^$evv(PSEUDO_SND)$		{ lappend pseudo  $fnam } \
				default 			 	{ lappend txtlist $fnam }

		}
	}
	if [regexp {^[bpekmq]$} $typ] {				;# Sort out special types of textfiles, where necessary
		if {[info exists txtlist]} {
			foreach fnam $txtlist {
				set got 0
				switch -- $typ {
					"b" {
						if {[IsABrkfile $pa($fnam,$evv(FTYP))]} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"p" {
						if {($pa($fnam,$evv(FTYP)) != $evv(MIX_MULTI)) && ($pa($fnam,$evv(FTYP)) & $evv(IS_A_P_OR_T_BRK))} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"e" {
						if {[IsANormdBrkfile $pa($fnam,$evv(FTYP))] \
						 || ($pa($fnam,$evv(FTYP)) & $evv(IS_A_DB_BRKFILE))} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"k" {
						set ftyp $pa($fnam,$evv(FTYP))
						if {[IsASndlist $ftyp]} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"m" {
						set ftyp $pa($fnam,$evv(FTYP))
						if {[IsAMixfile $ftyp]} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
					"q" {
						set ftyp $pa($fnam,$evv(FTYP))
						if {$ftyp == $evv(MIX_MULTI)} {
							lappend sublist $fnam
						} else {
							lappend subtext $fnam
						}
					}
				}
			}
			if [info exists subtext] {
				set txtlist $subtext
			} else {
	 			catch {unset txtlist}
			}
		}
	}											;#	establish sorting order (& check if sort necessary)
	switch -- $typ {							
		"t" {
			if {![info exists sndlist] && ![info exists analist] && ![info exists pchlist] && ![info exists trnlist] \
			&& ![info exists fmtlist] && ![info exists envlist] && ![info exists pseudo]} {
				Inf "There Are No Soundsystem Files On The Workspace"
			} else {
				set sortlist {}
				if {[info exists sndlist]} {
					set sortlist [concat $sortlist $sndlist]
				}
				if {[info exists analist]} {
					set sortlist [concat $sortlist $analist]
				}
				if {[info exists pchlist]} {
					set sortlist [concat $sortlist $pchlist]
				}
				if {[info exists trnlist]} {
					set sortlist [concat $sortlist $trnlist]
				}
				if {[info exists fmtlist]} {
					set sortlist [concat $sortlist $fmtlist]
				}
				if {[info exists envlist]} {
					set sortlist [concat $sortlist $envlist]
				}
				if {[info exists pseudo]} {
					set sortlist [concat $sortlist $pseudo]
				}
			}
		}
		"s" {
			if {![info exists sndlist]} {
				Inf "There Are No Sound Files On The Workspace"
			} else {
				set sortlist $sndlist
			}
		}
		"T" {
			if {![info exists txtlist]} {
				Inf "There Are No Text Files On The Workspace"
			} else {
				set sortlist $txtlist
			}
		}
		"a" {
			if {![info exists analist]} {
				Inf "There Are No Analysis Files On The Workspace"
			} else {
				set sortlist $analist
			}
		}
		"f" {
			if {![info exists fmtlist]} {
				Inf "There Are No Formant Files On The Workspace"
			} else {
				set sortlist $fmtlist
			}
		}
		"p" {
			if {![info exists pchlist] && ![info exists trnlist] && ![info exists sublist]} {
				Inf "There Are No Pitch Or Transposition Files On The Workspace"
			} else {
				set sortlist {}
				if {[info exists pchlist]} {
					set sortlist [concat $sortlist $pchlist]
				}
				if {[info exists trnlist]} {
					set sortlist [concat $sortlist $trnlist]
				}
				if {[info exists sublist]} {
					set sortlist [concat $sortlist $sublist]
				}
			}
		}
		"e" {
			if {![info exists envlist] && ![info exists sublist]} {
				Inf "There Are No Envelope Files On The Workspace"
			} else {
				set sortlist {}
				if {[info exists envlist]} {
					set sortlist [concat $sortlist $envlist]
				}
				if {[info exists sublist]} {
					set sortlist [concat $sortlist $sublist]
				}
			}
		}
		"m" {
			if {![info exists sublist]} {
				Inf "There Are No Mix Files On The Workspace"
			} else {
				set sortlist $sublist
			}
		}
		"q" {
			if {![info exists sublist]} {
				Inf "There Are No Multichan Mix Files On The Workspace"
			} else {
				set sortlist $sublist
			}
		}
		"k" {
			if {![info exists sublist]} {
				Inf "There Are No Soundfile-Listing Files On The Workspace"
			} else {
				set sortlist $sublist
			}
		}
		"b" {
			if {![info exists sublist]} {
				Inf "There Are No Breakpoint Files On The Workspace"
			} else {
				set sortlist $sublist
			}
		}
	}
	if {![info exists sortlist] || ([llength $sortlist] <= 0)} {
		return
	}
	set final_list $sortlist
	foreach fnam [$listing get 0 end] {
		if {[lsearch -exact $sortlist $fnam] < 0} {
			lappend final_list $fnam
		}
	}
	$listing delete 0 end
	foreach fnam $final_list {
		$listing insert end $fnam
	}
	catch {unset rememd}
}

proc ToPlayWindow {y} {
	global wl pa evv snack_enabled snack_stereo

	set i [$wl nearest $y]
	if {$i < 0} {
		return
	} else {
		$wl selection clear 0 end
		$wl selection set $i
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	switch -regexp -- $ftyp \
		^$evv(ANALFILE)$ {
			SetSel2 view
			AnalysisDisplayOptions $fnam
		} \
		^$evv(SNDFILE)$ {
			SetSel2 view
			if {$snack_enabled && (($pa($fnam,$evv(CHANS)) == 1) || $snack_stereo)} {
				SnackDisplay 0 $evv(SN_FROM_WKSP_NO_OUTPUT) 0 0
			} else {
				PlayWindow
			}
		} \
		^$evv(PSEUDO_SND)$	 {
			Inf "PSUEDO-SOUNDFILE"
		} \
		^$evv(PITCHFILE)$	{
			Inf "BINARY PITCH DATA: Use 'Edit Pitchfile' On Process Page To View"
		} \
		^$evv(TRANSPOSFILE)$ {
			Inf "BINARY TRANSPOSITION DATA"
		} \
		^$evv(FORMANTFILE)$	 {
			Inf "BINARY FORMANT DATA"
		} \
		^$evv(ENVFILE)$	{
			Inf "BINARY ENVELOPE DATA"
		} \
		default {
			SimpleDisplayTextfile $fnam
		}
}
	
proc Sound_Keep {last} {
	global ch chlist chcnt pr_chkeep chfilestokeep evv

	if {![info exists chlist]} {
		Inf "No Chosen Files To Select"
		return
	}
	set len [llength $chlist]
	if {$len <= 0} {
		Inf "No Chosen Files To Select"
		return
	}
	set f .ch_keep
	if [Dlg_Create $f "KEEP SOME CHOSEN FILES" "set pr_chkeep 0" -borderwidth $evv(BBDR)] {
		button $f.ok -text "Keep Files" -command "set pr_chkeep 1" -width 10 -highlightbackground [option get . background {}]
		label $f.lab -text "How many files"
		entry $f.e -textvariable chfilestokeep -width 6
		button $f.quit -text "Abandon" -command "set pr_chkeep 0" -width 10 -highlightbackground [option get . background {}]
		pack $f.ok $f.lab $f.e $f.quit -side left -padx 1
		bind $f <Return> {set pr_chkeep 1}
		bind $f <Escape> {set pr_chkeep 0}
	}
	if {$last==2} {
		$f.lab config -text "Which File ?"
	} else {
		$f.lab config -text "How many files ?"
	}
	set chfilestokeep 1
	set pr_chkeep 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_chkeep $f.e
	while {!$finished} {
		raise $f
		tkwait variable pr_chkeep
		if {$pr_chkeep} {				  						
			if {![IsNumeric $chfilestokeep] || ($chfilestokeep <= 0)} {
				if {$last == 2} {
					Inf "Invalid File Number"
				} else {
					Inf "Invalid Number Of Files To Keep"
				}
				continue
			}
			set qq [expr int(round($chfilestokeep))]
			if {$last == 2} {
				if {$qq < 1} {
					Inf "Invalid File Number"
					continue
				} elseif {$qq > $len} {
					Inf "Invalid File Number (max $len)"
					continue
				} else {
					set nulist [lindex $chlist [expr $qq - 1]]
				}
			} elseif {$last == 3} {
				if {$qq < 1} {
					Inf "Invalid File Number"
					continue
				} elseif {$qq >= $len} {
					Inf "Invalid File Number (max $len)"
					continue
				} else {
					catch {unset nulist}
					set n [expr $len - $qq]
					set thislist $chlist
					set len [llength $thislist]
					while {$n > 0} {
						set k [expr int(floor(rand() * double($len)))]
						set thislist [lreplace $thislist $k $k]
						set len [llength $thislist]
						incr n -1
					}
					set nulist $thislist
				}
			} else {
				if {$qq < 1} {
					Inf "Too Few Files To Keep"
					continue
				} elseif {$qq > $len} {
					Inf "Too Many Files To Keep"
					continue
				} elseif {$qq == $len} {
					Inf "This Would Keep All The Files"
					continue
				}
				if {$last} {
					set qq [expr $len - $qq]
					set nulist [lrange $chlist $qq end]
				} else {
					incr qq -1
					set nulist [lrange $chlist 0 $qq]
				}
			}
			DoChoiceBak
			ClearWkspaceSelectedFiles
			foreach fnam $nulist {
				lappend chlist $fnam		;#	add to end of list
				$ch insert end $fnam		;#	add to end of display
				incr chcnt
			}
			ChlistDupls
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc SearchWorkspaceForDirFile {} {
	global dl wl total_wksp_cnt
	set i [$dl curselection]
	if {![info exists i] || ($i < 0) || ([llength $i] <= 0)} {
		Inf "No Item Selected"
		return
	} elseif {[llength $i] > 1} {
		Inf "Select A Single File"
		return
	}
	set dirfile [$dl get $i]
	set i 0
	foreach fnam [$wl get 0 end] {
		if {[string match $fnam $dirfile]} {
			$wl selection clear 0 end
			$wl selection set $i
			$wl yview moveto [expr double($i)/double([$wl index end])]
			return 1
		}
		incr i
	}
	Inf "The File '$dirfile' Is Not On The Workspace"
	return 0
}

proc TellHarmony {} {
	set msg "TONAL HARMONY WORKSHOP\n"
	append msg "\n"
	append msg "Enter standard tempered-scale notes.\n"
	append msg "Play the resulting chord.\n"
	append msg "Perform Harmonic Manipulations on Note-Sets.\n"
	append msg "Listen.\n"
	append msg "\n"
	append msg "FREE HARMONY WORKSHOP\n"
	append msg "\n"
	append msg "Enter Frequency (and possibly amplitude) data.\n"
	append msg "(This can be from a previously saved datafile\n"
	append msg "hilighted on Workspace).\n"
	append msg "Perform Data manipulations, including pitch drift.\n"
	append msg "Listen. Save sound or data."
	Inf $msg
}

proc TellClean {} {
	set msg "CLEANING KIT\n\n"
	append msg "Remove Unwanted Elements From Sound Spectrum at Specified Times. (MONO FILES ONLY)\n\n"
	append msg "1) Clean General Noise:    Remove persistent & stable noise-background.\n"
	append msg "2) Gate Out Bad Signal:     Replace Unwanted signal,  at specified times, with silence.\n"
	append msg "3) Cut Away Bad Signal:    Cut out and discard areas of bad signal, joining up the remaining sound.\n"
	append msg "4) Reinsert Original:         Mix original signal back into cleaned version, at specified times.\n"
	append msg "5) Remove Blemishes:\n"
	append msg "       a) Pitch In Signal:             Remove background Pitched element at specified time, from pitched foreground.\n"
	append msg "       b) Sound Under Sibilant: Remove pitched or unpitched sound below sibilant.\n"
	append msg "       c) Noise Above Signal:      Remove noise blemish at particular times.\n"
	append msg "       d) Low Freq Problem:       Remove low frequency intrusions.\n"
	append msg "       e) Subtract Spectrum:     Remove intrusion by subtracting spectrum.\n"
	append msg "       f) Graft Seg Elsewhere:  Graft a segment of source over another area of source.\n"
	append msg "       g) Insert Silence:              Insert silent gap into sound.\n"
	append msg "       h) Attenuate Level:            Reduce level of source at specific times.\n"
	append msg "       i) Dovetail Ends:                Dovetail either or both ends of source.\n"
	Inf $msg
}

#------ Add files to a textlisting of workspace files

proc ChangeDirInFile {} {
	global wl pa wstk wksp_dirname evv

	if {![info exists wksp_dirname] || ([string length $wksp_dirname] <= 0)} {
		Inf "No New Directory Name Given"
	}
	set ilist [$wl curselection]
	if {[llength $ilist] != 1} {
		Inf "Select Just One Existing Textfile"
		return
	}
	set fnam [$wl get [lindex $ilist 0]]
	if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)) || ($pa($fnam,$evv(ALL_WORDS)) != $pa($fnam,$evv(LINECNT)))} {
		Inf "'$fnam' Is Not An Appropriate File For This Process"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		set line [split $line]
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] > 0} {
				set nufile [file tail $item]
				set nufile [file join $wksp_dirname $nufile]
				if {![file exists $nufile]} {
					Inf "The Newly Created Name '$nufile' Is Not The Name Of An Existing File"
					close $zit
					return
				}
				lappend nufiles $nufile
			}
		}
	}
	close $zit
	if {![info exists nufiles]} {
		Inf "No New (Valid) Filenames Created"
		return
	}
	set orig_fnam $fnam
	if [catch {open $evv(DFLT_TMPFNAME) w} zit] {
		Inf "Cannot Open Temporary File To Save New Filenames"
		return
	}
	foreach fnam $nufiles {
		puts $zit $fnam
	}
	close $zit
	if [catch {file delete $orig_fnam} zit] {
		Inf "Cannot Delete The Original File Listing"
		catch {file delete $evv(DFLT_TMPFNAME)}
		return
	}
	if [catch {file rename $evv(DFLT_TMPFNAME) $orig_fnam} zit]  {
		Inf "Cannot Save The New Listing Of Files\n\nOriginal Listing Is Also Lost"
		catch {file delete $evv(DFLT_TMPFNAME)}
		return
	}
	set a $pa($orig_fnam,$evv(FTYP))
	set a [expr $a | $evv(SNDLIST)]
	set pa($orig_fnam,$evv(FTYP)) $a
	Inf "File Directory Of Listed Files Has Been Changed"
}

#----- Hilite any soundsources in mixfile which are on wkspace

proc Hilite_MixSrcs {} {
	global wl pa sl_real evv

	if {!$sl_real} {
		Inf "If You Have Highlighted A Mixfile On The Workspace Window,\nYou Can Hilite All The Soundfiles It Uses, If They Are On The Workspace."
		return
	}

	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[info exists pa($fnam,$evv(FTYP))]} {
			set ftyp $pa($fnam,$evv(FTYP))
			if {[IsAMixfileIncludingMultichan $ftyp]} {
				set mfile $fnam
				break
			}
		}
	}
	if {![info exists mfile]} {
		Inf "No Mixfile Has Been Selected"
		return
	}
	if [catch {open $mfile "r"} Ifd] {
		Inf "Cannot Open File '$mfile'"
		return
	}
	set files_grabbed 0
	while {[gets $Ifd line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if [string match [string index $line 0] ";"] {
			continue
		}
		set line [split $line]
		foreach item $line {
			if {[string length $item] > 0} {
				set item [RegulariseDirectoryRepresentation $item]
				set i [LstIndx $item $wl]
				if {$i >= 0} {
					lappend hilist $i
				}
				break					
			}
		}
	}
	catch {close $Ifd}
	if {![info exists hilist]} {
		Inf "None Of The Soundfiles In '$mfile' Are On The Workspace"
		return
	}
	$wl selection clear 0 end
	foreach i $hilist {
		$wl selection set $i
	}
}

proc WkspaceSelectionSave {} {
	global was_selected wl
	set ilist [$wl curselection]
	if {$ilist == -1} {
		Inf "No Workspace Files Selected"
		return
	}
	set was_selected {}
	foreach i $ilist {
		lappend was_selected [$wl get $i]
	}
}

proc WkspaceSelectionRecall {} {
	global was_selected wl

	if {[llength $was_selected] <= 0} {
		Inf "No Workspace File Selection Remembered"
		return
	}
	foreach fnam $was_selected {
		set i [LstIndx $fnam $wl]
		if {$i >= 0} {
			lappend ilist $i
		} else {
			lappend badlist $fnam
		}
	}
	if {![info exists ilist]} {
		Inf "None Of The Previously Selected Files Is Still On The Workspace"
		return
	} elseif {[info exists badlist]} {
		set msg "The Following Previously Selected Files Are No Longer On The Workspace\n\n"
		set cnt 0
		foreach fnam $badlist {
			incr cnt
			if {$cnt > 20} {
				append msg "\n\nAnd More"
				break
			}
			append msg $fnam "  "
		}
		Inf $msg
	}
	$wl selection clear 0 end
	foreach i $ilist {
		$wl selection set $i
	}
}

proc SortFlistByDate {flist} {

	foreach fnam $flist {
		set abstime [AbsTimeFromDate $fnam]
		lappend sortlist [list $abstime $fnam]
	}
	set len [llength $sortlist]
	set len_less_one [expr $len - 1]
	set n 0
	while {$n < $len_less_one} {
		set date_n [lindex $sortlist $n]
		set time_n [lindex $date_n 0]
		set m $n
		incr m
		while {$m < $len} {
			set date_m [lindex $sortlist $m]
			set time_m [lindex $date_m 0]
			if {$time_n > $time_m} {
				set sortlist [lreplace $sortlist $n $n $date_m]
				set sortlist [lreplace $sortlist $m $m $date_n]
				set date_n $date_m
				set time_n $time_m
			}
			incr m
		}
		incr n
	}
	foreach date $sortlist {
		lappend outlist [lindex $date 1]
	}
	return $outlist
}

proc AbsTimeFromDate {date} {

	set date [file tail $date]
	set year [string range [file extension $date] 1 end]
	set time [file rootname $date]
	set time [split $time "_"]
	set date [lindex $time 1]
	set month [GetDateVal [string range $date 0 2]]
	set day   [string range $date 3 end]
	if {[string length $day] < 2} {
		set zz "0"
		append zz $day
		set day $zz
	}
	set time [lindex $time 2]
	set time [split $time "-"]
	set hour [lindex $time 0]
	if {[string length $hour] < 2} {
		set zz "0"
		append zz $hour
		set hour $zz
	}
	set min  [lindex $time 1]
	if {[string length $min] < 2} {
		set zz "0"
		append zz $min
		set min $zz
	}
	set sec  [lindex $time 2]
	if {[string length $sec] < 2} {
		set zz "0"
		append zz $sec
		set sec $zz
	}
	set val $year
	append val $month $day $hour $min $sec
	return $val
}

proc GetDateVal {month} {
	switch -- $month {
		"Jan" {return 01}
		"Feb" {return 02}
		"Mar" {return 03}
		"Apr" {return 04}
		"May" {return 05}
		"Jun" {return 06}
		"Jul" {return 07}
		"Aug" {return 08}
		"Sep" {return 09}
		"Oct" {return 10}
		"Nov" {return 11}
		"Dec" {return 12}
	}
}

proc KeepPlayNameHilite {} {
	global play_pll2 playname_i
	if {$playname_i >= 0} {
		$play_pll2 selection set $playname_i
	}
}

proc RemoveEndChars {start} {
	global sl_real wl pa background_listing wstk pr_rendch endchdel chlist ch chcnt evv dupl_mix dupl_vbx dupl_txt nesstype nessorig

	catch {unset nessorig}
	if {!$sl_real} {
		Inf "Selected Files Can Have N Characters Removed"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0

	set g .endchdel
	if [Dlg_Create $g "REMOVE END CHARACTERS" "set pr_rendch 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gi [frame $g.indx -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_rendch 0" -highlightbackground [option get . background {}]
		button $gn.ok -text OK -width 6 -command "set pr_rendch 1" -highlightbackground [option get . background {}]
		pack $gn.ok -side left
		pack $gn.b -side right
		label $gi.l -text "Number of end chars to remove" -width 30
		entry $gi.e -width 20 -textvariable endchdel
		pack $gi.l $gi.e -side left
		pack $g.name -side top -fill x -expand true
		pack $g.indx -side top
		wm resizable $g 1 1
		bind $g <Return> {set pr_rendch 1}
		bind $g <Escape> {set pr_rendch 0}
	}
	if {$start} {
		wm title $g "REMOVE START CHARACTERS"
		$g.indx.l config -text "Number of start chars to remove"
	} else {
		wm title $g "REMOVE END CHARACTERS"
		$g.indx.l config -text "Number of end chars to remove"
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		destroy $g
		return
	}

	set endchdel ""
	set rename_cnt 0 
	set finished 0
	set pr_rendch 0
	raise $g
	My_Grab 0 $g pr_rendch $g.indx.e
	while {!$finished} {
		tkwait variable pr_rendch
		if {!$pr_rendch} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			if {![regexp {^[0-9]+$} $endchdel] || ($endchdel < 1)} {
				Inf "No Valid Number Of Characters-For-Deletion Entered"
				continue
			}
			catch {unset nufnams}
			set OK 1
			foreach i $ilist {
				set fnam [$wl get $i]								;#	get each selected file
				set fext [file extension $fnam]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				set fnam [file rootname [file tail $fnam]]
				set len [string length $fnam]
				if {$len <= $endchdel} {
					Inf "Name '$origfnam' Is Too Short To Delete $endchdel Characters"
					set OK 0
					break
				}
				set len [expr $len - $endchdel]
				incr len -1
				if {$start} {
					set fnam [string range $fnam $endchdel end]
				} else {
					set fnam [string range $fnam 0 $len]
				}
				if {![ValidCDPRootname $fnam]} {
					set OK 0
					break
				}
				set fnam $fnam$fext
				set fnam [file join $fdir $fnam]
				if {[file exists $fnam] && ![file isdirectory $fnam]} {
					Inf "A File With The Name '$fnam' Already Exists"
					set OK 0
					break
				}
				lappend nufnams $fnam
			}
			if {!$OK} {
				break
			}

			set rename_cnt 0
			set save_mixmanage 0
			set nessupdate 0
			foreach i $ilist nufnam $nufnams {
				set origfnam [$wl get $i]								;#	get each selected file
				set haspmark [HasPmark $origfnam]
				set hasmmark [HasMmark $origfnam]
				if [catch {file rename $origfnam $nufnam} zub] {
					Inf "Cannot Rename File '$origfnam' To '$nufnam'"
				} else {
					DataManage rename $origfnam $nufnam
					lappend couettelist $origfnam $nufnam
					UpdateBakupLog $origfnam delete 0
					UpdateBakupLog $nufnam create 1
					CheckMainmix $origfnam $nufnam
					CheckMainmixSnd $origfnam $nufnam
					$wl delete $i								
					$wl insert $i $nufnam
					UpdateChosenFileMemory $origfnam $nufnam
					set oldname_pos_on_chosen [LstIndx $origfnam $ch]
					if {$oldname_pos_on_chosen >= 0} {
						RemoveFromChosenlist $origfnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $nufnam
					}
					RenameProps	$origfnam $nufnam 1				
					DummyHistory $origfnam "RENAMED_$nufnam"
					if {[MixMRename $origfnam $nufnam 0]} {
						set save_mixmanage 1
					} elseif {[NessMRename $origfnam $nufnam 0]} {
						set nessupdate 1
					}
					if {$haspmark} {
						MovePmark $origfnam $nufnam
					}
					if {$hasmmark} {
						MoveMmark $origfnam $nufnam
					}
					if [IsInBlists $origfnam] {
						if [RenameInBlists $origfnam $nufnam] {
							set ren_blist 1
						}
					}
					if [IsOnScore $origfnam] {
						RenameInScore $origfnam $nufnam
					}
					RenameOnDirlist $origfnam $nufnam
					incr rename_cnt
				}
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			if {$rename_cnt} {
				if {$save_mixmanage} {
					MixMStore
				}
				if {$nessupdate} {
					NessMStore
				}
				catch {unset rememd}
				set finished 1
			} else {
				Inf "No Files Have Been Renamed"
			}
		}
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
	return 1
}

proc RemoveFromChoiceBakup {fnam} {
	global last_ch lalast_ch
	if {[info exists lalast_ch]} {
		set k [lsearch $lalast_ch $fnam]
		if {$k >= 0} {
			set lalast_ch [lreplace $lalast_ch $k $k]
			if {[llength $lalast_ch] <= 0} {
				unset lalast_ch
			}
		}
	}
	if {[info exists last_ch]} {
		set k [lsearch $last_ch $fnam]
		if {$k >= 0} {
			set last_ch [lreplace $last_ch $k $k]
			if {[llength $last_ch] <= 0} {
				if {[info exists lalast_ch]} {
					set last_ch $lalast_ch
					unset lalast_ch
				} else {
					unset last_ch
				}
			}
		}
	}
}

proc LastChoiceRedundancy {} {
	global last_ch lalast_ch chlist

	if {[info exists last_ch] && [info exists lalast_ch] && ([llength $last_ch] == [llength $chlist])} {
		set allmatch 1
		foreach fnam $chlist {
			if {[lsearch $last_ch $fnam] < 0} {
				set allmatch 0
				break
			}
		}
		if {$allmatch} {
			set last_ch $lalast_ch
			unset lalast_ch
		} 
	}
}

proc MACdisclaimer {} {
	global newmac cutmac evv
	catch {unset newmac}
	set fnam [file join $evv(CDPRESOURCE_DIR) newmac$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		Welcome9

		if {![info exists cutmac]} {
			set newmac 1
			if {![catch {open $fnam "w"} zit]} {
				puts $zit $newmac
				close $zit
			}
		}
	} else {
		if {![catch {open $fnam "r"} zit]} {
			gets $zit newmac
			close $zit
		}
		if {[info exists newmac] && ($newmac == 0)} {
			unset newmac
		}
	}
}

proc MACMessage {val} {
	global newmac evv
	if {![info exists newmac]} {
		return
	}
	if {($newmac > $val) || ($newmac == 0)} {
		return
	}
	switch -- $val {
		1 {
			set msg    "            SPECIAL MESSAGE FOR MAC USERS\n"
			append msg "\n"
			append msg "Most Sound Loom windows appear\n"
			append msg "one at a time on the screen.\n"
			append msg "\n"
			append msg "They cannot be resized.\n"
			append msg "\n"
			append msg "You can use the yellow button on the top right\n"
			append msg "(as normally) to shrink the windows into the icon bar.\n"
			append msg "\n"
			append msg "However, in some situations,\n"
			append msg "(e.g. using the 'Calculator') a 2nd window appears\n"
			append msg "on top of the first.\n"
			append msg "\n"
			append msg "The upper window must be closed\n"
			append msg " before the calling window can be accessed again.\n"
			append msg "\n"
			append msg "If you shrink the upper window into the icon bar\n"
			append msg "you will not be able to use the calling window.\n"
			append msg "\n"
			Inf $msg
			set msg    "            THIS IS THE SOUNDLOOM WORKSPACE\n"
			append msg "\n"
			append msg "* To get info in future, use 'New User Help' button. *\n"
			append msg "\n"
			append msg "The basic way to proceed is\n"
			append msg "LIST DIRECTORY(1/2) -> GRAB FILES TO WORKSPACE(3/4) ->\n"
			append msg "CHOSE FILES TO PROCESS(5/6) -> PROCESS(7)\n"
			append msg "as follows...\n"
			append msg "1) ENTER NAME OF DIRECTORY WHICH CONTAINS YOUR SOUNDS,\n"
			append msg "IN THE LONG BOX, AT UPPER RIGHT.\n"
			append msg "Sound Loom remembers directories you use, and you can\n"
			append msg "access these later, from the 'Find Dir' button.\n"
			append msg "You can also find ANY directory from here.\n"
			append msg "2) PRESS BUTTON 'List' JUST BELOW THE ENTRY BOX.\n"
			append msg "You should now see listing of files in directory.\n"
			append msg "3) CHOOSE FILES TO WORK WITH (HIGHLIGHT WITH MOUSE).\n"
			append msg "4) GO TO 'Grab' MENU, ON RIGHT: SELECT 'Use on Workspace'\n"
			append msg "You should now see your files listed in central panel,\n"
			append msg "which is the WORKSPACE. You can list many files \n"
			append msg "from many different directories on the Workspace.\n"
			append msg "Files you create will also be listed here (at the top).\n"
			append msg "Once you have files listed on the Workspace\n"
			append msg "they are automatically loaded here for your next session.\n"
			append msg "Now you need to choose a specific file to process.\n"
			append msg "5) PRESS THE 'Enter Chosen Files Mode' BUTTON (Left).\n"
			append msg "6) ON WORKSPACE, WITH MOUSE, CHOOSE A FILE TO WORK WITH.\n"
			append msg "File is now listed in 'Chosen Files' list, on left.\n"
			append msg "(You can work with several files, but for this demo\n"
			append msg "we suggest you use just one soundfile).\n"
			append msg "7) SELECT 'Process' (TOP LEFT)\n"
			append msg "\n"
			append msg "To get info on what ALL buttons on a page do...\n"
			append msg "Click 'Help', then click on any item.\n"
			append msg "Description appears at top of screen. To quit 'Help',\n"
			append msg "reclick button, now relabelled 'Quiet'.\n"
			Inf $msg
			incr newmac
		}
		2 {
			set msg "                THIS IS THE PROCESS PAGE\n"
			append msg "\n"
			append msg "* To get info in future, use 'New User Help' button. *\n"
			append msg "\n"
			append msg "1) The buttons are menus of CDP processes\n"
			append msg "   which you can apply to your chosen file.\n"
			append msg "   Only processes which will work with your chosen file(s)\n"
			append msg "   are activated.\n"
			append msg "   Inactive buttons have no text.\n"
			append msg "\n"
			append msg "2) Click on a button. We suggest you select 'Edit'\n"
			append msg "   A menu of processes will appear, on the left.\n"
			append msg "\n"
			append msg "3) Select a process from the menu\n"
			append msg "   (we suggest 'Cut Out and Keep').\n"
			append msg "\n"
			Inf $msg
			incr newmac
		}
		3 {
			set msg "           THIS IS THE PARAMETERS PAGE\n\n"
			append msg "* To get info in future, use 'New User Help' button. *\n"
			append msg "\n"
			append msg "1) Set values for the parameters of this process\n"
			append msg "   (if there are any), by typing in values, \n"
			append msg "   or moving the sliders.\n"
			append msg "   You can also create and use breakpoint files,\n"
			append msg "   if the 'Get File' and 'Make File' buttons \n"
			append msg "   appear in the parameter's display.\n"
			append msg "\n"
			append msg "2) To run the process, hit 'Run' button, on the left.\n"
			append msg "\n"
			Inf $msg
			incr newmac
		}
		4 {
			set msg "               THIS IS THE RUN PAGE\n\n"
			append msg "* To get info in future, use 'New User Help' button. **\n"
			append msg "\n"
			append msg "1) If there are any messages from the process,\n"
			append msg "   they appear here.\n"
			append msg "\n"
			append msg "2) Once process has finished, if there are no messages,\n"
			append msg "   you will return automatically to Parameters page.\n"
			append msg "   If there are messages, press 'OK' (which will appear)\n"
			append msg "   to return.\n"
			append msg "\n"
			append msg "3) While process is running, 'Run/OK' button is disabled.\n"
			append msg "\n"
			append msg "To proceed, click on the 'Run' button.\n"
			append msg "(If messages appear on display, button changes to 'OK').\n"
			append msg "\n"
			Inf $msg
			incr newmac
		}
		5 {
			set msg "         YOU HAVE NOW RETURNED TO THE PARAMETERS PAGE\n\n"
			append msg "* To get info in future, use 'New User Help' button. *\n"
			append msg "\n"
			append msg "1) If process has run succesfully, you can play the output.\n"
			append msg "   using the 'Play' button, which is now active.\n"
			append msg "\n"
			append msg "2) If you don't like what you hear,\n"
			append msg "   you can rerun the process with new parameters.\n"
			append msg "   If there are messages, press 'OK' (which will appear)\n"
			append msg "   to return.\n"
			append msg "\n"
			append msg "3) Once you have the output you want,\n"
			append msg "   you can press the 'Save As' button.\n"
			append msg "   Sound Loom ONLY keeps outfiles which you NAME here.\n"
			append msg "\n"
			append msg "4) After naming file, it will be placed on Workspace.\n"
			append msg "\n"
			append msg "5) Press 'Save As' and name the file, to proceed.\n"
			append msg "\n"
			append msg "6) Then return to Workspace, using 'To Wkspace' button.\n"
			append msg "\n"
			Inf $msg
			incr newmac
		}
	}
}

proc SaveIntroState {} {
	global newmac evv
	if {![info exists newmac]} {
		return
	}
# ??????? -->
	if {$newmac > 5} {
		set newmac 0
	}
# <-- ???????
	set fnam [file join $evv(CDPRESOURCE_DIR) newmac$evv(CDP_EXT)]
	if {![catch {open $fnam "w"} zit]} {
		puts $zit $newmac
		close $zit
	}
}

#------ Replace existing test with these definitive tests

proc IsAMixfile {ftyp} {
	global evv
	if {($ftyp & $evv(IS_A_MIXFILE)) && ($ftyp != $evv(WORDLIST))} {
		return 1
	}
	return 0
}

proc IsAMixfileIncludingMultichan {ftyp} {
	global evv
	if {($ftyp & $evv(IS_A_MIXFILE)) && ($ftyp != $evv(WORDLIST))} {
		return 1
	}
	if {$ftyp == $evv(MIX_MULTI)} {
		return 1
	}
	return 0
}

proc IsASndlist {ftyp} {
	global evv
	if {($ftyp & $evv(IS_A_SNDLIST)) && ($ftyp != $evv(IS_A_SYNCLIST))} {
		return 1
	}
	return 0
}

proc IsAListofNumbers {ftyp} {
	global evv
	if {($ftyp & $evv(IS_A_NUMLIST)) && ($ftyp != $evv(WORDLIST))} {
		return 1
	}
	return 0
}

#----- Functions for file renaming of TEXT files which are on the Workspace

proc RenameTextWkspaceFile {fnam nufnam} {
	global wl ch rememd

	set i [LstIndx $fnam $wl]
	if {$i < 0} {
		return 0
	}
	set oldname_pos_on_chosen [LstIndx $fnam $ch]
	if [catch {file rename -force $fnam $nufnam} zorg] {	;#	Force any existing file to be OVERWRITTEN
		Inf "Cannot Rename The File '$fnam'"
		return 0
	}
	UpdateBakupLog $fnam delete 0
	UpdateBakupLog $nufnam create 1
	CheckMainmix $fnam $nufnam
	if {[file exists $nufnam]} {
		set newname_pos_on_wkspce [LstIndx $nufnam $wl]
		set newname_pos_on_chosen [LstIndx $nufnam $ch]
		DummyHistory $nufnam "OVERWRITTEN"
		if {$newname_pos_on_wkspce >= 0} {				;#	If new filename was already on workspace
			$wl delete $i								;#	Just delete old filename from workspace
			WkspCnt $nufnam -1							;# 	File overwritten, but origname file disappears!
			UpdateChosenFileMemory $fnam $nufnam
			if {$oldname_pos_on_chosen >= 0} {
				if {$newname_pos_on_chosen >= 0} {			
					RemoveFromChosenlist $nufnam
					set oldname_pos_on_chosen [LstIndx $fnam $ch]
				}
				ChosRename $fnam $nufnam $oldname_pos_on_chosen
			} elseif {$newname_pos_on_chosen >= 0} {			
				RemoveFromChosenlist $nufnam
			}
		} else {
			DoTheRename $fnam $nufnam $i $oldname_pos_on_chosen
		}												;#	Rename props,
	} else {						  					;#	Valid name, and file doesn't exist
		DoTheRename $fnam $nufnam $i $oldname_pos_on_chosen
		RenameOnDirlist $fnam $nufnam
	}
	RenameProps	$fnam $nufnam 1							;#	thus deleting props of any overwritten file
	DummyHistory $fnam "RENAMED_$nufnam"
	catch {unset rememd}
	return 1
}

proc ChosRename {fnam nufnam oldname_pos_on_chosen} {
	global chlist chcnt ch

	RemoveFromChosenlist $fnam
	set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
	incr chcnt
	$ch insert $oldname_pos_on_chosen $nufnam
}

proc DoTheRename {fnam nufnam i oldname_pos_on_chosen} {
	global wl 
	$wl delete $i								
	$wl insert $i $nufnam						;#	rename workspace item
	UpdateChosenFileMemory $fnam $nufnam
	if {$oldname_pos_on_chosen >= 0} {
		ChosRename $fnam $nufnam $oldname_pos_on_chosen
	}
}

#---- Rename a temp non-snd file (therefore NOT ON WKSPACE) and put file on wkspace

proc RenameNonSoundTempFile {fnam nufnam pre_exists} {
	global wl ch rememd total_wksp_cnt rememd ww
	if {$pre_exists} {
		set newname_pos_on_wkspce [LstIndx $nufnam $wl]
		set newname_pos_on_chosen [LstIndx $nufnam $ch]
	}
	if {[file exists $nufnam]} {
		if [catch {file rename -force $fnam $nufnam} zorg] {	;#	If newname an existing file, forces it to be OVERWRITTEN
			return 0
		}
	} else {
		if [catch {file rename $fnam $nufnam} zorg] {
			return 0
		}
	}
	if {$pre_exists} {
		DummyHistory $nufnam "OVERWRITTEN"
		if {$newname_pos_on_wkspce >= 0} {				;#	If new filename was already on workspace
			if {$newname_pos_on_chosen >= 0} {			
				RemoveFromChosenlist $nufnam
			}
			RemoveFromChoiceBakup $nufnam
			PurgePropfilesList $nufnam
			PurgeArray $nufnam
			$wl delete $newname_pos_on_wkspce
			incr total_wksp_cnt -1
			ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
			catch {unset rememd}
		}
	} else {
		DummyHistory $nufnam "CREATED"
	}
	FileToWkspace $nufnam 0 0 0 0 1
	return 1
}

#--- Remove NON-SND file from listing if it has been deleted

proc RemoveNonSndFileFromWkspaceListing {fnam} {
	global wl ww total_wksp_cnt rememd
	set i [LstIndx $fnam $wl]
	if {$i < 0} {
		return
	}
	PurgePropfilesList $fnam
	PurgeArray $fnam
	RemoveFromChosenlist $fnam
	incr total_wksp_cnt -1
	$wl delete $i
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	catch {unset rememd}
}				

#---- Update textfile extensions to User defined extensions

proc RenameExt {touserdef} {
	global new_user_text_extensions user_text_extensions other_text_extensions wstk wl pa evv nessinit

	if {($touserdef == 1) && ![info exists new_user_text_extensions] && ![info exists user_text_extensions]} {
		Inf "No User Textfile Extensions Defined"
		return
	}
	set ilist [$wl curselection]
	if {$ilist < 0} {
		Inf "No Files Selected"
		return
	}
	if {[info exists nessinit]} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Alter File Extension Of Physical Modelling Files"
				return
			}
		}
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {![info exists pa($fnam,$evv(FTYP))]} {
			Inf "Cannot Get The Properties Of $fnam"
			continue
		}
		if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)} {
			if {[info exists nesstype($fnam)] || ([file extension $fnam] == $evv(NESS_EXT))} {
				continue
			}
			switch -- $touserdef {
				2 {
					if {![info exists other_text_extensions]} {
						lappend badfnams $fnam
					} else {
						foreach item $other_text_extensions {
							if {[string match [file extension $fnam] $item]} {
								lappend fnams $fnam
							} else {
								lappend badfnams $fnam
							}
						}
					}
				}
				1 {
					if {[string match [file extension $fnam] $evv(TEXT_EXT)]} {
						lappend fnams $fnam
					} elseif {([string match [file extension $fnam] [GetTextfileExtension mix]]) && ($pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI))} {
						lappend fnams $fnam		;#	FORCE MCHAN-MIXFILES WITH (false) "mix" EXTENSION TO TAKE "mmx"
					}
				}
				0 {
					if {[info exists new_user_text_extensions]} {
						foreach item $new_user_text_extensions {
							if {[string match [file extension $fnam] $item]} {
								lappend fnams $fnam
							}
						}
					} else {
						foreach item $user_text_extensions {
							if {[string match [file extension $fnam] $item]} {
								lappend fnams $fnam
							}
						}
					}
				}
			}
		}
	}
	if {![info exists fnams]} {
		switch -- $touserdef {
			1 {
				Inf "No Textfiles With '$evv(TEXT_EXT)' Extensions Selected"
				return
			} 
			0 {
				Inf "No Textfiles With User-Defined Extensions Selected"
				return
			}
		}
	}
	if {[info exists badfnams]} {
		set new_exts {}
		foreach fnam $badfnams {
			set thsext [file extension $fnam]
			if {[lsearch $new_exts $thsext] < 0} {
				lappend new_exts $thsext
			}
		}
		set dostore 0
		foreach thsext $new_exts  {
			set msg "Convert Files With Extension '$thsext' To '.txt', And Add '$thsext' To List Of Known Text-Data Extensions ?"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if {$choice == "yes"} {
				set dostore 1
				lappend other_text_extensions $thsext
				set len [llength $badfnams]
				set k 0
				while {$k < $len} {
					set thisfnam [lindex $badfnams $k]
					if {[string match [file extension $thisfnam] $thsext]} {
						lappend fnams $thisfnam
						set badfnams [lreplace $badfnams $k $k]
						if {[llength $badfnams] <= 0} {
							break
						}
						incr len -1
					} else {
						incr k
					}
				}
			}
			if {[llength $badfnams] <= 0} {
				break
			}
		}
		if {$dostore} {
			StoreOtherTxtExtensions
		}
	}
	if {$touserdef == 2} {
		set touserdef 0
	}
	set cnt 0
	set save_mixmanage 0
	foreach fnam $fnams {
		set nufnam [file rootname $fnam]
		if {$touserdef} {
			Block "Checking File Contents"
			set ftyp $pa($fnam,$evv(FTYP))
			if {[IsAMixfile $ftyp]} {
				append nufnam [GetTextfileExtension mix]
				if {[RenameTextWkspaceFile $fnam $nufnam]} {
					if {[MixMRename $fnam $nufnam 0]} {
						set save_mixmanage 1
					}
				}
				incr cnt
			} elseif {$ftyp == $evv(MIX_MULTI)} {
				append nufnam [GetTextfileExtension mmx]
				if {[RenameTextWkspaceFile $fnam $nufnam]} {
					if {[MixMRename $fnam $nufnam 0]} {
						set save_mixmanage 1
					}
				}
				incr cnt
			} elseif {[IsASndlist $ftyp]} {
				append nufnam [GetTextfileExtension sndlist]
				RenameTextWkspaceFile $fnam $nufnam
				incr cnt
			} elseif {[IsABrkfile $ftyp]} {
				append nufnam [GetTextfileExtension brk]
				RenameTextWkspaceFile $fnam $nufnam
				incr cnt
			} else {
				Inf "Possible Props File $fnam"
				if {[ThisIsAPropsFile $fnam 0 0]} {
					append nufnam [GetTextfileExtension props]
					RenameTextWkspaceFile $fnam $nufnam
					incr cnt
				}
			}
			UnBlock
		} else {
			append nufnam $evv(TEXT_EXT)
			RenameTextWkspaceFile $fnam $nufnam
			incr cnt
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	Inf "$cnt Files Renamed"
	foreach i $ilist {
		$wl selection set $i
	}
}

proc GetFloatStatus {} {
	global evv float_out
	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(FLOAT)$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		return 1
	}
	return 0
}

#------ Attempt to rename several selected workspace files with a generic name

proc Prefix {suffix} {
	global wl pr_prefix p_s_nuname chlist ch chcnt evv
	global background_listing pa scores_refresh sl_real dupl_mix dupl_vbx dupl_txt prefix_replace nesstype nessorig

	catch {unset nessorig}
	if {!$sl_real} {
		Inf "A Selected Set Of Files On The Workspace\nCan Be Given Prefix Or Suffix"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ilist [$wl curselection]
	set oilist $ilist
	if {([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {							
		Inf "No Item(s) Selected"
		return
	}
	set ren_blist 0
	set are_snds 0
	set save_mixmanage 0
	set nessupdate 0
	set g .prefix
	if [Dlg_Create $g "ADD PREFIX" "set pr_prefix 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set go [frame $g.other -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_prefix 0" -highlightbackground [option get . background {}]
		label $gn.l -text "Prefix" -width 12
		button $gn.ok -text OK -width 6 -command "set pr_prefix 1" -highlightbackground [option get . background {}]
		entry $gn.e -width 20 -textvariable p_s_nuname
		checkbutton $gn.rep -text "Replace Existing" -variable prefix_replace
		pack $gn.ok $gn.l $gn.e $gn.rep -side left
		pack $gn.b -side right
		pack $g.name $g.other -side top
		wm resizable $g 1 1
		bind $g <Return> {set pr_prefix 1}
		bind $g <Escape> {set pr_prefix 0}
	}
	set prefix_replace 0
	switch -- $suffix {
		0  {
			$g.name.l config -text "Prefix"
			wm title $g "ADD PREFIX"
		}
		1 {
			$g.name.l config -text "Suffix"
			wm title $g "ADD SUFFIX"
		}
		2 {
			$g.name.l config -text "Prefix from number"
			wm title $g "ADD NUMERIC PREFIX IN DATE ORDER"
		}
		3 {
			$g.name.l config -text "Suffix from number"
			wm title $g "ADD NUMERIC SUFFIX IN DATE ORDER"
		}
	}
	set p_s_nuname ""
	set finished 0
	set pr_prefix 0
	raise $g
	My_Grab 0 $g pr_prefix $g.name.e
	while {!$finished} {
		tkwait variable pr_prefix
		if {$pr_prefix} {
			if {$suffix < 2} {
				if {![ValidCDPRootname $p_s_nuname]} {
					continue
				}
				set p_s_nuname [string tolower $p_s_nuname]
				set cnt 0
			} else {
				if {![regexp {^[0-9]+$} $p_s_nuname] || ($p_s_nuname < 0)} {
					Inf "Invalid Number to start at"
					continue
				}
				foreach i $ilist {			;#	SORT INDICES TO DATE ORDER
					set fnam [$wl get $i]
					set k [list $i [file mtime $fnam]]
					lappend ll $k
				}
				set len [llength $ll]
				incr len -1
				set i 0
				while {$i < $len} {
					set j $i
					incr j
					set lli [lindex $ll $i]
					while {$j <= $len} {
						set llj [lindex $ll $j]
						if {[lindex $llj 1] < [lindex $lli 1]} {
							set ll [lreplace $ll $i $i $llj] 
							set ll [lreplace $ll $j $j $lli] 
							set lli [lindex $ll $i]
						}
						incr j
					}
					incr i
				}
				catch {unset ilist}
				foreach item $ll {
					lappend ilist [lindex $item 0]
				}
				set cnt $p_s_nuname
			}
			set OK 1
			catch {unset origfnams}
			catch {unset nufnams}
			foreach i $ilist {
				set origfnam [$wl get $i]
				lappend origfnams $origfnam
				set thisdir [file dirname $origfnam]
				if {[string length $thisdir] <= 1} {
					set thisdir ""
				}
				set fnam [file tail $origfnam]
				set ext [file extension $fnam]
				set rfnam [file rootname $fnam]
				set len [string length $rfnam]
				incr len -1
				if {$prefix_replace} {
					switch -- $suffix {
						0 -
						2 {
							set k [string first "_" $rfnam]
							if {($k <= 0) || ($len == 0)} {
								Inf "The Name '$fnam' Does Not Have A Prefix To Replace"
								set OK 0
								break
							}
							incr k
							set fnam [string range $rfnam $k end]
							append fnam $ext
						}
						1 -
						3 {
							set k [string last "_" $rfnam]
							if {($k <= 0) || ($len == 0) || ($k == $len)} {
								Inf "The Name '$fnam' Does Not Have A Suffix To Replace"
								set OK 0
								break
							}
							incr k -1
							set fnam [string range $rfnam 0 $k]
							append fnam $ext
						}
					}
				}
				switch -- $suffix {
					0 {
						set nufnam $p_s_nuname
						append nufnam "_" $fnam
					}
					1 {
						set ext [file extension $fnam]
						set nufnam [file rootname $fnam]
						append nufnam "_" $p_s_nuname
						append nufnam $ext
					}
					2 {
						set nufnam $cnt
						append nufnam "_" $fnam
					}
					3 {
						set ext [file extension $fnam]
						set nufnam [file rootname $fnam]
						append nufnam "_" $cnt
						append nufnam $ext
					}
				}
				set nufnam [file join $thisdir $nufnam]
				if {[file exists $nufnam]} {
					if {$suffix < 2} {
						set msg "File Exists With Name '$nufnam': Choose A Different "
						if {$suffix} {
							append msg "Suffix"
						} else {
							append msg "Prefix"
						}
						Inf $msg
					} else {
						Inf "File Exists With Name $nufnam"
					}
					set OK 0
					break
				}
				lappend nufnams $nufnam
				incr cnt
			}
			if {!$OK} {
				continue
			}
			if {$suffix > 1} {
				set cnt $p_s_nuname
			}
			foreach i $ilist nufnam $nufnams origfnam $origfnams {
				set is_snd 0
				if {$pa($origfnam,$evv(FTYP)) == $evv(SNDFILE)} {
					set is_snd 1
				}
				set haspmark [HasPmark $origfnam]
				set hasmmark [HasMmark $origfnam]
				if [catch {file rename $origfnam $nufnam} zit] {
					Inf "Cannot Rename File '$origfnam'"
					continue
				}
				DataManage rename $origfnam $nufnam
				lappend couettelist $origfnam $nufnam
				UpdateBakupLog $origfnam delete 0
				UpdateBakupLog $nufnam create 1
				if {$is_snd} {
					CheckMainmixSnd $origfnam $nufnam
					set are_snds 1
				} else {
					CheckMainmix $origfnam $nufnam
				}
				if {$haspmark} {
					MovePmark $origfnam $nufnam
				}
				if {$hasmmark} {
					MoveMmark $origfnam $nufnam
				}
				if [IsInBlists $origfnam] {
					if [RenameInBlists $origfnam $nufnam] {
						set ren_blist 1
					}
				}
				if [IsOnScore $origfnam] {
					RenameOnScore $origfnam $nufnam
				}
				$wl delete $i								
				$wl insert $i $nufnam
				catch {unset rememd}

				UpdateChosenFileMemory $origfnam $nufnam
				set oldname_pos_on_chosen [LstIndx $origfnam $ch]
				if {$oldname_pos_on_chosen >= 0} {
					RemoveFromChosenlist $origfnam
					set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
					incr chcnt
					$ch insert $oldname_pos_on_chosen $nufnam
				}
				RenameProps	$origfnam $nufnam 1
				DummyHistory $origfnam "RENAMED_$nufnam"
				if {[MixMRename $origfnam $nufnam 0]} {
					set save_mixmanage 1
				} elseif {[NessMRename $origfnam $nufnam 0]} {
					set nessupdate 1
				}
				RenameOnDirlist $origfnam $nufnam
				incr cnt
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			set finished 1
		} else {
			break
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	if {$are_snds} {
		set scores_refresh 1
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $oilist {
		$wl selection set $i
	}
}

proc PlayAllChosen {fromlist} {
	global from_chosen chlist CDPidrun prg_dun pa wstk wl evv pr_pallcfl pallcfl_step pallcfl_proceed doplaystep playcmd_dummy
	set pallcfl_proceed 1
	if {$fromlist == 3} {
		if {![info exists doplaystep]} {
			set fromlist 1
		}
	}
	if {$fromlist == 3} {
		set j [$wl curselection]
		if {![info exists j] || ([llength $j] <= 0) || (([llength $j] == 1) && ($j == -1))} {
			Inf "No Sounds Selected"
			return
		}
		if {[info exists pallcfl_step]} {
			set pallcfl_proceed 2
		} elseif {[llength $j] > 1} {
			set fromlist 2
		}
	}
	if {$fromlist == 2} {
		set j [$wl curselection]
		if {![info exists j] || ([llength $j] <= 0) || (([llength $j] == 1) && ($j == -1))} {
			Inf "No Sounds Selected"
			return
		}
		set f .pallcfl
		if [Dlg_Create $f "MIX STEP" "set pr_pallcfl 0" -borderwidth $evv(BBDR)] {
			frame $f.1
			button $f.1.ok -text "OK" -command "set pr_pallcfl 1" -width 10
			button $f.1.quit -text "Abandon" -command "set pr_pallcfl 0" -width 10
			pack $f.1.ok -side left
			pack $f.1.quit -side right
			pack $f.1 -side top -fill x -expand true
			frame $f.2
			entry $f.2.e -textvariable pallcfl_step -width 8 -state readonly
			label $f.2.ll -text "Time between sound-entries"
			pack $f.2.e $f.2.ll -side left -fill x -expand true
			pack $f.2 -side top -fill x -expand true
			frame $f.3
			label $f.3.ll -text "Use Up/Down arrows" -fg $evv(SPECIAL)
			pack $f.3.ll -side left -fill x -expand true
			pack $f.3 -side top -fill x -expand true
			bind $f <Up> "Incrpallcfl 0"
			bind $f <Down> "Incrpallcfl 1"
			bind $f <Return> {set pr_pallcfl 1}
			bind $f <Escape> {set pr_pallcfl 0}
		}
		if {![info exists pallcfl_step] || ([string length $pallcfl_step] <= 0)} {
			set pallcfl_step .6
		}
		set pr_pallcfl 0
		set finished 0
		raise $f
		My_Grab 0 $f pr_pallcfl
		while {!$finished} {
			raise $f
			tkwait variable pr_pallcfl
			if {$pr_pallcfl} {				  						
				if {([string length $pallcfl_step] <= 0) || (![IsNumeric $pallcfl_step]) || ($pallcfl_step < 0.0)} {
					Inf "Invalid Time Value"
					continue
				}
				set pallcfl_proceed 2
			} else {				  						
				set pallcfl_proceed 0
			}
			set finished 1
		}
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
	}
	if {!$pallcfl_proceed} {
		return
	}			
	if {$fromlist} {
		set i [$wl curselection]
		if  {![info exists i] || ([llength $i] <= 0)} {
			Inf "Select Sounds Or A Text Listing Of Soundfiles"
			return
		}
		if  {[llength $i] > 1} {
			foreach ii $i {
				set fnam [$wl get $ii]
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					Inf "Not All Selected Files Are Sounds"
					return
				}
				if {$fromlist != 4} {
					if {![info exists srate]} {
						set srate $pa($fnam,$evv(SRATE))
					} else {
						if {$pa($fnam,$evv(SRATE)) != $srate } {
							Inf "Sounds Have Incompatible Sample Rates"
							return
						}
					}
				}
				lappend zlist $fnam
			}

		} else {
			if {$i == -1} {
				Inf "No Sounds Selected"
				return
			}
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				set zlist $fnam
			} else {
				if {![IsASndlist $pa($fnam,$evv(FTYP))]} {
					Inf "Select Sounds Or A Text Listing Of Soundfiles"
					return
				}
				if [catch {open $fnam "r"} zit] {
					Inf "Cannot Open List Of Soundfiles '$fnam'"
					return
				}
				while {[gets $zit line] >= 0} {
					set ffnam [string trim $line]
					if {[string length $ffnam] <= 0} {	
						continue
					}
					if {![file exists $ffnam]} {
						Inf "File '$fnam' Contains A Soundfile ($ffnam) Which No Longer Exists"
						close $zit
						return
					}
					lappend zlist $ffnam
				}
				close $zit
				if {![info exists zlist]} {
					Inf "No Soundfiles Found In File '$fnam'"
					return
				}
			}
		}
		if {[llength $zlist] == 1} {
			PlaySndfile $zlist 0
			return
		} elseif {$fromlist == 4} {
			foreach fffnam $zlist {
				if {$pa($fffnam,$evv(CHANS)) <= 2} {
					SnackDisplay 0 $evv(SN_FILE_PRMPAGE_NO_OUTPUT) 0 $fffnam
				} else {
					PlaySndfile $fffnam 0
				}
			}
			return
		}
		foreach fnam $zlist {
			if {![info exists pa($fnam,$evv(FTYP))]} {
				set msg "Not All Files Are On The Workspace (Need To Determine Channel Count): Grab Them ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "yes"} {
					set dograb 1
					break
				} else {
					return
				}
			}
		}
		if {[info exists dograb]} {
			foreach fnam $zlist {
				if {![info exists pa($fnam,$evv(FTYP))]} {
					if {[FileToWkspace $fnam 0 0 0 1 0] <= 0} {
						Inf "Cannot Grab All Files To Workspace"
						return
					}
				}
			}
		}
	} else {
		if {![info exists chlist] || ([llength $chlist] <= 0)} {
			return
		}
		foreach fnam $chlist {
			if {[info exists pa($fnam,$evv(FTYP))] && ($pa($fnam,$evv(FTYP)) == $evv(SNDFILE))} {
				lappend zlist $fnam
			}
		}
		if {![info exists zlist]} {
			Inf "No Soundfiles In Chosen Files List"
			return
		}
		if {[llength $zlist] == 1} {
			set fnam [lindex $zlist 0]
			set from_chosen 1
			PlayOutput 0
			return
		}
	}
	set totdur 0
	foreach fnam $zlist {
		if {$pallcfl_proceed == 2} {
			set dur $pallcfl_step
		} else {
			set dur $pa($fnam,$evv(DUR))
		}
		set chans $pa($fnam,$evv(CHANS))
		if {![info exists max_chans]} {
			set	max_chans $chans
		} else {
			if {$chans > $max_chans} {
				set max_chans $chans
			}
		}
		set line $fnam
		append line " " $totdur " " $chans " 1"
		lappend mixlines $line
		set totdur [expr $totdur + $dur + 0.2]
	}
	if {$max_chans > 2} {
		foreach line $mixlines {
			set chans [lindex $line 2]
			set n 1
			catch {unset routs}
			while {$n <= $chans} {
				set rout $n
				append rout ":" $n
				lappend routs $rout 1.0
				incr n
			}
			set line [lrange $line 0 2]
			set line [concat $line $routs]
			lappend lines $line
		}
		set mixlines $max_chans
		foreach line $lines {
			lappend mixlines $line
		}
	}
	set mfile $evv(DFLT_OUTNAME)
	set ofile $evv(DFLT_OUTNAME)
	append mfile "0" $evv(TEXT_EXT)
	append ofile "0" $evv(SNDFILE_EXT)
	Block "Joining Files"
	if [catch {open $mfile "w"} zit] {
		Inf "Cannot Make Temporary Mixfile"
		UnBlock
		return
	}
	foreach line $mixlines {
		puts $zit $line
	}
	close $zit
	if {$max_chans <= 2} {
		set cmd [file join $evv(CDPROGRAM_DIR) "submix"]
	} else {
		set cmd [file join $evv(CDPROGRAM_DIR) "newmix"]
	}
	lappend cmd "mix" $mfile $ofile

	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Make Temporary Mix"
		DeleteAllTemporaryFiles
		UnBlock
		return
	} else {
	   	fileevent $CDPidrun readable "Run_With_No_Messages"
	}
	vwait prg_dun
	UnBlock
	if {!$prg_dun} {
		set line "Cannot Make Temporary Mix"
	} elseif {[file exists $ofile]} {
		PlaySndfile $ofile 0			;# PLAY OUTPUT
	}
	DeleteAllTemporaryFiles
}

#------ Display info returned by running-batchfile in the the program-running display

proc Run_With_No_Messages {} {
	global CDPidrun prg_dun

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if [string match ERROR:* $line] {
			set prg_dun 0
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		} else {
			return
		}
	}
	update idletasks
}

#--- Display endtimes of files in mix

proc Mix_Endtimes {} {
	global wl pa evv pr_mixends mixends_name wstk
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		Inf "No File Selected"
		return
	}
	set fnam [$wl get $i]
	if {![info exists pa($fnam,$evv(FTYP))]} {
		Inf "Can't Find Details Of File '$fnam'"
		return
	}
	if {![IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
		Inf "File '$fnam' Is Not A Mixfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Canot Open File '$fnam'"
		return
	}
	while {[gets $zit line] >= 0}  {
		set line [string trim $line]
		if {([string length $line] <= 0) || [string match [string index $line 0] ";"]} {
			continue
		}
		set line [split $line]
		set gotsnd 0
		set gotdur 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] > 0} {
				if {!$gotsnd} {
					set zfnam $item
					if {![info exists pa($zfnam,$evv(DUR))]} {
						Inf "File '$zfnam' In The Mixfile Is Not On The Workspace: Cannot Proceed"
						close $zit
						return
					}
					set dur $pa($zfnam,$evv(DUR))
					set gotsnd 1
				} else {
					set starttime $item
					if {![IsNumeric $starttime] || ($starttime < 0.0)} {
						Inf "Invalid File Starttime For Sndfile '$zfnam' In Mixfile"
						close $zit
						return
					}
					set outline [expr $starttime + $dur]
					append outline "   " $zfnam
					lappend outlines $outline
					set gotdur 1
					break
				}
			}
		}
		if {!($gotsnd && $gotdur)} {
			Inf "Invalid Data Line In File '$fnam'"
			close $zit
			return
		}
	}
	close $zit
	if {![info exists outlines]} {
		return
	}
	set f .mixends
	if [Dlg_Create $f "Endtimes of Files in Mixfile" "set pr_mixends 0" -borderwidth $evv(SBDR)] {
		frame $f.b0 -borderwidth $evv(SBDR)
		frame $f.b1 -borderwidth $evv(SBDR)
		button $f.b0.s -text "Save To File" -command "set pr_mixends 1" -highlightbackground [option get . background {}]
		entry $f.b0.e -textvariable mixends_name -width 24
		button $f.b0.q -text "Close" -command "set pr_mixends 0" -highlightbackground [option get . background {}]
		pack $f.b0.s $f.b0.e -side left -padx 2
		pack $f.b0.q -side right
		Scrolled_Listbox $f.b1.ll -width 64 -height 24 -selectmode single
		pack $f.b1.ll  -side top -fill both -expand true
		pack $f.b0 -side top -pady 2 -fill x -expand true
		pack $f.b1 -side top
		bind $f <Return> {set pr_mixends 1}
		bind $f <Escape> {set pr_mixends 0}
	}
	$f.b1.ll.list delete 0 end
	foreach line $outlines {
		$f.b1.ll.list insert end $line
	}
	set pr_mixends 0
	set finished 0
	set mixends_name ""
	raise $f
	My_Grab 0 $f pr_mixends
	while {!$finished} {
		tkwait variable pr_mixends
		if {$pr_mixends == 0} {
			break
		}
		if {[string length $mixends_name] <= 0} {
			Inf "No Filename Entered"	
			continue
		}
		if {![ValidCDPRootname $mixends_name]} {
			continue
		}
		set outfname $mixends_name$evv(TEXT_EXT)
		if {[file exists $outfname]} {
			set msg "File '$outfname' Exists: Overwrite It ?"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				continue
			}
		}
		if [catch {open $outfname "w"} zit] {
			Inf "Cannot Open File '$outfname' To Write Data"
			continue
		}
		foreach line $outlines {
			puts $zit $line
		}
		close $zit
		if {[FileToWkspace $outfname 0 0 0 0 1] > 0} {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- RemoveDuplicatesInList

proc RemoveDuplicatesInList {thislist} {
	set len [llength $thislist]
	if {$len <= 1} {
		return $thislist
	}
	set len_less_one [expr $len - 1]
	set n 0
	while {$n < $len_less_one} {
		set m $n
		incr m
		while {$m < $len} {
			if {[string match [lindex $thislist $n] [lindex $thislist $m]]} {
				set thislist [lreplace $thislist $m $m]
				incr m -1
				incr len -1
				incr len_less_one -1
			}
			incr m
		}
		incr n
	}
	return $thislist
}

proc SortOnTimesInList {thislist thesetimes} {
	set len [llength $thislist]
	set len_less_one [expr $len - 1]
	set n 0
	while {$n < $len_less_one} {
		set ntime [lindex $thesetimes $n]
		set nfile [lindex $thislist $n]
		set m $n
		incr m
		while {$m < $len} {
			set mtime [lindex $thesetimes $m]
			set mfile [lindex $thislist $m]
			if {$mtime < $ntime} {
				set thislist [lreplace $thislist $m $m $nfile]
				set thislist [lreplace $thislist $n $n $mfile]
				set thesetimes [lreplace $thesetimes $m $m $ntime]
				set thesetimes [lreplace $thesetimes $n $n $mtime]
			}
			incr m
		}
		incr n
	}
	return $thislist
}

#--- FindDuplicatesInList

proc DuplicatesInList {thislist} {
	set len [llength $thislist]
	if {$len <= 1} {
		return 0
	}
	set len_less_one [expr $len - 1]
	set n 0
	while {$n < $len_less_one} {
		set m $n
		incr m
		while {$m < $len} {
			if {[string match [lindex $thislist $n] [lindex $thislist $m]]} {
				return 1
			}
			incr m
		}
		incr n
	}
	return 0
}

#--- Hilite Files on Wkspace which are on Chosen files list

proc ChosSelect {} {
	global w_hich wl
	set w_hich 0
	ToSelectionMode
	ToWkspaceMode
	set len [$wl index end]
	if {$len > 0} {
		set ilist [$wl curselection]
		set i [lindex $ilist 0]
		if {$i < 0} {
			return
		}
		set k [expr double($i) / double($len)]
		$wl yview moveto $k
	}
}

proc GetPreviousFilesUsed {previous} {
	global chused last_chused ch chlist chcnt wl wstk
	if {$previous} {
		if {![info exists last_chused]} {
			Inf "No Penultimate Usage Of Files"
			return
		}
		foreach fnam $last_chused {
			if {![file exists $fnam]} {
				lappend badfiles $fnam
			} else {
				lappend goodfiles $fnam
			}
		}
	} else {
		if {![info exists chused]} {
			Inf "No Files Have Been Used Yet"
			return
		}
		foreach fnam $chused {
			if {![file exists $fnam]} {
				lappend badfiles $fnam
			} else {
				lappend goodfiles $fnam
			}
		}
	}
	if {![info exists goodfiles]} {
		Inf "These Files No Longer Exist"
		return
	} elseif {[info exists badfiles]} { 
		set msg "Some Of These Files No Longer Exist: Load The Others ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	foreach fnam $goodfiles {
		if {[LstIndx $fnam $wl] < 0} {
			FileToWkspace $fnam 0 0 0 1 0
		}
		$ch insert end $fnam
		lappend chlist $fnam
		incr chcnt
	}
	ChlistDupls
}

proc StandardPosition {w} {
	set xy [wm geometry $w]
	set xy [split $xy +]
	set k [lindex $xy 0]
	append k "+30+30"
	wm geometry $w $k
}

proc StandardPosition2 {w} {
	set xy [wm geometry $w]
	set xy [split $xy +]
	set k [lindex $xy 0]
	set j [split $k x]
	set k [lindex $j 0]
	set z [lindex $j 1]
	incr z 15
	append k "x" $z
	append k "+30+30"
	wm geometry $w $k
}

proc StandardPosition3 {w} {
	set xy [wm geometry $w]
	set xy [split $xy +]
	set k [lindex $xy 0]
	append k "+1000+30"
	wm geometry $w $k
}

proc StandardPosition4 {w} {
	set xy [wm geometry $w]
	set xy [split $xy +]
	set k [lindex $xy 0]
	append k "+1175+40"
	wm geometry $w $k
}

proc ShowReminder {} {
	global unotes shortwindows pr_remind evv tasklist
	set gotdate 0 
	set gottext 0
	set gotmsg 0
	if {![info exists unotes]} {
		return
	}
	set len [llength $unotes]
	set n [expr $len - 1]
	while {$n >= 0} {
		set line [lindex $unotes $n]
		if {[IsDateLine $line]} {
			if {$gottext} {
				set start $n
				if {$gotdate} {
					set end [expr $dateline]
				} else {
					set end $len
				}
				set gotmsg 1
				break
			} else {
				set gotdate 1
				set dateline $n
			}
		} else {
			set line [string trim $line]
			if {[string length $line] > 0} {
				set gottext 1
			}
		}
		incr n -1
	}
	if {!$gotmsg} {
		return
	}
	set reminder [ConvertTabs [lindex $unotes $start]]
	set msglen [string length $reminder]
	incr start
	while {$start < $end} {
		set submsg [ConvertTabs [lindex $unotes $start]]
		lappend reminder $submsg
		if {[string length $submsg] > $msglen} {
			set msglen [string length $submsg]
		}
		incr start
	}
	if {[info exists tasklist] && ([llength $tasklist] > 0)} {
		set line ""
		lappend reminder $line
		set line "-------------   TASKLIST   -------------"
		lappend reminder $line
		set line ""
		lappend reminder $line
		incr msglen 3
		foreach line $tasklist {
			set submsg [ConvertTabs $line]
			lappend reminder $submsg
			if {[string length $submsg] > $msglen} {
				set msglen [string length $submsg]
			}
		}
	}
	incr msglen 2
	set f .remind
	if [Dlg_Create $f "CURRENT NOTEBOOK ENTRY" "set pr_remind 0" -borderwidth 2] {
		frame $f.a
		button $f.a.0 -text "OK (\"Escape\")" -command "set pr_remind 0" -bd 3 -width 12 -highlightbackground [option get . background {}]
		if {[info exists shortwindows]} {
			Scrolled_Listbox $f.a.1 -width $msglen -height 30 -selectmode single -font midfnt
		} else {
			Scrolled_Listbox $f.a.1 -width $msglen -height 40 -selectmode single -font midfnt
		}
		pack $f.a.1 $f.a.0 -side top -pady 6
		pack $f.a -side top
		wm resizable $f 1 1
		bind $f <Control-Key-p> {PossiblyFromReminder 0}
		bind $f <Control-Key-P> {PossiblyFromReminder 0}
		bind $f <Key-space>		{PossiblyFromReminder 0}
		bind $f <Double-1>		{PossiblyFromReminder 0}
		bind $f <Control-Key-g> {PossiblyFromReminder 1}
		bind $f <Control-Key-G> {PossiblyFromReminder 1}
		bind $f <Return> {set pr_remind 0}
		bind $f <Escape> {set pr_remind 0}
		bind $f <Key-#> {set pr_remind 0}
	}
	$f.a.1.list delete 0 end
	foreach line $reminder {
		$f.a.1.list insert end $line
	}
	set pr_remind 0
	raise $f
	My_Grab 0 $f pr_remind
	tkwait variable pr_remind
	My_Release_to_Dialog $f
	destroy $f
}

#-- Play or Grab file chosen in notebook-reminder

proc PossiblyFromReminder {grab} {
	global wl wstk pr_remind evv
	set ll .remind.a.1.list
	set i [$ll curselection]
	if {![info exists i] || ($i < 0)} {
		set pr_remind 0		;#	If no soundfile selected, quit on hitting "Space bar"
		return
	}
	set line [string trim [$ll get $i]]
	if {[string length $line] <= 0} {
		return
	}
	set line [split $line]
	foreach item $line {
		set item [string trim $item]
		if {[string length $item] <= 0} {
			continue
		}
		if {[file exists $item] && ![file isdirectory $item]} {
			set ftyp [FindFileType $item]
			if {$ftyp != $evv(SNDFILE)} {
				continue
			}
			if {$grab} {
				set test [LstIndx $item $wl]
				if {$test >= 0} {
					set msg "'$item' Is Already On The Workspace: Return To Workspace ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message "$msg"]
					if {$choice == "yes"} {
						$wl selection clear 0 end
						$wl selection set $test
						AdjustWkspaceView $test
						set pr_remind 0
						return
					}
				} else {
					FileToWkspace $item 0 0 0 1 0
					set msg "Return To Workspace ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message "$msg"]
					if {$choice == "yes"} {
						AdjustWkspaceView 0
						set pr_remind 0
						return
					}
				}
			} else {
				PlaySndfile $item 0
				return
			}
		}
	}
	set pr_remind 0		;#	If no soundfile selected, quit on hitting "Space bar"
	return
}

#----- Replace tabs by spaces

proc ConvertTabs {line} {
	set tabcnt 8
	set tabcnt_less_one [expr $tabcnt - 1]
	set len [string length $line]
	set n 0
	while {$n < $len} {
		if {[string match [string index $line $n] "\t"]} {
			set m [expr $n - 1]
			if {$m < 0} {
				set nuline ""
			} else {
				set nuline [string range $line 0 $m]
			}
			incr m 2
			if {$m >= $len} {
				set endline ""
			} else {
				set endline [string range $line $m end]
			}
			set k 0
			while {$k < $tabcnt} {
				append nuline " "
				incr k
			}
			append nuline $endline
			set line $nuline
			incr n $tabcnt_less_one
			incr len $tabcnt_less_one
		}
		incr n
	}
	return $line	
}

#
#	 example data = ---------------- Aug29_10-52.2006 ----------------
#

proc IsDateLine {line} {
	set len [string length $line]
	if {$len < 16} {
		return 0
	}
	set got 0
	set k 0
	while {$k < $len} {
		set char [string tolower [string range $line $k $k]]
		if [regexp {[a-z]} $char] {
			set got 1
			break
		}
		incr k
	}
	if {!$got || ![regexp {[jfmasond]} $char]} {
		return 0
	}
	set j [expr $k + 2]
	set month [string tolower [string range $line $k $j]]
	set got 0
	switch -- $month {
		"jan" -
		"feb" -
		"mar" -
		"apr" -
		"may" -
		"jun" -
		"jul" -
		"aug" -
		"sep" -
		"oct" -
		"nov" -
		"dec" {
			set got 1
		}
	}
	if {!$got} {
		return 0
	}
	incr k 3
	set j $k
	while {[regexp {[0-9]} [string index $line $j]]} {
		incr j
	}
	incr j -1
	if {$j < $k} {
		return 0
	}
	set day [string range $line $k $j]
	if {![regexp {^[0-9]+$} $day]} {
		return 0
	}
	if {[string match [string index $day 0] "0"]} { 
		set day [string index $day 1]
	}
	if {$day > 31 || $day < 1} {
		return 0
	}
	set k $j		
	incr k
	if {![string match [string index $line $k] "_"]} {
		return 0
	}
	incr k
	set j [expr $k + 1]
	set hour [string range $line $k $j]
	if {![regexp {^[0-9]+$} $hour]} {
		return 0
	}
	if {[string match [string index $hour 0] "0"]} { 
		set hour [string index $hour 1]
	}
	if {$hour > 23} {
		return 0
	}		
	incr k 2
	if {![string match [string index $line $k] "-"]} {
		return 0
	}
	incr k
	set j [expr $k + 1]
	set min [string range $line $k $j]
	if {![regexp {^[0-9]+$} $min]} {
		return 0
	}
	if {[string match [string index $min 0] "0"]} { 
		set min [string index $min 1]
	}
	if {$min > 59} {
		return 0
	}		
	incr k 2
	if {![string match [string index $line $k] "."]} {
		if {![string match [string index $line $k] "-"]} {
			return 0
		}
	}
	incr k
	set j [expr $k + 3]
	set year [string range $line $k $j]
	if {![regexp {^[0-9]+$} $year]} {
		return 0
	}
	if {$year < 2006 || $year > 3006} {
		return 0
	}		
	return 1
}

proc GetPreviousDir {} {
	global previous_dirlisting previous_active_dir active_dir wksp_dirname dl ww evv

	if {[info exists previous_active_dir]} {
		$dl delete 0 end
		foreach fnam $previous_dirlisting {
			if {![file exists $fnam]} {
				lappend notexist $fnam
			} elseif {![IsListableFile $fnam]} {
				lappend notapprop $fnam
			} else {
				$dl insert end $fnam
				set thisext [file extension $fnam]
				if {[string match $thisext ".wav"] || [string match $thisext ".aif"] || [string match $thisext ".aiff"]} {
					if {![info exists exttype]} {
						set exttype $thisext
					} elseif {![string match $thisext $exttype]} {
						set exttype "all"
					}
				}
			}
		}
		$dl xview moveto 0.0
		if {![info exists exttype]} {
			set exttype "all"
		}
		switch -- $exttype {
			"all" {	
				$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
			}
			default {	
				$ww.1.b.labels.msg2 config -text "Sndfile extension $exttype"
			}
		}
		set active_dir $previous_active_dir
		set wksp_dirname $active_dir
		set msg ""
		if {[info exists notexist]} {
			append msg "The Following Files No Longer Exists\n"
			set cnt 0
			foreach fnam $notexist {
				incr cnt
				if {$cnt > 10} {
					append msg "\nAND MORE"
					break
				}
				append msg $fnam "   "
			}
			append msg "\n\n"
		}
		if {[info exists notapprop]} {
			append msg "The Following Files Are No Longer Cdp Compatible\n"
			set cnt 0
			foreach fnam $notapprop {
				incr cnt
				if {$cnt > 10} {
					append msg "\nAND MORE"
					break
				}
				append msg $fnam "   "
			}
		}
		if {[string length $msg] > 0} {
			Inf $msg
		}
	} else {
		Inf "No Previous Listing"
	}
}

proc SetShowDirs {} {
	global evv
	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(NODIRS)$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {file delete $fnam} zit] {
			Inf "CANNOT DELETE FILE $fnam\NTO ENSURE BACKUP DIRECTORIES ARE DISPLAYED AT SESSION STARTUP"
		}
	}
}

proc GrabRename {withpath} {
	global wl
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] <= 0)} {
		Inf "No File Selected"
		return
	}	
	if {[llength $i] > 1} {
		Inf "Select Just One File"
		return
	}
	set namegot [$wl get $i]
	switch -- $withpath {
		0 {
			set namegot [file rootname [file tail $namegot]]
		}
		1 {
			set namegot [file tail $namegot]
		}
	}
	clipboard clear
	clipboard append $namegot
}

proc CopyToWkspace_or_QuickCopy {} {
	global wl pr_qikcopy qikcopy_name qikcopy_ext qikcopy_num wstk evv sysname qikcopy_toch nessinit
	global ch chcnt chlist dl pr_5
	if [info exists dl] {
		set ilist [$dl curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			set pr_5 $evv(DO_COPY)
			return
		}
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {
		Inf "No File Selected"
		return
	}
	if {[llength $ilist] > 1} {
		Inf "Choose Just One File"
		return
	}
	set i [lindex $ilist 0]
	set callcentre [GetCentre [lindex $wstk end]]
	set fnam [$wl get $i]
	set this_ext [file extension $fnam]
	set f .qikcopy
	if [Dlg_Create $f "COPY FILE" "set pr_qikcopy 0" -bd 2] {
		frame $f.1
		frame $f.2
		frame $f.3
		button $f.1.q -text "Close" -command "set pr_qikcopy 0" -highlightbackground [option get . background {}]
		button $f.1.c -text "Copy" -command "set pr_qikcopy 1" -highlightbackground [option get . background {}]
		label $f.1.lab -text "Number of copies"
		entry $f.1.n -textvariable qikcopy_num -width 4
		checkbutton $f.1.ch -variable qikcopy_toch -text "To chosen list"
		pack $f.1.c $f.1.lab $f.1.n $f.1.ch -side left -padx 2
		pack $f.1.q -side right
		label $f.2.ll -text "Name for new file"
		entry $f.2.e -textvariable qikcopy_name -width 16
		checkbutton $f.2.ch -variable qikcopy_ext -text "As extension to existing name"
		pack $f.2.ll $f.2.e $f.2.ch -side left
		button $f.3.1 -text $sysname(1) -command "set qikcopy_name $sysname(1)" -highlightbackground [option get . background {}]
		button $f.3.2 -text $sysname(2) -command "set qikcopy_name $sysname(2)" -highlightbackground [option get . background {}]
		button $f.3.3 -text $sysname(3) -command "set qikcopy_name $sysname(3)" -highlightbackground [option get . background {}]
		button $f.3.4 -text $sysname(4) -command "set qikcopy_name $sysname(4)" -highlightbackground [option get . background {}]
		button $f.3.5 -text $sysname(5) -command "set qikcopy_name $sysname(5)" -highlightbackground [option get . background {}]
		pack $f.3.1 $f.3.2 $f.3.3 $f.3.4 $f.3.5 -side left -padx 2
		pack $f.1 $f.2 -side top -pady 2 -fill x -expand true
		pack $f.3 -side top -pady 2
		wm resizable .workspace 1 1
		set qikcopy_name ""
		set qikcopy_ext 0
		bind $f.1.n <Up>   "IncrQikcopyNum 1"
		bind $f.1.n <Down> "IncrQikcopyNum 0"
		bind $f.2.e <Up>   "AdvanceNameIndex 1 qikcopy_name 0"
		bind $f.2.e <Down> "AdvanceNameIndex 0 qikcopy_name 0"
		bind $f.2.e <Control-Up>   "AdvanceNameIndex 1 qikcopy_name 1"
		bind $f.2.e <Control-Down> "AdvanceNameIndex 0 qikcopy_name 1"
		bind $f <Return> {set pr_qikcopy 1}
		bind $f <Escape> {set pr_qikcopy 0}
	}
	set qikcopy_toch 0
	set qikcopy_num 1
	set qikcopy_name [file rootname [file tail $fnam]]
	set pr_qikcopy 0
	set finished 0
	set save_mixmanage 0
	set nessupdate 0
	raise $f
	update idletasks
	set geo [CentreOnCallingWindow $f $callcentre]
	My_Grab 0 $f pr_qikcopy $f.2.e
	wm geometry $f $geo
	while {!$finished} {
		tkwait variable pr_qikcopy
		if {$pr_qikcopy} {
			if {[string length $qikcopy_name] <= 0} {
				Inf "No Name Entered"
				continue
			}
			if {![ValidCDPRootname $qikcopy_name]} {
				continue
			}
			if {![regexp {^[0-9]+$} $qikcopy_num] || ($qikcopy_num < 1) || ($qikcopy_num > $evv(MAXFILES))} {
				Inf "Invalid Number Of Copies"
				continue
			}
			if {$qikcopy_ext} {
				set nufnam [file rootname $fnam]
				append nufnam "_" [string tolower $qikcopy_name]
			} else {
				set nufnam [string tolower $qikcopy_name]
			}
			set outstr ""
			if {$qikcopy_num == 1} {
				append nufnam $this_ext
				if {[info exists nessinit] && [IsAValidNessFile $fnam 1 0 0]} {
					if {[file tail $fnam] == $nufnam} {
						Inf "You Cannot Make Identically Named Copies Of Physical Modelling Files"
						continue
					}
				}
				if {[file exists $nufnam]} {
					set msg "File With This Name Already Exists: Cannot Overwrite It Here\nTo Overwrite Use 'Housekeep Copy'"
					if {[FindFileType $fnam] & $evv(IS_A_TEXTFILE)} {
						append msg "\nOr The Duplication Option For Textfiles On 'Files Of Type' Menu"
					}
					Inf $msg
					continue
				}
				Block "Copying File"
				if [catch {file copy $fnam $nufnam} zit] {
					Inf "Failed To Copy File"
					UnBlock
					continue
				}
				CopyWkspaceFilePmarkMmark $fnam $nufnam
				if {[FileToWkspace $nufnam 0 0 0 0 1] <= 0} {
					if {[CopiedIfAMix $fnam $nufnam 0]} {
						set save_mixmanage 1
					} elseif {[CopiedIfANess $fnam $nufnam 1]} {
						set nessupdate 1
					}
					UnBlock
					continue
				}
				if {[CopiedIfAMix $fnam $nufnam 0]} {
					set save_mixmanage 1
				} elseif {[CopiedIfANess $fnam $nufnam 1]} {
					set nessupdate 1
				}
				if {$qikcopy_toch} {
					DoChoiceBak
					set chlist $nufnam
					$ch delete 0 end
					$ch insert end $nufnam
					set chcnt 1
				}
				set outstr $nufnam
				append outstr "  "
				UnBlock
			} else {
				set n 1
				set OK 1
				catch {unset zzz}
				while {$n <= $qikcopy_num} {
					set testfnam $nufnam
					append testfnam $n
					append testfnam $this_ext
					if {[file exists $testfnam]} {
						set msg "File With Name '$testfnam' Already Exists: Cannot Overwrite It Here\nTo Overwrite Use 'Housekeep Copy'"
						if {[FindFileType $fnam] & $evv(IS_A_TEXTFILE)} {
							append msg "\nOr The Duplication Option For Textfiles On 'Files Of Type' Menu"
						}
						Inf $msg
						set OK 0
						break
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				set n 1
				set OK 1
				set do_outstr 1
				Block "Copying File"
				while {$n <= $qikcopy_num} {
					set testfnam $nufnam
					append testfnam $n
					append testfnam $this_ext
					if [catch {file copy $fnam $testfnam} zit] {
						Inf "Failed To Copy File"
						set OK 0
						break
					}
					CopyWkspaceFilePmarkMmark $fnam $testfnam
					if {[FileToWkspace $testfnam 0 0 0 0 1] <= 0} {
						if {[CopiedIfAMix $fnam $testfnam 0]} {
							set save_mixmanage 1
						} elseif {[CopiedIfANess $fnam $testfnam 1]} {
							set nessupdate 1
						}
						continue
					}
					if {[CopiedIfAMix $fnam $testfnam 0]} {
						set save_mixmanage 1
					} elseif {[CopiedIfANess $fnam $testfnam 1]} {
						set nessupdate 1
					}
					lappend zzz $testfnam
					incr n
					if {$do_outstr} {
						set old_outstr $outstr
						append outstr $testfnam
						if {[string length $outstr] > 40} {
							set outstr $old_outstr
							append outstr "ETC" "  "
							set do_outstr 0
						} else {
							append outstr "  "
						}
					}
				}
				if {!$OK} {
					UnBlock
					continue
				}
				if {[info exists zzz]} {
					if {$qikcopy_toch} {
						DoChoiceBak
						set chlist {}
						$ch delete 0 end
						set chcnt 0
						foreach ffnam $zzz {
							lappend chlist $ffnam
							$ch insert end $ffnam
							incr chcnt
						}
					}
				}
				UnBlock
			}
			set len [string length $outstr]
			if {$len > 0} {
				incr len -3
				set outstr [string range $outstr 0 $len]
				DummyHistory $fnam COPIED_TO_$outstr
			}
			set finished 1
		} else {
			break
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc ResetSystemClock {} {
	global evv
	if {[info exists evv(CLOCK_TICK)]} {
		set old_tick $evv(CLOCK_TICK)
	}
	Block "Resetting system clock"
	set filename $evv(DFLT_TMPFNAME)
 	set t1 [clock clicks]
	after 10000
	set t2 [clock clicks]
	set evv(CLOCK_TICK) [expr ($t2 - $t1)/10]
	UnBlock
	if [catch {open $filename "w"} clkId] {
		Inf "Cannot write system clock speed to temporary file : continuing with session."
		set evv(CLOCK_TICK) $old_tick
		return
	} else {
		puts $clkId $evv(CLOCK_TICK)
		catch {close $clkId}
	}
	set clockfilename [file join $evv(CDPRESOURCE_DIR) $evv(SYSTEM_CLOCK)$evv(CDP_EXT)]
	if {[file exists $clockfilename]} {
		if [catch {file delete $clockfilename} zit] {
			Inf "Cannot delete existing	clockdata file '$clockfilename'\nIt may be open or being used by another application."
			set evv(CLOCK_TICK) $old_tick
			return
		}
	}
	if [catch {file rename $filename $clockfilename} zit] {
		Inf "Cannot rename temporary clockdata file '$filename' to '$clockfilename'\n\nDo this outside the CDP environment, before continuing."
	}
}

proc DoView {} {
	global snack_enabled snack_stereo wl chlist pa evv
	set ilist [$wl curselection]
		if {![info exists ilist] || ([llength $ilist] <= 0)} {
			if {![info exists chlist] || ([llength $chlist]  != 1)} {
				Inf "No File Selected"
				return
			}
			set k [LstIndx [lindex $chlist 0] $wl]
			if {$k >= 0} {
				set ilist $k
			} else {
				Inf "No File Selected"
				return
			}
		}
	if {[llength $ilist] > 1} {
		Inf "Select Just One File"
		return
	}
	set fnam [$wl get [lindex $ilist 0]]
	if {![info exists pa($fnam,$evv(FTYP))]} {
		Inf "Cannot Retrieve Information About File '$fnam'"
		return
	}
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp == $evv(SNDFILE)} {
		if {$snack_enabled && (($pa($fnam,$evv(CHANS)) == 1) || $snack_stereo)} {
			SnackDisplay 0 $evv(SN_FROM_WKSP_NO_OUTPUT) 0 0
		} else {
			PlayWindow
		}
	} elseif {$ftyp == $evv(ANALFILE)} {
		AnalysisDisplayOptions $fnam
	} else {
		Inf "File '$fnam' Is Neither A Soundfile Nor An Analysis File"
	}
	SetSel2 view
}

proc ReinstallSystem {} {
	global evv wstk do_reinstall
	set msg "Are You Sure You Want To Reinstall The System ?"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message "$msg"]
	if {$choice == "no"} {
		return
	}
	set do_reinstall 1
	Inf "Close The Soundloom, And Restart It"
}

proc DoTheReinstall {} {
	global evv
	set thisdir $evv(CDPRESOURCE_DIR)
	foreach fnam [glob  -nocomplain [file join $thisdir *]] {
		set basfnam [file rootname [file tail $fnam]]
		if {![string match $basfnam $evv(TESTFILE)] && ![string match $basfnam $evv(CDPRES)]} {
			if [catch {file stat $fnam filestatus} in] {
				Inf "Cannot Find File Status Info For $fnam"
				lappend badfiles $fnam
				continue
			}
			if {$filestatus(ino) >= 0} {
				catch {close $filestatus(ino)}
			}

			if [catch {file delete $fnam -force} zit] {
				lappend badfiles $fnam
			}
		}
	}
	if {[info exists badfiles]} {
		set k [llength $badfiles]
		if {$k > 1} {
			set msg "The Following Files Could Not Be Deleted\n\n"
		} else {
			set msg "The Following File Could Not Be Deleted\n\n"
		}
		foreach item $badfiles {
			append msg $item "   "
		}
		if {$k > 1} {
			append msg "\n\n\nYou Must Delete These Files Elsewhere, Before Proceeding"
		} else {
			append msg "\n\n\nYou Must Delete This File Elsewhere, Before Proceeding"
		}
		Inf $msg
	}
}

proc PutItOnChlist {fnam} {
	global chpos chlist ch chcnt topchpos
	UnsetThumbnail
	if {$chpos > 0} {
		incr chpos -1
		set chlist [linsert $chlist $chpos $fnam]
		$ch insert $chpos $fnam
	} else {
		if {$topchpos} {
			if {[info exists chlist]} {
				set chlist [linsert $chlist 0 $fnam]	;#	add to start of list
			} else {
				set chlist $fnam
			}
			$ch insert 0 $fnam							;#	add to start of display
		} else {
			lappend chlist $fnam						;#	add to end of list
			$ch insert end $fnam						;#	add to end of display
		}
	}
	incr chcnt
	LastChoiceRedundancy
}

proc ChoiceDelDupls {} {
	global chcnt ch chlist dupl_mix dupl_vbx dupl_txt
	if {[info exists chlist] && ($dupl_mix || $dupl_vbx || $dupl_txt)} {
		set len [llength $chlist]
		if {$len > 1} {
			set nulist $chlist
			set len_less_one [expr $len - 1]
			set i 0
			while {$i < $len_less_one} {
				set j $i
				incr j
				while {$j < $len} {
					if {[string match [lindex $nulist $i] [lindex $nulist $j]]} {
						set nulist [lreplace $nulist $j $j]
						incr j -1
						incr len -1
						incr len_less_one -1
					}
					incr j
				}
				incr i
			}
			ClearAndSaveChoice
			set chlist $nulist
			foreach fnam $chlist {
				$ch insert end $fnam
				incr chcnt
			}
		}
	}
	set dupl_mix 0
	set dupl_vbx 0
	set dupl_txt 0
}

proc DuplFilesMsg {} {
	global dupl_mix dupl_vbx dupl_txt
	if {[VBoxReleased]} {
		if {$dupl_vbx || $dupl_mix || $dupl_txt} {
			set msg "Chosen Files List Contains Duplicate Files\n\n"
			append msg "Your Selection Can Be Used For...\n\n"
			if {$dupl_vbx} {
				append msg "The Voicebox\n\n"
				if {$dupl_mix} {
					append msg "and\n\n"
					append msg "1) Making Mixfiles\n"
					append msg "2) Joining Files Together\n"
					append msg "3) Texture Processes\n"
					append msg "4) Multichannel Interleaving\n"
				}
			} elseif {$dupl_mix} {
				append msg "1) Making Mixfiles\n"
				append msg "2) Joining Files Together\n"
				append msg "3) Texture Processes\n"
				append msg "4) Multichannel Interleaving\n"
			} elseif {$dupl_txt} {
				append msg "1) Rhythmic Pattern Working\n"
				append msg "2) Data-Conversion Options\n"
			}
			append msg "\nOnly."
			Inf $msg
		}
	} else {
		if {$dupl_mix || $dupl_txt} {
			set msg "Chosen Files List Contains Duplicate Files\n\n"
			append msg "Your Selection Can Be Used For...\n\n"
			if {$dupl_mix} {
				append msg "1) Making Mixfiles\n"
				append msg "2) Joining Files Together\n"
				append msg "3) Texture Processes\n"
				append msg "4) Multichannel Interleaving\n"
			} elseif {$dupl_txt} {
				append msg "1) Rhythmic Pattern Working\n"
				append msg "2) Data-Conversion Options\n"
			}
			append msg "\nOnly."
			Inf $msg
		}
	}
}

#------ sort directory-listing files using an entered search-string

proc StrGetDl {} {
	global dl pr_dlss dl_sstr dl_sstr_zz dlss_typ wstk evv ww

	set f .dlss
	if [Dlg_Create $f "Search String" "set pr_dlss 0" -borderwidth $evv(BBDR)] {
		set b  [frame $f.b -borderwidth $evv(SBDR)]
		button $b.ok -text "Search" -width 5 -command "set pr_dlss 1" -highlightbackground [option get . background {}]
		button $b.q  -text "Close" -width 5 -command "set pr_dlss 0" -highlightbackground [option get . background {}]
		pack $b.ok -side left
		pack $b.q -side right
		set c [frame $f.c -borderwidth $evv(SBDR)]
		radiobutton $c.0 -variable dlss_typ -text "Starts with String" -value 0
		radiobutton $c.1 -variable dlss_typ -text "Includes String"    -value 1
		radiobutton $c.2 -variable dlss_typ -text "Ends with String"   -value 2
		radiobutton $c.3 -variable dlss_typ -text "Excludes String"    -value 3
		pack $c.0 $c.1 $c.2 $c.3 -side left
		set e  [frame $f.e -borderwidth $evv(SBDR)]
 		label $e.l -text "Search String"
		entry $e.e -width 20 -textvariable dl_sstr
		pack $e.l $e.e -side left -padx 1
		pack $f.b $f.c $f.e -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_dlss 1}
		bind $f <Escape> {set pr_dlss 0}
	}
	set dlss_typ 1
	if {[info exists dl_sstr_zz]} {
		set dl_sstr $dl_sstr_zz
	}
	set pr_dlss 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_dlss $f.e.e
	while {!$finished} {
		tkwait variable pr_dlss
		if {$pr_dlss} {
			if {$dlss_typ < 0} {
				Inf "No Search Type Selected."
				continue
			}
			if {[string length $dl_sstr] <= 0} {
				Inf "No (Valid) Search String Entered."
				continue
			}
			set dl_sstr [string tolower $dl_sstr]
			set this_dir [file dirname [$dl get 0]]
			if {[string length $this_dir] <= 1} {
				set this_dir ""
			}
			if {[info exists dl_sstr_zz] && ![string match $dl_sstr $dl_sstr_zz]} {
				unset dl_sstr_zz
			}
			foreach f_nam [glob -nocomplain [file join $this_dir *]] { 
				if {![string match "__" [string range [file tail $f_nam] 0 1]]} {
					lappend fnamlist $f_nam
				}
			}
			set local_fnamlist [$dl get 0 end]
			foreach f_nam $fnamlist {
				if {[lsearch $local_fnamlist $f_nam] < 0} {
					set msg "Search Entire Directory ?"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "no"} {
						set fnamlist $local_fnamlist
						set local 1
					} else {
						set alldir 1
					}
					break
				}
			}
			foreach fnam $fnamlist {
				if [file isdirectory $fnam] {
					continue
				}
				set ffnam [file rootname [file tail $fnam]]
				switch -- $dlss_typ {
					0 {
						if [string match $dl_sstr* $ffnam] {
							lappend ll $fnam
						}
					}
					1 {
						if {[string first $dl_sstr $ffnam] >= 0} {
							lappend ll $fnam
						}
					}
					2 {
						if [string match *$dl_sstr $ffnam] {
							lappend ll $fnam
						}
					}
					3 {
						if {[string first $dl_sstr $ffnam] < 0} {
							lappend ll $fnam
						}
					}
				}
			}
			if [info exists ll] {
				$dl delete 0 end
				foreach fnam [lsort -dictionary $ll] {
					$dl insert end $fnam
				}	
				$dl xview moveto 0.0
				if {[info exists alldir]} {
					$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
				}				
			} else {
				if [info exists local] {
					set thislist "Listed Here"
				} else {
					set thislist "In This Directory"
				}
				switch -- $dlss_typ {
					0 {
						Inf "No Files Whose Name Starts With '$dl_sstr' Are $thislist."
					}
					1 {
						Inf "No Files Whose Name Contains '$dl_sstr' Are $thislist."
					}
					2 {
						Inf "No Files Whose Name Ends With '$dl_sstr' Are $thislist."
					}
				}
			}
			set finished 1
		} else {
			set finished 1
		}
	} 
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Get previous to last set of files used

proc GetPreviousChosenList {} {
	global last_ch lalast_ch chlist ch chcnt previous_ch

	if {![info exists lalast_ch] || ([llength $lalast_ch] <= 0)} {
		return
	}
	if {![info exists previous_ch]} {
		set previous_ch {}
		if {[info exists chlist] && ([llength $chlist] > 0)} {
			set previous_ch $chlist
		}
		EnableRestoreChosenList
	}
	ClearWkspaceSelectedFiles
	foreach fnam $lalast_ch {
		if [file exists $fnam] {
			lappend chlist $fnam		;#	add to end of list
			$ch insert end $fnam		;#	add to end of display
			incr chcnt
		} else {
			Inf "File $fnam No Longer Exists"
		}
	}
	ChlistDupls
}

proc RestoreChosenList {} {
	global previous_ch ch chlist chcnt
	if {[info exists previous_ch]} {
		ClearWkspaceSelectedFiles
		foreach fnam $previous_ch {
			lappend chlist $fnam
			$ch insert end $fnam
			incr chcnt
		}
		unset previous_ch
	}
	DisableRestoreChosenList
}

proc DisableRestoreChosenList {} {
	global ww
	$ww.1.a.endd.r.x2.cp.menu entryconfig 4 -label "" -state disabled
}

proc EnableRestoreChosenList {} {
	global ww
	$ww.1.a.endd.r.x2.cp.menu entryconfig 4 -label "Restore Chosen List" -state normal
}

proc SomewhereOnWkspace {} {
	global tosomewhere wl
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {
		Inf "No Files Selected"
		return
	} else {
		catch {unset tosomewhere}
		foreach i $ilist {
			lappend tosomewhere [$wl get $i]
		}
		Inf "SAVED FILES, READY TO PASTE"
	}
}

proc PossiblyPut {y} {
	global wl tosomewhere

	set ilist [$wl curselection]
	set i [lindex $ilist 0]
	if {$i < 0} {
		Inf "No Position Specified"
		return
	}
	if {[info exists tosomewhere]} {
		foreach fnam $tosomewhere {
			set k [LstIndx $fnam $wl]
			if {$k < 0} {
				Inf "Cannot Insert Files, Workspace Has Been Modified"
				unset tosomewhere
				return
			}
		}
		foreach fnam $tosomewhere {
			set k [LstIndx $fnam $wl]
			if {$k < $i} {
				$wl insert $i $fnam
				$wl delete $k
			} else {
				$wl insert $i $fnam
				incr k
				$wl delete $k
				incr i
			}
		}
		unset tosomewhere
	} else {
		Inf "No Files Selected"
	}
}

proc Shortcuts {where} {
	global shortlock pr_shortcuts evv mm_multichan from_runpage pprg data_released mmod
	set f .shortcuts
	switch -- $where {
		"workspace" {
			set h_eight 46
		}
		"run" {
			set h_eight 7
		}
		"processpage" {
			set h_eight 38
		}
		"parampage" {
			set h_eight 28
		}
		"hfentry" {
			set h_eight 10
		}
		"qik" {
			set h_eight 30
		}
		"textfile" {
			set h_eight 25
		}
		"ts" {
			set h_eight 8
		}
		"spek" {
			set h_eight 8
		}
	}
	if {($where == "workspace") || ($where == "processpage")} {
		if [Dlg_Create $f "KEYBOARD SHORTCUTS" "set pr_shortcuts 0" -borderwidth $evv(BBDR)] {
			button $f.0 -text "OK" -command "set pr_shortcuts 0" -highlightbackground [option get . background {}]
			frame $f.1
			Scrolled_Listbox $f.1.0 -width 70 -height $h_eight -selectmode single
			Scrolled_Listbox $f.1.1 -width 70 -height $h_eight -selectmode single
			pack $f.1.0 $f.1.1 -side left
			pack $f.0 $f.1 -side top -pady 4
		}
	} else {
		if [Dlg_Create $f "KEYBOARD SHORTCUTS" "set pr_shortcuts 0" -borderwidth $evv(BBDR)] {
			button $f.0 -text "OK" -command "set pr_shortcuts 0" -highlightbackground [option get . background {}]
			Scrolled_Listbox $f.1 -width 70 -height $h_eight -selectmode single
			pack $f.0 $f.1 -side top -pady 4
		}
	}
	bind $f <Return> {set pr_shortcuts 0}
	bind $f <Escape> {set pr_shortcuts 0}
	bind $f <Key-space> {set pr_shortcuts 0}
	wm resizable $f 1 1
	switch -- $where {
		"workspace" {
			$f.1.0.list insert end "                            KEYBOARD SHORTCUTS"
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Return ......PROCESS Chosen Files."
			$f.1.0.list insert end "Space Bar  ..PLAY(+ STOP PLAY) highlighted, or Chosen, file(s)."
			$f.1.0.list insert end "Backspace ...CLEAR Chosen List."
			$f.1.0.list insert end "Tab .........Hilight on wkspace (only) files on Chosen List."
			$f.1.0.list insert end "Cmd Left/R...Toggle to or from CHOSEN FILES List"
			$f.1.0.list insert end "Cntrl 0 .....VIEW selected Wkspace Textfile or Soundfile."
			$f.1.0.list insert end "Cntrl e,E....EDIT selected Wkspace Textfile."
			$f.1.0.list insert end "Cntrl = .....SHOW (or STOP showing) pitchmarks with File select."
			$f.1.0.list insert end "Cntrl 8 .....Maximum Sample of soundfile."
			$f.1.0.list insert end "Cntrl 4 .....Find mixfile having name of selected sndfile."
			$f.1.0.list insert end "Cntrl 5 .....Move files to selected Directory."
			$f.1.0.list insert end "Cntrl 6 .....Move files to Directory, and Remove."
			$f.1.0.list insert end "Cntrl 8 .....Maximum Sample."
			$f.1.0.list insert end "Escape ......In Chosen Files Mode, goes to Worskpace Mode."

			$f.1.0.list insert end "Cmd l,L .....List Directory shown in Directory Name box."
			$f.1.0.list insert end "Cmd w,W .....Get Subdirectory Names"
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Shift Up ....Selected files to TOP of their listing"
			$f.1.0.list insert end "Shift Down ..to BOTTOM of their listing"
			$f.1.0.list insert end "Shift Left ..to next listing: Dirlist->Wkspace OR Wksp->Chosen"
			$f.1.0.list insert end "Shift Right .removed from Chosen List OR Wkspace"
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Shift  c,C ..CUT (Remember Wkspace files, ready to move)"
			$f.1.0.list insert end "Shift  p,P ..PASTE (Move grabbed files to new position)"
			$f.1.0.list insert end ""
			$f.1.0.list insert end "HIGHLIGHT on Wkspace (a,b etc): Directory List (A,B etc)"
			$f.1.0.list insert end "Cmd  a,A ... all ANALYSIS files"
			$f.1.0.list insert end "Cmd  b,B ....all BATCH files"
			$f.1.0.list insert end "Cmd  e,E ....all binary ENVELOPE files"
			$f.1.0.list insert end "Cmd  f,F ....all FORMANT files"
			$f.1.0.list insert end "Cmd  m,M ....all MIX files"
			$f.1.0.list insert end "Cmd  l,L ....all files in directory of selected file"
			$f.1.0.list insert end "Cmd  u,U ....all multi-CHANNEL MIX files"
			$f.1.0.list insert end "Cmd  p,P ....all PROPERTIES files"
			$f.1.0.list insert end "Cmd  o,O.....all sound-list (ORCHESTRA) files"
			$f.1.0.list insert end "Cmd  s,S.....all SOUND files"
			$f.1.0.list insert end "Cmd  t,T ....all TEXT files"
			$f.1.0.list insert end "Cmd  v,V ....launch Varibox"
			$f.1.0.list insert end "Cmd  z,Z ....Show zero-level snds: \"Z\" Recalcs level"
			$f.1.0.list insert end "Cmd  n ......See Current NOTEBOOK entry"
			$f.1.0.list insert end "Cmd  N ......See or Make Entry in NOTEBOOK"
			$f.1.0.list insert end "Cmd  = ......Creation date of file."
			$f.1.1.list insert end "Cmd  Down ...Go to End of wkspace"
			$f.1.1.list insert end "Cmd  Up .....Go to start of wkspace"
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Cntrl-Cmd  m ..is selected sndfile in any mixfile(s) ??"
			$f.1.0.list insert end "Cntrl-Cmd  T ..create mono thumbnail of multichannel soundfile."
			$f.1.0.list insert end ""
			if {$data_released} {
				$f.1.0.list insert end "# .............Data to sound conversion."
				$f.1.0.list insert end "Control e,E ...Data to numeric format."
			}
			$f.1.0.list insert end ""
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Cntrl-Cmd  Escape ..End the Session."

			$f.1.1.list insert end "Cntrl  a,A ..ADD top workspace file to Chosen List"
			$f.1.1.list insert end "Cntrl  b ....Get NON_BACKED-UP sounds from MIXFILE on Chosen List."
			$f.1.1.list insert end "Cntrl  B ....Get ALL sounds from a MIXFILE on Chosen List."
			$f.1.1.list insert end "Cmd Cntrl B ....Get all MUTED sounds from a MIXFILE on Chosen List."
			$f.1.1.list insert end "Cntrl  c,C ..COPY to wkspace Highlighted Directory-Listing Files"
			$f.1.1.list insert end "             ..... OR Copy (duplicate) Highlighted File on wkspace."
			$f.1.1.list insert end "Cntrl  d,D ..DESTROY File (ALSO \"Cntrl Delete\")"
			$f.1.1.list insert end "Cntrl  e,E ..VIEW Wkspace files"
			$f.1.1.list insert end "Cntrl  f,F ..FIND properties of file"
			$f.1.1.list insert end "Cntrl  g,G ..GRAB-to-wkspace Highlighted Directory-Listing Files"
			$f.1.1.list insert end "  ..... OR any sounds listed within highlighted textfile On Workspace."
			$f.1.1.list insert end "  ..... OR any sounds listed within textfile On Chosen List."
			$f.1.1.list insert end "Cntrl  h,H ..add top wkspace file to HEAD of Chosen List"
			$f.1.1.list insert end "Cntrl  i,I ..interleave (copies of) wkspace file between chosen files"
			$f.1.1.list insert end "Cntrl  j,J ..get max loudness of (several) file(s) in wkspace"
			$f.1.1.list insert end "Cntrl  l,L ..LAST files made to Chosen List"
			$f.1.1.list insert end "Cntrl  m ....get last MIXfile used : (* 2 -> params: * 3 -> QikEdit)"
			$f.1.1.list insert end "Cntrl  M ....get MAIN MIXfile used : (* 2 -> params: * 3 -> QikEdit)"
			$f.1.1.list insert end "Cntrl  n,N ..reNAME file"
			$f.1.1.list insert end "Cntrl  p,P ..PLAY all sounds chosen"
			$f.1.1.list insert end "Cntrl  r,R ..REMOVE from wkspace"
			$f.1.1.list insert end "Cntrl  s ....SEARCH for file"
			$f.1.1.list insert end "Cntrl  S ....new SEARCH for file"
			$f.1.1.list insert end "Cntrl  t,T ..WKSPACE file to Chosen List"
			$f.1.1.list insert end "Cntrl  u,U ..REFRESH selected files"
			$f.1.1.list insert end "Cntrl  w,W ..wkspace: toggle to or from Chosen Files List"
			$f.1.1.list insert end "Cntrl  z ....SEARCH for (& Sort) ALL wkspace files with pattern"
			$f.1.1.list insert end "Cntrl  Z ....SEARCH DIRECTORY LISTING for all files with pattern"
			$f.1.1.list insert end "Cntrl  Up ...move selected file(s) to Top of workspace"
			$f.1.1.list insert end "Cntrl  Down .move selected file(s) to Foot of workspace"
			$f.1.1.list insert end "Cntrl  Left .Selected file(s) or top file to Chosen list"
			$f.1.1.list insert end "Cntrl  Right Remove selected file(s) from workspace"
			$f.1.1.list insert end ""
			$f.1.1.list insert end "                              MOUSE ACTIONS"
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Double Click ..  PLAY / READ"
			$f.1.1.list insert end "Cmd Click ..... VIEW SOUND / TEXT"
			$f.1.1.list insert end "Shift Click ... selected item to TOP of Chosen Files list"
			$f.1.1.list insert end "                            (\"Chosen Files\" mode only)"
			$f.1.1.list insert end ""
			$f.1.1.list insert end "IN ~ANY~ FILE-NAMING BOX ~ANYWHERE~ ON THE SOUNDLOOM"
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Up  ..........increments number at END of name"
			$f.1.1.list insert end "Down  ........decrements number at END of name"
			$f.1.1.list insert end "Control-Up  ..increments number at START of name"
			$f.1.1.list insert end "Control-Down  decrements number at START of name"
			$f.1.1.list insert end ""
		}
		"processpage" {
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Return .....Uses Same Process Again."
			$f.1.0.list insert end "Escape .....Quit."
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Cntrl  f,F .. FIND properties of file(s) to process"
			$f.1.0.list insert end "Cntrl  c,C .. CHANNEL cnt of file(s) to process"
			$f.1.0.list insert end ""
			$f.1.0.list insert end ""
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Depending on NUMBER and TYPE of sounds being processed.."
			$f.1.0.list insert end ""
			$f.1.0.list insert end "Cmd 1 .......MONO: Convert multichannel sndfile to mono."
			$f.1.0.list insert end "Cmd b,B .... BRASSAGE (full monty or Sausage) or BLUR"
			$f.1.0.list insert end "Cmd c,C .... CHANNEL: Interleave, Extract, or Mono->Stereo"
			$f.1.0.list insert end "             or COMBINE: Pitch+Formants, or 2 spectra"
			$f.1.0.list insert end "Cmd k,K .... CURTAIL: double strength"
			$f.1.0.list insert end "Cmd d,D .... DOVETAIL: double strength"
			$f.1.0.list insert end "Cmd e,E .... EDIT: cut out and keep"
			$f.1.0.list insert end "Cmd # . .... EDIT: cut out and keep MANY"
			$f.1.0.list insert end "Cmd f,F .... FILTER: lopass/hipass, bands as frq, or get FORMANTS"
			$f.1.0.list insert end "Cmd g,G .... GRAIN: count"
			$f.1.0.list insert end "Cmd h,H .... HILIGHT: Trace, between frqs"
			$f.1.0.list insert end "Cmd i,I .... ITERATE, give dur,  or Edit INSERT"
			$f.1.0.list insert end "Cmd j,J .... JOIN"
			$f.1.0.list insert end "Cmd l,L .... LOUDNESS: gain"
			$f.1.0.list insert end "Cmd m,M .... MIX Create, or Run: or (cosin) MORPH"
			$f.1.0.list insert end "Cmd n,N .... Loudness NORMALISE"
			$f.1.0.list insert end "Cmd p,P .... PVOC: Analysis or Synthesis"
			$f.1.0.list insert end "Cmd r,R .... REVERB:ECHO: stadium, or"
			$f.1.0.list insert end "             or REPITCH extract pitch to textfile"
			$f.1.0.list insert end "Cmd s,S .... SEMITONES Transpose"
			$f.1.0.list insert end "Cmd t,T .... TIME Stretch"
			$f.1.0.list insert end "Cmd v,V .... VIBRATO Pitch"
			$f.1.0.list insert end "Cmd w,W .... TREMOLO Loudness (wobble)"
			$f.1.0.list insert end "Cmd x,X .... eXCISE (remove segment)."
			$f.1.0.list insert end "Cmd z,Z .... ZIGZAG, user specified"
			$f.1.0.list insert end ""

			$f.1.1.list insert end ""
			$f.1.1.list insert end "Control-Cmd-Escape ... End the Session"
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Right,Left ...Toggles to Menu-Info,"
			$f.1.1.list insert end "              to Process-Info,"
			$f.1.1.list insert end "              then back to Active State."
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Space Bar ... PLAY (and Stop) Chosen File(s)."
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Depending on NUMBER and TYPE of sounds being processed.."
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Cntrl Cmd c,C .. COMPARE: Two soundfiles."
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Cntrl Cmd d,D .. DRUNKWALK: completely"
			$f.1.1.list insert end "Cntrl e,E ...... ENVELOPE: Extract"
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Cntrl Cmd f,F .. FILTER: band pass"
			$f.1.1.list insert end "Cntrl Cmd g,G .. GRAIN: assess"
			$f.1.1.list insert end "Cntrl Cmd h,H .. HOLD: spectral window"
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Cntrl m,M ...... MULTICHANNEL MIX Create or ANY MIX Run"
			$f.1.1.list insert end "Cntrl Cmd p,P .. PAN Sound"
			$f.1.1.list insert end "Cntrl Cmd r,R .. REPEAT DISTORT"
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Cntrl Cmd s,S .. STACK, or SEMITONES Transpose but keep fmnts"
			$f.1.1.list insert end "Cntrl Cmd t,T .. TEXTURE: simple, neutral"
			$f.1.1.list insert end "Cntrl Cmd v,V .. VARIBANK Filter, data as midi"
			$f.1.1.list insert end ""
			$f.1.1.list insert end "Cntrl Cmd x,X .. eXCISE MANY, remove several segements."
			$f.1.1.list insert end "Cntrl Cmd z,Z .. ZERO crossing cut."
			$f.1.1.list insert end ""
			$f.1.1.list insert end ""
		}
		"run" {
			$f.1.list insert end ""
			$f.1.list insert end "Return .... Run process."
			$f.1.list insert end "     + acknowledge process completion."
			$f.1.list insert end "Escape .. Kill process, producing NO OUTPUT."
		}
		"parampage" {
			$f.1.list insert end ""
			$f.1.list insert end "Return + Return: RUN Process"
			$f.1.list insert end "Escape .... Quit"
			$f.1.list insert end "Space Bar ..PLAY (and Stop) Output (or Input, if no Output)."
			$f.1.list insert end ""
			$f.1.list insert end "Up - Down KEYS: Move between parameter."
			$f.1.list insert end "SHIFT Up - Down KEYS: Change (numeric) value of parameter."
			$f.1.list insert end ""
			$f.1.list insert end "TAB ....... in parameter value box, checks value."
			$f.1.list insert end "            In frq parameters, with pitch-boxes attached,"
			$f.1.list insert end "            puts closest tempered pitch in pitch box."
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  0 .. SEE selected Textfile Parameter."
			$f.1.list insert end "Cntrl  e,E  EDIT selected Textfile Parameter."
			$f.1.list insert end "Cntrl  8 .. Maximum Sample of SOURCE."
			$f.1.list insert end "Cntrl  9 .. Maximum Sample of OUTPUT."
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  s,S  SAVE Output, or (creating instrmnt) Process"
			$f.1.list insert end ""
			$f.1.list insert end "Cmd  d,D .. Set DEFAULT values in ALL Params."
			$f.1.list insert end "Cmd  p,P .. Set PENULTIMATE values in all params."
			$f.1.list insert end "Cmd  n,N .. Get a NEW Process."
			$f.1.list insert end "Cmd  r,R .. RECYCLE Outfile."
			$f.1.list insert end ""
			$f.1.list insert end "Cmd  c,C .. Play selected CHANNEL of multichan outfile."
			$f.1.list insert end ""
			$f.1.list insert end "Control-Cmd-Escape ... End the Session"
		}
		"hfentry" {
			$f.1.list insert end ""
			$f.1.list insert end "Click on Staff...............Add a Note"
			$f.1.list insert end "SHIFT-Click on Staff.........Add SHARP (Flat) Note"
			$f.1.list insert end ""
			$f.1.list insert end "COMMAND-Click on Staff.......Add a PASSING Note"
			$f.1.list insert end "COMMAND-SHFT-Click on Staff..Add SHARP(Fl) PASSING Note"
			$f.1.list insert end ""
			$f.1.list insert end "CONTROL-Click on Staff.......DELETE a note"
		}
		"qik" {
			$f.1.list insert end ""
			$f.1.list insert end "Space Bar ..... Play (and Stop) sound in line"
			$f.1.list insert end "Double Click .. Play sound in line"
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  Up ... Go to top of listing"
			$f.1.list insert end "Cntrl  Down.. Go to bottom of listing"
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  s,S ...Get START time snd in highlighted line"
			$f.1.list insert end "Cntrl  a,A ...Add START time snd in highlighted line to value in Value Box"
			$f.1.list insert end "Cntrl  e,E ...Get END time of sound in line"
			$f.1.list insert end "Cntrl  g,G ...Get GAIN, max possible for sound in line"
			$f.1.list insert end "Cntrl  n,N ...Get line NUMBER"
			$f.1.list insert end "Cntrl  h,H ...HIGHLIGHT line whose number is in Value box (cursor in Value Box)"
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  t,T .. Show text if text-property linked with sound in line"
			$f.1.list insert end ""
			$f.1.list insert end "Up   .........Increment Value in Value Box"
			$f.1.list insert end "Down  ........Decrement Value in Value Box"
			$f.1.list insert end ""
			$f.1.list insert end "Shift  Up   ..Selected lines to Top of listing"
			$f.1.list insert end "Shift  Down ..Selected lines to Foot of listing"
			$f.1.list insert end ""
			$f.1.list insert end "Shift  Left ..Selected lines are Muted"
			$f.1.list insert end "Shift  Right..Selected lines are Unmuted"
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  d,D ...Remove selected MUTED lines (only)"
			$f.1.list insert end ""
			$f.1.list insert end "Cntrl  q,Q ...View Sound Output of Mix"
			$f.1.list insert end ""
			if {$mm_multichan} {
				$f.1.list insert end "Cmd  s ... Graphic Display output channel assignment"
				$f.1.list insert end "                       for selected mixfile line."
			} else {
				$f.1.list insert end "Cmd  Up   ... Shuffle Gain-value up"
				$f.1.list insert end "Cmd  Down ... Shuffle Gain-value down"
				$f.1.list insert end ""
				$f.1.list insert end "Cmd  Right .. Shuffle Time-value up"
				$f.1.list insert end "Cmd  Left  .. Shuffle Time-value down"
				$f.1.list insert end ""
			}
		}
		"textfile" {
			$f.1.list insert end "Entering musical meter"
			$f.1.list insert end ""
			$f.1.list insert end "Not available on the MAC"
			$f.1.list insert end ""
		}
		"ts" {
			$f.1.list insert end "Keyboard Shortcuts"
			$f.1.list insert end "Escape: ...Quit"
			$f.1.list insert end "Return: ...Make Sound"
			$f.1.list insert end "Space: ....Play Sound"
			$f.1.list insert end "Cntrl  S ..Save Sound"
			$f.1.list insert end "Cntrl  P ..Play datafile directly"
			$f.1.list insert end "Cmd  S ....Save Settings"
			$f.1.list insert end "Cmd  L ....Load Settings"
			$f.1.list insert end "Tab .......Select All Files"
		}
		"spek" {
			$f.1.list insert end "Keyboard Shortcuts"
			$f.1.list insert end "Return ....Run default transform"
			$f.1.list insert end "\"#\" .....Get a named transform"
			$f.1.list insert end "Escape ....Quit"
			$f.1.list insert end "Space .....Play Spek output"
			$f.1.list insert end "Cntrl  1 ..Sound from data maxima"
		}
	}
	set pr_shortcuts 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_shortcuts
	tkwait variable pr_shortcuts
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc HiliteFoundFilesOnDirList {ilist} {
	global dl
	set jj 0
	foreach fnam [$dl get 0 end] {
		foreach i $ilist {
			set fnam2 [.find_file.ll.list get $i]
			if {[string match $fnam $fnam2]} {
				lappend sel_list $jj
				break
			}
		}
		incr jj
	}
	$dl selection clear 0 end
	foreach jj $sel_list {
		$dl selection set $jj
	}
	set jj [lindex $sel_list 0]
	set kk [$dl index end]
	set	kk [expr double($jj) / double ($kk)]
	$dl yview moveto $kk
}

proc Key_Keep {restore} {
	global key_chosen pa evv chlist ch chcnt
	if {$restore} {
		if {![info exists key_chosen]} {
			Inf "No Source Stored"
			return
		}
		if {![file exists $key_chosen]} {
			Inf "File '$key_chosen' No Longer Exists"
			return
		}
		if {![info exists pa($key_chosen,$evv(FTYP))]} {
			Inf "File '$key_chosen' Is No Longer On The Workspace"
			return
		}
		DoChoiceBak
		set chlist $key_chosen
		$ch delete 0 end
		$ch insert end $key_chosen
		set chcnt 1
	} else {
		if {![info exists chlist] || ([llength $chlist] <= 0)} {
			Inf "No Chosen File To Remember"	
			return
		}
		if {[llength $chlist] > 1} {
			Inf "More Than One Chosen File Listed"	
			return
		}
		set key_chosen [lindex $chlist 0]
	}
}

proc BaseChosName {} {
	global wl ch file_overwrite origrootname chlist evv
	global pa chcnt rememd background_listing wstk scores_refresh sl_real 
	if {![info exists chlist]} {
		Inf "No Chosen File"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "Select Just One Chosen File"
		return
	}
	set chname [lindex $chlist 0]
	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	if {[llength $ilist] > 1} {
		Inf "Select Just One Workspace File"
		return
	}
	set i [lindex $ilist 0]
	set oi $i
	set fnam [$wl get $i]
	if {[string match $chname $fnam]} {
		Inf "Files Have The Same Name"	
		return
	}
	set fnam_ext [file extension $fnam]
	set origchname $chname
	set chname [file rootname [file tail $chname]]
	set is_snd 0
	if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
		set is_snd 1
	}
	set origchname_ext [file extension $origchname]
	set matchOK 0
	if {![string match $origchname_ext $fnam_ext]} {
		set matchOK 1
	}
	if {[string length [file dirname $origchname]] > 1} {	;#	Copying name WITHOUT using dirname is OK
		set matchOK 1
	}
	set ren_blist 0
	set file_overwrite 0
	set done 1
	set haspmark [HasPmark $fnam]
	set hasmmark [HasMmark $fnam]
	set file_overwrite 0									;#	Default dialog caption for next file
	set fextens	 [file extension $fnam]
	set thisname [file tail $fnam]
	if [string match $thisname $fnam] {
		set dirname ""
	} else {
		set dirname [file dirname $fnam]
	}
	set origrootname [file rootname $thisname]
	set is_completed 0
	while {!$is_completed} {
		set newrootname [Dlg_Rootname_Change $chname $matchOK]
		if {[string length $newrootname] <= 0} {
			set done 0
			break
		}
		set	nufnam [file join $dirname $newrootname$fextens]
		if {$file_overwrite} {
			set newname_pos_on_wkspce [LstIndx $nufnam $wl]
			if {[LstIndx $nufnam $ch] >= 0} {
				Inf "You Cannot Overwrite The Chosen File Using This Rename Option"
				set file_overwrite 0
				continue
			}
			if [catch {file rename -force $fnam $nufnam} zorg] {
				Inf "Cannot Rename Existing Workspace File $fnam"
				set file_overwrite 0
				continue
			} else {
				UpdateBakupLog $fnam delete 0
				UpdateBakupLog $nufnam modify 1
				CheckMainmix $fnam $nufnam
				CheckMainmixSnd $fnam $nufnam
				DummyHistory $nufnam "OVERWRITTEN"
				if [IsInBlists $nufnam] {
					set msg "The Overwritten File $nufnam Was Mentioned In Background Listings\n\nRemove Those Mentions ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						if [RemoveFromBLists $nufnam] {
							set ren_blist 1
						}
					}
				}
				if {$is_snd} {
					DataManage rename $fnam $nufnam
					if [IsOnScore $nufnam] {
						set msg "The Overwritten File $nufnam Is In Use On Current Score\n\nRemove It ??"
						set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
						if {$choice == "yes"} {
							RemoveFromScore $nufnam
							set scores_refresh 1
						}
					} else {
						set scores_refresh 1
					}
				}
			}
			if {$newname_pos_on_wkspce >= 0} {				;#	If new filename was already on workspace
				$wl delete $i								;#	Just delete old filename from workspace
				WkspCnt $nufnam -1							;# 	File overwritten, but origname file disappears!
				set k [LstIndx $nufnam $wl]
				$wl delete $k
				$wl insert $i $nufnam
			} else {
				$wl delete $i								
				$wl insert $i $nufnam
			}
		} else {
			if [catch {file rename $fnam $nufnam} k] {	
				if {[string length [file rootname [file tail $fnam]]] == 8 \
				|| [string length [file rootname [file tail $nufnam]]] == 8} {
					Inf "TK/TCL May Give An Anomalous 'Overwrite' Request With 8 Character Names\nIf In Doubt, Check Whether An Overwrite Will Truly Happen!!"
				}
				set file_overwrite 1
				continue
			} else {						  					;#	Valid name, and file doesn't exist
				DataManage rename $fnam $nufnam
				set couettelist [list $fnam $nufnam]
				UpdateBakupLog $fnam delete 0
				UpdateBakupLog $nufnam create 1
				CheckMainmix $fnam $nufnam
				CheckMainmixSnd $fnam $nufnam
				$wl delete $i								
				$wl insert $i $nufnam							;#	rename workspace item
				RenameOnDirlist $fnam $nufnam
			}
		}
		set is_completed 1
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$done} {
		DummyHistory $fnam "RENAMED_$nufnam"
		UpdateChosenFileMemory $fnam $nufnam
		RenameProps	$fnam $nufnam 1				;#	rename props
		MixMRename $fnam $nufnam 1
		if {$is_snd} {
			set scores_refresh 1
			if {$haspmark} {
				MovePmark $fnam $nufnam
			}
			if {$hasmmark} {
				MoveMmark $fnam $nufnam
			}
			if [IsInBlists $fnam] {
				if [RenameInBlists $fnam $nufnam] {
					set ren_blist 1
				}
			}
			if [IsOnScore $fnam] {
				RenameOnScore $fnam $nufnam
			}
		}
		if {$ren_blist} {
			SaveBL $background_listing
		}
		AddNameToNameslist [file tail $nufnam] 0
		catch {unset rememd}
	}
	$wl selection set $oi
}

proc SelectMixfileToChlist {nulist} {
	global pr_smtoch mstc_nulist smtoch_keepmix chlist evv
	set f .smtoch
	set mstc_nulist [lindex $chlist 0]
	if [Dlg_Create $f "Soundfiles in Mix" "set pr_smtoch 0" -borderwidth $evv(BBDR)] {
		button $f.ok -text "OK" -command "set pr_smtoch 0" -highlightbackground [option get . background {}]
		pack $f.ok -side top -pady 2
		label $f.lab -text "SELECT SOUNDFILE WITH MOUSE-CLICK"
		pack $f.lab -side top -pady 2
		checkbutton $f.ch -variable smtoch_keepmix -text "Keep Mixfile on Chosen Files List"
		pack $f.ch -side top -pady 2
		Scrolled_Listbox $f.ll -width 64 -height 24 -selectmode single
		pack $f.ll -side top -fill both -expand true -pady 2
		wm resizable $f 1 1
		bind $f.ll.list <ButtonRelease-1> {MixfileSndToChlist %y}
		bind $f <Return> {set pr_smtoch 0}
		bind $f <Escape> {set pr_smtoch 0}
		bind $f <Key-space> {set pr_smtoch 0}
	}
	$f.ll.list delete 0 end
	foreach fnam $nulist {
		$f.ll.list insert end $fnam
	}
	set pr_smtoch 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_smtoch $f.ll.list
	tkwait variable pr_smtoch
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return $mstc_nulist
}

proc MixfileSndToChlist {y} {
	global mstc_nulist
	set i [.smtoch.ll.list nearest $y]
	set mstc_nulist [.smtoch.ll.list get $i]
}

proc ReinstallInstruments {} {
	global evv wstk ins
	set msg "It Is Strongly Recommended That You Make A Copy Of All Files With Extension '.mb'\nIn The Directory '$evv(INS_DIR)'\nBefore Proceeding\n\nDo You Want To Proceed Now ??"
	set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
	if {$choice == "no"} {
		return
	}
	if {![AreYouSure]} {
		return
	}
	set pwd [pwd]
	set thisdir [file join $pwd $evv(CDPROGRAM_DIR)]
	foreach fnam [glob -nocomplain [file join $evv(INS_DIR) *.mb]] {
		lappend flist $fnam
	}
	if {![info exists flist]} {
		Inf "No Instruments To Update"
		return
	}
	foreach fnam $flist {
		set already_valid 0
		if [catch {open $fnam "r"} zit] {
			lappend badinstrs $fnam
			continue
		}
		catch {unset nulines}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			catch {unset nuline}
			set line [split $line]
			set cnt 0
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {$cnt == 0} {
					if {[string first $thisdir $item] == 0} {
						set already_valid 1
						break
					} else {
						set thisprog [file tail $item]
						set nuline [file join $thisdir $thisprog]
					}
				} else {
					lappend nuline $item
				}
				incr cnt
			}
			if {$already_valid} {
				break
			}
			if {[info exists nuline]} {
				lappend nulines $nuline
			}
		}
		if {$already_valid} {
			lappend validfiles $fnam
			continue
		}
		close $zit
		if [catch {open $fnam "w"} zit] {
			lappend badfiles $fnam
			continue
		}
		foreach line $nulines {
			set line [join $line]
			puts $zit $line
		}
		close $zit
		lappend goodfiles $fnam
	}
	if {[info exists validfiles]} {
		if {![info exists goodfiles] && ![info exists badfiles]} {
			Inf "All Instrument Are Already Valid"
			return
		}
		set msg "The Following Instrument Files Were Already Valid\n"
		set cnt 0
		foreach fnam $validfiles {
			incr cnt
			append msg $fnam "    "
			if {$cnt >= 20} {
				append msg "\nAnd More"
				break
			}
		}
		Inf $msg
	}
	if {[info exists badfiles]} {
		set msg "Unable To Fix The Following Instrument Files\n"
		set cnt 0
		foreach fnam $badfiles {
			incr cnt
			append msg $fnam "    "
			if {$cnt >= 20} {
				append msg "\nAnd More"
				break
			}
		}
		Inf $msg
	}
	if {[info exists goodfiles]} {
		if {![info exists badfiles] && ![info exists validfiles]} {
			Inf "All Instrument Files Have Been Updated"
		} else {
			Inf "All Other Instrument Files Have Been Updated"
		}
		catch {unset ins(uberlist)}
		LoadInsInfo
	}
}

proc IsABrkfile {ftyp} {
	global evv
	if {($ftyp != $evv(MIX_MULTI)) && ($ftyp & $evv(IS_A_BRKFILE))} {
		return 1
	}
	return 0
}

proc IsANormdBrkfile {ftyp} {
	global evv
	if {($ftyp != $evv(MIX_MULTI)) && ($ftyp & $evv(IS_A_NORMD_BRKFILE))} {
		return 1
	}
	return 0
}

proc MixfileSndfilesOnWkspace {fnam fullmsg} {
	global evv pa wstk wl
	set linecnt 0
	if {![catch {open $fnam "r"} zit]} {
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string match ";" [string index $line 0]]} {
				continue
			}
			if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
				if {$linecnt == 0} {
					incr linecnt
					continue
				}
			}
			set line [split $line]
			set sndfnam [lindex $line 0]
			if {![info exists pa($sndfnam,$evv(FTYP))]} {
				lappend badfiles $sndfnam
			}
			incr linecnt
		}
		close $zit
		if {[info exists badfiles]} {
			set mfnam $fnam
			set msg2 ""
			if {$pa($fnam,$evv(FTYP)) == $evv(MIX_MULTI)} {
				set msg2 "Multi_Channel"
			}
			if {$fullmsg} {
				set msg "File $fnam Is A $msg2 Mixfile\n"
				append msg ": But The Following Files Are No Longer On The Workspace\n"
				set n 0
				foreach fnam $badfiles {
					append msg "$fnam   "
					incr n
					if {$n == 20} {
						append msg "\nAND MORE"
						break
					}
				}
				set msg3 $msg
				append msg3 "\n\n**** If The Missing Files Are In The Working Directory, You Can Attempt To Recover Them Now ***\n\n"
				append msg3 "Attempt Recovery Now ???"
				set choice [tk_messageBox -type yesno -default yes -message $msg3 -icon question -parent [lindex $wstk end]]
				if {$choice == "yes"} {
					set restored 0
					foreach ffnam $badfiles {
						if [file exists $ffnam] {
							if {[FileToWkspace $ffnam 0 0 0 1 0] > 0} {
								incr restored
							}
						}
					}
					if {$restored == [llength $badfiles]} {
						set k [LstIndx $mfnam $wl]
						if {$k >= 0} {
							$wl selection clear 0 end
							$wl delete $k
							$wl insert 0 $mfnam
							$wl selection set 0
							$wl yview moveto 0
						}					
						Inf "All Missing Files Have Been Successfully Added To Workspace\n\nUpdate The Mixfile Again, To Restore It.\n"
						return ""
					}
				} 
				set msg "\nTo Recover The Mix, Either\n"
				append msg "\n1) Edit The Mixfile & Refresh Data For This File"
				append msg "\n2) Load The Missing Files To The Workspace, And Refresh Data For This Mixfile"
				append msg "\n3) Move Files To The Appropriate Directories"
				Inf $msg
			} else {
				set msg "But Some Sounds Are No Longer On The Workspace"
				return $msg
			}
		}
	}
    if {!$fullmsg} {
		return ""
	}
}

proc OmitSpaces {fnam} {
	set len [string length $fnam]
	set i 0
	while {$i < $len} {
		set j [string index $fnam $i]
		if [string match $j " "] {
			append outstr "\\ "
		} else {
			append outstr $j
		}
		incr i
	}
	return $outstr
}

proc HiliteLastOutfiles {} {
	global last_outfile wl

	if {![info exists last_outfile]} {
		return
	}
	$wl selection clear 0 end
	foreach fnam $last_outfile {
		set k [LstIndx $fnam $wl]
		if {$k >= 0} {
			$wl selection set $k
		}
	}
}

proc TransferName {suffix} {
	global wl chlist ch chcnt last_mix pa evv rememd
	global sl_real background_listing dupl_mix dupl_vbx dupl_txt scores_refresh nessinit

	if {!$sl_real} {
		Inf "Transfer Part Of Name Of One Selected File To The Other"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] != 2} {							
		Inf "A Pair Of Files Must Be Selected"
		return
	}
	if {[info exists nessinit]} {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Name Swaps With Physical Modelling Files"
				return
			}
		}
	}
	set cnt 0
	foreach i $ilist {										;# check for valid (set of) files
		lappend innames [$wl get $i]
		if {$cnt == 0} {
			set baseext [file extension [$wl get $i]]
		} else {
			if {$suffix <= 1} {
				if {![string match [file extension [$wl get $i]] $baseext]} {
					Inf "File '[$wl get $i]' Is Not Of The Same Type As The First File"
					return
				}
			}
		}
		incr cnt
	}
	set cnt 0
	set affixed -1
	foreach fnam $innames {
		switch -- $suffix {
			0 {
				set fnam [file rootname [file tail $fnam]]
				set k [string first "_" $fnam]
				if {$k <= 0} {
					incr cnt
					continue
				}
				incr k -1
				set zz [string range $fnam 0 $k]
				if {[regexp {^[0-9]+$} $zz]} {
					if [info exists affix] {
						Inf "Both Files Have A Numeric Prefix"
						return
					}
					set affixed $cnt
					set affix $zz
				}
			}
			1 {
				set fnam [file rootname [file tail $fnam]]
				set penult [string length $fnam]
				incr penult -2
				if {$penult < 0} {
					incr cnt
					continue
				}
				set k [string last "_" $fnam]
				if {$k > $penult} {
					incr cnt
					continue
				}
				incr k
				set zz [string range $fnam $k end]
				if {[regexp {^[0-9]+$} $zz]} {
					if [info exists affix] {
						Inf "Both Files Have A Numeric Suffix"
						return
					}
					set affixed $cnt
					set affix $zz
				}
			}
			2 -
			3 {
				set ftyp $pa($fnam,$evv(FTYP))
				if {$cnt == 0} {
					if {$ftyp & $evv(IS_A_SNDSYSTEM_FILE)} {
						set issnd 0
					} elseif {$ftyp & $evv(IS_A_TEXTFILE)} {
						set istxt 0
					} else {
						Inf	"Neither File Is A Textfile Or A Soundsystem File"
						return
					}
				} else {
					if {[info exists issnd]} {
						if {($ftyp & $evv(IS_A_TEXTFILE))} {
							set istxt 1
						} else {
							Inf	"Must Use A Textfile And A Soundsystem File For This Option"
							return
						}
					} else {
						if {($ftyp & $evv(IS_A_SNDSYSTEM_FILE))} {
							set issnd 1
						} else {
							Inf	"Must Use A Textfile And A Soundsystem File For This Option"
							return
						}
					}
				}
			}
		}
		incr cnt
	}
	set is_snd 0
	switch -- $suffix {
		0 -
		1 {
			set affixed	[expr !$affixed]
			set i [lindex $ilist $affixed]
			set fnam [lindex $innames $affixed]
			set dirname [file dirname $fnam]
			set thisfnam [file tail $fnam]
			if [string match $thisfnam $fnam] {
				set dirname ""
			}
			set rfnam [file rootname $thisfnam]
			set ext [file extension $thisfnam]
			switch -- $suffix {
				1 {
					set nufnam $rfnam
					append nufnam "_" $affix $ext
				} 
				0 {
					set nufnam $affix
					append nufnam "_" $rfnam $ext
				}
			}
			set nufnam [file join $dirname $nufnam]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				set is_snd 1
			}
		}
		2 { ;# snd -> txt
			set fnam [lindex $innames $istxt]	;#	File whose name is changed
			set sndfnam [lindex $innames $issnd]
			set nufnam [file rootname [file tail $sndfnam]]
			set dirname [file dirname $fnam]
			if {[string length $dirname] <= 1} {
				set dirname ""
			}
			append nufnam [file extension $fnam]
			set nufnam [file join $dirname $nufnam]
			set i [LstIndx $fnam $wl]
		}
		3 { ;# txt -> snd
			set fnam [lindex $innames $issnd]	;#	File whose name is changed
			set txtfnam [lindex $innames $istxt]
			set nufnam [file rootname [file tail $txtfnam]]
			set dirname [file dirname $fnam]
			if {[string length $dirname] <= 1} {
				set dirname ""
			}
			append nufnam [file extension $fnam]
			set nufnam [file join $dirname $nufnam]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				set is_snd 1
			}
			set i [LstIndx $fnam $wl]
		}
	} 
	if {[file exists $nufnam]} {
		Inf "File '$nufnam' Already Exists"
		return
	}
	set haspmark [HasPmark $fnam]
	set hasmmark [HasMmark $fnam]
	set oldname_pos_on_chosen [LstIndx $fnam $ch]
	if [catch {file rename $fnam $nufnam} k] {	
		Inf "Rename Failed"
		return
	}
	DataManage rename $fnam $nufnam
	set couettelist [list $fnam $nufnam] 
	CouetteManage rename $couettelist
	UpdateBakupLog $fnam delete 0
	UpdateBakupLog $nufnam create 1
	CheckMainmix $fnam $nufnam
	CheckMainmixSnd $fnam $nufnam
	$wl delete $i								
	$wl insert $i $nufnam						;#	rename workspace item
	if {$haspmark} {
		MovePmark $fnam $nufnam
	}
	if {$hasmmark} {
		MoveMmark $fnam $nufnam
	}
	if [IsInBlists $fnam] {
		if [RenameInBlists $fnam $nufnam] {
			SaveBL $background_listing
		}
	}
	if [IsOnScore $fnam] {
		RenameOnScore $fnam $nufnam
	}
	UpdateChosenFileMemory $fnam $nufnam
	if {$oldname_pos_on_chosen >= 0} {
		RemoveFromChosenlist $fnam
		set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
		incr chcnt
		$ch insert $oldname_pos_on_chosen $nufnam
	}
	RenameProps	$fnam $nufnam 1				;#	rename props
	DummyHistory $fnam "RENAMED_$nufnam"
	MixMRename $fnam $nufnam 1
	AddNameToNameslist [file tail $nufnam] 0
	RenameOnDirlist $fnam $nufnam
	if {$is_snd} {
		set scores_refresh 1
	}
	catch {unset rememd}
	foreach i $ilist {
		$wl selection set $i
	}
}

#--- Set up Qikbutton

proc ActivateQikbutton {} {
	global ww wl qikbutton qboftpye pr_qikbut nessinit evv

	set f .qikbutmake
	if [Dlg_Create $f "SET UP QUICK BUTTON" "set pr_qikbut 0" -borderwidth 2] {
		frame $f.0
		frame $f.1
		label $f.0.1 -text "Put Command in Menu 'AGAIN' box onto QUICKBUTTON"
		pack $f.0.1 -side top
		radiobutton $f.1.0 -variable qboftpye -text "Any/All Menu" -value 3 -command "set pr_qikbut 1"
		radiobutton $f.1.1 -variable qboftpye -text "Selected File Menu" -value 1  -command "set pr_qikbut 1"
		radiobutton $f.1.2 -variable qboftpye -text "Selected File OF TYPE Menu" -value 2 -command "set pr_qikbut 1"
		radiobutton $f.1.3 -variable qboftpye -text "Directory LIST Menu" -value 4 -command "set pr_qikbut 1"
		radiobutton $f.1.4 -variable qboftpye -text "No Action" -value 5 -command "set pr_qikbut 1"
		button $f.1.5 -text Close -command "set pr_qikbut 0" -highlightbackground [option get . background {}]
		pack $f.1.0 $f.1.1 $f.1.2 $f.1.3 $f.1.4 -side left
		pack $f.1.5 -side right
		pack $f.0 $f.1 -side top -pady 4 -fill x -expand true
		set qboftype 0
		bind $f <Escape>  {set pr_qikbut 0}
	}
	set pr_qikbut 0
	set qboftype 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_qikbut $f.0
	tkwait variable pr_qikbut
	if {$pr_qikbut} {
		if {$qboftpye == 5} {
			$qikbutton config -command {}
		} elseif {$qboftpye == 2} {
			set str [$ww.1.a.endd.l.new.cre.menu entrycget 2 -label]
			switch -- $str {
				"Add Further Sounds To Listing" {
					$qikbutton config -command "AddToFile"
				}
				"Change Dir Of Files Listed In Textfile" {
					$qikbutton config -command "ChangeDirInFile"
				}
				"Play All Files Listed In Sndlist" {
					$qikbutton config -command "PlayAllChosen 1"
				}
				"Compare Selected Textfiles" {
					$qikbutton config -command "CompareTextfiles"
				}
				"Create Brkpnt File" {
					$qikbutton config -command "Create_Brkfile"
				}
				"Create Textfile" {
					$qikbutton config -command "Create_Textfile"
				}
				"Make Duplicate Textfiles" {
					$qikbutton config -command "DuplicateTextfile"
				}
				"Duplicate Several Textfile" {
					$qikbutton config -command "DuplicateSeveralTextfiles "
				}
				"Grab Sounds In Textfile To Workspace" {
					$qikbutton config -command "GrabFiles 1 0"
				}
				"Snds In Textfile Remove From Wkspace" {
					$qikbutton config -command "RemoveFromWkspace sndlist"
				}
				"Snds In Textfile To Top Of Workspace" {
					$qikbutton config -command "GrabHilite 2"
				}
				"Hilight Sounds Listed In Textfile" {
					$qikbutton config -command "GrabHilite 1"
				}
				"Grab Files To Workspace" {
					$qikbutton config -command "GrabFiles 0 0"
				}
				"Grab Specific Files To Workspace" {
					$qikbutton config -command "GrabFiles 0 1"
				}
				"Hilight Files Listed In Textfile" {
					$qikbutton config -command "GrabHilite 0"
				}
				"Put Sounds In Textfile On Chosen List" {
					$qikbutton config -command "GrabChoose 0"
				}
				"Add Sounds In Textfile To Chosen List" {
					$qikbutton config -command "GrabChoose 1"
				}
				"Add Snds In Txtfil To Chosen (incl Duplicates)" {
					$qikbutton config -command "GrabChoose 2"
				}
				"Next Soundlisting Sound To Chosen List" {
					$qikbutton config -command "GrabChoose 3"
				}
				"Next Soundlisting Snd To Chosen & Play"  {
					$qikbutton config -command "GrabChoose 4"
				}
				"Soundlisting Start Again"  {
					$qikbutton config -command "GrabChoose 5"
				}
				"Soundlisting Restart From Selected File"  {
					$qikbutton config -command "GrabChoose 6"
				}
				"Which Sounds In  Mix Don't Exist ?" {
					$qikbutton config -command "Assess_MixSrcs"
				}
				"Show End Times Of Files In Mix" {
					$qikbutton config -command "Mix_Endtimes"
				}
				"Sounds In Selected Mix To Wkspace" {
					$qikbutton config -command "Get_MixSrcs"
				}
				"Hilight Sounds In Mix Which Are On Wkspace" {
					$qikbutton config -command "Hilite_MixSrcs"
				}
				"Play Selected File" {
					$qikbutton config -command "PlayOutput 1"
				}
				"Play One Channel Of Sound" {
					$qikbutton config -command "PlayChan"
				}
				"Play Merged Channels" {
					$qikbutton config -command "PlayMerge"
				}
				"Permanent Play-display Of File" {
					$qikbutton config -command "PlaySndfileNew 0"
				}
				"Read/Edit Selected Textfile" {
					$qikbutton config -command "Read_Textfile"
				}
				"Display/Edit Selected Brkpnt File" {
					$qikbutton config -command "Read_Brkfile"
				}
				"Permanent Play-Display With Spectrum" {
					$qikbutton config -command "PlaySndfileNew 1"
				}
				"Overlay Sndfile(s) In Mixfile At Zero" {
					$qikbutton config -command "SndToMix 0"
				}
				"Insert Sndfile(s) At Mixfile Start" {
					$qikbutton config -command "SndToMix 1"
				}
				"Add Sndfile(s) (In Sequence) At Mixfile End" {
					$qikbutton config -command "SndToMix 2"
				}
				"Add Sndfile(s) (Overlayed) At Mixfile End" {
					$qikbutton config -command "SndToMix 3"
				}
				"Replace One Sndfile With Other In Mixfile" {
					$qikbutton config -command "SndToMix 4"
				}
				"Add Sndfile(s) To Mixfile At Specified Time" {
					$qikbutton config -command "SndToMix 7"
				}
				"Replace All Sndfiles In Mixfile" {
					$qikbutton config -command "SndToMix 8"
				}
				"Is Soundfile In Any Known Mixfile?" {
					$qikbutton config -command "SndInMix"
				}
				"Is Sound In Any Sndlist On Wkspace ?" {
					$qikbutton config -command "FindSndInSndlist"
				}
				"View Sound Or Brkpoint File" {
					$qikbutton config -command "ViewOutput"
				}
				default {
					Inf "No command in 'AGAIN' panel"
				}
			}
		} elseif {$qboftpye == 1} {
			set str [$ww.1.a.endd.l.new.few.menu entrycget 2 -label]
			switch -- $str {
				"Show Background Lists With File" {
					$qikbutton config -command "ShowBlistsOfFile $wl"
				}
				"Channel Count(s)" {
					$qikbutton config -command "Show_Props workspace chans"
				}
				"Duration(s)" {
					$qikbutton config -command "Show_Props workspace dur"
				}
				"Find File In Logs" {
					$qikbutton config -command "SearchLogsForFile $wl"
				}
				"Find File In B-Lists" {
					$qikbutton config -command "FileFind_inBLists 0"
				}
				"Find File In Mixfiles" {
					$qikbutton config -command "FindWkspaceFileInMixes"
				}
				"Move Files to Foot of List" {
					$qikbutton config -command "FootOfWkspace"
				}
				"Files To Next Selected Position" {
					$qikbutton config -command "SomewhereOnWkspace"
				}
				"Generically Rename" {
					$qikbutton config -command "GenericRenameWkspaceFiles"
				}
				"Generically Substitute Names" {
					$qikbutton config -command "GenericSubstituteWkspaceFiles"
				}
				"Swap Two Filenames" {
					$qikbutton config -command "SwapFileNames"
				}
				"Swap Selected Names With Chosenfiles" {
					$qikbutton config -command "SwapChFileNames"
				}
				"Transfer Prefix" {
					$qikbutton config -command "TransferName 0"
				}
				"Transfer Suffix" {
					$qikbutton config -command "TransferName 1"
				}
				"Base Name On Chosen File" {
					$qikbutton config -command "BaseChosName"
				}
				"Renumber" {
					$qikbutton config -command "GenericSubstituteWkspaceNumbers"
				}
				"Add Numbers" {
					$qikbutton config -command "AddWkspaceNumbers"
				}
				"Overwrite Chosen File(s)" {
					$qikbutton config -command "OverwriteRename"
				}
				"Grab Filename: Basic Name Only" {
					$qikbutton config -command "GrabRename 0"
				}
				"Grab Filename: Basic Name & Extension" {
					$qikbutton config -command "GrabRename 1"
				}
				"Grab Filename With Path & Extension" {
					$qikbutton config -command "GrabRename 2"
				}
				"Change Extension -> User Defined" {
					$qikbutton config -command "RenameExt 0"
				}
				"Change Extension -> Standard Text" {
					$qikbutton config -command "RenameExt 1"
				}
				"Change Unknown Extension -> Standard Text" {
					$qikbutton config -command "RenameExt 2"
				}
				"List All Files In Textfile" {
					$qikbutton config -command "WkToFile all 1"
				}
				"List Directory Of File" {
					$qikbutton config -command "ListDirOfFile"
				}
				"Load Similar Named Files From Dir" {
					$qikbutton config -command "LoadSimil"
				}
				"List Snds ,with Durs, in Textfile" {
					$qikbutton config -command "WkToFile sndur 1"
				}
				"List Mixfiles In Textfile" {
					$qikbutton config -command "WkToFile mix 1"
				}
				"List Multichan Mixfiles In Textfile" {
					$qikbutton config -command "WkToFile multimix 1" -text $str
				}
				"List Sndfiles In Textfile" {
					$qikbutton config -command "WkToFile snd 1" -text $str
				}
				"Add Sndfiles To List In Textfile" {
					$qikbutton config -command "WkToFile add 1" -text $str
				}
				"Add Sndfiles To Textfile & Remove" {
					$qikbutton config -command "WkToFile adddel 1" -text $str
				}
				"List Sndsystem Files In Textfile" {
					$qikbutton config -command "WkToFile sys 1" -text $str
				}
				"List Textfiles In Textfile" {
					$qikbutton config -command "WkToFile txt 1" -text $str
				}
				"Move Files In Directory To Top" {
					$qikbutton config -command "MoveDirMembersToTop" -text $str
				}
				"Move To New Directory" {
					$qikbutton config -command "MoveDirectory 0" -text $str
				}
				"Move To New Directory & Remove" {
					$qikbutton config -command "MoveDirectory 1" -text $str
				}
				"Maximum Sample(s)" {
					$qikbutton config -command "NewGetMaxsamplesOnWkspace" -text $str
				}
				"Simple Rename" {
					$qikbutton config -command "RenameWkspaceFiles"
				}
				"Show Pitch Mark" {
					$qikbutton config -command "DisplayPmark $wl"
				}
				"Play & Rename" {
					$qikbutton config -command "PlayAndRename"
				}
				"Show Properties" {
					$qikbutton config -command "Show_Props workspace 0"
				}
				"Recalculate Max Sample(s)" {
					$qikbutton config -command "GetMaxsamps 0 1"
				}
				"Update Data" {
					$qikbutton config -command "RefreshFiles"
				}
				"Remove End Character(s) From Name" {
					$qikbutton config -command "RemoveEndChars 0"
				}
				"Remove Start Character(s) From Name" {
					$qikbutton config -command "RemoveEndChars 1"
				}
				"Remove Character(s) After" {
					$qikbutton config -command "RemoveCharsAfter 0"
				}
				"Remove End Character(s) Before" {
					$qikbutton config -command "RemoveCharsAfter 1"
				}
				"Replace Spaces" {
					$qikbutton config -command "ReplaceTheChar space"
				}
				"Replace Dots" {
					$qikbutton config -command "ReplaceTheChar dot"
				}
				"Add Prefix" {
					$qikbutton config -command "Prefix 0"
				}
				"Add Suffix" {
					$qikbutton config -command "Prefix 1"
				}
				"Add Numeric Prefix In Creation Order" {
					$qikbutton config -command "Prefix 2"
				}
				"Add Numeric Suffix In Creation Order" {
					$qikbutton config -command "Prefix 3"
				}
				"Clear Backed-up File(s)" {
					$qikbutton config -command "RemoveFromWkspace wk"
				}
				"Clear File(s) In Same Directory" {
					$qikbutton config -command "RemoveFromWkspace dir"
				}
				"Reverse Order Of Files" {
					$qikbutton config -command "ReverseSelListing"
				}
				"Put Selected Files On Chosen List" {
					$qikbutton config -command "ChoseSel 0"
				}
				"Add Selected Files To Chosen List" {
					$qikbutton config -command "ChoseSel 1"
				}
				"Selectd Files To Chosen (with Duplicates)" {
					$qikbutton config -command "ChoseSel 2"
				}
				"Show Sources of non-sound file(s)" {
					$qikbutton config -command "ShowSrcs"
				}
				"Move Files to Top of List" {
					$qikbutton config -command "TopOfWkspace 0"
				}
				"Sort & Move Files to Top of List" {
					$qikbutton config -command "TopOfWkspace 1"
				}
				"Sort On Number At End of Name" {
					$qikbutton config -command "TopOfWkspace 2"
				}
				"Sort On Number At Start Of Name" {
					$qikbutton config -command "TopOfWkspace 3"
				}
				"Reverse Sort On Number At End Of Name" {
					$qikbutton config -command "TopOfWkspace -2"
				}
				"Reverse Sort On Number At Start Of Name" {
					$qikbutton config -command "TopOfWkspace -3"
				}
				"Move Sounds To Top Of List" {
					$qikbutton config -command "TopOfWkspace 4"
				}
				"Window Size" {
					$qikbutton config -command "Show_Props workspace winlen"
				}
				"Move Top File To After Marked Position" {
					$qikbutton config -command "FromTopOfWkspace"
				}
				"Add Selected File To A Sortlist" {
					$qikbutton config -command "AddToSortlist"
				}
				"Reorder Files As Per Sortlist" {
					$qikbutton config -command "ReorderAsSortlist"
				}
				default {
					Inf "No command in 'AGAIN' panel"
				}
			}
		} elseif {$qboftpye == 3} {
			set str [$ww.1.a.endd.l.new.all.menu entrycget 2 -label]
			switch -- $str {
				"Alphabetic Sort" {
					$qikbutton config -command "SortListing $wl 0"
				}
				"Reverse Alphabetic Sort" {
					$qikbutton config -command "SortListing $wl 1"
				}
				"Reverse Spelling Sort" {
					$qikbutton config -command "SortListing $wl 2"
				}
				"Alphabetic Sort (Snds Only)" {
					$qikbutton config -command "SortListing $wl 3"
				}
				"Reverse Alphabetic Sort (Snds)" {
					$qikbutton config -command "SortListing $wl 4"
				}
				"Reverse Spelling Sort (Snds)" {
					$qikbutton config -command "SortListing $wl 5"
				}
				"Files Starting With String, To Top" {
					$qikbutton config -command "StrSortWl 0"
				}
				"Files Containing String, To Top" {
					$qikbutton config -command "StrSortWl 1"
				}
				"Files Ending With String, To Top" {
					$qikbutton config -command "StrSortWl 2"
				}
				"Chosen Files To Top" {
					$qikbutton config -command "SortWl c"
				}
				"Soundsystem Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl t"
				}
				"Sound Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl s"
				}
				"Analysis Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl a"
				}
				"Pitch And Transpos Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl p"
				}
				"Formant Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl f"
				}
				"Envelope Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl e"
				}
				"Text Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl T"
				}
				"Breakpoint Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl b"
				}
				"Mix Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl m"
				}
				"Multichan Mix Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl q"
				}
				"Sound-Listing Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl k"
				}
				"Properties Files To Top & Sort" {
					$qikbutton config -command "SortListingType $wl P"
				}
				"Sort Snds, Largest Files First" {
					$qikbutton config -command "SortWl bs"
				}
				"Sort Snds, Smallest  Files First" {
					$qikbutton config -command "SortWl ss"
				}
				"Backed-Up Files To Top" {
					$qikbutton config -command "SortListingNew $wl b"
				}
				"Not-Backed-Up Files To Top" {
					$qikbutton config -command "SortListingNew $wl n"
				}
				"Newest Files To Top" {
					$qikbutton config -command "SortWl r"
				}
				"Oldest Files To Top" {
					$qikbutton config -command "SortWl o"
				}
				"Newest Soundfiles To Top" {
					$qikbutton config -command "SortWl rs"
				}
				"Oldest Soundfiles To Top" {
					$qikbutton config -command "SortWl os"
				}
				"Sort As Chosen Files Order" {
					$qikbutton config -command "SortWl ch"
				}
				"Sort As Playlist Order" {
					$qikbutton config -command "SortWl ps"
				}
				"Soundsystem Files To Top" {
					$qikbutton config -command "MoveListingType $wl t"
				}
				"Sound Files To Top" {
					$qikbutton config -command "MoveListingType $wl s"
				}
				"Analysis Files To Top" {
					$qikbutton config -command "MoveListingType $wl a"
				}
				"Pitch And Transpos Files To Top" {
					$qikbutton config -command "MoveListingType $wl p"
				}
				"Formant Files To Top" {
					$qikbutton config -command "MoveListingType $wl f"
				}
				"Envelope Files To Top" {
					$qikbutton config -command "MoveListingType $wl e"
				}
				"Text Files To Top" {
					$qikbutton config -command "MoveListingType $wl T"
				}
				"Breakpoint Files To Top" {
					$qikbutton config -command "MoveListingType $wl b"
				}
				"Mix Files To Top" {
					$qikbutton config -command "MoveListingType $wl m"
				}
				"Multichan Mix Files To Top" {
					$qikbutton config -command "MoveListingType $wl q"
				}
				"Sound-Listing Files To Top" {
					$qikbutton config -command "MoveListingType $wl k"
				}
				"Update Data On All Workspace Files" {
					$qikbutton config -command "RefreshWorkspace"
				}
				"Highlight All Chosen Files" {
					$qikbutton config -command "ChosSelect"
				}
				"Highlight Files In Directory Of Selected File" {
					$qikbutton config -command "SelectType sel"
				}
				"Highlight All Unselected Files" {
					$qikbutton config -command "InvertSelect"
				}
				"Higlighted Files Not On Chosenlist" {
					$qikbutton config -command "InvertSelectChosen"
				}
				"Highlight All Non Backed-Up Files" {
					$qikbutton config -command "SelectType nonbak"
				}
				"Highlight All Backed-Up Files" {
					$qikbutton config -command "SelectType bak"
				}
				"Highlight Sound Files" {
					$qikbutton config -command "SelectType snd"
				}
				"Highlight Sound Files With Odd Srates" {
					$qikbutton config -command "SelectType srate"
				}
				"Highlight Sound Files With Pitchmarks" {
					$qikbutton config -command "HilitePmarks $wl"
				}
				"Highlight Soundfile Listings" {
					$qikbutton config -command "SelectType sndlist"
				}
				"Highlight Properties Files" {
					$qikbutton config -command "SelectType props"
				}
				"Highlight Analysis Files" {
					$qikbutton config -command "SelectType anal"
				}
				"Highlight Batch Files" {
					$qikbutton config -command "SelectType batch"
				}
				"Highlight Envelope Files (Binary)" {
					$qikbutton config -command "SelectType envel"
				}
				"Highlight Formant Files" {
					$qikbutton config -command "SelectType formant"
				}
				"Highlight Mix Files" {
					$qikbutton config -command "SelectType mix"
				}
				"Highlight Multichannel Mix Files" {
					$qikbutton config -command "SelectType multimix"
				}
				"Highlight Pitch Files (Binary)" {
					$qikbutton config -command "SelectType pitch"
				}
				"Highlight Transposition Files (Binary)" {
					$qikbutton config -command "SelectType transpos"
				}
				"Highlight Text Files" {
					$qikbutton config -command "SelectType text"
				}
				"Highlight Files With Segment In Name" {
					$qikbutton config -command "$wl selection clear 0 end"
				}
				"Highlight Files With Segment In Specific Seg Of Name" {
					$qikbutton config -command "$wl selection clear 0 end"
				}
				"Highlight Snds With Segment In Specific Seg Of Name" {
					$qikbutton config -command "$wl selection clear 0 end"
				}
				"Select By Position In Listing" {
					$qikbutton config -command "ListingPosition $wl"
				}
				"Deselect All Files" {
					$qikbutton config -command "$wl selection clear 0 end"
				}
				"Remember Selection" {
					$qikbutton config -command "WkspaceSelectionSave"
				}
				"Recall Selection" {
					$qikbutton config -command "WkspaceSelectionRecall"
				}
				"Clear All Backed-Up Files" {
					$qikbutton config -command "ClearWkspace 0"
				}
				"Clear All Backed-Up Files Except Chosen Files" {
					$qikbutton config -command "ClearWkspace 1"
				}
				"Make Textlist Of All Files" {
					$qikbutton config -command "WkToFile all 0"
				}
				"Make Textlist Of Soundfiles" {
					$qikbutton config -command "WkToFile snd 0"
				}
				"Make Textlist Of Soundfiles & Durations" {
					$qikbutton config -command "WkToFile sndur 0"
				}
				"Make Textlist Of Sound-System Files" {
					$qikbutton config -command "WkToFile sys 0"
				}
				"Make Textlist Of Text Files" {
					$qikbutton config -command "WkToFile txt 0"
				}
				"Display/Don't Display Pitch Marks" {
					$qikbutton config -command "SetShowPmarks"
				}
				"Hilite All Files With Pitchmarks" {
					$qikbutton config -command "HilitePmarks $wl"
				}
				"Create A Textfile" {
					$qikbutton config -command "Create_Textfile"
				}
				"Create A Brkpnt File" {
					$qikbutton config -command "Create_Brkfile"
				}
			}

		} elseif {$qboftpye == 4} {
			set done 0
			set str [$ww.1.b.buttons2.lis.menu entrycget 2 -label]
			switch -- $str {
				"Previous Directory" {
					$qikbutton config -command GetLastDir
					set done 1
				}
				"Previous Listing" {
					$qikbutton config -command GetPreviousDir
					set done 1
				}
				"Subdirectories Only" {
					$qikbutton config -command GetSubdirNames
					set done 1
				}
				"Other Subdirectories" {
					$qikbutton config -command GetThisLevelSubdirNames
					set done 1
				}
				"No Subdirectories" {
					$qikbutton config -command NoSubdirNames
					set done 1
				}
				"Search By Specified String" {
					$qikbutton config -command StrGetDl
					set done 1
				}
				"Don't Show Directory Path" {
					$qikbutton config -command HiddenDirname
					set done 1
				}
				"Number At End Of Name" {
					$qikbutton config -command "SortDir 1 0"
					set done 1
				}
				"Number At End Of Name: In Reverse" {
					$qikbutton config -command "SortDir 1 1"
					set done 1
				}
				"Number At Start Of Name" {
					$qikbutton config -command "SortDir 0 0"
					set done 1
				}
				"Number At Start Of Name: In Reverse" {
					$qikbutton config -command "SortDir 0 1"
					set done 1
				}
				"Date Of Production: Oldest To Top" {
					$qikbutton config -command "SortDirDate 0"
					set done 1
				}
				"Date Of Production: Newest To Top" {
					$qikbutton config -command "SortDirDate 1"
					set done 1
				}
				"Home Directory" {
					$qikbutton config -command LoadHomeDirectory
					set done 1
				}
				".aif Files Only" {
					$qikbutton config -command "GetDirExt aif"
					set done 1
				}
				".aiff Files Only" {
					$qikbutton config -command "GetDirExt aiff"
					set done 1
				}
				"ANALYSIS FILES ONLY" {
;# 2023
					$qikbutton config -command "GetDirExt [string range $evv(ANALFILE_EXT) 1 end]"
					set done 1
				}
				".bat Files Only" {
					$qikbutton config -command "GetDirExt bat"
					set done 1
				}
				".evl Files Only" {
					$qikbutton config -command "GetDirExt evl"
					set done 1
				}
				".for Files Only" {
					$qikbutton config -command "GetDirExt for"
					set done 1
				}
				".frq Files Only" {
					$qikbutton config -command "GetDirExt frq"
					set done 1
				}
				".trn Files Only" {
					$qikbutton config -command "GetDirExt trn"
					set done 1
				}
				".txt Files Only" {
					$qikbutton config -command "GetDirExt txt"
					set done 1
				}
				".wav Files Only" {
					$qikbutton config -command "GetDirExt wav"
					set done 1
				}
				default {
					if {[info exists nessinit]} {
						set nessstr $evv(NESS_EXT)
						append nessstr " Files Only"
						if [string match $str $nessstr] {
							$qikbutton config -command "GetDirExt [string range $evv(NESS_EXT) 1 end]"
							set done 1
						}
					}
				}
			}
			if {!$done} {
				if {[info exists new_user_text_extensions]} {
					foreach item $new_user_text_extensions {
						if {[string first [string tolower $item] [string tolower $str]] == 0} {
							$qikbutton config -command "GetDirExt [string range $item 1 end]"
						}
					}
				} elseif {[info exists user_text_extensions]} {
					foreach item $user_text_extensions {
						if {[string first [string tolower $item] [string tolower $str]] == 0} {
							$qikbutton config -command "GetDirExt [string range $item 1 end]"
							break
						}
					}
				}
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc LoadQikbutton {} {
	global qikbutton wl evv nessinit
	set fnam [file join $evv(URES_DIR) qikbuton$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	while {[gets $zit str] >= 0} {
		set str [string trim $str]
		if {[string length $str] <= 0} {
			continue
		}
		switch -- $str {
			"Add Further Sounds To Listing" {
				$qikbutton config -command "AddToFile"
			}
			"Change Dir Of Files Listed In Textfile" {
				$qikbutton config -command "ChangeDirInFile"
			}
			"Play All Files Listed In Sndlist" {
				$qikbutton config -command "PlayAllChosen 1"
			}
			"Compare Selected Textfiles" {
				$qikbutton config -command "CompareTextfiles"
			}
			"Create Brkpnt File" {
				$qikbutton config -command "Create_Brkfile"
			}
			"Create Textfile" {
				$qikbutton config -command "Create_Textfile"
			}
			"Make Duplicate Textfiles" {
				$qikbutton config -command "DuplicateTextfile"
			}
			"Duplicate Several Textfile" {
				$qikbutton config -command "DuplicateSeveralTextfiles "
			}
			"Grab Sounds In Textfile To Workspace" {
				$qikbutton config -command "GrabFiles 1 0"
			}
			"Snds In Textfile Remove From Wkspace" {
				$qikbutton config -command "RemoveFromWkspace sndlist"
			}
			"Snds In Textfile To Top Of Workspace" {
				$qikbutton config -command "GrabHilite 2"
			}
			"Hilight Sounds Listed In Textfile" {
				$qikbutton config -command "GrabHilite 1"
			}
			"Grab Files To Workspace" {
				$qikbutton config -command "GrabFiles 0 0"
			}
			"Grab Specific Files To Workspace" {
				$qikbutton config -command "GrabFiles 0 1"
			}
			"Hilight Files Listed In Textfile" {
				$qikbutton config -command "GrabHilite 0"
			}
			"Put Sounds In Textfile On Chosen List" {
				$qikbutton config -command "GrabChoose 0"
			}
			"Add Sounds In Textfile To Chosen List" {
				$qikbutton config -command "GrabChoose 1"
			}
			"Add Snds In Txtfil To Chosen (incl Duplicates)" {
				$qikbutton config -command "GrabChoose 2"
			}
			"Next Soundlisting Sound To Chosen List" {
				$qikbutton config -command "GrabChoose 3"
			}
			"Next Soundlisting Snd To Chosen & Play"  {
				$qikbutton config -command "GrabChoose 4"
			}
			"Soundlisting Start Again"  {
				$qikbutton config -command "GrabChoose 5"
			}
			"Soundlisting Restart From Selected File"  {
				$qikbutton config -command "GrabChoose 6"
			}
			"Which Sounds In  Mix Don't Exist ?" {
				$qikbutton config -command "Assess_MixSrcs"
			}
			"Show End Times Of Files In Mix" {
				$qikbutton config -command "Mix_Endtimes"
			}
			"Sounds In Selected Mix To Wkspace" {
				$qikbutton config -command "Get_MixSrcs"
			}
			"Hilight Sounds In Mix Which Are On Wkspace" {
				$qikbutton config -command "Hilite_MixSrcs"
			}
			"Play Selected File" {
				$qikbutton config -command "PlayOutput 1"
			}
			"Play Merged Channels" {
				$qikbutton config -command "PlayMerge"
			}
			"Play One Channel Of Sound" {
				$qikbutton config -command "PlayChan"
			}
			"Permanent Play-display Of File" {
				$qikbutton config -command "PlaySndfileNew 0"
			}
			"Read/Edit Selected Textfile" {
				$qikbutton config -command "Read_Textfile"
			}
			"Display/Edit Selected Brkpnt File" {
				$qikbutton config -command "Read_Brkfile"
			}
			"Permanent Play-Display With Spectrum" {
				$qikbutton config -command "PlaySndfileNew 1"
			}
			"Overlay Sndfile(s) In Mixfile At Zero" {
				$qikbutton config -command "SndToMix 0"
			}
			"Insert Sndfile(s) At Mixfile Start" {
				$qikbutton config -command "SndToMix 1"
			}
			"Add Sndfile(s) (In Sequence) At Mixfile End" {
				$qikbutton config -command "SndToMix 2"
			}
			"Add Sndfile(s) (Overlayed) At Mixfile End" {
				$qikbutton config -command "SndToMix 3"
			}
			"Replace One Sndfile With Other In Mixfile" {
				$qikbutton config -command "SndToMix 4"
			}
			"Add Sndfile(s) To Mixfile At Specified Time" {
				$qikbutton config -command "SndToMix 7"
			}
			"Replace All Sndfiles In Mixfile" {
				$qikbutton config -command "SndToMix 8"
			}
			"Is Soundfile In Any Known Mixfile?"  {
				$qikbutton config -command "SndInMix"
			}
			"Is Sound In Any Sndlist On Wkspace ?" {
				$qikbutton config -command "FindSndInSndlist"
			}
			"View Sound Or Textfile" {
				$qikbutton config -command "ViewOutput"
			}
			"Show Background Lists With File" {
				$qikbutton config -command "ShowBlistsOfFile $wl"
			}
			"Channel Count(s)" {
				$qikbutton config -command "Show_Props workspace chans"
			}
			"Duration(s)" {
				$qikbutton config -command "Show_Props workspace dur"
			}
			"Find File In Logs" {
				$qikbutton config -command "SearchLogsForFile $wl"
			}
			"Find File In B-Lists" {
				$qikbutton config -command "FileFind_inBLists 0"
			}
			"Find File In Mixfiles" {
				$qikbutton config -command "FindWkspaceFileInMixes"
			}
			"Move Files to Foot of List" {
				$qikbutton config -command "FootOfWkspace"
			}
			"Files To Next Selected Position" {
				$qikbutton config -command "SomewhereOnWkspace"
			}
			"Generically Rename" {
				$qikbutton config -command "GenericRenameWkspaceFiles"
			}
			"Generically Substitute Names" {
				$qikbutton config -command "GenericSubstituteWkspaceFiles"
			}
			"Swap Two Filenames" {
				$qikbutton config -command "SwapFileNames"
			}
			"Swap Selected Names With Chosenfiles" {
				$qikbutton config -command "SwapChFileNames"
			}
			"Transfer Prefix" {
				$qikbutton config -command "TransferName 0"
			}
			"Transfer Suffix" {
				$qikbutton config -command "TransferName 1"
			}
			"Sndfile Name -> Txtfile" {
				$qikbutton config -command "TransferName 2"
			}
			"Txtfile Name -> Sndfile" {
				$qikbutton config -command "TransferName 3"
			}
			"Base Name On Chosen File" {
				$qikbutton config -command "BaseChosName"
			}
			"Renumber" {
				$qikbutton config -command "GenericSubstituteWkspaceNumbers"
			}
			"Add Numbers" {
				$qikbutton config -command "AddWkspaceNumbers"
			}
			"Overwrite Chosen File(s)" {
				$qikbutton config -command "OverwriteRename"
			}
			"Grab Filename: Basic Name Only" {
				$qikbutton config -command "GrabRename 0"
			}
			"Grab Filename: Basic Name & Extension" {
				$qikbutton config -command "GrabRename 1"
			}
			"Grab Filename With Path & Extension" {
				$qikbutton config -command "GrabRename 2"
			}
			"Change Extension -> User Defined" {
				$qikbutton config -command "RenameExt 0"
			}
			"Change Extension -> Standard Text" {
				$qikbutton config -command "RenameExt 1"
			}
			"Change Unknown Extension -> Standard Text" {
				$qikbutton config -command "RenameExt 2"
			}
			"List All Files In Textfile" {
				$qikbutton config -command "WkToFile all 1"
			}
			"List Directory Of File" {
				$qikbutton config -command "ListDirOfFile"
			}
			"Load Similar Named Files From Dir" {
				$qikbutton config -command "LoadSimil"
			}
			"List Snds ,with Durs, in Textfile" {
				$qikbutton config -command "WkToFile sndur 1"
			}
			"List Mixfiles In Textfile" {
				$qikbutton config -command "WkToFile mix 1"
			}
			"List Multichan Mixfiles In Textfile" {
				$qikbutton config -command "WkToFile multimix 1" -text $str
			}
			"List Sndfiles In Textfile" {
				$qikbutton config -command "WkToFile snd 1" -text $str
			}
			"Add Sndfiles To List In Textfile" {
				$qikbutton config -command "WkToFile add 1" -text $str
			}
			"Add Sndfiles To Textfile & Remove" {
				$qikbutton config -command "WkToFile adddel 1" -text $str
			}
			"List Sndsystem Files In Textfile" {
				$qikbutton config -command "WkToFile sys 1" -text $str
			}
			"List Textfiles In Textfile" {
				$qikbutton config -command "WkToFile txt 1" -text $str
			}
			"Move Files In Directory To Top" {
				$qikbutton config -command "MoveDirMembersToTop" -text $str
			}
			"Move To New Directory" {
				$qikbutton config -command "MoveDirectory 0" -text $str
			}
			"Move To New Directory & Remove" {
				$qikbutton config -command "MoveDirectory 1" -text $str
			}
			"Maximum Sample(s)" {
				$qikbutton config -command "NewGetMaxsamplesOnWkspace" -text $str
			}
			"Simple Rename" {
				$qikbutton config -command "RenameWkspaceFiles"
			}
			"Show Pitch Mark" {
				$qikbutton config -command "DisplayPmark $wl"
			}
			"Play & Rename" {
				$qikbutton config -command "PlayAndRename"
			}
			"Show Properties" {
				$qikbutton config -command "Show_Props workspace 0"
			}
			"Recalculate Max Sample(s)" {
				$qikbutton config -command "GetMaxsamps 0 1"
			}
			"Update Data" {
				$qikbutton config -command "RefreshFiles"
			}
			"Remove End Character(s) From Name" {
				$qikbutton config -command "RemoveEndChars 0"
			}
			"Remove Start Character(s) From Name" {
				$qikbutton config -command "RemoveEndChars 1"
			}
			"Remove Character(s) After" {
				$qikbutton config -command "RemoveCharsAfter 0"
			}
			"Remove End Character(s) Before" {
				$qikbutton config -command "RemoveCharsAfter 1"
			}
			"Replace Spaces" {
				$qikbutton config -command "ReplaceTheChar space"
			}
			"Replace Dots" {
				$qikbutton config -command "ReplaceTheChar dot"
			}
			"Add Prefix" {
				$qikbutton config -command "Prefix 0"
			}
			"Add Suffix" {
				$qikbutton config -command "Prefix 1"
			}
			"Add Numeric Prefix In Creation Order" {
				$qikbutton config -command "Prefix 2"
			}
			"Add Numeric Suffix In Creation Order" {
				$qikbutton config -command "Prefix 3"
			}
			"Clear Backed-up File(s)" {
				$qikbutton config -command "RemoveFromWkspace wk"
			}
			"Clear File(s) In Same Directory" {
				$qikbutton config -command "RemoveFromWkspace dir"
			}
			"Reverse Order Of Files" {
				$qikbutton config -command "ReverseSelListing"
			}
			"Put Selected Files On Chosen List" {
				$qikbutton config -command "ChoseSel 0"
			}
			"Add Selected Files To Chosen List" {
				$qikbutton config -command "ChoseSel 1"
			}
			"Selectd Files To Chosen (with Duplicates)" {
				$qikbutton config -command "ChoseSel 2"
			}
			"Show Sources of non-sound file(s)" {
				$qikbutton config -command "ShowSrcs"
			}
			"Move Files to Top of List" {
				$qikbutton config -command "TopOfWkspace 0"
			}
			"Sort & Move Files to Top of List" {
				$qikbutton config -command "TopOfWkspace 1"
			}
			"Sort On Number At End of Name" {
				$qikbutton config -command "TopOfWkspace 2"
			}
			"Sort On Number At Start Of Name" {
				$qikbutton config -command "TopOfWkspace 3"
			}
			"Reverse Sort On Number At End Of Name" {
				$qikbutton config -command "TopOfWkspace -2"
			}
			"Reverse Sort On Number At Start Of Name" {
				$qikbutton config -command "TopOfWkspace -3"
			}
			"Move Sounds To Top Of List" {
				$qikbutton config -command "TopOfWkspace 4"
			}
			"Window Size" {
				$qikbutton config -command "Show_Props workspace winlen"
			}
			"Move Top File To After Marked Position" {
				$qikbutton config -command "FromTopOfWkspace"
			}
			"Add Selected File To A Sortlist" {
				$qikbutton config -command "AddToSortlist"
			}
			"Reorder Files As Per Sortlist" {
				$qikbutton config -command "ReorderAsSortlist"
			}
			"Alphabetic Sort" {
				$qikbutton config -command "SortListing $wl 0"
			}
			"Reverse Alphabetic Sort" {
				$qikbutton config -command "SortListing $wl 1"
			}
			"Reverse Spelling Sort" {
				$qikbutton config -command "SortListing $wl 2"
			}
			"Alphabetic Sort (Snds Only)" {
				$qikbutton config -command "SortListing $wl 3"
			}
			"Reverse Alphabetic Sort (Snds)" {
				$qikbutton config -command "SortListing $wl 4"
			}
			"Reverse Spelling Sort (Snds)" {
				$qikbutton config -command "SortListing $wl 5"
			}
			"Files Starting With String, To Top" {
				$qikbutton config -command "StrSortWl 0"
			}
			"Files Containing String, To Top" {
				$qikbutton config -command "StrSortWl 1"
			}
			"Files Ending With String, To Top" {
				$qikbutton config -command "StrSortWl 2"
			}
			"Chosen Files To Top" {
				$qikbutton config -command "SortWl c"
			}
			"Soundsystem Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl t"
			}
			"Sound Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl s"
			}
			"Analysis Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl a"
			}
			"Pitch And Transpos Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl p"
			}
			"Formant Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl f"
			}
			"Envelope Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl e"
			}
			"Text Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl T"
			}
			"Breakpoint Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl b"
			}
			"Mix Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl m"
			}
			"Multichan Mix Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl q"
			}
			"Sound-listing Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl k"
			}
			"Properties Files To Top & Sort" {
				$qikbutton config -command "SortListingType $wl P"
			}
			"Sort Snds, Largest Files First" {
				$qikbutton config -command "SortWl bs"
			}
			"Sort Snds, Smallest  Files First" {
				$qikbutton config -command "SortWl ss"
			}
			"Backed-Up Files To Top" {
				$qikbutton config -command "SortListingNew $wl b"
			}
			"Not-Backed-Up Files To Top" {
				$qikbutton config -command "SortListingNew $wl n"
			}
			"Newest Files To Top" {
				$qikbutton config -command "SortWl r"
			}
			"Oldest Files To Top" {
				$qikbutton config -command "SortWl o"
			}
			"Newest Soundfiles To Top" {
				$qikbutton config -command "SortWl rs"
			}
			"Oldest Soundfiles To Top" {
				$qikbutton config -command "SortWl os"
			}
			"Sort As Chosen Files Order" {
				$qikbutton config -command "SortWl ch"
			}
			"Sort As Playlist Order" {
				$qikbutton config -command "SortWl ps"
			}
			"Soundsystem Files To Top" {
				$qikbutton config -command "MoveListingType $wl t"
			}
			"Sound Files To Top" {
				$qikbutton config -command "MoveListingType $wl s"
			}
			"Analysis Files To Top" {
				$qikbutton config -command "MoveListingType $wl a"
			}
			"Pitch And Transpos Files To Top" {
				$qikbutton config -command "MoveListingType $wl p"
			}
			"Formant Files To Top" {
				$qikbutton config -command "MoveListingType $wl f"
			}
			"Envelope Files To Top" {
				$qikbutton config -command "MoveListingType $wl e"
			}
			"Text Files To Top" {
				$qikbutton config -command "MoveListingType $wl T"
			}
			"Breakpoint Files To Top" {
				$qikbutton config -command "MoveListingType $wl b"
			}
			"Mix Files To Top" {
				$qikbutton config -command "MoveListingType $wl m"
			}
			"Multichan Mix Files To Top" {
				$qikbutton config -command "MoveListingType $wl q"
			}
			"Sound-Listing Files To Top" {
				$qikbutton config -command "MoveListingType $wl k"
			}
			"Update Data On All Workspace Files" {
				$qikbutton config -command "RefreshWorkspace"
			}
			"Highlight All Chosen Files" {
				$qikbutton config -command "ChosSelect"
			}
			"Highlight Files In Directory Of Selected File" {
				$qikbutton config -command "SelectType sel"
			}
			"Highlight All Unselected Files" {
				$qikbutton config -command "InvertSelect"
			}
			"Higlighted Files Not On Chosenlist" {
				$qikbutton config -command "InvertSelectChosen"
			}
			"Highlight All Non Backed-Up Files" {
				$qikbutton config -command "SelectType nonbak"
			}
			"Highlight All Backed-Up Files" {
				$qikbutton config -command "SelectType bak"
			}
			"Highlight Sound Files" {
				$qikbutton config -command "SelectType snd"
			}
			"Highlight Sound Files With Odd Srates" {
				$qikbutton config -command "SelectType srate"
			}
			"Highlight Sound Files With Pitchmarks" {
				$qikbutton config -command "HilitePmarks $wl"
			}
			"Highlight Soundfile Listings" {
				$qikbutton config -command "SelectType sndlist"
			}
			"Highlight Properties Files" {
				$qikbutton config -command "SelectType props"
			}
			"Highlight Analysis Files" {
				$qikbutton config -command "SelectType anal"
			}
			"Highlight Batch Files" {
				$qikbutton config -command "SelectType batch"
			}
			"Highlight Envelope Files (Binary)" {
				$qikbutton config -command "SelectType envel"
			}
			"Highlight Formant Files" {
				$qikbutton config -command "SelectType formant"
			}
			"Highlight Mix Files" {
				$qikbutton config -command "SelectType mix"
			}
			"Highlight Multichannel Mix Files" {
				$qikbutton config -command "SelectType multimix"
			}
			"Highlight Pitch Files (binary)" {
				$qikbutton config -command "SelectType pitch"
			}
			"Highlight Transposition Files (Binary)" {
				$qikbutton config -command "SelectType transpos"
			}
			"Highlight Text Files" {
				$qikbutton config -command "SelectType text"
			}
			"Highlight Files With Segment In Name" {
				$qikbutton config -command "$wl selection clear 0 end"
			}
			"Highlight Files With Segment In Specific Seg Of Name" {
				$qikbutton config -command "$wl selection clear 0 end"
			}
			"Highlight Snds With Segment In Specific Seg Of Name" {
				$qikbutton config -command "$wl selection clear 0 end"
			}
			"Select By Position In Listing" {
				$qikbutton config -command "ListingPosition $wl"
			}
			"Deselect All Files" {
				$qikbutton config -command "$wl selection clear 0 end"
			}
			"Remember Selection" {
				$qikbutton config -command "WkspaceSelectionSave"
			}
			"Recall Selection" {
				$qikbutton config -command "WkspaceSelectionRecall"
			}
			"Clear All Backed-Up Files" {
				$qikbutton config -command "ClearWkspace 0"
			}
			"Clear All Backed-Up Files Except Chosen Files" {
				$qikbutton config -command "ClearWkspace 1"
			}
			"Make Textlist Of All Files" {
				$qikbutton config -command "WkToFile all 0"
			}
			"Make Textlist Of Soundfiles" {
				$qikbutton config -command "WkToFile snd 0"
			}
			"Make Textlist Of Soundfiles & Durations" {
				$qikbutton config -command "WkToFile sndur 0"
			}
			"Make Textlist Of Sound-System Files" {
				$qikbutton config -command "WkToFile sys 0"
			}
			"Make Textlist Of Text Files" {
				$qikbutton config -command "WkToFile txt 0"
			}
			"Display/Don't Display Pitch Marks" {
				$qikbutton config -command "SetShowPmarks"
			}
			"Hilite All Files With Pitchmarks" {
				$qikbutton config -command "HilitePmarks $wl"
			}
			"Create A Textfile" {
				$qikbutton config -command "Create_Textfile"
			}
			"Create A Brkpnt File" {
				$qikbutton config -command "Create_Brkfile"
			}
			"Previous Directory" {
				$qikbutton config -command GetLastDir
			}
			"Previous Listing" {
				$qikbutton config -command GetPreviousDir
			}
			"Subdirectories Only" {
				$qikbutton config -command GetSubdirNames
			}
			"No Subdirectories" {
				$qikbutton config -command NoSubdirNames
			}
			"Other Subdirectories" {
				$qikbutton config -command GetThisLevelSubdirNames
			}
			"Search By Specified String" {
				$qikbutton config -command StrGetDl
			}
			"Don't Show Directory Path" {
				$qikbutton config -command HiddenDirname
			}
			"Number At End Of Name" {
				$qikbutton config -command "SortDir 1 0"
			}
			"Number At End Of Name: In Reverse" {
				$qikbutton config -command "SortDir 1 1"
			}
			"Number At Start Of Name" {
				$qikbutton config -command "SortDir 0 0"
			}
			"Number At Start Of Name: In Reverse" {
				$qikbutton config -command "SortDir 0 1"
			}
			"Date Of Production: Oldest To Top" {
				$qikbutton config -command "SortDirDate 0"
			}
			"Date Of Production: Newest To Top" {
				$qikbutton config -command "SortDirDate 1"
			}
			"Don't Show Directory Path" {
				$qikbutton config -command HiddenDirname
			}
			"Home Directory" {
				$qikbutton config -command LoadHomeDirectory
			}
			".aif Files Only" {
				$qikbutton config -command "GetDirExt aif"
			}
			".aiff Files Only" {
				$qikbutton config -command "GetDirExt aiff"
			}
        "ANALYSIS FILES ONLY" {
;# 2023
				$qikbutton config -command "GetDirExt [string range $evv(ANALFILE_EXT) 1 end]"
			}
			".bat Files Only" {
				$qikbutton config -command "GetDirExt bat"
			}
			".evl Files Only" {
				$qikbutton config -command "GetDirExt evl"
			}
			".for Files Only" {
				$qikbutton config -command "GetDirExt for"
			}
			".frq Files Only" {
				$qikbutton config -command "GetDirExt frq"
			}
			".trn Files Only" {
				$qikbutton config -command "GetDirExt trn"
			}
			".txt Files Only" {
				$qikbutton config -command "GetDirExt txt"
			}
			".wav Files Only" {
				$qikbutton config -command "GetDirExt wav"
			}
			default {
				if {[info exists nessinit]} {
					set nessstr $evv(NESS_EXT)
					append nessstr " Files Only"
					if [string match $str $nessstr] {
						$qikbutton config -command "GetDirExt [string range $evv(NESS_EXT) 1 end]"
					}
				}
			}
		}
		break
	}
	close $zit
}

proc SaveQikButton {} {
	global qikbutton evv nessinit
	set cmd [$qikbutton cget -command]
	set gotstr 0
	switch -- $cmd {
		"AddToFile" {
			set str "Add Further Sounds To Listing"
		}
		"ChangeDirInFile" {
			set str "Change Dir Of Files Listed In Textfile"
		}
		"PlayAllChosen 1" {
			set str "Play All Files Listed In Sndlist"
		}
		"CompareTextfiles" {
			set str "Compare Selected Textfiles"
		}
		"Create_Brkfile" {
			set str "Create Brkpnt File"
		}
		"Create_Textfile" {
			set str "Create Textfile"
		}
		"DuplicateTextfile" {
			set str "Make Duplicate Textfiles"
		}
		"DuplicateSeveralTextfiles " {
			set str "Duplicate Several Textfile"
		}
		"GrabFiles 1 0" {
			set str "Grab Sounds In Textfile To Workspace"
		}
		"GrabHilite 2" {
			set str "Snds In Textfile To Top Of Workspace"
		}
		"RemoveFromWkspace sndlist" {
			set str "Snds In Textfile Remove From Wkspace"
		}
		"GrabHilite 1" {
			set str "Hilight Sounds Listed In Textfile"
		}
		"GrabFiles 0 0" {
			set str "Grab Files To Workspace"
		}
		"GrabFiles 0 1" {
			set str "Grab Specific Files To Workspace"
		}
		"GrabHilite 0" {
			set str "Hilight Files Listed In Textfile"
		}
		"GrabChoose 0" {
			set str "Put Sounds In Textfile On Chosen List"
		}
		"GrabChoose 1" {
			set str "Add Sounds In Textfile To Chosen List"
		}
		"GrabChoose 2" {
			set str "Add Snds In Txtfil To Chosen (incl Duplicates)"
		}
		"GrabChoose 3" {
			set str "Next Soundlisting Sound To Chosen List"
		}
		"GrabChoose 4" {
			set str "Next Soundlisting Snd To Chosen & Play"
		}
		"GrabChoose 5" {
			set str "Soundlisting Start Again"
		}
		"GrabChoose 6" {
			set str "Soundlisting Restart From Selected File"
		}
		"Assess_MixSrcs" {
			set str "Which Sounds In  Mix Don't Exist ?"
		}
		"Mix_Endtimes" {
			set str "Show End Times Of Files In Mix"
		}
		"Get_MixSrcs" {
			set str "Sounds In Selected Mix To Wkspace"
		}
		"Hilite_MixSrcs" {
			set str "Hilight Sounds In Mix Which Are On Wkspace"
		}
		"PlayOutput 1" {
			set str "Play Selected File"
		}
		"PlayChan" {
			set str "Play One Channel Of Sound"
		}
		"PlayMerge" {
			set str "Play Merged Channels"
		}
		"PlaySndfileNew 0" {
			set str "Permanent Play-display Of File"
		}
		"Read_Textfile" {
			set str "Read/Edit Selected Textfile"
		}
		"Read_Brkfile" {
			set str "Display/Edit Selected Brkpnt File"
		}
		"PlaySndfileNew 1" {
			set str "Permanent Play-Display With Spectrum"
		}
		"SndToMix 0" {
			set str "Overlay Sndfile(s) In Mixfile At Zero"
		}
		"SndToMix 1" {
			set str "Insert Sndfile(s) At Mixfile Start"
		}
		"SndToMix 2" {
			set str "Add Sndfile(s) (In Sequence) At Mixfile End"
		}
		"SndToMix 3" {
			set str "Add Sndfile(s) (Overlayed) At Mixfile End"
		}
		"SndToMix 4" {
			set str "Replace One Sndfile With Other In Mixfile"
		}
		"SndToMix 7" {
			set str "Add Sndfile(s) To Mixfile At Specified Time"
		}
		"SndToMix 8" {
			set str "Replace All Sndfiles In Mixfile"
		}
		"SndInMix" {
			set str "Is Soundfile In Any Known Mixfile?"
		}
		"FindSndInSndlist" {
			set str "Is Sound In Any Sndlist On Wkspace ?"
		}
		"PlayWindow" {
			set str "View Soundfile In Edit Window"
		}
		"DoView" {
			set str "View Sound Or Anal File In Edit Window"
		}
		"ViewOutput" {
			set str "View Sound Or Textfile"
		}
		"Show_Props workspace chans" {
			set str "Channel Count(s)"
		}
		"Show_Props workspace dur" {
			set str "Duration(s)"
		}
		"FileFind_inBLists 0" {
			set str "Find File In B-Lists"
		}
		"FindWkspaceFileInMixes" {
			set str "Find File In Mixfiles"
		}
		"FootOfWkspace" {
			set str "Move Files to Foot of List"
		}
		"SomewhereOnWkspace" {
			set str "Files To Next Selected Position"
		}
		"GenericRenameWkspaceFiles" {
			set str "Generically Rename"
		}
		"GenericSubstituteWkspaceFiles" {
			set str "Generically Substitute Names"
		}
		"SwapFileNames" {
			set str "Swap Two Filenames"
		}
		"SwapChFileNames" {
			set str "Swap Selected Names With Chosenfiles"
		}
		"TransferName 0" {
			set str "Transfer Prefix"
		}
		"TransferName 1" {
			set str "Transfer Suffix"
		}
		"TransferName 2" {
			set str "Sndfile Name -> Txtfile"
		}
		"TransferName 3" {
			set str "Txtfile Name -> Sndfile"
		}
		"BaseChosName" {
			set str "Base Name On Chosen File"
		}
		"GenericSubstituteWkspaceNumbers" {
			set str "Renumber"
		}
		"AddWkspaceNumbers" {
			set str "Add Numbers"
		}
		"OverwriteRename" {
			set str "Overwrite Chosen File(s)"
		}
		"GrabRename 0" {
			set str "Grab Filename: Basic Name Only"
		}
		"GrabRename 1" {
			set str "Grab Filename: Basic Name & Extension"
		}
		"GrabRename 2" {
			set str "Grab Filename With Path & Extension"
		}
		"RenameExt 0" {
			set str "Change Extension -> User Defined"
		}
		"RenameExt 1" {
			set str "Change Extension -> Standard Text"
		}
		"RenameExt 2" {
			set str "Change Unknown Extension -> Standard Text"
		}
		"WkToFile all 1" {
			set str "List All Files In Textfile"
		}
		"ListDirOfFile" {
			set str "List Directory Of File"
		}
		"LoadSimil" {
			set str "Load Similar Named Files From Dir"
		}
		"WkToFile sndur 1" {
			set str "List Snds ,with Durs, in Textfile"
		}
		"WkToFile mix 1" {
			set str "List Mixfiles In Textfile"
		}
		"WkToFile multimix 1" -text $str {
			set str "List Multichan Mixfiles In Textfile"
		}
		"WkToFile snd 1" -text $str {
			set str "List Sndfiles In Textfile"
		}
		"WkToFile add 1" -text $str {
			set str "Add Sndfiles To List In Textfile"
		}
		"WkToFile adddel 1" -text $str {
			set str "Add Sndfiles To Textfile & Remove"
		}
		"WkToFile sys 1" -text $str {
			set str "List Sndsystem Files In Textfile"
		}
		"WkToFile txt 1" -text $str {
			set str "List Textfiles In Textfile"
		}
		"MoveDirMembersToTop" -text $str {
			set str "Move Files In Directory To Top"
		}
		"MoveDirectory 0" -text $str {
			set str "Move To New Directory"
		}
		"MoveDirectory 1" -text $str {
			set str "Move To New Directory & Remove"
		}
		"NewGetMaxsamplesOnWkspace" -text $str {
			set str "Maximum Sample(s)"
		}
		"RenameWkspaceFiles" {
			set str "Simple Rename"
		}
		"PlayAndRename" {
			set str "Play & Rename"
		}
		"Show_Props workspace 0" {
			set str "Show Properties"
		}
		"GetMaxsamps 0 1" {
			set str "Recalculate Max Sample(s)"
		}
		"RefreshFiles" {
			set str "Update Data"
		}
		"RemoveEndChars 0" {
			set str "Remove End Character(s) From Name"
		}
		"RemoveEndChars 1" {
			set str "Remove Start Character(s) From Name"
		}
		"RemoveCharsAfter 0" {
			set str "Remove Character(s) After"
		}
		"RemoveCharsAfter 1" {
			set str "Remove Character(s) Before"
		}
		"ReplaceTheChar space" {
			set str "Replace Spaces"
		}
		"ReplaceTheChar dot" {
			set str "Replace Dots"
		}
		"Prefix 0" {
			set str "Add Prefix"
		}
		"Prefix 1" {
			set str "Add Suffix"
		}
		"Prefix 2" {
			set str "Add Numeric Prefix In Creation Order"
		}
		"Prefix 3" {
			set str "Add Numeric Suffix In Creation Order"
		}
		"RemoveFromWkspace wk" {
			set str "Clear Backed-up File(s)"
		}
		"RemoveFromWkspace dir" {
			set str "Clear File(s) In Same Directory"
		}
		"ReverseSelListing" {
			set str "Reverse Order Of Files"
		}
		"ChoseSel 0" {
			set str "Put Selected Files On Chosen List"
		}
		"ChoseSel 1" {
			set str "Add Selected Files To Chosen List"
		}
		"ChoseSel 2" {
			set str "Selectd Files To Chosen (with Duplicates)"
		}
		"ShowSrcs" {
			set str "Show Sources of non-sound file(s)"
		}
		"TopOfWkspace 0" {
			set str "Move Files to Top of List"
		}
		"TopOfWkspace 1" {
			set str "Sort & Move Files to Top of List"
		}
		"TopOfWkspace 2" {
			set str "Sort On Number At End of Name"
		}
		"TopOfWkspace 3" {
			set str "Sort On Number At Start Of Name"
		}
		"TopOfWkspace -2" {
			set str "Reverse Sort On Number At End Of Name"
		}
		"TopOfWkspace -3" {
			set str "Reverse Sort On Number At Start Of Name"
		}
		"TopOfWkspace 4" {
			set str "Move Sounds To Top Of List"
		}
		"Show_Props workspace winlen" {
			set str "Window Size"
		}
		"FromTopOfWkspace" {
			set str "Move Top File To After Marked Position"
		}
		"AddToSortlist" {
			set str "Add Selected File To A Sortlist"
		}
		"ReorderAsSortlist" {
			set str "Reorder Files As Per Sortlist"
		}
		"SortListing $wl 0" {
			set str "Alphabetic Sort"
		}
		"SortListing $wl 1" {
			set str "Reverse Alphabetic Sort"
		}
		"SortListing $wl 2" {
			set str "Reverse Spelling Sort"
		}
		"SortListing $wl 3" {
			set str "Alphabetic Sort (Snds Only)"
		}
		"SortListing $wl 4" {
			set str "Reverse Alphabetic Sort (Snds)"
		}
		"SortListing $wl 5" {
			set str "Reverse Spelling Sort (Snds)"
		}
		"StrSortWl 0" {
			set str "Files Starting With String, To Top"
		}
		"StrSortWl 1" {
			set str "Files Containing String, To Top"
		}
		"StrSortWl 2" {
			set str "Files Ending With String, To Top"
		}
		"SortWl c" {
			set str "Chosen Files To Top"
		}
		"SortListingType $wl t" {
			set str "Soundsystem Files To Top & Sort"
		}
		"SortListingType $wl s" {
			set str "Sound Files To Top & Sort"
		}
		"SortListingType $wl a" {
			set str "Analysis Files To Top & Sort"
		}
		"SortListingType $wl p" {
			set str "Pitch And Transpos Files To Top & Sort"
		}
		"SortListingType $wl f" {
			set str "Formant Files To Top & Sort"
		}
		"SortListingType $wl e" {
			set str "Envelope Files To Top & Sort"
		}
		"SortListingType $wl T" {
			set str "Text Files To Top & Sort"
		}
		"SortListingType $wl b" {
			set str "Breakpoint Files To Top & Sort"
		}
		"SortListingType $wl m" {
			set str "Mix Files To Top & Sort"
		}
		"SortListingType $wl q" {
			set str "Multichan Mix Files To Top & Sort"
		}
		"SortListingType $wl k" {
			set str "Sound-Listing Files To Top & Sort"
		}
		"SortListingType $wl P" {
			set str "Properties Files To Top & Sort"
		}
		"SortWl bs" {
			set str "Sort Snds, Largest Files First"
		}
		"SortWl ss" {
			set str "Sort Snds, Smallest  Files First"
		}
		"SortListingNew $wl b" {
			set str "Backed-Up Files To Top"
		}
		"SortListingNew $wl n" {
			set str "Not-Backed-Up Files To Top"
		}
		"SortWl r" {
			set str "Newest Files To Top"
		}
		"SortWl o" {
			set str "Oldest Files To Top"
		}
		"SortWl rs" {
			set str "Newest Soundfiles To Top"
		}
		"SortWl os" {
			set str "Oldest Soundfiles To Top"
		}
		"SortWl ch" {
			set str "Sort As Chosen Files Order"
		}
		"SortWl ps" {
			set str "Sort As Playlist Order"
		}
		"MoveListingType $wl t" {
			set str "Soundsystem Files To Top"
		}
		"MoveListingType $wl s" {
			set str "Sound Files To Top"
		}
		"MoveListingType $wl a" {
			set str "Analysis Files To Top"
		}
		"MoveListingType $wl p" {
			set str "Pitch And Transpos Files To Top"
		}
		"MoveListingType $wl f" {
			set str "Formant Files To Top"
		}
		"MoveListingType $wl e" {
			set str "Envelope Files To Top"
		}
		"MoveListingType $wl T" {
			set str "Text Files To Top"
		}
		"MoveListingType $wl b" {
			set str "Breakpoint Files To Top"
		}
		"MoveListingType $wl m" {
			set str "Mix Files To Top"
		}
		"MoveListingType $wl q" {
			set str "Multichan Mix Files To Top"
		}
		"MoveListingType $wl k" {
			set str "Sound-Listing Files To Top"
		}
		"RefreshWorkspace" {
			set str "Update Data On All Workspace Files"
		}
		"ChosSelect" {
			set str "Highlight All Chosen Files"
		}
		"SelectType sel" {
			set str "Highlight Files In Directory Of Selected File"
		}
		"InvertSelect" {
			set str "Highlight All Unselected Files"
		}
		"InvertSelectChosen" {
			set str "Higlighted Files Not On Chosenlist"
		}
		"SelectType nonbak" {
			set str "Highlight All Non Backed-Up Files"
		}
		"SelectType bak" {
			set str "Highlight All Backed-Up Files"
		}
		"SelectType snd" {
			set str "Highlight Sound Files"
		}
		"SelectType srate" {
			set str "Highlight Sound Files With Odd Srates"
		}
		"HilitePmarks $wl" {
			set str "Highlight Sound Files With Pitchmarks"
		}
		"SelectType sndlist" {
			set str "Highlight Soundfile Listings"
		}
		"SelectType props" {
			set str "Highlight Properties Files"
		}
		"SelectType anal" {
			set str "Highlight Analysis Files"
		}
		"SelectType batch" {
			set str "Highlight Batch Files"
		}
		"SelectType envel" {
			set str "Highlight Envelope Files (Binary)"
		}
		"SelectType formant" {
			set str "Highlight Formant Files"
		}
		"SelectType mix" {
			set str "Highlight Mix Files"
		}
		"SelectType multimix" {
			set str "Highlight Multichannel Mix Files"
		}
		"SelectType pitch" {
			set str "Highlight Pitch Files (Binary)"
		}
		"SelectType transpos" {
			set str "Highlight Transposition Files (Binary)"
		}
		"SelectType text" {
			set str "Highlight Text Files"
		}
		"$wl selection clear 0 end" {
			set str "Highlight Files With Segment In Name"
		}
		"$wl selection clear 0 end" {
			set str "HIghlight Files With Segment In Specific Seg Of Name"
		}
		"$wl selection clear 0 end" {
			set str "Highlight Snds With Segment In Specific Seg Of Name"
		}
		"ListingPosition $wl" {
			set str "Select By Position In Listing"
		}
		"$wl selection clear 0 end" {
			set str "Deselect All Files"
		}
		"WkspaceSelectionSave" {
			set str "Remember Selection"
		}
		"WkspaceSelectionRecall" {
			set str "Recall Selection"
		}
		"ClearWkspace 0" {
			set str "Clear All Backed-Up Files"
		}
		"ClearWkspace 1" {
			set str "Clear All Backed-Up Files Except Chosen Files"
		}
		"WkToFile all 0" {
			set str "Make Textlist Of All Files"
		}
		"WkToFile snd 0" {
			set str "Make Textlist Of Soundfiles"
		}
		"WkToFile sndur 0" {
			set str "Make Textlist Of Soundfiles & Durations"
		}
		"WkToFile sys 0" {
			set str "Make Textlist Of Sound-System Files"
		}
		"WkToFile txt 0" {
			set str "Make Textlist Of Text Files"
		}
		"SetShowPmarks" {
			set str "Display/Don't Display Pitch Marks"
		}
		"HilitePmarks $wl" {
			set str "Hilite All Files With Pitchmarks"
		}
		"Create_Textfile" {
			set str "Create A Textfile"
		}
		"Create_Brkfile" {
			set str "Create A Brkpnt File"
		}
		"GetLastDir" {
			set str "Previous Directory"
		}
		"GetPreviousDir" {
			set str "Previous Listing"
		}
		"GetSubdirNames" {
			set str "Subdirectories Only"
		}
		"NoSubdirNames" { 
			set str "No Subdirectories"
		}
		"StrGetDl" { 
			set str "Search By Specified String"
		}
		"HiddenDirname" { 
			set str "Don't Show Directory Path"
		}
		"SortDir 1 0" {
			set str "Number At End Of Name"
		}
		"SortDir 1 1" {
			set str "Number At End Of Name: In Reverse"
		}
		"SortDir 0 0" {
			set str "Number At Start Of Name"
		}
		"SortDir 0 1" {
			set str "Number At Start Of Name: In Reverse"
		}
		"SortDirDate 0" {
			set str "Date Of Production: Oldest To Top"
		}
		"SortDirDate 1" {
			set str "Date Of Production: Newest To Top"
		}
		"LoadHomeDirectory" { 
			set str "Home Directory"
		}
		"GetDirExt aif" { 
			set str ".aif Files Only"
			set gotstr 1
		}
		"GetDirExt aiff" { 
			set str ".aiff Files Only"
			set gotstr 1
		}
;# 2023
		"GetDirExt [string range $evv(ANALFILE_EXT) 1 end]" { 
			set str "ANALYSIS FILES ONLY"
			set gotstr 1
		}
		"GetDirExt bat" { 
			set str ".bat Files Only"
			set gotstr 1
		}
		"GetDirExt evl" { 
			set str ".evl Files Only"
			set gotstr 1
		}
		"GetDirExt for" { 
			set str ".for Files Only"
			set gotstr 1
		}
		"GetDirExt frq" { 
			set str ".frq Files Only"
			set gotstr 1
		}
		"GetDirExt trn" { 
			set str ".trn Files Only"
			set gotstr 1
		}
		"GetDirExt txt" { 
			set str ".txt Files Only"
			set gotstr 1
		}
		"GetDirExt wav" { 
			set str ".wav Files Only"
			set gotstr 1
		}
		default {
			if {[string match DisplayPmark* $cmd]} {
				set str "Show Pitch Mark"
				set gotstr 1
			} elseif {[string match SearchLogsForFile* $cmd]} {
				set str "Find File In Logs"
				set gotstr 1
			} elseif {[string match ShowBlistsOfFile* $cmd]} {
				set str "Show Background Lists With File"
				set gotstr 1
			}
			if {[info exists nessinit]} {
				set nessstr [string range $evv(NESS_EXT) 1 end]
				if {[string match "GetDirExt $nessstr" $cmd]} {
					set str "$evv(NESS_EXT) Files Only"
					set gotstr 1
				}
			}
		}
	}
	if {([string first "GetDirExt" $cmd] == 0) && !$gotstr} {
		if {[info exists new_user_text_extensions]} {
			foreach item $new_user_text_extensions {
				set itemx [string range $item 1 end]
				if {[string match -nocase $itemx [string range $cmd 10 end]]} {
					set str $item
					append str " Files Only"
					break
				}
			}
		} elseif {[info exists user_text_extensions]} {
			foreach item $user_text_extensions {
				set itemx [string range $item 1 end]
				if {[string match -nocase $itemx [string range $cmd 10 end]]} {
					set str $item
					append str " Files Only"
					break
				}
			}
		}
	}
	if {![info exists str]} {
		return
	}
	set fnam [file join $evv(URES_DIR) qikbuton$evv(CDP_EXT)]
	if [catch {open $fnam "w"} zit] {
		return
	}
	puts $zit $str
	close $zit
}

proc GetNextToChosen {add} {
	global ch chlist chcnt topchpos chpos wl
	if {($add == 3) || ($add == 4) || ($add == 5)} {
		set ilist [$wl curselection]
		if {![info exists ilist] || ([llength $ilist] <= 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
			return
		}
		if {$add == 3} {
			ClearAndSaveChoice	
		} elseif {[info exists chlist]} {
			foreach i $ilist {
				set fnam [$wl get $i]
				if {[lsearch $chlist $fnam] >= 0} {
					Inf "'$fnam' Is Already Chosen.\nUse standard buttons for chosing duplicate files."
					return
				}
			}
		}
		UnsetThumbnail
		if {$add == 5} {
			foreach i $ilist {
				lappend nulist [$wl get $i]
			}
			if {[info exists chlist]} {
				set nulist [concat $nulist $chlist]
			}
			ClearAndSaveChoice	
			$ch delete 0 end
			foreach fnam $nulist {
				lappend chlist $fnam
				$ch insert end $fnam
				incr chcnt
			}
		} else {
			foreach i $ilist {
				set fnam [$wl get $i]
				lappend chlist $fnam
				$ch insert end $fnam
				incr chcnt
			}
		}
	} else {
		set fnam [$wl get 0]
		if {[string length $fnam] <= 0} {
			return
		}
		if {[info exists chlist] && ([llength $chlist] > 0)} {
			if {[llength $chlist] == 1} {
				if {[string match $fnam [lindex $chlist 0]]} {
					if {$add} {
						Inf "ALREADY CHOSEN.\nUse standard buttons for chosing duplicate files."
						return
					}
					return
				}
			} elseif {$add} {
				foreach fnamz $chlist {
					if {[string match $fnam $fnamz]} {
						Inf "ALREADY CHOSEN.\nUse standard buttons for chosing duplicate files."
						return
					}
				}
			}
			if {!$add} {
				ClearAndSaveChoice	
			}
		}
		if {$add == 2} {
			set topchpos 1
		}
		set chpos -1
		PutItOnChlist $fnam
		if {$add == 2} {
			set topchpos 0
		}
	}
}

proc AddWkspaceNumbers {} {
	global wl pr_snuma genericnumloa genericnumstepa chlist ch chcnt gennum_atenda gennum_samenamea evv
	global sl_real background_listing dupl_mix dupl_vbx dupl_txt nessinit

	if {!$sl_real} {
		Inf "Selected Files With Similar Names Ending In Numbers\nCan Have Their Numbering Altered"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		return
	}
	if [info exists nessinit] {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Generic Renaming Of Physical Modelling Files"
				return
			}
		}
	}
	set ren_blist 0

	set g .genericnuma
	if [Dlg_Create $g "NUMBER FILES" "set pr_snuma 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gn2 [frame $g.name2 -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_snuma 0" -highlightbackground [option get . background {}]
		label $gn.l1 -text "Number FROM  "
		entry $gn.e1 -width 4 -textvariable genericnumloa
		label $gn.l2 -text "with STEP  "
		entry $gn.e2 -width 4 -textvariable genericnumstepa
		button $gn.ok -text OK -width 6 -command "set pr_snuma 1" -highlightbackground [option get . background {}]
		pack $gn.ok $gn.l1 $gn.e1 $gn.l2 $gn.e2 -side left
		pack $gn.b -side right
		pack $g.name -side top
		radiobutton $gn2.a -variable gennum_atenda -text "Number at END of name" -value 1
		radiobutton $gn2.b -variable gennum_atenda -text "Number at START of name" -value 0
		pack $gn2.a $gn2.b -side left -padx 4
		pack $gn $gn2 -side top -pady 2
		wm resizable $g 1 1
		bind $g <Return> {set pr_snuma 1}
		bind $g <Escape> {set pr_snuma 0}
	}
	set genericnumloa 0
	set genericnumstepa 1
	set gennum_atenda 1
	set gennum_samenamea 1
	set finished 0
	set pr_snuma 0
	set save_mixmanage 0
	raise $g
	My_Grab 0 $g pr_snuma $g.name.e1
	while {!$finished} {
		tkwait variable pr_snuma
		if {!$pr_snuma} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			if {[string length $genericnumloa] <= 0} {
				Inf "No start number has been entered"
				continue
			}
			if {![regexp {^[0-9]+$} $genericnumloa]} {
				Inf "Invalid start number entered"
				continue
			}
			if {[string length $genericnumstepa] <= 0} {
				Inf "No step value entered"
				continue
			}
			if {![regexp {^[0-9]+$} $genericnumstepa]} {
				Inf "Invalid step value entered"
				continue
			}
			if {$genericnumstepa < 1} {
				Inf "Invalid step value entered (must be greater than zero)"
				continue
			}
			set cnt 0
			foreach i $ilist {										;# check for valid (set of) files
				lappend innames [$wl get $i]
				set fnam [file rootname [$wl get $i]]
				if {$cnt == 0} {
					set baseext [file extension [$wl get $i]]
				}
				if {![string match [file extension [$wl get $i]] $baseext]} {
					Inf "Files '$fnam' is not of the same type as the first file"
					My_Release_to_Dialog $g
					Dlg_Dismiss $g
					return
				}
				incr cnt
			}
			set j $genericnumloa
			foreach i $ilist {
				set fnam [$wl get $i]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				set ffnam [file tail $fnam]
				set basefnam [file rootname $ffnam]
				set len [string length $basefnam]
				if {$gennum_atenda} {
					set nuname [file join $fdir $basefnam]
					append nuname "_"
					append nuname $j $baseext
				} else {
					set nuname [file join $fdir $j]
					append nuname "_" $basefnam $baseext
				}
				if {[file exists $nuname] && ([lsearch -exact $innames $nuname] < 0)} {
					Inf "A File With The Name '$nuname' Already Exists"
					My_Release_to_Dialog $g
					Dlg_Dismiss $g
					return
				}
				incr j $genericnumstepa
			}
			set j $genericnumloa
			foreach i $ilist {
				set fnam [$wl get $i]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				if {$gennum_atenda} {
					set nuname [file rootname $fnam]
					append nuname "_" $j $baseext
				} else {
					set ffnam [file tail $fnam]
					set basefnam [file rootname $ffnam]
					set nuname [file join $fdir $j]
					append nuname "_" $basefnam $baseext
				}
				incr j $genericnumstepa
				set origfnam [$wl get $i]
				set haspmark [HasPmark $origfnam]
				set hasmmark [HasMmark $origfnam]
				if [catch {file rename $origfnam $nuname} zub] {
					Inf "Cannot rename file\n$origfnam\nTO\n$nuname"
					continue
				}
				DataManage rename $origfnam $nuname
				lappend couettelist $origfnam $nuname
				UpdateBakupLog $origfnam delete 0
				UpdateBakupLog $nuname create 1
				CheckMainmix $origfnam $nuname
				CheckMainmixSnd $origfnam $nuname
				$wl delete $i								
				$wl insert $i $nuname
				catch {unset rememd}
				UpdateChosenFileMemory $origfnam $nuname
				set oldname_pos_on_chosen [LstIndx $origfnam $ch]
				if {$oldname_pos_on_chosen >= 0} {
					RemoveFromChosenlist $origfnam
					set chlist [linsert $chlist $oldname_pos_on_chosen $nuname]
					incr chcnt
					$ch insert $oldname_pos_on_chosen $nuname
				}
				RenameProps	$origfnam $nuname 1				
				DummyHistory $origfnam "RENAMED_$nuname"
				if {[MixMRename $origfnam $nuname 0]} {
					set save_mixmanage 1
				}
				if {$haspmark} {
					MovePmark $origfnam $nuname
				}
				if {$hasmmark} {
					MoveMmark $origfnam $nuname
				}
				if [IsInBlists $origfnam] {
					if [RenameInBlists $origfnam $nuname] {
						set ren_blist 1
					}
				}
				RenameOnDirlist $origfnam $nuname
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			break
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}		
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
}

proc RemoveCharsAfter {before} {
	global sl_real wl pa background_listing wstk pr_aftchdel aftchdel chlist ch chcnt evv dupl_mix dupl_vbx dupl_txt nesstype nessorig

	catch {unset nessorig}
 	if {!$sl_real} {
		Inf "Selected Files Can Have N Characters Removed"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0
	set save_mixmanage 0
	set nessupdate 0

	set g .aftchdel
	if [Dlg_Create $g "REMOVE CHARACTERS AFTER" "set pr_aftchdel 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gi [frame $g.indx -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_aftchdel 0" -highlightbackground [option get . background {}]
		button $gn.ok -text OK -width 6 -command "set pr_aftchdel 1" -highlightbackground [option get . background {}]
		pack $gn.ok -side left
		pack $gn.b -side right
		label $gi.l -text "String to find in name" -width 30
		entry $gi.e -width 20 -textvariable aftchdel
		pack $gi.l $gi.e -side left
		pack $g.name -side top -fill x -expand true
		pack $g.indx -side top
		wm resizable $g 1 1
		bind $g <Return> {set pr_aftchdel 1}
		bind $g <Escape> {set pr_aftchdel 0}
	}
	if {$before} {
		wm title $g "REMOVE CHARACTERS BEFORE"
	} else {
		wm title $g "REMOVE CHARACTERS AFTER"
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "NO ITEM(S) SELECTED"
		destroy $g
		return
	}

	set aftchdel ""
	set rename_cnt 0 
	set finished 0
	set pr_aftchdel 0
	raise $g
	My_Grab 0 $g pr_aftchdel $g.indx.e
	while {!$finished} {
		tkwait variable pr_aftchdel
		if {!$pr_aftchdel} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			if {![regexp {^[a-zA-Z0-9_\-\ ]+$} $aftchdel] } {
				"Invalid Characters In Search String"
				continue
			}
			set cutlen [string length $aftchdel]
			catch {unset nufnams}
			set OK 1
			foreach i $ilist {
				set fnam [$wl get $i]								;#	get each selected file
				set fext [file extension $fnam]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				set fnam [file rootname [file tail $fnam]]
				set flen [string length $fnam]
				set k [string first $aftchdel $fnam]
				if {$k < 0} {
					Inf "File '$fnam$fext' Does Not Contain The String '$aftchdel'"
					set OK 0
					break
				}
				if {$before} {
					if {$k == 0} {
						Inf "There Are No Characters Before '$aftchdel' In Filename '$fnam$fext'"
						set OK 0
						break
					}
					set nuname [string range $fnam $k end] 
				} else {
					incr k $cutlen
					if {$k >= $flen} {
						Inf "There Are No Characters After '$aftchdel' In Filename '$fnam$fext'"
						set OK 0
						break
					}
					incr k -1
					set nuname [string range $fnam 0 $k] 
				}
				if {![ValidCDPRootname $nuname]} {
					set OK 0
					break
				}
				set fnam $nuname$fext
				set fnam [file join $fdir $fnam]
				if {[file exists $fnam] && ![file isdirectory $fnam]} {
					Inf "A File With The Name '$fnam' Already Exists"
					set OK 0
					break
				}
				lappend nufnams $fnam
			}
			if {!$OK} {
				break
			}
			set nufnam [lindex $nufnams 0]
			foreach fnam [lrange $nufnams 1 end] {
				if {[string match $fnam $nufnam]} {
					Inf "The Name '$fnam' Will Be Duplicated By This Action"
					set OK 0
					break
				}
			}
			if {!$OK} {
				break
			}
			set rename_cnt 0
			foreach i $ilist nufnam $nufnams {
				set origfnam [$wl get $i]								;#	get each selected file
				set haspmark [HasPmark $origfnam]
				set hasmmark [HasMmark $origfnam]
				if [catch {file rename $origfnam $nufnam} zub] {
					Inf "Cannot Rename File '$origfnam' To '$nufnam'"
				} else {
					DataManage rename $origfnam $nufnam
					lappend couettelist $origfnam $nufnam
					UpdateBakupLog $origfnam delete 0
					UpdateBakupLog $nufnam create 1
					CheckMainmix $origfnam $nufnam
					CheckMainmixSnd $origfnam $nufnam
					$wl delete $i								
					$wl insert $i $nufnam
					UpdateChosenFileMemory $origfnam $nufnam
					set oldname_pos_on_chosen [LstIndx $origfnam $ch]
					if {$oldname_pos_on_chosen >= 0} {
						RemoveFromChosenlist $origfnam
						set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
						incr chcnt
						$ch insert $oldname_pos_on_chosen $nufnam
					}
					RenameProps	$origfnam $nufnam 1				
					DummyHistory $origfnam "RENAMED_$nufnam"
					if {[MixMRename $origfnam $nufnam 0]} {
						set save_mixmanage 1
					} elseif {[NessMRename $origfnam $nufnam 0]} {
						set nessupdate 1
					}
					if {$haspmark} {
						MovePmark $origfnam $nufnam
					}
					if {$hasmmark} {
						MoveMmark $origfnam $nufnam
					}
					if [IsInBlists $origfnam] {
						if [RenameInBlists $origfnam $nufnam] {
							set ren_blist 1
						}
					}
					if [IsOnScore $origfnam] {
						RenameInScore $origfnam $nufnam
					}
					RenameOnDirlist $origfnam $nufnam
					incr rename_cnt
				}
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			if {$rename_cnt} {
				catch {unset rememd}
				set finished 1
			} else {
				Inf "No Files Have Been Renamed"
			}
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$nessupdate} {
		NessMStore
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
	return 1
}

proc TellKeyboard1 {} {
	set msg "ASSIGNING A MOTIF (A PITCH SEQUENCE) TO A SOUND.\n"
	append msg "        (Put one sndfile on Chosen Files list)\n"
	append msg "\n"
	append msg "Output is sequence of (tempered) MIDI Pitches, but NO RHYTHM SPECIFIED.\n"
	append msg "A) Enter MIDI data from piano display (or from textfile).\n"
	append msg "B) Save data in textfile (row or column format) OR..\n"
	append msg "C) Save data as MOTIF MARKER, permanently associated with file (and any copies made).\n"
	append msg "    Stored motifs can be viewed, played (DISPLAY MOTIFS), deleted (DELETE MOTIFS).\n"
	append msg "    (Place a sound that has motif marker on Chosen Files List).\n"
	append msg "    (Notes of equal duration are played in sequence).\n"
	append msg "D) Can also store all the pitches as PITCHMARK (a Chord).\n"
	append msg "\n"
	append msg "    Stored pitchmarks can be viewed, played, edited etc.\n"
	append msg "    by choosing PITCHMARK options on Wkspace or Music Testbed.\n"
	append msg "\n"
	Inf $msg
}

proc TellKeyboard2 {} {
	set msg "WORKING WITH PITCH DATA EXTRACTED FROM SOUND.\n"
	append msg "\n"
	append msg "A) Timed (quantised) MIDI-pitch data may be derived from the Frequency plot of a sound,\n"
	append msg "    obtained using the pitch-extraction process.\n"
	append msg "    The frq data extracted can contain Signal zeros (no signal) but not Pitch zeros (no pitch).\n"
	append msg "\n"
	append msg "B) This frq data may be converted to quantised, vocal-range, midi-pitch data.\n"
	append msg "    (Put the frq data file on the Chosen Files list.\n"
	append msg "    and select \"EXTRACTED FREQ DATA -> VOCAL-RANGE MIDI\")\n"
	append msg "\n"
	append msg "C) The MIDI data may be heard, displayed, played in parallel with the original sound source\n"
	append msg "    and modified on screen in the \"TIMED MIDI DATA WORKSHOP\"\n"
	append msg "    (Put Source sound file, and midi data file on Chosen Files list).\n"
	append msg "\n"
	append msg "D) Any modified data from the WORKSHOP can be saved .....\n"
	append msg "    a) As another (timed) list of MIDI pitches, which can be used in a similar way.\n"
	append msg "    b) As Timed Frequency Data which can be used to synthesize the pitch line.\n"
	append msg "    c) As a (Harmonic Field) Pitchmark.\n"
	append msg "    d) In a text file, as an (untimed) list of MIDI pitches.\n"
	append msg "    e) As a Motif Marker (no rhythm).\n"
	append msg "\n"
	Inf $msg
}

proc FrqExtractionDataToNotatableMidi {} {
	global chlist pr_pconvertor pconvfnam pa wstk evv

	if {![info exists chlist] || ([llength $chlist] < 1)} {
		Inf "No Files On Chosen List"
		return
	}
	set gotit 0
	foreach fnam $chlist {
		if {![info exists pa($fnam,$evv(FTYP))]} {
			Inf "Cannot Find Properties Of File '$fnam'"
			return
		}
		if {[IsABrkfile $pa($fnam,$evv(FTYP))]} {
			set gotit 1
			break
		}
	}
	if {!$gotit} {
		Inf "There Is No Pitch-Data File On Chosen-Files List"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	set linecnt 1
	while {[gets $zit line] >= 0} {				;#	READ DATA
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set line [split $line]
		set cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {$cnt == 0}  {
				if {$linecnt == 1} {
					if {![Flteq $item 0.0]} {
						Inf "Time Values In File Do Not Start At Zero"
						close $zit
						return
					}
				} elseif {$item <= $lasttime} {
					Inf "Time Values In File Do Not Advance At Line $linecnt"
					close $zit
					return
				}
				set lasttime $item
			}
			lappend nulines $item
			incr cnt
		}
		incr linecnt
	}
	close $zit
	foreach {time val} $nulines {
		lappend ztimes $time
		lappend zvals $val
	}
	set ccnt 0
	foreach val $zvals {											;#	REMOVE PITCH ZEROS
		if {$val < 0} { 
			if {![info exists at_start]} {
				set at_start $ccnt
				if {$ccnt != 0} {
					set atstartval $lastval
				}
			}
		} else {
			if {[info exists at_start]} {
				if {$at_start == 0} {
					while {$at_start < $ccnt} {
						lappend nuvals $val
						incr at_start
					}
				} else {
					set midistart [HzToMidi $atstartval]
					set midiend   [HzToMidi $val]
					set steps [expr $ccnt - $at_start + 1]
					set midistep [expr $midiend - $midistart]
					set midistep [expr double($midistep) / double($steps)]
					set thismidi $midistart
					while {$at_start < $ccnt} {
						set thismidi [expr $thismidi + $midistep]
						lappend nuvals [MidiToHz $thismidi]
						incr at_start
					}
				}
				unset at_start
			}
			lappend nuvals $val
			set lastval $val
		}
		incr ccnt
	}
	if {[info exists at_start]} {
		while {$at_start < $ccnt} {
			lappend nuvals $lastval
			incr at_start
		}
	}
	catch {unset nulines}
	foreach time $ztimes val $nuvals {			;# CONVERT TO QUANTISED MIDI
		lappend nulines $time [expr int(round([HzToMidi $val]))]
	}
	catch {unset nuvals}
	set ccnt 0
	foreach {time val} $nulines {				;#	REMOVE CONSECUTIVE DUPLICATED VALS
		if {$ccnt == 0} {
			lappend nuvals $time $val
		} else {
			if {[Flteq $val $lastval]} {
				set sustained 1
			} else {
				if {[info exists sustained]} {
					lappend nuvals $lasttime $lastval
					unset sustained
				}
				lappend nuvals $time $val
			}
		}
		set lasttime $time
		set lastval $val
		incr ccnt
	}
	if {[info exists sustained]} {
		lappend nuvals $lasttime $lastval
	}			
	set nulines $nuvals
	catch {unset nuvals}
	set ccnt 0
	foreach {time val} $nulines {		;#	SMOOTH OUTPUT VALUES (REMOVE BRIEF PITCH DIGRESSIONS)
		if {$ccnt > 1} {
			set step   [expr $val - $lastval]
			set lastep [expr $lastval - $lalastval]
			if {(($step > 0) && ($lastep < 0)) \
			||  (($step < 0) && ($lastep > 0))} {
				if {[expr $time - $lasttime] < 0.05} {
					if {$step < 0} {
						set step [expr -$step]
					}
					if {$lastep < 0} {
						set lastep [expr -$lastep]
					}
					if {$step > $lastep} {
						set lastval $lalastval
					} else {
						set lastval $val
					}
				}
			}
		}
		if {$ccnt > 0} {
			set lalastval $lastval
			lappend nuvals $lasttime $lastval
		}
		set lastval $val
		set lasttime $time
		incr ccnt
	}
	lappend nuvals $lasttime $lastval

	set ccnt 0						;#	REMOVE CONSECUTIVE DUPLICATES (AGAIN)
	foreach {time val} $nuvals {
		if {$ccnt > 0} {
			if {[Flteq $val $lastval]} {
				set waiting 1
			} else {
				if {[info exists waiting]} {
					lappend out_vals $lasttime $lastval
					unset waiting
				}
				lappend out_vals $time $val
			}
		} else {
			lappend out_vals $time $val
		}
		set lastval $val
		set lasttime $time
		incr ccnt
	}
	if {[info exists waiting]} {
		lappend out_vals $lasttime $lastval
	}
	set ccnt 0						;#	REMOVE NONVOCAL RANGE
	catch {unset sustained}
	catch {unset nuvals}
	foreach {time val} $out_vals {
		if {($val < 36 ) || ($val > 84)} {
			if {![info exists sustained]} {
				set sustained 1
				if {$ccnt == 0} {
					set startsustain 0.0
				} else {
					set startsustain $lasttime
					set valsustain $lastval
				}
			}
		} else {
			if [info exists sustained] {
				if {$startsustain == 0.0} {
					lappend nuvals 0.0 $val
				} else {
					set timegap [expr $time - $startsustain]
					if {$timegap > 0.1} {
						set midtime [expr $startsustain + ($timegap/2.0)]
						lappend nuvals [expr $midtime - 0.025] $valsustain
						lappend nuvals [expr $midtime + 0.025] $val
					}
				}
				catch [unset sustained]
			}
			lappend nuvals $time $val
		}
		set lasttime $time
		set lastval $val
		incr ccnt
	}
	if [info exists sustained] {
		if {![info exists nuvals]} {
			Inf "There Are No Values Within The Vocal Range."
			return
		}
		lappend nuvals $lasttime $valsustain
	}
	set out_vals $nuvals
	unset nuvals
	set ccnt 0
	catch {unset sustain}
	foreach {time val} $out_vals {			;#	REMOVE CONSECUTIVE DUPLICATES
		if {$ccnt == 0} {
			lappend nuvals $time $val
		} else {
			if {[Flteq $val $lastval]} {
				set sustain 1
			} else {
				if {[info exists sustain]} {
					lappend nuvals $lasttime $lastval
					unset sustain
				}
				lappend nuvals $time $val
			}
		}
		set lasttime $time
		set lastval $val
		incr ccnt
	}
	if {[info exists sustain]} {
		lappend nuvals $lasttime $lastval
		unset sustain
	}
	set out_vals $nuvals

	set ccnt 0								;#  CHANGE TO IMPLIED-SUSTAIN FORMAT
	catch {unset nuvals}
	foreach {time val} $out_vals {
		if {$ccnt == 0} {
			lappend nuvals $time $val
		} elseif {![Flteq $val $lastval]} {
			lappend nuvals $time $val
		}
		set lastval $val
		incr ccnt
	}
	set out_vals $nuvals

	set callcentre [GetCentre [lindex $wstk end]]
	set f .pconvertor
	if [Dlg_Create $f "CONVERT PITCH TO NOTATABLES" "set pr_pconvertor 0" -borderwidth 2] {
		frame $f.0
		frame $f.1
		button $f.0.q -text "Close" -command "set pr_pconvertor 0" -highlightbackground [option get . background {}]
		button $f.0.c -text "Convert" -command "set pr_pconvertor 1" -highlightbackground [option get . background {}]
		pack $f.0.c -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		label $f.1.ll -text "Outfile Name  "
		entry $f.1.e -textvariable pconvfnam -width 26
		pack $f.1.ll $f.1.e  -side left
		pack $f.1 -side top -pady 2
		bind $f <Return> {set pr_pconvertor 1}
		bind $f <Escape> {set pr_pconvertor 0}
	}
	set finished 0
	set pr_pconvertor 0
	raise $f
	update idletasks
	set geo [CentreOnCallingWindow $f $callcentre]
	My_Grab 0 $f pr_pconvertor $f.1.e
	wm geometry $f $geo
	while {!$finished} {
		tkwait variable pr_pconvertor
		if {$pr_pconvertor} {
			if {[string length $pconvfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $pconvfnam]} {
				continue
			}
			set ofnam [string tolower $pconvfnam]
			append ofnam [GetTextfileExtension brk]
			if [catch {open $ofnam "w"} zit] {
				Inf "Cannot Open File '$ofnam'"
				continue
			}
			foreach {time val} $out_vals {
				set line $time
				lappend line $val
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
				Inf "File '$ofnam' Is Now On The Workspace"
			} else {
				Inf "Output Data Is In File '$ofnam'"
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Add pitch-suffix to filenames

proc PSuffix {} {
	global wl pr_psuffix chlist ch chcnt evv
	global background_listing pa scores_refresh sl_real dupl_mix dupl_vbx dupl_txt 
	global psuf psuffix psuford wstk wl psufincr psufincr_e psuffix_rep nesstype nessorig

	catch {unset nessorig}
	if {!$sl_real} {
		Inf "Selected Files On The Workspace\nCAn Be Given Pitch-Name Suffixes"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ilist [$wl curselection]
	if {([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {							
		Inf "No Item(s) Selected"
		return
	}
	set ren_blist 0
	set are_snds 0
	set g .psuffix
	set callcentre [GetCentre [lindex $wstk end]]
	if [Dlg_Create $g "ADD PITCH SUFFIX" "set pr_psuffix 0" -borderwidth $evv(BBDR)] {
		set gt [frame $g.top -borderwidth $evv(SBDR)]
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set go [frame $g.other -borderwidth $evv(SBDR)]

		button $gt.ok -text Rename -command "set pr_psuffix 1" -highlightbackground [option get . background {}]
		button $gt.quit -text Close -command "set pr_psuffix 0" -highlightbackground [option get . background {}]
		pack $gt.ok -side left
		pack $gt.quit -side right

		radiobutton $gn.c  -text C  -variable psuf -value 0  -command "set psuffix c"
		radiobutton $gn.dd -text Dd -variable psuf -value 1  -command "set psuffix dd"
		radiobutton $gn.d  -text D  -variable psuf -value 2  -command "set psuffix d"
		radiobutton $gn.eb -text Eb -variable psuf -value 3  -command "set psuffix eb"
		radiobutton $gn.e  -text E  -variable psuf -value 4  -command "set psuffix e"
		radiobutton $gn.f  -text F  -variable psuf -value 5  -command "set psuffix f"
		radiobutton $gn.gg -text Gg -variable psuf -value 6  -command "set psuffix gg"
		radiobutton $gn.g  -text G  -variable psuf -value 7  -command "set psuffix g"
		radiobutton $gn.ab -text Ab -variable psuf -value 8  -command "set psuffix ab"
		radiobutton $gn.a  -text A  -variable psuf -value 9  -command "set psuffix a"
		radiobutton $gn.bb -text Bb -variable psuf -value 10 -command "set psuffix bb"
		radiobutton $gn.b  -text B  -variable psuf -value 11 -command "set psuffix b"

		pack $gn.c $gn.dd $gn.d $gn.eb $gn.e $gn.f $gn.gg $gn.g $gn.ab $gn.a $gn.bb $gn.b -side left

		radiobutton $go.a -text "All The Same"   -variable psuford -value 0 -width 12
		radiobutton $go.c -text "Chromatic Up"   -variable psuford -value 1 -width 12
		label $go.ll -text "Octave Index (>=0) "
		entry $go.e -textvariable psufincr_e
		checkbutton $go.rep -variable psuffix_rep -text "Replace Any Existing Suffix"
		
		pack $go.a $go.c $go.ll $go.e $go.rep -side left -padx 2

		pack $g.top -side top -fill x -expand true
		pack $g.name $g.other -side top
		wm resizable $g 1 1
		bind $g <Return> {set pr_psuffix 1}
		bind $g <Escape> {set pr_psuffix 0}
	}
	set psuf -1
	set psuford -1
	set psufincr 0
	set psuffix_rep 0
	set psufinc_e ""
	set finished 0
	set pr_psuffix 0
	set save_mixmanage 0
	set nessupdate 0
	raise $g
	update idletasks
	set geo [CentreOnCallingWindow $g $callcentre]
	My_Grab 0 $g pr_psuffix
	wm geometry $g $geo
	while {!$finished} {
		tkwait variable pr_psuffix
		if {$pr_psuffix} {
			if {$psuf < 0} {
				Inf "No Pitch Selected"
				continue
			}
			if {$psuford < 0} {
				Inf "All Same, Or Chromatic ??"
				continue
			}
			if {[string length $psufincr_e] <= 0} {
				if {$psuford} {
					set psufincr 0
				} else {
					set psufincr ""
				}
			} elseif {![regexp {^[0-9]+$} $psufincr_e]} {
				Inf "Invalid Octave Index: Must Be >= 0"
				continue
			} elseif {$psufincr_e == 0} {
				set psufincr 0
			} else {
				set psufincr [StripLeadingZeros $psufincr_e]
			}
			set qsuffix $psuffix
			append qsuffix $psufincr
			catch {unset origfnams}
			catch {unset nufnams}
			set OK 1
			foreach i $ilist {
				set fnam [$wl get $i]
				lappend origfnams $fnam
				set ext [file extension $fnam]
				set fnam [file rootname $fnam]
				if {$psuffix_rep} {
					set k [string last "_" $fnam]
					if {$k >= 0} {
						incr k -1
						set fnam [string range $fnam 0 $k]
					}
				}
				append fnam "_" $qsuffix
				append fnam $ext
				if {[file exists $fnam]} {
					Inf "File '$fnam' Already Exists"
					set OK 0
					break
				}
				if {[info exists nufnams]} {
					set k [lsearch $nufnams $fnam]
					if {$k >= 0} {
						Inf "Name '$fnam' Would Be Duplicated"
						set OK 0
						break
					}
				}
				lappend nufnams $fnam
				if {$psuford} {
					set qsuffix [IncrPSuffix $qsuffix] 
				}
			}
			if {!$OK} {
				continue
			}
			foreach i $ilist origfnam $origfnams nufnam $nufnams {
				set is_snd 0
				if {$pa($origfnam,$evv(FTYP)) == $evv(SNDFILE)} {
					set is_snd 1
					set haspmark [HasPmark $origfnam]
					set hasmmark [HasMmark $origfnam]
				}
				if [catch {file rename $origfnam $nufnam} zit] {
					Inf "Cannot Rename File $origfnam"
					continue
				}
				UpdateBakupLog $origfnam delete 0
				UpdateBakupLog $nufnam create 1
				if {$is_snd} {
					DataManage rename $origfnam $nufnam
					CheckMainmixSnd $origfnam $nufnam
					set are_snds 1
					if {$haspmark} {
						MovePmark $origfnam $nufnam
					}
					if {$hasmmark} {
						MoveMmark $origfnam $nufnam
					}
					if [IsInBlists $origfnam] {
						if [RenameInBlists $origfnam $nufnam] {
							set ren_blist 1
						}
					}
					if [IsOnScore $origfnam] {
						RenameOnScore $origfnam $nufnam
					}
				} else {
					CheckMainmix $origfnam $nufnam
				}
				$wl delete $i								
				$wl insert $i $nufnam
				catch {unset rememd}

				UpdateChosenFileMemory $origfnam $nufnam
				set oldname_pos_on_chosen [LstIndx $origfnam $ch]
				if {$oldname_pos_on_chosen >= 0} {
					RemoveFromChosenlist $origfnam
					set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
					incr chcnt
					$ch insert $oldname_pos_on_chosen $nufnam
				}
				RenameProps	$origfnam $nufnam 1
				DummyHistory $origfnam "RENAMED_$nufnam"
				if {[MixMRename $origfnam $nufnam 0]} {
					set save_mixmanage 1
				} elseif {[NessMRename $origfnam $nufnam 0]} {
					set nessupdate 1
				}
				RenameOnDirlist $origfnam $nufnam
			}
			set finished 1
		} else {
			break
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
 	if {$nessupdate} {
		NessMStore
	}
	if {$are_snds} {
		set scores_refresh 1
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
}

proc IncrPSuffix {qsuffix} {
	global psuffix psufincr
	set k [string first $psufincr $qsuffix]
	if {$k >= 0} {
		incr k -1
		set zsuffix [string range $qsuffix 0 $k]
	} else {
		set zsuffix $qsuffix
	}
	switch -- $zsuffix {
		"c"  {set val 0} 
		"dd" {set val 1} 
		"d"  {set val 2} 
		"eb" {set val 3} 
		"e"  {set val 4} 
		"f"  {set val 5} 
		"gb" {set val 6} 
		"g"  {set val 7} 
		"ab" {set val 8} 
		"a"  {set val 9} 
		"bb" {set val 10} 
		"b"  {set val 11}
	}
	incr val
	switch -- $val {
		12 {set val "c"  } 
		1  {set val "dd" } 
		2  {set val "d"  } 
		3  {set val "eb" } 
		4  {set val "e"  } 
		5  {set val "f"  } 
		6  {set val "gb" } 
		7  {set val "g"  } 
		8  {set val "ab" } 
		9  {set val "a"  } 
		10 {set val "bb" } 
		11 {set val "b"  }
	}
	if {[string match $val $psuffix]} {
		if {$k >= 0} {
			incr psufincr
		}
	}
	append val $psufincr
	return $val
}

proc CopyWkspaceFilePmarkMmark {fnam nufnam} {
	global pitchmark mtfmark pa evv
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		return
	}
	if {[info exists pitchmark($fnam)]} {
		CopyPmark $fnam $nufnam
	}	
	if {[info exists mtfmark($fnam)]} {
		CopyMmark $fnam $nufnam
	}
}

proc DurSort {listing} {
	global wl ch chlist evv pa
	if {$listing == "wl"} {
		set ll $wl
		set ilist [$ll curselection]
		if {[llength $ilist] < 2} {
			Inf "Insufficient Files Selected"
			return
		}
		foreach i $ilist {
			set fnam [$ll get $i]
			if {![info exists pa($fnam,$evv(DUR))] || [Flteq $pa($fnam,$evv(DUR)) 0.0]} {
				continue
			}
			lappend nuilist $i
		}
		if {[llength $nuilist] < 2} {
			Inf "Insufficient Files Selected Have A Duration Value"
			return
		}
		set ilist $nuilist
		foreach i $ilist {
			lappend durs $pa([$ll get $i],$evv(DUR))
		}
	} else {
		set ll $ch
		if {![info exists chlist] || ([llength $chlist] < 2)} {
			Inf "Insufficient Files On Chosen List"
			return
		}
		set cnt 0
		foreach fnam $chlist {
			if {![info exists pa($fnam,$evv(DUR))] || [Flteq $pa($fnam,$evv(DUR)) 0.0]} {
				Inf "Not All Chosen List Have A Duration Value"
				return
			}
			lappend ilist $cnt
			lappend durs $pa($fnam,$evv(DUR))
			incr cnt
		}
	}
	set len [llength $durs]
	set len_less_one $len
	incr len_less_one -1
	set n 0
	while {$n < $len_less_one} {
		set thisdur [lindex $durs $n]
		set thisi	[lindex $ilist $n]
		set m $n
		incr m
		while {$m < $len} {
			set thatdur [lindex $durs $m]
			set thati	[lindex $ilist $m]
			if {$thatdur < $thisdur} {
				set durs [lreplace $durs $m $m $thisdur]
				set durs [lreplace $durs $n $n $thatdur]
				set ilist [lreplace $ilist $m $m $thisi]
				set ilist [lreplace $ilist $n $n $thati]
				set thisdur $thatdur
				set thisi   $thati
			}
			incr m
		}
		incr n
	}
	foreach i $ilist {
		lappend nufiles [$ll get $i]
	}
	set ilist [lsort -integer -decreasing $ilist]
	foreach i $ilist {
		$ll delete $i
	}
	foreach fnam [$ll get 0 end] {
		lappend nufiles $fnam
	}
	$ll delete 0 end
	foreach fnam $nufiles {
		$ll insert end $fnam
	}
	if {$listing == "ch"} {
		unset chlist
		foreach fnam [$ch get 0 end] {
			lappend chlist $fnam
		}
	}
}

proc ResetMasterGain {gain fnam} { 
	global prm pprg actvhi evv pa evv wstk
	switch -regexp -- $pprg \
		^$evv(MIX)$ - \
		^$evv(MIXMULTI)$ {
			set fixparam 2
		} \
		^$evv(ACC_STREAM)$ {
			set fixparam 1
		} \
		^$evv(SEQUENCER)$ - \
		^$evv(SEQUENCER2)$ {
			set fixparam 1
		} \
		default {
			return
		}

	if {[IsNumeric $prm($fixparam)]} {
		set maxest [expr int(round($pa($fnam,$evv(MAXSAMP)) * 100))]
		if {$prm($fixparam) == 1.0} {
			if {$gain < 0.99} {			;#	ATTENUATE OVERALL GAIN PARAM IF NESS
				if {$maxest > 98} {
					set msg "Mix Overload\n\nReduce Mix Level ??"
					set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
					if {$choice == "yes"} {
						set prm($fixparam) [expr $prm($fixparam) * $gain]
					}
				}
			} elseif {$maxest > 98} {	;#	GAIN CLOSE TO 1.0 INDICATES OUTPUT HAS OVERLOADAD
				set msg "Mix Overload\n\nReduce Mix Level To 0.1\n\nRecheck Max Level After Rerun\nAnd Run A 2nd Time ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "yes"} {
					set prm($fixparam) 0.1
				}
				return
			}
		} else {
			if {$maxest > 98} {			;#	GAIN CLOSE TO 1.0 INDICATES OUTPUT HAS PROBABLY OVERLOADAD
				set msg "Mix Overload\n\nReduce Mix Level To 0.1\n\nRecheck Max Level After Rerun\nAnd Run A 2nd Time ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "yes"} {
					set prm($fixparam) 0.1
				}
				return
			} 
			if {($gain <= 0.99) && ($maxest > 98)} {	
				set msg "Mix Overload\n\nReduce Mix Level ??"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					return
				}
			}
			if {(($gain <= 0.99) && ($maxest > 97)) || ($gain > 0.99)} {		;#	ADJUST OVERALL GAIN DOWN OR UP IF NESS
				set val [TwoSigFig [expr $gain * $prm($fixparam)]]
				if {$val > 1.0} {
					set val 1.0
				}
				if {$val > $prm($fixparam)} {
					if {$prm($fixparam) != 0.1} {
						set msg "Mix Gain Can Be Higher: Increase It ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							return
						}
					}
				}
				set prm($fixparam) $val
			}
		}
	}
}

proc FileStatus {} {
	global wl testzog5 pr_status wl evv
	set f .filestatus
	if [Dlg_Create $f "File Status" "set pr_status 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.1
		button $f.0.quit -text Close -command "set pr_status 0" -highlightbackground [option get . background {}]
		label $f.0.ll -text "Click on filename to view Status Report"
		pack $f.0.ll -side left
		pack $f.0.quit -side right -padx 2
		pack $f.0 -side top -fill x -expand true
		Scrolled_Listbox $f.1.ll -width 64 -height 24 -selectmode single
		pack $f.1.ll -side top -fill both -expand true
		pack $f.1 -side top -pady 4
		bind $f.1.ll.list <ButtonRelease-1> {ShowStatus .filestatus.1.ll.list}
		bind $f <Return> {set pr_status 0}
		bind $f <Escape> {set pr_status 0}
		bind $f <Key-space> {set pr_status 0}
	}
	set pr_status 0
	$f.1.ll.list delete 0 end
	foreach fnam [$wl get 0 end] {
		$f.1.ll.list insert end $fnam
	}
	raise $f
	update idletasks
	StandardPosition2 $f
	My_Grab 0 $f pr_status $f.1.ll.list
	tkwait variable pr_status
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	set testzog5 0
}

proc ShowStatus {ll} {
	set i [$ll curselection]
	if {$i < 0} {
		return
	}
	set fnam [$ll get $i]
	if [catch {file stat $fnam filestatus} in] {
		set msg "Cannot Determine Status Of File '$fnam'"
	} else {
		set msg "FILE: $fnam\n\n"
		foreach name [array names filestatus] {
			append msg "filestatus($name) = $filestatus($name)\n"
		}
	}
	Inf $msg
}

proc CheckNewReleases {} {
	global released gate_version filter_version modify_version specnu_version evv
	set gate_version 0
	set filter_version 0
	set modify_version 0
	set specnu_version 0
	if {[file exists [file join $evv(CDPROGRAM_DIR) modify$evv(EXEC)]]} {
		set modify_version [GetVersion modify]
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) filter$evv(EXEC)]]} {
		set filter_version [GetVersion filter]
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) newmix$evv(EXEC)]]} {
		set released(newmix) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) analjoin$evv(EXEC)]]} {
		set released(analjoin) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) ptobrk$evv(EXEC)]]} {
		set released(ptobrk) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) psow$evv(EXEC)]]} {
		set released(psow) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) oneform$evv(EXEC)]]} {
		set released(oneform) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) gate$evv(EXEC)]]} {
		set released(gate) 1
		set gate_version [GetVersion gate]
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specnu$evv(EXEC)]]} {
		set released(specnu) 1
		set specnu_version [GetVersion specnu]
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) prefix$evv(EXEC)]]} {
		set released(prefix) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) strans$evv(EXEC)]]} {
		set released(strans) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) get_partials$evv(EXEC)]]} {
		set released(get_partials) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specross$evv(EXEC)]]} {
		set released(specross) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) lucier$evv(EXEC)]]} {
		set released(lucier) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) phase$evv(EXEC)]]} {
		set released(phase) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) chanphase$evv(EXEC)]]} {
		set released(chanphase) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) features$evv(EXEC)]]} {
		set released(features) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) brktopi$evv(EXEC)]]} {
		set released(brktopi) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) fofex$evv(EXEC)]]} {
		set released(fofex) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) grainex$evv(EXEC)]]} {
		set released(grainex) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) peakfind$evv(EXEC)]]} {
		set released(peakfind) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) constrict$evv(EXEC)]]} {
		set released(constrict) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) envnu$evv(EXEC)]]} {
		set released(envnu) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mchanpan$evv(EXEC)]]} {
		set released(mchanpan) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) texmchan$evv(EXEC)]]} {
		set released(texmchan) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) manysil$evv(EXEC)]]} {
		set released(manysil) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) retime$evv(EXEC)]]} {
		set released(retime) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) hover$evv(EXEC)]]} {
		set released(hover) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) hover2$evv(EXEC)]]} {
		set released(hover2) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) multimix$evv(EXEC)]]} {
		set released(multimix) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) frame$evv(EXEC)]]} {
		set released(frame) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) search$evv(EXEC)]]} {
		set released(search) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mchanrev$evv(EXEC)]]} {
		set released(mchanrev) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) wrappage$evv(EXEC)]]} {
		set released(wrappage) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mchstereo$evv(EXEC)]]} {
		set released(mchstereo) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mton$evv(EXEC)]]} {
		set released(mton) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) flutter$evv(EXEC)]]} {
		set released(flutter) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) peak$evv(EXEC)]]} {
		set released(peak) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mchshred$evv(EXEC)]]} {
		set released(mchshred) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mchzig$evv(EXEC)]]} {
		set released(mchzig) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) mchiter$evv(EXEC)]]} {
		set released(mchiter) 1
	}
;# NON CORE-MENU-BASED PROGS
	if {[file exists [file join $evv(CDPROGRAM_DIR) tv$evv(EXEC)]]} {
		set released(tv) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) spacedesign$evv(EXEC)]]} {
		set released(spacedesign) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) convert_to_midi$evv(EXEC)]]} {
		set released(convert_to_midi) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) cdpconv$evv(EXEC)]]} {
		set released(cdpconv) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) abfpan$evv(EXEC)]]} {
		set released(mchantoolkit) 1
	}
;# NEW RELEASE 7.0 PROGRAMS
	if {[file exists [file join $evv(CDPROGRAM_DIR) specsphinx$evv(EXEC)]]} {
		set released(specsphinx) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) superaccu$evv(EXEC)]]} {
		set released(superaccu) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) partition$evv(EXEC)]]} {
		set released(partition) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) specgrids$evv(EXEC)]]} {
		set released(specgrids) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) glisten$evv(EXEC)]]} {
		set released(glisten) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) tunevary$evv(EXEC)]]} {
		set released(tunevary) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) isolate$evv(EXEC)]]} {
		set released(isolate) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) rejoin$evv(EXEC)]]} {
		set released(rejoin) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) panorama$evv(EXEC)]]} {
		set released(panorama) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) tremolo$evv(EXEC)]]} {
		set released(tremolo) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) sfecho$evv(EXEC)]]} {
		set released(sfecho) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) packet$evv(EXEC)]]} {
		set released(packet) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) newsynth$evv(EXEC)]]} {
		set released(newsynth) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) tangent$evv(EXEC)]]} {
		set released(tangent) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) spectwin$evv(EXEC)]]} {
		set released(spectwin) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) transit$evv(EXEC)]]} {
		set released(transit) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) cantor$evv(EXEC)]]} {
		set released(cantor) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) shrink$evv(EXEC)]]} {
		set released(shrink) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) newtex$evv(EXEC)]]} {
		set released(newtex) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) ceracu$evv(EXEC)]]} {
		set released(ceracu) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) madrid$evv(EXEC)]]} {
		set released(madrid) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) shifter$evv(EXEC)]]} {
		set released(shifter) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) fracture$evv(EXEC)]]} {
		set released(fracture) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) subtract$evv(EXEC)]]} {
		set released(subtract) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) spectrum$evv(EXEC)]]} {
		set released(spectrum) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) newmorph$evv(EXEC)]]} {
		set released(newmorph) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) newdelay$evv(EXEC)]]} {
		set released(newdelay) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) filtrage$evv(EXEC)]]} {
		set released(filtrage) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) iterline$evv(EXEC)]]} {
		set released(iterline) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) iterlinef$evv(EXEC)]]} {
		set released(iterlinef) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) selfsim$evv(EXEC)]]} {
		set released(selfsim) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) iterfof$evv(EXEC)]]} {
		set released(iterfof) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) pulser$evv(EXEC)]]} {
		set released(pulser) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) chirikov$evv(EXEC)]]} {
		set released(chirikov) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) multiosc$evv(EXEC)]]} {
		set released(multiosc) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) synfilt$evv(EXEC)]]} {
		set released(synfilt) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) strands$evv(EXEC)]]} {
		set released(strands) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) refocus$evv(EXEC)]]} {
		set released(refocus) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) unknot$evv(EXEC)]]} {
		set released(unknot) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) rhymorph$evv(EXEC)]]} {
		set released(rhymorph) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) rhymorph2$evv(EXEC)]]} {
		set released(rhymorph2) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) silend$evv(EXEC)]]} {
		set released(silend) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) logistic$evv(EXEC)]]} {
		set released(logistic) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) cubicspline$evv(EXEC)]]} {
		set released(cubicspline) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) notchinvert$evv(EXEC)]]} {
		set released(notchinvert) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) peakiso$evv(EXEC)]]} {
		set released(peakiso) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) smooth$evv(EXEC)]]} {
		set released(smooth) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specanal$evv(EXEC)]]} {
		set released(specanal) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specav$evv(EXEC)]]} {
		set released(specav) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) ts$evv(EXEC)]]} {
		set released(ts) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) tsconvert$evv(EXEC)]]} {
		set released(tsconvert) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) copysfx$evv(EXEC)]]} {
		set released(copysfx) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) speculate$evv(EXEC)]]} {
		set released(speculate) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) spectune$evv(EXEC)]]} {
		set released(spectune) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) repair$evv(EXEC)]]} {
		set released(repair) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) distshift$evv(EXEC)]]} {
		set released(distshift) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) quirk$evv(EXEC)]]} {
		set released(quirk) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) rotor$evv(EXEC)]]} {
		set released(rotor) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) distcut$evv(EXEC)]]} {
		set released(distcut) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) envcut$evv(EXEC)]]} {
		set released(envcut) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specfold$evv(EXEC)]]} {
		set released(specfold) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) brownian$evv(EXEC)]]} {
		set released(brownian) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) spin$evv(EXEC)]]} {
		set released(spin) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) crumble$evv(EXEC)]]} {
		set released(crumble) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) ness-brass$evv(EXEC)]]} {
		set released(ness) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) tesselate$evv(EXEC)]]} {
		set released(tesselate) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) phasor$evv(EXEC)]]} {
		set released(phasor) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) crystal$evv(EXEC)]]} {
		set released(crystal) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) waveform$evv(EXEC)]]} {
		set released(waveform) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) dvdwind$evv(EXEC)]]} {
		set released(dvdwind) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) cascade$evv(EXEC)]]} {
		set released(cascade) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) synspline$evv(EXEC)]]} {
		set released(synspline) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) fractal$evv(EXEC)]]} {
		set released(fractal) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) splinter$evv(EXEC)]]} {
		set released(splinter) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) repeater$evv(EXEC)]]} {
		set released(repeater) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) verges$evv(EXEC)]]} {
		set released(verges) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) motor$evv(EXEC)]]} {
		set released(motor) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) stutter$evv(EXEC)]]} {
		set released(stutter) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) scramble$evv(EXEC)]]} {
		set released(scramble) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) impulse$evv(EXEC)]]} {
		set released(impulse) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) tweet$evv(EXEC)]]} {
		set released(tweet) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specnu$evv(EXEC)]]} {
		set specnu_version [GetVersion specnu]
		if {$specnu_version >= 8} {
			set released(specsync) 1
		}
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) sorter$evv(EXEC)]]} {
		set released(sorter) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specfnu$evv(EXEC)]]} {
		set released(specfnu) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) flatten$evv(EXEC)]]} {
		set released(flatten) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) wavmedian$evv(EXEC)]]} {
		set released(wavmedian) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) distortt$evv(EXEC)]]} {
		set released(distortt) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) bounce$evv(EXEC)]]} {
		set released(bounce) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) integratetime$evv(EXEC)]]} {
		set released(integratetime) 1
	}
	if {[file exists [file join $evv(CDPROGRAM_DIR) distmark$evv(EXEC)]]} {
		set released(distmark) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) distrep$evv(EXEC)]]} {
		set released(distrep) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) tostereo$evv(EXEC)]]} {
		set released(tostereo) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) suppress$evv(EXEC)]]} {
		set released(suppress) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) caltrain$evv(EXEC)]]} {
		set released(caltrain) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) specenv$evv(EXEC)]]} {
		set released(specenv) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) see_text_characters$evv(EXEC)]]} {
		set released(see_text_characters) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) pairex$evv(EXEC)]]} {
		set released(pairex) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) clicknew$evv(EXEC)]]} {
		set released(clicknew) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) texture_new$evv(EXEC)]]} {
		set released(texture_new) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) clip$evv(EXEC)]]} {
		set released(clip) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) fastconv$evv(EXEC)]]} {
		set released(fastconv) 1
	} 
	if {[file exists [file join $evv(CDPROGRAM_DIR) onset$evv(EXEC)]]} {
		set released(onset) 1
	} 
}

proc IncrQikcopyNum {up} {
	global qikcopy_num 
	if {![regexp {^[0-9]+$} $qikcopy_num]} {
		return
	}
	if {$up} {
		incr qikcopy_num
	} else {
		if {$qikcopy_num <= 1} {
			return
		}
		incr qikcopy_num -1
	}
}

proc ReplaceTheChar {typ} {
	global sl_real wl pa background_listing wstk chlist ch chcnt evv dupl_mix dupl_vbx dupl_txt nesstype nessorig

	catch {unset nessorig}
	if {!$sl_real} {
		Inf "Selected Files Can Have Spaces Replaced By Underscores"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ren_blist 0

	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]								;#	get each selected file
		set fdir [file dirname $fnam]
		if {[string length $fdir] <= 1} {
			set fdir ""
		}
		set zfnam [file tail $fnam]
		switch -- $typ {
			"space" {
				set nufnam [file join $fdir [ReplaceSpaces $zfnam]]
			}
			"dot" {
				set nufnam [file join $fdir [ReplaceDots $zfnam]]
			}
		}
		if {![string match $fnam $nufnam]} {
			if {[file exists $nufnam] && ![file isdirectory $nufnam]} {
				Inf "A File With The Name '$nufnam' Already Exists"
				return
			}
			lappend nufnams $i $nufnam
		}
	}
	if {![info exists nufnams]} {
		Inf "No Files To Rename"
		return
	}
	set rename_cnt 0 
	set save_mixmanage 0
	set nessupdate 0
	foreach {i nufnam} $nufnams {
		set origfnam [$wl get $i]								;#	get each selected file
		set haspmark [HasPmark $origfnam]
		set hasmmark [HasMmark $origfnam]
		if [catch {file rename $origfnam $nufnam} zub] {
			Inf "Cannot Rename File '$origfnam' To '$nufnam'"
		} else {
			DataManage rename $origfnam $nufnam
			lappend couettelist $origfnam $nufnam
			UpdateBakupLog $origfnam delete 0
			UpdateBakupLog $nufnam create 1
			CheckMainmix $origfnam $nufnam
			CheckMainmixSnd $origfnam $nufnam
			$wl delete $i								
			$wl insert $i $nufnam
			UpdateChosenFileMemory $origfnam $nufnam
			set oldname_pos_on_chosen [LstIndx $origfnam $ch]
			if {$oldname_pos_on_chosen >= 0} {
				RemoveFromChosenlist $origfnam
				set chlist [linsert $chlist $oldname_pos_on_chosen $nufnam]
				incr chcnt
				$ch insert $oldname_pos_on_chosen $nufnam
			}
			RenameProps	$origfnam $nufnam 1				
			DummyHistory $origfnam "RENAMED_$nufnam"
			if {[MixMRename $origfnam $nufnam 0]} {
				set save_mixmanage 1
			} elseif {[NessMRename $origfnam $nufnam 0]} {
				set nessupdate 1
			}
			if {$haspmark} {
				MovePmark $origfnam $nufnam
			}
			if {$hasmmark} {
				MoveMmark $origfnam $nufnam
			}
			if [IsInBlists $origfnam] {
				if [RenameInBlists $origfnam $nufnam] {
					set ren_blist 1
				}
			}
			if [IsOnScore $origfnam] {
				RenameInScore $origfnam $nufnam
			}
			RenameOnDirlist $origfnam $nufnam
			incr rename_cnt
		}
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$rename_cnt} {
		if {$save_mixmanage} {
			MixMStore
		}
		if {$nessupdate} {
			NessMStore
		}
		catch {unset rememd}
	} else {
		Inf "No Files Have Been Renamed"
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	foreach i $ilist {
		$wl selection set $i
	}
	return 1
}

proc SndInMix {} {
	global mixmanage wl pa evv wstk
	if {![info exists mixmanage]} {
		Inf "No Information On Mixes"
		return
	}
	set i [$wl curselection]
	if {$i < 0} {
		Inf "Select A Soundfile"
		return
	}
	if {[llength $i] == 1} {
		set fnam [$wl get $i]
		if {![info exists pa($fnam,$evv(FTYP))]} {
			return
		}
		set ftyp $pa($fnam,$evv(FTYP))
		if {$ftyp != $evv(SNDFILE)} {
			Inf "Select A Soundfile"
			return
		}
	} else {
		foreach ii $i {
			set fnam [$wl get $ii]
			if {![info exists pa($fnam,$evv(FTYP))]} {
				continue
			}
			set ftyp $pa($fnam,$evv(FTYP))
			if {$ftyp != $evv(SNDFILE)} {
				continue
			}
			lappend fnams $fnam
		}
		if {![info exists fnams]}  {
			Inf "No Soundfiles Chosen"
			return
		}
		if {[llength $fnams] > 1} {
			foreach fnam $fnams {
				foreach name [array names mixmanage] {
					set k [lsearch $mixmanage($name) $fnam]
					if {$k >= 0} {
						lappend outlist [list "YES" $fnam]
						lappend mixoutlist $name
						break
					}
				}
				if {$k < 0} {
					lappend outlist [list "NO" $fnam]
				}
			}
			set verdict [lindex [lindex $outlist 0] 0]
			foreach zart [lrange $outlist 1 end] {
				if {![string match [lindex $zart 0] $verdict]} {
					set verdict "VARIOUS"
					break
				}
			}
			switch -- $verdict {
				"YES" {
					set msg "All These Files Are In Mixfiles\n\n"
					append msg "See Which Mixfiles They Are In ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						Inf "Select Single Soundfile To Find Which Mixfile It Is In"
						return
					} 
					foreach fnamval $outlist mxfnam $mixoutlist {
						set line [list [lindex $fnamval 1] " In Mix " $mxfnam]
						lappend nuoutlist $line
					}
					set msg "Soundfiles In Mixfiles\n\n"
					set cnt 0
					foreach line $nuoutlist {
						append msg $line "\n"
						incr cnt
						if {$cnt >= 20} {
							Inf $msg
							set cnt 0
							set msg "More Soundfiles In Mixfiles\n\n"
						}
					}
					if {$cnt > 0} {
						Inf $msg
					}
				}
				"NO" {
					Inf "None Of These Files Are In Mixfiles"
				}
				"VARIOUS" {
					set msg "Only The Following Soundfiles Are In Mixfiles\n\n"
					set cnt 0
					set mcnt 0
					foreach fnamval $outlist {
						if {[string match [lindex $fnamval 0] "YES"]} {
							set fnam [lindex $fnamval 1]
							set mfnam [lindex $mixoutlist $mcnt]
							incr mcnt
							set msg2 $fnam
							append msg2 " In Mix " $mfnam
							append msg $msg2 "\n"		
						} else {
							append msg $fnamval "\n"
						}
						incr cnt
						if {$cnt >= 20} {
							Inf $msg
							set cnt 0
							set msg "More Soundfiles In Mixfiles\n\n"
						}
					}
					if {$cnt > 0} {
						Inf $msg
					}
				}
			}
			return
		}
		set fnam [lindex $fnams 0]
	}
	foreach name [array names mixmanage] {
		set k [lsearch $mixmanage($name) $fnam]
		if {$k >= 0} {
			lappend outlist $name
		}
	}
	if {![info exists outlist]} {
		Inf "$fnam Is Not In Any Known Mixfiles"
		return
	}
	if {[llength $outlist] == 1} {
		Inf "$fnam\nIs In The Mixfile\n[lindex $outlist 0]"
		return
	}
	set msg "$fnam\nIs In The Following Mixfiles\n\n"
	set cnt 0
	foreach fnam $outlist {
		append msg $fnam "\n"
		incr cnt
		if {$cnt >= 20} {
			Inf $msg
			set cnt 0
			set msg "And The Following Mixfiles\n\n"
		}
	}
	if {$cnt > 0} {
		append msg "\n\nHighlight These, If On The Workspace ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			foreach fnam $outlist {
				set j [LstIndx $fnam $wl]
				if {$j >= 0} {
					lappend nusel $j
				}
			}
			if {[info exists nusel]} {
				set doshow 1
				if {[llength $nusel] != [llength $outlist]} {
					set msg "Not All The Mixes Are On The Workspace : Highlight Just Those That Are ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						set doshow 0
					}
				}
				if {$doshow} {
					$wl selection clear 0 end
					foreach j $nusel {
						$wl selection set $j
					}
				}
			} else {
				Inf "None Of The Mixfiles Are On The Workspace"
			}
		}
	}
}

proc DealwithCleaningFiles {} {
	global evv wstk

	set evv(CLEANKIT_NAME) "__cln"

	foreach fnam [glob -nocomplain $evv(CLEANKIT_NAME)*] {
		if [file isdirectory $fnam] {
			continue
		}
		if {![info exists killclean]} {
			set msg "There Are Files On The Workspace Starting With The Reserved Name '$evv(CLEANKIT_NAME)'"
			append msg "\nTo Retain These Files: You Must Rename Them Outside The Sound Loom."
			append msg "\n\nDo You Wish To Retain Them ?"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				return 0
			} else {
				break
			}
		}
	}
	DeleteAllCkitFiles	
	return 1
}

proc InterleaveFile {} {
	global wstk wl ch chlist chcnt pa evv
	if {![info exists chlist] || ([llength $chlist] < 2)} {
		Inf "Insufficient Files On Chosen Files List"
		return
	}
	foreach fnam $chlist {
		if {![info exists pa($fnam,$evv(FTYP))]} { 
			Inf "Bad Data On Chosen Files"
			return
		} elseif {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Not All Chosen Files Are Soundfiles"
			return
		}
	}
	set i 0
	foreach fnam $chlist {
		if {$i == 0} {
			set chans $pa($fnam,$evv(CHANS))
		} elseif {$pa($fnam,$evv(CHANS)) != $chans} {
			Inf "Not All Chosen Files Have Same Number Of Channels"
			return
		}
		incr i
	}
	unset i
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] > 1) || ($i < 0)} {
		Inf "Select Just One File On Workspace"
		return
	}
	set fnam [$wl get $i]
	if {![info exists pa($fnam,$evv(FTYP))]} { 
		Inf "Bad Data On Workspace Selected File"
		return
	} elseif {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Workspace Selected File Is Not A Soundfile"
		return
	} elseif {$pa($fnam,$evv(CHANS)) != $chans} {
		Inf "Workspace Selected File Does Not Have Same Number Of Channels As Chosen-List Files"
		return
	}
	set go_ahead 0
	set keep_dupl 1
	set nulist [lindex $chlist 0]
	foreach fnamorig [lrange $chlist 1 end] {
		set keep_it 1
		if {[string match $fnam $fnamorig]} {
			if {!$go_ahead} {
				set msg "Remove File(s) '$fnam' From Chosen File List Before Interleaving ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					set msg "Interleave Anyway ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						return
					}
				} else {
					set keep_dupl 0
				}
				set go_ahead 1
			}
			if {!$keep_dupl} {
				set keep_it 0
			}
		}
		if {$keep_it} {
			lappend nulist $fnam $fnamorig
		}
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	foreach fnam $nulist {
		lappend chlist $fnam		;#	add to end of list
		$ch insert end $fnam		;#	add to end of display
		incr chcnt
	}
	ChlistDupls
}

proc ZDeleteFromSystem {} {
	global wl dl pr_5 evv chlist ch
	if {[info exists chlist] && ([llength $chlist] > 0)} {
		set ilist [$ch curselection]
		if {([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			$wl selection clear 0 end
			foreach i $ilist {
				set fnam [$ch get $i]
				set j [LstIndx $fnam $wl]
				$wl selection set $j
			}
		}
	}
	set ilist [$wl curselection]
	if {([llength $ilist] <= 0) || (([llength $ilist] == 1) && ($ilist  < 0))} {
		set pr_5 $evv(DELETE_SOME)		
	} else {
		DeleteFromSystem 0
	}
}

proc ChangePropfilesProtocol {} {
	global old_props_protocol evv pr_prproto proprot
	set fnam [file join $evv(CDPRESOURCE_DIR) "proproto"]
	append fnam $evv(CDP_EXT)
	set f .proproto
	if [Dlg_Create $f "Props Protocol" "set pr_prproto 0" -borderwidth $evv(SBDR)] {
		button $f.0 -text Abandon -command "set pr_prproto 0" -highlightbackground [option get . background {}]
		radiobutton $f.1 -text "All sounds in a property file must be in SAME directory" -variable proprot -value 1 -command DoProPro
		radiobutton $f.2 -text "Sounds in a property file MAY BE FROM DIFFERENT directories" -variable proprot -value 0 -command DoProPro
		pack $f.0 $f.1 $f.2 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_prproto 0}
		bind $f <Escape> {set pr_prproto 0}
		bind $f <Key-space> {set pr_prproto 0}
	}
	set pr_prproto 0
	set proprot $old_props_protocol
	raise $f
	update idletasks
	StandardPosition2 $f
	My_Grab 0 $f pr_prproto $f
	tkwait variable pr_prproto
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc DoProPro {} {
	global pr_prproto proprot old_props_protocol evv
	set fnam [file join $evv(CDPRESOURCE_DIR) "proproto"]
	append fnam $evv(CDP_EXT)
	if {$proprot != $old_props_protocol} {
		if {$proprot == 1} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Create File '$fnam' To Remember Your Property-Files Protocol"
				return
			}
			set old_props_protocol 1
			close $zit
		} elseif {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot Delete File '$fnam' To Remember Your Property-files Protocol"
			}
			set old_props_protocol 0
		}
	}
	set pr_prproto 0
}

proc ChangeSubpatchProtocol {} {
	global old_subpatch_protocol evv pr_subproto subprot
	set fnam [file join $evv(CDPRESOURCE_DIR) "subproto"]
	append fnam $evv(CDP_EXT)
	set f .subproto
	if [Dlg_Create $f "Props Protocol" "set pr_subproto 0" -borderwidth $evv(SBDR)] {
		button $f.0 -text Abandon -command "set pr_subproto 0" -highlightbackground [option get . background {}]
		radiobutton $f.1 -text "Old subpatch numbering" -variable subprot -value 1 -command DoSubPro
		radiobutton $f.2 -text "New subpatch numbering" -variable subprot -value 0 -command DoSubPro
		pack $f.0 $f.1 $f.2 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_subproto 0}
		bind $f <Escape> {set pr_subproto 0}
		bind $f <Key-space> {set pr_subproto 0}
	}
	set pr_subproto 0
	set subprot $old_subpatch_protocol
	raise $f
	update idletasks
	StandardPosition2 $f
	My_Grab 0 $f pr_subproto $f
	tkwait variable pr_subproto
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc DoSubPro {} {
	global pr_subproto subprot old_subpatch_protocol evv
	set fnam [file join $evv(CDPRESOURCE_DIR) "subproto"]
	append fnam $evv(CDP_EXT)
	if {$subprot != $old_subpatch_protocol} {
		if {$subprot == 1} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Create File '$fnam' To Remember Your Subpatch Protocol"
				return
			}
			set old_subpatch_protocol 1
			close $zit
		} elseif {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot Delete File '$fnam' To Remember Your Subpatch Protocol"
			}
			set old_subpatch_protocol 0
		}
	}
	set pr_subproto 0
}

proc GetPropsProtocol {} {
	global old_props_protocol evv
	set old_props_protocol 0
	set fnam [file join $evv(CDPRESOURCE_DIR) "proproto"]
	append fnam $evv(CDP_EXT)
	if {[file exists $fnam]} {
		set old_props_protocol 1
	}
}

proc GetSubpatchProtocol {} {
	global old_subpatch_protocol evv
	set old_subpatch_protocol 0
	set fnam [file join $evv(CDPRESOURCE_DIR) "subproto"]
	append fnam $evv(CDP_EXT)
	if {[file exists $fnam]} {
		set old_subpatch_protocol 1
	}
}

proc DecrGenericnumlo {} {
	global genericnumlo 
	set val [expr $genericnumlo - 1]
	if {$val >= 0} {
		set genericnumlo $val
	}
}

proc StripLeadingZerosFromInteger {val} {
	set isneg 0
	if {[string match [string index $val 0] "-"]} {
		set isneg 1
		set val [string range $val 1 end]
	}
	if {$val == "0"} {
		return 0
	}
	set len [string length $val]
	set n 0
	while {[string match [string index $val $n] "0"]} {
		incr n
	}
	set val [string range $val $n end]
	if {$isneg} {
		set nstr "-"
		append nstr $val
		set val $nstr
	}
	return $val
}

proc UpdateInfo {verno} {
	global evv playcmd_dummy playdir_dummy system_initialisation wstk
	set fnam [file join $evv(CDPRESOURCE_DIR) ver$verno$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		if {$verno == "11-0-0"} {		;#	MAC ONLY
			set play_cmd [file tail $playcmd_dummy]
			if {![string match $playcmd_dummy "QuickTime Player.app/Contents/MacOS/QuickTime Player"]} {
				set msg "You are currently using \"$playcmd_dummy\"\n(in directory \"$playdir_dummy\")\nto play sounds on the Loom.\n\n"
				append msg "Would you prefer to use \"QuickTime Player\" ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set system_initialisation 1
					EstablishPlayLocation 1
					set system_initialisation 0
				}
			}
		}
		DisplayUpdates
		if {![catch {open $fnam "w"} zit]} {
			close $zit
			foreach zfnam [glob -nocomplain [file join $evv(CDPRESOURCE_DIR) ver*]] {
				if {![string match $zfnam $fnam]} {
					catch {file delete $zfnam}
				}
			}
		}
	}
}

#------ FORCE text-edit (not graphics) as default editing style, so SOUND VIEW can be used ....

proc ForceTextEditOfBrkfiles {} {
	global evv
	set fnam [file join $evv(CDPRESOURCE_DIR) $evv(EDIT_STYLE)$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		if {![catch {open $fnam "w"} zit]} {
			close $zit
		}
	}
}

#------ Find Nth item in a listing and highlight it

proc ListingPosition {ll} {
	global pr_listpos list_pos evv
	set f .listpos
	if [Dlg_Create $f "Get Nth Item" "set pr_listpos 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.f -text Find -command "set pr_listpos 1" -highlightbackground [option get . background {}]
		button $f.0.q -text Quit -command "set pr_listpos 0" -highlightbackground [option get . background {}]
		pack $f.0.f -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Position in list  "
		entry $f.1.e  -textvariable list_pos -width 8
		pack $f.1.ll $f.1.e  -side left -pady 2
		pack $f.1 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_listpos 1}
		bind $f <Escape> {set pr_listpos 0}
	}
	set endpos [$ll index end]
	set pr_listpos 0
	set list_pos ""
	raise $f
	update idletasks
	StandardPosition2 $f
	My_Grab 0 $f pr_listpos $f
	set finished 0
	while {!$finished} {
		tkwait variable pr_listpos
		if {!$pr_listpos} {
			break
		}
		if {![regexp {^[0-9]+$} $list_pos]} {
			Inf "No Position Value Entered"
			continue
		}
		if {$list_pos >= $endpos} {
			set list_pos [expr $endpos - 1]
		}
		$ll selection clear 0 end
		$ll selection set $list_pos
		set pos [expr double($list_pos) / double($endpos)]
		$ll yview moveto $pos
		break
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc WkspaceToggle {} {
	global wksp_in_chose_mode
	if {$wksp_in_chose_mode} {
		ToWkspaceMode
	} else {
		ToSelectionMode
	}
}

proc HowManySel {} {
	global wl
	set ilist [$wl curselection]
	set len [llength $ilist]
	set hm $len
	if {($len == 1) && ([lindex $ilist 0] == -1)} {
		set hm 0
	}
	Inf "$hm Files Selected"
}

proc HowManyLines {} {
	global wl evv pa
	set ilist [$wl curselection]
	if {![info exists ilist] || (([llength $ilist] == 1) && ($ilist == -1))} {
		Inf "No Files Selected"
		return
	}
	set linecnt 0
	foreach i $ilist {
		set fnam [$wl get $i]
		if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
			Inf "Not All Selected Files Are Textfiles"
			return
		}
		incr linecnt $pa($fnam,$evv(LINECNT))
	}
	Inf "Total Number Of Lines = $linecnt"
}

#--- Delete a file which is NOT a soundfile (checking the mixmanagement system)

proc DeleteNonSndfileFromSystem {fnam} {
	global wl rememd evv

	if {[file extension $fnam] == $evv(NESS_EXT)} {
		return 0
	}
	if {[DeleteFileFromSystem $fnam 0 1]} {
		DummyHistory $fnam "DESTROYED"
		MixMDelete $fnam 1	;#	If its a mixfile, updates mixmanager	
	} else {
		return 0
	}
	set i [LstIndx $fnam $wl]
	if {$i >= 0} {
		WkspCnt [$wl get $i] -1
		$wl delete $i
		catch {unset rememd}
	}
	return 1
}

proc HelpEventIsolator {} {
	set msg "Specified Events In A Soundfile Are Retained\n"
	append msg "While Everything Else Is Replaced By Silence.\n\n"
	append msg "The Retained Events Hence Remain At Their Original Times.\n"
	Inf $msg
}

proc LoudSort {listing} {
	global wl ch chlist evv pa dursortmsgs
	catch {unset dursortmsgs}
	if {$listing == "wl"} {
		set ll $wl
		set ilist [$ll curselection]
		if {[llength $ilist] < 2} {
			Inf "Insufficient Files Selected"
			return
		}
		foreach i $ilist {
			lappend fnams [$wl get $i]
		}
	} else {
		set ll $ch
		if {![info exists chlist] || ([llength $chlist] < 2)} {
			Inf "Insufficient Files On Chosen List"
			return
		}
		set cnt 0
		foreach fnam $chlist {
			lappend fnams $fnam
			lappend ilist $cnt
			incr cnt
		}
	}
	set noprog 0
	foreach i $ilist fnam $fnams {
		if {![info exists pa($fnam,$evv(MAXREP))]} {
			if {![info exists basecmd]} {
				set basecmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				if [info exists maxsamp_missing] {
					set noprog 1
					Inf "maxsamp2$evv(EXEC) Is Not On Your System.\nCannot Get Maxsample Of Any Files Which Currently Have No Maxsample Information."
				} elseif [ProgMissing $basecmd "Cannot Get Maxsample Of Any Files Which Currently Have No Maxsample Information."] {
					set noprog 1
				}
			} 
			if {$noprog} {
				lappend badfiles $fnam
				continue
			}
			set cmd [list $basecmd $fnam]
			catch {unset maxsamp_line}
			if [catch {open "|$cmd"} CDPmaxId] {
				lappend dursortmsgs "$fnam : $CDPmaxId"
				lappend badfiles $fnam
				continue
	   		} else {
	   			fileevent $CDPmaxId readable "GetData_Maxsamp_For_LoudSort $fnam"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				lappend badfiles $fnam
				continue
			} else {
				set pa($fnam,$evv(MAXSAMP)) [lindex $maxsamp_line 0]
				set pa($fnam,$evv(MAXLOC))  [lindex $maxsamp_line 1]
				set pa($fnam,$evv(MAXREP))  [lindex $maxsamp_line 2]
			}
		}
		lappend nuilist $i
	}
	if {[llength $nuilist] < 2} {
		set msg "Insufficient Files Selected Have A Known Duration Value"
		if {[info exists badfiles]} {
			append msg "\n\nThe Maxsample Of The Following Files Could Not Be Determined."
			set cnt 0
			foreach fnam $badfiles {
				append msg "\n$fnam"
				incr cnt
				if {$cnt >= 20} {
					append msg "\nAnd More"
					break
				}
			}
		}
		Inf $msg
		return
	}
	set ilist $nuilist
	foreach i $ilist {
		lappend louds $pa([$ll get $i],$evv(MAXSAMP))
	}

	set len [llength $louds]
	set len_less_one $len
	incr len_less_one -1
	set n 0
	while {$n < $len_less_one} {
		set thisloud [lindex $louds $n]
		set thisi	[lindex $ilist $n]
		set m $n
		incr m
		while {$m < $len} {
			set thatloud [lindex $louds $m]
			set thati	[lindex $ilist $m]
			if {$thatloud > $thisloud} {
				set louds [lreplace $louds $m $m $thisloud]
				set louds [lreplace $louds $n $n $thatloud]
				set ilist [lreplace $ilist $m $m $thisi]
				set ilist [lreplace $ilist $n $n $thati]
				set thisloud $thatloud
				set thisi   $thati
			}
			incr m
		}
		incr n
	}
	foreach i $ilist {
		lappend nufiles [$ll get $i]
	}
	if [info exists badfiles] {
		set nufiles [concat $nufiles $badfiles]
	}
	set ilist [lsort -integer -decreasing $ilist]
	foreach i $ilist {
		$ll delete $i
	}
	foreach fnam [$ll get 0 end] {
		lappend nufiles $fnam
	}
	$ll delete 0 end
	foreach fnam $nufiles {
		$ll insert end $fnam
	}
	if {$listing == "ch"} {
		unset chlist
		foreach fnam [$ch get 0 end] {
			lappend chlist $fnam
		}
	}
	while {[info exists dursortmsgs]} {
		set msg ""
		set cnt 0
		set OK 1
		foreach line $dursortmsgs {
			append msg "\n$line"
			incr cnt
			if {$cnt > 20} {
				set OK 0
				set dursortmsgs [lrange $dursortmsgs $cnt end]
				break
			}
		}
		if {$OK} {
			unset dursortmsgs
		}
	}
}

#---- Display maximum sampleval

proc GetData_Maxsamp_For_LoudSort {fnam} {
	global CDPmaxId done_maxsamp maxsamp_line dursortmsgs evv

	if {[info exists CDPmaxId] && [eof $CDPmaxId]} {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match INFO:* $line] {
			return
		} elseif [string match WARNING:* $line] {
			lappend dursortmsgs "$fnam : $line"
			return
		} elseif [string match ERROR:* $line] {
			lappend dursortmsgs "$fnam : $line"
			return
		} elseif [string match KEEP:* $line] {
			set line [string range $line 6 end] 
			set maxsamp_line $line
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} else {
			lappend dursortmsgs "$fnam : $line"
			return
		}
	}
	update idletasks
}			

proc HelpTimeMarks {} {
	set msg "TIME MARKS\n"
	append msg "\n"
	append msg "Specific times in a file (e.g. principal peaks)\n"
	append msg "Can be marked and stored as \"Timemarks\".\n"
	append msg "\n"
	append msg "Timemark operations can use STORED timemarks\n"
	append msg "OR timemarks ENTERED when a timemark-process is run.\n"
	append msg "\n"
	append msg "Timemarks entered when a timemark-process is run\n"
	append msg "can also be stored at that moment.\n"
	append msg "\n"
	append msg "Files can be synchronised at such timemarks\n"
	append msg "(by timewarping one of the files)\n"
	append msg "or timewarped so the timemarks sync to some\n"
	append msg "other set of time data (pulse, rhythm, timecues).\n"
	Inf $msg
}

proc HelpTimeCues {} {
	set msg "                                        TIMEMARKS\n"
	append msg "\n"
	append msg "Graphic display of sndfile can be used to enter \"timemarks\"\n"
	append msg "by clicking at appropriate places on the display.\n"
	append msg "If 3 (or more) files have timemarks, they can by synchronised\n"
	append msg "at these timemarks.\n"
	append msg "Alternatively, a textfile-listing of timemarks can be used.\n"
	append msg "\n"
	append msg "                                        TIME CUES\n"
	append msg "\n"
	append msg "A list of (increasing) times, stored in a textfile.\n"
	append msg "\n"
	append msg "Can be automatically created here, using specified tempi,\n"
	append msg "or using mouse clicks to measure out time between time-marks.\n"
	append msg "\n"
	append msg "                       SYNC FILES TO TIMEMARKS BY SILENCEPADS\n"
	append msg "\n"
	append msg "Two or more soundfiles graphically displayed, successively,\n"
	append msg "and the attack peak of each marked on the display.\n"
	append msg "\n"
	append msg "Files with attack peaks before latest of these attack peaks\n"
	append msg "are padded with initial silence, so that the output files\n"
	append msg "all have synchronous attack peaks.\n"
	append msg "\n"
	Inf $msg
}

proc MidiBrkSeqHelp {} {
	set msg "MIDI BRKPNTS AND SEQUENCES"
	append msg "\n"
	append msg "A MIDI SEQUENCE file contains onset times of samples,\n"
	append msg "their transpositions, and event levels (0-1).\n"
	append msg "Conversion here assumes transpositions set for\n"
	append msg "default sample pitch MIDI 60 (Middle C).\n"
	append msg "\n"
	append msg "A FRQ BRKPNT file contains data for synthesis\n"
	append msg "(or convertible to varibank filter format).\n"
	append msg "\n"
	append msg "A FILTER file contains (MIDI) data in a format\n"
	append msg "to control a varibank filter.\n"
	append msg "\n"
	append msg "A STANDARD MIDI file contains binary (MIDI) data\n"
	append msg "in a format readable by a MIDI device or program-environment.\n"
	append msg "\n"
	append msg "A STACCATO MIDI FILE is the same format\n"
	append msg "with note-offs set to produce a staccato output.\n"
	append msg "\n"
	append msg "Options with \"+PEAKS\" require a 2nd input file\n"
	append msg "containing a list of levels of each MIDI note.\n"
	Inf $msg
}

proc TransposSyncHelp {} {
	set msg "TRANSPOSING SYNCD TO TIMEMARKS\n"
	append msg "\n"
	append msg "In these processes 1st file, & its frequency data,\n"
	append msg "act as template for freq warping of other files.\n"
	append msg "\n"
	append msg "TRANSPOSE FILES TO PITCH OF 1st, AT TIMEMARKS\n"
	append msg "\n"
	append msg "Later files transposed to pitchline of 1st file.\n"
	append msg "Pitches at timemarks 1,2,etc of files to be warped\n"
	append msg "correspond to pitches at timemarks of 1st file.\n"
	append msg "\n"
	append msg "TRANSPOSE FILES TO 1st & SYNC AT TIMEMARKS\n"
	append msg "\n"
	append msg "Later files transposed AND time-warped so that\n"
	append msg "timemarks in warped files sync with those in file 1\n"
	append msg "& pitch sequence of all files is same as 1st file.\n"
	Inf $msg
}

proc MelAssignHelp {} {
	set msg "ASSOCIATING A PITCH LINE WITH A SOUND\n"
	append msg "\n"
	append msg "Associate a timed, tempered-scale MIDI motif with sound,\n"
	append msg "graphically entering both time and pitch.\n"
	append msg "\n"
	append msg "ADJUST SND PITCH USING ASSOCIATED LINE\n"
	append msg "\n"
	append msg "Pitches in line can be adjusted, & the sound pitchwarped\n"
	append msg "in parallel with these adjustments to the MIDI line.\n"
	append msg "Process assumes a frq breakpnt file for input sound exists\n"
	append msg "in same directory as sound, and with the name tag \"frq\",\n"
	append msg "so sound \"mysound\" would be associated with \"mysound_frq\".\n"
	append msg "\n"
	append msg "ADJUST PITCHLINE TO HARMONIC FIELD & WARP SND\n"
	append msg "\n"
	append msg "The MIDI line can be forced onto Harmonic field,\n"
	append msg "and used to pitchwarp associated soundfile.\n"
	append msg "Process also assumes frq breakpnt file for sound exists.\n"
	append msg "\n"
	append msg "You can also warp REAL freq-trace of sound to\n"
	append msg "a harmonic field, using CDP repitch tools.\n"
	append msg "\n"
	append msg "CUT SPECIFICALLY-PITCHED SEGS FROM SOUNDSET\n"
	append msg "\n"
	append msg "Takes set of sounds and associated pitch-tracking file\n"
	append msg "(eiterh varibank MIDI-data file OR frequency brkpnt file)\n"
	append msg "and searches for areas within sounds that contain\n"
	append msg "a set of specified MIDI pitches (only).\n"
	append msg "\n"
	append msg "It generates either\n"
	append msg "A batchfile, to cut these areas from original sounds, or\n"
	append msg "A soundfile list of sounds containing pitches required.\n"
	append msg "\n"
	append msg "ISOLATE SPECIFICALLY-PITCHED SEGS IN SOUNDSET\n"
	append msg "\n"
	append msg "Takes a set of soundfiles and their associated pitch-tracking data\n"
	append msg "(which must be a varibank MIDI-data file)\n"
	append msg "and searches for areas within the sounds that contain a set of specified MIDI pitches.\n"
	append msg "\n"
	append msg "It imposes a loudness envelope on the sound which retains specified pitches and silences others.\n"
	Inf $msg
}

#------- TEMPORARY PROCEDURE TO SORT DIPHONE STUFF

proc DataSort {info} {
	global evv wl wstk chlist
	if {$info} {
		set msg "SORT ON 1st WORD OF LINE, TO DECREASING STRING LENGTH\n"
		append msg "+ ALPHABETIC ORDER WITHIN STRING LENGTH GROUPS.\n"
		append msg "1) Assumes text data in the format ......\n"
		append msg "Astring eAstring1\n"
		append msg "-        eAstring2 stringa stringb ..... (optional)\n"
		append msg "-        eAstring3 stringm stringn ..... (optional)\n"
		append msg "Bstring eBstring1\n"
		append msg "         (etc)\n"
		append msg "where eAstring1,eAstring2... equivalent to \"Astring\",\n"
		append msg "\"eAstring1\" being the standard equivalent,\n"
		append msg "& \"eAstring2\" etc. being alternatives, where\n"
		append msg "stringa stringb... is set of cases where alternative applies.\n"
		append msg "e.g.\n"
		append msg "\"eAstring1\" = standard phonetic equiv to word-ending \"Astring\"\n"
		append msg "\"eAstring3\" = some alternative pronunciation,\n"
		append msg "and \"stringm stringn .....\" would be a list of words\n"
		append msg "having that alternative pronunciation.\n"
		append msg "***********************************\n"
		append msg "Algorithm sorts SETS of lines,\n"
		append msg "using 1st-word of 1st-line of line-set,\n"
		append msg "(in the above example, Astring and Bstring).\n"
		append msg "Line-sets 1st sorted on length of inital strings\n"
		append msg " (Astring, Bstring etc.).\n"
		append msg "Within length-groups, lines then sorted alphabetically.\n"
		append msg "SO (bo,biz,bi,buzan,bik)\n"
		append msg "would first be sorted by length...\n"
		append msg "(buzan,biz,bik,bo,bi)\n"
		append msg "and then alphabetically, thus...\n"
		append msg "(buzan,bik,biz,bi,bo)\n"
		Inf $msg
		return
	}
	set ilist [$wl curselection]
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
	} elseif {([llength $ilist] != 1) || ([lindex $ilist 0] == -1)} {
		Inf "Select A Single File"
		return
	} else {
		set fnam [$wl get [lindex $ilist 0]]
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File $fnam"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set line [split $line]
		catch {unset nuline}
		foreach item $line {
			if {[string length $item] > 0} {
				if {![info exists nuline]} {
					set nuline [list $item]
				} else {
					lappend nuline $item
				}
			}
		}
		if {[info exists nuline]} {
			lappend nulines $nuline
		}
	}
	close $zit
	if {![info exists nulines]} {
		Inf "NO DATA IN FILE $fnam"
		return
	}
	set linecnt 0
	foreach line $nulines {
		if [string match [lindex $line 0] "-"] {
			if {$linecnt == 0} {
				Inf "First Item In Data Cannot Be '-'"
				return
			}
			if {![info exists linegroup]} {
				set linegroup [list $line]
			} else {
				lappend linegroup $line
			}
		} else {
			if [info exists linegroup] {
				if {![info exists linegroups]} {
					set linegroups [list $linegroup]
				} else {
					lappend linegroups $linegroup
				}
				unset linegroup
			}
			set linegroup [list $line]
		}
		incr linecnt
	}
	if {[info exists linegroup]} {
		lappend linegroups $linegroup
	}
	if {![info exists linegroups]} {
		Inf "No Linegroups : Error In Code"
		return
	}
	set fnamout [file rootname [file tail $fnam]]
	append fnamout "_sorted"
	lappend fnamout $evv(TEXT_EXT)
	if {[file exists $fnamout]} {
		set msg "Sort File '$fnamout' Already Exists: Overwrite It ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		} elseif [catch {file delete $fnamout} zit] {
			Inf "Cannot Delete Existing Sortfile"
			return
		}
	}
	;#	SORT BY LENGTH
	set len [llength $linegroups]
	set len_less_one [expr $len - 1]
	set n 0
	while {$n < $len_less_one} {
		set linegroup_n [lindex $linegroups $n]
		set line [lindex $linegroup_n 0]
		set word_n [lindex $line 0]
		set len_n [string length $word_n]
		set m $n
		incr m
		while {$m < $len} {
			set linegroup_m [lindex $linegroups $m]
			set line [lindex $linegroup_m 0]
			set word_m [lindex $line 0]
			set len_m [string length $word_m]
			if {$len_m > $len_n} {
				set linegroups [lreplace $linegroups $n $n $linegroup_m]
				set linegroups [lreplace $linegroups $m $m $linegroup_n]
				set linegroup_n $linegroup_m 
				set len_n $len_m
			}
			incr m
		}
		incr n
	}
			;# SORT INTO GROUPS OF EQUAL LENGTH

	set linegroup [lindex $linegroups 0]
	set line [lindex $linegroup 0]
	set word [lindex $line 0]
	set wlen [string length $word]
	set maxwlen $wlen
	set n 0
	while {$n < $len} {
		set linegroup [lindex $linegroups $n]
		set line [lindex $linegroup 0]
		set word [lindex $line 0]
		set thislen [string length $word]
		if {$thislen != $wlen} {
			set wlen $thislen
		}
		lappend gp($wlen) $linegroup
		incr n
	}
	set minwlen $wlen
	set thislen $maxwlen
	while {$thislen >=  $minwlen} {
		if [info exists gp($thislen)] {
			set linegps $gp($thislen)

			;# SORT ALPHABETICALLY WITHIN GROUPS OF EQUAL LENGTH

			set len [llength $linegps]
			set len_less_one [expr $len - 1]
			set n 0
			while {$n < $len_less_one} {
				set linegroup_n [lindex $linegps $n]
				set line [lindex $linegroup_n 0]
				set word_n [string tolower [lindex $line 0]]
				set len_n [string length $word_n]
				set m $n
				incr m
				while {$m < $len} {
					set linegroup_m [lindex $linegps $m]
					set line [lindex $linegroup_m 0]
					set word_m [string tolower [lindex $line 0]]
					set len_m [string length $word_m]
					if {$len_m == $len_n} {
						if {[string compare $word_m $word_n] < 0} {
							set linegps [lreplace $linegps $n $n $linegroup_m]
							set linegps [lreplace $linegps $m $m $linegroup_n]
							set linegroup_n $linegroup_m
							set word_n $word_m
						}
					} else {	;#	AT CHANGE IN WORDLEN,	SKIP TO NEXT GROUP TO COMPARE
						set n $m
						set linegroup_n $linegroup_m
						set word_n $word_m
						set len_n $len_m 
					}
					incr m
				}
				incr n
			}
			set gp($thislen) $linegps
		}
		incr thislen -1
	}
	set thislen $maxwlen
	set linegroups {}

	;#	CONCATENTATE GROUPS SO THEY ARE IN DECREASING LENGTH (AND WITH THIS, ALPHABETIC) ORDER

	while {$thislen >=  $minwlen} {
		if [info exists gp($thislen)] {
			set	linegroups [concat $linegroups $gp($thislen)]
		}
		incr thislen -1
	}
	if [catch {open $fnamout "w"} zit] {
		Inf "Cannot Open File '$fnamout' To Write Sorted Data"
		return
	}
	foreach linegroup $linegroups {
		foreach line $linegroup {
			puts $zit $line
		}
	}
	close $zit
	FileToWkspace $fnamout 0 0 0 0 1
	Inf "File $fnamout Is On The Workspace"
}

#------ Find numeric part of a filename, starting at the end

proc GetNumericEndPart {val} {
	set len [string length $val]
	set gg [expr $len - 1]
	while {$gg >= 0} {
		set char [string index $val $gg]
		if {![info exists endnum]} {
			if {[regexp {[0-9]} $char]} {
				set endnum $gg
			}
		} else {	
			if {![regexp {[0-9]} $char]} {
				set startnum [expr $gg + 1]
				break
			}
		}
		incr gg -1
	}
	if {![info exists startnum]} {
		set startnum 0
	}
	return [list $startnum $endnum]
}

#------ Find numeric part of a filename, starting at beginning

proc GetNumericStartPart {val} {
	set len [string length $val]
	set gg 0
	while {$gg < $len} {
		set char [string index $val $gg]
		if {![info exists startnum]} {
			if {[regexp {[0-9]} $char]} {
				set startnum $gg
			}
		} else {
			if {![regexp {[0-9]} $char]} {
				set endnum [expr $gg - 1]
				break
			}
		}
		incr gg
	}
	if {![info exists endnum]} {
		set endnum [expr $gg - 1]
	}
	return [list $startnum $endnum]
}

proc FilesRelated {typ} {
	global wl chlist chcnt ch pa wstk pa evv
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		return
	}
	foreach fnam $chlist {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			lappend fnams $fnam
		} else {
			lappend notfnams $fnam
		}
	}
	if {![info exists fnams]} {
		Inf "No Soundfiles On Chosen List"
		return
	}
	if {[info exists notfnams]} {
		Inf "Not All Files On Chosen List Are Soundfiles "
		return
	}
	switch -- $typ {
		"flt" { set thistag $evv(FILT_TAG); set thisext $evv(TEXT_EXT) }
		"seq" { set thistag $evv(SEQ_TAG) ; set thisext $evv(TEXT_EXT) }
		"pch" { set thistag $evv(PCH_TAG) ; set thisext [GetTextfileExtension brk] } 
	}
	foreach fnam $chlist {
		set fnam [file rootname $fnam]
		append fnam $thistag $thisext
		if {[file exists $fnam]} {
			lappend nulist $fnam
		}
	}
	if {![info exists nulist]} {
		Inf "No Related Files Of This Type Exist"
		return
	} elseif {[llength $nulist] != [llength $chlist]} {
		set msg "Not All These Soundfiles Have A Related File Of This Type : Continue Anyway ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	foreach fnam $nulist {
		if {[LstIndx $fnam $wl] < 0} {
			if {[FileToWkspace $fnam 0 0 0 0 0] <= 0} {
				continue
			}
		}
		lappend chlist $fnam		;#	add to end of list
		$ch insert end $fnam		;#	add to end of display
		incr chcnt
	}
}

proc ChTotDur {} {
	global chlist pa evv
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		return
	}
	set got 0
	set totdur 0
	foreach fnam $chlist {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set totdur [expr $totdur + $pa($fnam,$evv(DUR))]
			if {$got == 0} {
				set got 1	
			}
		} else {
			if {$got == 1} {
				set got 2
			}
		}
	}
	switch -- $got {
		0 {
			Inf "No Soundfiles Listed"
		} 
		2 {
			Inf "Not All Files Listed Are Soundfiles\n\nTotal Duration Of Soundfiles = $totdur secs."
		}
		1 {
			Inf "Total Duration = $totdur secs."
		}
	}
}

proc TellContract {} {
	set msg "CONTRACT EVENTS BUT RETAIN RHYTHM\n"
	append msg "\n"
	append msg "Time-shrinks events within sound, retaining original rhythm.\n"
	append msg "\n"
	append msg "SYNC SOUNDS TO MM BY EDITING\n"
	append msg "\n"
	append msg "Takes file indicating Peaks and Troughs (and a final peak)\n"
	append msg "in the sound, edits sound into elements this implies\n"
	append msg "then replays them at the Tempo given.\n"
	append msg "\n"
	append msg "Indicate Tempo by Metronome Mark (MM) or by beat duration.\n"
	append msg "\n"
	append msg "SYNC SOUNDS TO A RHYTHM BY EDITING\n"
	append msg "\n"
	append msg "Takes file indicating Troughs and Onsets (and a final trough)\n"
	append msg "in the sound, Onsets are either the attack peak of the event\n"
	append msg "or the stress onset of a syllable.\n"
	append msg "\n"
	append msg "This data can be saved to file\n"
	append msg "(which has a name related to the input soundfile)\n"
	append msg "and if such a file already exists you can load\n"
	append msg "that data or create a new troughs-onsets file.\n"
	append msg "\n"
	append msg "Sound is edited into the elements this implies.\n"
	append msg "If \"Syllable dovetailing\" selected, some allowance made\n"
	append msg "for the overlapping of syllables in the speech stream.\n"
	append msg "\n"
	append msg "Indicate output pulse/rhythm by Metronome Mark (MM),\n"
	append msg "or beat duration, or the name of a file\n"
	append msg "containing a list of times in a specific rhythm.\n"
	append msg "\n"
	Inf $msg
}

proc TellEmphasize {} {
	set msg "EMPHASIZE SPECIFIED EVENTS\n"
	append msg "\n"
	append msg "Uses envelope to create loudness peaks\n"
	append msg "at specified times, separated by silence.\n"
	append msg "\n"
	append msg "EMPHASIZE PEAK(S)\n"
	append msg "\n"
	append msg "Uses envelope to isolate loudness peak in sound\n"
	append msg "or in each of a list of sounds.\n"
	append msg "\n"
	append msg "MATCH LEVELS OF ISOLATED EVENTS\n"
	append msg "\n"
	append msg "In a soundfile containing a sequence of events\n"
	append msg "separated by (true) silence, equalises level of events.\n"
	append msg "\n"
	Inf $msg
}

#------ Last details of any last soundlist being used, and position in it.

proc LoadLastSoundlist {} {
	global lastgrabfil lastgrab evv
	set fnam [file join $evv(URES_DIR) lastgrab$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	gets $zit line
	close $zit
	set line [string trim $line]
	set line [split $line]
	if {[llength $line] != 2} {
		catch {file delete $fnam}
		return
	}
	set lastgrabfil [lindex $line 0]
	if {![file exists $lastgrabfil]} {
		catch {file delete $fnam}
		unset lastgrabfil
		return
	}
	set lastgrab [lindex $line 1]
	if {![regexp {^[0-9]+$} $lastgrab]} {
		catch {file delete $fnam}
		unset lastgrabfil
		unset lastgrab
	}		
}

proc PropsSoundRenameHelp {} {
	set msg "RENAME SOUNDS IN PROPERTIES FILE\n"
	append msg "\n"
	append msg "1) Use this if one or more sounds in an\n"
	append msg "      existing propsfile is renamed.\n"
	append msg "2) List ALL sounds named in the propsfile,\n"
	append msg "      in their correct order, in a textfile,\n"
	append msg "      using the new names where necessary.\n"
	append msg "3) Submit propsfile and textfile to this process.\n"
	append msg "\n"
	append msg "NB, you should do all this in the same session,\n"
	append msg "as once sounds are renamed, any propsfile\n"
	append msg "containing them becomes invalid as a propsfile.\n"
	append msg "\n"
	append msg "However the Loom will not complain.\n"
	append msg "\n"
	append msg "If the sounds are renamed\n"
	append msg "WITHOUT altering the names in the propsfile,\n"
	append msg "on starting a new session, the Loom complains.\n"
	Inf $msg
}

proc MaxLevelOnChlist {} {
	global chlist done_maxsamp maxsamp_line pa evv CDPmaxId
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		return
	}
	foreach fnam $chlist {
		set ftyp $pa($fnam,$evv(FTYP))
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Some Of The Chosen Files Are Not Soundfiles."
			return
		}
	}
	foreach fnam $chlist {
		if {![info exists pa($fnam,$evv(MAXREP))]} {
			catch {unset maxsamp_line}
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			if {[ProgMissing $cmd "'maxsamp2$evv(EXEC)' Is Not On Your System. Cannot Search For Maximum Samples In File."]} {
				return
			}
			catch {unset maxsamp_line}
			set done_maxsamp 0
			lappend cmd $fnam
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
				return
	   		} else {
	   			fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				Inf "Cannot Retrieve Maximum Sample Information For 'fnam'
				return
			}
			set pa($fnam,$evv(MAXSAMP)) [lindex $maxsamp_line 0]
			set pa($fnam,$evv(MAXLOC))  [lindex $maxsamp_line 1]
			set pa($fnam,$evv(MAXREP))  [lindex $maxsamp_line 2]
			lappend maxlist $pa($fnam,$evv(MAXSAMP))
			catch {unset maxsamp_line}
		} else {
			lappend maxlist $pa($fnam,$evv(MAXSAMP))
		}
	}
	if {![info exists maxlist]} {
		return
	}
	set maxval [lindex $maxlist 0]
	if {[llength $maxlist] > 1} {
		foreach val [lrange $maxlist 1 end] {
			if {$val > $maxval} {
				set maxval $val
			}
		}
	}
	Inf "Maximum Level = $maxval"
}

#---- Get maximum sampleval

proc Display_Maxsamp_Info_Wksp {} {
	global CDPmaxId done_maxsamp maxsamp_line

	if {[info exists CDPmaxId] && [eof $CDPmaxId]} {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match INFO:* $line] {
			return
		} elseif [string match WARNING:* $line] {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} elseif [string match ERROR:* $line] {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} elseif [string match KEEP:* $line] {
			set line [string range $line 6 end] 
			set maxsamp_line $line
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} else {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		}
	}
	update idletasks
}			

proc AddToSortlist {} {
	global wkspsortlist wl wstk
	set ilist [$wl curselection]
	if {([llength $ilist] == 1) && ($ilist < 0)} {
		Inf "Select Files On The Workspace"
		return
	}
	foreach i $ilist {
		lappend chfnams [$wl get $i]
	}
	if {[info exists wkspsortlist]} {
		foreach fnam $wkspsortlist {
			if {[LstIndx $fnam $wl] < 0} {
				unset wkspsortlist
				break
			}
			foreach chfnam $chfnams {
				if {[string match $fnam $chfnam]} {
					set msg "'$chfnam' Is Already On The Sortlist\n\nStart A New Sortlist ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						unset wkspsortlist
						break
					} else {
						return
					}
				}
			}
		}
	}
	foreach chfnam $chfnams {
		lappend wkspsortlist $chfnam
	}
}

proc ReorderAsSortlist {} {
	global wkspsortlist wl
	if {![info exists wkspsortlist]} {
		return
	}
	foreach fnam $wkspsortlist {
		if {[LstIndx $fnam $wl] < 0} {
			Inf "Some Of The Files In The Sortlist Are No Longer On The Workspace"
			unset wkspsortlist
			return
		}
	}
	foreach fnam [$wl get 0 end] {
		lappend wklist $fnam
	}
	foreach fnam $wkspsortlist {
		set k [lsearch $wklist $fnam]
		set wklist [lreplace $wklist $k $k]
	}
	set nulist [concat $wkspsortlist $wklist]
	$wl delete 0 end
	foreach fnam $nulist {
		$wl insert end $fnam
	}
}

proc DuplicateChlist {} {
	global ch chlist chcnt chpos pa evv
	if {![info exists chlist]} {
		return
	}
	foreach ff_nam $chlist {
		if {$pa($ff_nam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Only With Soundfiles"
			return
		}
		lappend nulist $ff_nam $ff_nam
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	set chlist $nulist
	foreach ff_nam $chlist {
		$ch insert end $ff_nam
		incr chcnt
	}
	ChlistDupls
	set chpos -1
	$ch yview moveto 0
	$ch xview moveto 0
}

proc DuplicateChlistN {rnd} {
	global pr_duplchn duplchn_cnt ch chlist chcnt chpos wstk pa evv
	global mix_perm
	if {![info exists chlist]} {
		return
	}
	set endch [expr [llength $chlist] - 1]
	set subendch [expr $endch - 1]
	set subsubendch [expr $subendch - 1]
	switch -- $rnd {
		1 {
			if {$endch < 2} {
				Inf "Random Perms Impossible With Less Than 3 Items"
				return
			}
		}
		2 {
			if {$endch < 4} {
				Inf "Random Perms Preserving First And Last Item, Impossible With Less Than 5 Items"
				return
			}
		}
	}
	set duplchn_cnt ""
	foreach ff_nam $chlist {
		if {$pa($ff_nam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Only With Soundfiles"
			return
		}
	}
	set f .duplchn
	if [Dlg_Create  $f "HOW MANY DUPLICATIONS" "set pr_duplchn 0" -borderwidth $evv(SBDR)] {
		button $f.ok -text "Duplicate" -command "set pr_duplchn 1" -highlightbackground [option get . background {}]
		label $f.ll -text "Total Number of copies "
		entry $f.e -textvariable duplchn_cnt -width 6
		button $f.qu -text "Quit" -command "set pr_duplchn 0" -highlightbackground [option get . background {}]
		pack $f.ok $f.ll $f.e -side left -padx 1
		pack $f.qu -side right -padx 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_duplchn 1}
		bind $f <Escape> {set pr_duplchn 0}
	}
	if {$rnd} {
		wm title $f "HOW MANY RANDOM DUPLICATIONS"
	} else {
		wm title $f "HOW MANY DUPLICATIONS"
	}
	set pr_duplchn 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition2 $f
	My_Grab 0 $f pr_duplchn $f.e
	while {!$finished} {
		tkwait variable pr_duplchn
		if {$pr_duplchn} {
			if {![IsNumeric $duplchn_cnt] || ($duplchn_cnt < 2)} {
				Inf "Invalid Duplication Count"
				continue
			}
			if {($rnd < 2) && ([expr $duplchn_cnt * [llength $chlist]] > $evv(MAXFILES))} {
				Inf "This Will Produce A List Of Almost 1000 Files, Which Cannot All Be Opened For A Single Operation."
				continue
			}
			if {($rnd == 2) && ([expr $duplchn_cnt * ([llength $chlist] - 2)] > [expr $evv(MAXFILES) - 2])} {
				Inf "This Will Produce A List Of Almost [expr $evv(MAXFILES) + 2] Files, Which Cannot All Be Opened For A Single Operation."
				continue
			}
			if {$duplchn_cnt > 100} {
				set msg "Are You Sure You Want $duplchn_cnt Duplications ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
			}
			catch {unset nulist}
			set n 0
			while {$n < $duplchn_cnt} {
				switch -- $rnd {
					0 {
						foreach ff_nam $chlist {
							lappend nulist $ff_nam
						}
					}
					1 {
						if {$n == 0} {
							set nulist $chlist
							set lastpermd $endch
						} else {
							RandomiseOrder [llength $chlist]
							while {$mix_perm(0) == $lastpermd} {
								RandomiseOrder [llength $chlist]
							}
							set lastpermd $mix_perm($endch)
							set k 0
							while {$k <= $endch} {
								lappend nulist [lindex $chlist $mix_perm($k)]
								incr k
							}
						}
					}
					2 {
						if {$n == 0} {
							set nulist [lrange $chlist 0 $subendch]
							set lastpermd $subsubendch	;#	as perms are done on list from 0, but items in list-to-be-permd start from 1
						} else {
							RandomiseOrder $subendch
							while {$mix_perm(0) == $lastpermd} {
								RandomiseOrder $subendch
							}
							set lastpermd $mix_perm($subsubendch)
							set k 0
							while {$k <= $subsubendch} {
								incr mix_perm($k)
								lappend nulist [lindex $chlist $mix_perm($k)]
								incr k
							}
						}
					}
				}
				incr n
			}
			if {$rnd == 2} {
				lappend nulist [lindex $chlist $endch]
			}
			DoChoiceBak
			ClearWkspaceSelectedFiles
			set chlist $nulist
			foreach ff_nam $chlist {
				$ch insert end $ff_nam
				incr chcnt
			}
			ChlistDupls
			set chpos -1
			$ch yview moveto 0
			$ch xview moveto 0
		}
		set finished 1
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc DoNuTimer {} {
	global pr_nutimer ocl origocl timerfnam wstk evv nessparam nes nessco

	catch {unset ocl}
	catch {unset origocl}
	catch {unset nes(got_valvetimes)}
	set f .timernu
	if [Dlg_Create $f "TIME TAP PAD" "set pr_nutimer 0" -borderwidth $evv(SBDR)] {
		frame $f.0 -borderwidth $evv(SBDR)
		frame $f.1 -borderwidth $evv(SBDR)
		frame $f.2 -borderwidth $evv(SBDR)
		frame $f.3 -borderwidth $evv(SBDR)
		button $f.0.quit  -text "Close" -command "catch {unset ocl}; set pr_nutimer 0" -highlightbackground [option get . background {}]
		pack $f.0.quit -side top
		
		if {[tk windowingsystem] eq "aqua"} {
		    button $f.1.times -text "TAP TIMES HERE" -command "Timer" -highlightbackground [option get . background {}]
		} else {
		    button $f.1.times -text "TAP\nTIMES\nHERE" -command "Timer" -width 8 -highlightbackground [option get . background {}]
		}
		pack $f.1.times -side top
		button $f.2.stop -text "KEEP TIMES"  -width 12 -command {set pr_nutimer [NuTimeCalc]} -highlightbackground [option get . background {}]
		button $f.2.res  -text "START AGAIN" -width 12 -command {catch {unset ocl}; catch {unset origocl}; set pr_nutimer 3} -highlightbackground [option get . background {}]
		pack $f.2.stop $f.2.res -side left -padx 2
		label $f.3.ll -text "Output Filename "
		entry $f.3.e -textvariable timerfnam -width 16
		pack $f.3.ll $f.3.e -side left
		pack $f.0 $f.1 $f.2 $f.3 -side top -pady 3 -fill x -expand true
		bind $f <Escape> {set pr_nutimer 0}
	}
	.timernu.1.times config -state normal -bg $evv(EMPH)
	.timernu.2.stop  config -state normal
	raise $f
	set pr_nutimer 0
	set finished 0
	set timerfnam ""
	if {[info exists nessparam(provisional)]} {
		$f.3.ll config -text "Quantise To MM "
	} else {
		$f.3.ll config -text "Output Filename "
	}
	My_Grab 0 $f pr_nutimer $f.1.times
	while {!$finished} {
		tkwait variable pr_nutimer
		switch -- $pr_nutimer {
			0 {
				break
			}
			1 {
				if {![info exists ocl]} {
					Inf "No Time Data Found"	
					.timernu.1.times config -state normal
					.timernu.2.stop  config -state normal
					continue
				}
				if {[info exists nessparam(provisional)]} {
					set quant 0
					if {[string length $timerfnam] > 0} {
						if {![IsNumeric $timerfnam] || ($timerfnam < 30) || ($timerfnam > 240)} {
							Inf "Invalid Metronome Mark (range 30 - 240)"
							.timernu.2.stop  config -state normal
							continue
						}
						set quant [expr (60.0/$timerfnam)/4.0]
					}
					set times_len [llength $ocl]
					if {$times_len < $nes(valve_eventcnt)} {
						Inf "Not Enough Time Values Entered ($times_len : Should Be $nes(valve_eventcnt))"
						catch {unset ocl}
						catch {unset origocl}
						.timernu.1.times config -state normal
						.timernu.2.stop  config -state normal
						continue
					} elseif {$times_len > $nes(valve_eventcnt)} {
						set msg "Too Many Time Values Entered : Drop The End Values And Proceed ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							catch {unset ocl}
							catch {unset origocl}
							.timernu.1.times config -state normal
							.timernu.2.stop  config -state normal
							continue
						} else {
							set ocl [lrange $ocl 0 [expr $nes(valve_eventcnt) - 1]]
						}
					}
					set OK 1
					catch {unset nu_ocl}
					foreach val $ocl {
						if {$val > $nessparam(t)} {
							Inf "Some Timings Exceed The Output Duration Set ($nessparam(t) secs.)"
							set OK 0
							break
						}
						lappend nu_ocl [DecPlaces $val 3]
					}
					set ocl $nu_ocl
					if {!$OK} {
						catch {unset ocl}
						catch {unset origocl}
						.timernu.1.times config -state normal
						.timernu.2.stop  config -state normal
						continue
					}
					if {$quant > 0} {
						catch {unset vals}
						foreach val $ocl {
							set val [expr int(round(double($val) / $quant))]
							set val [DecPlaces [expr double($val) * $quant] 3]
							lappend vals $val
						}
						set ocl $vals		
					}
					set setsize [expr $nes(valvecnt) + 1]
					set total_len [expr $setsize * $nes(valve_eventcnt)]
					set cnt 0
					set tcnt 0
					set vcnt 0
					catch {unset vals}
					while {$cnt < $total_len} {
						if {$cnt % $setsize == 0} {
							lappend vals [lindex $ocl $tcnt]
							incr tcnt
						} else {
							lappend vals [lindex $nessparam(provisional) $vcnt]
							incr vcnt
						}
						incr cnt
					}
					set nessparam($nes(provisional_param)) $vals
					set nes(got_valvetimes) 1
					break
				}
				if {[string length $timerfnam] <= 0} {
					Inf "No Outputfile Name Entered"
					.timernu.2.stop  config -state normal
					continue
				}
				if {![ValidCDPRootname $timerfnam]} {
					.timernu.2.stop  config -state normal
					continue
				}
				set outfname [string tolower $timerfnam]
				append outfname $evv(TEXT_EXT)
				if {[file exists $outfname]} {
					set msg "File '$outfname' Exists: Overwrite It ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				if [catch {open $outfname "w"} zit] {
					Inf "Cannot Open File '$outfname' To Write Data"
					continue
				}
				foreach item $ocl {
					puts $zit $item
				}
				close $zit
				FileToWkspace $outfname 0 0 0 0 1
				break
			}
			2 {
				continue
			}
			3 {
				.timernu.1.times config -state normal
				.timernu.2.stop  config -state normal
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc NuTimeCalc {} {
	global ocl origocl evv

	if {![info exists ocl] || ([llength $ocl] <= 0)} {
		Inf "No Times Entered"
		return 2
	}
	if {[info exists origocl]} {
		set ocl $origocl
		return 1
	}
	.timernu.1.times config -state disabled -bg [option get . background {}]
	.timernu.2.stop  config -state disabled
	set baseval [expr double([lindex $ocl 0]) / $evv(CLOCK_TICK)]
	set n 0
	foreach time $ocl {
		set time [expr (double($time) / $evv(CLOCK_TICK)) - $baseval]
		set ocl [lreplace $ocl $n $n $time]
		incr n
	}
	set ocl [lreplace $ocl 0 0 0.0]
	set origocl $ocl
	return 1
}

#--- Write files from Chosen List to Textfile

proc WriteChosenFiles {} {
	global chlist pr_wrch wrchfnam wstk evv
	if {![info exists chlist]} {
		return
	}
	set flist {}
	foreach fnam $chlist {
		if {[lsearch $flist $fnam] >= 0} {
			if {![info exists hasdupls]} {
				set msg "Duplicate Files: List All Duplicates ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set hasdupls 1
					lappend flist $fnam
				} else {
					set hasdupls 0
				}
			} elseif {$hasdupls} {
				lappend flist $fnam
			}
		} else {
			lappend flist $fnam
		}
	}
	if {[llength $flist] <= 0} {
		Inf "NO FILES TO SAVE"
		return
	}
	set f .wrch
	if [Dlg_Create $f "Store Chosen Files" "set pr_wrch 0" -borderwidth $evv(BBDR)] {
		set b  [frame $f.b -borderwidth $evv(SBDR)]
		button $b.ok -text "Save"    -width 7 -command "set pr_wrch 1" -highlightbackground [option get . background {}]
		button $b.q  -text "Abandon" -width 7 -command "set pr_wrch 0" -highlightbackground [option get . background {}]
		pack $b.ok -side left
		pack $b.q -side right
		set e  [frame $f.e -borderwidth $evv(SBDR)]
 		label $e.l -text "Textfile Name "
		entry $e.e -width 20 -textvariable wrchfnam -width 16
		pack $e.l $e.e -side left -padx 1
		pack $f.b $f.e -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_wrch 1}
		bind $f <Escape> {set pr_wrch 0}
	}
	set wrchfnam ""
	set pr_wrch 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_wrch $f.e.e
	while {!$finished} {
		tkwait variable pr_wrch
		if {$pr_wrch} {
			if {[string length $wrchfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			set outfnam [string tolower $wrchfnam]
			if {![ValidCDPRootname $outfnam]} {
				continue
			}
			append outfnam [GetTextfileExtension sndlist]
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write Data"
				continue
			}
			foreach fnam $flist {
				puts $zit $fnam
			}
			close $zit
			FileToWkspace $outfnam 0 0 0 0 1
			break
		} else {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc EstablishMusicTestbedMenu {mfz} {
	global sl_real released development_version musictestbed_established evv

	$mfz add command -label "DO IT AGAIN" -command {}  -foreground black
	$mfz add separator
	$mfz add command -label "                                                                                      " -command {} -foreground black
	$mfz add separator
	$mfz add command -label "MUSIC FACILITIES" -command {}  -foreground black
	$mfz add separator
	if {!$sl_real} {
		$mfz add command -label "Background Listings"  -command TellBlists -foreground black
		$mfz add command -label "Interpolation Workshop" -command {TellInterp} -foreground black
		$mfz add command -label "Name Games" -command {TellNameGames} -foreground black
		$mfz add command -label "Partition Soundfiles" -command {TellPartition} -foreground black
		$mfz add command -label "Pitch Marks" -command {TellPitchmarks} -foreground black
		$mfz add command -label "Properties Files"  -command {TellPropFiles} -foreground black
		$mfz add command -label "Sketch Score" -command {TellSketchScore} -foreground black
	} else {

		$mfz add cascade -label "Background Listings"  -menu $mfz.subb -foreground black
		if {[info exists released(cdpconv)]} {
			$mfz add command -label  "Byte Reversal" -command {ByteReversal; SetTestbed bytetyb} -foreground black
			$mfz add command -label "~ More Information ~" -command {HelpOnByteReversal} -foreground $evv(SPECIAL)
			$mfz add separator
		}
		if {[info exists released(specnu)]} {
			$mfz add cascade -label "Cleaning Kit" -command {CleaningKit; SetTestbed cleank} -foreground black
			$mfz add command -label "                          More Information" -command {TellClean} -foreground $evv(SPECIAL)
		}
		$mfz add command -label  "Compare Several Soundfiles" -command {CompareAll; SetTestbed compareall}
		$mfz add separator
		$mfz add cascade -label "Double Processes" -menu $mfz.poly
		$mfz add separator
		set mfzxx [menu $mfz.poly -tearoff 0]
		$mfzxx add command -label  "Degrade Sound" -command {Degrade; SetTestbed degrade}
		$mfzxx add separator
		$mfzxx add command -label  "Recursive Filtering" -command {Polyfilter; SetTestbed polyfilter}

		$mfz add cascade -label "Editing Operations" -menu $mfz.edit -foreground black
		$mfz add separator
		set mfzedit [menu $mfz.edit -tearoff 0]
		$mfzedit add command -label "Rearrange A Soundfile" -command {Rearrange; SetTestbed rearrange} -foreground black
		$mfzedit add command -label "Random Perm Chunks Of Files" -command {PermChunks; SetTestbed permchunks} -foreground black
		$mfzedit add command -label "Create Related Zigzags" -command {ReZig; SetTestbed rezig} -foreground black
		$mfzedit add command -label "Internally Contract" -command {Contract; SetTestbed contract} -foreground black
		$mfzedit add command -label "Slice To Overlapping Segments" -command {OverlapSlice; SetTestbed overlapslice}
		$mfzedit add command -label "Join Files In Rand-Permed Sequence" -command {ChantExtend; SetTestbed chantextend}
		$mfzedit add command -label "Cyclically Concatenate" -command {CycConcat; SetTestbed cycconcat}
		$mfzedit add command -label "------------ More Information ------------" -command {CycConcatHelp} -foreground $evv(SPECIAL)
		if {[info exists released(pairex)]} {
			$mfzedit add command -label "Extract Channel Pair" -command {ChanPairExtract; SetTestbed chanpairextract}
		}
		$mfzedit add command -label "Slice For Processing In Situ" -command {SliceInSitu; SetTestbed sliceinsitu}
		$mfzedit add command -label "------------ More Information ------------" -command {HelpSliceInSitu} -foreground $evv(SPECIAL)
		$mfzedit add command -label "Create Dropout In Sound" -command {DropOutEnv; SetTestbed dropoutenv}
		$mfzedit add command -label "Extend By Rand-Permuting Slices Within" -command {ExtendFileWithOnsets; SetTestbed efwo}
		$mfzedit add command -label "Remove (Cut Out) Loud Peaks In Sound" -command {CutPeaks; SetTestbed cutpeaks}
		$mfz add cascade -label "Envelopes & Loudness" -menu $mfz.env -foreground black
		set mfzee [menu $mfz.env -tearoff 0]
		$mfzee add command -label "Smooth Sound Loudness" -command {TimeAveragedEnvelope; SetTestbed taenv} -foreground black
		$mfzee add command -label "List (Normalised) Peaks At Timemarks"	-command {LevelsAtTimeMarks; SetTestbed synlev} -foreground black
		$mfzee add command -label "Fade In Beyond Start"	-command {FadeIn; SetTestbed fadein} -foreground black
		$mfzee add command -label "Max & Min Level Amongst All Sounds"	-command {MaxlevelOfAllFilesSelectedOrInSelectedMixfile; SetTestbed maxsnd}
		$mfzee add command -label "Loudest Channel For Each Snd In List"	-command {ListLoudestChannels; SetTestbed listloudest}
		$mfzee add command -label "Create Mix With Snd Peaks Staggered"	-command {StaggerPeaks; SetTestbed stagger}
		$mfzee add command -label "List Sudden Onsets In Sound"	-command {ExtractSuddenOnsets; SetTestbed xonsets}
		$mfzee add command -label "Apply Limiter"	-command {Limiter; SetTestbed limiter}
		if {[info exists released(features)]} {
			$mfz add command -label "Feature Extraction" -command {Features; SetTestbed features} -foreground black
		}
		$mfz add cascade -label "Filter Options" -menu $mfz.ffff
		set mfzfff [menu $mfz.ffff -tearoff 0]
		$mfzfff add command -label "Convert Pitchfollow To HF" -command {Convert_PitchFollowFilt_to_HFFilt 0; SetTestbed followtoHF0}
		$mfzfff add command -label "Convert Pfollow To HF in Key" -command {Convert_PitchFollowFilt_to_HFFilt 1; SetTestbed followtoHF1}
		$mfzfff add command -label "Play Fixed-Harmony MIDI Varibank Data" -command {PlayVbankChord; SetTestbed playvbankchord}
		if {[info exists released(shrink)]} {
			$mfzfff add command -label "Filter A Sequence" -command {GroupFilter; SetTestbed gpfilter}
		}
		$mfzfff add command -label "Recursively Filter" -command {DoubleFilter; SetTestbed dblfilter}
		if {[info exists released(fofex)]} {
			$mfz add cascade -label "Fof Reconstruction" -menu $mfz.subx -foreground black
			set mfzx [menu $mfz.subx -tearoff 0]
			$mfzx add command -label "FOFs Extract For Reconstruction" -command {FofReco 1; SetTestbed fofex} -foreground black
			$mfzx add command -label "                          More Information" -command {FofexHelp 1} -foreground $evv(SPECIAL)
			$mfzx add command -label "Single FOF (Group) Extract" -command {FofReco 2; SetTestbed fofex1} -foreground black
			$mfzx add command -label "FOF Reconstruction" -command {FofReco 0; SetTestbed fofreco} -foreground black
			$mfzx add command -label "                          More Information" -command {FofexHelp 2} -foreground $evv(SPECIAL)
		}
		$mfz add cascade -label "Harmony Workshop" -menu $mfz.menu -foreground black
		$mfz add command -label "Interpolation Workshop" -command {Interpolator 0; SetTestbed interp} -foreground black
#		$mfz add cascade -label "Name Games"   -menu $mfz.subf -foreground black
		if {[info exists released(mchanpan)]} {
			$mfz add cascade -label "Multichannel & Mixes" -menu $mfz.subm
			set mfzmch [menu $mfz.subm -tearoff 0]
			$mfzmch add command -label "Merge Mixfiles" -command {MixMerge; SetTestbed mixmerge}
			$mfzmch add command -label "MULTICHANNEL PROCESSES" -command {} -background $evv(HELP)
			$mfzmch add cascade -label "Multichannel Processes" -menu $mfzmch.subg
			set mfzmchg [menu $mfzmch.subg -tearoff 0]
			$mfzmchg add command -label "Reformat To 8-Channel Ring" -command {ReFormatMchan; SetTestbed reformatmchan}
			$mfzmchg add command -label "Pan Process Round Multichan File" -command {PanProcess 1}
			$mfzmchg add command -label "Stack Transposed Multichan Copies" -command {MultiStack; SetTestbed multistack}
			$mfzmchg add command -label "Place Mono/Stereo File In Multichan Space" -command {MonoInject; SetTestbed monoinject}
			$mfzmchg add command -label "Files Side-By-Side In Multichan Mix" -command {SideBySideMix; SetTestbed sidebyside}
			$mfzmchg add command -label "Stereo Interleave Rotate In Multichan Mix" -command {StirMix; SetTestbed stirmix}
			$mfzmchg add command -label "Reverb On Multichan Sound Tail" -command {MresTail; SetTestbed mrestail}
			$mfzmchg add command -label "Multilayered Rotations In 8-Chan" -command {MultiRotate; SetTestbed multirotate}
			$mfzmchg add command -label "Pan 8-Chans Gradually Into 1" -command {EightToOne; SetTestbed eighttoone}
			$mfzmchg add command -label "Rearrange Channels" -command {EightToEight; SetTestbed eighttoeight}

			$mfzmch add command -label "OPERATIONS ON INDIVIDUAL CHANNELS" -command {} -background $evv(HELP)
			$mfzmch add cascade -label "Operations On Individual Channels" -menu $mfzmch.subq
			set mfzmchq [menu $mfzmch.subq -tearoff 0]
			$mfzmchq add command -label "Play Single Channels Of Multichan File" -command {PlayChannel 0; SetTestbed playchan}
			$mfzmchq add command -label "Find Or Remove Empty Channels" -command {MchanActive; SetTestbed mchactive}
			$mfzmchq add command -label "Find Any Matching Channels" -command {FindMatchingChannels; SetTestbed findmatchans}
			if {[info exists released(onset)]} {
				$mfzmchq add command -label "List Onset Sequence Of Channels" -command {OnsetSequence; SetTestbed onsetsequence}
			}
			$mfzmchq add command -label "Multichannel Engineering" -command {MchanEngineer; SetTestbed mchengineer}
			$mfzmchq add command -label "------------ More Information ------------" -command {TellEngineer} -foreground $evv(SPECIAL)

			$mfzmch add command -label "STEREO AND MULTICHANNEL" -command {} -background $evv(HELP)
			$mfzmch add cascade -label "Stereo And Multichannel" -command {}  -menu $mfzmch.subw
			set mfzmchw [menu $mfzmch.subw -tearoff 0]
			$mfzmchw add command -label "Extract Stereos From Multichannel" -command {MchXToStereo; SetTestbed mchxstereo}
			$mfzmchw add command -label "Inject Stereos Into Multichannel" -command {MchFromStereo; SetTestbed stereoinmch}
			$mfzmchw add command -label "Randorient Stereopans In Multichan" -command {MultiChanRandStereoPan; SetTestbed stereorand}
			$mfzmchw add command -label "Place Stereo Snd In Multichan Space" -command {MultiChanStereoPan; SetTestbed stereomulti}
			$mfzmchw add command -label "Stereo Wraparound In 3 Chan Surround" -command {StereoWrap; SetTestbed stereowrap}
			$mfzmchw add command -label "Stereo Reveal Mono->Stereo->Mono" -command {StereoReveal; SetTestbed stereoreveal}

			$mfzmch add command -label "CONVERSION TO MULTICHANNEL" -command {} -background $evv(HELP)
			$mfzmch add cascade -label "Conversion To Multichannel" -command {}  -menu $mfzmch.subx
			set mfzmchx [menu $mfzmch.subx -tearoff 0]
			if {[info exists released(mton)]} {
				$mfzmchx add command -label "Convert Mono Soundfile To Multichannel" -command {MonoToMch; SetTestbed monotomch}
			}
			$mfzmchx add command -label "Convert Stereo Mixfile To Multichannel" -command {StereoToMchMix; SetTestbed stereotomch}
			$mfzmchx add command -label "Inject K Mono Sndfiles In N-Channel Ring" -command {KMonoToNMulti; SetTestbed kmonotonmulti}
			$mfzmchx add command -label "Transfer Times From 1st Mixfile To 2nd" -command {MultiTransfer; SetTestbed multitransfer}

			$mfzmch add command -label "CONVERSION FROM MULTICHANNEL" -command {} -background $evv(HELP)
			$mfzmch add cascade -label "Conversion From Multichannel" -command {}   -menu $mfzmch.suby
			$mfzmch add command -label "------------ More Information ------------" -command {TellConvFromMchan} -foreground $evv(SPECIAL)
			set mfzmchy [menu $mfzmch.suby -tearoff 0]
			$mfzmchy add command -label "Multichan Sound Reduce To Stereo" -command {MchToStereo; SetTestbed mchtostereo}
			$mfzmchy add command -label "Multichan Sound Select To Stereo" -command {MchSelectStereo; SetTestbed mchtostereo2}
			$mfzmchy add command -label "Multichan Mix To Standard Mixfile" -command {MultiToStereoMix; SetTestbed mch2tomix}
			$mfzmchy add command -label "Transfer Times From 1st Mixfile To 2nd" -command {MultiTransfer; SetTestbed multitransfer}

			$mfzmch add command -label "WARP MULTICHANNEL SPACE" -command {} -background $evv(HELP)
			$mfzmch add command -label "Shrink/Expand Space Of Multichan" -command {MchShrink; SetTestbed mchshrink}
			$mfzmch add command -label "SPECIAL MIXES" -command {} -background $evv(HELP)
			$mfzmch add command -label "Create Mix With Snd Peaks Staggered" -command {StaggerPeaks; SetTestbed stagger}
			$mfzmch add command -label "Create Mix From Sndfiles And Onset-List" -command {TimesFilesToMix; SetTestbed timsfilsmix}
			$mfzmch add command -label "Replace All Sounds In Mixfile"  -command {ReplaceSndsInMixfile; SetTestbed replaceallmix}
			$mfzmch add command -label "Stereo To \"Stereo\" On Left Or Right"  -command {StereoOnLeft; SetTestbed stereoonleft}
			$mfzmch add command -label "------------ More Information ------------" -command {TellStereoOnLeft} -foreground $evv(SPECIAL)
		}
		$mfz add cascade -label "Partition Soundfiles" -menu $mfz.subg -foreground black
		$mfz add cascade -label "Patterning Operations" -menu $mfz.subpp -foreground black
		if {[info exists released(ness)]} {
			$mfz add cascade -label "Physical Modelling" -menu $mfz.synpm -foreground black
			$mfz add command -label "                          More Information" -command {PhysicalModelling} -foreground $evv(SPECIAL)
			$mfz add separator
			set mfzsypm [menu $mfz.synpm -tearoff 0]
			$mfzsypm add command -label "MANAGE PHYSICAL MODELLING DATA" -command {} -background $evv(HELP) -foreground black
			$mfzsypm add command -label "List Physical Modelling Scores" -command {ShowNessData 1; SetTestbed nessscores} -foreground black
			$mfzsypm add command -label "List Physical Modelling Instruments" -command {ShowNessData 0; SetTestbed nessinstrs} -foreground black
			$mfzsypm add command -label "Refresh Physical Modelling Data" -command {RefreshNessData; SetTestbed nessrefresh} -foreground black
			$mfzsypm add command -label "BRASS INSTRUMENTS" -command {} -background $evv(HELP) -foreground black
			$mfzsypm add command -label "Profile Of Instrument : View/Edit" -command {NessProfile 1 0; SetTestbed nessprofile} -foreground black
			$mfzsypm add command -label "Profile Of Instrument : Create" -command {NessProfile 0 0; SetTestbed nessprofile0} -foreground black
			$mfzsypm add command -label "Score For Instrument : View/Edit/Play" -command {NessScore 1 0; SetTestbed nessscore} -foreground black
			$mfzsypm add command -label "Score For Instrument : Create/Play" -command {NessScore 0 0; SetTestbed nessscore0} -foreground black

		}
		$mfz add cascade -label "Pitch Operations" -menu $mfz.pich -foreground black
		$mfz add separator
		set ppich [menu $mfz.pich -tearoff 0]
		$ppich add command -label "                          More Information" -command {WholeHelp}  -background $evv(HELP) -foreground $evv(SPECIAL)
		$ppich add command -label "Create Set Of Semitone-Transposed Copies" -command {TransposSet; SetTestbed transposset} -foreground black
		if {[info exists released(spectune)]} {
			$ppich add command -label "Tune Whole-Sounds To Given Tuning Set" -command {TuneSet; SetTestbed tuneset} -foreground black
			$ppich add command -label "                          More Information" -command {TunerHelp}  -foreground $evv(SPECIAL)
			$ppich add command -label "Adjust Name Of File Having Pitch-in-Name" -command {PitchNamesAdjust; SetTestbed tuneadj} -foreground black
		}
		if {[info exists released(specanal)]} {
			set specanal_version [GetVersionNumber $evv(SPECANAL)]
			set specanal_version [split $specanal_version "."]
			if {([lindex $specanal_version 0] >= 6) && ([lindex $specanal_version 1] >= 2)} {
				$ppich add command -label "Extract/Apply Average Or Time-Varying Harmonic Field" -command {ExtractApplyHF; SetTestbed extracthf}
				$ppich add command -label "------------ More Information ------------" -command {ExtractHFHelp 0}  -foreground $evv(SPECIAL)
			}
		}
		if {[info exists released(spectune)]} {
			$ppich add command -label "Adjust Name Of File Having Pitch-In-Name" -command {PitchNamesAdjust; SetTestbed tuneadj}
		}
		$ppich add command -label "Chords From Non-Vocal Sample" -command {TransposChord; SetTestbed transposchord}
		$ppich add cascade -label "Pitch Data Operations" -menu $ppich.subq -foreground black
		$ppich add command -label "                          More Information" -command {PDHelp}  -background $evv(HELP) -foreground $evv(SPECIAL)
		$ppich add cascade -label "Pitch Data (Tempered) Operations" -menu $ppich.subqt -foreground black
		$ppich add cascade -label "Pitch Data (Varibank Filter) Operations" -menu $ppich.subqv -foreground black
		$ppich add cascade -label "Pitch Marks (Harmonic Field)" -menu $ppich.sube -foreground black
		$ppich add cascade -label "Pitch Sequence Markers (Melodic Line)" -menu $ppich.subh -foreground black
		if {[info exists released(newmix)]} {
			$mfz add cascade -label "Play Options" -menu $mfz.play
			set pplay [menu $mfz.play -tearoff 0]
			$pplay add command -label "PLAY IN GROUPS OF N" -command {} -background $evv(HELP)
			$pplay add command -label "Play Groups Sequentially" -command {PlayN 0; SetTestbed playgroups0}
			$pplay add command -label "Play Groups Multichannel" -command {PlayN 1; SetTestbed playgroups1}
			$pplay add command -label "Play Part Of Multichan Snd" -command {PlayPM; SetTestbed playpm}
			$pplay add command -label "Play Single Channel Of Snd" -command {PlayCh; SetTestbed playch}
			$pplay add command -label "Play Stereo In Wide Multichan" -command {PlayChWide; SetTestbed playchwide}
		}
		$mfz add cascade -label "Properties Files" -menu $mfz.suba -foreground black
		$mfz add cascade -label "Reverb Operations" -menu $mfz.subrev -foreground black
		$mfz add cascade -label "Rhythm and Time Operations"  -menu $mfz.subr -foreground black
		$mfz add cascade -label "Sketch Score"  -menu $mfz.subc -foreground black
		$mfz add cascade -label "Sound Lists"  -menu $mfz.subslist -foreground black
		set subslist [menu $mfz.subslist -tearoff 0]
		$subslist add command -label "Compare Soundlists" -command {SoundlistsCompare; SetTestbed slistcomp} -foreground black
		$subslist add command -label "Sort By Directory"  -command {SoundlistSort; SetTestbed slistsort} -foreground black
		$subslist add command -label "Mix Cyclically From Mono Soundlists"  -command {SoundlistsMix; SetTestbed slistmix} -foreground black
		$mfz add cascade -label "Space Design" -menu $mfz.subspace -foreground black
		set mfzspac [menu $mfz.subspace -tearoff 0]
		if {[info exists released(spacedesign)]} {
			$mfzspac add command -label "Space Design"   -command {SpaceDesign; SetTestbed spacedesign} -foreground black
		}
		$mfzspac add command -label "Spatialise Mono Mix" -command {SpatialiseMonoMix; SetTestbed spacmonmix} -foreground black
		$mfzspac add command -label "Doppler Pan" -command {DopplerPan; SetTestbed dopplerpan}
		$mfzspac add command -label "Pan Stereo Round Multichannel Space" -command {MchPanStereo; SetTestbed stereopanmch} -foreground black
		$mfzspac add command -label "Rotate Stereo+ Round Multichannel Space" -command {MchRotateMchan; SetTestbed stereorotmch} -foreground black
		$mfzspac add separator
		if {[info exists released(mchanpan)] && [info exists released(newmix)]} {
			$mfzspac add command -label "Random Rotations Of Several Mono Srcs" -command {MchRandRotate; SetTestbed mchrandrotate}
		}
		$mfz add separator
		if {[info exists released(specav)] && [info exists released(specanal)]} {
			$mfz add command -label "Spectral Display Or Movies ($)" -command {SpecAverageMaster; SetTestbed specav}
			$mfz add command -label "------------ More Information ------------" -command {SpecAvHelp} -foreground $evv(SPECIAL)
			$mfz add separator
		}
		$mfz add cascade -label "Synth Sets Operations" -menu $mfz.syn
		$mfz add command -label "                          More Information" -command {SynthSetsHelp} -foreground $evv(SPECIAL)
		set mfzsy [menu $mfz.syn -tearoff 0]
		$mfzsy add command -label "GENERATE SOUND SETS" -command {} -background $evv(HELP)
		$mfzsy add command -label "                          More Information" -command {SynthSetsHelp1} -background $evv(HELP) -foreground $evv(SPECIAL)
		$mfzsy add separator -background $evv(HELP)
		$mfzsy add command -label "Generate Spectra By Filtering" -command {GenerateSpectraByFiltering; SetTestbed genspecfilt} -foreground black
		$mfzsy add command -label "Modify Sounds By Filtering" -command {ModifySpectraByFilterAndInterp; SetTestbed modspecfilt} -foreground black
		if {[info exists released(prefix)]} {
			$mfzsy add command -label "Generate Sounds By Interpolation" -command {GenerateSpectraByInterpolation; SetTestbed genspecinterp} -foreground black
			$mfzsy add separator
		}
		$mfzsy add command -label "Modify Sounds By Stacking" -command {GenerateSpectraByStacking; SetTestbed genspecstak} -foreground black
		$mfzsy add command -label "Modify Sounds By Reverb" -command {GenerateSpectraByReverb; SetTestbed genspecrev} -foreground black
		$mfzsy add command -label "Modify Sounds By Distortion" -command {GenerateSpectraByDistort; SetTestbed genspecdist} -foreground black
		if {[info exists released(tremolo)]} {
			$mfzsy add command -label "Modify Snds By Trem, Vib Or Accel" -command {GenerateSpectraByTremolo; SetTestbed genspectrem} -foreground black
		}
		$mfzsy add command -label "Modify Spectrum By Harmonic Shift" -command {GenerateSpectraByHShift; SetTestbed genspechsh} -foreground black
		$mfzsy add command -label "Modify Pitch Of Sound" -command {GenerateSpectraByPshift; SetTestbed genspecpsh} -foreground black
		$mfzsy add command -label "Modify Pitch By Octave" -command {GenerateSpectraByOct; SetTestbed genspecoct} -foreground black
		$mfzsy add command -label "Modify Sound By Timestretch" -command {GenerateSpectraByTstretch; SetTestbed genspectstr} -foreground black
		$mfzsy add command -label "Modify Sound By Timeshrink" -command {GenerateSpectraByTshrink; SetTestbed genspectshr} -foreground black
		$mfzsy add command -label "Modify Sound By Endtrim" -command {GenerateSpectraByETrim; SetTestbed genspectrim} -foreground black
		$mfzsy add command -label "Modify Sound By Trim" -command {GenerateSpectraByTrim; SetTestbed genspectrii} -foreground black
		$mfzsy add command -label "Mix Orchestras" -command {GenerateSpectraByMixOrc 0; SetTestbed genspecmixoct}
		$mfzsy add command -label "Merge Mono Orchestras To Stereo" -command {GenerateSpectraByMixOrc 1; SetTestbed genspecmixoctst} -foreground black
		$mfzsy add command -label "PROGRESSIVELY MODIFY SOUND SETS" -command {} -background $evv(HELP)
		$mfzsy add command -label "                          More Information" -command {SynthSetsHelp2} -background $evv(HELP) -foreground $evv(SPECIAL)
		$mfzsy add command -label "Modify Pitches Of Soundset" -command {GenerateSpectraByPshiftSet; SetTestbed genspecpshset} -foreground black
		if {[info exists released(tremolo)]} {
			$mfzsy add command -label "Modify Set By Trem, Vib Or Accel" -command {GenerateSpectraByTremoloSet; SetTestbed genspectrems} -foreground black
		}
		$mfzsy add command -label "Stretch Durations Of Soundset" -command {GenerateSpectraByTstretchSet; SetTestbed genspectstrs} -foreground black
		$mfzsy add command -label "Shrink Durations Of Soundset" -command {GenerateSpectraByTshrinkSet; SetTestbed genspectshrs} -foreground black
		$mfzsy add command -label "Trim Ends Of Soundset" -command {GenerateSpectraByETrimSet; SetTestbed genspectris} -foreground black
		$mfzsy add command -label "IDENTICALLY MODIFY SOUND SETS" -command {} -background $evv(HELP)
		$mfzsy add command -label "                          More Information" -command {SynthSetsHelp3} -background $evv(HELP) -foreground $evv(SPECIAL)
		$mfzsy add command -label "Cut And Normalise" -command {GenerateSpectraByETrimNorm; SetTestbed genspectrin} -foreground black

		$mfz add cascade -label "Text Operations" -menu $mfz.text -foreground black
		set mfztxt [menu $mfz.text -tearoff 0]
		$mfztxt add command -label "TEXT OPERATIONS" -command {}   -foreground black
		$mfztxt add separator
		$mfztxt add command -label "Length + Alpha Sort On 1st Words Of	Lines" -command {DataSort 0; SetTestbed datasort} -foreground black
		$mfztxt add command -label "                          More Information" -command {DataSort 1} -foreground $evv(SPECIAL)
		$mfztxt add command -label "Reversed-Text Word Sort" -command {ReverseTextSort; SetTestbed txtbkwdsort} -foreground black
		$mfztxt add command -label "Rhyme Sort On List Of Words" -command {RhymeSort; SetTestbed rhymesort} -foreground black
		$mfztxt add command -label "Generate Phrases From Wordlists" -command {GeneratePhrases; SetTestbed generatephrases}
		$mfztxt add command -label "------------ More Information ------------" -command {GenPhraseHelp} -foreground $evv(SPECIAL)
		$mfztxt add command -label "Group Phrases From Two Or More Textfiles" -command {PairPhrases; SetTestbed pairphrases}
		$mfztxt add command -label "Swap Paired Phrases" -command {PairPhraseSwap; SetTestbed pairphrswap}
		$mfztxt add command -label "Link Paired Phrases" -command {PhraseLinkage; SetTestbed phraselink}
		$mfztxt add command -label "------------ More Information ------------" -command {Help_PhrasePairs} -foreground $evv(SPECIAL)
		$mfztxt add command -label "Alphabetic Sort & Remove Duplicates" -command {PreSortTexts; SetTestbed presort}
		$mfztxt add command -label "Conflate (& Possibly Re-Sort) Textlines In Files" -command {ConflateTexts; SetTestbed conflatetexts}
		$mfztxt add command -label "Eliminate Texts Common To Different Files" -command {MutualEliminationOfTexts; SetTestbed mutualeliminate}
		if {[info exists released(see_text_characters)]} {
			$mfztxt add command -label "Check Bad Chars In Non-Grabbed Textfile" -command {CheckForInvalidCharacters; SetTestbed invalidchars}
			$mfztxt add separator
		}
		$mfztxt add command -label "Find Repeated Words : Partition Texts To Files" -command {SameFirstLastWord; SetTestbed firstlast}
		$mfztxt add command -label "Mark & Extract Items From Texts List" -command {SelectStarredTexts; SetTestbed selectstarred}
		$mfztxt add command -label "Categorise & Extract Items From Texts List" -command {SelectCategorisedTexts; SetTestbed selectcats}
		$mfztxt add command -label "Specify Order & Reorder Texts In A Texts List" -command {OrderTexts 0; SetTestbed ordertexts}
		$mfztxt add command -label "Reorder Pre-Numbered Texts" -command {OrderTexts 1; SetTestbed reordertexts}
		$mfztxt add command -label "Assemble Text-Lines To A Continuous Text" -command {AssembleTexts; SetTestbed assembletexts}
		$mfztxt add command -label "Count Syllables : Assess Spoken Duratiion" -command {SyllableCount; SetTestbed syllablecount}

		if {[info exists released(mchanpan)]} {
			$mfz add cascade -label "Thumbnails (Mono Versions Of Multichan)" -menu $mfz.thumb -foreground black
			set mfzthm [menu $mfz.thumb -tearoff 0]
			$mfzthm add command -label "Make Mono Thumbnail Of Multichan Sound" -command "MakeThumbnail 0; SetTestbed thumbmake" -foreground black
			$mfzthm add command -label "Destroy Thumbnail Of Selected Multichan Sound(s)" -command "ThumbKill 0; SetTestbed thumbkill" -foreground black
		}
		$mfz add command -label "Timeline"   -command {EstablishTimeline; ; SetTestbed timeline} -foreground black
		if {[info exists released(tremolo)]} {
			$mfz add command -label "Varibox (Cmd-v)" -command {Varibox; SetTestbed varibox}
		}
		if {[info exists released(specnu)]} {
			$mfz add command -label "Varispec"   -command {Varispec; SetTestbed varispec}
		}

		;#	HARMONY

		set mfh [menu $mfz.menu -tearoff 0]
		$mfh add command -label "Harmony Workshop" -command {TellHarmony}  -foreground black
		$mfh add command -label "                          More Information" -command {TellHarmony} -foreground $evv(SPECIAL)
		$mfh add command -label  "Tonal Harmony Workshop" -command {PitchManips 0; SetTestbed harmony} -foreground black
		$mfh add command -label  "Free Harmony Workshop" -command {PreNTHarmony; SetTestbed nharmony} -foreground black

		;#	PITCH DATA

		set mfzq [menu $ppich.subq -tearoff 0]
		$mfzq add command -label "PITCH EXTRACTION & SMOOTHING" -command {}  -foreground black
		$mfzq add command -label "Bulk Pitch Extraction (As Text)" -command {BulkPitchExtract; SetTestbed bulkpitch} -foreground black
		if {[info exists released(ptobrk)] && [info exists released(brktopi)]} {
			$mfzq add command -label "Smooth : Correct Text Pitchdata" -command {CorrectPitch; SetTestbed correctpitch} -foreground black
			$mfzq add command -label "                          More Information" -command {PitchCorrHelp} -foreground $evv(SPECIAL)
		}
		$mfzq add command -label "PITCH DATA CONVERSION" -command {} -background $evv(HELP) -foreground black
		$mfzq add command -label "Trim Range Of Midi Pitchdata" -command {MidiTrim; SetTestbed miditrim} -foreground black
		$mfzq add command -label "MIDI Sequence (C60) --> Frq Brkpnt"		 -command {MidiBrkSeq 1 1 0; SetTestbed midibrkseq110} -foreground black
		$mfzq add command -label "MIDI Sequence (C60) --> Varibank Filter Data" -command {MidiBrkSeq 1 0 1; SetTestbed midibrkseq101} -foreground black
		$mfzq add command -label "Transpose MIDI Sequence To Given Pitch"	 -command {TransposeC60SequenceFileToGivenPitch; SetTestbed seqshift} -foreground black
		if {[info exists released(convert_to_midi)]} {
			$mfzq add command -label "Frq Brkpnt+Peaks --> Standard Midi"		 -command {FrqBrkToStandardMidi 0; SetTestbed mstandard0} -foreground black
			$mfzq add command -label "Frq Brkpnt+Peaks --> Midi,Staccato"		 -command {FrqBrkToStandardMidi 1; SetTestbed mstandard1} -foreground black
		}
		$mfzq add command -label "Frq Brkpnt+Peaks --> CDP Sequence (C60)"	 -command {ConvertFrqbrkpntDataAndPeakLevelDataToSequencer60Data; SetTestbed seqpk} -foreground black
		$mfzq add command -label "Frq Brkpnt --> Fixed Level CDP Seq (C60)" -command {MidiBrkSeq 0 1 0; SetTestbed midibrkseq010} -foreground black
		$mfzq add command -label "                          More Information" -command {MidiBrkSeqHelp} -foreground $evv(SPECIAL)
		$mfzq add command -label "USE PITCH DATA" -command {} -background $evv(HELP) -foreground black
		$mfzq add command -label "Play Sample In Sequence: Specify Pitch" -command {PlaySampleWithNormalisedMidiSeq; SetTestbed midipspec} -foreground black
		$mfzq add command -label "Transpose Files To Pitch Of 1st, At Timemarks" -command {TransposToPitch_SyncingAtTimeMarks 0; SetTestbed syncpch0} -foreground black
		$mfzq add command -label "Transpose Files To 1st & Sync At Timemarks" -command {TransposToPitch_SyncingAtTimeMarks 1; SetTestbed syncpch1} -foreground black
		$mfzq add command -label "                          More Information" -command {TransposSyncHelp} -foreground $evv(SPECIAL)

		;#	PITCH DATA (TEMPERED)

		set mfzqt [menu $ppich.subqt -tearoff 0]
		$mfzqt add command -label "TEMPERED PITCH DATA OPERATIONS" -command {}  -foreground black
		$mfzqt add command -label "Extracted Freq Data -> Vocal-Range MIDI" -command {FrqExtractionDataToNotatableMidi; SetTestbed frqexmidi} -foreground black
		$mfzqt add command -label "Associate Pitch Line With Sound"  -command {MelodyAssign 0; SetTestbed massign} -foreground black
		$mfzqt add command -label "Adjust Snd Pitch Using Associated Line"  -command {MelodyAdjust 0; SetTestbed madjusthf0} -foreground black
		$mfzqt add command -label "Adjust Pitchline To Harmonic Field & Warp Snd"  -command {MelodyAdjust 1; SetTestbed madjusthf1} -foreground black
		$mfzqt add command -label "Cut Specifically-Pitched Segs From Soundset" -command {ExtractSpecificPitchedMaterial; SetTestbed cutspecp} -foreground black
		$mfzqt add command -label "Isolate Specifically-Pitched Segs In Sounds" -command {IsolatePitches; SetTestbed isopitch} -foreground black
		$mfzqt add command -label "                          More Information" -command {MelAssignHelp} -foreground $evv(SPECIAL)

		;#	PITCH DATA (VARIBANK)

		set mfzqv [menu $ppich.subqv -tearoff 0]
		$mfzqv add command -label "CONVERSION TO VARIBANK MIDI-FILTER DATA" -command {} -background $evv(HELP) -foreground black
		$mfzqv add command -label "Frq Brkpnt --> Varibank Midi Filter Data" -command {MidiBrkSeq 0 1 1; SetTestbed midibrkseq011} -foreground black
		$mfzqv add command -label "MIDI Sequence (C60) --> Varibank Filter Data" -command {MidiBrkSeq 1 0 1; SetTestbed midibrkseq101} -foreground black
		if {[info exists released(specnu)]} {
			$mfzqv add command -label "Pitched Analysis Data --> Varibank Filter Data" -command {ExtractVfilterFromAnalData; SetTestbed evffad} -foreground black
			$mfzqv add command -label "Adjust Varibank Filter Data To Pitch Of Sound" -command {AdjustVfiltToPitchofSrc; SetTestbed avfdtpos} -foreground black
		}
		$mfzqv add command -label "VARIBANK MIDI-FILTER DERIVATIVES" -command {} -background $evv(HELP) -foreground black
		$mfzqv add command -label "Time Average, Ignoring Durs Of Orig Pitches" -command {PollOfFilters 0; SetTestbed midifpoll0} -foreground black
		$mfzqv add command -label "Time Average, Weighing Durs Of Orig Pitches" -command {PollOfFilters 1; SetTestbed midifpoll1} -foreground black
		$mfzqv add command -label "Divide Filter To Static Subfilters" -command {FilterDivideByPitch; SetTestbed midifdiv} -foreground black
		$mfzqv add command -label "                         More Information" -command {FilterDivideByPitchHelp} -foreground $evv(SPECIAL)

		;#	PITCH MARKS

		set mfze [menu $ppich.sube -tearoff 0]
		$mfze add command -label "Pitch Marks (Harmonic Field)" -command {TellPitchmarks} -background $evv(HELP) -foreground black
		$mfze add command -label "                          More Information" -command {TellPitchmarks} -foreground $evv(SPECIAL)
		$mfze add command -label "ON WORKSPACE" -command {}  -foreground black
		$mfze add command -label "Find Files With Specified Pitch Marks" -command {ManipulatePmarks $wl 0; SetTestbed findpmarks} -foreground black
		$mfze add command -label "WITH WORKSPACE SELECTED FILES" -command {}  -foreground black
		$mfze add command -label "Create Or Edit Pitch Marks" -command {Do_Pitchmark $wl 0; SetTestbed dopmarks} -foreground black
		$mfze add command -label "Compare Two Pitch Marks" -command {PmarkCompare $wl; SetTestbed compmarks} -foreground black
		$mfze add command -label "Compare Pmark With All Existing Pmarks" -command {ManipulatePmarks $wl 1; SetTestbed allpmarks} -foreground black
		$mfze add command -label "Display Harmonic Set Of All Pmarks" -command {CombinePmarks; SetTestbed combopmarks} -foreground black
		$mfze add command -label "Sort Into Descending Pitchmark Order" -command {SortOnPmarks; SetTestbed sortpmarks} -foreground black
		$mfze add command -label "Highlight Files In Harmonic Set" -command {InSetPmarks 0; SetTestbed inspmarks0} -foreground black
		$mfze add command -label "Highlight Files In Harmonic Field" -command {InSetPmarks 1; SetTestbed inspmarks1} -foreground black
		$mfze add command -label "" 	-command {} -foreground black
		$mfze add command -label "Delete Pitch Mark (!!)" 	-command {Do_Pitchmark $wl 1; SetTestbed delpmarks} -foreground black

		;#	USER PROPERTY FILES

		set mfza [menu $mfz.suba -tearoff 0]

		$mfza add command -label "PROPERTIES TABLES"  -command {} -background $evv(HELP) -foreground black
		$mfze add separator
		$mfza add command -label "Display Properties Table (select propfile)" -command {TabProps 1; SetTestbed proptab} -foreground black
		$mfza add command -label "Start A New Properties Table (select sndfile)" -command {NewPropfile; SetTestbed newprops} -foreground black
		$mfza add command -label "List Known Property Tables" -command {ShowKnownPropfiles; SetTestbed knownprops} -foreground black
		$mfza add command -label "                          More Information" -command {UserPropsHelp} -foreground $evv(SPECIAL)
		$mfza add command -label "Are Selected Sndfiles In Props Table?" -command {SndsInPropsfile; SetTestbed sndsinprop} -foreground black
		$mfza add command -label "MODIFY SOUND LISTING" -command {}  -foreground black
		$mfza add command -label "Add New Sounds With Empty Props (Prop + Sndfile(s))" -command {AddSndsToPropfile; SetTestbed sndtoprop} -foreground black
		$mfza add command -label "Remove Sounds (Prop + Sndfile(s))" -command {RemoveSndsFromPropfile; SetTestbed propsremove} -foreground black
		$mfza add command -label "Numerically Order Sndfiles (Propfile)" -command {PropsNumericSort; SetTestbed propnsort} -foreground black
		$mfza add command -label "Change Directory Of All Snds (Propfile)" -command {PropsDirChange; SetTestbed propnudir} -foreground black
		$mfza add cascade -label "Merge 2 Property Tables (2 Propfiles)" -menu $mfza.sub8 -foreground black
		$mfza add command -label "Merge Many Property Tables (Propfiles)" -command {Merge_Many_Props; SetTestbed mergmanypr} -foreground black
		$mfza add command -label "All Snds In Props Table To Workspace (Propfile)" -command {Do_Props 3; SetTestbed sndpropsw} -foreground black
		$mfza add command -label "All Snds In Props Table To Chosen List (Propfile)" -command {Do_Props 2; SetTestbed sndprops} -foreground black
		$mfza add command -label "Snds In Props Table To Soundlist Of Same Name" -command {PropToOrc; SetTestbed proptoorc} -foreground black
		$mfza add command -label "ADD, REMOVE, MODIFY PROPERTIES (Select Propfile)" -command {} -background $evv(HELP) -foreground black
		$mfza add command -label "Add Empty Property To All Files" -command {Add_Prop $evv(ADD_VOID_PROP); SetTestbed mtprops} -foreground black
		$mfza add command -label "Remove An Entire Property" -command {Add_Prop $evv(DELETE_ENTIRE_PROP); SetTestbed remprops} -foreground black
		$mfza add command -label "Add Vectored Property To All Files" -command {Add_Prop $evv(ADD_VECTOR_PROP); SetTestbed vecprops} -foreground black
		$mfza add command -label "Change A Property Name" -command {PropNamesChange; SetTestbed namprops} -foreground black
		$mfza add command -label "Globally Change A Property Value" -command {GlobalPropVals; SetTestbed globprops} -foreground black
		$mfza add command -label "Reorder Property Columns" -command {PropsPropnameSort; SetTestbed propreorder} -foreground black
		$mfza add command -label "Reorder Property Rows" -command {PropsSoundSort; SetTestbed propsndorder} -foreground black
		$mfza add command -label "Rename All Sounds" -command {PropsSoundRename; SetTestbed propsndrename} -foreground black
		$mfza add command -label "                          More Information" -command {PropsSoundRenameHelp} -foreground $evv(SPECIAL)
		$mfza add command -label "WORK WITH PROPERTY FILE" -command {} -background $evv(HELP) -foreground black
		$mfza add command -label "Sort/Select Snds By Properties (Select Propfile)" -command {Do_Props 0; SetTestbed doprops} -foreground black
		$mfza add command -label "Sort/Select Selected Snds By Props (..and Sndfiles)" -command {Do_Props 1; SetTestbed showprops} -foreground black
		$mfza add command -label "Extract Snd Name And Text Prop(if any)" -command {TextPropExtract; SetTestbed textpex} -foreground black
		$mfza add command -label "PROPERTY STATISTICS" -command {} -background $evv(HELP) -foreground black
		$mfza add command -label "How Many Sounds In Props File ?" -command {PropsFileCount; SetTestbed propscount} -foreground black
		$mfza add command -label "Statistics On Prop Value In Props File(s)" -command {PropsStats; SetTestbed propsstats} -foreground black
		$mfza add command -label "Find Items From Property Rhyme Statistics"  -command {FindSpecifiedRhymesInTextsOfTextPropertyInAllFiles 0; SetTestbed findrhyme} -foreground black
		$mfza add command -label "Find Items From Property Wordstarts Statistics"  -command {FindSpecifiedRhymesInTextsOfTextPropertyInAllFiles 1; SetTestbed findwstts} -foreground black
		$mfza add command -label "Gather Sounds With Propval To New Propfile" -command {PropsGather; SetTestbed propsgather} -foreground black
		set mfz8 [menu $mfza.sub8 -tearoff 0]
		$mfz8 add cascade -label "Identical Props: Different Sounds" -command {Merge_Props 0; SetTestbed dsprops} -foreground black
		$mfz8 add cascade -label "Different Props: Identical Sounds" -command {Merge_Props 1; SetTestbed isprops} -foreground black

		;#	BACKGROUND LISTINGS

		set mfzb [menu $mfz.subb -tearoff 0]

		$mfzb add command -label "Background Listings" -command {CDP_Specific_Usage $evv(TE_28) 0}  -foreground black
		$mfzb add command -label "                          More Information" -command {CDP_Specific_Usage $evv(TE_28) 0}  -foreground black
		$mfzb add command -label "PUT FILES IN BACKGROUND LISTING" -command {}  -foreground black
		$mfzb add cascade -label "Files To Background Listing" -menu $mfzb.sub1 -foreground black
		set mfz1 [menu $mfzb.sub1 -tearoff 0]
		$mfz1 add command -label "Selected Workspace Files" -command {BListFromWkspace $wl 1 0; SetTestbed selbkgd} -foreground black
		$mfz1 add command -label "All (Backed Up) Workspace Files" -command {BListFromWkspace $wl 0 0; SetTestbed allbkgd} -foreground black
		$mfz1 add command -label "Chosen Files" -command {BListFromWkspace $ch 0 0; SetTestbed chosbkgd} -foreground black
		$mfz1 add command -label "Chosen Files, Forcing Duplicates If Ness" -command {BListFromWkspace $ch 0 1; SetTestbed chosbkgd_dup} -foreground black
		$mfz1 add command -label "Selected Directory Listing Files" -command {BListFromWkspace dirlist 0 0; SetTestbed dirbkgd} -foreground black
		$mfzb add command -label "WORK ON BACKGROUND LISTINGS" -command {}  -foreground black

		$mfzb add cascade -label "Background Listings" -menu $mfzb.sub0 -foreground black

		set mfz0 [menu $mfzb.sub0 -tearoff 0]
		$mfz0 add command -label "See/Play/Edit A B-List" -command {GetBLName 2; SetTestbed seebkgd} -foreground black
		$mfz0 add command -label "Check B-Lists Are Distinct" -command {GetBLName 17; SetTestbed checkbkgd} -foreground black
		$mfz0 add command -label "Rename A B-List" -command {GetBLName 4; SetTestbed renamebkgd} -foreground black
		$mfz0 add command -label "Destroy A Named B-List" -command {GetBLName 1; SetTestbed desbkgd} -foreground black
		$mfz0 add command -label "Delete All B-Lists (!!!)" -command {DeleteAllBL; SetTestbed delbkgd} -foreground black

		$mfzb add cascade -label "Pitch Marks In B-Lists" -menu $mfzb.sub2 -foreground black

		set mfz2 [menu $mfzb.sub2 -tearoff 0]
		$mfz2 add command -label "Create/Edit/Delete Sound Pitchmarks" -command {GetBLName 5; SetTestbed pmbkgd} -foreground black
		$mfz2 add command -label "Hilight All / Compare Any Two" -command {GetBLName 6; SetTestbed hibkgd} -foreground black
		$mfz2 add command -label "Compare With All Pitchmarks Anywhere" -command {GetBLName 7; SetTestbed combkgd} -foreground black

		$mfzb add command -label "Music Workpad" -command {GetBLName 11; SetTestbed workpad} -foreground black
		$mfzb add command -label "                          More Information" -command {CDP_Specific_Usage $evv(TE_29) 0} -foreground $evv(SPECIAL)
		$mfzb add command -label "GET B-LIST FILES TO WORKSPACE" -command {}  -foreground black
		$mfzb add separator

		$mfzb add cascade -label "To Workspace" -menu $mfzb.sub3 -foreground black
		set mfz3 [menu $mfzb.sub3 -tearoff 0]

		$mfz3 add command -label "Replace Workspace" -command {LoadToWorkspaceBL 0 0; SetTestbed wkrepl} -foreground black
		$mfz3 add command -label "Add Files To Workspace" -command {LoadToWorkspaceBL 1 0; SetTestbed wkadd} -foreground black
		$mfz3 add command -label "Add Selected Files Only" -command {GetBLName 10; SetTestbed wksel} -foreground black

		$mfzb add cascade -label "To Chosen Files List" -menu $mfzb.sub5 -foreground black

		set mfz5 [menu $mfzb.sub5 -tearoff 0]
		$mfz5 add command -label "All Files To Chosen Files" -command {LoadToWorkspaceBL 1 1; SetTestbed tochos} -foreground black
		$mfz5 add command -label "Selected Files Only" -command {GetBLName 14; SetTestbed tochosel} -foreground black

		$mfzb add separator
		$mfzb add command -label "CLEAR WORKSPACE OF B-LIST FILES" -command {}  -foreground black
		$mfzb add separator
		$mfzb add command -label "Files Actually Loaded At Last B-List Load" -command {RemoveBkgd 0; SetTestbed remlast} -foreground black
		$mfzb add command -label "All Files In Last B-List Loaded" -command {RemoveBkgd 1; SetTestbed remlastall} -foreground black
		$mfzb add command -label "All Files In Last B-List Accessed" -command {RemoveBkgd 2; SetTestbed remacc} -foreground black
		$mfzb add command -label "Files In Specified B-List" -command {RemoveFromWkspace bkgdthis; SetTestbed rembl} -foreground black

		;#	SKETCH SCORE

		set mfzc [menu $mfz.subc -tearoff 0]
		$mfzc add command -label "Sketch Score" -command {CDP_Specific_Usage $evv(TE_30) 0}  -foreground black
		$mfzc add command -label "                          More Information" -command {CDP_Specific_Usage $evv(TE_30) 0} -foreground $evv(SPECIAL)
		$mfzc add command -label "WORK WITH SKETCH SCORE" -command {}   -foreground black
		$mfzc add command -label "Load A Named Sketch Score" -command {EstablishScore -1; SetTestbed skorg-1} -foreground black
		$mfzc add command -label "Continue Organizing Sounds On A Sketch Score" -command {EstablishScore 0; SetTestbed skorg0} -foreground black
		$mfzc add command -label "Create New Score With Selected Wkspace Files" -command {EstablishScore 1; SetTestbed skorg1} -foreground black
		$mfzc add command -label "Refresh All Score Files" -command {RefreshUnloadedScores 0; SetTestbed skrefr} -foreground black
		$mfzc add command -label "Destroy a Named Score" -command {DestroyNamedScore; SetTestbed skrede} -foreground black
		$mfzc add command -label "KEEP SELECTED SOUNDS TO PUT ON SCORE" -command {}   -foreground black
		$mfzc add command -label "From Workspace" -command {GetWkspaceSoundToScore $wl 0; SetTestbed skwk} -foreground black
		$mfzc add command -label "From Chosen Files List (in that order)" -command {GetWkspaceSoundToScore $ch 0; SetTestbed skch} -foreground black
		$mfzc add command -label "From Directory Listing" -command {GetWkspaceSoundToScore $dl 0; SetTestbed skdir} -foreground black
		$mfzc add command -label "From List In Textfile" -command {GetWkspaceSoundListToScore 0; SetTestbed sklist} -foreground black
		$mfzc add command -label "From Mixfile" -command {GetWkspaceSoundListToScore 1; SetTestbed skmix} -foreground black

		;#	NAME GAMES

		set mfzf [menu $mfz.subf -tearoff 0]

		$mfzf add command -label "NAME GAMES" -command {}   -foreground black
		$mfzf add command -label "                          More Information" -command {TellNameGames} -foreground $evv(SPECIAL)
		$mfzf add command -label "Rename By Shuffling Name Segments"  -command {}   -foreground black
		$mfzf add cascade -label "Workspace Selected Sound Files Only" -menu $mfzf.sub1 -foreground black
		set mfzf1 [menu $mfzf.sub1 -tearoff 0]
		$mfzf add cascade -label "Any Workspace Selected Files" -menu $mfzf.sub1a -foreground black
		set mfzf1a [menu $mfzf.sub1a -tearoff 0]
		$mfzf add cascade -label "Chosen List Sound Files Only" -menu $mfzf.sub4 -foreground black
		set mfzf4 [menu $mfzf.sub4 -tearoff 0]
		$mfzf add cascade -label "Any Chosen List Files" -menu $mfzf.sub4a -foreground black
		set mfzf4a [menu $mfzf.sub4a -tearoff 0]
		$mfzf add command -label "Reverse Previous Renamings !!" -command {RestoreOriginalFilenames} -foreground black
		$mfzf add command -label "REARRANGE FILE ORDER"  -command {}   -foreground black
		$mfzf add cascade -label "Wkspace Selection : Sort By Name Segment" -menu $mfzf.sub2 -foreground black
		set mfzf2 [menu $mfzf.sub2 -tearoff 0]
		$mfzf add cascade -label "All Wkspace: Sort By Name Segment" -menu $mfzf.sub2a -foreground black
		set mfzf2a [menu $mfzf.sub2a -tearoff 0]
		$mfzf add cascade -label "Snds On Chosen List: Sort By Name Segment" -menu $mfzf.sub5 -foreground black
		set mfzf5 [menu $mfzf.sub5 -tearoff 0]
		$mfzf add cascade -label ".......Sort & Keep Equal Nos Of Each Type" -menu $mfzf.sub7 -foreground black
		set mfzf7 [menu $mfzf.sub7 -tearoff 0]
		$mfzf add cascade -label ".......Interleave By Name Segment" -menu $mfzf.sub6 -foreground black
		set mfzf6 [menu $mfzf.sub6 -tearoff 0]
		$mfzf add cascade -label "All On Chosen List: Sort By Name Segment" -menu $mfzf.sub5a -foreground black
		set mfzf5a [menu $mfzf.sub5a -tearoff 0]
		$mfzf add cascade -label ".......Sort & Keep Equal Nos Of Each Type" -menu $mfzf.sub7a -foreground black
		set mfzf7a [menu $mfzf.sub7a -tearoff 0]
		$mfzf add cascade -label ".......Interleave By Name Segment" -menu $mfzf.sub6a -foreground black
		set mfzf6a [menu $mfzf.sub6a -tearoff 0]
		$mfzf add command -label ".......Substitute via Segment In Every Nth File"  -command {MassageFilenames cycfiles 1 $ch; SetTestbed substitute} -foreground black
		$mfzf add command -label "SUBSTITUTE FILES WITH SPECIFIC SEGMENT VALUE"  -command {}   -foreground black
		$mfzf add command -label "Change Chosen Files With Specific Seg Value" -command {MassageFilenames delsegval 0 $ch; SetTestbed delsegval} -foreground black

		$mfzf1 add command -label "Add Head" -command {MassageFilenames addhead 1 $wl; SetTestbed addhead} -foreground black
		$mfzf1 add command -label "Add Tail" -command {MassageFilenames addtail 1 $wl; SetTestbed addtail} -foreground black
		$mfzf1 add command -label "Move Head To Tail" -command {HeadVTail 1 1 $wl; SetTestbed headtail} -foreground black
		$mfzf1 add command -label "Move Tail To Head" -command {HeadVTail 0 1 $wl; SetTestbed tailhead} -foreground black
		$mfzf1 add command -label "Add Segment At Character" -command {MassageFilenames addat 1 $wl; SetTestbed addat} -foreground black
		$mfzf1 add command -label "Add Segment After Segment N" -command {MassageFilenames addatseg 1 $wl; SetTestbed addatseg} -foreground black
		$mfzf1 add command -label "Swap Specific Segments" -command {MassageFilenames swapsegs 1 $wl; SetTestbed swapseg} -foreground black
		$mfzf1 add command -label "Reverse All Segments" -command {MassageFilenames reverse 1 $wl; SetTestbed reverse} -foreground black
		$mfzf1 add command -label "Delete Head" -command {MassageFilenames deletehead 1 $wl; SetTestbed delhead} -foreground black
		$mfzf1 add command -label "Delete Tail" -command {MassageFilenames deletetail 1 $wl; SetTestbed deltail} -foreground black
		$mfzf1 add command -label "Delete Specific Segment" -command {MassageFilenames deleteseg 1 $wl; SetTestbed delseg} -foreground black
		$mfzf1 add command -label "GET SEGMENTS FROM NAMES" -command {}  -foreground black
		$mfzf1 add command -label "Get A Segment From Every Nth Filename" -command {MassageFilenames getsegs 1 $wl; SetTestbed getsegs} -foreground black

		$mfzf1a add command -label "Add Head" -command {MassageFilenames addhead 0 $wl; SetTestbed all_addhead} -foreground black
		$mfzf1a add command -label "Add Tail" -command {MassageFilenames addtail 0 $wl; SetTestbed all_addtail} -foreground black
		$mfzf1a add command -label "Move Head To Tail" -command {HeadVTail 1 0 $wl; SetTestbed all_headtail} -foreground black
		$mfzf1a add command -label "Move Tail To Head" -command {HeadVTail 0 0 $wl; SetTestbed all_tailhead} -foreground black
		$mfzf1a add command -label "Add Segment At Character" -command {MassageFilenames addat 0 $wl; SetTestbed all_addat} -foreground black
		$mfzf1a add command -label "Add Segment After Segment N" -command {MassageFilenames addatseg 0 $wl; SetTestbed all_addatseg} -foreground black
		$mfzf1a add command -label "Swap Specific Segments" -command {MassageFilenames swapsegs 0 $wl; SetTestbed all_swapseg} -foreground black
		$mfzf1a add command -label "Reverse All Segments" -command {MassageFilenames reverse 0 $wl; SetTestbed all_reverse} -foreground black
		$mfzf1a add command -label "Delete Head" -command {MassageFilenames deletehead 0 $wl; SetTestbed all_delhead} -foreground black
		$mfzf1a add command -label "Delete Tail" -command {MassageFilenames deletetail 0 $wl; SetTestbed all_deltail} -foreground black
		$mfzf1a add command -label "Delete Specific Segment" -command {MassageFilenames deleteseg 0 $wl; SetTestbed all_delseg} -foreground black

		$mfzf2 add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $wl alphabet 1 sort; SetTestbed alphabet} -foreground black
		$mfzf2 add command -label "By Start Consonant Of Segment" -command {SortFilenames $wl startcons 1 sort; SetTestbed startcons} -foreground black
		$mfzf2 add command -label "By End Consonant Of Segment" -command {SortFilenames $wl endcons 1 sort; SetTestbed endcons} -foreground black
		$mfzf2 add command -label "By Vowel In Segment" -command {SortFilenames $wl vowel 1 sort; SetTestbed vowel} -foreground black
		$mfzf2 add command -label "Numerically On Segment" -command {SortFilenames $wl numeric 1 sort; SetTestbed number} -foreground black
		$mfzf2 add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $wl pitchclass 1 sort; SetTestbed pclass} -foreground black
		$mfzf2 add command -label "On Entire Basic Filename" -command {SortFilenames $wl all 1 sort; SetTestbed entire} -foreground black

		$mfzf2a add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $wl alphabet 0 sort; SetTestbed all_alphabet} -foreground black
		$mfzf2a add command -label "By Start Consonant Of Segment" -command {SortFilenames $wl startcons 0 sort; SetTestbed all_startcons} -foreground black
		$mfzf2a add command -label "By End Consonant Of Segment" -command {SortFilenames $wl endcons 0 sort; SetTestbed all_endcons} -foreground black
		$mfzf2a add command -label "By Vowel In Segment" -command {SortFilenames $wl vowel 0 sort; SetTestbed all_vowel} -foreground black
		$mfzf2a add command -label "Numerically On Segment" -command {SortFilenames $wl numeric 0 sort; SetTestbed all_number} -foreground black
		$mfzf2a add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $wl pitchclass 0 sort; SetTestbed all_pclass} -foreground black
		$mfzf2a add command -label "On Entire Basic Filename" -command {SortFilenames $wl all 0 sort; SetTestbed all_entire} -foreground black

		$mfzf4 add command -label "Add Head" -command {MassageFilenames addhead 1 $ch; SetTestbed addhead_ch} -foreground black
		$mfzf4 add command -label "Add Tail" -command {MassageFilenames addtail 1 $ch; SetTestbed addtail_ch} -foreground black
		$mfzf4 add command -label "Move Head To Tail" -command {HeadVTail 1 1 $ch; SetTestbed headtail_ch} -foreground black
		$mfzf4 add command -label "Move Tail To Head" -command {HeadVTail 0 1 $ch; SetTestbed tailhead_ch} -foreground black
		$mfzf4 add command -label "Add Segment At Character" -command {MassageFilenames addat 1 $ch; SetTestbed addat_ch} -foreground black
		$mfzf4 add command -label "Add Segment After Segment N" -command {MassageFilenames addatseg 1 $ch; SetTestbed addatseg_ch} -foreground black
		$mfzf4 add command -label "Swap Specific Segments" -command {MassageFilenames swapsegs 1 $ch; SetTestbed swapseg_ch} -foreground black
		$mfzf4 add command -label "Reverse All Segments" -command {MassageFilenames reverse 1 $ch; SetTestbed reverse_ch} -foreground black
		$mfzf4 add command -label "Delete Head" -command {MassageFilenames deletehead 1 $ch; SetTestbed delhead_ch} -foreground black
		$mfzf4 add command -label "Delete Tail" -command {MassageFilenames deletetail 1 $ch; SetTestbed deltail_ch} -foreground black
		$mfzf4 add command -label "Delete Specific Segment" -command {MassageFilenames deleteseg 1 $ch; SetTestbed delseg_ch} -foreground black
		$mfzf4 add command -label "GET SEGMENTS FROM NAMES" -command {}  -foreground black
		$mfzf4 add command -label "Get Segment From Every Nth Filename" -command {MassageFilenames getsegs 1 $ch; SetTestbed getsegs_ch} -foreground black

		$mfzf4a add command -label "Add Head" -command {MassageFilenames addhead 0 $ch; SetTestbed all_addhead_ch} -foreground black
		$mfzf4a add command -label "Add Tail" -command {MassageFilenames addtail 0 $ch; SetTestbed all_addtail_ch} -foreground black
		$mfzf4a add command -label "Move Head To Tail" -command {HeadVTail 1 0 $ch; SetTestbed all_headtail_ch} -foreground black
		$mfzf4a add command -label "Move Tail To Head" -command {HeadVTail 0 0 $ch; SetTestbed all_tailhead_ch} -foreground black
		$mfzf4a add command -label "Add Segment At Character" -command {MassageFilenames addat 0 $ch; SetTestbed all_addat_ch} -foreground black
		$mfzf4a add command -label "Add Segment After Segment N" -command {MassageFilenames addatseg 0 $ch; SetTestbed all_addatseg_ch} -foreground black
		$mfzf4a add command -label "Swap Specific Segments" -command {MassageFilenames swapsegs 0 $ch; SetTestbed all_swapseg_ch} -foreground black
		$mfzf4a add command -label "Reverse All Segments" -command {MassageFilenames reverse 0 $ch; SetTestbed all_reverse_ch} -foreground black
		$mfzf4a add command -label "Delete Head" -command {MassageFilenames deletehead 0 $ch; SetTestbed all_delhead_ch} -foreground black
		$mfzf4a add command -label "Delete Tail" -command {MassageFilenames deletetail 0 $ch; SetTestbed all_deltail_ch} -foreground black
		$mfzf4a add command -label "Delete Specific Segment" -command {MassageFilenames deleteseg 0 $ch; SetTestbed all_delseg_ch} -foreground black

		$mfzf5 add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $ch alphabet 1 sort; SetTestbed alphabet_ch} -foreground black
		$mfzf5 add command -label "By Start Consonant Of Segment" -command {SortFilenames $ch startcons 1 sort; SetTestbed startcons_ch} -foreground black
		$mfzf5 add command -label "By End Consonant Of Segment" -command {SortFilenames $ch endcons 1 sort; SetTestbed endcons_ch} -foreground black
		$mfzf5 add command -label "By Vowel In Segment" -command {SortFilenames $ch vowel 1 sort; SetTestbed vowel_ch} -foreground black
		$mfzf5 add command -label "Numerically On Segment" -command {SortFilenames $ch numeric 1 sort; SetTestbed number_ch} -foreground black
		$mfzf5 add command -label "By Midi Pitch-class In Segment" -command {SortFilenames $ch pitchclass 1 sort; SetTestbed pclass_ch} -foreground black
		$mfzf5 add command -label "On Entire Basic Filename" -command {SortFilenames $ch all 1 sort; SetTestbed entire_ch} -foreground black

		$mfzf5a add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $ch alphabet 0 sort; SetTestbed all_alphabet_ch} -foreground black
		$mfzf5a add command -label "By Start Consonant Of Segment" -command {SortFilenames $ch startcons 0 sort; SetTestbed all_startcons_ch} -foreground black
		$mfzf5a add command -label "By End Consonant Of Segment" -command {SortFilenames $ch endcons 0 sort; SetTestbed all_endcons_ch} -foreground black
		$mfzf5a add command -label "By Vowel In Segment" -command {SortFilenames $ch vowel 0 sort; SetTestbed all_vowel_ch} -foreground black
		$mfzf5a add command -label "Numerically On Segment" -command {SortFilenames $ch numeric 0 sort; SetTestbed all_number_ch} -foreground black
		$mfzf5a add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $ch pitchclass 0 sort; SetTestbed all_pclass_ch} -foreground black
		$mfzf5a add command -label "On Entire Basic Filename" -command {SortFilenames $ch all 0 sort; SetTestbed all_entire_ch} -foreground black

		$mfzf6 add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $ch alphabet 1 interleave; SetTestbed ialphabet_ch} -foreground black
		$mfzf6 add command -label "By Start Consonant Of Segment" -command {SortFilenames $ch startcons 1 interleave; SetTestbed istartcons_ch} -foreground black
		$mfzf6 add command -label "By End Consonant Of Segment" -command {SortFilenames $ch endcons 1 interleave; SetTestbed iendcons_ch} -foreground black
		$mfzf6 add command -label "By Vowel In Segment" -command {SortFilenames $ch vowel 1 interleave; SetTestbed ivowel_ch} -foreground black
		$mfzf6 add command -label "Numerically On Segment" -command {SortFilenames $ch numeric 1 interleave; SetTestbed inumber_ch} -foreground black
		$mfzf6 add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $ch pitchclass 1 interleave; SetTestbed ipclass_ch} -foreground black
		$mfzf6 add command -label "On Entire Basic Filename" -command {SortFilenames $ch all 1 interleave; SetTestbed ientire_ch} -foreground black

		$mfzf6a add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $ch alphabet 0 interleave; SetTestbed all_ialphabet_ch} -foreground black
		$mfzf6a add command -label "By Start Consonant Of Segment" -command {SortFilenames $ch startcons 0 interleave; SetTestbed all_istartcons_ch} -foreground black
		$mfzf6a add command -label "By End Consonant Of Segment" -command {SortFilenames $ch endcons 0 interleave; SetTestbed all_iendcons_ch} -foreground black
		$mfzf6a add command -label "By Vowel In Segment" -command {SortFilenames $ch vowel 0 interleave; SetTestbed all_ivowel_ch} -foreground black
		$mfzf6a add command -label "Numerically On Segment" -command {SortFilenames $ch numeric 0 interleave; SetTestbed all_inumber_ch} -foreground black
		$mfzf6a add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $ch pitchclass 0 interleave; SetTestbed all_ipclass_ch} -foreground black
		$mfzf6a add command -label "On Entire Basic Filename" -command {SortFilenames $ch all 0 interleave; SetTestbed all_ientire_ch} -foreground black

		$mfzf7 add command -label "By Alphabetic Chars In Segment" -command {SortFilenames $ch alphabet 1 reduce; SetTestbed alphabet_r} -foreground black
		$mfzf7 add command -label "By Start Consonant Of Segment" -command {SortFilenames $ch startcons 1 reduce; SetTestbed startcons_r} -foreground black
		$mfzf7 add command -label "By End Consonant Of Segment" -command {SortFilenames $ch endcons 1 reduce; SetTestbed endcons_r} -foreground black
		$mfzf7 add command -label "By Vowel In Segment" -command {SortFilenames $ch vowel 1 reduce; SetTestbed vowel_r} -foreground black
		$mfzf7 add command -label "Numerically On Segment" -command {SortFilenames $ch numeric 1 reduce; SetTestbed number_r} -foreground black
		$mfzf7 add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $ch pitchclass 1 reduce; SetTestbed pclass_r} -foreground black

		$mfzf7a add command -label "by Alphabetic Chars In Segment" -command {SortFilenames $ch alphabet 0 reduce; SetTestbed alphabet_rall} -foreground black
		$mfzf7a add command -label "By Start Consonant Of Segment" -command {SortFilenames $ch startcons 0 reduce; SetTestbed startcons_rall} -foreground black
		$mfzf7a add command -label "By End Consonant Of Segment" -command {SortFilenames $ch endcons 0 reduce; SetTestbed endcons_rall} -foreground black
		$mfzf7a add command -label "By Vowel In Segment" -command {SortFilenames $ch vowel 0 reduce; SetTestbed vowel_rall} -foreground black
		$mfzf7a add command -label "Numerically On Segment" -command {SortFilenames $ch numeric 0 reduce; SetTestbed number_rall} -foreground black
		$mfzf7a add command -label "By Midi Pitch-Class In Segment" -command {SortFilenames $ch pitchclass 0 reduce; SetTestbed pclass_rall} -foreground black

		set mfzg [menu $mfz.subg -tearoff 0]

		$mfzg add command -label "Partition Soundfiles" -command {TellPartition}  -foreground black
		$mfzg add command -label "                          More Information" -command {TellPartition} -foreground $evv(SPECIAL)
		$mfzg add separator
		$mfzg add command -label "Play And Partition Selected Files" -command {PlayOutput 3; SetTestbed ppartition} -foreground black
		$mfzg add command -label "Play And Swap Files Between Lists"  -command {SwapPartitionPlay; SetTestbed pswap} -foreground black

		set mfzpp [menu $mfz.subpp -tearoff 0]

		$mfzpp add command -label "PATTERNING OPERATIONS" -command {} -background $evv(HELP)
		$mfzpp add command -label "Generate Fractals" -command {Fractals; SetTestbed fractals} -foreground black
		if {[info exists released(mchanpan)] && [info exists released(newmix)]} {
			$mfzpp add command -label "Filter Partitions" -command {FilterPartition; SetTestbed fpartition} -foreground black
		}
		$mfzpp add cascade -label "Detect, Extend Or Sync-With Onsets" -menu $mfzpp.ons
		set mfzppo [menu $mfzpp.ons -tearoff 0]
		$mfzppo add command -label "List Sudden Onsets In Sound"	-command {ExtractSuddenOnsets; SetTestbed xonsets}
		$mfzppo add command -label "Convert Onset-List To Edit-Slices-List"	-command {OnsetsToSlice; SetTestbed onsetstoslice}
		$mfzppo add command -label "Extend By Rand-Permuting Slices Within" -command {ExtendFileWithOnsets; SetTestbed efwo}
		$mfzppo add command -label "Create Mix From Sndfiles And Onset-List" -command {TimesFilesToMix; SetTestbed timsfilsmix}
		$mfzppo add command -label "------------ More Information ------------" -command {TellOnsetSlice} -foreground $evv(SPECIAL)


		set mfzh [menu $mfz.subh -tearoff 0]

		$mfzh add command -label "Pitch Sequence Markers (Melodic Line)" -command {TellKeyboard}  -foreground black
		$mfzh add command -label "Untimed Sequences (More Information)" -command {TellKeyboard1} -foreground $evv(SPECIAL)
		$mfzh add command -label "Enter Motif Via Piano Keyboard" -command {TheKeyboard; SetTestbed keyboard} -foreground black
		$mfzh add command -label "Display Motifs" -command {ShowMotifs; SetTestbed shmotif} -foreground black
		$mfzh add command -label "Delete Motifs" -command {DeleteMotifs 0; SetTestbed delmtf0} -foreground black
		$mfzh add command -label "Delete All Existing Motif Markers" -command {DeleteMotifs 1; SetTestbed delmtf1} -foreground black
		$mfzh add command -label "Timed Sequences (More Information)" -command {TellKeyboard2} -foreground $evv(SPECIAL)
		$mfzh add command -label "Extracted Freq Data -> Vocal-Range Midi" -command {FrqExtractionDataToNotatableMidi; SetTestbed frqexmidi} -foreground black
		$mfzh add command -label "Timed Midi Data Workshop" -command {TheMelodyFixer; SetTestbed melfix} -foreground black
		$mfzh add command -label "" -command {TheMelodyFixer; SetTestbed melfix} -foreground black

		set mfzr [menu $mfz.subr -tearoff 0]
		$mfzr add command -label "RHYTHM" -command {} -background $evv(HELP) -foreground black
		$mfzr add command -label "Extract Rhythm" -command {ExtractRhythm; SetTestbed exrhythm} -foreground black
		$mfzr add command -label "Contract Events But Retain Rhythm" -command {RhythmicSyllableShrink; SetTestbed rhshrink} -foreground black
		$mfzr add command -label "Sync Sound To MM By Editing" -command {MMTrim 0; SetTestbed mmtrim} -foreground black
		$mfzr add command -label "Sync Sound To A Rhythm By Editing" -command {MMTrim 1; SetTestbed mmtrimnew} -foreground black
		if {[info exists released(clicknew)]} {
			$mfzr add command -label "Create Click Track Over Sound Or From Textlist" -command {DoClick; SetTestbed doclick}
		}
		$mfzr add command -label "------------ More Information ------------" -command {TellContract} -foreground $evv(SPECIAL)
		$mfzr add command -label "ACCENTS" -command {} -background $evv(HELP) -foreground black
		$mfzr add command -label "Emphasize Specified Events" -command {EventsEmphasize; SetTestbed evemph} -foreground black
		$mfzr add command -label "Emphasize Peak(s)" -command {IsolatePeak; SetTestbed isopeak} -foreground black
		$mfzr add command -label "Match Levels Of Isolated Events" -command {MatchIsolates; SetTestbed matchiso} -foreground black
		$mfzr add command -label "~ More Information ~" -command {TellEmphasize} -foreground $evv(SPECIAL)
		$mfzr add cascade -label "Isolate Events" -menu $mfzr.subi -foreground black
		$mfzr add command -label "~ More Information ~" -command {HelpEventIsolator} -foreground $evv(SPECIAL)
		set mfzri [menu $mfzr.subi -tearoff 0]
		$mfzri add command -label "Isolate Events To Sndfile" -command {EventIsolator 0; SetTestbed isolator0} -foreground black
		$mfzri add command -label "Isolate Events To Mixfile" -command {EventIsolator 1; SetTestbed isolator1} -foreground black
		$mfzri add command -label "Isolate Events By Spectral Analysis" -command {SpectralEventIsolator; SetTestbed speciso} -foreground black
		$mfzr add command -label "TIMEMARKS" -command {}  -foreground black
		$mfzr add command -label "Assign Timemarks To File And Save" -command {SynchroniseSoundsAtTimeMarks 6; SetTestbed syncmarks6} -foreground black
		$mfzr add command -label "Copy Timemarks File 1 To Other Files" -command {SynchroniseSoundsAtTimeMarks 4; SetTestbed syncmarks4} -foreground black
		$mfzr add command -label "                          More Information" -command {HelpTimeMarks} -foreground $evv(SPECIAL)
		$mfzr add command -label "SYNCHRONISE SOUND RHYTHM" -command {} -background $evv(HELP) -foreground black
		$mfzr add command -label "Sync File2 To File1 At Timemark(s)" -command {SynchroniseSoundsAtTimeMarks 0; SetTestbed syncmarks0} -foreground black
		$mfzr add command -label "Give Tmark File 3 To 2 & Sync 2 To 1" -command {SynchroniseSoundsAtTimeMarks 5; SetTestbed syncmarks5} -foreground black
		$mfzr add command -label "Sync Many Files To File1 At Timemark(s)" -command {SyncSeveralFilesAtTimemarks; SetTestbed syncmult} -foreground black
		if {[info exists released(specsync)]} {
			$mfzr add command -label "Exact Sync File(s) To File1 At Timemark(s)" -command {SyncSeveralFilesAtTimemarks; SetTestbed syncmult}
		}
		$mfzr add command -label "Sync File To Pulse At Timemarks"   -command {SynchroniseSoundsAtTimeMarks 1; SetTestbed syncmarks1} -foreground black
		$mfzr add command -label "Sync File To Rhythm At Timemarks"   -command {SynchroniseSoundsAtTimeMarks 2; SetTestbed syncmarks2} -foreground black
		$mfzr add command -label "Sync File To Timecues At Timemarks" -command {SynchroniseSoundsAtTimeMarks 3; SetTestbed syncmarks3} -foreground black
		$mfzr add command -label "Create Timecues" -command {CreateTimeCues; SetTestbed timecues} -foreground black
		$mfzr add command -label "                          More Information" -command {HelpTimeCues} -foreground $evv(SPECIAL)
		$mfzr add command -label "List (Normalised) Peaks At Timemarks"	-command {LevelsAtTimeMarks; SetTestbed synlev} -foreground black
		$mfzr add command -label "SYNCHRONISE OR MODIFY DATA RHYTHM" -command {} -background $evv(HELP) -foreground black
		$mfzr add command -label "Sync Mixfile Times To Rhythm"   -command {RerhythmMixfile; SetTestbed syncmix} -foreground black
		$mfzr add command -label "Warp Timedata In Mix, Brk Or List" -command {DataWarp; SetTestbed datawarp} -foreground black
		$mfzr add command -label "Replace All Sndfiles In Mix" -command {SndToMix 9; SetTestbed sndtomix9} -foreground black

		set mfzsubrev [menu $mfz.subrev -tearoff 0]
		$mfzsubrev add command -label "REVERB" -command {} -background $evv(HELP) -foreground black
		$mfzsubrev add command -label "Create Reverb On Sound Tail" -command {ResTail; SetTestbed restail} -foreground black
		$mfzsubrev add command -label "Reverb On Multichan Sound Tail" -command {MresTail; SetTestbed mrestail} -foreground black
		$mfzsubrev add command -label "Create Stereo Reverb" -command {RevStereo; SetTestbed revstereo} -foreground black
		if {[info exists released(verges)]} {
			$mfzsubrev add command -label "Create Reverbd Verges" -command {ReverbdVerges; SetTestbed reverg}
		}
		$mfzsubrev add command -label "Internal Stereo Delay" -command {InternalDelay; SetTestbed internaldelay}
		$mfzsubrev add command -label "Distort Reverb" -command {DistRev; SetTestbed distrev}
		if {[info exists released(fastconv)]} {
			$mfzsubrev add command -label "Fast Convolution" -command {FastConvolution; SetTestbed fastconv}
		}
	}
	set musictestbed_established 1
}

proc GetParseTheMax {} {
	global parse_the_max evv
	set fnam [file join $evv(CDPRESOURCE_DIR) parsemax$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {open $fnam "r"} zit] {
			Inf "Cannot Open File '$fnam' To Read Maxval-Parsing State\nDefaulting To Read Maxval On Loading Files"
			set parse_the_max 1
			return
		}
		gets $zit line
		set parse_the_max $line
		close $zit
	} else {
		Inf "Setting System To Read Maxval In Soundfile On Loading To Workspace\nYou Can Unset This On The System-State Menu"
		SetParseTheMax 1
	}
}

proc SetParseTheMax {setit} {
	global parse_the_max evv
	set fnam [file join $evv(CDPRESOURCE_DIR) parsemax$evv(CDP_EXT)]
	set parse_the_max $setit
	if [catch {open $fnam "w"} zit] {
		Inf "Cannot Open File '$fnam' To Set Maxval-Parsing In Future Sessions"
		return
	}
	puts $zit $setit
	close $zit
}

proc GetEofTrap {} {
	global eoftrap evv
	set eoftrap 0
	if {[file exists [file join $evv(CDPRESOURCE_DIR) eoftrap$evv(CDP_EXT)]]} {
		set eoftrap 1
	}
}

proc SetEofTrap {setit} {
	global eoftrap evv
	set fnam [file join $evv(CDPRESOURCE_DIR) eoftrap$evv(CDP_EXT)]
	if {$setit} {
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Create File '$fnam' To Remember State Of 'EOF Trap' For Future Sessions"
			} else {
				close $zit
			}
		}
		set eoftrap 1
	} else {
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot Delete File '$fnam' To Remember State Of 'EOF Trap' For Future Sessions"
			}
		}
		set eoftrap 0
	}
}
proc EofTrapHelp {} {
	set msg "BULK PROCESSES: EOF TRAP\n"
	append msg "\n"
	append msg "If Bulk Processing always fails on your machine, with an error message\n"
	append msg "suggesting that the Loom failed to read an EOF (end of file) message,\n"
	append msg "use the EOF trap.\n"
	Inf $msg
}

proc RemoveDuplsInFile {} {
	global wl pa wstk evv
	set i [$wl curselection]
	if {[llength $i] != 1} {
		Inf "Select A Single Textfile Which Lists Soundfiles"
		return
	} elseif {$i < 0} {
		Inf "No Workspace File Selected"
		return
	}
	set fnam [$wl get $i]
	if {![IsASndlist $pa($fnam,$evv(FTYP))]} {
		Inf "Select A Single Textfile Which Lists Soundfiles"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"	
		return
	}
	set filelist {}
	while {[gets $zit line] >= 0} {
		set listedfile [string trim $line]
		if {[string length $listedfile] <= 0} {
			continue
		}
		if {![file exists $listedfile]} {
			lappend badfiles1 $listedfile
			continue
		}
		set ftyp [FindFileType $listedfile]
		if {$ftyp != $evv(SNDFILE)} {
			lappend badfiles2 $listedfile
			continue
		}
		lappend filelist $listedfile
	}
	close $zit
	set origlen [llength $filelist]	
	if [info exists badfiles1] {
		incr origlen [llength $badfiles1]	
	}
	if [info exists badfiles2] {
		incr origlen [llength $badfiles2]	
	}
	if [info exists badfiles1] {
		set msg "Some Files In This Listing Do Not Exist : Keep These ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set filelist [concat $filelist $badfiles1]
		}
	}
	if [info exists badfiles2] {
		set msg "Some Files In This Listing Are Not Soundfiles: Keep These ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set filelist [concat $filelist $badfiles2]
		}
	}
	if {![info exists filelist]} {
		return
	}
	set len [llength $filelist]
	if {($len <= 1) && ($len == $origlen)} {
		Inf "NO DUPLICATES TO REMOVE"
		return
	}
	set len_less_one [expr $len - 1]
	set n 0
	set dupl_removed 0
	while {$n < $len_less_one} {
		set fnam_n [lindex $filelist $n]
		set m $n
		incr m 
		while {$m < $len} {
			set fnam_m [lindex $filelist $m]
			if {[string match $fnam_n $fnam_m]} {
				set filelist [lreplace $filelist $m $m]
				set dupl_removed 1
				incr len -1
				incr len_less_one -1
			} else {
				incr m
			}
		}
		incr n
	}
	if {!$dupl_removed} {
		Inf "No Duplicates Found"
		if {$len == $origlen} {
			return
		}
	}
	if [catch {open $fnam "w"} zit] {
		Inf "Cannot Open File '$fnam' To Write The Sorted Data"	
		return
	}
	foreach listedfile $filelist {
		puts $zit $listedfile
	}
	close $zit
	Inf "Items Removed"
}

proc GetBigSnack {} {
	global evv
	set fnam [file join $evv(CDPRESOURCE_DIR) bigsnack$evv(CDP_EXT)]
	if [file exists $fnam] {
		return 1
	}
	return 0
}

proc SetBigSnack {on} {
	global big_snack evv
	set fnam [file join $evv(CDPRESOURCE_DIR) bigsnack$evv(CDP_EXT)]
	if {$on} {
		set big_snack 1
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Create File '$fnam' To Remember The Sound View Sizing For Next Session"
			} else {
				close $zit
			}
		}
	} else {
		set big_snack 0
		if [file exists $fnam] {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot Delete File '$fnam' To Remember The Sound View Sizing For Next Session"
			}
		}
	}
}

proc RemoveFrmSndlist {retain} {
	global wl pa wstk evv

	set got_list 0
	if {$retain} {
		set bigmsg "Select An Existing Textfile Listing Of Sounds, And Some Soundfiles To Retain In It"
	} else {
		set bigmsg "Select An Existing Textfile Listing Of Sounds, And Some Soundfiles To Remove From It"
	}
	set ilist [$wl curselection]
	if {[llength $ilist] < 2} {
		Inf $bigmsg
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[IsASndlist $pa($fnam,$evv(FTYP))]} {
			if {$got_list} {
				Inf $bigmsg
				return
			}
			set got_list 1
			set lfnam $fnam
		} elseif {$pa($fnam,$evv(FTYP)) != $evv(IS_A_SNDFILE)} {
			Inf $bigmsg
			return
		} else {
			lappend in_snds $fnam
		}
	}
	if {!$got_list || ![info exists in_snds]} {
		Inf $bigmsg
		return
	}			
	if [catch {open $lfnam "r"} zit] {
		Inf "Cannot Open File '$lfnam' To Read Soundfile Names Already Listed"
		return
	}
	while {[gets $zit line] >= 0} {
		set fnam [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[info exists txtlisted_snds] && ([lsearch $txtlisted_snds $fnam] >= 0)} {
			Inf "Remove Duplicated Sounds In Textlisting (e.g. $fnam) Before Proceeding"
			return
		}
		lappend txtlisted_snds $fnam
	}
	close $zit
	foreach fnam $in_snds {
		set k [lsearch $txtlisted_snds $fnam]
		if {$k < 0} {
			Inf "At Least One Highlighted Soundfile ($fnam) Is Not In The Highlighted Sndfile-Listing"
			return
		}
		if {$retain} {
			lappend nulist $fnam
		} else {
			set txtlisted_snds [lreplace $txtlisted_snds $k $k]
		}
	}
	if {$retain} {
		if {![info exists nulist]} {
			Inf "No List Of Sounds To Retain: Program Error"
			return
		}
		set txtlisted_snds $nulist
	}
	if [catch {open $lfnam "w"} zit] {
		Inf "Cannot Open File '$lfnam' To Write New Data"
		return
	}
	foreach fnam $txtlisted_snds {
		puts $zit $fnam
	}
	close $zit
	if {$retain} {
		Inf "Highlighted Soundfiles (Only) Have Been Retained In File '$lfnam'"
	} else {
		Inf "Highlighted Soundfiles Have Been Removed From File '$lfnam'"
	}
}

proc SetMixLastVals {} {
	global mix_last_preset evv
	set fnam [file join $evv(URES_DIR) mixlastvset$evv(CDP_EXT)]
	if {[info exists mix_last_preset]} {
		set mix_last_preset [expr !$mix_last_preset]
	} else {
		set mix_last_preset 1
	}
	set msg ""
	if {$mix_last_preset} {
		append msg "Mixing: Previous-Run Values Will Be Set As Initial Defaults"
		append msg "\n\n(Avoids Switching Back And Forth Between Mix-default-settings During A Session)."
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				append msg "\n\nCannot Create File '$fnam' To Remember This Change Of Mix-Defaults"
			}
			close $zit
		}
	} else {
		append msg "Mixing: Standard Default Values Will Be Set"
		append msg "\n\n(Change Only Takes Effect After You Run A Process Other Than Mixing)"
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				append msg "\n\nCannot Delete File '$fnam' To Remember This Change Of Mix-Defaults"
			}
		}
	}
	Inf $msg
}

proc GetMixLastVals {} {
	global mix_last_preset evv
	set fnam [file join $evv(URES_DIR) mixlastvset$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set mix_last_preset 1
	} else {
		set mix_last_preset 0
	}
}

#---- Redundant functionality: this item ensures that related info file no longer exists

proc GetDontShowWkspaceSave {} {
	global evv
	set fnam [file join $evv(URES_DIR) nowk_show$evv(CDP_EXT)]
	catch {file delete $fnam}
}

#---- Remember or set option to offer Memory-Stick backup at end of session

proc SetShowStick {} {
	global tostick evv
	set fnam [file join $evv(CDPRESOURCE_DIR) to_stick$evv(CDP_EXT)]
	if {[info exists tostick]} {
		unset tostick
	} else {
		set tostick 1
	}
	set msg ""
	if {[info exists tostick]} {
		append msg "The Option To Save To An External Drive (e.g. Memory Stick) Will Be Offered At Session End."
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				append msg "\n\nCannot Create File '$fnam' To Remember This For Next Session."
			}
			close $zit
		}
	} else {
		append msg "The Option To Save To An External Drive (e.g. Memory Stick) Will ~Not~ Be Offered At Session End."
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				append msg "\n\nCannot Delete File '$fnam' To Remember This For Next Session."
			}
		}
	}
	Inf $msg
}

proc GetShowStick {} {
	global tostick evv
	set fnam [file join $evv(CDPRESOURCE_DIR) to_stick$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set tostick 1
	} else {
		catch {unset tostick}
	}
}

#------ Put main mixfile used onto chosenfile list

proc GetMainMixfile {} {
	global chlist ch chcnt main_mix wl wstk bulk

	if {![info exists main_mix]} {
		Inf "No Previous Mixfile Established As Main Mixfile"
		MainMixButton 1
		return
	}
	if {[string length $main_mix(fnam)] <= 0} {
		MainMixButton 1
		return
	}
	if {(![file isfile $main_mix(fnam)]) || [file isdirectory $main_mix(fnam)]} {
		Inf "The Main Mixfile No Longer Exists"
		catch {unset main_mix}
		MainMixButton 1
		return
	}
	set pos [LstIndx $main_mix(fnam) $wl]
	if {$pos < 0} {
		set msg "Main Mix ([file rootname [file tail $main_mix(fnam)]]) Is Not On The Workspace : Use It Now ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			set msg "Retain ([file rootname [file tail $main_mix(fnam)]]) As The Main Mix ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -default yes -message $msg]
			if {$choice == "no"} {
				catch {unset main_mix}
				MainMixButton 1
				return
			}
			return
		}
		FileToWkspace $main_mix(fnam) 0 0 0 0 0
	} else {
		$wl delete $pos
		$wl insert 0 $main_mix(fnam)
		$wl yview moveto 0
	}
	DoChoiceBak
	ClearWkspaceSelectedFiles
	UnsetThumbnail
	set chcnt 0
	lappend chlist $main_mix(fnam)		;#	add to end of list
	$ch insert end $main_mix(fnam)		;#	add to end of display
	incr chcnt
	$ch xview moveto 0
	set bulk(run) 0
	GotoGetAProcess
}

proc Set_MainMix {} {
	global wl main_mix pa evv
	set ilist [$wl curselection]
	if {[llength $ilist] <= 0} {
		Inf "No Item Selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[info exists pa($fnam,$evv(FTYP))] && [IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
			set mfile $fnam
			break
		}
	}
	if {![info exists mfile]} {
		Inf "No Mixfile Has Been Selected"
		return
	}
	$wl delete $i
	$wl insert 0 $mfile
	$wl selection clear 0 end
	$wl selection set 0
	$wl yview moveto 0
	catch {unset main_mix}
	set main_mix(fnam) $mfile
	if {[FindMainMixSound]} {
		MainMixButton 0
	}
}

proc CheckAnalPlay {} {
	global no_analplay evv
	set ofil [file join $evv(URES_DIR) badpvplay$evv(CDP_EXT)]
	if {[file exists $ofil]} {
		set no_analplay 1
	} else {
		set no_analplay 0
	}
}

#---- Get, or Remember last mixfile used and its output snd

proc SetLastMixIO {} {
	global lastmixio evv
	set fnam [file join $evv(URES_DIR) lastmix_io$evv(CDP_EXT)]
	if {[info exists lastmixio]} {
		if [catch {open $fnam "w"} zit] {
			Inf "\n\nCannot Create File '$fnam' To Remember Last Mixfile Used And Its Output."
			return
		}
		puts $zit $lastmixio
		close $zit
	} elseif {[file exists $fnam]} {
		if [catch {file delete $fnam} zit] {
			Inf "\n\nCannot Delete File '$fnam' To Remember Last Mixfile Used And Its Output."
		}
	}
}

proc GetLastMixIO {} {
	global lastmixio evv
	set fnam [file join $evv(URES_DIR) lastmix_io$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "\n\nCannot Open File '$fnam' To Discover Last Mixfile Used And Its Output."
		return
	}
	gets $zit line
	close $zit
	set line [string trim $line]
	set line [split $line]
	foreach item $line {
		lappend lastmixio $item
	}
}

#---- Get, or Remember any defined main_mix used and its last parameter values

proc SaveMainMix {} {
	global main_mix evv
	set fnam [file join $evv(URES_DIR) mainmix$evv(CDP_EXT)]
	if {[info exists main_mix]} {
		if [catch {open $fnam "w"} zit] {
			Inf "\n\nCannot Create File '$fnam' To Remember Defined Main Mixfile."
			return
		}
		puts $zit $main_mix(fnam)
		if {[info exists main_mix(lastrunvals)]} {
			puts $zit $main_mix(lastrunvals)
			puts $zit $main_mix(penultrangetype)
		}
		if {[info exists main_mix(snd)]} {
			puts $zit $main_mix(snd)
		}
		close $zit
	} elseif {[file exists $fnam]} {
		if [catch {file delete $fnam} zit] {
			Inf "\n\nCannot Delete File '$fnam' To Remember That There Is No Longer Any Main Mix Defined."
		}
	}
}

proc GetMainMix {} {
	global main_mix wstk evv
	set fnam [file join $evv(URES_DIR) mainmix$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "\n\nCannot Open File '$fnam' To Get Details Of Main Mixfile."
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			lappend lines $line
		}
	}
	close $zit
	if {![info exists lines]} {
		catch {file delete $fnam} zit
		return
	}
	set mfnam [lindex $lines 0]
	if {![file exists $mfnam]} {
		if [catch {file delete $fnam} zit] {
			Inf "Cannot Delete File '$fnam' To Mark That Defined Main Mixfile ($mfnam) No Longer Exists"
		}
		return
	}
	set main_mix(fnam) $mfnam
	switch -- [llength $lines] {
		2 {
			set main_mix(snd)			  [lindex $lines 1]
		}
		3 {
			set main_mix(lastrunvals)	  [lindex $lines 1]
			set main_mix(penultrangetype) [lindex $lines 2]
		}
		4 {
			set main_mix(lastrunvals)	  [lindex $lines 1]
			set main_mix(penultrangetype) [lindex $lines 2]
			set main_mix(snd)			  [lindex $lines 3]
		}
	}
}

#------ Save and restore any MM set (in Qikedit)

proc GetMMLastVals {} {
	global qebeat evv
	set fnam [file join $evv(URES_DIR) qebeat$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			set val $line
			break
		}
	}
	close $zit
	if {![info exists val] || ![IsNumeric $val] || ($val <= $evv(FLTERR))} {
		return
	}
	set qebeat $val
}

proc SaveMMLastVals {} {
	global qebeat evv
	if {![info exists qebeat]} {
		return
	}
	set fnam [file join $evv(URES_DIR) qebeat$evv(CDP_EXT)]
	if [catch {open $fnam "w"} zit] {
		return
	}
	puts $zit $qebeat
	close $zit
}

#------ Save and restore any clicktrack line in a mixfile (for qikedit)

proc GetQikClikVals {} {
	global qiki qikclik evv
	set fnam [file join $evv(URES_DIR) qikclik$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	set cnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			set val $line
		} else {
			continue
		}
		if {$cnt == 0} {
			if {![regexp {^[0-9]+$} $val]} {
				close $zit
				catch {file delete $fnam}
				return
			}
			set qiki $val
		} else {
			set qikclik $val
		}
		incr cnt
	}
	close $zit
	if {$cnt != 2} {
		catch {unset qiki}
		catch {unset qikclik}
		catch {file delete $fnam}
	}
}

proc SaveQikClikVals {} {
	global qiki qikclik evv
	set fnam [file join $evv(URES_DIR) qikclik$evv(CDP_EXT)]
	if {![info exists qiki] || ![info exists qikclik]} {
		if {[file exists $fnam]} {
			catch {file delete $fnam}
		}
		return
	}
	if [catch {open $fnam "w"} zit] {
		return
	}
	puts $zit $qiki
	puts $zit $qikclik
	close $zit
}

#--- On Wkspace, get sndiles referenced in any textfile, to the workspace

proc GrabToWkspace_or_GetSndfilesInTxtfile {} {
	global wl chlist propfiles_list pa wstk nudir pr_speclistdir speclist_dir dl pr_5 evv
	if [info exists dl] {
		set ilist [$dl curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			set pr_5 $evv(DO_GRAB)
			return
		}
	}
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i == -1)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Single Textfile"
			return
		} else {
			set fnam [lindex $chlist 0]
		}
	} else {
		set fnam [$wl get $i]
	}
	set ftyp $pa($fnam,$evv(FTYP)) 
	if {!($ftyp & $evv(IS_A_TEXTFILE))} {
		Inf "Select A Textfile"
		return
	}
	set OK 0
	if {[IsAMixfileIncludingMultichan $ftyp]} {
		set OK 1
	} elseif {[IsASndlist $ftyp]} {
		set OK 1
	} else {
		set propext [GetTextfileExtension props]
		if {![string match $propext $evv(TEXT_EXT)]} {				;#	If using user-defined extension for properties-files
			if {[string match [file extension $fnam] $propext]} {	;#	Check file extension
				set OK 2
			}
		}
		if {[string match [file extension $fnam] ".bat"]} {	;#	Check file extension
			Inf "Files In Batchfiles May Not Have Soundfile Extensions, And Hence May Not Be Found In This Search"
			set OK 3
		}
		if {!$OK} {													;#	If a list of property files exists, is file on list
			if {[info exists propfiles_list] && ([lsearch $propfiles_list $fnam] >= 0)} {
				set OK 2
			}
		}
	}
	if {!$OK} {
		set msg "File '$fnam' Is Not Known To Contain Soundfile Names: Search It Anyway ?"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	set linecnt 0
	set unlistedcnt 0
	set goodcnt 0
	Block "Searching Textfile"
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {($linecnt == 0) && ($OK == 2)} {	;#	Skip first line of a properties file
			incr linecnt
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		catch {unset nuline}
		set line [split $line]
		foreach item $line {	
			set item [string trim $item]
			if {[string length $item] > 0} {
				lappend nuline $item
			}
		}
		if {![info exists nuline]} {
			incr linecnt
			continue
		}
		set cnt 0
		set line $nuline
		foreach val $line {
			set ffnam $val
			lappend ffnams $ffnam
			if {![file exists $ffnam]} {
				if {$OK != 3} {
					break		;#	go to next line
				}
				continue
			}
			set ftyp [FindFileType $ffnam]
			if {$ftyp != $evv(SNDFILE)} {
				continue
			}
			if {[LstIndx $ffnam $wl] < 0} {
				incr unlistedcnt				;#	Count sndfiles not already listed on wkspace
				lappend filelist $ffnam
			} else {
				lappend listed $ffnam
			}
			if {$OK != 3} {
				break
			}
		}
		incr linecnt							;#	Count sounfiles found in textfile
	}
	close $zit
	UnBlock
	if {$linecnt == 0} {
		set msg "No Soundfiles Listed In This Textfile"
		if {![info exists ffnams]} {
			Inf $msg
			return
		}
		append msg "\n\nDo You Want To Specify A Directory Where Soundfiles Might Be Found ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set nudir ""
		set f .speclistdir
		if [Dlg_Create  $f "SPECIFY DIRECTORY" "set pr_speclistdir 0" -borderwidth $evv(SBDR)] {
			set f1 [frame $f.1 -bd $evv(SBDR)]
			set f2 [frame $f.2 -bd $evv(SBDR)]
			button $f1.qu -text "Abandon" -command {set pr_speclistdir 0} -highlightbackground [option get . background {}]
			label $f1.ll -text "Use 'Get Directory' button to find Dir"
			button $f1.ok -text "Get Directory" -command {set pr_speclistdir 1} -highlightbackground [option get . background {}]
			entry $f2.ee -textvariable speclist_dir -width 0 -bd 0		;#	UNSEEN ENTRY BOX
			pack $f1.ok -side left -pady 2
			pack $f1.ll -side left -pady 20
			pack $f1.qu -side right -pady 2
			pack $f2.ee  -side left
			pack $f1 $f2 -side top -fill x -expand true
			wm resizable .speclistdir 1 1
			bind $f <Return> {set pr_speclistdir 1}
			bind $f <Escape> {set pr_speclistdir 0}
		}
		set speclist_dir ""
		raise $f
		set pr_speclistdir 0
		set finished 0
		My_Grab 0 $f pr_speclistdir
		while {!$finished} {
			tkwait variable pr_speclistdir
			if {$pr_speclistdir} {
				DoListingOfDirectories .speclistdir.2.ee
				if {([string length $speclist_dir] <= 0) || ![file isdirectory $speclist_dir]} {
					Inf "No Valid Directory Name Entered"
					continue
				}
				set nudir $speclist_dir
				break
			} else {
				break
			}
		}
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
		if {[string length $nudir] <= 0} {
			return
		}
		set testnudir [string tolower $nudir]
		set thisdir [string tolower [pwd]]
		if {[string first $thisdir $testnudir] == 0} {
			set k [string length $thisdir]
			incr k
			set nudir [string range $nudir $k end]
		}
		catch {unset filelist}
		foreach ffnam $ffnams {
			set nufnam [file join $nudir [file tail $ffnam]]
			if {![file exists $nufnam]} {
				Inf "File '$nufnam' Does Not Exist"
				return
			}
			lappend filelist $nufnam
		}
		set unlistedcnt [llength $filelist]
	}
	if {$unlistedcnt == 0} {
		if {![info exists listed]} {
			Inf "None Of The Files Listed Are (Existing) Soundfiles"
			return
		}
		set msg "All Listed Soundfiles Are Already On The Workspace: Highlight Them ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		$wl selection clear 0 end
		foreach fnam $listed {
			$wl selection set [LstIndx $fnam $wl]
		}
		return
	}
	set filelist [RemoveDuplicatesInList $filelist]
	set unlistedcnt [llength $filelist]
	set filelist [ReverseList $filelist]
	foreach ffnam $filelist {
		if {[FileToWkspace $ffnam 0 0 0 1 0] <= 0} {
			lappend badfiles $ffnam
		} else {
			incr goodcnt				;#	Count sndfiles succesfully loaded to workspace
		}
	}
	if {$goodcnt == 0} {
		Inf "Failed To Load To Workspace $unlistedcnt Sndfiles Listed In Textfile"
		return
	}
	if {$goodcnt != $unlistedcnt} {
		set msg "\n\nThe Following Listed Soundfiles Could Not Be Loaded To The Workspace"
		set bcnt 0
		foreach bfnam $badfiles {
			if {$bcnt >= 20} {
				append msg "\n\nAnd More"
				break
			}
			append msg "\n$bfnam"
			incr bcnt
		}
		Inf $msg
	}
	set i [LstIndx $fnam $wl]
	if {$i > 0} {
		$wl delete $i
		$wl insert 0 $fnam
	}
	$wl yview moveto 0.0
}

#------ Fix text-extension of mixfile

proc FixMixfileExtension {fnam ext} {

	set nufnam [file rootname $fnam]
	append nufnam $ext
	if {[RenameTextWkspaceFile $fnam $nufnam]} {
		if {[MixMRename $fnam $nufnam 0]} {
			MixMStore
		}
	}
}

#--- Scroll worksapce if highlighted item is not in view

proc AdjustWkspaceView {i} {
	global wl evv
	if {$i >= $evv(WKSPACE_HEIGHT)} {
		set kk [expr double($i) / double([$wl index end])]
		$wl yview moveto $kk
	} else {
		$wl yview moveto 0
	}
}

#------ Make a textlisting of chosen files list, to process one at a time

proc SetupOneAtATime {} {
	global chlist dupl_mix dupl_vbx dupl_txt pa evv oneatatime which_oneatatime panprocess

	if {[info exists panprocess]} {
		return
	}

	if {![info exists chlist]} {
		Inf "No Chosen Files"
		return
	}
	set len [llength $chlist]
	if {$len < 2} {
		if {$len == 1} {
			Inf "Only One File On Chosen Files List"
		} else {
			Inf "No Files On Chosen Files List"
		}
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen File List"
		return
	}
	set flcnt 0
	set flacnt 0
	foreach fnam $chlist {
		if {[info exists pa($fnam,$evv(FTYP))]} {
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				incr flcnt
			} elseif {$pa($fnam,$evv(FTYP)) == $evv(ANALFILE)} {
				incr flacnt
			}
		}
	}
	if {($flcnt != $len) && ($flacnt != $len)} {
		Inf "Not All Sounds Are Soundfiles"
		return
	}
	UnsetThumbnail
	catch {unset oneatatime}
	foreach fnam $chlist {
		lappend oneatatime $fnam
	}
	set which_oneatatime 0
	DoOneAtATime
}

#------ Make a textlisting of chosen files list, to process one at a time

proc DoOneAtATime {} {
	global chlist ch chcnt pa evv oneatatime which_oneatatime onpage_oneatatime

	if {![info exists oneatatime]} {
		Inf "No 'One At A Time' Listing Exists"
		catch {unset which_oneatatime}
		catch {unset onpage_oneatatime}
		return
	}
	set len [llength $oneatatime]
	if {$which_oneatatime >= $len} {
		Inf "That's All The Files"
		unset which_oneatatime
		unset oneatatime
		catch {unset onpage_oneatatime}
		return
	}
	set fnam [lindex $oneatatime $which_oneatatime]
	while {![file exists $fnam] || ![info exists pa($fnam,$evv(FTYP))]} {
		Inf "File '$fnam' Is No Longer On The Workspace"
		incr which_oneatatime
		if {$which_oneatatime >= $len} {
			Inf "That's All The Files"
			unset which_oneatatime
			unset oneatatime
			return
		}
		set fnam [lindex $oneatatime $which_oneatatime]
	}
	incr which_oneatatime
	DoChoiceBak
	ClearWkspaceSelectedFiles
	lappend chlist $fnam						;#	add to end of list
	$ch insert end $fnam						;#	add to end of display
	incr chcnt
	set onpage_oneatatime 1
}

#------ Make a textlisting of chosen files list, to process one at a time

proc DoOneAtATimeFromParampage {} {
	global chlist ch chcnt pa evv oneatatime which_oneatatime onpage_oneatatime papag qikmixset articvw

	catch {unset qikmixset}
	catch {file delete $articvw}

	if {![info exists oneatatime]} {
		Inf "No 'One At A Time' Listing Exists"
		catch {unset which_oneatatime}
		catch {unset onpage_oneatatime}
		$papag.parameters.zzz.newf config -text "To Wkspace" -command {GetNewFilesFromPpg}
		GetNewFilesFromPpg
		return
	}
	set len [llength $oneatatime]
	if {$which_oneatatime >= $len} {
		Inf "That's All The Files"
		unset which_oneatatime
		unset oneatatime
		catch {unset onpage_oneatatime}
		$papag.parameters.zzz.newf config -text "To Wkspace" -command {GetNewFilesFromPpg}
		GetNewFilesFromPpg
		return
	}
	set lastftyp  $pa([lindex $chlist 0],$evv(FTYP))
	set lastchans $pa([lindex $chlist 0],$evv(CHANS))
	set lastsrate $pa([lindex $chlist 0],$evv(SRATE))

	set fnam [lindex $oneatatime $which_oneatatime]
	while {![file exists $fnam] || ![info exists pa($fnam,$evv(FTYP))]} {
		Inf "File '$fnam' Is No Longer On The Workspace"
		incr which_oneatatime
		if {$which_oneatatime >= $len} {
			Inf "That's All The Files"
			unset which_oneatatime
			unset oneatatime
			catch {unset onpage_oneatatime}
			$papag.parameters.zzz.newf config -text "To Wkspace" -command {GetNewFilesFromPpg}
			GetNewFilesFromPpg
			return
		}
		set fnam [lindex $oneatatime $which_oneatatime]
	}
	set ftyp $pa($fnam,$evv(FTYP))				;#	Can't proceed if file NOT same type etc. as last
	set chans $pa($fnam,$evv(CHANS))
	set srate $pa($fnam,$evv(SRATE))
	if {($lastftyp != $ftyp) || ($lastchans != $chans) || ($lastsrate != $srate)} {
		catch {unset onpage_oneatatime}
		$papag.parameters.zzz.newf config -text "To Wkspace" -command {GetNewFilesFromPpg}
		GetNewFilesFromPpg
		return
	}
	incr which_oneatatime
	DoChoiceBak
	ClearWkspaceSelectedFiles
	lappend chlist $fnam						;#	add to end of list
	$ch insert end $fnam						;#	add to end of display
	incr chcnt
	OneAtATimeReconfigParamPage $fnam
	Inf "Got Next File"
}

proc GetPropsSearchProtocol {} {
	global search_for_propsfiles evv
	set fnam [file join $evv(CDPRESOURCE_DIR) propsearch$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set search_for_propsfiles 1
	} else {
		set search_for_propsfiles 0
	}
}

proc SetPropsSearchProtocol {} {
	global search_for_propsfiles evv
	set fnam [file join $evv(CDPRESOURCE_DIR) propsearch$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		catch {file delete $fnam}
		set search_for_propsfiles 0
	} else {
		if {![catch {open $fnam "w"}  zit]} {
			close $zit
		}
		set search_for_propsfiles 1
	}
}

proc HideFromWkspace {} {
	global ww wl rememd wstk total_wksp_cnt wksp_cnt
	set ilist [$wl curselection]
	if {![info exists ilist]} {
		Inf "No Files Selected"
		return
	}
	set len [llength $ilist]
	switch -- $len {
		0 {
			Inf "No Files Selected"
			return
		}
		1 {
			set i [lindex $ilist 0]
			if {$i == -1} {
				Inf "No Files Selected"
				return
			} else {
				set msg "Are You Sure You Want To Hide File '[$wl get $i]' ??"
			}
		}
		default {
			set msg "Are You Sure You Want To Hide These $len Files ??"
		}
	}
	set ilist [lsort -integer -decreasing $ilist]
	foreach i $ilist {
		set fnam [$wl get $i]
		set ff [file tail $fnam]					;#	get name without directory path
		if {![string match $ff $fnam]} {	 		;#	If has directory path, it's bakdup
			set msg2 "Can Only \"Hide\" Files In The Base Directory."
			append msg2 "\n\nFile '$fnam' Is Not In The Base Directory."
			append msg2 "\n\nSelect \"Files Which Are Already Backed Up\" TO REMOVE OTHER FILES."
			Inf $msg2
			return
		}
	}
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		PurgeArray $fnam
		RemoveFromChosenlist $fnam
		incr total_wksp_cnt -1
		incr wksp_cnt -1
		$wl delete $i
	}
	ForceVal $ww.1.a.endd.l.cnts.all $total_wksp_cnt
	ForceVal $ww.1.a.endd.l.cnts.new $wksp_cnt
	catch {unset rememd}
}

proc SaveFOFSeparator {} {
	global fof_separator evv
	set fnam [file join $evv(CDPRESOURCE_DIR) fofseparator$evv(CDP_EXT)]
	if {![info exists fof_separator]} {
		if {[file exists $fnam]} {
			catch {file delete $fnam}
		}
		return
	}
	if [catch {open $fnam "w"} zit] {
		return
	}
	puts $zit $fof_separator
	close $zit
}

proc GetFOFSeparator {} {
	global fof_separator evv
	set fnam [file join $evv(CDPRESOURCE_DIR) fofseparator$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set val $line
		if {[regexp {^[0-9]+$} $val] && ($val > 0)} {
			set fof_separator $val
		} else {
			unset val
		}
		break
	}
	close $zit
	if {![info exists val]} {
		Inf "Corrupted File '$fnam' : Deleting It"
		catch {file delete $fnam}
	}
}

#--- Retain and restore highlight state of wkspace, when setting directory

proc SaveWkstate {} {
	global wkstate wl
	catch {unset wkstate}
	set ilist [$wl curselection]
	if {([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
		set wkstate $ilist
	}
}

proc RestoreWkstate {} {
	global wkstate wl
	if {[info exists wkstate]} {
		$wl selection clear 0 end
		foreach i $wkstate {
			$wl selection set $i
		}
		unset wkstate
	}
}

proc ChangeMACFont {} {
	global evv mumacfnt

	set fnam [file join $evv(CDPRESOURCE_DIR) numacfnt$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set newmacfnt 1
		if [catch {file delete $fnam} zit] {
			Inf "Cannot Delete File '$fnam' To Change Font"
			return
		}
		set mumacfnt 0
	} else {
		set mumacfnt 0
		if [catch {open $fnam "w"} zit] {
			Inf "Cannot Create File '$fnam' To Change Font"
			return
		}
		set mumacfnt 1
	}
	set fnam [file join $evv(URES_DIR) $evv(USERENV)$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {file delete $fnam} zit] {
			Inf "Cannot Delete File '$fnam' To Overrule Previous User-Specified Interface Design Params"
			return
		}
	}
	Inf "Close And Restart The Loom To Use New Font"
}

#--- Control-0, Key to View Sound or textfiles, Control-e/E key to Edit textfiles, on wkspace

proc KeyViewWkspaceFile {edit} {
	global wl evv wstk propfiles_list
	set gotfile 0
	if {$edit} {
		set act Edit
	} else {
		set act View
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {
		Inf "No File Selected"
		return
	}
	if {[llength $ilist] > 1} {
		foreach i $ilist {
			set fnam [$wl get $i]
			set ftyp [FindFileType $fnam]	
			if {$ftyp & $evv(IS_A_TEXTFILE)} {
				set msg "$act File $fnam ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					$wl selection clear 0 end
					$wl selection set $i
					set gotfile 1
					break
				} else {
					Inf "Select A Single File To $act"	
					return
				}
			} elseif {($ftyp== $evv(SNDFILE)) && ($act == "View")} {
				set msg "View Soundfile $fnam ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					$wl selection clear 0 end
					$wl selection set $i
					set gotfile 1
					break
				} else {
					Inf "Select A Single File To View"	
					return
				}
			}
		}
	} else {
		set i [lindex $ilist 0]
		set fnam [$wl get $i]
		set ftyp [FindFileType $fnam]	
		if {($ftyp & $evv(IS_A_TEXTFILE)) || (($ftyp== $evv(SNDFILE)) && ($act == "View"))} {
			set gotfile 1
		}
	}
	if {!$gotfile} {
		if {$act == "View"} {
			Inf "Select A Viewable File"
		} else {
			Inf "Select A Textfile To $act"
		}
		return
	}
	if {[info exists propfiles_list] && ([lsearch $propfiles_list $fnam] >= 0)} {
		TabProps 0
		return
	}
	if {$edit} {
		Read_Textfile
		SetSel2 read
	} else {
		if {$ftyp == $evv(SNDFILE)} {
			ViewOutput
			SetSel2 view
		} else {
			SimpleDisplayTextfile $fnam
		}
	}
}

#------ AGAIN button for ANY/ALL MENU

proc SetSel3 {str} {
	global selcmd3 ww

	set selcmd3 $str

	switch -- $selcmd3 {
		aplha		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Alphabetic Sort"}
		ahpla		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Reverse Alphabetic Sort"}
		lleps		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Reverse Spelling Sort"}
		alphanodir	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Alphabetic Sort (Snds Only)"}
		ahplanodir	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Reverse Alphabetic Sort (Snds)"}
		llepsnodir	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Reverse Spelling Sort (Snds)"}
		sortstart	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Files Starting With String, To Top"}
		sortcontain  { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Files Containing String, To Top"}
		sortend		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Files Ending With String, To Top"}
		sortch		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Chosen Files To Top"}
		sortsys		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Soundsystem Files To Top & Sort"}
		sortsnd		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sound Files To Top & Sort"}
		sortanal	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Analysis Files To Top & Sort"}
		sortpch		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Pitch And Transpos Files To Top & Sort"}
		sortfmnt	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Formant Files To Top & Sort"}
		sortenv		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Envelope Files To Top & Sort"}
		sorttxt		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Text Files To Top & Sort"}
		sortbrk		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Breakpoint Files To Top & Sort"}
		sortmix		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Mix Files To Top & Sort"}
		sortmult	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Multichan Mix Files To Top & Sort"}
		sortsndlist	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sound-Listing Files To Top & Sort"}
		sortprop	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Properties Files To Top & Sort"}
		sortarge	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sort Snds, Largest Files First"}
		sortsmall	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sort Snds, Smallest  Files First"}
		sortbak		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Backed-Up Files To Top"}
		unbak		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Not-Backed-Up Files To Top"}
		sortnew		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Newest Files To Top"}
		sortold		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Oldest Files To Top"}
		sortnewsnd	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Newest Soundfiles To Top"}
		sortoldsnd	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Oldest Soundfiles To Top"}
		sortchorder	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sort As Chosen Files Order"}
		sortplorder	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sort As Playlist Order"}
		topsys		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Soundsystem Files To Top"}
		topsnd		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sound Files To Top"}
		topanal		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Analysis Files To Top"}
		toppch		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Pitch And Transpos Files To Top"}
		topfmnt		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Formant Files To Top"}
		topenv		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Envelope Files To Top"}
		toptxt		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Text Files To Top"}
		topbrk		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Breakpoint Files To Top"}
		topmix		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Mix Files To Top"}
		topmult		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Multichan Mix Files To Top"}
		topsndlist	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Sound-Listing Files To Top"}
		update		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Update Data On All Workspace Files"}
		selchos		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight All Chosen Files"}
		seldir		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Files In Directory Of Selected File"}
		seldirspec	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Files In Specified Directory"}
		selundir	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight All Unselected Files"}
		selunseldir	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Higlighted Files Not On Chosenlist"}
		selunbak	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight All Non Backed-Up Files"}
		selunbaksnd	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight All Non Backed-Up Sounds"}
		selbak		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight All Backed-Up Files"}
		selsnd		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Sound Files"}
		selsrate	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Sound Files With Odd Srates"}
		selpmark	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Sound Files With Pitchmarks"}
		selsndlist	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Soundfile Listings"}
		selprop		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Properties Files"}
		selanal		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Analysis Files"}
		selbatch	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Batch Files"}
		selenv		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Envelope Files (Binary)"}
		selfmnt		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Formant Files"}
		selmix		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Mix Files"}
		selmulti	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Multichannel Mix Files"}
		selinmix	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Sounds In Known Mixfiles"}
		selinmixun	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Un-Backed-Up Sounds In Known Mixfiles"}
		selpch		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Pitch Files (Binary)"}
		seltrans	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Transposition Files (Binary)"}
		seltxt		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Text Files"}
		selseg		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Files With Segment In Name"}
		selseghere	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Files With Segment In Specific Seg Of Name"}
		selsegsnd	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Snds With Segment In Specific Seg Of Name"}
		selsegend	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Snds With Name Ending In ..."}
		selsegstt	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Highlight Snds With Name Starting With ..."}
		selpos		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select By Position In Listing"}
		unsel		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Deselect All Files"}
		selmem		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Remember Selection"}
		selrecall	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Recall Selection"}
		clearbak	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Clear All Backed-Up Files"}
		clearunchos	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Clear All Backed-Up Files Except Chosen Files"}
		txtlist		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Make Textlist Of All Files"}
		txtlistsnd	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Make Textlist Of Soundfiles"}
		txtlistsndur { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Make Textlist Of Soundfiles & Durations"}
		txtlistsys	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "make Textlist Of Sound-System Files"}
		txtlistxt	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Make Textlist Of Text Files"}
		pmarkshow	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Display/Don't Display Pitch Marks"}
		pmarkhilite	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Hilite All Files With Pitchmarks"}
		creatxt		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Create A Textfile"}
		creabrk		 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Create A Brkpnt File"}
		selchan1	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select Mono Files"}
		selchan2	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select Stereo Files"}
		selchan4	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select 4-channel Files"}
		selchan5	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select 5-channel Files"}
		selchan7	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select 7-channel Files"}
		selchan8	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select 8-channel Files"}
		selchan16	 { $ww.1.a.endd.l.new.all.menu entryconfig 2 -label "Select 16-channel Files"}
	}
	$ww.1.a.endd.l.new.all.menu entryconfig 2 -command WkspaceAgain3
}

proc WkspaceAgain3 {} {
	global selcmd3 wl evv

	if {![info exists selcmd3]} {
		Inf "No Previous Command Used"
		return
	}
	switch -- $selcmd3 {
		aplha		 { SortListing $wl 0 }
		ahpla		 { SortListing $wl 1 }
		lleps		 { SortListing $wl 2 }
		alphanodir	 { SortListing $wl 3 }
		ahplanodir	 { SortListing $wl 4 }
		llepsnodir	 { SortListing $wl 5 }
		sortstart	 { StrSortWl 0 }
		sortcontain  { StrSortWl 1 }
		sortend		 { StrSortWl 2 }
		sortch		 { SortWl c }
		sortsys		 { SortListingType $wl t }
		sortsnd		 { SortListingType $wl s }
		sortanal	 { SortListingType $wl a }
		sortpch		 { SortListingType $wl p }
		sortfmnt	 { SortListingType $wl f }
		sortenv		 { SortListingType $wl e }
		sorttxt		 { SortListingType $wl T }
		sortbrk		 { SortListingType $wl b }
		sortmix		 { SortListingType $wl m }
		sortmult	 { SortListingType $wl q }
		sortsndlist  { SortListingType $wl k }
		sortprop	 { SortListingType $wl P }
		sortarge	 { SortWl bs }
		sortsmall	 { SortWl ss }
		sortbak		 { SortListingNew $wl b }
		unbak		 { SortListingNew $wl n }
		sortnew		 { SortWl r }
		sortold		 { SortWl o }
		sortnewsnd	 { SortWl rs }
		sortoldsnd	 { SortWl os }
		sortchorder  { SortWl ch }
		sortplorder  { SortWl ps }
		topsys		 { MoveListingType $wl t }
		topsnd		 { MoveListingType $wl s }
		topanal		 { MoveListingType $wl a }
		toppch		 { MoveListingType $wl p }
		topfmnt		 { MoveListingType $wl f }
		topenv		 { MoveListingType $wl e }
		toptxt		 { MoveListingType $wl T }
		topbrk		 { MoveListingType $wl b }
		topmix		 { MoveListingType $wl m }
		topmult		 { MoveListingType $wl q }
		topsndlist	 { MoveListingType $wl k }
		update		 { RefreshWorkspace }
		selchos		 { ChosSelect }
		seldir		 { SelectType sel }
		seldirspec	 { SelectSpecDir }
		selundir	 { InvertSelect }
		selunseldir	 { InvertSelectChosen }
		selunbak	 { SelectType nonbak }
		selunbaksnd	 { SelectType nonbaksnd }
		selbak		 { SelectType bak }
		selsnd		 { SelectType snd }
		selsrate	 { SelectType srate }
		selpmark	 { HilitePmarks $wl }
		selsndlist	 { SelectType sndlist }
		selprop		 { SelectType props }
		selanal		 { SelectType anal }
		selbatch	 { SelectType batch }
		selenv		 { SelectType envel }
		selfmnt		 { SelectType formant }
		selmix		 { SelectType mix }
		selmulti	 { SelectType multimix }
		selinmix	 { SelectType inmix }
		selinmixun	 { SelectType inmixun }
		selpch		 { SelectType pitch }
		seltrans	 { SelectType transpos }
		seltxt		 { SelectType text }
		selseg		 { $wl selection clear 0 end; MassageFilenames hiliteseg 0 $wl }
		selseghere	 { $wl selection clear 0 end; MassageFilenames selfiles 0 $wl  }
		selsegsnd	 { $wl selection clear 0 end; MassageFilenames selfiles 1 $wl  }
		selsegend	 { $wl selection clear 0 end; MassageFilenames endnames 2 $wl  }
		selsegstt	 { $wl selection clear 0 end; MassageFilenames sttnames 2 $wl  }
		selpos		 { ListingPosition $wl }
		unsel		 { $wl selection clear 0 end }
		selmem		 { WkspaceSelectionSave }
		selrecall	 { WkspaceSelectionRecall }
		clearbak	 { ClearWkspace 0 }
		clearunchos	 { ClearWkspace 1 }
		txtlist		 { WkToFile all 0 }
		txtlistsnd	 { WkToFile snd 0 }
		txtlistsndur { WkToFile sndur 0 }
		txtlistsys	 { WkToFile sys 0 }
		txtlistxt	 { WkToFile txt 0 }
		pmarkshow	 { SetShowPmarks }
		pmarkhilite	 { HilitePmarks $wl }
		creatxt		 { Create_Textfile }
		creabrk		 { Create_Brkfile }
		selchan1	 { SelectChans 1 }
		selchan2	 { SelectChans 2 }
		selchan4	 { SelectChans 4 }
		selchan5	 { SelectChans 5 }
		selchan7	 { SelectChans 7 }
		selchan8	 { SelectChans 8 }
		selchan16	 { SelectChans 16 }
		default	{ Inf "UNKNOWN COMMAND" }
	}
}

proc SetSel4 {str} {
	global selcmd4 new_user_text_extensions user_text_extensions ww nessinit evv

	set selcmd4 $str
;# 2023
	if {[string match $selcmd4 [string range $evv(ANALFILE_EXT) 1 end]]} {
		$ww.1.b.buttons2.lis.menu entryconfig 2 -label "ANALYSIS FILES ONLY"
	} else {
	    switch -- $selcmd4 {
		    lastdir		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Previous Directory"}
		    lastlist	{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Previous Listing"}
		    subdirs		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Subdirectories Only"}
		    subtldirs	{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Other Subdirectories"}
		    nosubs		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "No Subdirectories"}
		    search		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Search By Specified String"}
		    nodir		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Don't Show Directory Path"}
		    home		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Home Directory"}
		    endnum		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Sort On Number At End Of Name"}
		    endnumr		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Reverse Sort On Number At End Of Name"}
		    sttnum		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Sort On Number At Start Of Name"}
		    sttnumr		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Reverse Sort On Number At Start Of Name"}
		    srtdate		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Sort: Oldest To Top"}
		    srtetad		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Sort: Newest To Top"}
		    aif			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".aif Files Only"}
		    aiff		{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".aiff Files Only"}
;#2023, RWD: removed ref to .ana
		    bat			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".bat Files Only"}
		    evl			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".evl Files Only"}
		    for			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".for Files Only"}
		    frq			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".frq Files Only"}
		    trn			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".trn Files Only"}
		    txt			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".txt Files Only"}
		    wav			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label ".wav Files Only"}
		    1			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Mono Files"}
		    2			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "Stereo Files"}
		    4			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "4 Channel Files"}
		    5			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "5 Channel Files"}
		    7			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "7 Channel Files"}
		    8			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "8 Channel Files"}
		    16			{ $ww.1.b.buttons2.lis.menu entryconfig 2 -label "16 Channel Files"}
		    default {
			    if {[info exists nessinit]} {
				    set nessstr [string range $evv(NESS_EXT) 1 end]
				    if {[string match $selcmd4 $nessstr]} {
					    set nessstr $evv(NESS_EXT)
					    append nessstr " Files Only"
					    $ww.1.b.buttons2.lis.menu entryconfig 2 -label "$nessstr"
				    }
			    }
			    if {[info exists new_user_text_extensions]} {
				    foreach item $new_user_text_extensions {
					    set xitem [string range $item 1 end]
					    if {[string match -nocase $str $xitem]} {
						    $ww.1.b.buttons2.lis.menu entryconfig 2 -label "$item Files Only"
					    }
				    }
			    } elseif {[info exists user_text_extensions]} {
				    foreach item $user_text_extensions {
					    set xitem [string range $item 1 end]
					    if {[string match -nocase $str $xitem]} {
						    $ww.1.b.buttons2.lis.menu entryconfig 2 -label "$item Files Only"
					    }
				    }
			    }
		    }
		}
	}
	$ww.1.b.buttons2.lis.menu entryconfig 2 -command WkspaceAgain4
}

proc WkspaceAgain4 {} {
	global selcmd4 new_user_text_extensions user_text_extensions wl evv nessinit

	if {![info exists selcmd4]} {
		Inf "No Previous Command Used"
		return
	}
	switch -- $selcmd4 {
		lastdir	 { GetLastDir; return }
		lastlist { GetPreviousDir; return }
		subdirs	 { GetSubdirNames; return }
		subtldirs { GetThisLevelSubdirNames; return }
		nosubs	 { NoSubdirNames;  return }
		search	 { StrGetDl;	   return }
		nodir	 { HiddenDirname;  return }
		home	 { LoadHomeDirectory; return }
		endnum	 { SortDir 1 0; return }
		endnumr	 { SortDir 1 1; return }
		sttnum	 { SortDir 0 0; return }
		sttnumr	 { SortDir 0 1; return }
		srtdate	 { SortDirDate 0; return }
		srtetad	 { SortDirDate 1; return }
		aif		 { GetDirExt aif;  return  }
		aiff	 { GetDirExt aiff; return  }
		ana		 {
;# 2023
				   GetDirExt [string range $evv(ANALFILE_EXT) 1 end]
				   return
				 }
		bat		 { GetDirExt bat;  return  }
		evl		 { GetDirExt evl;  return  }
		for		 { GetDirExt for;  return  }
		frq		 { GetDirExt frq;  return  }
		trn		 { GetDirExt trn;  return  }
		txt		 { GetDirExt txt;  return  }
		wav		 { GetDirExt wav;  return  }
		1		 { GetDirChan 1;  return  }
		2		 { GetDirChan 2;  return  }
		4		 { GetDirChan 4;  return  }
		5		 { GetDirChan 5;  return  }
		7		 { GetDirChan 7;  return  }
		8		 { GetDirChan 8;  return  }
		16		 { GetDirChan 16; return  }
		default {
			if {[info exists nessinit]} {
				set nessstr [string range $evv(NESS_EXT) 1 end]]
				if {[string match $selcmd4 $nessstr]} {
					GetDirExt $nessstr
					return
				}
			}
		}
	}
	if {[info exists new_user_text_extensions]} {
		foreach item $new_user_text_extensions {
			set xitem [string range $item 1 end]
			if {[string match -nocase $xitem $selcmd4]} {
				GetDirExt $xitem
				return
			}
		}
	} elseif {[info exists user_text_extensions]} {
		foreach item $user_text_extensions {
			set xitem [string range $item 1 end]
			if {[string match -nocase $xitem $selcmd4]} {
				GetDirExt $xitem
				return
			}
		}
	}
}

#--- Where are items on menus on Wkspace ??

proc WkWhich {} {
	global pr_wkwhich wkw evv

	set f .wkwhich
	if [Dlg_Create $f "WHICH MENU ??" "set pr_wkwhich 0" -borderwidth $evv(SBDR)] {
		frame $f.1
		frame $f.2
		button $f.1.ok -text OK -command "set pr_wkwhich 1" -highlightbackground [option get . background {}]
		label $f.1.ll -text "Hit 'D' for items starting with 'D' etc." -fg $evv(SPECIAL)
		pack $f.1.ok -side left
		pack $f.1.ll -side right -padx 10
		set wkw [Scrolled_Canvas $f.2.c -width 600 -height 470 -scrollregion {0 0 500 4800}]
		pack $f.2.c -fill both -expand true
		set fi [frame $wkw.fi -bd 2]
		$wkw create window 0 0 -anchor nw -window $fi
		frame $fi.ve1 -width 1 -bg $evv(POINT)
		grid $fi.ve1 -row 2 -column 1 -rowspan 244 -sticky ns
		frame $fi.ve3 -width 1 -bg $evv(POINT)
		grid $fi.ve3 -row 2 -column 3 -rowspan 244 -sticky ns
		frame $fi.ve5 -width 1 -bg $evv(POINT)
		grid $fi.ve5 -row 2 -column 5 -rowspan 244 -sticky ns
		frame $fi.ve00 -height 1 -bg $evv(POINT)
		grid $fi.ve00 -row 1 -column 0 -columnspan 7 -sticky ew
		frame $fi.ve0 -height 1 -bg $evv(POINT)
		grid $fi.ve0 -row 3 -column 0 -columnspan 7 -sticky ew

		Whichgrid "ALSO SEE KEYBOARD SHORTCUTS" 		"under the \"K\" Key" 		"" 								"" 					0	$fi
		Whichgrid "ACTION" 								"MENU or BUTTON" 			"ROUTE" 						"WHERE" 			2	$fi
		Whichgrid "Background List, add to notebook" 	"Notebook"  				"" 								"Top of Page" 		3	$fi
		Whichgrid "Background List, containing sound" 	"Selected Files Only"  		"" 								"Above Workspace" 	4	$fi
		Whichgrid "Background List, Find File in" 		"Selected Files Only" 		"Find File" 					"Above Workspace" 	5	$fi
		Whichgrid "Backed up files, highlight" 			"Any/All"  					"" 								"Above Workspace" 	6	$fi
		Whichgrid "Backup New Files" 					"Backup Selected Files"  "" 							"Above Workspace" 	7	$fi
		Whichgrid "Back up  Notebook" 					"Notebook"  				"" 								"Top of Page" 		8	$fi
		Whichgrid "Batch File, Change" 					"Batchfiles"  				"" 								"Top of Page" 		9	$fi
		Whichgrid "Batch File, Create" 					"Batchfiles" 				"" 								"Top of Page" 		10	$fi
		Whichgrid "Batch File, Edit" 					"Batchfiles" 				"" 								"Top of Page" 		11	$fi
		Whichgrid "Batch File, Run" 					"Batchfiles" 				"" 								"Top of Page" 		12	$fi
		Whichgrid "Batch File, Syntax" 					"Batchfiles" 			 	"Create Batchfile-->Syntax" 	"Top of Page" 		13	$fi
		Whichgrid "Batch File, Grab Sounds in" 			"Batchfiles" 				"" 								"Top of Page" 		14	$fi
		Whichgrid "Batch File, remember process in a "  "Go to ParametersPage"  	"" 								"" 					15	$fi
		Whichgrid "Calculator" 							"Calculator"  				"" 								"Top of Page" 		16	$fi
		Whichgrid "Channel Count of File" 				"Selected Files Only"   	"Properties" 					"Above Workspace" 	17	$fi
		Whichgrid "Channel Count Chosen of File" 		"Play:Read:Props"  			"" 								"Above Chosen Lists" 18	$fi
		Whichgrid "Choose Files" 						"Select Buttons" 			"" 								"Below Workspace" 	19	$fi
		Whichgrid "Choose Selected Files" 				"Selected Files Only"  		"" 								"Above Workspace" 	20	$fi
		Whichgrid "Chosen Files, insert snds" 			"Get/Mod"  					"" 								"Above Chosen Lists" 21	$fi
		Whichgrid "Chosen Files, reorder" 				"Reorder" 					"" 								"Above Chosen List" 22	$fi
		Whichgrid "Chosen Files, Randomise" 			"Reorder"  					"" 								"Above Chosen List" 23	$fi
		Whichgrid "Chosen Files, Remove types of" 		"Reorder"  					"" 								"Above Chosen List" 24	$fi
		Whichgrid "Chosen Files, Select types of" 		"Get/Mod"  					"" 								"Above Chosen List" 25	$fi
		Whichgrid "Chosen Files, Sort" 					"Reorder"  					"" 								"Above Chosen List" 26	$fi
		Whichgrid "Chosen files to Textfile"  			"Play:Read:Props"  			"" 								"Above Chosen Lists" 27	$fi
		Whichgrid "Clean Sources" 						"Music Testbed" 			"Cleaning Kit" 					"Top Left" 			28	$fi
		Whichgrid "Clear, selected files" 				"Selected Files Only"  		"" 								"Above Workspace" 	29	$fi
		Whichgrid "Clear All Backed-up Files" 			"Any/All"  					"" 								"Above Workspace" 	30	$fi
		Whichgrid "Clear Selected Backed-up Files" 		"Selected Files Only"  		"" 								"Above Workspace" 	31	$fi
		Whichgrid "Clear, Workspace" 					"Clear" 					"" 								"Above Chosen List" 32	$fi
		Whichgrid "Colour of interface" 				"System State"  			"" 								"Top Right of Page" 33	$fi
		Whichgrid "Compare Textfiles" 					"Selected Files of Type"          	"Textfiles" 					"Above Workspace" 	34	$fi
		Whichgrid "Compare Soundfile" 					"Process 	 etc." 			"" 								"Top of Page" 		35	$fi
		Whichgrid "Concert A" 							"\"A\""  					"" 								"Above Workspace" 	36	$fi
		Whichgrid "Copy Textfiles" 						"Selected Files of Type"           	"Textfiles" 					"Above Workspace" 	37	$fi
		Whichgrid "Convert, Mono to Stereo" 			"Get/Mod"  					"" 								"Above Chosen Lists" 38	$fi
		Whichgrid "Count, selected files"				"Selected Files Only"  		"" 								"Above Workspace" 	39	$fi
		Whichgrid "Create Brkpnt file" 					"Any/All"  					"" 								"Above Workspace" 	40	$fi
		Whichgrid "Create Sound" 						"Process"  					"" 								"Top of Page" 		41	$fi
		Whichgrid "Create Textfile" 					"Any/All"  					"" 								"Above Workspace" 	42	$fi
		Whichgrid "" 									"Go to Parameters Page" 	"Make File" 					"" 					43	$fi
		Whichgrid "Cut and Paste filename" 				"Selected Files Only"  		"" 								"Above Workspace" 	44	$fi
		Whichgrid "Delete Files" 						"Any/All"  					"" 								"Above Workspace" 	45	$fi
		Whichgrid "Delete Selected Files" 				"Selected Files Only"  		"" 								"Above Workspace" 	46	$fi
		Whichgrid "Destroy Files" 						"Any/All"  					"" 								"Above Workspace" 	47	$fi
		Whichgrid "Destroy Selected Files" 				"Selected Files Only"  		"" 								"Above Workspace" 	48	$fi
		Whichgrid "Directories, compare" 				"System State"  			"" 								"Top Right of Page" 49	$fi
		Whichgrid "Directories, Empty  manage" 			"System State"  			"" 								"Top Right of Page" 50	$fi
		Whichgrid "Directories, for backup, edit" 		"System State"  			"" 								"Top Right of Page" 51	$fi
		Whichgrid "Directories, for backup, select" 	"Entry Box" 				"" 								"Top Right of Page" 52	$fi
		Whichgrid "Directories, Highlight files in" 	"Any/All"  					"" 								"Above Workspace" 	53	$fi
		Whichgrid "Directories, Recent List, Edit" 		"System State"  			"" 								"Top Right of Page" 54	$fi
		Whichgrid "Directories, Recent List, Get" 		"Find Directory"  			"" 								"Top Right of Page" 55	$fi
		Whichgrid "Directory for programs" 				"System State"  			"" 								"Top Right of Page" 56	$fi
		Whichgrid "Directory, move to new" 				"Selected Files Only"  		"" 								"Above Workspace" 	57	$fi
		Whichgrid "Directory Name, add to notebook" 	"Notebook"  				"" 								"Top of Page" 		58	$fi
		Whichgrid "Disk Space available" 				"System State"  			"" 								"Top Right of Page" 59	$fi
		Whichgrid "Duplicate Textfiles" 				"Selected Files of Type"      	"Textfiles" 					"Above Workspace" 	60	$fi
		Whichgrid "Duration, create" 					"Duration"  				"" 								"Top of Page" 		61	$fi
		Whichgrid "Duration of Chosen File" 			"Play:Read:Props"  			"" 								"Above Chosen Lists" 62	$fi
		Whichgrid "Duration of File" 					"Selected Files Only"   	"Properties" 					"Above Workspace" 	63	$fi
		Whichgrid "Duration Total of Chosen Files" 		"Play:Read:Props"  			"" 								"Above Chosen Lists" 64	$fi
		Whichgrid "Edit Sound" 							"Go to Process Page" 		"" 								"Top of Page" 		65	$fi
		Whichgrid "Edit Textfile" 						"Selected Files of Type"      	"Textfiles" 					"Above Workspace" 	66	$fi
		Whichgrid ""     								"Go to Parameters Page" 	"Get File-->Edit" 				"" 					67	$fi
		Whichgrid "Envelopes, Loudness" 				"Music Testbed" 			"Envelopes" 					"Top Left" 			68	$fi
		Whichgrid ""     								"Process"  					"Etc..." 						"Top Left" 			69	$fi
		Whichgrid "External Drives" 					"System State"  			"" 								"Top Right of Page" 70	$fi
		Whichgrid "File extension, Change" 				"Selected Files Only"   	"Rename" 						"Above Workspace" 	71	$fi
		Whichgrid "Filename, add to notebook" 			"Notebook"  				"" 								"Top of Page" 		72	$fi
		Whichgrid "Filename, extensions" 				"System State"  			"" 								"Top Right of Page" 73	$fi
		Whichgrid "Filenames, recent, edit list" 		"System State"  			"" 								"Top Right of Page" 74	$fi
		Whichgrid "Files, Delete" 						"Any/All"  					"" 								"Above Workspace" 	75	$fi
		Whichgrid "Files, Destroy" 						"Any/All"  					"" 								"Above Workspace" 	76	$fi
		Whichgrid "Files, Properties of" 				"Selected Files Only"  		"" 								"Above Workspace" 	77	$fi
		Whichgrid "Filter files, display resonance" 	"Selected Files of Type"      	"Filter Files" 					"Above Workspace" 	78	$fi
		Whichgrid "Find File, in Background List" 		"Selected Files Only"   	"Find File" 					"Above Workspace" 	79	$fi
		Whichgrid "Find File, in History" 				"Selected Files Only" 		"Find File" 					"Above Workspace" 	80	$fi
		Whichgrid "Find File, in Logs" 					"Selected Files Only" 		"Find File" 					"Above Workspace" 	81	$fi
		Whichgrid "Find File, in Mixfiles" 				"Selected Files Only" 		"Find File" 					"Above Workspace" 	82	$fi
		Whichgrid "Find File, in Notebook" 				"Notebook"  				"" 								"Top of Page" 		83	$fi
#MOVED TO LEFT
#		Whichgrid "Finish" 								"End Session"  				"" 								"Top Right" 		84	$fi
		Whichgrid "Finish" 								"End Session"  				"" 								"Top Left" 			84	$fi
		Whichgrid "Harmony Workshop" 					"Music Testbed" 			"Harmony Workshop" 				"Top Left" 			85	$fi
		Whichgrid "Hear Pitch" 							"\"A\""  					"" 								"Above Workspace" 	86	$fi
		Whichgrid "History, Find File in" 				"Selected Files Only"   	"Find File" 					"Above Workspace" 	87	$fi
		Whichgrid "History of Sessions, edit" 			"System State"  			"" 								"Top Right of Page" 88	$fi
		Whichgrid "History of Sessions, recall act" 	"Recall Action"  			"" 								"Top of Page" 		89	$fi
		Whichgrid "History of Sessions, search" 		"System State"  			"" 								"Top Right of Page" 90	$fi
		Whichgrid ""     								"Recall Action"    			"Search All Logs" 				"Top of Page" 		91	$fi
		Whichgrid "History of Sessions, see" 			"System State"  			"" 								"Top Right of Page" 92	$fi
		Whichgrid "Instrument, Create" 					"Instrument"  				"" 								"Top of Page" 		93	$fi
		Whichgrid "Instruments, Reinstall" 				"System State"  			"" 								"Top Right of Page" 94	$fi
		Whichgrid "Instrument, Run" 					"Go to ProcessPage"  		"Instruments Panel" 			"" 					95	$fi
		Whichgrid "Interface, Colour Style" 			"System State"  			"" 								"Top Right of Page" 96	$fi
		Whichgrid "Interpolate Between Sounds" 			"Music Testbed" 			"Interpolation Workshop" 		"Top Left" 			97	$fi
		Whichgrid "Logs, Find File in"  				"Selected Files Only"   	"Find File" 					"Above Workspace" 	98	$fi
		Whichgrid "Logs of Sessions, edit" 				"System State"  			"" 								"Top Right of Page" 99	$fi
		Whichgrid "Logs of Sessions, recall act" 		"Recall Action"  			"" 								"Top of Page" 		100	$fi
		Whichgrid "Logs of Sessions, search" 			"System State"  			"" 								"Top Right of Page" 101	$fi
		Whichgrid ""     								"Recall Action"    			"Search All Logs" 				"Top of Page" 		102	$fi
		Whichgrid "Logs of Sessions, see" 				"System State"  			"" 								"Top Right of Page" 103	$fi
		Whichgrid "Loudness" 							"Selected Files Only"   	"Properties" 					"Above Workspace" 	104	$fi
		Whichgrid "Loudness of Chosen File" 			"Play:Read:Props"  			"" 								"Above Chosen Lists" 105	$fi
		Whichgrid "Loudness, Max of Chosen Files" 		"Play:Read:Props"  			"" 								"Above Chosen Lists" 106	$fi
		Whichgrid "Main Mix, set file as" 				"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	107	$fi
		Whichgrid "MIDI input device, set/change" 		"System State"  				"" 							"Top Right of Page" 108	$fi
		Whichgrid "Maximum Loudness of Chosen Files" 	"Play:Read:Props"  			"" 								"Above Chosen Lists" 109	$fi
		Whichgrid "Mixfiles, add/replace sounds" 		"Get/Mod"  					"" 								"Above Chosen Lists" 110	$fi
		Whichgrid ""     								"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	111	$fi
		Whichgrid "Mixfile, alter" 						"Selected Files of Type"    	"Mixfiles" 						"Above Workspace" 	112	$fi
		Whichgrid ""     								"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	113	$fi
		Whichgrid "Mixfiles, get last used" 			"Get/Mod"  					"" 								"Above Chosen Lists" 114	$fi
		Whichgrid "Mixfile, info" 						"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	115	$fi
		Whichgrid "Mixfile, is sound in any known" 		"Selected Files of Type"    	"Mixfiles" 						"Above Workspace" 	116	$fi
		Whichgrid "Mixfiles, Find File in"  			"Selected Files Only"   	"Find File" 					"Above Workspace" 	117	$fi
		Whichgrid "Mixfile, hilite snds on wkspace" 	"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	118	$fi
		Whichgrid "Mixfiles, get main mix" 				"Get/Mod"  					"" 								"Above Chosen Lists" 119	$fi
		Whichgrid "Mixfile, set as Main Mix" 			"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	120	$fi
		Whichgrid "Mixfile, sounds to workspace" 		"Selected Files of Type"    	"Mixfiles" 						"Above Workspace" 	121	$fi
		Whichgrid "Mono files, choose" 					"Get/Mod"  					"" 								"Above Chosen Lists" 122	$fi
		Whichgrid "Move files of type to top" 			"Any/All"  					"" 								"Above Workspace" 	124	$fi
		Whichgrid "Move Selected Files" 				"Selected Files Only"   	"Sort" 							"Above Workspace" 	125	$fi
		Whichgrid "New User Help, disable" 				"New User Help"  			"Disable" 						"Top of Page" 		126	$fi
		Whichgrid "New User Help, reinstall" 			"System State"  			"" 								"Top Right of Page" 127	$fi
		Whichgrid "Notebook, make entry" 				"Notebook"  				"" 								"Top of Page" 		128	$fi
		Whichgrid "Notebook, clear"						"Notebook"	 				" "								" Top of Page" 		129	$fi
		Whichgrid "Notebook, see latest entry" 			"Notebook"  				"" 								"Top of Page" 		130	$fi
		Whichgrid "Notebook, add filenames to" 			"Notebook"  				"" 								"Top of Page" 		131	$fi
		Whichgrid "Notebook, add directory to" 			"Notebook"  				"" 								"Top of Page" 		132	$fi
		Whichgrid "Notebook, add backgd list" 			"Notebook"  				"" 								"Top of Page" 		133	$fi
		Whichgrid "Orchestra File, change" 				"Selected Files of Type"      	"Lists Of Soundfiles" 			"Above Workspace" 	134	$fi
		Whichgrid "Orchestra File, Snds to Chosen" 		"Selected Files of Type"    	"Lists Of Soundfiles" 			"Above Workspace" 	135	$fi
		Whichgrid "Orchestra File, snds to wkspace" 	"Selected Files of Type"    	"Lists Of Soundfiles" 			"Above Workspace" 	136	$fi
		Whichgrid "Order, Chosen Files" 				"Reorder"  					"" 								"Above Chosen List" 137	$fi
		Whichgrid "Order, Reverse  Selected Files" 		"Selected Files Only"   	"Sort" 							"Above Workspace" 	138	$fi
		Whichgrid "Origins of files" 					"Selected Files Only" 		"Properties" 					"Above Workspace" 	139	$fi
		Whichgrid "Overwrite File" 						"Selected Files Only"   	"Rename" 						"Above Workspace" 	140	$fi
		Whichgrid "Pitch Data operations" 				"Music Testbed" 			"Pitch Data Operations" 		"Top Left" 			141	$fi
		Whichgrid "Pitch marks" 						"Selected Files Only"  		"" 								"Above Workspace" 	142	$fi
		Whichgrid ""     								"Music Testbed" 			"Pitch Marks   Harmonic Field" 	"Top Left" 			143	$fi
		Whichgrid "Pitch marks, display, or not" 		"Any/All"  					"" 								"Above Workspace" 	144	$fi
		Whichgrid "Play All, Sounds in listfile" 		"Selected Files of Type"      	"Lists Of Soundfiles" 			"Above Workspace" 	145	$fi
		Whichgrid "Play All, Sounds Chosen" 			"Play:Read:Props"  			"" 								"Above Chosen List Left" 146	$fi
		Whichgrid "Play Command" 						"System State"  			"" 								"Top Right of Page" 147	$fi
		Whichgrid "Play Next, Sounds in listfile" 		"Selected Files of Type"      	"Lists Of Soundfiles" 			"Above Workspace" 	148	$fi
		Whichgrid "Play Pitch" 							"\"A\""  					"" 								"Above Workspace" 	149	$fi
		Whichgrid "Play Selected Sounds" 				"Selected Files of Type"      	"Soundfiles" 					"Above Workspace" 	150	$fi
		Whichgrid "Play Sounds" 						"Play Sounds"  				"" 								"Above Workspace" 	151	$fi
		Whichgrid "Play Sounds in Directory List" 		"Play:Read"  				"" 								"Above Directory List Right" 152	$fi
		Whichgrid "Play Sounds in Chosen List" 			"Play:Read:Props"  			"" 								"Above Chosen List Left" 153	$fi
		Whichgrid "Previous Chosen List, restore" 		"Previous Choices"  		"" 								"Above Chosen Lists" 154	$fi
		Whichgrid "Previous Chosen Lists, recall" 		"Recall"  					"" 								"Above Chosen Lists" 155	$fi
		Whichgrid "Previous Workspaces, restore" 		"Recall"  					"" 								"Above Workspace" 	156	$fi
		Whichgrid "Previous Workspaces, edit" 			"System State"  			"" 								"Top Right of Page" 157	$fi
		Whichgrid "Program directory" 					"System State"  			"" 								"Top Right of Page" 158	$fi
		Whichgrid "Properties Files" 					"Music Testbed" 			"Properties Files" 				"Top Left" 			159	$fi
		Whichgrid "Properties of Files" 				"Selected Files Only" 		"Properties" 					"Above Workspace" 	160	$fi
		Whichgrid "Properties of Chosen Files" 			"Play:Read:Props"  			"" 								"Above Chosen Lists" 161	$fi
		Whichgrid "Randomise Chosen Files" 				"Reorder"  					"" 								"Above Chosen List" 162	$fi
		Whichgrid "Read Chosen Textfile   s" 			"Play:Read:Props"  			"" 								"Above Chosen Lists" 163	$fi
		Whichgrid "Recall, previous workspace" 			"Recall"  					"" 								"Above Workspace" 	164	$fi
		Whichgrid "Recall, previous chosen list" 		"Recall"  					"" 								"Above Chosen List" 165	$fi
		Whichgrid "Recall, previous patch" 				"Go To Parameters Page"  	"" 								"" 					166	$fi
		Whichgrid "Recall Process" 						"Recall Action"  			"" 								"Top of Page" 		167	$fi
		Whichgrid "Reference Pitches" 					"\"A\"" 					"" 								"Above Workspace" 	168	$fi
		Whichgrid "Reference Values  enter" 			"Reference"  				"" 								"Top of Page" 		169	$fi
		Whichgrid "Reference Values  delete" 			"Reference"  				"" 								"Top of Page" 		170	$fi
		Whichgrid "Refresh all File data" 				"Any/All"  					"" 								"Above Workspace" 	171	$fi
		Whichgrid "Refresh selected-Files data" 		"Selected Files Only"  		"" 								"Above Workspace" 	172	$fi
		Whichgrid "Refresh Chosen File Data" 			"Play:Read:Props"  			"" 								"Above Chosen Lists" 173	$fi
		Whichgrid "Remember Chosen Files" 				"Previous Choices"  		"" 								"Above Chosen Lists" 174	$fi
		Whichgrid "Remember, Keep Name of File" 		"Reference"  				"" 								"Top of Page" 		175	$fi
		Whichgrid "Remember make texlist all files" 	"Any/All"  					"" 								"Above Workspace" 	176	$fi
		Whichgrid "Remember, make texlist of files" 	"Selected Files Only"  		"" 								"Above Workspace" 	177	$fi
		Whichgrid "Remember, Send file to Notebook" 	"Notebook"  				"" 								"Top of Page" 		178	$fi
		Whichgrid "Remember Selected Files" 			"Any/All"  					"" 								"Above Workspace" 	179	$fi
		Whichgrid "Remember, Write in Notebook" 		"Notebook"  				"" 								"Top of Page" 		180	$fi
		Whichgrid "Rename Files" 						"Selected Files Only" 		"Rename" 						"Above Workspace" 	181	$fi
		Whichgrid "Rename Files, Generically" 			"Selected Files Only" 		"Rename" 						"Above Workspace" 	182	$fi
		Whichgrid "Rename, Swap Names" 					"Selected Files Only" 		"Rename" 						"Above Workspace" 	183	$fi
		Whichgrid "Renumber Files" 						"Selected Files Only" 		"Rename" 						"Above Workspace" 	184	$fi
		Whichgrid "Reorder, Chosen Files" 				"Reorder"  					"" 								"Above Chosen List" 185	$fi
		Whichgrid "Restore Chosen Files" 				"Previous Choices"  		"" 								"Above Chosen List" 186	$fi
		Whichgrid "Restore Workspace" 					"Recall"  					"" 								"Above Workspace" 	187	$fi
		Whichgrid "Reverse Order, Selected Files" 		"Selected Files Only"   	"Sort" 							"Above Workspace" 	188	$fi
		Whichgrid "Rhythm" 								"Music Testbed" 			"Rhythm And Time Operations" 	"Top Left" 			189	$fi
		Whichgrid "Run a process" 						"Process"  					"" 								"Top of Page" 		190	$fi
		Whichgrid "Run a process on many files" 		"Bulk Process"  			"" 								"Top of page" 		191	$fi
		Whichgrid "Rhythm, Create" 						"Tap Rhythm"  				"" 								"Top of Page" 		192	$fi
		Whichgrid "Screen Sizes" 						"System State"  			"" 								"Top Right of Page" 193	$fi
		Whichgrid "Search for file match" 				"Search"  					"" 								"Above Workspace" 	194	$fi
		Whichgrid "Search for file match  again" 		"&Again"  					"" 								"Above Workspace" 	195	$fi
		Whichgrid "Selected Files, Remember" 			"Any/All"  					"" 								"Above Workspace" 	196	$fi
		Whichgrid "Select specific files" 				"Any/All"  					"" 								"Above Workspace" 	197	$fi
		Whichgrid "Select Files" 						"Select buttons" 			"" 								"Below Workspace" 	198	$fi
		Whichgrid "Session-End actions" 				"System State"  			"" 								"Top Right of Page" 199	$fi
		Whichgrid "Sort by specified string" 			"Any/All"  					"" 								"Above Workspace" 	200	$fi
		Whichgrid "Sort Chosen Files" 					"Reorder"  					"" 								"Above Chosen List" 201	$fi
		Whichgrid "Sort workspace" 						"Any/All"  					"" 								"Above Workspace" 	202	$fi
		Whichgrid "Sort Selected Files" 				"Selected Files Only"   	"Sort" 							"Above Workspace" 	203	$fi
		Whichgrid "Sort by Number, Selected Files" 		"Selected Files Only" 		"Sort" 							"Above Workspace" 	204	$fi
		Whichgrid "Sort by Sortlist" 					"Selected Files Only" 		"Sort" 							"Above Workspace" 	205	$fi
		Whichgrid "Sort Sounds" 						"Music Testbed" 			"Partition Soundfiles" 			"Top Left" 			206	$fi
		Whichgrid "Sound in any Mixfile?" 				"Selected Files of Type"      	"Mixfiles" 						"Above Workspace" 	207	$fi
		Whichgrid "Sound List, change" 					"Selected Files of Type"      	"Lists Of Soundfiles" 			"Above Workspace" 	208	$fi
		Whichgrid "Sound List, Sounds to Chosen" 		"Selected Files of Type"      	"Lists Of Soundfiles" 			"Above Workspace" 	209	$fi
		Whichgrid "Sound List, snds to workspace" 		"Selected Files of Type"      	"Lists Of Soundfiles" 			"Above Workspace" 	210	$fi
		Whichgrid "Space" 								"Music Testbed" 			"Space Design" 					"Top Left" 			211	$fi
		Whichgrid "Stereo, convert from mono" 			"Get/Mod"  					"" 								"Above Chosen Lists" 212	$fi
		Whichgrid "Stereo Files, choose" 				"Get/Mod"  					"" 								"Above Chosen List" 213	$fi
		Whichgrid "Store, Chosen Files list" 			"Store" 					"" 								"Above Chosen List" 214	$fi
		Whichgrid "Store, Workspace State" 				"Store"  					"" 								"Above Workspace" 	215	$fi
		Whichgrid "Swap Names" 							"Selected Files Only"   	"Rename" 						"Above Workspace" 	216	$fi
		Whichgrid "System, Alter settings" 				"System State"  			"" 								"Top Right of Page" 217	$fi
		Whichgrid "System Clock, reset" 				"System State"  			"" 								"Top Right of Page" 218	$fi
		Whichgrid "System, data output format" 			"System State"  			"" 								"Top Right of Page" 219	$fi
		Whichgrid "System, sample rates" 				"System State"  			"" 								"Top Right of Page" 220	$fi
		Whichgrid "System, filename extensions" 		"System State"  			"" 								"Top Right of Page" 221	$fi
		Whichgrid "System, See settings" 				"System State"  			"" 								"Top Right of Page" 222	$fi
		Whichgrid "System, Reinstall  Reset" 			"System State"  			"" 								"Top Right of Page" 223	$fi
		Whichgrid "System, screen sizes" 				"System State"  			"" 								"Top Right of Page" 224	$fi
		Whichgrid "System, version number" 				"System State"  			"" 								"Top Right of Page" 225	$fi
		Whichgrid "System, data output format" 			"System State"  			"" 								"Top Right of Page" 226	$fi
		Whichgrid "Table Editor" 						"Table Editor"  			"" 								"Top of Page" 		227	$fi
		Whichgrid "Table Editor macros, edit" 			"System State"  			"" 								"Top Right of Page" 228	$fi
		Whichgrid "Tempo, find" 						"Tempo"  					"" 								"Top of Page" 		229	$fi
		Whichgrid "Textfile, Chosen files to" 			"Play:Read:Props"  			"" 								"Above Chosen Lists" 230	$fi
		Whichgrid "Textfiles, Compare" 					"Selected Files of Type"      	"Textfiles" 					"Above Workspace" 	231	$fi
		Whichgrid "Textfiles, Duplicate" 				"Selected Files of Type"    	"Textfiles" 					"Above Workspace" 	232	$fi
		Whichgrid "Textfiles, Edit" 					"Selected Files of Type"    	"Textfiles" 					"Above Workspace" 	233	$fi
		Whichgrid ""     								"Go To Parameters Page" 	"Get File-->Edit" 				"" 					234	$fi
		Whichgrid "Timeline" 							"Music Testbed" 			"Timeline" 						"Top Left" 			235	$fi
		Whichgrid "Total Duration of Chosen Files" 		"Play:Read:Props"  			"" 								"Above Chosen Lists" 236	$fi
		Whichgrid "Update Data, Selected Files" 		"Selected Files Only"  		"" 								"Above Workspace" 	237	$fi
		Whichgrid "Users, multi-user system" 			"System State"  			"" 								"Top Right of Page" 238	$fi
		Whichgrid "View Files" 							"Selected Files of Type"      	"Soundfiles" 					"Above Workspace" 	239	$fi
		Whichgrid "Window Size of AnalFile" 			"Selected Files Only"  		"Properties" 					"Above Workspace" 	240	$fi
		Whichgrid "Window Size of Chosen AnalFile" 		"Play:Read:Props"  			"" 								"Above Chosen Lists" 241	$fi
		Whichgrid "Workspaces, previous, edit" 			"System State"  			"" 								"Top Right of Page" 242	$fi
		Whichgrid "Workspaces, previous, restore" 		"Recall"  					"" 								"Above Workspace" 	243	$fi
		pack $f.1 $f.2 -side top
		bind $f <KeyPress> {
			if [string match {[a-zA-Z]} %A] {
				set q [string toupper %A]
				switch -- $q {
					A { set k [expr double(0) / double(252)]}
					B { set k [expr double(0) / double(252)]}					
					C { set k [expr double(14) / double(252)]}					
					D { set k [expr double(42) / double(252)]}					
					E { set k [expr double(60) / double(252)]}					
					F { set k [expr double(66) / double(252)]}					
					G { set k [expr double(74) / double(252)]}					
					H { set k [expr double(79) / double(252)]}					
					I { set k [expr double(87) / double(252)]}					
					J { set k [expr double(87) / double(252)]}					
					K { set k [expr double(87) / double(252)]}					
					L { set k [expr double(92) / double(252)]}					
					M { set k [expr double(100) / double(252)]}					
					N { set k [expr double(116) / double(252)]}					
					O { set k [expr double(124) / double(252)]}					
					P { set k [expr double(131) / double(252)]}					
					Q { set k [expr double(131) / double(252)]}					
					R { set k [expr double(150) / double(252)]}					
					S { set k [expr double(180) / double(252)]}					
					T { set k [expr double(212) / double(252)]}					
					U -
					V -
					W -
					X -
					Y -
					Z { set k [expr double(221) / double(252)]}				
				}
				$wkw yview moveto $k 
			}
		}
		wm resizable $f 1 1
		bind $f <Return> {set pr_wkwhich 0}
		bind $f <Escape> {set pr_wkwhich 0}
	}
	set finished 0
	set pr_wkwhich 0
	set alg_name ""
	raise $f
	My_Grab 0 $f pr_wkwhich
	tkwait variable pr_wkwhich
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}
				
proc Whichgrid {what on via where which fi} {
	set n 100
	if {$which > 2} {
		incr which
	}
	while {$n < 401} {
		switch -- $n {
			100 {
				label $fi.$which$n -text $what
				grid $fi.$which$n -row $which -column 0 -sticky w
			}
			200 {
				label $fi.$which$n -text $on
				grid $fi.$which$n -row $which -column 2 -sticky w
			}
			300 {
				label $fi.$which$n -text $via
				grid $fi.$which$n -row $which -column 6 -sticky w
			}
			400 {
				label $fi.$which$n -text $where
				grid $fi.$which$n -row $which -column 4 -sticky w
			}
		}
		incr n 100
	}
}

#--- Play snd from Chosen List, with Double Click, if NOT in Chosen-Files mode

proc ChDoublePlay {} {
	global selection_mode
	if {!$selection_mode} {
		UniversalPlay ww 0
	}
}

#--- Get device to play sounds

proc GetPlayDevice {} {
	global snack_audio evv
	set fnam [file join $evv(CDPRESOURCE_DIR) device$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		set evv(DEVICE) $evv(DEVICE_DFLT)
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Read File '$fnam' To Find Your Play-Device Identifier\nDefaulting To Standard Play Device"
		set evv(DEVICE) $evv(DEVICE_DFLT)
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {![regexp {^[0-9]+$} $line]} {
			Inf "Corrupted Data In File '$fnam'\nDefaulting To Standard Play Device"
			set evv(DEVICE) $evv(DEVICE_DFLT)
			return
		}
		set val $line
		break
	}
	close $zit
	if {![info exists val]} {
		Inf "Corrupted Data In File '$fnam'\nDefaulting To Standard Play Device"
		set evv(DEVICE) $evv(DEVICE_DFLT)
		return
	}
	if {($val < $evv(DEVICE_DFLT)) || ($val > $evv(DEVICE_MAX))} {
# MESSAGE REMOVED JUNE 2011, AS DEVICE NUMBERS MAY CHANGE WITH PLUG-IN HARDWARE ETC
#		Inf "Invalid Play Device Identifier ($val) In File '$fnam'\nDefaulting To Standard Play Device"
		set evv(DEVICE) $evv(DEVICE_DFLT)
		return
	}
	set evv(DEVICE) $val
}

#--- Set or change device to play sounds

proc SetPlayDevice {} {
	global pr_device device_val device_always snack_audio devicelist evv

	if {![info exists devicelist]} {
		Inf "No device list: Cannot Change Audio Devices"
		return
	}
	set f .device
	if [Dlg_Create  $f "SPECIFY PLAY DEVICE" "set pr_device 0" -borderwidth $evv(SBDR)] {
		set f1 [frame $f.1 -bd $evv(SBDR)]
		set f2 [frame $f.2 -bd $evv(SBDR)]
		button $f1.qu -text "Abandon" -command {set pr_device 0} -highlightbackground [option get . background {}]
		button $f1.ok -text "Set Device" -command {set pr_device 1} -highlightbackground [option get . background {}]
		pack $f1.ok -side left -pady 2
		pack $f1.qu -side right -pady 2
		pack $f.1 -side top -fill x -expand true
		foreach dd $devicelist {
			set no  [lindex $dd 0]
			set nam [lindex $dd 1]
			set och [lindex $dd 2]
			append nam " ($och)"
			radiobutton $f2.$no -variable device_val -value $no -text $nam -command "DeviceColor"
			pack $f2.$no -side top -pady 2 -anchor w
		}
		pack $f.2 -side top -fill x -expand true
		wm resizable .device 1 1
		bind $f <Return> {set pr_device 1}
		bind $f <Escape> {set pr_device 0}
	}
	if {[info exists evv(DEVICE)]} {
		set device_val $evv(DEVICE)
		.device.2.$device_val config -bg $evv(EMPH)
	} else {
		set device_val 0
	}
	raise $f
	set pr_device 0
	set finished 0
	My_Grab 0 $f pr_device
	while {!$finished} {
		tkwait variable pr_device
		if {$pr_device} {
			if {$device_val == 0} {
				Inf "No Device Selected"
				continue
			}
			set evv(DEVICE) $device_val
			set fnam [file join $evv(CDPRESOURCE_DIR) device$evv(CDP_EXT)]
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Save Play-Device Identifier To File To Remember For Next Session"
			} else {
				puts $zit $evv(DEVICE)
				close $zit
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc DeviceColor {} {
	global device_val devicelist evv
	set n $evv(DEVICE_DFLT)
	while {$n <= $evv(DEVICE_MAX)} {
		catch {.device.2.$n config -bg [option get . background {}]}
		incr n
	}
	catch {.device.2.$device_val config -bg $evv(EMPH)}
	foreach dd $devicelist {
		if {[lindex $dd 0] == $device_val} {
			Inf "[lindex $dd 1] : selected as Audio Device"
			break
		}
	}
}

proc GetSmallDisplay {} {
	global macsmall evv
	set fnam [file join $evv(CDPRESOURCE_DIR) macsmall$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set macsmall 1
	} else {
		set macsmall 0
	}
}

proc SetSmallDisplay {} {
	global macsmall evv
	set fnam [file join $evv(CDPRESOURCE_DIR) macsmall$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		catch {file delete $fnam}
		set macsmall 0
		set msg "Buttons Texts Set To Normal (Full)\n\n"
	} else {
		catch {open $fnam "w"} zit
		catch {close $zit}
		set macsmall 1
		set msg "Buttons Texts Set To Abbreviated\n\n"
	}
	append msg "Restart The Loom To Change To New Dimensions"
	Inf $msg
}

#--- Change display length, for wide-screen monitors

proc GetShortWindows {init} {
	global shortwindows longqik ww evv lengthen_screen_menu_index
	set fnam [file join $evv(URES_DIR) shortwindows$evv(CDP_EXT)]
	if {$init} {
		set evv(SCROLL_HEIGHT) 820
		if {[file exists $fnam]} {
			set shortwindows 1
			set evv(WKSPACE_HEIGHT) 16
			set evv(PROPTABLEN)	350
			set evv(QIKEDITLEN) 20
			set longqik 0
			SetBigSnack 0
		} else {
			set evv(WKSPACE_HEIGHT) 24
			set evv(PROPTABLEN)	500
			set evv(QIKEDITLEN) 34
			set longqik 1
			SetBigSnack 1
		}
	} else {
		if {[info exists shortwindows]} {
			unset shortwindows
			set evv(WKSPACE_HEIGHT) 24
			set evv(PROPTABLEN)	500
			set evv(QIKEDITLEN) 34
			set longqik 1
			if {[file exists $fnam]} {
				catch {file delete $fnam}
			}
			$ww.h.syscon.menu.sub1a entryconfig $lengthen_screen_menu_index -label "Shorten Windows"
			SetBigSnack 1
		} else {
			set shortwindows 1
			set evv(WKSPACE_HEIGHT) 16
			set evv(PROPTABLEN)	350
			set evv(QIKEDITLEN) 20
			set longqik 0
			SaveShortWindows
			$ww.h.syscon.menu.sub1a entryconfig $lengthen_screen_menu_index -label "Lengthen Windows"
			SetBigSnack 0
		}
		Inf "Restart The Loom To Move To The Different Window Size"
	}
}

proc SaveShortWindows {} {
	global shortwindows evv
	set fnam [file join $evv(URES_DIR) shortwindows$evv(CDP_EXT)]
	if [catch {open $fnam "w"} zit] {
		close $zit
	}
}

#---- Save Current woskapce as named workspace OR load a named workspace

proc NamedWkspace {save} {
	global pr_namedwk wkname wksp_cnt total_wksp_cnt rememd ww wl wstk chlist ch evv
	if {[$wl index end] < 0} {
		Inf "No Files On Workspace"
		return
	}
	foreach fnam [$wl get 0 end] {
		set ftail [file tail $fnam]
		if {[string match $ftail $fnam]} {
			Inf "You Cannot Save or Load A Workspace With A Name\nUntil ALL Files On The Workspace Are Backed Up To Directories"
			return
		}
	}
	set f .namedwk
	if [Dlg_Create $f "Store Workspace with Name" "set pr_namedwk 0" -borderwidth $evv(BBDR)] {
		frame $f.1 -borderwidth $evv(SBDR)
		frame $f.2 -borderwidth $evv(SBDR)
		frame $f.3 -borderwidth $evv(SBDR)
		button $f.1.ok -text "Save" -width 15 -command "set pr_namedwk 1" -highlightbackground [option get . background {}]
		button $f.1.q  -text "Abandon" -width 7 -command "set pr_namedwk 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.q -side right
		pack $f.1 -side top -fill x -expand true
 		label $f.2.l -text "Workspace Name "
		entry $f.2.e -width 20 -textvariable wkname -width 16
		pack $f.2.l $f.2.e -side left -padx 1
		label $f.3.tit -text "Existing Named Workspaces" -fg $evv(SPECIAL)
		Scrolled_Listbox $f.3.ll -width 64 -height 24 -selectmode single
		pack $f.3.tit $f.3.ll -side top -fill both -expand true
		pack $f.2 $f.3 -side top -pady 4
		wm resizable $f 1 1
		bind $f.3.ll.list <ButtonRelease-1> {WkNameGet %y}
		bind $f <Return> {set pr_namedwk 1}
		bind $f <Escape> {set pr_namedwk 0}
	}
	if {$save} {
		$f.2.e config -state normal
		$f.1.ok config -text "Save Workspace"
	} else {
		$f.2.e config -state readonly
		$f.1.ok config -text "Load Workspace"
	}
	foreach fnam [glob -nocomplain [file join $evv(URES_DIR) wknm_*]] {
		set fnam [file rootname [file tail $fnam]]
		set fnam [string range $fnam 5 end]
		lappend oldnames $fnam
	}
	if {[info exists oldnames]} {
		set oldnames [lsort -dictionary $oldnames]
		foreach nam $oldnames {
			$f.3.ll.list insert end $nam
		}
	} elseif {!$save} {
		Inf "No Existing Named Workspaces To Load"
		return
	}
	set wkname ""
	set pr_namedwk 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_namedwk $f.2.e
	while {!$finished} {
		tkwait variable pr_namedwk
		if {$pr_namedwk} {
			if {[string length $wkname] <= 0} {
				Inf "No Workspace Name Entered"
				continue
			}
			if {$save} {
				if {!([regexp {^[A-Za-z0-9]+$} $wkname] && [regexp {[A-Za-z]} $wkname])} {
					Inf "Workspace Name Must Be Alphanumeric, With At Least One Letter"
					continue
				}
				set nuname [string tolower $wkname]
				set OK 1
				foreach nam [$f.3.ll.list get 0 end] {
					if {[string match $nuname $nam]} {
						set msg "Overwrite Existing Workspace '$nam' ??"
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							set OK 0
						}
						break
					}
				}
				if {!$OK} {
					continue
				}
				set ofnam [file join $evv(URES_DIR) "wknm_"]
				append ofnam $nuname $evv(CDP_EXT)
				if [catch {open $ofnam "w"} zit] {
					Inf "Cannot Open File '[file tail $ofnam]' To Write Workspace Data"
					continue
				}
				foreach fnam [$wl get 0 end] {
					puts $zit $fnam
				}
				close $zit
				Inf "Workspace '$nuname' Saved"
				set finished 1
			} else {
				set ofnam [file join $evv(URES_DIR) "wknm_"]
				append ofnam $wkname $evv(CDP_EXT)
				if [catch {open $ofnam "r"} zit] {
					Inf "Cannot Open File '[file tail $ofnam]' To Read Workspace Data"
					continue
				}
				while {[gets $zit fnam] >= 0} {
					set fnam [string trim $fnam]
					if {[string length $fnam] <= 0} {
						continue
					}
					if {![file exists $fnam]} {
						lappend badfiles $fnam
					} else {
						lappend goodfiles $fnam
					}
				}
				close $zit
				if {![info exists goodfiles]} {
					set msg "None Of The Files Listed In This Workspace Exist\n\nDelete Workspace '$wkname' ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if [catch {file delete $ofnam} zit] {
							Inf "Cannot Delete Existing Workspace '$nuname'"
						} else {
							set k [LstIndx $wkname $f.3.ll.list]
							$f.3.ll.list delete $k
							set wkname ""
						}
					}
					continue
				}
				if {[info exists badfiles]} {
					set msg "Some Of The Files In This Workspace No Longer Exist\n\nContinue Loading The Workspace ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
					;#	CLEAR EXISTING WORKSPACE

				foreach fnam [$wl get 0 end] {
					PurgeArray $fnam						;#	can't remove unbakdup files!!
					RemoveFromChosenlist $fnam				;#	Otherwise, remove it
				}
				$wl delete 0 end
				if {[info exists wksp_cnt] && ($wksp_cnt > 0)} {
					catch {unset rememd}
				}
				set wksp_cnt 0
				set total_wksp_cnt 0
				ForceVal $ww.1.a.endd.l.cnts.all 0

					;#	LOAD NEW WORKSPACE

				set goodfiles [ReverseList $goodfiles]
				set save_mixmanage 0
				set nessupdate 0
				foreach newfile $goodfiles {
					FileToWkspace $newfile 1 0 0 1 0
					if {[UpdatedIfAMix $newfile 0]} {
						set save_mixmanage 1
					} elseif {[UpdatedIfANessFull $newfile]} {
						set nessupdate 1
					}
				}
				if {$save_mixmanage} {
					MixMStore
				}
				if {$nessupdate} {
					NessMStore
				}
				$wl yview moveto 0.0
				set finished 1
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc WkNameGet {y} {
	global wkname
	set i [.namedwk.3.ll.list nearest $y]
	set wkname [.namedwk.3.ll.list get $i]
}

proc MixActiveCnt {} {
	global wl pa evv
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i == -1)} {
		Inf "SELECT A SINGLE MIXFILE"	
		return
	}
	set fnam [$wl get $i]
	if {![IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
		Inf "SELECT A MIXFILE"	
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "CANOT OPEN FILE '$fnam'"	
		return
	}
	set cnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		incr cnt
	}
	close $zit
	Inf "Number Of Active Lines In\n '[file tail $fnam]\n\n\t\t$cnt"
}

proc MixChanCnt {} {
	global wl pa evv
	set maxchans 0
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i == -Inf)} {
		1 "Select A Single Mixfile"	
		return
	}
	set fnam [$wl get $i]
	if {![IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
		Inf "Select a mixfile"	
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Canot open file '$fnam'"	
		return
	}
	set activecnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		} else {
			catch {unset nuline}
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend nuline $item
			}
			if {[llength $nuline] >= 3} {
				set chans [lindex $nuline 2]
				if {$chans > $maxchans} {
					set maxchans $chans
				}
				if {![info exists chancnt($chans)]} {
					set chancnt($chans) 1
				} else {
					incr chancnt($chans)
				}
			}
		}
		incr activecnt
	}
	close $zit
	if {![info exists chancnt]} {
		Inf "Error counting files with specific numbers of channels"
		return
	}
	set msg "Total number of active lines $activecnt"
	set n 1
	while {$n <= $maxchans} {
		if {[info exists chancnt($n)]} {
			append msg "\n$chancnt($n) "
			if {$n == 1} {
				append msg "Mono "
			} elseif {$n == 2} {
				append msg "Stereo "
			} else {
				append msg "$n-Channel "
			}
			append msg "files"
		}
		incr n
	}
	Inf $msg
}

#-- Concatenate two mixfiles

proc MixAdd {} {
	global wl pa evv pr_mixadd mixaddstep mixaddfnam
	set ilist [$wl curselection]
	if {[llength $ilist] != 2} {
		Inf "Select Two Mixfiles"
		return
	}
	set fnam1 [$wl get [lindex $ilist 0]]
	set fnam2 [$wl get [lindex $ilist 1]]
	set ftyp1 $pa($fnam1,$evv(FTYP))
	set ftyp2 $pa($fnam2,$evv(FTYP))
	if {$ftyp1 != $ftyp2} {
		Inf "Selected Files Are Not Of Same Type"
		return
	}
	if {!([IsAMixfile $ftyp1] || ($ftyp1 == $evv(MIX_MULTI)))} {
		Inf "Selected Files Are Not Mixfiles"
		return
	}
	if {$ftyp1 == $evv(MIX_MULTI)} {
		if {$pa($fnam1,$evv(OUT_CHANS)) != $pa($fnam2,$evv(OUT_CHANS))} {
			Inf "Multichannel Files Do Not Have Same Output Channel Count"
			return
		}
		set ochancnt $pa($fnam1,$evv(OUT_CHANS))
		set multichan 1
	} else {
		set multichan 0
	}
	set f .mixadd
	if [Dlg_Create $f "COLLAPSE MULTICHAN" "set pr_mixadd 0" -borderwidth 2 -width 80] {
		frame $f.1
		button $f.1.ok -text "Merge" -command "set pr_mixadd 1" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Abandon" -command "set pr_mixadd 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		label $f.2.ll -text "Timestep between files "
		entry $f.2.e -textvariable mixaddstep -width 8
		pack $f.2.ll $f.2.e -side left
		pack $f.2 -side top -pady 2
		frame $f.3
		label $f.3.ll -text "Name of new mixfile "
		entry $f.3.e -textvariable mixaddfnam -width 40
		pack $f.3.ll $f.3.e -side left
		pack $f.3 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_mixadd 1}
		bind $f <Escape> {set pr_mixadd 0}
	}
	set mixaddstep 0.0
	set mixaddfnam ""
	set finished 0
	set pr_mixadd 0
	raise $f
	My_Grab 0 $f pr_mixadd
	while {!$finished} {
		tkwait variable pr_mixadd
		catch {unset nulines}
		catch {unset outlines}
		catch {unset times}
		if {$pr_mixadd} {
			if {[string length $mixaddfnam] <= 0} {
				Inf "No Filename Entered"
				continue
			}
			set outfnam [string tolower $mixaddfnam]
			if {![ValidCDPRootname $outfnam]} {
				continue
			}
			if {$multichan} {
				append outfnam [GetTextfileExtension mmx]
			} else {
				append outfnam [GetTextfileExtension mix]
			}
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			if {[string length $mixaddstep] <= 0} {
				Inf "No Timestep Entered"
				continue
			}
			if {![IsNumeric $mixaddstep] || ($mixaddstep < 0.0)} {
				Inf "Invalid Timestep Entered"
				continue
			}
			if [catch {open $fnam1 "r"} zit] {
				Inf "Cannot Open File '$fnam1' To Read Data"
				continue
			}
			set gotochan 0
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				if {$multichan && !$gotochan} {
					if {![string match [string index $line 0] ";"]} {
						set gotochan 1
						continue
					}
				}
				lappend nulines $line
			}
			set gotochan 0
			close $zit
			if [catch {open $fnam2 "r"} zit] {
				Inf "Cannot Open File '$fnam2' To Read Data"
				continue
			}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				if {$multichan && !$gotochan} {
					if {![string match [string index $line 0] ";"]} {
						set gotochan 1
						continue
					}
				} elseif {$mixaddstep > 0.0} {
					catch {unset out_line}
					set line [split $line]
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] > 0} {
							lappend out_line $item
						}
					}
					set time [lindex $out_line 1]
					set time [expr $time + $mixaddstep]
					set line [lreplace $out_line 1 1 $time]
				}
				lappend nulines $line
			}
			close $zit

			foreach line $nulines {
				if {[string match [string index $line 0] ";"]} {
					lappend times -1
				} else {
					set cnt 0
					set line [split $line]
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] > 0} {
							if {$cnt == 1} {
								lappend times $item
								break
							}
							incr cnt
						}
					}
				}
			}
			set n 0
			set len [llength $nulines]
			set len_less_one [expr $len - 1]
			while {$n < $len_less_one } {
				set line_n [lindex $nulines $n]
				set time_n [lindex $times $n]
				set m $n
				incr m
				while {$m < $len} {
					set line_m [lindex $nulines $m]
					set time_m [lindex $times $m]
					if {$time_m < $time_n} {
						set nulines [lreplace $nulines $n $n $line_m]
						set nulines [lreplace $nulines $m $m $line_n]
						set times [lreplace $times $n $n $time_m]
						set times [lreplace $times $m $m $time_n]
						set line_n $line_m
						set time_n $time_m
					}
					incr m
				}
				incr n
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write Data"
				continue
			}
			if {$multichan} {
				puts $zit $ochancnt
			}
			foreach line $nulines {
				puts $zit $line
			}
			close $zit
			MixMUpdate $outfnam 1
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return 1
}

proc SelectChans {chans} {
	global wl evv pa
	set i 0
	foreach fnam [$wl get 0 end] {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			if {$pa($fnam,$evv(CHANS)) == $chans} {
				lappend ilist $i
			}
		}
		incr i
	}
	if {![info exists ilist]} {
		set msg "There Are No "
		switch -- $chans {
			1 {
				append msg "Mono "
			}
			2 {
				append msg "Stereo "
			}
			default {
				append msg $chans "-Channel "
			}
		}
		append msg "Files On The Workspace"
		Inf $msg
		return
	}
	$wl selection clear 0 end
	foreach i $ilist {
		$wl selection set $i
	}
	set top [lindex $ilist 0]
	if {$top >= $evv(WKSPACE_HEIGHT)} {
		set qq [expr double($top) / double ([$wl index end])]
		$wl yview moveto $qq
	}
}

#--- Set up and excute panning of a process around a multichan file

proc PanProcess {goto} {
	global panprocess panprocessfnam panprocess_individ chlist prg_ocnt CDPidrun prg_dun prg_abortd simple_program_messages pr3 pa evv

	if {$goto} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "WOrks Only With A Single Multichannel File"
			return
		}
		set fnam [lindex $chlist 0]
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 2)} {
			Inf "Works Only With A Single Multichannel File"
			return
		}
		if {[info exists panprocessfnam]} {
			if {[string match $panprocessfnam $fnam]} {
				if {$panprocess == 3} {
					Inf "Do The Spatialisation From The Process Page"
				} else {
					Inf "go To Get The Process"
				}
				return
			} else {
				unset panprocessfnam
				DeleteAllTemporaryFiles
			}
		}
	}
	set simple_program_messages ""
	if {$goto} {
		set innam $evv(DFLT_OUTNAME)
		append innam 0000
		append innam $evv(SNDFILE_EXT)
		if [catch {file copy $fnam $innam} zit] {
			Inf "Failed To Copy Multichannel File"	
			return
		}
		Block "Separating Channels of Unprocessed Multichannel File"
	} else {
		set innam $evv(DFLT_OUTNAME)
		append innam 0 
		append innam $evv(SNDFILE_EXT)
		if {![info exists panprocess_individ]} {
			Block "Separating Channels of Processed Multichannel File"
		}
	}

	if {![info exists panprocess_individ]} {
		set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
		lappend cmd chans 2 $innam
		set CDPidrun 0
		set prg_dun 0
		set prg_abortd 0
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "Channel Extraction Failed"
			DeleteAllTemporaryFiles
			catch {unset panprocess}
			catch {unset panprocessfnam}
			set prg_ocnt 0
			if {$panprocess == 3} {
				set pr3 1
			}
			UnBlock
			return
   		} else {
   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			Inf "Channel Extraction Failed"
			DeleteAllTemporaryFiles
			catch {unset panprocess}
			catch {unset panprocessfnam}
			set prg_ocnt 0
			if {$panprocess == 3} {
				set pr3 1
			}
			UnBlock
			return
		}
	}
	if {$goto} {
		set panprocess 1
		set panprocessfnam $fnam
		Inf "First Select The Process To Apply"
		UnBlock
		return
	}
	if {[info exists panprocess_individ]} {
		Block "Assembling all channel-files"
	}
	if [catch {file delete $innam} zit] {
		Inf "Failed To Delete Intermediate Multichannel Processed File"
		DeleteAllTemporaryFiles
		catch {unset panprocess}
		catch {unset panprocessfnam}
		catch {unset panprocess_individ}
		set prg_ocnt 0
		UnBlock
		set pr3 1
		return
	}
	set basfnam $evv(DFLT_OUTNAME)
	append basfnam 0000_c
	foreach fnam [glob $basfnam*] {
		lappend srcfiles $fnam
	}
	set basfnam $evv(DFLT_OUTNAME)
	set basfnam $evv(DFLT_OUTNAME)
	append basfnam 0_c
	foreach fnam [glob $basfnam*] {
		lappend goalfiles $fnam
	}
	if {[llength $srcfiles] != [llength $goalfiles]} {
		Inf "Anomaly In Count Of Channels, In Source And Processed File"
		unset panprocess
		catch {unset panprocessfnam}
		catch {unset panprocess_individ}
		set prg_ocnt 0
		UnBlock
		set pr3 1
		return
	}
	set n 1
	while {$n <= $pa([lindex $chlist 0],$evv(CHANS))} {
		set brkfile $evv(DFLT_OUTNAME)
		append brkfile $n $evv(TEXT_EXT)
		lappend brkfiles $brkfile
		incr n
	}
	if {[llength $brkfiles] != [llength $goalfiles]} {
		Inf "Anomaly In Count Of Channels In Source v. Enveloping Files"
		unset panprocess
		catch {unset panprocessfnam}
		catch {unset panprocess_individ}
		set prg_ocnt 0
		UnBlock
		set pr3 1
		return
	}
	set msg "Assiging Processing to Channels of multichannel file"
	wm title .blocker "PLEASE WAIT :      [string toupper $msg]"
	set n 1
	foreach srcfile $srcfiles goalfile $goalfiles brkfile $brkfiles {
		set outfile $evv(DFLT_OUTNAME)
		append outfile $n $evv(SNDFILE_EXT)
		set cmd [file join $evv(CDPROGRAM_DIR) submix]
		lappend cmd balance $goalfile $srcfile $outfile -k$brkfile
		set CDPidrun 0
		set prg_dun 0
		set prg_abortd 0
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "Channel Processing Failed (1) For Channel $n"
			DeleteAllTemporaryFiles
			catch {unset panprocess}
			catch {unset panprocessfnam}
			catch {unset panprocess_individ}
			set prg_ocnt 0
			UnBlock
			set pr3 1
			return
   		} else {
   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			Inf "Channel Processing Failed (2) For Channel $n"
			DeleteAllTemporaryFiles
			catch {unset panprocess}
			catch {unset panprocessfnam}
			catch {unset panprocess_individ}
			set prg_ocnt 0
			UnBlock
			set pr3 1
			return
		}
		if {![file exists $outfile]} {
			Inf "Channel Processing Failed (3) For Channel $n"
			DeleteAllTemporaryFiles
			catch {unset panprocess}
			catch {unset panprocessfnam}
			catch {unset panprocess_individ}
			set prg_ocnt 0
			UnBlock
			set pr3 1
			return
		}
		incr n
	}
	set cnt $n
	set outfile $evv(DFLT_OUTNAME)
	append outfile 0 $evv(SNDFILE_EXT)
	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	lappend cmd interleave
	set n 1
	while {$n < $cnt} {
		set infile $evv(DFLT_OUTNAME)
		append infile $n $evv(SNDFILE_EXT)
		lappend cmd $infile
		incr n
	}
	lappend cmd $outfile
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Channel Interleaving Failed (1)"
		DeleteAllTemporaryFiles
		catch {unset panprocess}
		catch {unset panprocessfnam}
		catch {unset panprocess_individ}
		set prg_ocnt 0
		UnBlock
		set pr3 1
		return
   	} else {
   		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "Channel Interleaving Failed (2)"
		DeleteAllTemporaryFiles
		catch {unset panprocess}
		catch {unset panprocessfnam}
		catch {unset panprocess_individ}
		set prg_ocnt 0
		UnBlock
		set pr3 1
		return
	}
	if {![file exists $outfile]} {
		Inf "Channel Interleaving Failed (3)"
		DeleteAllTemporaryFiles
		catch {unset panprocess}
		catch {unset panprocessfnam}
		catch {unset panprocess_individ}
		set prg_ocnt 0
		UnBlock
		set pr3 1
		return
	}
	set n 1
	while {$n <= $cnt} {
		set infile $evv(DFLT_OUTNAME)
		append infile $n $evv(SNDFILE_EXT)
		if [catch {file delete $infile} zit] {
			set badfiles 1
		}
		incr n
	}
	if {[info exists badfiles]} {
		Inf "WARNING: Failed to delete some intermediate temporary files"
	}
	if {![info exists pa("cdptest0.wav",$evv(FTYP))]} {
		if {[DoParse "cdptest0.wav" 0 0 0] <= 0} {
			Inf "Problem Establishing Properties Of The Output File"
			DeleteAllTemporaryFiles
			set prg_ocnt 0
			UnBlock
			catch {unset panprocess}
			catch {unset panprocessfnam}
			catch {unset panprocess_individ}
			set pr3 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput except cdptest0.wav
	set prg_ocnt 1
	UnBlock
	catch {unset panprocess}
	catch {unset panprocessfnam}
	catch {unset panprocess_individ}
	set pr3 1
}

proc GetRecentMixfiles {} {
	global pr_recmix wl ch chlist chcnt pa evv
	foreach fnam [$wl get 0 end] {
		if {[IsAMixfileIncludingMultichan $pa($fnam,$evv(FTYP))]} {
			lappend fnams $fnam
		}
	}
	if {![info exists fnams]} {
		Inf "No Mixfiles On Workspace"
		return
	}
	set f .recmix
	if [Dlg_Create $f "MIXFILES ON WORKSPACE" "set pr_recmix 0" -borderwidth 2 -width 80] {
		frame $f.1
		button $f.1.ok -text "Select" -command "set pr_recmix 1" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Abandon" -command "set pr_recmix 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		Scrolled_Listbox $f.2.ll -width 64 -height 24 -selectmode single
		pack $f.2.ll -side top -fill both -expand true -pady 2
		pack $f.2 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_recmix 1}
		bind $f <Escape> {set pr_recmix 0}
	}
	$f.2.ll.list delete 0 end
	foreach fnam $fnams {
		$f.2.ll.list  insert end $fnam
	}
	set finished 0
	set pr_recmix 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_recmix
	while {!$finished} {
		tkwait variable pr_recmix
		if {$pr_recmix} {
			set i [$f.2.ll.list curselection]
			if {![info exists i] || ($i < 0)} {
				Inf "No Mixfile Selected"
				continue
			}
			set mfnam [$f.2.ll.list get $i]
			UnsetThumbnail
			DoChoiceBak
			ClearWkspaceSelectedFiles
			set chcnt 0
			lappend chlist $mfnam		;#	add to end of list
			$ch insert end $mfnam		;#	add to end of display
			incr chcnt
			$ch xview moveto 0
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

##################################
# LOAD WORKSPACE WITHOUT PARSING #
##################################

#------ Save properties of files on workspace, to avoid parsing on starting next session

proc QikLoadSave {palist} {
	global evv pa pathumb
	foreach fnam $palist {
		if {![info exists  pa($fnam,$evv(FTYP))]} {
			Inf "Workspace Property Data Inconsistent:\n\nCannot Set Up QikLoading For Next Session"
			return
		}
	}
	set qfnam [file join $evv(URES_DIR) qikload$evv(CDP_EXT)]
	if {[file exists $qfnam]} {
		if [catch {file delete $qfnam} zit] {
			Inf "Cannot Delete Previous QikLoad File '$qfnam':\n\nDelete This Outside The CDP Before Proceeding"
			return
		}
	}
	if {[catch {open $qfnam "w"} zit]} {
		Inf "Cannot Create File '$qfnam':\n\nCannot Set Up QikLoading For Next Session"
		return
	}
	foreach fnam $palist {
		set line "$fnam"
		set propno 0	;#	Add all file props to line
		while {$propno < ($evv(CDP_PROPS_CNT) + $evv(CDP_MAXSAMP_CNT))} {
			if {[info exists pa($fnam,$propno)]} {
				append line " " $pa($fnam,$propno)
			}
			incr propno
		}
		puts $zit $line
	}
	close $zit

	;#	BAKUP PROPERTIES OF THUMBNAILS, IF ANY

	if {[info exists evv(THUMDIR)] && [file exists $evv(THUMDIR)]} {		;#	Does a thumbnail directory exist
		foreach fnam [glob -nocomplain [file join $evv(THUMDIR) *.*]] {
			lappend fnams $fnam
		}
	}
	if [info exists fnams] {												;#	Are there any thumbnail files in directory
		set qthfnam [file join $evv(URES_DIR) qikthumb$evv(CDP_EXT)]
		if [catch {open $qthfnam "w"} zit] {								;#	Open a qikoaf store for thumbnail props
			return
		}
		foreach fnam $fnams {												;#	For each thumbnail
			if {[info exists pathumb($fnam,$evv(FTYP))]} {					;#	Check props exits
				set line "$fnam"											;#	And if they do, store them in qikload-thumbnails file
				set propno 0	;#	Add all file props to line
				while {$propno < ($evv(CDP_PROPS_CNT) + $evv(CDP_MAXSAMP_CNT))} {
					if {[info exists pathumb($fnam,$propno)]} {
						append line " " $pathumb($fnam,$propno)
					}
					incr propno
				}
				puts $zit $line
			}
		}
		close $zit
	}
}

#------ If a qikloading file exists, get the workspace file properties from it

proc QikLoadPrepare {} {
	global evv pa qikloadfiles wstk
	set qfnam [file join $evv(URES_DIR) qikload$evv(CDP_EXT)]
	if {![file exists $qfnam]} {
		return 0
	}
	if [catch {open $qfnam "r"} zit] {
		Inf "Failed To Open Qikloading File '$qfnam'"
		catch {file delete $qfnam}
		return 0
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		set line [split $line]
		set cnt -1
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] > 0} {
				switch -- $cnt {
					"-1" {
						set fnam $item
						lappend qikloadfiles $fnam
					}
					default {
						set pa($fnam,$cnt) $item
					}
				}
				incr cnt
			}
		}
	}
	close $zit
	catch {file delete $qfnam}
	return 1
}

#------ If properties of file already exist (grabbed from qikload),
#------ load to workspace without parsing, and delete from qikloadfiles list

proc QikLoad {fnam} {
	global evv pa qikloadfiles
	if {[info exists pa($fnam,$evv(FTYP))]} {
		QikFileToWkspace $fnam
		set k [lsearch $qikloadfiles $fnam]
		if {$k >= 0} {
			set qikloadfiles [lreplace $qikloadfiles $k $k]
		}
		return 1
	}
	return 0
}

#------ If a file listed in qikload fails to load to workspace, 
#------ purge its properties-data, and delete from qikloadfiles list

proc QikLoadPurge {fnam} {
	global qikloadfiles
	catch {PurgeArray $fnam}
	set k [lsearch $qikloadfiles $fnam]
	if {$k >= 0} {
		set qikloadfiles [lreplace $qikloadfiles $k $k]
	}
}

#------ If any files in the qikload list remain, after loading wkspace,
#------ they have not been loaded, so purge their property-arrays

proc QikLoadFlush {} {
	global qikloadfiles evv
	foreach fnam $qikloadfiles {
		catch {PurgeArray $fnam}
	}
	unset qikloadfiles
}

#------ Load a file to workspace, without parsing.
#------ Check for properties files, if requested.
#------ Check for maxsamp, if requested and not already known

proc QikFileToWkspace {fnam} {
	global rememd parse_the_max search_for_propsfiles pa wl evv

	if {![file isfile $fnam]} {
		QikLoadPurge $fnam
		return
	} elseif [IgnoreSoundloomxxxFilenames $fnam] { 
		return
	}
	set filetype $pa($fnam,$evv(FTYP))
	if {$evv(DFLT_SR) > 0} {
		if {($filetype & $evv(IS_A_SNDSYSTEM_FILE)) && ($filetype != $evv(ENVFILE))} {
			if {$filetype == $evv(SNDFILE)} {
				if {$pa($fnam,$evv(SRATE)) != $evv(DFLT_SR)} {
					QikLoadPurge $fnam
					return
				}
			} elseif {$pa($fnam,$evv(ORIGRATE)) != $evv(DFLT_SR)} {
				QikLoadPurge $fnam
				return
			}
		} elseif {$filetype == $evv(PSEUDO_SND)} {
			if {$pa($fnam,$evv(SRATE)) != $evv(DFLT_SR)} {
				QikLoadPurge $fnam
				return
			}
		}			
	}
	if {$search_for_propsfiles} {
		if {[HasUserDefinedPropfileExtension $fnam]} {
			AddToPropfilesList $fnam
		} elseif {($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)) && [ThisIsAPropsFile $fnam 0 0]} {
			AddToPropfilesList $fnam
		}
	}
	if {$parse_the_max} {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			if {![info exists pa($fnam,$evv(MAXREP))]} {	;#	Otherwise it's already known
				GetMaxsampOnInput $fnam
			}
		}
	}
	$wl insert end $fnam
	WkspCnt $fnam 1
	catch {unset rememd}
}

#---- Play individual channels of a multichan soundfile

proc PlayChannel {qik} {
	global pr_plchan plchan mix_outchans prg_dun prg_abortd CDPidrun wl chlist xx_basfnam pa playchqik evv
	global qikkeepfnam qikdelfnams

	switch -- $qik {
		1 {
			set playchqik 1
			set fnam $evv(DFLT_OUTNAME)
			append fnam 0 $evv(SNDFILE_EXT)
			if {![file exists $fnam]} {
				Inf "No Mix To Play"
				return
			}
			set chans $mix_outchans 
			set do_extract 0
			set n 1
			while {$n <= $chans} {
				set outfnam $evv(DFLT_OUTNAME)
				append outfnam "_c" $n $evv(SNDFILE_EXT)
				if {![file exists $outfnam]} {
					set do_extract 1
					catch {unset outfnams}
					break
				}
				lappend outfnams $outfnam
				incr n
			}
		} 
		0 {
			set playchqik 0
			set i [$wl curselection]
			if {([llength $i] != 1) || ($i == -1)} {
				if {[info exists chlist] && ([llength $chlist] == 1)} {
					set fnam [lindex $chlist 0]
					set i [LstIndx $fnam $wl]
					$wl selection clear 0 end
					$wl selection set $i
				} else {
					Inf "Select A Single Multichannel Soundfile"
					return
				}
			}
			set fnam [$wl get $i]
			set chans $pa($fnam,$evv(CHANS))
			if {$chans < 2} {
				Inf "Select A Single Multichannel Soundfile"
				return
			}
			set do_extract 1
		}
		2 {
			set playchqik 2
			set fnam cdptest0$evv(SNDFILE_EXT)
			if {![file exists $fnam]} {
				return
			}
			set chans $pa($fnam,$evv(CHANS))
			if {$chans < 2} {
				return
			}
			set do_extract 1
		}
	}
	set xx_basfnam $evv(DFLT_OUTNAME) 
	if {$do_extract} {
		Block "Extracting Channels"
		DeleteAllTemporarySndfilesExcept $fnam
		set fnamsrc $evv(DFLT_OUTNAME)
		append fnamsrc $evv(SNDFILE_EXT)
		if [catch {file copy $fnam $fnamsrc} zit] {
			Inf "Cannot Copy File '$fnam'"
			UnBlock
			return
		}
		set prg_dun 0
		set prg_abortd 0
		set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
		lappend cmd chans 2 $fnamsrc
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "Channel Separation Failed"
			DeleteAllTemporarySndfilesExcept $fnam
			UnBlock
			return
   		} else {
   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			Inf "Channel Separation Failed"
			DeleteAllTemporarySndfilesExcept $fnam
			UnBlock
			return
		}
		set outfnams {}
		set n 1
		while {$n <= $chans} {
			set outfnam [file rootname $fnamsrc]
			append outfnam "_c" $n $evv(SNDFILE_EXT)
			if {![file exists $outfnam]} {
				Inf "Not All Channels Were Extracted"
				DeleteAllTemporarySndfilesExcept $fnam
				foreach outfnam $outfnams {
					unset pa($outfnam,$evv(CHANS))
				}
				UnBlock
				return
			}
			set pa($outfnam,$evv(CHANS)) 1
			lappend outfnams $outfnam
			incr n
		}
		UnBlock
	}
	set f .plchan
	if [Dlg_Create $f "PLAY CHANNEL OF MULTICHAN SNDFILE" "set pr_plchan 0" -borderwidth 2 -width 120] {
		frame $f.1
		button $f.1.ok -text "Play" -command "set pr_plchan 1" -highlightbackground [option get . background {}]
		button $f.1.vv -text "Sound View" -command "set pr_plchan 2" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		button $f.1.mm -text "Max Sample" -command "set pr_plchan 3" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Quit" -command "set pr_plchan 0" -highlightbackground [option get . background {}]
		pack $f.1.ok $f.1.vv $f.1.mm -side left -padx 2
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		label $f.2.ll -text "Channel "
		pack $f.2.ll -side left
		set n 1
		while {$n <= 16} {
			radiobutton $f.2.$n -variable plchan -value $n -text $n
			pack $f.2.$n -side left
			incr n
		}
		pack $f.2 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_plchan 0}
		bind $f <space>  {PlayMultichanChan 0}
	}
	set plchan 0
	set n 1
	while {$n <= $chans} {
		.plchan.2.$n config -state normal -text $n
		incr n
	}
	while {$n <= 16} {
		.plchan.2.$n config -state disabled -text ""
		incr n
	}
	set finished 0
	set pr_plchan 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_plchan
	while {!$finished} {
		tkwait variable pr_plchan
		switch -- $pr_plchan {
			1 {
				PlayMultichanChan 0
			} 
			2 {
				PlayMultichanChan 1
				focus .plchan
			} 
			3 {
				MaxsampMultichanChans
			} 
			0 {
				break
			}
		}
	}
	if {$qik == 1} {
		set qikkeepfnam $fnam
		set qikdelfnams $outfnams
	} else {
		DeleteAllTemporarySndfilesExcept $fnam
		foreach outfnam $outfnams {
			unset pa($outfnam,$evv(CHANS))
		}
	}
	My_Release_to_Dialog $f
	destroy $f
}

proc PlayMultichanChan {view} {
	global plchan xx_basfnam evv
	if {$plchan < 1} {
		Inf "No Channel Chosen"
		return
	}
	set file_to_play $xx_basfnam
	append file_to_play "_c" $plchan $evv(SNDFILE_EXT)
	if {$view} {
		SnackDisplay 0 $evv(SN_FROM_MULTICHAN_CHANVIEW) 0 $file_to_play
	} else {
		PlaySndfile $file_to_play 0
	}
}

#------ Store time info returned by maxsamp2

proc Maxsamp_Info3 {} {
	global CDPmaxId done_maxsamp maxsamp_line

	if {[info exists CDPmaxId] && [eof $CDPmaxId]} {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		}
		if {[string first "ABSOLUTE" $line] >=0} {
			lappend maxsamp_line $line
			return
		} elseif {[string first "Location" $line] >=0} {
			lappend maxsamp_line $line
			set done_maxsamp 1
			return
		}
	}
	update idletasks
}


			
#----- Delete (various categories of) temporary files which are NOT outputs of CDP processes.

proc DeleteAllTemporarySndfilesExcept {args} {
	global evv
	set outfname $evv(DFLT_OUTNAME)
	set fnams [glob -nocomplain "$outfname*"]
	foreach fnam $fnams {
		if {[string match [file extension $fnam] $evv(SNDFILE_EXT)]} {
			set dodelete 1
			foreach ifnam $args {
				if {[string match $fnam $ifnam]} {
					set dodelete 0
					break
				}
			}
			if {$dodelete} {
				catch {file delete -force $fnam}
			}
		}
	}
}

#----- Is sound in any sndlist on the workspace

proc FindSndInSndlist {} {
	global wl chlist pa wstk evv
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i == -1)} {
		if {[info exists chlist] && ([llength $chlist] == 1)} {
			set fnam [lindex $chlist 0]
			set i [LstIndx $fnam $wl]
			$wl selection clear 0 end
			$wl selection set $i
		} else {
			Inf "Select A Single Soundfile"
			return
		}
	}
	set fnam [$wl get $i]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Select A Single Soundfile"
		return
	}
	foreach zfnam [$wl get 0 end] {
		if {![info exists pa($zfnam,$evv(FTYP))]} {
			continue
		}
		if {[IsASndlist $pa($zfnam,$evv(FTYP))] || [string match [file extension $zfnam] ".orc"]} {
			lappend orclist $zfnam
		}
	}
	if {![info exists orclist]} {
		Inf "There Are No Sndlist Files On The Workspace"
		return
	}
	foreach orc $orclist {
		if [catch {open $orc "r"} zit] {
			lappend unopened $orc
			continue
		}
		set gotinvalid 0
		while {[gets $zit zfnam] >= 0} {
			set zfnam [string trim $zfnam]
			if {[string length $zfnam] <= 0} {
				continue
			}
			if {![file exists $zfnam] && !$gotinvalid} {
				lappend invalid $orc
				set gotinvalid 1
			} elseif {[string match $zfnam $fnam]} {
				lappend inorcs $orc
			}
		}
		close $zit
	}
	if {[info exists inorcs] && [info exists invalid]} {
		foreach zfnam $inorcs {
			set k [lsearch $invalid $zfnam]
			if {$k >= 0} {
				lappend badfiles $zfnam
				set invalid [lreplace $invalid $k $k]
				if {[llength $invalid] <= 0} {
					unset invalid
					break
				}
			}
		}
	}
	if {[info exists unopened]} {
		set msg "Some Sndlist Files Could Not Be Opened: Do You Wish To List These ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set msg "The Following Sndlist Files Could Not Be Opened\n"
			set len [llength $unopened]
			set n 0
			while {$n < $len} {
				if {$n >= 20} {
					append msg "AND  MORE\n"
					break
				}
				append msg [lindex $badfiles $n] "\n"
				incr n
			}
		}
		Inf $msg
	}
	if {[info exists invalid]} {
		set msg "Some Sndlist Files (Not Containing '$fnam') Are No Longer Valid: Do You Wish To List These ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set msg "The Following Sndlist Files Are No Longer Valid\n"
			set len [llength $invalid]
			set n 0
			while {$n < $len} {
				if {$n >= 20} {
					append msg "And  More\n"
					break
				}
				append msg [lindex $invalid $n] "\n"
				incr n
			}
		}
		Inf $msg
	}
	if {![info exists inorcs]} {
		Inf "File '$fnam' Is Not In Any Sndlist Files On The Workspace"
		return
	}
	set msg "File '$fnam' Is In The Following Sndlist Files On The Workspace\n"
	set len [llength $inorcs]
	set n 0
	while {$n < $len} {
		set thisfnam [lindex $inorcs $n]
		lappend ilist [LstIndx $thisfnam $wl]
		if {$n >= 20} {
			if {$n == 20} {
				append msg "AND  MORE\n"
			}
		} else {
			append msg $thisfnam "\n"
		}
		incr n
	}
	append msg "\nAll Relevant Sndlist Files Will Be Highlighted On The Workspace\n"
	Inf $msg
	if {[info exists badfiles]} {
		set msg "Some Sndlist Files (Containing '$fnam') Are No Longer Valid: Do You Wish To List These ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set msg "The Following Sndlist Files (Containing '$fnam') Are No Longer Valid\n"
			set len [llength $badfiles]
			set n 0
			while {$n < $len} {
				if {$n >= 20} {
					append msg "AND  MORE\n"
					break
				}
				append msg [lindex $badfiles $n] "\n"
				incr n
			}
		}
		Inf $msg
	}
	$wl selection clear 0 end
	foreach i $ilist {
		$wl selection set $i
	}
}

#------ alphabetical sorts on SELECTED sounds on wkspace

proc SortPartListing {listing typ} {
	global rememd wl
	set ilist [$listing curselection]
	if {([llength $ilist] < 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
		Inf "Select Files To Sort"
		return
	}
	foreach i $ilist {
		set fnam [$listing get $i]
		lappend tl $fnam
	}
	if {![info exists tl]} {
		return
	}
	switch -- $typ {
		0 {
			foreach fnam [lsort -dictionary $tl] {
				lappend newlist $fnam
			}
		}
		1 {
			foreach fnam [lsort -dictionary -decreasing $tl] {
				lappend newlist $fnam
			}
		}
		2 {
			foreach fnam $tl {
				set tla [file rootname [file tail $fnam]]
				set tla [ReverseString $tla]
				lappend tla $fnam
				lappend tlas $tla
			}
			set len [llength $tlas]
			set len_less_one [expr $len - 1]
			set n 0
			while {$n < $len_less_one} {
				set tlan [lindex $tlas $n]
				set thisn [lindex $tlan 0]
				set m $n
				incr m
				while {$m < $len} {
					set tlam [lindex $tlas $m]
					set thism [lindex $tlam 0]
					if {[string compare $thism $thisn] < 0} {
						set tlas [lreplace $tlas $m $m $tlan]
						set tlas [lreplace $tlas $n $n $tlam]
						set tlan $tlam
						set thisn $thism
					}
					incr m
				}
				incr n
			}
			foreach tla $tlas {
				lappend newlist [lindex $tla 1]
			}
		}
	}
	set ilist [ReverseList $ilist]
	set newlist [ReverseList $newlist]
	foreach i $ilist fnam $newlist {
		$listing delete $i
		$listing insert $i $fnam
	}
	if [string match $listing $wl] {
		catch {unset rememd}
	}
}

#--- Sort Workspace Directory-listing on basis of numbers at start or end of name

proc SortDir {atend reverse} {
	global dl active_dir wksp_dirname previous_dirlisting previous_active_dir wstk

	if {![info exists active_dir]} {
		Inf "No Directory Listed Yet: Use 'List : List Named Directory'"
		return
	}
	if {[info exists previous_active_dir]} {
		set xx $previous_active_dir
		set yy $previous_dirlisting
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	set cnt 0
	foreach fnam [$dl get 0 end] {
		set orignam $fnam
		set fnam [file rootname [file tail $fnam]]
		if {![regexp {[0-9]+} $fnam]} {
			Inf "Not All The Files Have Numeric Parts To Their Names"
			set previous_active_dir $xx
			set previous_dirlisting $yy
			return
		} 
		if {$atend} {
			set numends [GetNumericEndPart $fnam]
		} else {
			set numends [GetNumericStartPart $fnam]
		}
		set num [string range $fnam [lindex $numends 0] [lindex $numends 1]]
		lappend dlist [list $orignam $num]
		incr cnt
	}
	set cnt_less_one [expr $cnt - 1]
	set n 0
	while {$n < $cnt_less_one} {
		set dlist_n [lindex $dlist $n]
		set num_n [lindex $dlist_n 1]
		set m [expr $n + 1]
		while {$m < $cnt} {
			set dlist_m [lindex $dlist $m]
			set num_m [lindex $dlist_m 1]
			if {$num_m < $num_n} {
				set dlist [lreplace $dlist $m $m $dlist_n]
				set dlist [lreplace $dlist $n $n $dlist_m]
				set dlist_n $dlist_m
				set num_n $num_m
			}
			incr m
		}
		incr n
	}
	foreach dd $dlist {
		lappend newlist [lindex $dd 0]
	}
	if {$reverse} {
		set newlist [ReverseList $newlist]
	}
	$dl delete 0 end
	foreach fnam $newlist {
		$dl insert end $fnam
	}
	$dl xview moveto 0.0
}

#------ Get max sample in file

proc GetMaxsampBulksplit {fnams} {
	global CDPmaxId done_maxsamp maxsamp_line maxsamp_missing evv

	set basecmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
	if [info exists maxsamp_missing] {
		Inf "maxsamp2$evv(EXEC) Is Not On Your System.\nCannot Search File For Maximum Sample In File."
		return
	} elseif [ProgMissing $basecmd "Cannot search file for maximum sample in file."] {
		set maxsamp_missing 1
		return
	}
	Block "Getting maximum sample across all output files"
	set n 1
	foreach fnam $fnams {
		set done_maxsamp 0
		catch {unset CDPmaxId}
		catch {unset maxsamp_line}
		set cmd $basecmd
		lappend cmd $fnam 1
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "Failed To Run Max-Sample Program For File $fnam"
	   	} else {
			wm title .blocker "PLEASE WAIT:       CALCULATING MAXIMUM FOR CHANNEL $n"
	   		fileevent $CDPmaxId readable "Get_Bulksplit_Maxsamp_Info"
	 		vwait done_maxsamp
			if {[info exists maxsamp_line]} {
				lappend maxbulksplitsamp [lindex $maxsamp_line 0]
			}
		}
		incr n
	}
	UnBlock
	if {![info exists maxbulksplitsamp]} {
		Inf "No Maximum Sample Information Retrieved"
		return
	} elseif {[llength $maxbulksplitsamp] != [llength $fnams]} {
		Inf "Incomplete Maximum Sample Information Retrieved"
	}
	set maxs [lindex $maxbulksplitsamp 0]
	if {[llength $maxbulksplitsamp] > 1} {
		foreach ms [lrange $maxbulksplitsamp 1 end] {
			if {$ms  > $maxs} {
				set maxs $ms
			}
		}
	}
	if {$maxs > 0.95} {
		Inf "Output Probably Overloaded: Reduce Level"
	} else {
		set msg "Max Level = $maxs"
		if {$maxs < .8} {
			set gain [DecPlaces [expr (0.95)/$maxs] 2]
			set gain [DecPlaces [expr $gain - 0.01] 2]
			append msg ": Could Increase Any Gain Parameter By $gain"
		}
		Inf $msg
	}
}

#------ Display info returned by maxsamp

proc Get_Bulksplit_Maxsamp_Info {} {
	global CDPmaxId done_maxsamp maxsamp_line

	if [eof $CDPmaxId] {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		}
		if [string match KEEP:* $line] {
			set maxsamp_line $line
		} elseif [string match ERROR:* $line] {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		}
	}
	update idletasks
}

#---- Find directories of (start of) filenames listed in textfile listing of files: write file with correct dirs

proc GrabFromDir {} {
	global wstk wl evv ch chcnt pa pr_nonexist fnam_nonexist fnam_nonexistout nonexext nonafter
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] <= 0)} {
		Inf "No File Selected"
		return
	}
	if {[llength $i] > 1} {
		Inf "Select A Single Textfile"
		return
	}
	set fnam [$wl get $i]
	if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
		Inf "Select A Single Textfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	set existcnt 0
	set nonexistcnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			continue
		}
		set line [RegulariseDirectoryRepresentation $line]
		if {[file exists $line]} {
			lappend existers $line
			lappend nonexisters 0
			incr existcnt
		} else {
			lappend existers 0
			lappend nonexisters $line
			incr nonexistcnt
		}
		lappend fnams $line
	}
	close $zit
	if {$nonexistcnt == 0} {
		Inf "All Files Are In The Directories Used In File '$fnam'"
		return
	}
	set totalcnt [expr $existcnt + $nonexistcnt]
	set nonexext 1
	set nonafter 1
	set f .nonexist
	if [Dlg_Create $f "SEARCHING FOR FILES STARTING WITH LISTED STRINGS" "set pr_nonexist 0" -borderwidth 2 -width 120] {
		frame $f.1
		button $f.1.ok -text "Find Directories" -command "set pr_nonexist 1" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Quit" -command "set pr_nonexist 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		label $f.2.ll -text "Directory (with subdirs) to search "
		entry $f.2.e -textvariable fnam_nonexist -width 32
		button $f.2.b -text "Get Directory" -command "DoListingOfDirectories .nonexist.2.e" -highlightbackground [option get . background {}]
		pack $f.2.ll $f.2.e $f.2.b -side left -padx 2
		pack $f.2 -side top -pady 2
		frame $f.3
		label $f.3.ll -text "Output filename "
		entry $f.3.e -textvariable fnam_nonexistout -width 60
		pack $f.3.ll $f.3.e -side left
		pack $f.3 -side top -pady 2
		label $f.4 -text "File Extension"
		pack $f.4 -side top -pady 6
		frame $f.5
		radiobutton $f.5.1  -variable nonexext -value 1  -text ANY
		radiobutton $f.5.2  -variable nonexext -value 2  -text "wav,aif,aiff"
;# 2023  RWD: want to have both ana and pvx in the list, like above
		radiobutton $f.5.3  -variable nonexext -value 3  -text [string range $evv(ANALFILE_EXT) 1 end]
		radiobutton $f.5.4  -variable nonexext -value 4  -text evl
		radiobutton $f.5.5  -variable nonexext -value 5  -text for
		radiobutton $f.5.6  -variable nonexext -value 6  -text frq
		radiobutton $f.5.7  -variable nonexext -value 7  -text trn
		pack $f.5.1 -side left
		pack $f.5.7 $f.5.6 $f.5.5 $f.5.4 $f.5.3 $f.5.2 -side right
		pack $f.5 -side top -pady 2 -fill x -expand true
		frame $f.6
		radiobutton $f.6.8  -variable nonexext -value 8  -text txt
		radiobutton $f.6.9  -variable nonexext -value 9  -text brk
		radiobutton $f.6.10 -variable nonexext -value 10 -text mix 
		radiobutton $f.6.11 -variable nonexext -value 11 -text mmx
		radiobutton $f.6.12 -variable nonexext -value 12 -text orc
		radiobutton $f.6.13 -variable nonexext -value 13 -text prp
		radiobutton $f.6.14 -variable nonexext -value 14 -text bat
		pack $f.6.8 -side left
		pack $f.6.14 $f.6.13 $f.6.12 $f.6.11 $f.6.10 $f.6.9 -side right
		pack $f.6 -side top -pady 2 -fill x -expand true
		label $f.7 -text "Following Characters"
		pack $f.7 -side top -pady 6
		frame $f.8
		radiobutton $f.8.0  -variable nonafter -value 0  -text "NONE"
		radiobutton $f.8.1  -variable nonafter -value 1  -text "file extension only"
		radiobutton $f.8.2  -variable nonafter -value 2  -text ANY
		radiobutton $f.8.3  -variable nonafter -value 3  -text alphanumeric
		radiobutton $f.8.4  -variable nonafter -value 4  -text alphabetic
		radiobutton $f.8.5  -variable nonafter -value 5  -text numeric
		radiobutton $f.8.6  -variable nonafter -value 6  -text underscore
		radiobutton $f.8.7  -variable nonafter -value 7  -text hyphen
		pack $f.8.0 $f.8.1 $f.8.2 $f.8.3 $f.8.4 $f.8.5 $f.8.6 $f.8.7 -side left
		pack $f.8 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_nonexist 1}
		bind $f <Escape> {set pr_nonexist 0}
	}
	set finished 0
	set pr_nonexist 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_nonexist
	while {!$finished} {
		tkwait variable pr_nonexist
		if {$pr_nonexist} {
			set searchdir [string tolower $fnam_nonexist]
			if {[string length $searchdir] <= 0} {
				Inf "No Directory Name Entered"
				continue
			}
			if {![file exists $searchdir] || ![file isdirectory $searchdir]} {
				Inf "Directory '$searchdir' Does Not Exist"
				continue
			}
			if {[string length $fnam_nonexistout] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			set outfnam [string tolower $fnam_nonexistout]
			if {![ValidCDPRootname $outfnam]} {
				continue
			}
			append outfnam $evv(TEXT_EXT)
			switch -- $nonexext {
				1  {set ext ""	}
				2  {set ext "SND" }
				3  {
;# 2023 RWD want to have both ana and pvx. How?
					set ext $evv(ANALFILE_EXT)
				}
				4  {set ext ".evl"}
				5  {set ext ".for"}
				6  {set ext ".frq"}
				7  {set ext ".trn"}
				8  {set ext ".txt"}
				9  {set ext ".brk"}
				10 {set ext ".mix"}
				11 {set ext ".mmx"}
				12 {set ext ".orc"}
				13 {set ext ".prp"}
				14 {set ext ".bat"}
			}
			Block "Searching for Files"
			set found {}
;# 2023
			set badfiles {}
			set n 0
			foreach nexi $nonexisters exi $existers {
				if {[string match $exi "0"]} {
					wm title .blocker "PLEASE WAIT:        SEARCHING FOR $nexi"
					set fdir {}
					set fdir [SearchDirsForFile $searchdir $nexi $fdir $ext $nonafter]
					if {[string length $fdir] <= 0} {
						lappend badfiles $nexi
					} else {
						set existers [lreplace $existers $n $n $fdir]
						lappend found $n
					}
				}
				incr n
			}
			UnBlock
			if {[info exists badfiles]} {
				set msg "The Following Files Are Not In The Specified Directory (Or Its Subdirectories)\n"
				set n 0
				foreach zfnam $badfiles {
					append msg $zfnam "\n"
					incr n
					if {$n >= 20} {
						append msg "And More"
						break
					}
				}
				Inf $msg
				if {[llength $found] > 0} {
					set n 0
					set msg "The Following Files Are In The Directories Shown\n"
					foreach k $found {
						append msg [lindex $existers $k] "\n"
						incr n
						if {$n >= 20} {
							append msg "And More\n"
							break
						}
					}
					append msg "Write All Found Files To Output ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if [catch {open $outfnam "w"} zit] {
							Inf "Cannot Open File '$outfnam' To Write New Data"
						} else {
							foreach exi $existers {
								if {![string match $exi "0"]} {
									puts $zit $exi
								}
							}
							close $zit
							if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
								Inf "File '$outfnam' Is On The Workspace"
							}
						}
					}
				}
			} else {
				if [catch {open $outfnam "w"} zit] {
					Inf "Cannot Open File '$outfnam' To Write New Data"
				} else {
					foreach exi $existers {
						puts $zit $exi
					}
					close $zit
					if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
						Inf "File '$outfnam' Is On The Workspace"
					}
					set finished 1
				}
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Search Directories for filename starting with given searchstring

proc SearchDirsForFile {dirname str fdir ext afterchar} {
	global pa evv
	set str [string tolower $str]
	set len [string length $str]
	foreach fnam [glob -nocomplain [file join $dirname *]] {
		set fnam [string tolower $fnam]
		if {[file isdirectory $fnam]} {
			if {![CDP_Restricted_Directory $fnam 1]} {
				set fdir [SearchDirsForFile $fnam $str $fdir $ext $afterchar]
			}
			continue
		}
		if [IgnoreSoundloomxxxFilenames $fnam] { 
			continue
		}
		set tfnam  [file tail $fnam]
		set rfnam  [file rootname $tfnam]
		set rlen [string length $rfnam]
		set filext [file extension $tfnam]
		if {[string first $str $tfnam] != 0} {
			continue
		}
		switch -- $afterchar {
			0 {			;#	NO ENSUING CHARACTERS ALLOWED
				if {![string match $str $tfnam]} {
					continue
				}
			}
			1 {			;#	FILE EXTENSION ONLY
				if {![string match $str $rfnam]} {
					continue
				}
			}
			2 {			;#	ANY ENSUING CHARACTERS ALLOWED
			}
			default {	;#	SPECIFIC (TYPE OF) ENSUING CHARACTER ALLOWED
				if {$len < $rlen} {
					set thischar [string index $rfnam $len]
					switch -- $afterchar {
						3 {		;#	ALPHANUMERIC
							if {![regexp {^[A-Za-z0-9]$} $thischar]} {
								continue
							}
						}
						4 {		;#	ALPHABETIC
							if {![regexp {^[A-Za-z]$} $thischar]} {
								continue
							}
						}
						5 {		;#	NUMERIC
							if {![regexp {^[0-9]$} $thischar]} {
								continue
							}
						}
						6 {		;#	UNDERSCORE
							if {![regexp {^[\_]$} $thischar]} {
								continue
							}
						}
						7 {		;#	HYPHEN
							if {![regexp {^[\-]$} $thischar]} {
								continue
							}
						}
					}
				}
			}
		}
		if {[string length $ext] == 0} {
			lappend fdir $fnam
		} else {
			if {[string match $ext "SND"]} {
				if {[string match ".wav"  $filext] || [string match ".aif"  $filext] || [string match ".aiff" $filext] } {
					lappend fdir $fnam
				}
			} elseif {[string match $ext $filext]} {
				lappend fdir $fnam
			}
		}
	}
	return $fdir
}

#-- Copy files with bad headers

proc CopyToStandardFormat {fnam} {
	global prg_dun prg_abortd CDPidrun evv
	set outfile [file tail $fnam]
	set cmd [file join $evv(CDPROGRAM_DIR) copysfx]
	lappend cmd $fnam $outfile
	catch {unset simple_program_messages}
	set prg_dun 0
	set prg_abortd 0
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Failed To Copy To Standard Format"
		catch {unset CDPidrun}
		return ""
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Copy To Standard Format"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return ""
	}
	if {![file exists $outfile]} {
		set msg "Failed To Copy To Standard Format"
		return ""
	}
	return $outfile
}

#------ Hilite workspace files in a specified directory

proc SelectSpecDir {} {
	global pr_specdir specdir_dir wl evv wksp_dirname

	if {![info exists wksp_dirname] || ([string length $wksp_dirname] <= 0)} {
		Inf "No Directory Specified"
		return
	}
	if {![file exists $wksp_dirname] || ![file isdirectory $wksp_dirname]} {
		Inf "Specified Directory ($wksp_dirname) Does Not Exist"
		return
	}
	set i 0
	foreach fnam [$wl get 0 end] {
		set thisdir [file dirname $fnam]
		if {[string match -nocase $thisdir $wksp_dirname]} {
			lappend ilist $i
		}
		incr i
	}
	if {![info exists ilist]} {
		Inf "There Are No Files From This Directory On The Workspace"
		continue
	}
	$wl selection clear 0 end
	foreach i $ilist {
		$wl selection set $i
	}
	set i [lindex $ilist 0]
	if {$i > $evv(WKSPACE_HEIGHT)} {
		set len [$wl index end]
		set val [expr double($i)/double($len)]
		$wl yview moveto $val
	}
}

#---- New "loadWkspace", simplifying error reporting (and allowing user to switch it off)

proc LoadWkspace {wrksp_file initial} {
	global fileWkspId ww wl do_parse_report pa evv wstk do_the_qikload is_initial_parse badparse_ignore
	global chlist ch fileChosId chcnt sl_real
	global pprg mmod again last_chlist last_ch lalast_ch
	global wksp_cnt total_wksp_cnt rememd pim last_mix last_b_l parse_the_max maxsamp2_version texture_version
	global dupl_mix dupl_vbx dupl_txt ch_analy

	set doqikload 0
	set tell_me 0
	if {$initial} {
		set is_initial_parse 1
		Block "Loading Workspace"
		set maxsamp2_version [GetVersion maxsamp2]
		set texture_version [GetVersion texture]
		set tell_me -1
	} else {
		catch {unset is_initial_parse}
		Block "Loading New Workspace"
	}
	if [file exists $wrksp_file] {
		if [catch {open $wrksp_file} fileWkspId] {
			Inf "Cannot Open Workspace File '$wrksp_file'"
			return 1								;#	No need to exit program
		}
		catch {unset pa}
		if {[info exists evv(THUMDIR)]} {
			RestoreThumbnailProps
		}
		if {!$initial} {
			if {![info exists rememd]} {
				RememberList wl 0
			}
			$wl delete 0 end
			if {[info exists wksp_cnt] && ($wksp_cnt > 0)} {
				catch {unset rememd}
			}
			set wksp_cnt 0
			set total_wksp_cnt 0
		} else {
			set doqikload [QikLoadPrepare]			;#	Check HERE for qikload info
		}
		set OK 1
		set restore_told 0
		while {$OK && ([gets $fileWkspId fnam] >= 0)} {
			set fnam [AdjustDirname $fnam]
			if [file exists $fnam] {		;#	Attempt to load files listed in existing wkspace file
				if {$initial && $doqikload} {
					if {[QikLoad $fnam]} {
						continue
					}
				}
				set fnam [string tolower $fnam]
				if [IgnoreSoundloomxxxFilenames $fnam] { 
					continue
				}
				set test [FileToWkspace $fnam 0 0 1 0 0]
				if {$test == $evv(PARSE_FAILED)} {
					if {[file isfile $fnam] && ([LstIndx $fnam $wl] < 0)} {
						lappend badfiles $fnam
					}
				} elseif {$test < 0} {
					if {$initial} {
						catch {close $fileWkspId}
						return 0
					} else {
						lappend badfiles $fnam
					}
				} elseif {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)}  {
					if {![info exists pa($fnam,$evv(MAXREP))] && $parse_the_max} {	;#	Otherwise it's already known
						GetMaxsampOnInput $fnam
					}
				}
			} else {
				if {$initial} {
					if {$doqikload} {
						QikLoadPurge $fnam
					}
					switch -- $tell_me {
						-1 {
							set choice [tk_messageBox -type yesno -default yes \
							-message "File '$fnam' No Longer Exists : Do You Wish To Know Which Other Files No Longer Exist ?" \
							-icon question -parent [lindex $wstk end]]
							if {$choice == "no"} {
								set tell_me 0
							} else {
								set tell_me 1
								set cnt 0
							}
						}
						1 {
							lappend nolongerlist $fnam
							incr cnt
							if {$cnt >= 20} {
								set msg "The Following Files No Longer Exist\n"
								foreach fffnam $nolongerlist {
									append msg "$fffnam\n"
								}
								Inf $msg
								set cnt 0
								unset nolongerlist
							}
						}
					}
				} else {
					if {!$restore_told} {
						set choice [tk_messageBox -type yesno -default yes \
						-message "File '$fnam' No Longer Exists : Do You Wish To Continue With Restoring This Workspace ?" \
						-icon question -parent [lindex $wstk end]]
						if {$choice == "no"} {
							set OK 0
						}
						set restore_told 1
					}
				}
			}
		}
		if {$initial && $doqikload} {
			QikLoadFlush
		}	
		close $fileWkspId
		if {[info exists nolongerlist]} {
			set msg "The Following Files No Longer Exist\n\n"
			foreach fffnam $nolongerlist {
				append msg "$fffnam\n"
			}
			Inf $msg
		}
	}												;#	Load all files NOT wkspace listed
													;#	But remaining IN wkspace directory
	foreach fnam [glob -nocomplain *] {
#JUNE 30 UC-LC FIX
		set fnam [string tolower $fnam]
		if [file isdirectory $fnam] {
			continue
		} elseif [IgnoreSoundloomxxxFilenames $fnam] { 
			continue
		} elseif {[info exists asked_re_delete] && ([lsearch -exact $asked_re_delete $fnam] >= 0)} {
			continue
		}
		if {[LstIndx $fnam $wl] < 0} {
			if {[string match $evv(MACH_OUTFNAME)* $fnam] \
			||  [string match $evv(DFLT_OUTNAME)* $fnam] \
			||  [string match $evv(DFLT_TMPFNAME)* $fnam]} {
				if [catch {file delete -force $fnam} xx] {
					lappend badfiles2 $fnam
				}
				continue
			}
			set do_parse_report 0
			if {[DoParse $fnam $wl 2 0] <= 0} {
				lappend badfiles $fnam
			} else {
				if {$initial} {
					$wl insert end $fnam			;#	Possibly spurious; to foot of listing
				} else {
					$wl insert 0 $fnam				;#	Simply unbakdup : to top of listing
				}
				WkspCntSimple 1
			}
		}
	}
	if {$initial} {										;#	If this is an initial workspace load,
		if [file exists $evv(CHOSEN_FILE)] {			;#	Load chlist data
			if [catch {open $evv(CHOSEN_FILE)} fileChosId] {
				Inf "Cannot Open Existing Chosen-Files File"		;#	No need to exit program
			} else {
				while { [gets $fileChosId fnam] >= 0} {
					if {[LstIndx $fnam $wl] >= 0} {
						lappend chlist $fnam
						lappend last_ch $fnam
		 				$ch insert end $fnam
						incr chcnt
					}
				}
				if {[info exists chlist] && ([llength $chlist] == 1)} {
					set fzam [lindex $chlist 0]
					if {[IsAMixfileIncludingMultichan $pa($fzam,$evv(FTYP))]} {
						set last_mix $fzam
					}
				}
			}
			catch {close $fileChosId}
		}
		if {$sl_real} {
			GetSrcListsFromFile								;#	and load srcs-of-nonsoundfiles info
			GetRecentDirsFromFile
			if {![NnnLoad]} {
				return 0
			}
		}
	} else {
		set pprg 0				 					;#	Otherwise, reset GUI memory
		set mmod 0
		set again(0) -1
		set again(1) -1
		catch {$pim.last.2 config -text "NONE"}
		catch {unset chlist}
		set dupl_mix 0
		set dupl_vbx 0
		set dupl_txt 0
		set ch_analy 0
		catch {unset last_chlist}
		catch {unset last_ch}
		catch {unset lalast_ch}
		catch {unset last_mix}
		$ch delete 0 end
		set chcnt 0
	}
	UnBlock

	if {$initial && ![info exists badparse_ignore]} {
		if {[info exists badfiles]} {
			set len [llength $badfiles]
			if {$len == 1} {
				set msg "1 File Was Not Recognised By The Soundloom Parser: And Not Loaded To The Workspace.\n"
				append msg "You Can Either\n"
				append msg "(1) Ignore It On This Occasion,\n"
			} else {
				set msg "[llength $badfiles] Files Were Not Recognised By The Soundloom Parser: : And Not Loaded To The Workspace.\n"
				append msg "You Can Either\n"
				append msg "(1) Ignore These On This Occasion,\n"
			}
			append msg "(2) Always Ignore These By Selecting That Option On The \"System\" Menu\n"
			append msg "(3) See Which Files These Are\n"
			append msg "(4) Selectively Delete Unwanted Files Now\n"
			Inf $msg
			set msg "Ignore File(s) On This Occasion ??"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				set msg "The Files Are\n"
				set cnt 0
				foreach fnam $badfiles {
					append msg "$fnam\n"
					incr cnt
					if {$cnt >= 20} {
						append msg "And More\n"
						break
					}
				}
				if {$len == 1} {
					append msg "Delete This File Now ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						set fnam [lindex $badfiles 0]
						if [catch {file delete -force $fnam} xx] {
							Inf "$xx\nCannot Remove File '$fnam' : Ignoring It"
						} else {
							DataManage delete $fnam
							lappend couettedelete $fnam
							DummyHistory $fnam "DESTROYED"
						}
					}
				} else {
					append msg "Selectively Delete These Files Now ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						foreach fnam $badfiles {
							set msg "Delete File '$fnam' ??"
							set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								if [catch {file delete -force $fnam} xx] {
									Inf "$xx\nCannot Remove File '$fnam' : Ignoring It"
								} else {
									DataManage delete $fnam
									lappend couettedelete $fnam
									DummyHistory $fnam "DESTROYED"
								}
							}
						}
					}
				}
			}
		}
		if {[info exists couettedelete]} {
			CouettePatchesDelete $couettedelete
		}
	}
	if {$initial && [info exists badfiles2]} {
		set len [llength $badfiles2]
		if {$len == 1} {
			set msg "A CDP Temporary File Could Not Be Deleted.\n"
		} else  {
			set msg "[llength $badfiles2] CDP Temporary Files Could Not Be Deleted.\n"
		}
		append msg "\n"
		append msg "This May Be Because The File Is Open In Some Other Application\n"	
		append msg "Or Because A CDP Program Is Still Running, After A Crash.\n"
		append msg "\n"
		append msg "These Files Should Be Removed Before Proceeding\n"
		append msg "As They May Prevent Other CDP Processes From Running.\n"
		append msg "\n"
		append msg "The Files Are\n"
		set cnt 0
		foreach fnam $badfiles2 {
			append msg "$fnam\n"
			incr cnt
			if {$cnt >= 20} {
				append msg "And More\n"
				break
			}
		}
		Inf $msg
	}
	if {!$initial} {
		ChlistDupls
		DuplFilesMsg
	}
	catch {unset is_initial_parse}
	return 1
}

#------ Load info about ignoring badfiles at startup

proc LoadIgnoreBadfiles {} {
	global badparse_ignore evv
	set fnam [file join $evv(CDPRESOURCE_DIR) badig$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set badparse_ignore 1
	}
}

#------ Change whether to ignore or check badfiles at startup

proc IgnoreBadfiles {} {
	global badparse_ignore evv wstk
	set fnam [file join $evv(CDPRESOURCE_DIR) badig$evv(CDP_EXT)]
	if {[info exists badparse_ignore]} {
		set msg "Bad Files At Startup Are Currently Always Ignored: Change This ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			unset badparse_ignore
			if {[file exists $fnam]} {
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Delete File '$fnam' To Remember That Bad Files At Startup Are NOT To Be Ignored"
				}
			}
		}	
	} else {
		set msg "Bad Files At Startup Are Currently Always Checked: Change This ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set badparse_ignore 1
			if [catch {open $fnam "w"} zit] {
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Create File '$fnam' To Remember That Bad Files At Startup Are To Be Ignored"
				}
			}
		}
	}
}

#-------- Hilight on the workspace (only) those files selected on the Chosen list

proc HilightChosen {totop} {
	global chlist wl selection_mode evv
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		return
	}
	if {$selection_mode} {
		ToWkspaceMode
		return
	}
	foreach fnam $chlist {
		set i [LstIndx $fnam $wl]
		if {$i >= 0} {
			lappend ilist $i
		}
	}
	if {![info exists ilist]} {
		return
	}
	set ilist [RemoveDuplicatesInList $ilist]
	if {$totop} {
		foreach i $ilist {
			lappend nuwk [$wl get $i]
		}		
		set i 0
		foreach fnam [$wl get 0 end] {
			if {[lsearch $ilist $i] < 0} {
				lappend nuwk [$wl get $i]
			}
			incr i
		}
		$wl delete 0 end
		foreach fnam $nuwk {
			$wl insert end $fnam
		}
		set len [llength $ilist]
		unset ilist
		set i 0
		while {$i < $len} {
			lappend ilist $i
			incr i
		}
	}
	$wl selection clear 0 end
	foreach i $ilist {
		$wl selection set $i
	}
	set i [lindex $ilist 0]
	if {$i > $evv(WKSPACE_HEIGHT)} {
		incr i -3
		set rat [expr double ($i)/double([$wl index end])]
		$wl yview moveto $rat
	} elseif {[lindex [$wl yview] 0] > 0.0} {
		$wl yview moveto 0.0
	}
}

proc EstablishSessionDateDisplay {} {
	global superlog logname logname_got CDPid
	if {[info exists superlog]} {
		set daydate $superlog
	} else {
		set cmd [file join $evv(CDPROGRAM_DIR) listdate]
		if [ProgMissing $cmd ""] {
			return ""
		}
		set logname_got 0
		if [catch {open "|$cmd"} CDPid] {
			catch {unset CDPid}
			return ""
		} else {
			fileevent $CDPid readable SetLogname		;#	Display info from program
			fconfigure $CDPid -buffering line
			vwait logname_got
		}
		if {![info exists logname]} {
			return ""
		}
		set daydate $logname
	}
	set daydate [split $daydate "_"]
	set date [lindex $daydate 0]
	set daydate [split [lindex $daydate 1] "."]
	set year [lindex $daydate 1]
	set daydate [split [lindex $daydate 0] "-"]
	set time [lindex $daydate 0]
	append time ":" [lindex $daydate 1]
	set daydate $date
	append daydate " " ($year) "  " $time
	return $daydate
}

proc FilesLeft {} {
	global dl pr_5 evv
	if [info exists dl] {
		set ilist [$dl curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			set pr_5 $evv(DO_GRAB)
			return
		}
	}
	GetNextToChosen 4
}

proc FilesDeselect {} {
	global ch chlist chcnt wl
	if [info exists ch] {
		set ilist [$ch curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			set len [llength $chlist]
			set i 0
			while {$i < $len} {
				if {[lsearch $ilist $i] < 0} {
					lappend nulist [lindex $chlist $i]
				}
				incr i
			}
			DoChoiceBak
			$ch delete 0 end
			catch {unset chlist}
			set chcnt 0
			if {[info exists nulist]} {
				set chlist $nulist
				foreach fnm $chlist {
					$ch insert end $fnm
					incr chcnt
				}
			}
			ChlistDupls
			UnsetThumbnail
			return
		}
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {
		return
	}
	RemoveFromWkspace wk
}

proc TellEngineer {} {
	set msg "              MULTICHANNEL ENGINEERING\n"	
	append msg "\n"
	append msg "Modify 1 or more channels of multichannel file.\n"
	append msg "\n"
	append msg "Reintegrate modified chans with other channels\n"
	append msg "to produce a new multichannel output\n"
	append msg "\n"
	append msg "Duration of individual channel data cannot be changed.\n"
	append msg "\n"
	append msg "Available processes either cannot change the duration\n"
	append msg "or can be set not to change the duration.\n"
	Inf $msg
}

proc ShowComp {} {
	global shc_ilist0 shc_ilist1 compare_fils
	switch -- $compare_fils {
		0 {
			.textcomp.b.b.ll.list selection clear 0 end
			if {[info exists shc_ilist0]} {
				foreach i $shc_ilist0 { 
					.textcomp.b.b.ll.list selection set $i
				}
				set k [lindex $shc_ilist0 0]
				if {$k >= 48} {
					set j [.textcomp.b.b.ll.list index end]
					set val [expr double($k)/double($j)]
					.textcomp.b.b.ll.list yview moveto $val
					.textcomp.b.c.ll.list yview moveto $val
				}
			}
		}
		1 {
			.textcomp.b.c.ll.list selection clear 0 end
			if {[info exists shc_ilist1]} {
				foreach i $shc_ilist1 { 
					.textcomp.b.c.ll.list selection set $i
				}
				set k [lindex $shc_ilist1 0]
				if {$k >= 48} {
					set j [.textcomp.b.c.ll.list index end]
					set val [expr double($k)/double($j)]
					.textcomp.b.b.ll.list yview moveto $val
					.textcomp.b.c.ll.list yview moveto $val
				}
			}
		}
	}
}
			
proc ShowCompMix {} {
	global shc_ilist0m shc_ilist1m compare_filsm
	switch -- $compare_filsm {
		0 {
			.textcomp.b.b.ll.list selection clear 0 end
			if {[info exists shc_ilist0m]} {
				foreach i $shc_ilist0m { 
					.textcomp.b.b.ll.list selection set $i
				}
				set k [lindex $shc_ilist0m 0]
				if {$k >= 48} {
					set j [.textcomp.b.b.ll.list index end]
					set val [expr double($k)/double($j)]
					.textcomp.b.b.ll.list yview moveto $val
					.textcomp.b.c.ll.list yview moveto $val
				}
			}
		}
		1 {
			.textcomp.b.c.ll.list selection clear 0 end
			if {[info exists shc_ilist1m]} {
				foreach i $shc_ilist1m { 
					.textcomp.b.c.ll.list selection set $i
				}
				set k [lindex $shc_ilist1m 0]
				if {$k >= 48} {
					set j [.textcomp.b.c.ll.list index end]
					set val [expr double($k)/double($j)]
					.textcomp.b.b.ll.list yview moveto $val
					.textcomp.b.c.ll.list yview moveto $val
				}
			}
		}
	}
}

#----- Keyboard Shortcut : move selected files up or down in any of workspace listings

proc FilesMove {up} {
	global ch chlist dl wl
	set fselected {}
	set funselctd {}
	if [info exists ch] {
		set ilist [$ch curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			set len [llength $chlist]
			set i 0
			while {$i < $len} {
				if {[lsearch $ilist $i] >= 0} {
					lappend fselected [lindex $chlist $i]
				} else {
					lappend funselctd [lindex $chlist $i]
				}
				incr i
			}
			if {$up} {
				set chlist [concat $fselected $funselctd]
			} else {
				set chlist [concat $funselctd $fselected]
			}
			$ch delete 0 end
			foreach fnm $chlist {
				$ch insert end $fnm
			}
			return
		}
	}
	if [info exists dl] {
		set ilist [$dl curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			set len [$dl index end]
			set i 0
			while {$i < $len} {
				if {[lsearch $ilist $i] >= 0} {
					lappend fselected [$dl get $i]
				} else {
					lappend funselctd [$dl get $i]
				}
				incr i
			}
			if {$up} {
				set nulist [concat $fselected $funselctd]
			} else {
				set nulist [concat $funselctd $fselected]
			}
			$dl delete 0 end
			foreach fnm $nulist {
				$dl insert end $fnm
			}
			return
		}
	}
	if {$up} {
		TopOfWkspace 0
		return
	}
	FootOfWkspace
}

################################################################
# WORKSPACE FACILITY TO PLAY AN EXISTING MAIN MIX SOUND OUTPUT #
################################################################

proc PlayMainMix {} {
	global ww wl main_mix evv pa wstk
	if {![info exists main_mix(snd)] || ![file exists $main_mix(snd)]} {
		catch {unset main_mix(snd)}
		if {![FindMainMixSound]} {
			return
		}
	}
	PlaySndfile $main_mix(snd) 0
}

#--- Find output of main mix, if possible

proc FindMainMixSound {} {
	global wl main_mix evv pa wstk

	Block "Looking for Main Mix Output"
	set nofile_yet 1
	set fnam [file rootname $main_mix(fnam)]						;#	Look for a soundfile with same name and dir as mixfile
	append fnam $evv(SNDFILE_EXT)
	if {[file exists $fnam]} {
		set nofile_yet 0
	}
	if {$nofile_yet} {												;#	Then look for any soundfile in directory of mixfile
		set thisdir [file dirname $fnam]							;#	whose name starts with name of mixfile.	
		if {![string match $fnam [file tail $fnam]]} {
			foreach wfnam [glob -nocomplain [file join $thisdir *]]] {
				set ftyp [FindFileType $wfnam]
				if {($ftyp == $evv(SNDFILE)) && ([string first [file rootname [file tail $fnam]] [file rootname [file tail $wfnam]]] == 0)} {
					set msg "Use Output File '$wfnam' ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						set fnam $wfnam
						set nofile_yet 0
						break
					}
				}
			}
		}
	}	
	if {$nofile_yet} {												;#	Then look for any soundfile with same name as mixfile	
		set fnam [file tail $fnam]									;#	in base directory
		foreach wfnam [$wl get 0 end] {
			if {($pa($wfnam,$evv(FTYP)) == $evv(SNDFILE)) && [string match [file tail $wfnam] $fnam]} {
				set msg "Use Output File '$wfnam' ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set fnam $wfnam
					set nofile_yet 0
					break
				}
			}
		}
	}
	if {$nofile_yet} {												;#	Then look for any soundfile starting with same name as mixfile	
		foreach wfnam [$wl get 0 end] {								;#	in base directory
			if {$pa($wfnam,$evv(FTYP)) == $evv(SNDFILE)} {
				if {[string first $fnam [file tail $wfnam]] == 0} {
					set msg "Use Output File '$wfnam' ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						set fnam $wfnam
						set nofile_yet 0
						break
					} else {
						break
					}
				}
			}
		}
	}
	UnBlock
	if {$nofile_yet} {
		set zfnam [file rootname [file tail $main_mix(fnam)]]
		set msg "No Mix Output Found In Directory Of Main Mix, Or On Workspace:\n\nDo Wider Search ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			set fnam [MainMixWideSearch $zfnam $thisdir]
			if {[string length $fnam] <= 0} {
				set msg "Specify A Different Soundfile As Output Of Main Mix ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					MainMixButton 1
					return 0
				}		
				set fnam [MainMixWideSearch 0 $thisdir]
				if {[string length $fnam] <= 0} {
					MainMixButton 1
					return 0
				}
			}
		} else {
			MainMixButton 1
			return 0
		}
	}
	set msg "Using '$fnam' As Output Of Main Mix: OK ??"
	set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		set msg "Specify A Different Soundfile As Output Of Main Mix ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			MainMixButton 1
			return 0
		}		
		set fnam [MainMixWideSearch 0 $thisdir]
		if {[string length $fnam] <= 0} {
			MainMixButton 1
			return 0
		}
	}
	if {![info exists pa($fnam,$evv(CHANS))]} {
		if {[DoParse $fnam 0 0 0] <= 0} {
			return 0
		}
	}
	set main_mix(snd) $fnam
	return 1
}

#--- Find output of main mix, by comparing less and less of mixfilename chars

proc MainMixWideSearch {fnam mdir} {
	global wl evv pa wstk pr_wider widerfnam

	set poss {}
																				;#	Where the seartch is for ANY sounfile
	if {[string match $fnam "0"]} {
		foreach wfnam [glob -nocomplain [file join $mdir *]]] {					;#	For every file in directory of mix
			if {[string match [file extension $wfnam] $evv(SNDFILE_EXT)]} {		;#	If it's a sndfile
				lappend poss $wfnam												;#  retain it as possible
			}
		}
		foreach wfnam [$wl get 0 end] {											;#	For every file in CDP base directory
			if {[string match [file extension $wfnam] $evv(SNDFILE_EXT)]} {		;#	If it's a sndfile
				lappend poss $wfnam												;#  retain it as possible
			}
		}

	} else {
		Block "Searching Wider for Main Mix Output"
		set len [string length $fnam]											;#	Where the search is for a semi-matching name
		set k [expr $len - 1]
		while {$k >= 3} {
			foreach wfnam [glob -nocomplain [file join $mdir *]]] {				;#	For every file in directory of mix
				if {[string match [file extension $wfnam] $evv(SNDFILE_EXT)]} {	;#	If it's a sndfile
					set twfnam [file tail $wfnam]
					if {[string first [string range $fnam 0 $k] $twfnam] == 0} {;#  and it starts with same k letters as fnam
						if {[lsearch $poss $wfnam] < 0} {						;#	and it's not already chosen, keep it
							lappend possibs($k) $wfnam
							lappend poss $wfnam
						}
					}
				}
			}
			incr k -1
		}
		set k [expr $len - 1]
		while {$k >= 3} {
			foreach wfnam [$wl get 0 end] {										;#	For every file in CDP base directory
				set twfnam [file tail $wfnam]
				if {[string match [file extension $wfnam] $evv(SNDFILE_EXT)]} {	;#	If it's a sndfile
					if {[string first [string range $fnam 0 $k] $twfnam] == 0} {;#  and it starts with same k letters as fnam
						if {[lsearch $poss $wfnam] < 0} {						;#	and it's not already chosen, keep it
							lappend possibs($k) $wfnam
							lappend poss $wfnam
						}
					}
				}
			}
			incr k -1
		}
		if {[llength $poss] > 0} {
			set poss {}
			set k [expr $len - 1]
			while {$k >= 3} {
				if {[info exists possibs($k)]} {								;#	Sort possible files, so those with most chars in common
					set poss [concat $poss $possibs($k)]						;#	with orig filename, are at top of list
				}
				incr  k -1
			}
		}
		UnBlock
	}
	if {[llength $poss] <= 0} {
		Inf "No Suitable File Found In Wider Search"
		return ""
	}
	set f .wider
	if [Dlg_Create $f "HILIGHT WORKSPACE FILES IN SPECIFIED DIRECTORY" "set pr_wider 0" -borderwidth 2] {
		frame $f.1
		button $f.1.ok -text "Select" -command "set pr_wider 1" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Quit" -command "set pr_wider 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		Scrolled_Listbox $f.2.ll -width 120 -height 24 -selectmode single
		pack $f.2.ll -side top -fill both -expand true -pady 2
		pack $f.2 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Return> {set pr_wider 1}
		bind $f <Escape> {set pr_wider 0}
	}
	$f.2.ll.list delete 0 end
	foreach fnam $poss {
		$f.2.ll.list insert end $fnam
	}
	set widerfnam ""
	set finished 0
	set pr_wider 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_wider $f.2.ll.list
	while {!$finished} {
		tkwait variable pr_wider
		if {$pr_wider} {
			set i [.wider.2.ll.list curselection]
			if {$i < 0} {
				Inf "No File Selected"
				continue
			}
			set widerfnam [.wider.2.ll.list get $i]
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	return $widerfnam
}

#--- Display (or not) the "Play Main Mix" button

proc MainMixButton {off} {
	global ww main_mix evv
	if {$off} {	;#	OFF
		$ww.1.a.endd.l.sub.qik.main.play config -text "" -command {} -bg [option get . background {}] -bd 0 -state disabled
		$ww.1.a.endd.l.sub.qik.main.kill config -text "" -command {} -bd 0 -state disabled
	} elseif {[info exists main_mix(fnam)]} {
		$ww.1.a.endd.l.sub.qik.main.play config -text "Play Main Mix" -command "PlayMainMix" -bg $evv(SNCOLOR) -bd 2
		$ww.1.a.endd.l.sub.qik.main.kill config -text "Not!" -command "DumpMainMixSnd" -bd 2
	}
}

#--- Get Rid of Inappropriate Sound assocd with "Play Main Mix" button

proc DumpMainMixSnd {} {
	global main_mix wstk evv
	set msg "Is The Wrong Sound Associated With Main Mix ??"
	set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		return
	}
	catch {unset main_mix(snd)}
	Inf "Try Again"
}

#---- Check for renaming of main_mix and its sound output

proc CheckMainmixSnd {fnam nufnam} {
	global main_mix
	if {[info exists main_mix(snd)] && [string match $main_mix(snd) $fnam]} {
		set main_mix(snd) $nufnam
	}
}

proc CheckSwapMainmixSnd {fnam1 fnam2} {
	global main_mix
	if {[info exists main_mix(snd)]} {
		if {[string match $main_mix(snd) $fnam1]} {
			set main_mix(snd) $fnam2
		} elseif {[string match $main_mix(snd) $fnam2]} {
			set main_mix(snd) $fnam1
		}
	}
}

proc CheckMainmix {fnam nufnam} {
	global main_mix
	if {[info exists main_mix(fnam)] && [string match $main_mix(fnam) $fnam]} {
		set main_mix(fnam) $nufnam
	}
}

proc CheckSwapMainmix {fnam1 fnam2} {
	global main_mix
	if {[info exists main_mix(fnam)]} {
		if {[string match $main_mix(fnam) $fnam1]} {
			set main_mix(fnam) $fnam2
		} elseif {[string match $main_mix(fnam) $fnam2]} {
			set main_mix(fnam) $fnam1
		}
	}
}

proc KeyMaxsamp {} {
	global wl ch chlist dl CDPmaxId done_maxsamp maxsamp_line evv
	set ilist [$wl curselection]
	if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
		GetMaxsamps 0 1
		return
	}
	if {[info exists chlist]} {
	set ilist [$ch curselection]
		if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
			GetMaxsamps 1 0
			return
		}
	}
	set ilist [$dl curselection]
	if {[info exists ilist] && ([llength $ilist] > 0) && ([lindex $ilist 0] != -1)} {
		if {[llength $ilist] > 1} {
			Inf "Select A Single File In Directory Listing"
			return
		}
		set fnam [$dl get $ilist]
		set ftyp [FindFileType $fnam]
		if {$ftyp != $evv(SNDFILE)} {
			return
		}
		set done_maxsamp 0
		catch {unset maxsamp_line}
		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		if {[ProgMissing $cmd "'maxsamp2$evv(EXEC)' Is Not On Your System. Cannot Search For Maximum Samples In File."]} {
			return
		}
		lappend cmd $fnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
			return
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "Cannot Retrieve Maximum Sample Information For '$fnam'"
			return
		}
		Inf "Maximum sample = [lindex $maxsamp_line 0] at (grouped)sample [lindex $maxsamp_line 1]"
		unset maxsamp_line
	}
}

proc Tasks {} {
	global pr_tasks tasklist evv wstk
	set tasksfnam [file join $evv(URES_DIR) tasks$evv(CDP_EXT)]
	set f .tasks
	if [Dlg_Create $f "TASK LIST" "set pr_tasks 0" -borderwidth $evv(BBDR)] {
		set b [frame $f.b]
		set k [frame $f.k]		
		button $b.keep -text "Keep Changes"    -command "set pr_tasks 1" -highlightbackground [option get . background {}]
		label $b.dum  -text "" -width 20
		button $b.quit -text "No Changes"      -command "set pr_tasks 0" -highlightbackground [option get . background {}]
		button $b.kill -text "Delete Tasklist" -command "set pr_tasks 2" -highlightbackground [option get . background {}]
		pack $b.keep $b.dum $b.kill -side left
		pack $b.quit -side right
		pack $b -side top -fill x -expand true
		label $f.d -text "TASKLIST" -fg $evv(SPECIAL)
		pack $f.d -side top -pady 2
		set t [text $k.t -setgrid true -wrap word -width 76 -height 32 \
		-xscrollcommand "$k.sx set" -yscrollcommand "$k.sy set"]
		scrollbar $k.sy -orient vert  -command "$f.k.t yview"
		scrollbar $k.sx -orient horiz -command "$f.k.t xview"
		pack $k.t -side left -fill both -expand true
		pack $k.sy -side right -fill y
		pack $f.k -side top -fill x
		bind $f.k.t <Control-s> "set pr_tasks 1"
		bind $f.k.t <Control-S> "set pr_tasks 1"
		bind $f.k.t <Control-P>	"UniversalPlay text $f.k.t"
		bind $f.k.t <Control-p>	"UniversalPlay text $f.k.t" 
		bind $f.k.t <Control-G>	"UniversalGrab $f.k.t"
		bind $f.k.t <Control-g>	"UniversalGrab $f.k.t" 
		bind $f <Escape> {set pr_tasks 0}
	}
	.tasks.k.t delete 1.0 end
	if {[info exists tasklist]} {
		foreach item $tasklist {
			.tasks.k.t insert end $item\n
		}
	}
	set finished 0
	set pr_tasks 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_tasks .tasks.k.t
	while {!$finished} {
		tkwait variable pr_tasks
		switch -- $pr_tasks {
			1 {
				catch {unset empty}
				catch {unset tasklist}
				set tasklist [split [.tasks.k.t get 1.0 end] "\n"]
				set len [llength $tasklist]
				incr len -1
				if {$len < 0} {
					set empty 1
				} else {
					while {[llength [lindex $tasklist $len]] <= 0} {
						incr len -1
						if {$len < 0} {
							set empty 1
							break
						}
						set tasklist [lrange $tasklist 0 $len]
					}
				}
				if {[info exists empty]} {
					catch {unset tasklist}
					if {[file exists $tasksfnam]} {
						if [catch {file delete $tasksfnam} zit] {
							Inf "Cannot Delete Existing Tasklists File '$tasksfnam'"
						}
					}
				} else {
					SaveTasks
				}
				set finished 1
			} 
			2 { 
				if {![AreYouSure]} {
					continue
				}
				catch {unset tasklist}
				if {[file exists $tasksfnam]} {
					if [catch {file delete $tasksfnam} zit] {
						Inf "Cannot Delete Existing Tasklists File '$tasksfnam'"
					}
				}
				set finished 1
			}
			0 { 
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc LoadTasks {} {
	global evv tasklist
	set fnam [file join $evv(URES_DIR) tasks$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	while {[gets $zit line] >= 0} {
		lappend tasklist $line
	}
	close $zit
}

proc SaveTasks {} {
	global evv tasklist
	if {[info exists tasklist] && ([llength $tasklist] <= 0)} {
		unset tasklist
	}
	if {![info exists tasklist]} {
		Inf "No Tasklist To Save"
		return 0
	}
	set fnam [file join $evv(URES_DIR) tasks$evv(CDP_EXT)]
	set tempfnam $evv(DFLT_OUTNAME)$evv(CDP_EXT)
	if [catch {open $tempfnam "w"} zit] {
		Inf "Cannot Open Temporary File '$tempfnam' To Write New Tasklist"
		return 0
	}
	foreach line $tasklist {
		puts $zit $line
	}
	close $zit
	if [catch {file delete $fnam} zit] {
		Inf "Cannot Delete Pre-Existing Tasklist In Order To Write New Tasklist"
		return 0
	}
	if [catch {file rename $tempfnam $fnam} zit] {
		Inf "Cannot Rename Temporary Tasklist File '$tempfnam' TO '$fnam'\nTo Preserve The Data, Do This Now, Outside The Loom"
	}
	catch {file delete $tempfnam}
	return 1
}

#------ Get creation time of file

proc ModificationDate {ll} {
	global wl dl ch evv month_end

	switch -- $ll {
		"ww" {
			set ilist [$wl curselection]
			if {[info exists ilist] && ([llength $ilist] >= 1) && ([lindex $ilist 0] != -1)} {
				set fnam [$wl get [lindex $ilist 0]]
				if {[llength $ilist] == 2} {
					set fnam2 [$wl get [lindex $ilist 1]]
				} elseif {[llength $ilist] > 2} {
					Inf "Select No More Than 2 Files"
					return
				}
			} else {
				set ilist [$ch curselection]
				if {[info exists ilist] && ([llength $ilist] >= 1) && ([lindex $ilist 0] != -1)} {
					set fnam [$ch get [lindex $ilist 0]]
					if {[llength $ilist] == 2} {
						set fnam2 [$ch get [lindex $ilist 1]]
					} elseif {[llength $ilist] > 2} {
						Inf "Select No More Than 2 Files"
						return
					}
				} elseif {[info exists dl]} {
					set ilist [$dl curselection]
					if {[info exists ilist] && ([llength $ilist] >= 1) && ([lindex $ilist 0] != -1)} {
						set fnam [$dl get [lindex $ilist 0]]
						if {[llength $ilist] == 2} {
							set fnam2 [$dl get [lindex $ilist 1]]
						} elseif {[llength $ilist] > 2} {
							Inf "Select No More Than 2 Files"
							return
						}
					}
				}
			}
		}
		"thumbs" {
			set ilist [.thumbs.2.ll.list curselection]
			if {![info exists ilist] || ([llength $ilist] <= 0) || (([llength $ilist] == 1) && ([lindex $ilist 0] == -1))} {
				Inf "No Thumbnail Selected"
				return
			}
			if {[llength $ilist] > 1} {
				Inf "Select Just One Thumbnail"
				return
			}
			set fnam [file join $evv(THUMDIR) [.thumbs.2.ll.list get [lindex $ilist 0]]]
			append fnam $evv(SNDFILE_EXT)
		}
		"redthumbs" {
			set ilist [.thumpurj.3.ll.list curselection]
			if {![info exists ilist] || ([llength $ilist] <= 0) || (([llength $ilist] == 1) && ([lindex $ilist 0] == -1))} {
				Inf "No Thumbnail Selected"
				return
			}
			if {[llength $ilist] > 1} {
				Inf "Select Just One Thumbnail"
				return
			}
			set fnam [file join $evv(THUMDIR) [.thumpurj.3.ll.list get [lindex $ilist 0]]]
		}
		"bul" {
			set ilist [.bul.1.ll.list curselection]
			if {![info exists ilist] || (([llength $ilist] == 1) && ([lindex $ilist 0] == -1))} {
				Inf "No File Selected"
				return
			}
			if {[llength $ilist] > 1} {
				Inf "Select Just One File"
				return
			}
			set fnam [.bul.1.ll.list get [lindex $ilist 0]]
			set fnam [string trim $fnam]
			if {[string length $fnam] <= 0} {
				Inf "No File Selected"
				return
			}
			if {[string first "FILES " $fnam] >= 0} {
				Inf "No File Selected"
				return
			}
			if {[string first "~~" $fnam] >= 0} {
				Inf "No File Selected"
				return
			}
		}
	}
	if {![info exists fnam]} {
		Inf "No File Selected"
		return
	}
	set compare 0
	if {[info exists fnam2]} {
		set compare 1
	}
	set modtime_secs [file mtime $fnam]
	if {$compare} {
		set modtime_secs_2 [file mtime $fnam2]
		set earlier 1
		if {$modtime_secs_2 < $modtime_secs} {
			set earlier 2
		}
		set diff [expr abs($modtime_secs_2 - $modtime_secs)]

		set day  [expr int(floor($diff / double($evv(SECS_PER_DAY))))]
		set now  [expr $diff - ($day * $evv(SECS_PER_DAY))]
		set hour [expr int(floor($diff / double($evv(SECS_PER_HOUR))))]
		set now  [expr $diff - ($hour * $evv(SECS_PER_HOUR))]
		set min  [expr int(floor($diff / double($evv(SECS_PER_MIN))))]

		set msg "The More Recent File Is\n\n"
		if {$earlier == 2} {
			append msg "'$fnam'"
		} else {
			append msg "'$fnam2'"
		}
		append msg "\n\nTime Between Creation Of These 2 Files Is\n\n"
		if {$day > 0} {
			set months [expr $day / 30]
			if {$months > 12} {
				set years [expr $months/12]
				if {$years > 0} {
					if {$years == 1} {
						append msg " More Than A Year\n\n"
					} else {
						append msg " More Than $years Years\n\n"
					}
				}
			} elseif {$months > 0} {
				if {$months  == 1} {
					append msg "A Month Or More\n\n"
				} else {
					append msg "$months Months Or More\n\n"
				}
			} elseif {$day > 7} {
				set weeks [expr $day / 7]
				if {$weeks > 0} {
					if {$weeks == 1} {
						append msg " A Week Or More\n\n"
					} else {
						append msg " $weeks Weeks Or More\n\n"
					}
				}
			} else {
				append msg " $day Days\n\n"
			}
		} elseif {$hour > 0} {
			append msg " $hour Hours\n\n"
		} elseif {$min > 0} {
			append msg " $min Minutes\n\n"
		} else {
			append msg " Less Than A Minute\n\n"
		}
		if {$earlier == 1} {
			set fnam $fnam2
			set modtime_secs $modtime_secs_2
		}
	}
	set modtime_secs_since_start_2010 [expr $modtime_secs - $evv(SECS_BEFORE_2010)]
	set now $modtime_secs_since_start_2010
	set year 2010
	set is_leap 0
	while {$now >= 0} {
		set then $now
		set was_leap $is_leap
		if {$year % 4 == 0} {
			set now [expr $now - $evv(LEAP_YEAR_SECS)]
			set isleap 1
		} else {
			set now [expr $now - $evv(YEAR_SECS)]
			set isleap 0
		}
		if {$now >= 0} {
			incr year
		} else {
			set now $then
			set is_leap $was_leap
			break
		}
	}
	set monthcnt 1
	while {$monthcnt <= 12} {
		if {$now < $month_end($monthcnt,$is_leap)} {
			set month $monthcnt
			set now [expr $now - $month_end([expr $monthcnt - 1],$is_leap)]
			break
		}
		incr monthcnt
	}
	if {$month < 10} {
		set zz "0"
		append zz $month
		set month $zz
	}
	set day  [expr int(floor($now / double($evv(SECS_PER_DAY))))]
	set now  [expr $now - ($day * $evv(SECS_PER_DAY))]
	set hour [expr int(floor($now / double($evv(SECS_PER_HOUR))))]
	set now  [expr $now - ($hour * $evv(SECS_PER_HOUR))]
	set min  [expr int(floor($now / double($evv(SECS_PER_MIN))))]
	if {$day < 0} {
		set date "Before 2010"
	} else {
		set date $day
		append date "/" $month "/" $year "  " $hour ":" $min "  (Greenwich mean time)"
	}
	if {$compare} {
		append msg "The More Recent File Was Created\n\n"
		append msg $date
	} else {
		set msg $date
	}
	Inf $msg
}

#--- Apply various Loom updates to new user of Release13
#--- (1) Ignore routine program messages
#--- (2) Keep a log of modified files
#--- (3) Use name-extensions for special types of textfile

proc Release13LoomUpdates {} {
	global no_run_msgs evv wstk user_text_extensions new_user_text_extensions dobakuplog bakuplog dovemix
	set rel13fnam [file join $evv(URES_DIR) rel13opts$evv(CDP_EXT)]
	if {[file exists $rel13fnam]} {
		return
	}
	set nomsgfnam [file join $evv(URES_DIR) no_run_msgs$evv(CDP_EXT)]
	set go [file join $evv(URES_DIR) dobakuplog$evv(CDP_EXT)]
	set extfnam [file join $evv(CDPRESOURCE_DIR) user_ext$evv(CDP_EXT)]

	set msg "NEW FACILITIES FOR RELEASE 13.0.1\n"
	append msg "\n"
	append msg "It Is Now Possible To Ignore Routine Program Messages\n"
	append msg "Sent To The \"Run\" Screen.\n"
	append msg "\n"
	append msg "This Means That, After A Process Is Complete,\n"
	append msg "The Loom Will Automatically Return You To The Parameters Screen\n"
	append msg "~~Unless~~ Warnings Or Errors Appear,or The Program Fails.\n"
	append msg "\n"
	append msg "(You Don't Have To Hit The \"OK\" Button)\n"
	append msg "\n"
	append msg "Would You Like To Ignore Routine Program Messages ??\n"
	append msg "\n"
	append msg "(You Can Change This Decision Later, From The \"System\" Menu)"
	set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		Inf "Routine Messages From Programs ~~WILL~~ Be Displayed"
		catch {file delete $nomsgfnam}
	} else {
		set no_run_msgs 1
		if {![file exists $nomsgfnam]} {
			catch {open $nomsgfnam "w"} zit
			catch {close $zit}
		}
		Inf "Routine Messages From Programs Will ~~NOT~~ Be Displayed"
	}

	set msg "A Log Of All Files Created, Altered Or Deleted Can Now Be Kept By The Loom.\n"
	append msg "\n"
	append msg "You Can Use This Log To Decide Which Files Need To Be Backed Up To An External Medium.\n"
	append msg "\n"
	append msg "The Log Is Displayed At The Start And End Of Each Session And Can Be Accessed From A New Button At The Bottom Right Of The Workspace.\n"
	append msg "\n"
	append msg "Once You Have Backed Up Any Displayed Files, You Can Delete The Current Log.\n"
	append msg "\n"
	append msg "If You Do Not Delete The Log, It Continues To Collect Information From One Session To The Next, Until You Do Decide To Backup Files.\n"
	append msg "\n"
	append msg "Note That Files That Only Exist In The CDP Base Directory\n"
	append msg "(i.e. Files Displayed On The Workspace With ~NO~ Directory Path)\n"
	append msg "Are Not Listed, As They Are Assumed To Be Temporary Files.\n"
	append msg "\n"
	append msg "If You Do ~~NOT~~ Want To Use This Feature, You Can Override It Here.\n"
	append msg "\n"
	append msg "(You Can Change This Decision Later, From The \"System\" Menu).\n"
	append msg "\n"
	append msg "Do You Want To Display The Log Of Altered Files ??"
	set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		catch {file delete $go}
		Inf "Log Of File Changes Will ~~NOT~~ Be Kept"
		set dobakuplog 0
		catch {unset bakuplog}
	} else {
		if {![catch {open $go "w"} zit]} {
			close $zit
			Inf "Log Of File Changes ~~WILL~~ Be Kept"
			set dobakuplog 1
		}
	}
	set orch 0
	if {![file exists $extfnam]} {
		set msg "Different Types Of File On Your System Have Different Name-Extensions.\n"
		append msg "e.g. \".wav\" For Sounds, OR \".txt\" For Textfiles.\n"
		append msg "\n"
		append msg "The CDP/LOom Uses Many Types Of Textifles.\n"
		append msg "\n"
		append msg "Mixfile : to mix sounds together.\n"
		append msg "Multichannel Mixfile : can create multichannel output.\n"
		append msg "Breakpoint File: defines how a parameter changes over time.\n"
		append msg "Orchestra: a list of soundfiles.\n"
		append msg "Property File: a list of sounds, with properties defined by you.\n"
		append msg "\n"
		append msg "It Is Possible To Give Each Of These A Different Name-Extension Which Will Help You Recognise Which Is Which On The Workspace.\n"
		append msg "\n"
		append msg "\".mix\" : Mixfile\n"
		append msg "\".mmx\" : Multichannel Mixfile\n"
		append msg "\".brk\" : Breakpointfile\n"
		append msg "\".orc\" or \"orch\": Orchestra\n"
		append msg "\".prp\" : Property File\n"
		append msg "\n"
		append msg "(The Loom Can Still Differentiate Between These Files Even If You Decide ~NOT~ To Use These Name-Extensions)\n"
		append msg "\n"
		append msg "You Are Recommended To Use These Special Filename-Extensions.\n"
		append msg "(You Can Change This Decision Later, From The \"System\" Menu).\n"
		append msg "\n"
		append msg "Do You Want To Use The CDP/Loom Filename-extensions ??"
		append msg "\n"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		catch {unset user_text_extensions}
		catch {unset new_user_text_extensions}
		if {$choice == "no"} {
			Inf "CDP/Loom Filename-Extensions Will ~~NOT~~ Be Used"
		} else {
			set msg	"Do you want to use \"orch\" (rather than \"orc\") for soundlists ??\n\n"
			append msg "(You Can Change This Decision Later, From The \"System\" Menu).\n"
			set which [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$which == "yes"} {
				set orch 1
			}
			if {$orch} {
				set new_user_text_extensions [list ".mix" ".orch" ".prp" ".brk" ".mmx"]
			} else {
				set new_user_text_extensions [list ".mix" ".orc" ".prp" ".brk" ".mmx"]
			}
			SaveTextfileExtensions
			Inf "CDP/Loom Filename-Extensions ~~WILL~~ Be Used"
		}
	}
	catch {open $rel13fnam "w"} zit
	catch {close $zit}
}

proc IgnoreProgMsgs {} {
	global no_run_msgs evv
	set fnam [file join $evv(URES_DIR) no_run_msgs$evv(CDP_EXT)]
	if {[info exists no_run_msgs]} {
		unset no_run_msgs
		catch {file delete $fnam}
		Inf "Routine Messages From Programs Will Be Displayed"
	} else {
		set no_run_msgs 1
		if {![file exists $fnam]} {
			catch {open $fnam "w"} zit
			catch {close $zit}
		Inf "Routine Messages From Programs Will ~~Not~~ Be Displayed"
		}
	}
}

proc LoadIgnoreProgMsgs {} {
	global no_run_msgs evv
	set fnam [file join $evv(URES_DIR) no_run_msgs$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set no_run_msgs 1
	}
}

#--- Find whichever file is highlighted on wkspace page

proc GetFirstOfAnySelectedFileOnWkspacePage {} {
	global wl dl ch
	set fnam ""
	set ilist [$wl curselection]
	if {[info exists ilist] && ([llength $ilist] >= 1) && ([lindex $ilist 0] != -1)} {
		set fnam [$wl get [lindex $ilist 0]]
	} elseif {[info exists dl]} {
		set ilist [$dl curselection]
		if {[info exists ilist] && ([llength $ilist] >= 1) && ([lindex $ilist 0]!= -1)} {
			set fnam [$dl get [lindex $ilist 0]]
		} elseif {[info exists ch]} {
			set ilist [$ch curselection]
			if {[info exists ilist] && ([llength $ilist] >= 1)&& ([lindex $ilist 0]!= -1)} {
				set fnam [$ch get [lindex $ilist 0]]
			}
		}
	}
	return $fnam
}

proc PlayIconifyHelp {} {
	set msg "HIDE MAIN WINDOW DURING PLAY\n"
	append msg "\n"
	append msg "On some MAC systems, the \"Stop Play\" button\n"
	append msg "becomes hidden behind other on-screen windows\n"
	append msg "making it inconvenient to stop a playing sound.\n"
	append msg "\n"
	append msg "This option hides the main Loom window\n"
	append msg "during Play, and restores it afterwards.\n"
	append msg "\n"
	Inf $msg
}

proc PlayIconify {} {
	global playiconify evv
	set fnam [file join $evv(URES_DIR) pliconf$evv(CDP_EXT)]
	if {[info exists playiconify]} {
		unset playiconify
		if {[file exists $fnam]} {
			catch {file delete $fnam}
		}
		Inf "Removed Hide-Window Option"
	} else {
		set playiconify 1
		Inf "Hide-Window Option Set"
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot create file '$fnam' to Remember to Hide Main Window"
				return
			}
			close $zit
		}
	}
}
proc LoadPlayIconify {} {
	global playiconify evv
	set fnam [file join $evv(URES_DIR) pliconf$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set playiconify 1
	}
}

#------ Change filename extension wav <--> aiff

proc WavAiffFlip {} {
	global wstk evv uv
	if {[string match $evv(SNDFILE_EXT) ".wav"]} {
		set nuext ".aiff"
	} else {
		set nuext ".wav"
	}
	set msg "Are You Sure You Want To Change Soundfilename Extension To \"$nuext\" ??"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "yes"} {
		set evv(SNDFILE_EXT) $nuext
		set uv(sndfile_extension) $nuext
		SaveUserEnvironment
	}
}

proc StoreOtherTxtExtensions {} {
	global other_text_extensions evv
	set fnam [file join $evv(URES_DIR) othertxtext$evv(CDP_EXT)]
	if [catch {open $fnam "w"} zit] {
		Inf "CANNOT OPEN FILE [file tail $fnam] TO STORE OTHER KNOWN TEXTFILE EXTENSIONS"
		return
	}
	foreach extt $other_text_extensions {
		puts $zit $extt
	}
	close $zit
}

proc LoadOtherTxtExtensions {} {
	global other_text_extensions evv
	set fnam [file join $evv(URES_DIR) othertxtext$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {open $fnam "r"} zit] {
			Inf "CANNOT OPEN FILE [file tail $fnam] TO READ OTHER KNOWN TEXTFILE EXTENSIONS"
			return
		}
		while {[gets $zit line] >= 0} {
			lappend other_text_extensions $line
		}
		close $zit
	}
}

proc ViewMixFromSnd {} {
	global wl pa evv
	set i [$wl curselection]
	if {[llength $i] != 1} {
		Inf "Select Just One Soundfile"
		return
	} elseif {$i < 0} {
		Inf "Select One Soundfile"
		return
	}
	set fnam [$wl get $i]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Not A Soundfile"
		return
	}
	set mmxfnam [file rootname [file tail $fnam]]
	set ext [GetTextfileExtension mmx]
	append mmxfnam $ext
	foreach zfnam [$wl get 0 end] {
		if {[string match [file tail $zfnam] $mmxfnam]} {
			lappend possibs $zfnam
		}
	}
	set ext [GetTextfileExtension mix]
	set mixfnam [file rootname $mmxfnam]
	append mixfnam $ext
	foreach zfnam [$wl get 0 end] {
		if {[string match [file tail $zfnam] $mixfnam]} {
			lappend possibs $zfnam
		}
	}
	if {![info exists possibs]} {
		Inf "No Corresponding Mixfile On Workspace"
		return
	}
	if {[llength $possibs] > 1} {
		Inf "More Than One Mixfile With This Name On Workspace"
		return
	}
	SimpleDisplayTextfile $possibs
}

#-- Load files with similar names from a different dir

proc LoadSimil {} {
	global wl wksp_dirname wstk pa evv
	set ilist [$wl curselection]
	if {([llength $ilist] < 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
		Inf "No Sounds Selected On Workspace"
		return
	}
	if {![info exists wksp_dirname] || ([string length $wksp_dirname] <= 0) || ![file exists $wksp_dirname] || ![file isdirectory $wksp_dirname]} {
		Inf "No Valid Directory Specified"
		return
	}
	Block "Searching For Files"
	set sametype 1
	set cnt 0
	set checked 0
	foreach i $ilist {
		set w_fnam [$wl get $i]
		lappend w_fnams [file rootname [file tail $w_fnam]]
		set ftyp $pa($w_fnam,$evv(FTYP))
		lappend wftyps $ftyp
		if {$cnt == 0} {
			set firstftyp $ftyp
		} elseif {!$checked} {
			if {$ftyp != $firstftyp} {
				set sametype 0
				set checked 1
			}
		}
	}
	foreach dir_fnam [glob -nocomplain [file join $wksp_dirname *]] {
		set dir_fnam [file tail $dir_fnam]
		set dir_fnamroot [file rootname $dir_fnam]
		lappend dir_fnams $dir_fnam
		lappend dir_fnamroots $dir_fnamroot
	}
	set gotit 0
	foreach dir_fnamroot $dir_fnamroots {
		wm title .blocker "PLEASE WAIT:        FIRST PASS OF SEARCH"
		foreach w_fnam $w_fnams {
			set k [string first $w_fnam $dir_fnamroot]			;#	Is workspace filename contained in a dir filename
			if {$k >= 0} {
				set gotit 1
				if {$k > 0} {
					set prefix [string range $dir_fnamroot 0 [expr $k - 1]]
				} else {
					set prefix ""
				}
				incr k [string length $w_fnam]
				if {$k < [string length $dir_fnamroot]} {
					set suffix [string range $dir_fnamroot $k end]
				} else {
					set suffix ""
				}
				if {[info exists presufs]} {				;#	Have files with these prefix/suffixes been already tested
					foreach {pre suf} $presufs { 
						if {[string match $prefix $pre] && [string match $suffix $suf]} {
							set gotit 0
							break
						}
					}
				}
				if {$gotit} {								;#	Do all other wkspace files corrersponding to dir files
					set nunams {}							;#	with same suffix/prefixes
					foreach yw_fnam $w_fnams {
						set nunam ""
						append nunam $prefix
						append nunam $yw_fnam
						append nunam $suffix
						set k [lsearch $dir_fnamroots $nunam]
						if {$k < 0} {
							set gotit 0
							break
						} 
						set nunam [lindex $dir_fnams $k]
						lappend nunams $nunam
					}
				}
				if {$gotit} {								;#	If wkspace files are of same type, are these ??	
					foreach nunam $nunams {
						lappend ftyps [FindFileType [file join $wksp_dirname $nunam]]
					}
					if {$sametype} {
						if {[llength $w_fnams] > 1} {
							set ftyp [lindex $ftyps 0]
							foreach thisftyp [lrange $ftyps 1 end] {
								if {$thisftyp != $ftyp} {
									set gotit 0
									break
								}
							}
						}
					} else {
						foreach wftyp $wftyps ftyp $ftyps {
							if {$wftyp != $ftyp} {
								set msg "Filetypes Of Similarly Named Files Do Not All Correspond: Is This OK ?"
								set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
								if {$choice == "no"} {
									set gotit 0
									break
								}
							}
						}
					}
				}
				if {$gotit} {								;#	Are these the files we want
					set msg "Found File [lindex $nunams 0]: Is This Correct ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						set gotit 0
					}
				}
				if {$gotit} {
					break
				} else {
					lappend presufs $prefix $suffix
				}
			}
			if {$gotit} {
				break
			}
		}
		if {$gotit} {
			break
		}
	}
	if {!$gotit} {											;#	Is dir filename contained in a workspace filename
		catch {unset presufs}
		wm title .blocker "PLEASE WAIT:        SECOND PASS OF SEARCH"
		foreach dir_fnamroot $dir_fnamroots {
			foreach w_fnam $w_fnams {
				set k [string first $dir_fnamroot $w_fnam]
				if {$k >= 0} {
					set gotit 1
					if {$k > 0} {
						set prefix [string range $w_fnam 0 [expr $k - 1]]
					} else {
						set prefix ""
					}
					incr k [string length $dir_fnamroot]
					if {$k < [string length $w_fnam]} {
						set suffix [string $w_fnam $k end]
					} else {
						set suffix ""
					}
					if {[info exists presufs]} {			;#	Have files with these prefix/suffixes been already tested
						foreach {pre suf} $presufs { 
							if {[string match $prefix $pre] && [string match $suffix $suf]} {
								set gotit 0
								break
							}
						}
					}
					if {$gotit} {
						set nunams {}
						foreach yfnam $dir_fnamroots yyfnam $dir_fnams {
							set nunam ""
							append nunam $prefix
							append nunam $yfnam
							append nunam $suffix
							set k [lsearch $w_fnams $nunam]
							if {$k < 0} {
								set gotit 0
								break
							} 
							lappend nunams $yyfnam
						}
					}
					if {$gotit} {
						foreach nunam $nunams {
							lappend ftyps [FindFileType [file join $wksp_dirname $nunam]]
						}
						if {$sametype} {
							if {[llength $w_fnams] > 1} {
								set ftyp [lindex $ftyps 0]
								foreach thisftyp [lrange $ftyps 1 end] {
									if {$thisftyp != $ftyp} {
										set gotit 0
										break
									}
								}
							}
						} else {
							foreach wftyp $wftyps ftyp $ftyps {
								if {$wftyp != $ftyp} {
									set msg "Filetypes Of Similarly Named Files Do Not All Correspond: Is This OK ?"
									set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
									if {$choice == "no"} {
										set gotit 0
										break
									}
								}
							}
						}
					}
					if {$gotit} {
						set msg "Found File [lindex $nunams 0]: Is This Correct ?"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							set gotit 0
						}
					}
					if {$gotit} {
						break
					} else {
						lappend presufs $prefix $suffix
					}
				}
				if {$gotit} {
					break
				}
			}
			if {$gotit} {
				break
			}
		}
	}
	if {!$gotit} {
		Inf "No Matching Files Found"
		UnBlock
		return
	}
	set nunams [ReverseList $nunams]
	foreach fnam $nunams {
		set fnam [file join $wksp_dirname $fnam]
		if {[FileToWkspace $fnam 0 0 0 1 0] > 0} {
			lappend goodfiles
		} else {
			lappend badfiles $fnam
		}
	}
	if {![info exists goodfiles]} {
		Inf "FAILED TO LOAD ANY FILES TO WORKSPACE"
		UnBlock
		return
	}
	if {[info exists badfiles]} {
		set msg "FAILED TO LOAD THE FOLLOWING FILES\n"
		set cnt 0
		foreach fnam $badfiles { 
			append msg "$fnam\n"
			incr cnt
			if {$cnt >= 20} {
				append msg "AND MORE"
				break
			}
		}
		Inf $msg
	}
	UnBlock
}

#--- Check bad files for CDP system files and directories

proc SubCheck {fnam} {
	global evv
	set filerootname [file rootname [file tail $fnam]]
#NOV 2011 More rigorous name check
	if [IgnoreSoundloomxxxFilenames $filerootname] { 
		return 0
	}
	if {[string match $evv(DFLT_TMPFNAME) $filerootname]} {
		return 0
	}
	if {[string match $evv(DFLT_OUTNAME)* $filerootname]} {
		return 0
	}
	if {[string match $evv(MACH_OUTFNAME)* $filerootname]} {
		return 0
	}
	if {[string match $evv(GUI_NAME)* $filerootname]} {
		return 0
	}
	if {[string match $evv(CDP_TEMPDIR)* $filerootname]} {
		return 0
	}
	if {[string match __* $filerootname]} {
		return 0
	}
	if {[file isdirectory $fnam]} {
		if {[string match _cdpatch $filerootname]} {
			return 0
		}
		if {[string match $evv(PATCH_DIRECTORY)	   $filerootname]} {
			return 0
		}
		if {[string match $evv(SUBPATCH_DIRECTORY) $filerootname]} {
			return 0
		}
		if {[string match $evv(INS_DIR)	  $filerootname]} {
			return 0
		}
		if {[string match $evv(MACRO_DIR) $filerootname]} {
			return 0
		}
		if {[string match $evv(URES_DIR)  $filerootname]} {
			return 0
		}
		if {[string match $evv(LOGDIR)	  $filerootname]} {
			return 0
		}
		if {[string match $evv(CDPRESOURCE_DIR) $filerootname]} {
			return 0
		}
		if {[string match $evv(CDPGUI_DIR) $filerootname]} {
			return 0
		}
		if {[string match [file tail $evv(CDPROGRAM_DIR)] $filerootname]} {
			return 0
		}
	}
	return 1
}

#--- Sort on date of production

proc SortDirDate {reversed} {
	global dl evv
	foreach fnam [$dl get 0 end] {
		set k [list [file mtime $fnam] $fnam]
		lappend datelist $k
	}
	set len [llength $datelist]
	incr len -1
	set i 0
	while {$i < $len} {
		set j $i
		incr j
		set fnami [lindex $datelist $i]
		set dati  [lindex $fnami 0]
		while {$j <= $len} {
			set fnamj [lindex $datelist $j]
			set datj  [lindex $fnamj 0]
			if {$dati > $datj} {
				set datelist [lreplace $datelist $i $i $fnamj] 
				set datelist [lreplace $datelist $j $j $fnami] 
				set fnami $fnamj
				set dati  $datj
			}
			incr j
		}
		incr i
	}
	if {$reversed} {
		set datelist [ReverseList $datelist]
	}
	$dl delete 0 end
	foreach item $datelist {
		lappend filelist [lindex $item 1]
	}
	if [info exists filelist] {
		foreach fnam $filelist {
			$dl insert end $fnam
		}
	}
}

proc DataConvertHelp {} {
	set msg "            DATA CONVERSION\n"
	append msg "\n"
	append msg "(1)  SCIENTIFIC -> NUMERIC \n"
	append msg "\n"
	append msg "Converts files in scientific data format,\n"
	append msg "where small numbers are represented as\n"
	append msg "e.g. 4267e-4\n"
	append msg "to standard numeric format\n"
	append msg "i.e. 0.00004267\n"
	append msg "\n"
	append msg "(2)  AMPLITUDE LIST -> FRQ/AMP FILES\n"
	append msg "\n"
	append msg "Converts File of Data in the form\n"
	append msg "\n"
	append msg "(a) List of times (at which data observed)\n"
	append msg "(b) List of frequencies (frequencies sampled)\n"
	append msg "(c) Several Lists of amplitudes\n"
	append msg "        One amp-list for each time in times-list.\n"
	append msg "        (In each amp-list) one amp for each frq in frq-list.\n"
	append msg "\n"
	append msg "into a set of files, each file representing\n"
	append msg "a single time in the times-list,\n"
	append msg "each file containing\n"
	append msg "paired Frequency - Amplitude data.\n"
	append msg "\n"
	append msg "(3)  TIME SERIES -> BREAKPOINT FILE\n"
	append msg "\n"
	append msg "Converts File of Data in the form\n"
	append msg "\n"
	append msg "List of values\n"
	append msg "\n"
	append msg "into a file of time/value pairs.\n"
	append msg "\n"
	Inf $msg
}

proc ArrowLeftFileToChos {} {
	global wl
	set i [$wl curselection]
	if {([llength $i] <= 0) || (([llength $i] == 1) && ([lindex $i 0] == -1))} {
		GetNextToChosen 0
	} else {
		GetNextToChosen 3
	}
}
#--- Ignores  soundloom.lcl, soundloom.exe and e.g. soundloom_0014.cmd etc in ANY directory

proc IgnoreSoundloomxxxFilenames {fnam} {
	global evv
	if {[string first [string tolower [file rootname $evv(SOUNDLOOM)]] [string tolower [file tail $fnam]]] == 0}  {
		return 1
	}
	return 0
}

proc IndependentMaxsample {fnam} {
	global evv pa CDPmaxId done_maxsamp maxsamp_line
	set done_maxsamp 0
	catch {unset maxsamp_line}
	set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
	if [info exists maxsamp_missing] {
		return 0
	}
	lappend cmd $fnam 1
	if [catch {open "|$cmd"} CDPmaxId] {
		ErrShow "$CDPmaxId"
		return 0
	} else {
#	   	fileevent $CDPmaxId readable "Keep_Maxsamp_Info"
	   	fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
	}
	vwait done_maxsamp
	if {[info exists maxsamp_line]} {
		set pa($fnam,$evv(MAXSAMP)) [lindex $maxsamp_line 0]
		set pa($fnam,$evv(MAXLOC))  [lindex $maxsamp_line 1]
		set pa($fnam,$evv(MAXREP))  [lindex $maxsamp_line 2]
		return 1
	} 
	return 0
}

#------ Display info returned by maxsamp

proc Keep_Maxsamp_Info {} {
	global CDPmaxId done_maxsamp maxsamp_display maxsamp_line

	if [eof $CDPmaxId] {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		}
		if [string match KEEP:* $line] {
			set maxsamp_line $line
		} elseif [string match INFO:* $line] {
			set line [string range $line 6 end] 
		} elseif [string match WARNING:* $line] {
			set line [string range $line 9 end] 
		} elseif [string match ERROR:* $line] {
			set line [string range $line 7 end] 
			return
		} else {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		}
	}
	update idletasks
}

proc ListAcceptableBadnames {badnames} {
	global evv checkspace allow_numeric_filenames
	foreach fnam $badnames {
		set filerootname [file rootname [file tail $fnam]]
		if {[string first [string tolower [file rootname $evv(SOUNDLOOM)]] [string tolower $filerootname]] == 0} { 
			continue
		}
		if {!$allow_numeric_filenames} {
			if {![regexp {^[a-zA-Z_]} $filerootname]} {	;#	Filenames must start with alphabet character or '_'
				lappend outnames $fnam
			}
		} else {
			if {[regexp {^[\-]} $filerootname]} {	;#	Filenames cannot start with '-' (interpreted as a flag!!)
				lappend outnames $fnam
			}
		}
		if {[info exists checkspace]} {
			if {![regexp {^[a-zA-Z0-9_\-\ ]+$} $filerootname] } {
				lappend outnames $fnam
			}
		} else {
			if {![regexp {^[a-zA-Z0-9_\-]+$} $filerootname] } {
				lappend outnames $fnam
			}
		}
		if {[string match $evv(DFLT_TMPFNAME) $filerootname]} {
			continue
		}
		if {[string match $evv(DFLT_OUTNAME)* $filerootname]} {
			continue
		}
		if {[string match $evv(MACH_OUTFNAME)* $filerootname]} {
			continue
		}
		if {[string match $evv(GUI_NAME)* $filerootname]} {
			continue
		}
		if {[string match $evv(CDP_TEMPDIR)* $filerootname]} {
			continue
		}
		if {[string match __* $filerootname]} {
			continue
		}
	}
	if {[info exists outnames]} {
		set msg "The Following Filenames May Contain Invalid Characters\n\n"
		foreach fnam $outnames {
			append msg "$fnam\t"
		}
		append msg "\n\nMust Use Characters a-z,A-Z,underscore,hyphen"
		if {[info exists checkspace]} {
			append msg ",space"
		}
		append msg " and 0-9, Only.\n"
		append msg "Accents In Filenames Cannot Be Read, Nor \".\" Within The Body Of The Filename.\n"
		append msg "Filenames Must Also Not Begin With A Hyphen"
		if {!$allow_numeric_filenames} {
			append msg " Or A Number"
		}
		append msg ".\n"
		Inf $msg
	}
}

proc MarkZeroLevelFiles {force} {
	global evv maxsamp_missing wl pa CDPmaxId done_maxsamp maxsamp_line

	set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
	if [info exists maxsamp_missing] {
		Inf "maxsamp2$evv(EXEC) Is Not On Your System.\nCannot Search Files For Level Information."
		return
	} elseif [ProgMissing $cmd "Cannot search files for maximum sample."] {
		set maxsamp_missing 1
		return
	}
	set ilist [$wl curselection]
	if {([llength $ilist] == 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
		set i 0
		foreach fnam [$wl get 0 end] {
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				lappend fnams $fnam
				lappend ilist $i

			}
			incr i
		}
		if {![info exists fnams]} {
			Inf "No Soundfiles On Workspace"
			return
		}
	} else {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				lappend fnams $fnam
				lappend nuilist $i
			}
		}
		if {![info exists fnams]} {
			Inf "No Soundfiles Selected"
			return
		}
		set ilist $nuilist
		unset nuilist
	}
	if {$force} {
		Block "Getting levels"
		set n 0
		foreach fnam $fnams {
			catch {unset maxsamp_line}
			set done_maxsamp 0
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			lappend cmd $fnam
			lappend cmd 1		;#	1 flag added to FORCE read of maxsample
			if [catch {open "|$cmd"} CDPmaxId] {
				ErrShow "$CDPmaxId"
				continue
	   		} else {
	   			fileevent $CDPmaxId readable "Maxsamp_Info"
			}
	 		vwait done_maxsamp
			if {[info exists maxsamp_line]} {
			set pa($fnam,$evv(MAXSAMP)) [lindex $maxsamp_line 0]
				if {$pa($fnam,$evv(MAXSAMP)) <= 0.0} {
					set fnams [lreplace $fnams $n $n 0]
				}
			}
			incr n
		}
		UnBlock
		foreach fnam $fnams i $ilist {
			if {[string match $fnam "0"]} {
				lappend nuilist $i
			}
		}
	} else {
		foreach fnam $fnams i $ilist {
			if {$pa($fnam,$evv(MAXSAMP)) <= 0.0} {
				lappend nuilist $i
			}
		}
	}
	if {![info exists nuilist]} {
		Inf "No Zero-Level Soundfiles"
		return
	}
	$wl selection clear 0 end
	foreach i $nuilist {
		$wl selection set $i
	}
}

#--- Establish max number of files that can be open at any time

proc EstablishMaxfiles {} {
global tcl_platform evv
	switch -- $tcl_platform(platform) {
		"windows" {	
			set evv(MAXFILES) 998
		}
		"unix"	  {
			set evv(MAXFILES) 248
		}
	}
}

#--------- Functions to allow DATA Functions to come to top of menu, in DO IT AGAIN

proc DataAgain {} {
	global datacmd wl

	if {![info exists datacmd]} {
		Inf "NO PREVIOUS DATA COMMAND USED"
		return
	}
	switch -- $datacmd {
		scinu			{ DataConvertor }
		ampfrqamp		{ CosmicConvertor }
		tstobk			{ TimeSeriesConvertor }
		uber			{ UberData}
		spechear		{ SpectralDataToSoundCompare }
		logisitc		{ LogisticMotifs }
		couette			{ CouetteFlow }
		knotextend		{ KnotExtend }
		knotjoin		{ KnotJoin }
		knotpos			{ KnotPosition }
		knotlayer		{ KnotLayer }
		knotunknot		{ UnKnot }
		knotcount		{ KnotMidiToMix 1 0 }
		knottomidi		{ KnotMidiToMix 0 0 }
		knottomidisnd	{ KnotMidiToMix 0 1 }
		sndindexcreate	{ CreateSndIndex }
		sndindexmodify	{ ModifySndIndex }
		rhpatrand		{ RhythmPatternRand }
		rhpatmorph		{ RhythmMorph }
		rymsub			{ RhythmSoundSubstitute}
		rhpatsnip		{ RhythmSnip}
		rhsndconcat		{ RhythmConcat}
		rymrecol		{ ForwardRecolorRhythmPattern}
		rhymanage		{ Rhystory}
		rhycompare		{ RhyCompare }
		rhsqueeze		{ RhySqueeze }
		tilphi			{ FindTILPfiles 0 }
		rhpatsplit		{ RhythmSplit }
		sindxcount		{ CountSndIndeces }
		sndindexconcat	{ ConcatSndIndex }
		sndindexdir		{ NewDirSndIndex }
		knotmmxtorhy	{ MmixToRhyCell }
		sndindexget		{ GetSndSndIndex }
	}
}

proc SetData {str} {	
	global datacmd ww

	set datacmd $str
	switch -- $datacmd {
		scinu			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Scientific -> Numeric  (\"Control e\")" }
		ampfrqamp		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Amplitude List -> Frq/Amp Pairs   (\"Control x\")" }
		tstobk			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Time Series --> Breakpoint File   (\"Control y\")" }
		uber			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Data To Sound" }
		spechear		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Hear Sounds Generated From Spectra" }
		logisitc		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Logistic Eqn Motifs" }
		couette			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Couette Flow" }
		knotextend		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Repeat/Scale A Rhythm Pattern" }
		knotjoin		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Join (Abutt) Rhythm Patterns" }
		knotpos			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Position Rhythm Pattern In 8-Chan Space" }
		knotlayer		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Overlay Rhythm Patterns" }
		knotunknot		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Unknot Rhythm Patterns" }
		knotcount		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Count Distinct Sound-Index Vals In Pattern" }
		knottomidi		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Convert Positioned Rhythm Pattern To Mixfile" }
		knottomidisnd	{ $ww.1.a.mez.data.menu entryconfig 2 -label "Convert Rhythm To Mixfile And Mix To Sound" }
		sndindexcreate	{ $ww.1.a.mez.data.menu entryconfig 2 -label "Create A Sound Indexing File" }
		sndindexmodify	{ $ww.1.a.mez.data.menu entryconfig 2 -label "Modify A Sound Indexing File" }
		rhpatrand		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Randomise A Rhythm Pattern" }
		rhpatmorph		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Morph Between 2 Rhythm Patterns" }
		rymsub			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Rhythm Pattern Sound-Index Substitution" }
		rhpatsnip		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Snip-Off Last Cell From Rhythm Pattern" }
		rhsndconcat		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Concatenate Rhythm-Pattern Sound-Outputs" }
		rymrecol		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Rhythm Pattern Sound-Index Transfer" }
		rhymanage		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Manage Rhythm Histories" }
		rhycompare		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Compare Two Rhythm Patterns" }
		rhsqueeze		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Snipped-Off Rhythm Cell" }
		tilphi			{ $ww.1.a.mez.data.menu entryconfig 2 -label "Hilight TILP Patterns On Workspace" }
		rhpatsplit		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Split A Rhythm Pattern" }
		sindxcount		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Count Repeats Of Each Sound-Index In Pattern" }
		sndindexconcat	{ $ww.1.a.mez.data.menu entryconfig 2 -label "Concatenate Sound Indexing Files" }
		sndindexdir		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Change Dir Inside Snd-Indexing File" }
		knotmmxtorhy	{ $ww.1.a.mez.data.menu entryconfig 2 -label "Convert Mixfile To Rhythm Pattern" }
		sndindexget		{ $ww.1.a.mez.data.menu entryconfig 2 -label "Get Sndfiles Inside Snd-Indexing File" }
	}
	$ww.1.a.mez.data.menu entryconfig 2 -command DataAgain
}

proc Incrpallcfl {down} {
	global pallcfl_step
	if {$down} {
		if {$pallcfl_step > 0.0} {
			set pallcfl_step [expr $pallcfl_step - 0.1]
			if {$pallcfl_step < 0.0} {
				set pallcfl_step 0.0
			}
		}
	} else {
		set pallcfl_step [expr $pallcfl_step + 0.1]
	}
}

proc AddWkspaceNumbersFrom {} {
	global wl pr_rsnuma genericrnumloa genericrnumstepa chlist ch chcnt genrnum_atenda genrnum_samenamea evv genrnum_len
	global sl_real background_listing dupl_mix dupl_vbx dupl_txt nessinit

	if {!$sl_real} {
		Inf "Selected Files With Similar Names Ending In Numbers\nCan Have Their Numbering Altered"
		return
	}
	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Remove Duplicates From Chosen Files List, Before Proceeding"
		return
	}
	set ilist [$wl curselection]							;#	get indices of selected files
	if {[llength $ilist] <= 0} {							
		Inf "No Item(s) Selected"
		return
	}
	if [info exists nessinit] {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {[IsAValidNessFile $fnam 1 0 0] != 0} {
				Inf "Cannot Do Generic Name Substitions With Physical Modelling Files"
				return
			}
		}
	}
	set ren_blist 0

	set g .genericnruma
	if [Dlg_Create $g "NUMBER FILES FROM CHAR" "set pr_rsnuma 0" -borderwidth $evv(BBDR)] {
		set gn [frame $g.name -borderwidth $evv(SBDR)]
		set gn2 [frame $g.name2 -borderwidth $evv(SBDR)]
		button $gn.b -text Close -width 6 -command "set pr_rsnuma 0" -highlightbackground [option get . background {}]
		label $gn.l1 -text "Number FROM  "
		entry $gn.e1 -width 4 -textvariable genericrnumloa
		label $gn.l2 -text "with STEP  "
		entry $gn.e2 -width 4 -textvariable genericrnumstepa
		button $gn.ok -text OK -width 6 -command "set pr_rsnuma 1" -highlightbackground [option get . background {}]
		pack $gn.ok $gn.l1 $gn.e1 $gn.l2 $gn.e2 -side left
		pack $gn.b -side right
		pack $g.name -side top
		radiobutton $gn2.a -variable genrnum_atenda -text "Number at END of name" -value 1
		radiobutton $gn2.b -variable genrnum_atenda -text "Number at START of name" -value 0
		pack $gn2.a $gn2.b -side left -padx 4
		set gc [frame $g.count -borderwidth $evv(SBDR)]
		label $gc.ll -text "Number replaces characters from character-number N"
		entry $gc.e -textvariable genrnum_len -width 10
		pack $gc.ll $gc.e -side left -padx 2
		pack $gn $gn2 $gc -side top -pady 2 -fill x -expand true
		wm resizable $g 0 0
		bind $g <Return> {set pr_rsnuma 1}
		bind $g <Escape> {set pr_rsnuma 0}
	}
	set genericrnumloa 0
	set genericrnumstepa 1
	set genrnum_atenda 1
	set genrnum_samenamea 1
	set finished 0
	set pr_rsnuma 0
	set save_mixmanage 0
	raise $g
	My_Grab 0 $g pr_rsnuma $g.name.e1
	while {!$finished} {
		tkwait variable pr_rsnuma
		if {!$pr_rsnuma} {				  						
			My_Release_to_Dialog $g
			Dlg_Dismiss $g
			return
		} else {				  							;#	If a generic name has been entered
			if {[string length $genericrnumloa] <= 0} {
				Inf "No start number has been entered"
				continue
			}
			if {![regexp {^[0-9]+$} $genericrnumloa]} {
				Inf "Invalid start number entered"
				continue
			}
			if {[string length $genericrnumstepa] <= 0} {
				Inf "No step value entered"
				continue
			}
			if {![regexp {^[0-9]+$} $genericrnumstepa]} {
				Inf "Invalid step value entered"
				continue
			}
			if {$genericrnumstepa < 1} {
				Inf "Invalid step value entered (must be greater than zero)"
				continue
			}
			if {[string length $genrnum_len] <= 0} {
				Inf "No entry for index N for characters to replace"
				continue
			}
			if {![regexp {^[0-9]+$} $genrnum_len] || ($genrnum_len < 1)} {
				Inf "Invalid index N for characters to replace : must be 1 or more"
				continue
			}

			set genrnum_end $genrnum_len
			incr genrnum_end -1
			set cnt 0
			set minnamelen 10000
			set OK 1
			foreach i $ilist {										;# check for valid (set of) files
				lappend innames [$wl get $i]
				set fnam [file rootname [$wl get $i]]
				if {$cnt == 0} {
					set baseext [file extension [$wl get $i]]
				}
				if {![string match [file extension [$wl get $i]] $baseext]} {
					Inf "Files '$fnam' is not of the same type as the first file"
					My_Release_to_Dialog $g
					Dlg_Dismiss $g
					return
				}
				if {[string length [file tail $fnam]] < $genrnum_len} {
					Inf "Not All Filenames Are Long Enough To Do This Substitution"
					set OK 0
					break
				}
				lappend nunames [string range [file tail $fnam] 0 $genrnum_end] 
				incr cnt
			}
			if {!$OK} {
				continue
			}
			set j $genericrnumloa
			set n 0
			foreach i $ilist {
				set fnam [$wl get $i]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				if {$genrnum_atenda} {
					set nuname [lindex $nunames $n]
					set nuname [file join $fdir $nuname]
					append nuname "_"
					append nuname $j $baseext
				} else {
					set nuname [file join $fdir $j]
					append nuname "_" [lindex $nunames $n] $baseext
				}
				if {[file exists $nuname] && ([lsearch -exact $innames $nuname] < 0)} {
					Inf "a file with the name '$nuname' already exists"
					My_Release_to_Dialog $g
					Dlg_Dismiss $g
					return
				}
				incr j $genericrnumstepa
				incr n
			}
			set j $genericrnumloa
			set n 0
			foreach i $ilist {
				set fnam [$wl get $i]
				set fdir [file dirname $fnam]
				if {[string length $fdir] <= 1} {
					set fdir ""
				}
				if {$genrnum_atenda} {
					set nuname [file join $fdir [lindex $nunames $n]]
					append nuname "_" $j $baseext
				} else {
					set basefnam [lindex $nunames $n]
					set nuname [file join $fdir $j]
					append nuname "_" $basefnam $baseext
				}
				incr j $genericrnumstepa
				set origfnam [$wl get $i]
				set haspmark [HasPmark $origfnam]
				set hasmmark [HasMmark $origfnam]
				if [catch {file rename $origfnam $nuname} zub] {
					Inf "Cannot rename file\n$origfnam\nTO\n$nuname"
					continue
				}
				DataManage rename $origfnam $nuname
				lappend couettelist $origfnam $nuname
				UpdateBakupLog $origfnam delete 0
				UpdateBakupLog $nuname create 1
				CheckMainmix $origfnam $nuname
				CheckMainmixSnd $origfnam $nuname
				$wl delete $i								
				$wl insert $i $nuname
				catch {unset rememd}
				UpdateChosenFileMemory $origfnam $nuname
				set oldname_pos_on_chosen [LstIndx $origfnam $ch]
				if {$oldname_pos_on_chosen >= 0} {
					RemoveFromChosenlist $origfnam
					set chlist [linsert $chlist $oldname_pos_on_chosen $nuname]
					incr chcnt
					$ch insert $oldname_pos_on_chosen $nuname
				}
				RenameProps	$origfnam $nuname 1				
				DummyHistory $origfnam "RENAMED_$nuname"
				if {[MixMRename $origfnam $nuname 0]} {
					set save_mixmanage 1
				}
				if {$haspmark} {
					MovePmark $origfnam $nuname
				}
				if {$hasmmark} {
					MoveMmark $origfnam $nuname
				}
				if [IsInBlists $origfnam] {
					if [RenameInBlists $origfnam $nuname] {
						set ren_blist 1
					}
				}
				RenameOnDirlist $origfnam $nuname
				incr n
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			break
		}
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}		
	My_Release_to_Dialog $g
	Dlg_Dismiss $g
	foreach i $ilist {
		$wl selection set $i
	}
}

proc SetPlayStep {} {
	global doplaystep evv
	set fnam [file join $evv(URES_DIR) doplaystep$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set doplaystep 1
	}
	return
}

proc SavePlayStep {} {
	global doplaystep evv pr_doplaystep set_doplaystep
	set fnam [file join $evv(URES_DIR) doplaystep$evv(CDP_EXT)]
	set f .doplstp
	if [Dlg_Create $f "SET MULTIPLE PLAYBACK" "set pr_doplaystep 0" -borderwidth 2 -width 120] {
		frame $f.0
		button $f.0.qq -text "Quit" -command "set pr_doplaystep 0" -highlightbackground [option get . background {}]
		pack $f.0.qq -side right
		pack $f.0 -side top -fill x -expand true
		label $f.00 -text "\"Control-p\" Playback of selected sounds on workspace"
		label $f.01 -text "where More Than One sound is selected, can be set as Either" -fg $evv(SPECIAL)
		label $f.02 -text "(1) Play All Snds Selected (end-to-end) OR" -fg $evv(SPECIAL)
		label $f.03 -text "(2) Play All Snds Selected At Fixed Timestep" -fg $evv(SPECIAL)
		pack $f.00 $f.01 $f.02 $f.03 -side top -pady 2
		frame $f.1
		checkbutton	$f.1.ch -variable set_doplaystep -text "at a Fixed Timestep." -command "set pr_doplaystep 1"
		pack $f.1.ch -side left -padx 2
		pack $f.1 -side top -fill x -expand true
		wm resizable $f 0 0
		bind $f <Escape> {set pr_doplaystep 0}
	}
	if [info exists doplaystep] {
		set set_doplaystep 1
	} else {
		set set_doplaystep 0
	}
	set finished 0
	set pr_doplaystep 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_doplaystep
	while {!$finished} {
		tkwait variable pr_doplaystep
		if {$pr_doplaystep} {
			if {$set_doplaystep} {
				set doplaystep 1
			} else {
				catch {unset doplaystep}
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f

	if [info exists doplaystep] {
		if {[file exists $fnam] && [catch {file delete $fnam} zit]} {
			Inf "Cannot Delete File [file tail $fnam] To Remember Setting Of Play Key"
		}
	} else {
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Open File [file tail $fnam] To Remember Setting Of Play Key"
			}
			close $zit
		}
	}
}

proc GetDataReleased {} {
	global released
	if {![info exists released(cubicspline)]} {
		return 0
	}	
	if {![info exists released(newmix)]} {
		return 0
	}	
	if {![info exists released(notchinvert)]} {
		return 0
	}	
	if {![info exists released(peakiso)]} {
		return 0
	}	
	if {![info exists released(smooth)]} {
		return 0
	}	
	if {![info exists released(specanal)]} {
		return 0
	}	
	if {![info exists released(specav)]} {
		return 0
	}	
	if {![info exists released(spectrum)]} {
		return 0
	}	
	if {![info exists released(ts)]} {
		return 0
	}	
	if {![info exists released(tsconvert)]} {
		return 0
	}
	return 1
}

proc GetCouetteReleased {} {
	global released
	if {![info exists released(strands)]} {
		return 0
	}	
	if {![info exists released(newmix)]} {
		return 0
	}	
	if {![info exists released(mchanpan)]} {
		return 0
	}	
	if {![info exists released(refocus)]} {
		return 0
	}	
	if {![info exists released(pulser)]} {
		return 0
	}
	return 1
}

proc WholeHelp {} {
	set msg "WHOLE-SOUND TUNING OPERATIONS\n"
	append msg "\n"
	append msg "These processes transpose the entire soundfile\n"
	append msg "by some fixed amount.\n"
	append msg "\n"
	append msg "When tuning a sound to a given tuning-set\n"
	append msg "only the most prominent pitch in the source\n"
	append msg "will end up tuned to some pitch in the tuning set.\n"
	append msg "\n"
	Inf $msg
}

proc PDHelp {} {
	set msg "PITCH DATA OPERATIONS\n"
	append msg "\n"
	append msg "These processes work with\n"
	append msg "\n"
	append msg "(1) The internal pitch-countour of sounds\n"
	append msg "        and data derived from this.\n"
	append msg "\n"
	append msg "(2) Pitchmarks (pitch or Harmonic Field data)\n"
	append msg "        which have been assigned to soundfiles.\n"
	append msg "\n"
	append msg "\n"
	append msg "(2) Motif markers (pitch contour data)\n"
	append msg "        which have been assigned to soundfiles.\n"
	append msg "\n"
	Inf $msg
}

#--- List contents of subdirectory selected on Source Directory Listing

proc GetThisLevelSubdirNames {} {
	global dl wksp_dirname active_dir previous_dirlisting previous_active_dir ww evv

	if {[info exists active_dir] && [info exists previous_active_dir]} {
		set xx $previous_active_dir
		set yy $previous_dirlisting
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	set subdirlist {}
	set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
	if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
		if {[info exists xx]} {
			set previous_active_dir $xx
			set previous_dirlisting $yy
		}
	 	return
	}
	set dirlen [string length $dirname]
	set pwd [string tolower [pwd]]
	set pwdlen [string length $pwd]
	if [string match $pwd* $dirname] {
		if {$pwdlen == $dirlen} {
			set dirname ""
		} else {
			incr pwdlen
			set dirname [string range $dirname $pwdlen end]
		}
	}
	set len [string length $dirname]
	if {$len == 0} { 
		return
	}
	set k $len
	while {$k > 0} {
		incr k -1
		if {$k == 0} {
			return
		}
		if {[string match [string index $dirname $k] \/]} {
			incr k -1
			if {$k == 0} {
				return
			}
			set dirname [string range $dirname 0 $k]
			break
		}
	}
	set active_dir $dirname
	Block "Listing SubDirectories"
	foreach fnam [lsort -dictionary [glob -nocomplain [file join $dirname *]]] {
		if [file isdirectory $fnam] {
			if {[string match $fnam soundloom$evv(EXEC)]} {
				continue
			}
			set fnam [CheckDirectoryName $fnam "directory name" 0 1]
			if {[string length $fnam] <= 0} {
				continue
			} else {
				set fnam [string tolower $fnam]
				lappend subdirlist $fnam
			}
		}
	}
	UnBlock
	set len [llength $subdirlist]
	switch -- $len {
		0 {
			Inf "There Are No Subdirectories In This Directory"
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
				return
			}
		}
		1 {
			Inf "There Are No Other Subdirectories At This Level"
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
				return
			}
		}
		default {
			$dl delete 0 end
			foreach item $subdirlist {
				$dl insert end $item
			}
		}
	}
	$dl xview moveto 0.0
	$ww.1.b.labels.msg2 config -text "Default Sndfile extension '$evv(SNDFILE_EXT)'"
}

proc LoadDirectToView {} {
	global evv directtoview
	set fnam [file join $evv(URES_DIR) directoview$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set directtoview 1
	} else {
		catch {unset directtoview}
	}
}

proc SaveDirectToViewStatus {on} {
	global evv directtoview ww
	set fnam [file join $evv(URES_DIR) directoview$evv(CDP_EXT)]
	if {$on} {
		set directtoview 1
		$ww.h.syscon.menu.sub1 entryconfig 36 -label "\"Play\" (~~NOT~~ \"Snd View\") With Dbl-Clk On Wksp" -command "SaveDirectToViewStatus 0"
		if [catch {open $fnam "w"} zit] {
			Inf "Failed To Create File $fnam"
			return
		}
		close $zit
	} else {
		catch {unset directtoview}
		$ww.h.syscon.menu.sub1 entryconfig 36 -label "\"Sound View\" With Double-Click On Workspace" -command "SaveDirectToViewStatus 1"
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				Inf "Failed To Delete File $fnam"
			}
		}
	}
}

proc SetParamLastVals {} {
	global param_last_preset evv
	set fnam [file join $evv(URES_DIR) paramlastvset$evv(CDP_EXT)]
	if {[info exists param_last_preset]} {
		set param_last_preset [expr !$param_last_preset]
	} else {
		set param_last_preset 1
	}
	set msg ""
	if {$param_last_preset} {
		append msg "Previous-Run Values Will Be Set As Initial Defaults When Param-Page Called."
		append msg "\n\n(No Efect On Mix Process - Reset This Elsewhere On System State Menu)."
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				append msg "\n\nCannot Create File '$fnam' To Remember This Change Of Param-Page-Defaults."
			}
			close $zit
		}
	} else {
		append msg "Standard Default Values Will Be Set As Initial Defaults When Param-Page Called."
		append msg "\n\n(1) Change Only Takes Effect After You Run A ~~Different Process~ To The One You Just Ran."
		append msg "\n(2) No Efect On Mix Process - Reset This Elsewhere On System State Menu."
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				append msg "\n\nCannot Delete File '$fnam' To Remember This Change Of Param-Page-Defaults."
			}
		}
	}
	Inf $msg
}

proc GetParamLastVals {} {
	global param_last_preset evv
	set fnam [file join $evv(URES_DIR) paramlastvset$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		set param_last_preset 1
	} else {
		set param_last_preset 0
	}
}

#---- Button to backup (or Move) files to a directory

proc GetFilesToDir {andremove} {
	global wl wksp_dirname
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] == 0) || (([llength $ilist] == 1) && ([lindex $ilist 0] < 0))} {
		Inf "No Files Selected"
		return
	}
	set dirname [CheckDirectoryName $wksp_dirname "directory name" 1 0]
	if {([string length $dirname] <= 0) && ([string length $wksp_dirname] > 0)} {
		Inf "No valid directory specified"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		set shrtname [file tail $fnam]				;#	by removing any directory path, and comparing orig
		if [string match $shrtname $fnam] {			;#	Look for filenames with NO directory part 
			lappend unbakdupfiles $i				
		} else {
			lappend bakdupfiles $i				
		}
	}
	if {[info exists unbakdupfiles] && ([llength $ilist] == [llength $unbakdupfiles])} {
		BakupWkspace $andremove
	} elseif {[info exists bakdupfiles] && ([llength $ilist] == [llength $bakdupfiles])} { 
		MoveDirectory $andremove
	} else {
		Inf "Mix of backed-up and non-backed-up files selected: can't proceed"
	}
}

proc PossiblySaveWkspaceSelection {} {
	global wlilist wl
	set wlilist [$wl curselection]
	if {[info exists wlilist] && (([llength $wlilist] <= 0) || ([lindex $wlilist 0] == -1))} {
		unset wlilist
	}
}

#---- Highlight only the currently higlighted files which are NOT on Chosen Files list

proc InvertSelectChosen {} {
	global wl chlist
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		Inf "No Sounds On Chosen List"
		return
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
		Inf "No Workspace Files Highlighted"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {[lsearch $chlist $fnam] >= 0} {
			lappend exilist $i
		}
	}
	if {![info exists exilist]} {
		return
	}
	foreach i $exilist {
		$wl selection clear $i
	}
}

proc TargetTextfile {} {
	global wl pa evv target wstk
	if {[info exists target(file)] && [file exists $target(file)]} {
		set msg "Target File $target(file) Exists : Set Up A New Target File ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	set i [$wl curselection]
	if {![info exists i] || ([llength $i] > 1) || ($i == -1)} {
		Inf "Select Target Textfile"
		return
	}	
	set fnam [$wl get $i]
	if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
		Inf "Select An Existing Textfile"
		return
	}	
	set target(file) $fnam
	set fnam [file join $evv(URES_DIR) target$evv(CDP_EXT)]
	if {![catch {open $fnam "w"} zit]} {
		puts $zit $target(file)
		close $zit
	}
}

proc GrabToTarget {withpath} {
	global wl target pr_target evv my_clipboard

	if {![info exists target(file)]} {
		Inf "Target Textfile Not Yet Specified"
		return
	}
	if {![file exists $target(file)]} {
		Inf "Target Textfile $target(file) No Longer Exists"
		catch [unset target(file)]
		return
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
		if {$withpath < 3} {
			Inf "Select Files To Add To [file rootname [file tail $target(file)]]"
			return
		} else {
			Inf "Select Files To Search For In [file rootname [file tail $target(file)]]"
			return
		}
	}
	if {($withpath > 2) && ([llength $ilist] > 1)} {
		Inf "To Search Targetfile, Select Only One File From Workspace"
		return
	}
	switch -- $withpath {
		0 -
		1 -
		2 {
			set target(null) 0
		}
		3 -
		4 {
			set target(null) 1
		}
	}
	set my_clipboard "\n"
	foreach i $ilist {
		set namegot [$wl get $i]										;#	DEFAULT (withpath 3) COMPLETE NAME
		switch -- $withpath {
			0 {
				set namegot [file rootname [file tail $namegot]]		;#	BASIC NAME
			}
			1 {
				set namegot [file tail $namegot]						;#	BASIC NAME + EXTENSION
			}
			3 {
				set target(srch) [file rootname [file tail $namegot]]	;#	SEARCH STRING = BASIC NAME
			}
			4 {
				set target(srch) [file dirname $namegot]				;#	SEARCH STRING = DIRECTORY
			}
		}
		append my_clipboard "$namegot\n"
	}
	set f .target
	if [Dlg_Create $f "ADD FILES TO TEXTFILE" "set pr_target 0" -borderwidth $evv(SBDR)] {
		set b [frame $f.b -borderwidth $evv(SBDR)]
		set k [frame $f.k -borderwidth $evv(SBDR)]
		button $b.s -text "Save" -command "set pr_target 1" -highlightbackground [option get . background {}]
		button $b.z -text "Search For" -command "set pr_target 2" -highlightbackground [option get . background {}]
		entry $b.e -textvariable target(srch) -width 40
		button $b.a -text "Again" -command "set pr_target 3" -highlightbackground [option get . background {}]
		menubutton $b.pich -text "A" -menu .target.b.pich.menu -relief raised -bd 4 -width 2 -background $evv(HELP)
		set tpchmenu [menu .target.b.pich.menu -tearoff 0]
		$tpchmenu add command -label "C" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilec$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "C#" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfiledb$evv(SNDFILE_EXT)] 0; set pr_target 4" -background black -foreground white
		$tpchmenu add separator
		$tpchmenu add command -label "D"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfiled$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "Eb" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileeb$evv(SNDFILE_EXT)] 0; set pr_target 4" -background black -foreground white
		$tpchmenu add separator
		$tpchmenu add command -label "E"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilee$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "F"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilef$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "F#" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilegb$evv(SNDFILE_EXT)] 0; set pr_target 4" -background black -foreground white
		$tpchmenu add separator
		$tpchmenu add command -label "G"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileg$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "Ab" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileab$evv(SNDFILE_EXT)] 0; set pr_target 4" -background black -foreground white
		$tpchmenu add separator
# RWD 2023 was just "testfile"
		$tpchmenu add command -label "A"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilea$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "Bb" -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilebb$evv(SNDFILE_EXT)] 0; set pr_target 4" -background black -foreground white
		$tpchmenu add separator
		$tpchmenu add command -label "B"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfileb$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		$tpchmenu add separator
		$tpchmenu add command -label "C"  -command "PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfilec2$evv(SNDFILE_EXT)] 0; set pr_target 4" -background white -foreground black
		bind .target.b.pich <Shift-ButtonPress-1> {}
		bind .target.b.pich <Shift-ButtonRelease-1> {PlaySndfile [file join $evv(CDPRESOURCE_DIR) testfile$evv(SNDFILE_EXT)] 0; set pr_target 4}
		button $b.r -text "Restore Data" -command "set pr_target 5" -highlightbackground [option get . background {}]
		button $b.q -text "Abandon" -command "set pr_target 0" -highlightbackground [option get . background {}]
		pack $b.s $b.z $b.e $b.a $b.pich -side left -padx 2
		pack $b.r -side left -padx 20
		pack $b.q -side right
		pack $b -side top -fill x -expand true
		label $f.m -text "CLICK ON PAGE AT ANY POSITION, TO PASTE INPUT FILENAMES." -fg $evv(SPECIAL)
		pack $f.m -side top -pady 2
		set t [text $k.t -setgrid true -wrap word -width 160 -height 64 \
		-xscrollcommand "$k.sx set" -yscrollcommand "$k.sy set"]
		scrollbar $k.sy -orient vert  -command "$f.k.t yview"
		scrollbar $k.sx -orient horiz -command "$f.k.t xview"
		pack $k.t -side left -fill both -expand true
		pack $k.sy -side right -fill y
		pack $k -side top -fill both -expand true
		bind .target.k.t <Control-s> {set pr_target 1}
		bind .target.k.t <Control-S> {set pr_target 1}
		bind .target.k.t <Control-p> {UniversalPlay text .target.k.t}
		bind .target.k.t <Control-P> {UniversalPlay text .target.k.t}
		bind $f <Escape> {set pr_target 0}
	}
	if [catch {open $target(file) r} fileId] {
		Inf "Cannot open file $target(file)."	;#	Open the textfile
		Dlg_Dismiss $f
		return
	}
	set qq 0
	while {[gets $fileId line] >= 0} {					;#	Put contents of file into window, avoiding extra newline
		if {$qq > 0} {
			.target.k.t insert end "\n"
		}
		.target.k.t insert end "$line"
		incr qq
	}
	close $fileId
	set target(list) [split [.target.k.t get 1.0 end] "\n"]
	if {$target(null)} {
		wm title .target "SEARCH TARGETFILE [file rootname [file tail $target(file)]]"
		.target.m config -text "USE \"Search For\" BUTTON TO SEARCH FOR ITEM"
		bind .target.k.t <ButtonRelease-1> {}
	} else {
		wm title .target "ADD FILES TO [file rootname [file tail $target(file)]]"
		.target.m config -text "CLICK ON PAGE AT ANY POSITION, TO PASTE INPUT FILENAMES."
		bind .target.k.t <ButtonRelease-1> {Deposit}
	}

	set pr_target 0
	set finished 0
	raise $f
	My_Grab 1 $f pr_target .target.k.t
	while {!$finished} {
		tkwait variable pr_target
		switch -- $pr_target {
			1 {
				if [catch {open $target(file) w} fileId] {
					Inf "Cannot Reopen Target File To Write New Contents"
					continue
				}
				puts -nonewline $fileId "[.target.k.t get 1.0 end]"
				close $fileId						;#	Write data to file
				set finished 1
			}
			2 {
				if {[string length $target(srch)] < 0} {
					Inf "No Search String Entered"
					continue
				}
				if {![regexp {^[a-zA-Z0-9_:\-\/]+$} $target(srch)]} {
					Inf "Invalid Search String Entered"
					continue
				}
				set target(srchlen) [string length $target(srch)]
				catch {unset target(found)}
				set target(list) [split [.target.k.t get 1.0 end] "\n"]
				if {![info exists target(list)] || ([llength $target(list)] <= 0)} {
					Inf "No Text To Search"
					continue
				}
				set indx 1
				catch {unset target(found)}
				foreach line $target(list) {
					set k [string first $target(srch) $line]
					if {$k >= 0} {
						set thisindx $indx
						append thisindx "." $k
						lappend target(found) $thisindx
					}
					incr indx
				}
				if {![info exists target(found)]} {
					Inf "Not Found"
					continue
				}
				focus .target.k.t
				set target(foundcnt) [llength $target(found)]
				set target(foundno) 0
				set start [lindex $target(found) $target(foundno)]
				.target.k.t tag add sel $start "$start + $target(srchlen) chars"
				if {$start > 60} {
					.target.k.t yview moveto $start
				} else {
					.target.k.t yview moveto 1.0
				}
				incr target(foundno)
			}
			3 {
				if {![info exists target(found)]} {
					Inf "Search String Not Previously Found"
					continue
				}
				if {$target(foundno) >= $target(foundcnt)} {
					Inf "That's All"	
					set target(foundno) 0
					continue
				}
				focus .target.k.t
				set start [lindex $target(found) $target(foundno)]
				.target.k.t tag add sel $start "$start + $target(srchlen) chars"
				if {$start > 60} {
					.target.k.t yview moveto $start
				} else {
					.target.k.t yview moveto 1.0
				}
				incr target(foundno)
			}
			4 {
				continue
			}
			5 {
				if {![info exists target(list)] || ([llength $target(list)] <= 0)} {
					Inf "No Listing To Restore"
					continue
				}
				.target.k.t delete 1.0 end
				foreach line $target(list) {
					.target.k.t insert end "$line\n"
				}
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc Deposit {} {
	global my_clipboard
	.target.k.t insert insert $my_clipboard
	set my_clipboard {}
	bind .target.k.t <ButtonRelease-1> {}
	.target.m config -text ""
}

proc LoadTargetTextfile {} {
	global evv target
	set fnam [file join $evv(URES_DIR) target$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File $fnam To Get Name Of Your Target File"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		break
	}
	close $zit
	if {![info exists line]} {
		Inf "no Information In File $fnam"
		catch {file delete $fnam}
		return
	}
	if {![file exists $line]} {
		Inf "Specified Targetfile $line No Longer Exists"
		catch {file delete $fnam}
		return
	}
	set target(file) $line
}

proc TellConvFromMchan {} {
	set msg "~~~  MULTICHANNEL SOUND TO STEREO  ~~~\n"
	append msg "\n"
	append msg "Takes a multichannel soundfile and mixes the N channels\n"
	append msg "to create a stereo reduction.\n"
	append msg "The original sources are layed out either left-to-right\n"
	append msg "or arrayed in a flattened \"circle\" slightly offset\n"
	append msg "so that the original front centre and rear centre\n"
	append msg "sounds do not overlay one-another\n"
	append msg "and the (originally) rear-positioned sounds\n"
	append msg "are at a lower level in the mix.\n"
	append msg "\n"
	append msg "\n"
	append msg "~~~  MULTICHANNEL SELECTED STEREO  ~~~\n"
	append msg "\n"
	append msg "Takes two specified channels form a multichannel mix\n"
	append msg "to create a stereo output.\n"
	append msg "\n"
	append msg "\n"
	append msg "~~~  MULTICHANEL-MIX TO STANDARD MIXFILE  ~~~\n"
	append msg "\n"
	append msg "Input is a multichannel mixfile, in which\n"
	append msg "\n"
	append msg "(1)  All the source sounds are stereo.\n"
	append msg "(2)  All outputs are routed to channel 1 or 2, or both.\n"
	append msg "\n"
	append msg "The multichannel file will be converted to\n"
	append msg "a STANDARD FORMAT stereo mixfile.\n"
	append msg "\n"
	append msg "This process can be used in the preparation of stereo reductions\n"
	append msg "of multichannel sources, where straightforward mapping of the\n"
	append msg "original multichannel-mix-output-sound to stereo is not possible\n"
	append msg "(e.g. where phasing delays between channels will result in\n"
	append msg "phase cancellation when channels of the N-channel sound are\n"
	append msg "mixed into a stereo format).\n"
	append msg "\n"
	append msg "(A copy of) the original multichannel mix can be edited\n"
	append msg "(e.g. \"QikEdit\" using \"CHANGE FILE TO\" options),\n"
	append msg "replacing multichannel sources with appropriate stereo reductions.\n"
	append msg "\n"
	append msg "Once all input files are (mono or) stereo,\n"
	append msg "these can, if necessary, be re-routed,\n"
	append msg "so that sounds are routed only to Channels 1, or 2 or both.\n"
	append msg "(e.g. \"QikEdit\" option \"REROUTE\")\n"
	append msg "\n"
	append msg "The final, edited multichannel mix can then be\n"
	append msg "converted to a standard format stereo mixfile.\n"
	append msg "\n"
	Inf $msg
}

proc PhysicalModelling {} {
	set msg "SYNTHESIS BY PHYSICAL MODELLING\n"
	append msg "\n"
	append msg "Synthesis from \"physical models\" of instruments\n"
	append msg "built on the computer by the NESS project group\n"
	append msg "at the University of Edinburgh.\n"
	append msg "\n"
	append msg "You can PLAY a physical model from the 'Score' page\n"
	append msg "once the score syntax is correct.\n"
	append msg "and this will produce a soundfile output on the workspace\n"
	append msg "with the same name as the scorefile.\n"
	append msg "\n"
	append msg "NB: \"Instrument\" files must have distinct names.\n"
	append msg "Do not use an identical instrument name in a different directory.\n"
	append msg "The same applies to \"Score\" files.\n"
	append msg "\n"
	append msg "\n"
	append msg "Create these files on the workspace, then save the session.\n"
	append msg "The files may SUBSEQUENTLY be moved to another directory.\n"
	append msg "They will then be invisible to the Physical Modelling process\n"
	append msg "until COPIED (NOT \"Grabbed\") back onto the workspace.\n"
	append msg "\n"
	append msg "This work was supported in part by the NESS project,\n"
	append msg "funded by the EUROPEAN RESESARCH COUNCIL\n"
	append msg "under grant number ERC-StG-2011-279068-NESS\n"
	append msg "\n"
	append msg "\n"
	Inf $msg
}

proc NewWindowShortenMsg {} {
	global evv
	set fnam [file join $evv(URES_DIR) shwmsg$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		set msg "SHORTENING / LENGTHENING WINDOWS\n"
		append msg "\n"
		append msg "If any of the Loom windows are \n"
		append msg "TOO LONG for your screen.....\n"
		append msg "\n"
		append msg "(1) Go to \"System State\" menu,\n"
		append msg "         (top right of workspace page).\n"
		append msg "(2) Select \"System Settings 2\".\n"
		append msg "(3) Select \"Shorten Windows\"\n"
		append msg "         (near to bottom of menu)\n"
		append msg "\n"
		append msg "You can RESTORE LONGER WINDOWS .....\n"
		append msg "\n"
		append msg "(1) Go to \"System State\" menu,\n"
		append msg "(2) Select \"System Settings 2\".\n"
		append msg "(3) Select \"Lengthen Windows\"\n"
		append msg "         (near to bottom of menu)\n"
		append msg "\n"
		Inf $msg
		catch {open $fnam "w"}
		catch {close $zit}
	}
}

#---- Larger mixedit windows

proc SetExtendableMixEditPage {on} {
	global bigmix evv ww big_mixwindows_index ww
	set fnam [file join $evv(URES_DIR) "bigmix"]
	append fnam $evv(CDP_EXT)
	if {$on} {
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot create file $fnam to remember state of mix edit window"
			} else {
				close $zit
			}
		}
		set bigmix 1
		catch {destroy .mixdisplay}
		$ww.h.syscon.menu.sub1a entryconfig $big_mixwindows_index -label "NORMAL MIX EDIT PAGE" -command "SetExtendableMixEditPage 0"
	} else {
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot destroy file $fnam to remember state of mix edit window"
			}
		}
		catch {unset bigmix}
		catch {destroy .mixdisplay}
		$ww.h.syscon.menu.sub1a entryconfig $big_mixwindows_index -label "EXTENDED MIX EDIT PAGE" -command "SetExtendableMixEditPage 1"
	}
}

proc LoadBigMixInfo {} {
	global evv bigmix
	set fnam [file join $evv(URES_DIR) "bigmix"]
	append fnam $evv(CDP_EXT)
	if {[file exists $fnam]} {
		set bigmix 1
	}
}

proc VBoxReleased {} {
	global released extendversion formantsversion sfeditversion
	if {[info exists released(specfnu)]  && ($extendversion >= 7) \
	&& [info exists released(wavmedian)] && [info exists released(bounce)] && [info exists released(distortt)] \
	&& ($formantsversion >= 6) && ($sfeditversion >= 7) } {
		return 1
	}
	return 0
}


#-- Exclude non-CDP files from loading to workspace

proc ExcludedFiletype {fnam} {
	set ext [file extension $fnam]
	switch -- $ext {
		".doc"  -
		".rff"  -
		".html" -
		".jpg" {
			return 1
		}
	}
	return 0
}

#--- On returning to superdir, highlight last dir used, and move display so it's in middle thereof

proc HilightLastSubdirUsed {lastdir} {
	global dl evv
	set i [LstIndx $lastdir $dl]
	set zend [$dl index end]
	if {$i >= 0} {
		$dl selection set $i
		if {$i >= [expr $evv(WKSPACE_HEIGHT) - 1]} {	;#	If previous dir is at or beyond foot of standard display (xview 0)
			set halflistlen [expr $evv(WKSPACE_HEIGHT)/2]
			set iup [expr $i - $halflistlen]			;#	Find start and end display-index if previous directory is in middle of new display
			set idn [expr $i + $halflistlen]				
			if {$iup < 0} {								;#	If start-of-display-index would be before start of list, move display to start of list 
				$dl yview 0
			} elseif {$idn >= [expr $zend - 1]} {		;#	If end-of-display-index would be beyond end of list, move display to end of list 		
				$dl yview $zend
			} else {									;#	Else, position previous directory in middle of display, by moving display	
				$dl yview $iup							;#	to start half-a-displaylen above the previous dir		
			}
		}
	}
}

proc LeaveSelectionMode {} {
	global ww
	if {[string match [$ww.1.a.endd.r.over.sel cget -text] "Return to Wkspace Mode"]} {
		ToWkspaceMode
	}
}

#--- From times from one mixfile to another

proc MultiTransfer {} {
	global chlist ch wl wstk evv pa

	set OK 0
	if {[info exists chlist] && ([llength $chlist] == 2)} {
		set OK 1
		set fnam1 [lindex $chlist 0]
		set fnam2 [lindex $chlist 1]
		if {![IsAMixfileIncludingMultichan $pa($fnam1,$evv(FTYP))] || ![IsAMixfileIncludingMultichan $pa($fnam2,$evv(FTYP))]} {
			set OK 0
			break
		}
	}
	if {!$OK} {
		set ilist [$wl curselection]
		if {[llength $ilist] == 2} {
			set OK 1
			set fnam1 [$wl get [lindex $ilist 0]]
			set fnam2 [$wl get [lindex $ilist 1]]
			if {![IsAMixfileIncludingMultichan $pa($fnam1,$evv(FTYP))] || ![IsAMixfileIncludingMultichan $pa($fnam2,$evv(FTYP))]} {
				set OK 0
			}
		}
	}
	if {!$OK} {
		Inf "Select two mixfiles"
		return 0
	}
	set multi1 1
	set multi2 1
	if {[IsAMixfile $pa($fnam1,$evv(FTYP))]} {
		set multi1 0
	}
	if {[IsAMixfile $pa($fnam2,$evv(FTYP))]} {
		set multi2 0
	}
	if [catch {open $fnam1 "r"} zit] {
		Inf "Cannot open file $fnam1 to read mix data"
		return 0
	}
	set linecnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			continue
		}
		if {($linecnt == 0) && $multi1} {				;#	Skip line with channel count
			incr linecnt
			continue
		}
		set line [split $line]
		set cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {$cnt == 1} {
				lappend times1 $item
				break
			}
			incr cnt
		}
		incr linecnt									;#	Counts all non-commented input lines
	}
	close $zit
	if {![info exists times1]} {
		Inf "Failed to find times in mixfile $fnam1"
		return 0
	}
	set timecnt1 [llength $times1]						;#	Count of times found

	if [catch {open $fnam2 "r"} zit] {
		Inf "Cannot open file $fnam1 to read mix data"
		return 0
	}
	catch {unset lines2}
	set linecnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			continue
		}
		if {($linecnt == 0) && $multi2} {				;#	Skip line with channel count
			lappend lines2 $line						;#	But remember value
			incr linecnt
			continue	
		}
		set line [split $line]
		set cnt 0
		catch {unset line2}
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {$cnt == 1} {
				lappend times2 $item
			}
			lappend line2 $item
			incr cnt
		}
		lappend lines2 $line2							;#	Stores all lines in 2nd file
		incr linecnt									;#	Counts all non-commented input lines
	}
	close $zit
	if {![info exists times2]} {
		Inf "Failed to find times in mixfile $fnam2"
		return 0
	}
	set timecnt2 [llength $times2]						;#	Number of times found	
	set linecnt2 [llength $lines2]						;#	Number of non-commented lines found
	set offset [expr $linecnt2 - $timecnt2]				;#	Any offset for channel-cnt line in multichan files

	set timepos1 0
	set timepos2 0

	;#	RESTART START OF COPYING, IF TIMES AT START TO BE SKIPPED

	if {$timecnt1 > $timecnt2} {
		set skip [expr $timecnt1 - $timecnt2]
		set msg "More lines in the first mixfile : skip $skip lines at end of $fnam1 ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			set msg "Skip $skip lines at start of $fnam1 ??"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return
			} else {
				set timepos1 $skip
			}
		}
	} elseif {$timecnt2 > $timecnt1} {
		set skip [expr $timecnt2 - $timecnt1]
		set msg "More lines in the second mixfile : skip $skip lines at end of $fnam2 ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			set msg "Skip $skip lines at start of $fnam2 ??"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return
			} else {
				set timepos2 $skip
			}
		}
	}

	;#	SET END OF COPYING TO MINIMUM NO OF TIMES STORED

	if {$timecnt2 < $timecnt1} {
		set copymax $timecnt2
	} else {
		set copymax $timecnt1
	}

	;#	SET LINENO AT START OF COPYING TO CORRESPOND TO TIME TO COPY, BUT INCR IF MULTICHAN FILE (WITH EXTRA CHANCNT LINE)

	set  linepos2 $timepos2
	incr linepos2 $offset

	while {$timepos1 < $copymax} {
		set time1 [lindex $times1 $timepos1]
		set line [lindex $lines2 $linepos2]
		set line [lreplace $line 1 1 $time1]
		set lines2 [lreplace $lines2 $linepos2 $linepos2 $line]
		incr timepos1
		incr timepos2
		incr linepos2
	}
	
	set tempfile $evv(DFLT_OUTNAME)$evv(TEXT_EXT)
	if [catch {file copy $fnam2 $tempfile} zit] {
		set msg "Cannot make failsafe bakup copy of original mix: proceed anyway ??"
		if {$choice == "no"} {
			return 0
		}
	}
	if {![DeleteNonSndfileFromSystem $fnam2]} {
		return 0
	}
	if [catch {open $fnam2 "w"} zit] {
		if {![file exists $tempfile]} {
			Inf "Failed to do time-transfer into file $fnam2: original file lost"
			return 0
		} elseif [catch {file rename $tempfile $fnam2} zit] {
			Inf "Failed to restore oiginal mix after time-transfer failure : Data is in file $tempfile\nrename this to $fnam2 ~~outside the Loom~~ before proceeding!!"
		}
		return 0
	}
	foreach line $lines2 {
		puts $zit $line
	}
	close $zit
	FileToWkspace $fnam2 0 0 0 0 1
	Inf "Times transferred"
	return 1
}

#-- Maxlevel of all files in mixfile

proc MaxlevelOfAllFilesSelectedOrInSelectedMixfile {} {
	global chlist wl evv pa maxsamp_line done_maxsamp CDPmaxId

	set OK 0
	if {[info exists chlist] && ([llength $chlist] >= 1)} {
		set OK 1
		if {[llength $chlist] == 1} {
			set mfnam [lindex $chlist 0]
			if {![IsAMixfileIncludingMultichan $pa($mfnam,$evv(FTYP))]} {
				unset mfnam
				set OK 0
			}
		} else {
			foreach fnam $chlist {
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					set OK 0
					break
				} else {
					lappend fnams $fnam
				}
			}
		}
	}
	if {!$OK} {
		set OK 1
		set ilist [$wl curselection]
		if {[llength $ilist] == 1} {
			set mfnam [$wl get [lindex $ilist 0]]
			if {![IsAMixfileIncludingMultichan $pa($mfnam,$evv(FTYP))]} {
				unset mfnam
				set OK 0
			}
		} else {
			foreach i $ilist {
				set fnam [$wl get $i]
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					set OK 0
					break
				} else {
					lappend fnams $fnam
				}
			}
	
		}
	}
	if {!$OK} {
		Inf "Select either a mixfile, or several soundfiles"
		return
	}
	if {[info exists mfnam]} {
		if [catch {open $mfnam "r"} zit] {
			Inf "Cannot open mixfile $mfnam to read it"
			return
		}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			if {[string match ";" [string index $line 0]]} {
				continue
			}
			set line [split $line]
			set cnt 0
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				if {$cnt == 0} {
					lappend fnams $item
				}
				incr cnt
			}
			if {$cnt == 1} {								;#	Don't keep channel-cnt line of multichan file
				set fnams [lreplace $fnams 0 0]
			}
		}
		close $zit
		if {![info exists fnams]} {
			Inf "No sound files found in file $mfnam"
			return
		}
	}
	set maxlev 0.0
	set minlev 10000000.0
	set thismaxsnd "Unknown"
	set thisminsnd "Unknown"

	Block "PLEASE WAIT: FINDING MAXSAMPS IN FILES"

	foreach fnam $fnams {

		wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP IN FILE $fnam"

		set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
		catch {unset maxsamp_line}
		set done_maxsamp 0
		lappend cmd $fnam
		if [catch {open "|$cmd"} CDPmaxId] {
			Inf "Failed to run 'maxsamp2$evv(exec)' for file $fnam"
			UnBlock
			return
	   	} else {
	   		fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
		}
	 	vwait done_maxsamp
		if {![info exists maxsamp_line]} {
			Inf "Cannot retrieve maximum sample of file $fnam"
			UnBlock
			return
		}
		set thismax [lindex $maxsamp_line 0]
		if {$thismax > $maxlev} {
			set thismaxsnd $fnam
			set maxlev $thismax
		}
		if {$thismax < $minlev} {
			set thisminsnd $fnam
			set minlev $thismax
		}
	}
	UnBlock
	Inf "Max sound level ($thismaxsnd) = $maxlev\nmin sound level ($thisminsnd) = $minlev"
}

proc SndsInTextfileExist {} {
	global wl evv chlist pa
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i == -1)} {
		if {[info exists chlist] && ([llength $chlist] == 1)} {
			set fnam [lindex $chlist 0]
			set i [LstIndx $fnam $wl]
			$wl selection clear 0 end
			$wl selection set $i
		} else {
			Inf "Select a single textfile containing soundfile names"
			return
		}
	}
	set fnam [$wl get $i]
	set is_sndlist 0
	if {[IsASndlist $pa($fnam,$evv(FTYP))] || [string match [file extension $fnam] ".orc"]} {
		set is_sndlist 1
	}

	if [catch {open $fnam "r"} zit] {
		Inf "Cannot open file $fnam"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		if {$is_sndlist} {
			if {![file exists $line]} {
				lappend bumlist $line
			}
		} else {
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				} else {
					if {![file exists $item]} {
						lappend bumlist $item
					}
					break
				}
			}
		}
	}
	close $zit
	if {[info exists bumlist]} {
		if {[llength $bumlist] == 1} {
			set msg "File [lindex $bumlist 0] no longer exists or has been moved"
		} else {
			set msg "The following files no longer exist or have been moved"
			set cnt 0
			foreach fnam $bumlist {
				if {$cnt >= 20} {
					append msg "\nand more"
					break
				}
				append msg "\n$fnam"
				incr cnt
			}
		}
	} else {
		set msg "All the files in the "
		if {$is_sndlist} {
			append msg "Soundlist "
		} else {
			append msg "Mixfile "
		}
		append msg "exist"
	}
	Inf $msg
}

proc OverlapSlice {} {
	global wl chlist evv wstk pr_ovslic ovslic pa simple_program_messages CDPidrun prg_dun prg_abortd last_outfile
	set ovslic(dfltlen) 60
	set ovslic(dfltovr) 5
	set ovslic(splice) 15		;#	15 mS splice

	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
	} else {
		set i [$wl curselection]
		if {[info exists i] && ([llength $i] == 1) && ($i >= 0)}  {
			set fnam [$wl get $i]
		}
	}
	if {![info exists fnam]} {
		Inf "Select a single soundfile"
		return
	}
	set ovslic(dur) $pa($fnam,$evv(DUR))
	set ovslic(idur) [expr int(floor($ovslic(dur)))]

	set f .ovslic
	if [Dlg_Create $f "OVERLAPPING SLICES" "set pr_ovslic 0" -borderwidth 2 -width 120] {
		frame $f.0
		button $f.0.do -text "Slice" -command "set pr_ovslic 1" -highlightbackground [option get . background {}]
		button $f.0.hh -text "Help" -command "set pr_ovslic 3" -bg $evv(HELP) -highlightbackground [option get . background {}]
		button $f.0.qq -text "Quit"  -command "set pr_ovslic 0" -highlightbackground [option get . background {}]
		pack $f.0.do $f.0.hh -side left -padx 8
		pack $f.0.qq -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.00
		label $f.00.ll -text "Up/Down Keys for Length : Control Up/Down for Overlap" -fg $evv(SPECIAL)
		button $f.00.df -command "set pr_ovslic 2" -text "Defaults" -highlightbackground [option get . background {}]
		pack $f.00.ll $f.00.df -side left -padx 4
		pack $f.00 -side top -pady 2
		frame $f.1
		label $f.1.len -text "Chunk length (secs)" -width 20
		entry $f.1.chlen -textvariable ovslic(len) -width 20 -state readonly
		pack $f.1.len $f.1.chlen -side left -padx 2
		pack $f.1 -side top -fill x -expand true -pady 2
		frame $f.2
		label $f.2.ovr -text "Overlap (secs)" -width 20
		entry $f.2.chovr -textvariable ovslic(ovr) -width 20 -state readonly
		pack $f.2.ovr $f.2.chovr -side left -padx 2
		pack $f.2 -side top -fill x -expand true -pady 2
		wm resizable $f 0 0
		bind $f <Up>			{Ovslice 0 0}
		bind $f <Down>			{Ovslice 0 1}
		bind $f <Control-Up>	{Ovslice 1 0}
		bind $f <Control-Down>	{Ovslice 1 1}
		bind $f <Return> {set pr_ovslic 1}
		bind $f <Escape> {set pr_ovslic 0}
	}
	if {![info exists ovslic(len)] || ([string length $ovslic(len)] == 0)} {
		ForceVal .ovslic.1.chlen $ovslic(dfltlen)
	}
	if {![info exists ovslic(ovr)] || ([string length $ovslic(ovr)] == 0)} {
		ForceVal .ovslic.2.chovr $ovslic(dfltovr)
	}
	set finished 0
	set pr_ovslic 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_ovslic $f.1.len
	while {!$finished} {
		DeleteAllTemporaryFiles
		tkwait variable pr_ovslic
		switch -- $pr_ovslic {
			0 {
				break
			}
			1 {
				if {![info exists ovslic(len)] || ([string length $ovslic(len)] == 0) || ($ovslic(len) < 1)} {
					Inf "Invalid length value : minimum 1 sec"
					continue
				}
				if {![info exists ovslic(ovr)] || ([string length $ovslic(ovr)] == 0) || ($ovslic(ovr) < 1)} {
					Inf "Invalid overlap value : minimum 1 sec"
					continue
				}
				if {$ovslic(dur) <= $ovslic(len)} {
					Inf FIle shorter than duration of one chunk"
					continue
				}
				set cutcnt [expr $ovslic(dur)/$ovslic(len)]
				if {$cutcnt > 100} {
					set msg "More than 100 slices : continue ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				set done 0
				set stt  0.0
				set endd [expr $ovslic(len) + $ovslic(ovr)]
				if {$endd >= $ovslic(dur)} {
					Inf "Only one slice"
					continue
				}
				catch {unset cuts}
				set step $ovslic(len)
				while {$stt < $ovslic(dur)} {
					set cut [list $stt $endd]
					lappend cuts $cut
					if {$done} {
						break
					}
					set stt [expr $stt  + $step]
					set endd [expr $endd + $step]
					if {$endd >= $ovslic(dur)} {
						set endd $ovslic(dur)
						set done 1
					}
				}
				set ocnt [llength $cuts]
				set outfnambas [file rootname [file tail $fnam]]
				set m 1
				catch {unset badouts}
				while {$m <= $ocnt} {
					set outfnam $outfnambas
					append outfnam "_"  $m $evv(SNDFILE_EXT)
					if {[file exists $outfnam]} {
						lappend badouts $outfnam
					}
					if {[info exists badouts]} {
						catch {unset outfnams}
					} else {
						lappend outfnams $outfnam
					}
					incr m
				}
				if {[info exists badouts]} {
					set msg "Output file [lindex $badouts 0] "
					if {[llength $badouts] > 1} {
						append msg "And others already exist\n\nDelete or backup these files"
					} else {
						append msg "Already exists\n\nDelete or backup this file"
					}
					append msg " to a directory before proceeding"
					Inf $msg
					continue
				}
				Block "SLICING $fnam"
				catch {unset ofnams}
				set n 0
				set m 1
				set OK 1
				while {$n < $ocnt} {		
					wm title .blocker "PLEASE WAIT:        CREATING SLICE $m of $ocnt"
					set cut [lindex $cuts $n]
					set stt  [lindex $cut 0]
					set endd [lindex $cut 1]
					set ofnam $evv(DFLT_OUTNAME)
					append ofnam $n $evv(SNDFILE_EXT)
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd cut 1 $fnam $ofnam $stt $endd -w$ovslic(splice)
					catch {unset simple_program_messages}
					set CDPidrun 0
					set prg_dun 0
					set prg_abortd 0
					if [catch {open "|$cmd"} CDPidrun] {
						Inf "Can't run process to create slice $m : $CDPidrun"
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						Inf "Failed to create slice $m"
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						Inf "No slice $m created"
						set OK 0
						break
					}
					lappend ofnams $ofnam
					incr n
					incr m
				}
				if {!$OK} {
					UnBlock
					continue
				}
				catch {unset finalfnams}
				foreach ofnam $ofnams outfnam $outfnams {
					if [catch {file rename $ofnam $outfnam} zit] {
						Inf "Cannot rename temporary file $ofnam to $outfnam"
					} else {
						lappend finalfnams $outfnam
					}
				}
				if {![info exists finalfnams]} {
					continue
				}
				set last_outfile $finalfnams
				set finalfnams [ReverseList $finalfnams]
				foreach finalfnam $finalfnams {
					FileToWkspace $finalfnam 0 0 0 0 1
				}
				UnBlock
				set finished 1
			}
			2 {
				ForceVal .ovslic.1.chlen $ovslic(dfltlen)
				ForceVal .ovslic.2.chovr $ovslic(dfltovr)
				continue
			}		
			3 {
				set msg "Slice to overlapping segments\n"
				append msg "\n"
				append msg "Cut a source into overlapping chunks of equal length.\n"
				append msg "\n"
				append msg "Use to chop up sources into smaller segments, for processing.\n"
				append msg "\n"
				append msg "The \"Chunk length\" specified will be extend by \"Overlap\" length,\n"
				append msg "but the next chunk will still start at +\"Chunk length\"\n"
				append msg "so the resulting cut segments will overlap one another.\n"
				append msg "\n"
				append msg "\"Chunk length\" must exceed \"Overlap\" by at least 1 sec.\n"
				Inf $msg
				continue
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}


proc Ovslice {over down } {
	global ovslic
	set maxovr [expr $ovslic(len) - 1]
	if {$over} {
		if {$down} {
			if {$ovslic(ovr) > 1} {
				incr ovslic(ovr) -1
			}
		} else {
			if {$ovslic(ovr) < $maxovr} {
				incr ovslic(ovr)
			}
		}
	} else {
		if {$down} {
			if {$ovslic(len) > 1} {
				incr ovslic(len) -1
			}
		} else {
			if {$ovslic(len) < $ovslic(idur)} {
				incr ovslic(len)
			}
		}
	}
}

proc DirSelAsWkspaceSelect {} {
	global wl dl_sstr
	set i [$wl curselection]
	if {![info exists i]} {
		Inf "No workspace file selected"
		return
	}
	if {[llength $i] > 1} {
		Inf "Select a single workspace file"
		return
	}
	if {$i == -1} {
		Inf "No workspace file selected"
		return
	}
	set fnam [$wl get $i]
	set dl_sstr [file rootname [file tail $fnam]]
	ForceVal .dlss.e.e $dl_sstr
}

proc GenPhraseHelp {} {
	global released
	set msg "                             GENERATE PHRASES FROM WORDLISTS\n"
	append msg "\n"
	append msg "Takes several textfiles containing adverbs, (Categories of) adjectives and nouns\n"
	append msg "and selects items from these to make phrases.\n"
	append msg "\n"
	append msg "Categories should fall into two contrasting types.\n"
	append msg "\n"
	append msg "More information from the \"Help\" button on the \"GENERATE PHRASES\" Window.\n"
	append msg "\n"
	append msg "\n"
	append msg "The following processes complement \"GENERATE PHRASES\" ...\n"
	append msg "\n"
	append msg "ALPHABETIC SORT & REMOVE DUPLICATES\n"
	append msg "\n"
	append msg "      Sorts the text-lines in a textfile into alphabetical order, removing duplicates.\n"
	append msg "      All texts are reduced to lower case.\n"
	append msg "\n"
	append msg "CONFLATE (& POSSIBLY RE-SORT) TEXTLINES IN FILES\n"
	append msg "\n"
	append msg "      Takes the text-lines from several textfiles, and merges them into one new file.\n"
	append msg "      Option to sort into alphabetical order and remove duplicates.\n"
	append msg "\n"
	append msg "ELIMINATE TEXTS COMMON TO DIFFERENT FILES\n"
	append msg "\n"
	append msg "      Examines the text-lines in several textfiles, removing any duplicated texts\n"
	append msg "      from ALL files EXCEPT THE SHORTEST of the files cotaining the SPECIFIC text.\n"
	append msg "\n"
	if {[info exists released(see_text_characters)]} {
		append msg "CHECK BAD CHARS IN NON-GRABBED TEXTFILE\n"
		append msg "\n"
		append msg "      Should a textfile, editied outside the Loom, fail to be grabbed to the Workspace\n"
		append msg "      the file is checked for any non-standard characters it may contain.\n"
		append msg "\n"
	}
	append msg "FIND REPEATED WORDS : PARTITION TEXTS TO FILES\n"
	append msg "\n"
	append msg "      Examines the text-lines in a textfile for matching words.\n"
	append msg "      The text-lines may then be partitioned into several different files,\n"
	append msg "      distributing the lines with matching words to different files.\n"
	append msg "\n"
	append msg "MARK & EXTRACT ITEMS FROM TEXTS LIST\n"
	append msg "\n"
	append msg "      Select lines from the the text-lines in a textfile\n"
	append msg "      and extract the selected lines to a new file.\n"
	append msg "\n"
	append msg "CATEGORISE & EXTRACT ITEMS FROM TEXTS LIST\n"
	append msg "\n"
	append msg "      Numerically mark text-lines in a textfile with values between 1 and 9.\n"
	append msg "      Extract the marked lines to new files, one for each number used.\n"
	append msg "\n"
	append msg "SPECIFY ORDER & REORDER TEXTS IN A TEXTS LIST\n"
	append msg "\n"
	append msg "      Number lines in a textfile, in any order.\n"
	append msg "      Extract the lines, in numbered order, to a new textfile.\n"
	append msg "\n"
	append msg "REORDER PRE-NUMBERED TEXTS\n"
	append msg "\n"
	append msg "      Extract the lines, in numbered order, to a new textfile.\n"
	append msg "\n"
	append msg "ASSEMBLE TEXT-LINES TO A CONTINUOUS TEXT\n"
	append msg "\n"
	append msg "      Get text-lines from a list of text-lines\n"
	append msg "      and assemble them into a continuous text (with possible paragraphing).\n"
	append msg "\n"
	append msg "COUNT SYLLABLES\n"
	append msg "\n"
	append msg "      Count the syllables in the words in text-lines in a textfile,\n"
	append msg "      and assess how long they would take to speak.\n"
	append msg "\n"
	Inf $msg
}

proc Help_PhrasePairs {} {
	set msg "                                       PAIR PHRASES\n"
	append msg "\n"
	append msg "TAKES TWO OR MORE TEXTFILES LISTING PHRASES\n"
	append msg "(alphabetic characters, underscores, hyphens & spaces only)\n"
	append msg "\n"
	append msg "Selects phrases at random from each list\n"
	append msg "and conjoins them using \":\" as a separator.\n"
	append msg "\n"
	append msg "With 2 input files, output is \"File 1 Phrase  :  File 2 Phrase\"\n"
	append msg "With 3 input files, output is \"File 1 Phrase  :  File 2 Phrase  :  File 3 Phrase\"\n"
	append msg "AND SO ON....\n"
	append msg "\n"
	append msg "Output text is then written to a new file.\n"
	append msg "\n"
	append msg "\n"
	append msg "                                       LINK PHRASES\n"
	append msg "\n"
	append msg "TAKES A TEXTFILES OF PAIRED PHRASES SEPARATED BY \":\"\n"
	append msg "AND ONE OR MORE OF THE FILES WITH THE FOLLOWING NAMES\n"
	append msg "\n"
	append msg "And links the paired-phrases with linkage words taken from the files ...\n"
	append msg "\n"
	append msg "(1) PRELINK\n"
	append msg "\n"
	append msg "             Introduces the selected phrase-pair with a \"Prelink\" text.\n"
	append msg "\n"
	append msg "(2) MIDLINK\n"
	append msg "\n"
	append msg "             Joins the selected phrase-pair with a \"Midlink\" text.\n"
	append msg "\n"
	append msg "(3) POSTLINK\n"
	append msg "\n"
	append msg "             Concludes the selected phrase-pair with a \"Postlink\" text.\n"
	append msg "\n"
	append msg "(4) INVERSELINK\n"
	append msg "\n"
	append msg "             Invert the order of the phrases in the phrase-pair\n"
	append msg "             and link with an \"Inverselink\" text.\n"
	append msg "\n"
	append msg "Output text is then written to a new file.\n"
	Inf $msg
}

proc WkDisplay {} {
	global wl evv last_stack_window ww chlist ch dl pa
	set islines 0
	if [winfo exists .display] {
		catch {destroy .display}
	}
	if {[info exists dl]} {
		set dlist [$dl curselection]
	}
	if {[info exists ch]} {
		set clist [$ch curselection]
	}
	set ilist [$wl curselection]
	if {[info exists ilist] && (([llength $ilist] > 1) || (([llength $ilist] == 1) && ($ilist != -1)))} {
		foreach i $ilist {
			lappend fxams [$wl get $i]
			lappend fnams [file rootname [file tail [$wl get $i]]]
		}
		set msg "From workspace"
	} elseif {[info exists clist] && (([llength $clist] > 1) || (([llength $clist] == 1) && ($clist != -1)))} {
		foreach i $clist {
			lappend fxams [$ch get $i]
			lappend fnams [file rootname [file tail [$ch get $i]]]
		}
		set msg "From chosen files"
	} elseif {[info exists dlist] && (([llength $dlist] > 1) || (([llength $dlist] == 1) && ($dlist != -1)))} {
		foreach i $dlist {
			lappend fxams [$dl get $i]
			lappend fnams [file rootname [file tail [$dl get $i]]]
		}
		set msg "From directory listing"
	}
	if {![info exists fnams]} {
		Inf "No files selected"
		return
	}
	if {[llength $fnams] == 1} {
		set fnam [lindex $fxams 0]
		if {$pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)} {
			if [catch {open $fnam "r"} zit] {
				Inf "Cannot open textfile [lindex $fnams 0]"
				return
			}
			while {[gets $zit line] >= 0} {
				lappend lines $line
			}
			close $zit
			if {![info exists lines]} {
				Inf "No data found in textfile [lindex $fnams 0]"
				return
			}
			set fnams $lines
			set islines 1
		}
	}
	set f .display
	set pr_display 0
	if [Dlg_Create $f "FILENAME DISPLAY $msg" "" -borderwidth $evv(BBDR)] {
		set f1 [frame $f.1]
		set f2 [frame $f.2]
		label $f1.ll -text "Move Leftwards with LEFT ARROW (twice) : Move Back with RIGHT ARROW" -fg $evv(SPECIAL)
		pack $f1.ll -side left -fill both -expand true -pady 2
		pack $f.1 -side top -pady 2 -anchor w 
		Scrolled_Listbox $f.2.ll -width 120 -height 48 -selectmode single
		pack $f.2.ll -side top -fill both -expand true -pady 2
		pack $f.2 -side top -pady 2
		wm resizable $f 0 0
	}
	if {$islines} {
		wm title .display "[file rootname [file tail $fnam]] DISPLAY"
	}
	foreach fnam $fnams {			
		$f2.ll.list insert end $fnam
	}
	set is_displayed 1
	Simple_Grab 1 .display pr_display
	update idletasks
	StandardPosition4 .display
	focus $last_stack_window
	catch {grab $last_stack_window}
	$ww.1.a.mez.dum config -text "DispOff" -command DestroyDisplay -bg $evv(QUIT_COLOR)
	bind $ww <Left>  {StandardPosition2 .display; raise .display; focus $ww}
	bind $ww <Right> {StandardPosition4 .display; raise $ww; focus $ww}
}


proc DestroyDisplay {} {
	global ww evv
	.display.2.ll.list delete 0 end
	catch {destroy .display}
	$ww.1.a.mez.dum config -text "Display" -command BareText -bg $evv(HELP)
	bind $ww <Left>  {}
	bind $ww <Right> {}
}

#--- 

proc ReplaceSuffixes {add} {
	global chlist ch wl pa evv background_listing rememd scores_refresh wstk
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No workspace files selected"
		return
	}
	foreach i $ilist {
		lappend wfnams [$wl get $i]
	}
	set len [llength $ilist]

	if {![info exists chlist] || ([llength $chlist] != $len)} {
		Inf "Number of chosen files does not equal number of workspace selected files"
		return
	}
	foreach cfnam $chlist {
		foreach wfnam $wfnams {
			if {[string match $cfnam $wfnam]} {
				Inf "File $cfnam is in both selections: cannot proceed"
				return
			}
		}
	}
	if {$add} {
		foreach wfnam $wfnams {
			lappend wfnampres [file rootname $wfnam]
			lappend wfnamexts [file extension $wfnam] 
		}
	} else {
		foreach wfnam $wfnams {
			set fnam [file rootname [file tail $wfnam]]
			set k [string length $fnam]			;#	012345	k = 6	:1::::		::::4: =(k-2) are limiting position for extension
			incr k -2							;#	abcdef			a_cdef  and abcd_f 
			while {$k > 0} {
				if {[string match [string index $fnam $k] "_"]} {
					lappend wfnampres [string range $wfnam 0 $k]
					lappend wfnamexts [file extension $wfnam] 
					break
				}
				incr k -1
			}			
			if {$k == 0} {
				Inf" no suffix found on workspace selected file $wfnam"
				return
			}
		}
	}
	foreach cfnam $chlist {
		set fnam [file rootname [file tail $cfnam]]
		set k [string length $fnam]
		incr k -2							;#	abcdef  a_cdef  and abcd_f are limiting position for extension
		while {$k > 0} {					
			if {[string match [string index $fnam $k] "_"]} {
				incr k
				lappend cfnamsufs [string range $fnam $k end]
				set j $k
				break
			}
			incr k -1
		}			
		if {$k == 0} {
			Inf" no suffix found on chosen list file $cfnam"
			return
		}
	}

	foreach wfnampre $wfnampres cfnamsuf $cfnamsufs wfnamext $wfnamexts {
		set nufnam $wfnampre
		append nufnam $cfnamsuf $wfnamext
		if {[file exists $nufnam]} {
			Inf "File $nufnam already exists : cannot proceed"
			return
		}
		lappend nufnams $nufnam
	}
	set msg "The new names are"
	foreach nufnam $nufnams {
		append msg "\n[file rootname [file tail $nufnam]]"
	}
	append msg "\n\nProceed ??"
	set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		return
	}
	set ren_blist 0
	set save_mixmanage 0

	foreach i $ilist fnam $wfnams nufnam $nufnams {
		set is_snd 0
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set is_snd 1
		}
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]

		if [catch {file rename -force $fnam $nufnam}] {
			ErrShow "CANNOT RENAME FILE $fnam\nIT MAY BE OPEN FOR PLAY, READ or VIEW\nCLOSE IT, TO RENAME FROM ITEM %d (ORIGINAL NAME $fnam) ONWARDS\n"
			if {$ren_blist} {
				SaveBL $background_listing
			}
			return
		}
		DataManage rename $fnam $nufnam
		lappend couettelist $fnam $nufnam
		UpdateBakupLog $fnam delete 0
		UpdateBakupLog $nufnam create 1
		if {$haspmark} {
			MovePmark $fnam $nufnam
		}
		if {$hasmmark} {
			MoveMmark $fnam $nufnam
		}
		if [IsInBlists $fnam] {
			if [RenameInBlists $fnam $nufnam] {
				set ren_blist 1
			}
		}
		if [IsOnScore $fnam] {
			RenameOnScore $fnam $nufnam
		}
		$wl delete $i								
		$wl insert $i $nufnam
		catch {unset rememd}

		RenameProps	$fnam $nufnam 1
		DummyHistory $fnam "RENAMED_$nufnam"
		if {[MixMRename $fnam $nufnam 0]} {
			set save_mixmanage 1
		}
		RenameOnDirlist $fnam $nufnam
		if {$is_snd} {
			CheckMainmixSnd $fnam $nufnam
			set are_snds 1
		} else {	
			CheckMainmix $fnam $nufnam
		}
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$are_snds} {
		set scores_refresh 1
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	foreach i $ilist {
		$wl selection set $i
	}
}

proc TellOnsetSlice {} {
	set msg "ONSET DETECTION, SLICING AND SYNCHRONISATION\n"
	append msg "\n"
	append msg "This set of processes allow you to ...\n"
	append msg "\n"
	append msg "(1)  Detect Sudden onsets in a sound.\n"
	append msg "             creating an ONSET LIST of these onset times.\n"
	append msg "(2)  Convert the ONSET LIST to an EDIT SLICE FILE.\n"
	append msg "             This can be used to slice the original sound\n"
	append msg "             into SLICES each starting at an onset\n"
	append msg "             (plus any pre-onsets sound).\n"
	append msg "\n"
	append msg "EITHER\n"
	append msg "\n"
	append msg "(3)  Use the ONSET LIST and the SLICES\n"
	append msg "             to create an EXTENDED VERSION of the original file.\n"
	append msg "\n"
	append msg "OR\n"
	append msg "\n"
	append msg "(4)  Use the EDIT SLICE FILE and one or more OTHER SOUNDS\n"
	append msg "             to generate a new sound whose onsets are\n"
	append msg "             synchronous with the original sound's onsets.\n"
	append msg "\n"
	Inf $msg
}

proc HelpInterleave {} {
	set msg "INTERLEAVE BY N\n"
	append msg "\n"
	append msg "If list consists of K sets of N items\n"
	append msg "regroup as N sets of K items.\n"
	append msg "\n"
	append msg "e.g.\n"
	append msg "N = setsize = 4    :     K = number of sets = 3\n"
	append msg "\n"
	append msg "List:           a1  a2  a3  a4  \\  b1  b2  b3  b4  \\  c1  c2  c3  c4            \n"
	append msg "\n"
	append msg "Regroup using N (setsize) = 4\n"
	append msg "\n"
	append msg "Becomes:  a1  b1  c1  \\  a2  b2  c2  \\  a3  b3  c3  \\  a4  b4  c4            \n"
	append msg "\n"
	append msg "-----------------------------------------------------------------------------------------------\n"
	append msg "\n"
	append msg "INTERLEAVE BY PATTERN\n"
	append msg "\n"
	append msg "If list consists of K sets of N items\n"
	append msg "regroup each set of N in a different order.\n"
	append msg "\n"
	append msg "e.g.\n"
	append msg "N = setsize = 4    :     K = number of sets = 3\n"
	append msg "\n"
	append msg "List:     a1  a2  a3  a4  \\  b1  b2  b3  b4  \\  c1  c2  c3  c4            \n"
	append msg "\n"
	append msg "Regroup using pattern a b c d : c b d a\n"
	append msg "\n"
	append msg "Becomes:  a3  a2  a4  a1  \\  b3  b2  b4  b1  \\  c3  c2  c4  c1            \n"
	append msg "\n"
	append msg "Pattern information consists of ...\n"
	append msg "\n"
	append msg "(1) A list of items separated by spaces with no item repeated.\n"
	append msg "(1) A 2nd list of ALL the SAME items, in a different order, with no item repeated.\n"
	append msg "\n"
	append msg "Number of items in pattern must be AN INTEGRAL DIVISOR of Number of items on Chosen List.\n"
	append msg "Items in list can use any letter combination  e.g. \"aa\" \"Dog\" \"fQWbtYi\"\n"
	append msg "\n"
	append msg "-----------------------------------------------------------------------------------------------\n"
	append msg "\n"
	append msg "INTERLEAVE BY NAME\n"
	append msg "\n"
	append msg "If list consists of sets of items with filenames containing distinct words\n"
	append msg "and these files are grouped so that AT LEAST ONE file with each name occurs\n"
	append msg "before any name is reused,\n"
	append msg "then the files can be reordered in terms of the words.\n"
	append msg "\n"
	append msg "List:     a_cat1  a_cat2   a_dog   a_vole \\  b_cat1  d_vole   b_dog1   b_dog2     \n"
	append msg "\n"
	append msg "Regroup using pattern \"dog cat vole\"\n"
	append msg "\n"
	append msg "Becomes:  a_dog   a_cat1  a_cat2   a_vole   \\  b_dog1   b_dog2  b_cat1  d_vole     \n"
	append msg "\n"
	append msg "\n"
	Inf $msg
}

#--- Rename workspace selected files using Rootname of files on Chosen List PLUS a suffix

proc BaseChosNamePlusSuffix {} {
	global wl chlist evv pr_chosuf chosufnam pa rememd background_listing scores_refresh 
	if {![info exists chlist] || ([llength $chlist] < 1)} {
		Inf "No chosen files"
		return
	}
	set chnams $chlist
	set ilist [$wl curselection]
	if {([llength $ilist] != [llength $chnams]) || ([lindex $ilist 0] < 0)} { 
		Inf "Number of workspace-selected items does not tally with number of files on chosen-files list"
		return
	}
	foreach i $ilist {
		lappend fnams [$wl get $i]
	}
	foreach fnam $fnams {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "This renaming process only works with soundfiles"
			return
		}
	}
	foreach chnam $chnams {
		if {$pa($chnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "This renaming process only works with soundfiles"
			return
		}
	}
	set f .chosuf
	if [Dlg_Create $f "CHOSENFILE NAMES + SUFFIX" "set pr_chosuf 0" -borderwidth 2] {
		frame $f.1
		button $f.1.ok -text "Rename" -command "set pr_chosuf 1" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Quit" -command "set pr_chosuf 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		label $f.2.ll -text "Suffix  :  (Letters and/or Numbers only)"
		entry $f.2.e -textvariable chosufnam -width 20
		pack $f.2.e $f.2.ll -side left -padx 2
		pack $f.2 -side top -pady 2
		wm resizable $f 0 0
		bind $f <Return> {set pr_chosuf 1}
		bind $f <Escape> {set pr_chosuf 0}
	}
	set chosufnam ""
	set finished 0
	set pr_chosuf 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_chosuf $f.2.e
	while {!$finished} {
		tkwait variable pr_chosuf
		if {$pr_chosuf} {
			if {([string length $chosufnam] <= 0) || ![regexp {^[a-zA-Z0-9]+$} $chosufnam]} {
				Inf "Invalid suffix : must be leters and/or numbers only"
				continue
			}
			set suf [string tolower $chosufnam]
			catch {delete nufnams}
			set OK 1
			foreach chnam $chnams {
				set nufnam [file rootname [file tail $chnam]]
				append nufnam "_" $suf $evv(SNDFILE_EXT)
				if {[file exists $nufnam]} {
					Inf "File $nufnam already exists : cannot proceed"
					set OK 0
					break
				}
				lappend nufnams $nufnam
			}
			if {!$OK} {
				continue
			}
			foreach nufnam $nufnams {
				foreach fnam $fnams {
					if {[string match $nufnam $fnam]} {
						Inf "The name $fnam occurs in both selections : cannot proceed"
						set OK 0
						break
					}
				}
				if {!$OK} {
					break
				}
			}
			if {!$OK} {
				continue
			}
			set ren_blist 0
			catch {unset couettelist}
			catch {unset badfiles}
			foreach fnam $fnams nufnam $nufnams i $ilist {
				set haspmark [HasPmark $fnam]
				set hasmmark [HasMmark $fnam]
				if [catch {file rename $fnam $nufnam} zit] {	
					lappend badfiles $fnam
					continue
				} else {						  					;#	Valid name, and file doesn't exist
					DummyHistory $fnam "RENAMED_$nufnam"
					UpdateChosenFileMemory $fnam $nufnam
					RenameProps	$fnam $nufnam 1				;#	rename props
					MixMRename $fnam $nufnam 1
					DataManage rename $fnam $nufnam
					lappend couettelist $fnam $nufnam
					UpdateBakupLog $fnam delete 0
					UpdateBakupLog $nufnam create 1
					CheckMainmix $fnam $nufnam
					CheckMainmixSnd $fnam $nufnam
					$wl delete $i								
					$wl insert $i $nufnam							;#	rename workspace item
					RenameOnDirlist $fnam $nufnam
					set scores_refresh 1
					if {$haspmark} {
						MovePmark $fnam $nufnam
					}
					if {$hasmmark} {
						MoveMmark $fnam $nufnam
					}
					if [IsInBlists $fnam] {
						if [RenameInBlists $fnam $nufnam] {
							set ren_blist 1
						}
					}
					if [IsOnScore $fnam] {
						RenameOnScore $fnam $nufnam
					}
					catch {unset rememd}
				}
			}
			if {[info exists couettelist]} {
				CouetteManage rename $couettelist
			}
			if {$ren_blist} {
				SaveBL $background_listing
			}
			if {[info exists badfiles]} {
				set cnt 0
				set msg "The following files could not be renamed"
				foreach fnam $badfiles {
					if {$cnt > 20} {
						append msg "\nand more"
						break
					}
					append msg "\n$fnam"
					incr cnt
				}
				Inf $msg
			}
			set finished 1
		} else {
			set finished 1
		}		
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}


#--- List only files with specified extension on Source Directory Listing

proc GetDirChan {chancnt} {
	global dl active_dir wksp_dirname previous_dirlisting previous_active_dir wstk ww evv is_subdirlist

	if {[info exists active_dir] && [info exists previous_active_dir]} {
		set xx $previous_active_dir
		set yy $previous_dirlisting
		set previous_active_dir $active_dir
		set previous_dirlisting [$dl get 0 end]
	}
	if {![info exists active_dir]} {
		Inf "No directory listed yet: use 'List : List Named Directory' or 'Home' key"
	} else {
		if {[string length $chancnt] <= 0} {
			Inf "No channel count entered"
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
			}
			return
		}
		foreach f_nam [glob -nocomplain [file join $wksp_dirname *]] {
			lappend fnamlist $f_nam
		}
		set local_fnamlist [$dl get 0 end]
		foreach f_nam $fnamlist {
			if {[lsearch $local_fnamlist $f_nam] < 0} {
				set msg "Search entire directory '$wksp_dirname' ?"
				set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
				if {$choice == "no"} {
					set fnamlist $local_fnamlist
					set local 1
				}
				break
			}
		}
		Block "PARSING FILES"
		foreach fnam $fnamlist {
			if [file isdirectory $fnam] {
				continue
			} elseif {[string match [file extension $fnam] $evv(SNDFILE_EXT)]} {
				if {[DoChanParse $fnam] == $chancnt} {
					lappend nuflist $fnam
				}
			}
		}
		UnBlock
		if {![info exists nuflist]} {
			if [info exists local] {
				Inf "No files of this type are listed"
			} else {
				Inf "No files of this type exist in this directory"
			}
			if {[info exists xx]} {
				set previous_active_dir $xx
				set previous_dirlisting $yy
			}
			return
		} else {
			$dl delete 0 end
			foreach fnam $nuflist {
				$dl insert end $fnam
			}
			$dl xview moveto 0.0
			$ww.1.b.labels.msg2 config -text "Files with Channel Count $chancnt"
		}
		catch {unset is_subdirlist}
	}
}

#------ Parse the file (using cdparse) merely to find the chan cnt

proc DoChanParse {fnam} {
	global CDPid parse_error infile_rejected pa propslist props_got is_input_parse evv
	set parse_error 0
	set props_got 0
	set infile_rejected 0
	set is_input_parse 0

	set CDPid 0
	set cmd [file join $evv(CDPROGRAM_DIR) cdparse]
	set zzfnam [OmitSpaces $fnam]
	lappend cmd $zzfnam 0
	if [catch {open "|$cmd"} CDPid] {
		catch {unset CDPid}
		return 0
	} else {
		set propslist ""
		fileevent $CDPid readable AccumulateFileProps
	}
	vwait props_got
	if {$parse_error || $infile_rejected || ![info exists propslist] || ([llength $propslist] < 1)} {
		return 0
	}
	return [lindex $propslist 4]

}

#--- Rename workspace selected files using Rootname of files on Chosen List PLUS a suffix

proc BaseChosNameReindexed {} {
	global wl chlist evv pa rememd background_listing scores_refresh 
	if {![info exists chlist] || ([llength $chlist] < 1)} {
		Inf "No chosen files"
		return
	}
	set chnams $chlist
	set ilist [$wl curselection]
	if {([llength $ilist] != [llength $chnams]) || ([lindex $ilist 0] < 0)} {
		Inf "Number of workspace-selected items does not tally with number of files on chosen-files list"
		return
	}
	foreach i $ilist {
		lappend fnams [$wl get $i]
	}
	foreach fnam $fnams {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "This renaming process only works with soundfiles"
			return
		}
	}
	set n 0
	foreach chnam $chnams {
		if {$pa($chnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "This renaming process only works with soundfiles"
			return
		}
		set qq [file rootname [file tail $chnam]]
		set qq [ReverseString $qq]
		if {![regexp {[0-9]} [string index $qq 0]]} {
			Inf "Not all chosen files have a numeric index at end of name"
			return
		}
		set k 1
		while {[regexp {[0-9]} [string index $qq $k]]} {
			incr k
		}
		incr k -1
		set num [string range $qq 0 $k]
		set num [ReverseString $num]
		if {$n == 0} {
			set nindex $num
		} elseif {$nindex != $num} {
			Inf "Not all chosen files have the same numeric index at end of name"
			return
		}
		incr n
	}
	incr nindex
	foreach chnam $chlist {
		set qq [file rootname [file tail $chnam]]
		set qq [ReverseString $qq]
		set k 0
		while {[regexp {[0-9]} [string index $qq $k]]} {
			incr k
		}
		set nufnam [string range $qq $k end]
		set nufnam [ReverseString $nufnam]
		append nufnam $nindex $evv(SNDFILE_EXT)
		lappend nufnams $nufnam
	}
	foreach nufnam $nufnams {
		if {[file exists $nufnam]} {
			Inf "File $nufnam already exists : cannot proceed"
			return
		}
	}
	set ren_blist 0
	catch {unset couettelist}
	catch {unset badfiles}
	foreach fnam $fnams nufnam $nufnams i $ilist {
		set haspmark [HasPmark $fnam]
		set hasmmark [HasMmark $fnam]
		if [catch {file rename $fnam $nufnam} zit] {	
			lappend badfiles $fnam
			continue
		} else {						  					;#	Valid name, and file doesn't exist
			DummyHistory $fnam "RENAMED_$nufnam"
			UpdateChosenFileMemory $fnam $nufnam
			RenameProps	$fnam $nufnam 1						;#	rename props
			MixMRename $fnam $nufnam 1
			DataManage rename $fnam $nufnam
			lappend couettelist $fnam $nufnam
			UpdateBakupLog $fnam delete 0
			UpdateBakupLog $nufnam create 1
			CheckMainmix $fnam $nufnam
			CheckMainmixSnd $fnam $nufnam
			$wl delete $i								
			$wl insert $i $nufnam							;#	rename workspace item
			RenameOnDirlist $fnam $nufnam
			set scores_refresh 1
			if {$haspmark} {
				MovePmark $fnam $nufnam
			}
			if {$hasmmark} {
				MoveMmark $fnam $nufnam
			}
			if [IsInBlists $fnam] {
				if [RenameInBlists $fnam $nufnam] {
					set ren_blist 1
				}
			}
			if [IsOnScore $fnam] {
				RenameOnScore $fnam $nufnam
			}
			catch {unset rememd}
		}
	}
	if {[info exists couettelist]} {
		CouetteManage rename $couettelist
	}
	if {$ren_blist} {
		SaveBL $background_listing
	}
	if {[info exists badfiles]} {
		set cnt 0
		set msg "The following files could not be renamed"
		foreach fnam $badfiles {
			if {$cnt > 20} {
				append msg "\nand more"
				break
			}
			append msg "\n$fnam"
			incr cnt
		}
		Inf $msg
	}
}

proc PlayMerge {} {
	global wl pa evv wstk simple_program_messages CDPidrun prg_dun prg_abortd
	set ilist [$wl curselection]
	set len [llength $ilist]
	if {$len < 2} {
		Inf "Too few files selected"
		return
	}
	if {$len > 8} {
		Inf "Too many files selected"
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {($pa($fnam,$evv(TYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 1)} {
			Inf "Mono soundfiles only"
			return
		}
		lappend fnams $fnam
	}
	set ofnam $evv(DFLT_OUTNAME)
	append ofnam $evv(SNDFILE_EXT)
	Block "INTERLEAVING FILES"
	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	lappend cmd interleave 
	foreach fnam $fnams {
		lappend cmd $fnam
	}
	lappend cmd $ofnam

	catch {unset simple_program_messages}
	set CDPidrun 0
	set prg_dun 0
	set prg_abortd 0
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Can't run process to interleave files : $CDPidrun"
		UnBlock
		return
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "Failed to create interleaved file"
		catch {unset CDPidrun}
		UnBlock
		return
	}
	if {![file exists $ofnam]} {
		Inf "No interleaved file created"
		catch {unset CDPidrun}
		UnBlock
		return
	}
	UnBlock
	set choice "yes"
	while {$choice == "yes"} {
		set msg "HEAR IT AGAIN ?"
		while {$choice == "yes"} {
			PlaySndfile $ofnam 0			;# PLAY OUTPUT
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		}
	}
	DeleteAllTemporaryFiles
}

proc MergeTextfiles {} {
	global wl pa evv wstk
	set msg "Select two textfiles of the same type"
	set ilist [$wl curselection]
	if {[llength $ilist] != 2} {
		Inf $msg
		return
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		lappend fnams $fnam
	}
	set n 0
	foreach fnam $fnams {
		if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE)) } {
			Inf $msg
			return
		}
		set typ($n) $pa($fnam,$evv(FTYP))
		incr n
	}
	if {$typ(0) != $typ(1)} {
		Inf $msg
		return
	}
	if {$typ(0) == $evv(MIX_MULTI)} {
		set fnam [lindex $fnams 0]
		if [catch {open $fnam "r"} zit] {
			Inf "Cannot open file 1 to read the channel count data : $zit"
			return
		}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			if {[string match [string index $line 0] ";"]} {
				continue
			}
			set chans1 $line
			break
		}
		close $zit
		if {![info exists chans1]} {
			Inf "No channel count data found in file 1"
			return
		}
	}
	set fnam [lindex $fnams 1]
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot open file 2 to read the data : $zit"
		return
	}
	set istop 1
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {$istop && ([string match [string index $line 0] ";"])} {	;#	IGNORE ANY COMMENTS AT TOP OF 2ND FILE
			continue
		}
		lappend lines $line
		if {$istop && ($typ(0) == $evv(MIX_MULTI))} {
			set chans2 $line
		}
		set istop 0
	}
	close $zit
	if {![info exists lines]} {
		Inf "No data found in file 2"
		return
	}
	if {$typ(0) == $evv(MIX_MULTI)} {
		if {$chans1 < $chans2} {
			Inf "The 2nd mixfile has more channels than the first"
			return
		} elseif {$chans1 > $chans2} {
			set msg "The 2nd mixfile has less channels than the first : proceed anyway ??"
			set choice [tk_messageBox -type yesno -default yes -message $msg -icon question -parent [lindex $wstk end]]
			if {$choice == "no"} {
				return
			}
		}
		set lines [lrange $lines 1 end]
	}

	set outfnam [lindex $fnams 0]
	if [catch {open $outfnam "a"} zit] {
		Inf "Cannot open original file 1 to append data : $zit"
		return
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	if [catch {open $outfnam "r"} zit] {
		Inf "Cannot open output file to count lines : $zit\n\nline count data will be wrong"
		return
	}
	set n 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		incr n
	}
	close $zit
	set pa($outfnam,$evv(LINECNT)) $n
}


#------ Parse the file (using cdparse) merely to find the duration

proc DoDurParse {fnam} {
	global CDPid parse_error infile_rejected pa propslist props_got is_input_parse evv
	set parse_error 0
	set props_got 0
	set infile_rejected 0
	set is_input_parse 0

	set CDPid 0
	set cmd [file join $evv(CDPROGRAM_DIR) cdparse]
	set zzfnam [OmitSpaces $fnam]
	lappend cmd $zzfnam 0
	if [catch {open "|$cmd"} CDPid] {
		catch {unset CDPid}
		return 0
	} else {
		set propslist ""
		fileevent $CDPid readable AccumulateFileProps
	}
	vwait props_got
	if {$parse_error || $infile_rejected || ![info exists propslist] || ([llength $propslist] < 1)} {
		return 0
	}
	set pa($fnam,$evv(DUR)) [lindex $propslist 11]
	return 1
}

proc Show_Linepair {del} {
	global ct_line
	if {$del} {
		ForceVal .textcomp.aaa.ee ""
		return
	}
	set kk -1
	set k [.textcomp.b.b.ll.list curselection]
	if {$k < 0} {
		set k [.textcomp.b.c.ll.list curselection]
		set kk $k
	}
	if {$k >= 0} {
		 if {[llength $k] != 1} {
			return
		}
		set n 0
		while {$n < 2} {
			.textcomp.b.b.ll.list selection set $k
			set x 0
			after 1000 {set x 1}
			vwait x
			.textcomp.b.c.ll.list selection set $k
			set x 0
			after 1000 {set x 1}
			vwait x
			incr n
		}
		if {$kk >= 0} {
			.textcomp.b.c.ll.list selection set $k
		} else {
			.textcomp.b.b.ll.list selection set $k
		}
		set ct_line [expr $k + 1]
		ForceVal .textcomp.aaa.ee $ct_line
	} else {
		Inf "No line selected"
	}
}

proc CompareGrab {} {
	set kk -1
	set k [.textcomp.b.b.ll.list curselection]
	if {$k < 0} {
		set k [.textcomp.b.c.ll.list curselection]
		set kk $k
		set listing .textcomp.b.c.ll.list
	} else {
		set listing .textcomp.b.b.ll.list
	}
	if {$k >= 0} {
		UniversalGrab $listing
	}
}

proc ComparePlay {} {
	set kk -1
	set k [.textcomp.b.b.ll.list curselection]
	if {$k < 0} {
		set k [.textcomp.b.c.ll.list curselection]
		set kk $k
		set listing .textcomp.b.c.ll.list
	} else {
		set listing .textcomp.b.b.ll.list
	}
	if {$k >= 0} {
		set fnam [$listing get $k]
		set fnam [split $fnam]
		set fnam [lindex $fnam 0]
		if {[string match ";" [string index $fnam 0]]} {
			set fnam {[string range $fnam 1 end]}
		}
		if {[file exists $fnam]} {
			PlaySndfile $fnam 0
		} else {
			Inf "\"$fnam\" is not a soundfile"
		}
	}
}

proc CheckTextfileSyntaxForAMix {} {
	global pa evv wl wstk
	set outchans 2
	set is_multi 0
	set i [$wl curselection]
	if {[info exists i] && ([llength $i] == 1) && ($i != -1)} {
		set fnam [$wl get $i]
		if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
			unset fnam
		}
	}
	if {![info exists fnam]} {
		Inf "Select a textfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot open file $fnam to read the data"
		return
	}

	set linecnt 1					;#	
	set true_linecnt 1				;#	COUNTS ALL LINES
	set badfilelist {}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			if {$linecnt != 1} {
				incr linecnt
			}
			incr true_linecnt
			continue
		}
		set line [split $line]
		set cnt 0
		set OK 1
		set superchans 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			switch -- $cnt {
				0 {	;# SOUNDFILE
					catch {unset inchans}
					if {($linecnt == 1) && [regexp {^[0-9]+$} $item] && [IsNumeric $item]} {
						set outchans $item
						set is_multi 1
						incr cnt
						break
					} else {
						if {![file exists $item]} {
							if {[lsearch $item $badfilelist] < 0} {
								set badfile "line $true_linecnt : $item DOES NOT EXIST"
								lappend badfiles $badfile
								lappend badfilelist $item
							}
							incr cnt 
							break
						} else {
							if {![info exists pa($item,$evv(FTYP))]} {
								if {[FileToWkspace $item 0 0 0 1 1] <= 0} {
									Inf "Cannot grab file $item to workspace to check channel count"
								}
							}
							if {[info exists pa($item,$evv(FTYP))]} {
								if {$pa($item,$evv(FTYP)) != $evv(SNDFILE)} {
									set badfile "line $true_linecnt : FILE IS NOT A SOUNDFILE"
									lappend badfiles $badfile
								} elseif {$pa($item,$evv(CHANS)) > $outchans} {
									if {$is_multi} {
										set superchans $pa($item,$evv(CHANS))
										set inchans $pa($item,$evv(CHANS))
									} else {
										set badfile "line $true_linecnt : FILE HAS TOO MANY CHANNELS"
										lappend badfiles $badfile
									}
								} else {
									set inchans $pa($item,$evv(CHANS))
								}
							}
						}
					}
				}
				1 {	;# TIME
					if {($linecnt == 1) && $is_multi} {
						set badline "FIRST LINE INVALID FOR ANY MIXFILE"
						set OK 0
						break
					}
					if {![IsNumeric $item] || ($item < 0)} {
						set badtime "line $true_linecnt time $item"
						lappend badtimes $badtime 
					}
				}
				2 {	;# CHANNEL CNT
					if {![IsNumeric $item] || ![regexp {^[0-9]+$} $item] || ($item < 1) || ($item > 16)} {
						set badchan "line $true_linecnt channel-cnt $item"
						lappend badchans $badchan
					} elseif {[info exists inchans] && ($item != $inchans)} {
						set badchan "line $true_linecnt channel-cnt ($item) does not tally with file's chancnt ($inchans)"
						lappend badchans $badchan
					}
				}
				3 -
				5 {
					if {$is_multi} {
						;# ROUTING
						set badrout [IsGoodRout $item $inchans $outchans $true_linecnt $superchans]
						if {[string length $badrout] > 0} {
							lappend badrouts $badrout
						}
					} else {
						;# LEVEL
						if {![IsNumeric $item] || ($item < 0)} {
							set badlevel "line $true_linecnt level $item"
							lappend badlevels $badlevel
						}
					}
				}
				4 -
				6 {
					if {$is_multi} {
						;# LEVEL
						if {![IsNumeric $item] || ($item < 0)} {
							set badlevel "line $true_linecnt level $item"
							lappend badlevels $badlevel
						}
					} else {
						;# STEREO ROUTING
						if {!([string match "L" $item] || [string match "R" $item] || [string match "C" $item]) && (![IsNumeric $item] || ($item < -1) || ($item > 1))} {
							set badrout "line $true_linecnt position $item"
							lappend badrouts $badrout
						}
					}
				}
				default {
					if {$is_multi} {
						if {[IsEven $cnt]} {
							;# LEVEL
							if {![IsNumeric $item] || ($item < 0)} {
								set badlevel "line $true_linecnt level $item"
								lappend badlevels $badlevel
							}
						} else {
							;# ROUTING
							set badrout [IsGoodRout $item $inchans $outchans $true_linecnt $superchans]
							if {[string length $badrout] > 0} {
								lappend badrouts $badrout
							}
						}
					}
				}
			}	
			incr cnt
		}
		if {$OK} {
			if {$is_multi} {
				if {[IsEven $cnt]} {
					set badlinecnt "line $true_linecnt entries-in-line $cnt"
					lappend badlinecnts $badlinecnt 
				}
			} elseif {[info exists inchans]} {
				if {$inchans == 2} {
					if {!(($cnt == 4) || ($cnt == 7))} {
						set badlinecnt "line $true_linecnt entries-in-line $cnt"
						lappend badlinecnts $badlinecnt 
					}
				} else {
					if {!(($cnt == 4) || ($cnt == 5))} {
						set badlinecnt "line $true_linecnt entries-in-line $cnt"
						lappend badlinecnts $badlinecnt 
					}
				}
			}
		}
		incr linecnt
		incr true_linecnt
	}
	close $zit
	set msg ""
	if {[info exists badline]} {
		append msg "$badline\n"
	}
	if {[info exists badfiles]} {
		append msg "These files are invalid\n"
		foreach item $badfiles {
			append msg "$item\n"
		}
	}
	if {[info exists badtimes]} {
		append msg "These times are not valid\n"
		foreach item $badtimes {
			append msg "$item\n"
		}
	}
	if {[info exists badchans]} {
		append msg "These channel-count values are not valid\n"
		foreach item $badchans {
			append msg "$item\n"
		}
	}
	if {[info exists badrouts]} {
		append msg "This routing data is not valid in this file\n"
		foreach item $badrouts {
			append msg "$item\n"
		}
	}
	if {[info exists badlevels]} {
		append msg "This level data is not valid\n"
		foreach item $badlevels {
			append msg "$item\n"
		}
	}
	if {[info exists badlinecnts]} {
		append msg "These lines have inappropriate length for this type of mix\n"
		foreach item $badlinecnts {
			append msg "$item\n"
		}
	}
	if {[string length $msg] <= 0} {
		set ext [file extension $fnam]
		set msg "This is a valid mixfile"
		if {!([string match $ext [GetTextfileExtension mix]] || [string match $ext [GetTextfileExtension mmx]])} {
			append msg " : Run \"UPdate Data\" on the file"
		}
	}
	Inf $msg
	return
}

proc IsGoodRout {str inchans outchans linecnt superchans} {
	if {$superchans} {					;#	FILE HAS MORE CHANNELS THAN MIX OUTPUT ; POSSIBLE WITH STEREO-STAGING FROM MULTICHAN FILE
		set inchans $superchans
	} else {
		set inchans $outchans
	}
	set badrout ""
	if {[string first ":" $str] < 0} {
		set badrout "line $linecnt rout $str"
	} else {
		set items [split $str ":"]
		if {[llength $items] != 2} {
			set badrout "line $linecnt rout $str"
		} else {
			set x [lindex $items 0]
			if {![IsNumeric $x] || ![regexp {^[0-9]+$} $x] || ($x > $inchans) || ($x < 1)} {
				set badrout "line $linecnt rout $str"
			} else {
				set x [lindex $items 1]
				if {![IsNumeric $x] || ![regexp {^[0-9]+$} $x] || ($x > $outchans) || ($x < 1)} {
					set badrout "line $linecnt rout $str"
				}
			}
		}
	}
	return $badrout
}

proc ThisSndInMix {} {
	global chlist wl pa evv
	if {[info exists chlist] && ([llength $chlist] == 2)} {
		set fnam1 [lindex $chlist 0]
		set fnam2 [lindex $chlist 1]
		if {[IsAMixfileIncludingMultichan $pa($fnam1,$evv(FTYP))]} {
			set fnammix $fnam1
			if {$pa($fnam2,$evv(FTYP)) == $evv(SNDFILE)} {
				set fnamsnd $fnam2
			}
		} elseif {$pa($fnam1,$evv(FTYP)) == $evv(SNDFILE)} {
			set fnamsnd $fnam1
			if {[IsAMixfileIncludingMultichan $pa($fnam2,$evv(FTYP))]} {
				set fnammix $fnam2
			} else {
				unset fnamsnd
			}
		}
	}
	if {![info exists fnamsnd]} {
		set ilist [$wl curselection]
		if {[llength $ilist] == 2} {
			set fnam1 [$wl get [lindex $ilist 0]]
			set fnam2 [$wl get [lindex $ilist 1]]
			if {[IsAMixfileIncludingMultichan $pa($fnam1,$evv(FTYP))]} {
				set fnammix $fnam1
				if {$pa($fnam2,$evv(FTYP)) == $evv(SNDFILE)} {
					set fnamsnd $fnam2
				}
			} elseif {$pa($fnam1,$evv(FTYP)) == $evv(SNDFILE)} {
				set fnamsnd $fnam1
				if {[IsAMixfileIncludingMultichan $pa($fnam2,$evv(FTYP))]} {
					set fnammix $fnam2
				} else {
					unset fnamsnd
				}
			}
		}
	}
	if {![info exists fnamsnd]} {
		Inf "Select a soundfile and a mixfile"
		return
	}
	if [catch {open $fnammix "r"} zit] {
		Inf "Cannot open mixfile [file tail $fnammix] : $zit"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[llength $line] <= 0} {
			continue
		}
		set iscomment 0
		if {[string match ";" [string index $line 0]]} {
			set iscomment 1
			set line [string range $line 1 end]
		}
		set line [split $line]
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {[string match $item $fnamsnd]} {
				if {$is_comment && ![info exists outmsg]} {
					set outmsg "FILE IS COMMENTED OUT IN THIS MIXFILE"
				} else {
					close $zit
					Inf "File is in the mixfile"
					return
				}
			}
			break
		}
	}
	close $zit
	if {[info exists outmsg]} {
		set msg $outmsg
	} else {
		set msg "File is ~~not~~ in the mixfile"
	}
	Inf $msg
}

proc TellStereoOnLeft {} {
	set msg "STEREO TO \"STEREO\" ON LEFT, OR ON RIGHT\n"
	append msg "\n"
	append msg "For \"STEREO ON LEFT\", takes a stereo input file ...\n"
	append msg "\n"
	append msg "(1)  Places the Input Left Channel on the Output Left Channel.\n"
	append msg "\n"
	append msg "(2)  Places the Input Right Channel at the mix Centre.\n"
	append msg "\n"
	append msg "\n"
	append msg "\n"
	append msg "For \"STEREO ON RIGHT\", takes a stereo input file ...\n"
	append msg "\n"
	append msg "(1)  Places the Input Right Channel on the Output Right Channel.\n"
	append msg "\n"
	append msg "(2)  Places the Input Left Channel at the mix Centre.\n"
	append msg "\n"
	append msg "\n"
	append msg "\n"
	append msg "CREATES MULTICHANNEL MIXFILE TO ACHIEVE REQUIRED REBALANCING.\n"
	Inf $msg
}

#--- Create mix to shift a stereo image to left, or to right

proc StereoOnLeft {} {
	global chlist wl pa evv pr_stonleft ston_left stonleftofnam stonleft_dflt stoneleftcentre
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 2) } {
			unset fnam
		}
	}
	if {![info exists fnam]} {
		set ilist [$wl curselection]
		if {[info exists ilist] && ([llength $ilist] == 1) && ($ilist != -1)} {
			set i [lindex $ilist 0]
			set fnam [$wl get $i]
			if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 2) } {
				unset fnam
			}
		}
	}
	if {![info exists fnam]} {
		Inf "Select a stereo soundfile"
		return
	}
	set f .ston_left
	if [Dlg_Create $f "STEREO TO ON-LEFT OR ON-RIGHT" "set pr_stonleft 0" -borderwidth 2] {
		frame $f.1
		button $f.1.ok -text "Reorient" -command "set pr_stonleft 1" -highlightbackground [option get . background {}]
		button $f.1.qq -text "Quit" -command "set pr_stonleft 0" -highlightbackground [option get . background {}]
		pack $f.1.ok -side left
		pack $f.1.qq -side right
		pack $f.1 -side top -fill x -expand true
		frame $f.2
		radiobutton $f.2.ll -variable ston_left -text "on Left" -value 1
		radiobutton $f.2.rr -variable ston_left -text "on Right" -value 2
		pack $f.2.ll $f.2.rr -side left -padx 4
		pack $f.2 -side top -pady 2
		frame $f.3
		label $f.3.ll -text "Output Mixfile Name"
		entry $f.3.e -textvariable stonleftofnam -width 64
		checkbutton $f.3.d -variable stonleft_dflt -text "Use default Name" 
		pack $f.3.e $f.3.ll $f.3.d -side left -padx 2
		pack $f.3 -side top -pady 2
		wm resizable $f 0 0
		bind $f <Return> {set pr_stonleft 1}
		bind $f <Escape> {set pr_stonleft 0}
	}
	set stonleftofnam ""
	set ston_left 1
	set stonleft_dflt 0
	set finished 0
	set pr_stonleft 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_stonleft $f.3.e
	while {!$finished} {
		tkwait variable pr_stonleft
		switch -- $pr_stonleft {
			1 {
				if {$ston_left <= 0} {
					Inf "Select the output bias (to left or right)"
					continue
				}
				if {$stonleft_dflt} {
					set stonleftofnam [file rootname [file tail $fnam]]
					switch -- $ston_left {
						1 {
							append stonleftofnam "_toleft"
						} 
						2 {
							append stonleftofnam "_toright"
						}
					}
					set ofnam $stonleftofnam
				} else {
					if {[string length $stonleftofnam] <= 0} {
						Inf "No output file name specified"
						continue
					}
					set ofnam [string tolower $stonleftofnam]
					if {![ValidCDPRootname $ofnam]} {
						continue
					}
				}
				append ofnam [GetTextfileExtension mmx]
				if {[file exists $ofnam]} {
					Inf "File $ofnam already exists : please choose a different name"
					set stonleftofnam [file rootname [file tail $fnam]]
					set stonleft_dflt 0
					continue
				}
				switch -- $ston_left {
					1 {
						set mixline [list $fnam 0.0 2 1:1 1.0 2:1 0.5 2:2 0.5]
					}
					2 {
						set mixline [list $fnam 0.0 2 1:1 0.5 1:2 0.5 2:2 1.0]
					}
				}
				catch {unset mixlines}
				set line 2
				lappend mixlines $line
				lappend mixlines $mixline
				if [catch {open $ofnam "w"} zit] {
					Inf "Can not open file $ofnam to wrote output mix data"
					continue
				}
				foreach line $mixlines {
					puts $zit $line
				}
				close $zit
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File $ofnam is on the workspace"
				} else {
					Inf "File $ofnam has been created, but is not yet on the workspace (see home directory)"
				}
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc CompareAll {} {
	global chlist wl evv pa wstk compare_info simple_program_messages CDPidrun prg_dun prg_abortd
	catch {unset compare_info}
	if {[info exists chlist] && ([llength $chlist] > 2)} {
		foreach fnam $chlist {
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				lappend fnams $fnam
			} else {
				unset fnams
				break
			}
		}
	}
	if {![info exists fnams]} {
		set ilist [$wl curselection]
		if {[llength $ilist] > 2} {
			foreach i $ilist {
				set fnam [$wl get $i]
				if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
					lappend fnams $fnam
				} else {
					unset fnams
					break
				}
			}
		}
	}
	set msg ""
	if {![info exists fnams]} {
		append msg "Select at least threee soundfiles"
		if {([info exists chlist] && ([llength $chlist] == 2)) || ([info exists ilist] && ([llength $ilist] == 2))} {
			append msg "\n\n(To compare two soundfiles, use the \"Sound Info\" menu item \"compare files\")\n"
		}
		Inf $msg
	}
	set len [llength $fnams]
	set j $len
	set k $j
	incr k -1
	set k [expr $k * $j]
	if {$k > 100} {
		set msg "This involves over 100 comparisons\n\ncompare files in batches of (no more than) 10 (recommended) ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			return
		}
	}
	set len_less_one [expr $len - 1]
	set k 0
	while {$k < $len_less_one} {
		set j $k
		incr j
		while {$j < $len} {
			set pair [list [lindex $fnams $k] [lindex $fnams $j]]
			set pairno [list [expr $k + 1] [expr $j + 1]]
			lappend pairs $pair
			lappend pairnos $pairno
			incr j
		}
		incr k
	}
	Block "Comparing Files"
	set OK 1
	foreach pair $pairs pairno $pairnos {
		if {[info exists compare_info]} {
			lappend blag [StripCurlies $compare_info]
		}
		catch {unset compare_info}
		set i [lindex $pairno 0]
		set j [lindex $pairno 1]
		set cmd [file join $evv(CDPROGRAM_DIR) sndinfo]
		lappend cmd diff 
		set cmd [concat $cmd $pair]
		wm title .blocker "PLEASE WAIT:        COMPARING FILES $i AND $j"
		catch {unset simple_program_messages}
		set CDPidrun 0
		set prg_dun 0
		set prg_abortd 0
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "Can't run comparison process for files $i and $j : $CDPidrun"
			continue
		} else {
			fileevent $CDPidrun readable "Get_Compare_Info $i $j"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			Inf "Failed to run comparison process for files $i and $j"
			catch {unset CDPidrun}
		}
		set x 0
		after 10 {set x 1}
		vwait x
	}
	UnBlock
	if {![info exists blag]} {
		Inf "No comparison information"
		return
	}
	set msg ""
	foreach line $blag {
		append msg "$line\n"
	}
	Inf $msg
}


#---- Get file comparison info

proc Get_Compare_Info {x y} {
	global CDPidrun prg_dun compare_info

	if {[info exists CDPidrun] && [eof $CDPidrun]} {
		catch {close $CDPidrun}
		set prg_dun 1
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} else {
			set compare_info [concat FILES $x $y : $line]
			catch {close $CDPidrun}
			set prg_dun 1
			return
		}
	}
	update idletasks
}			

#####################
# pvx OUTPUT FORMAT #
#####################

proc ReadPvx {} {
	global evv pvx
	set fnam [file join $evv(URES_DIR) pvx$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		set evv(ANALFILE_OUT_EXT) .ana
		catch {unset pvx}
		return
	} else {
		set evv(ANALFILE_OUT_EXT) .pvx
	}
	set pvx 1
}


proc SavePvx {} {
	global evv pvx
	set fnam [file join $evv(URES_DIR) pvx$evv(CDP_EXT)]
	if {[info exists pvx]} {
		if {![file exists $fnam]} {
			if [catch {open $fnam "w"} zit] {
				Inf "CANNOT CREATE FILE $fnam TO REMEMBER pvx SETTING"
				return
			}
			close $zit
		}
	} else {
		if {[file exists $fnam]} {
			if [catch {file delete $fnam} zit] {
				Inf "CANNOT DLETE FILE $fnam TO REMEMBER pvx SETTING"
				return
			}
		}
	}
}

proc PvxFormat {set} {	
	global pvx evv
	if {$set} {
		if {![info exists pvx]} {
			set evv(ANALFILE_OUT_EXT) .pvx
			set pvx 1
			SavePvx
		}
	} else {
		if {[info exists pvx]} {
			set evv(ANALFILE_OUT_EXT) .ana
			unset pvx
			SavePvx
		}
	}
}
