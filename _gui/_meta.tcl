#
# SOUND LOOM RELEASE mac version 17.0.4
#
#RWD 30 June 2013
# ... fixup button rectangles

#----- Interpolation interface

proc Interpolator {test} {
	global interp_outlist pr_interp inbicnt inbiname intpskew pa chlist wstk sl_real evv shortwindows
	global intp_last_ilist ch chcnt chpos interpsrccnt interpsrc interpcnt intp_templist outbicnt genintname wl 
	global dupl_mix dupl_vbx dupl_txt readonlyfg readonlybg

	if {$sl_real} {
		if {(![info exists chlist]) || ([llength $chlist] < 2)} {
			Inf "Choose At Least Two Files On The Workspace"
			return
		}
		set fnam [lindex $chlist 0]
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "First Chosen File Is Not A Soundfile"
			return
		}
		if {$dupl_mix || $dupl_vbx || $dupl_txt} {
			Inf "Duplicate Files On Chosen Files List: Interpolation Will Make No Difference"
			return
		}
		set n 0
		set interpsrc($n) $fnam
		incr n
		set srate $pa($fnam,$evv(SRATE)) 
		set chans $pa($fnam,$evv(CHANS))
		set maxlen $pa($fnam,$evv(DUR))
		foreach fnam [lrange $chlist 1 end] {
			if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
				Inf "Not All The Chosen Files Are Soundfiles"
				return
			}
			if {$pa($fnam,$evv(SRATE)) != $srate} {
				Inf "The Chosen Files Do Not Have The Same Sampling Rate"
				return
			}
			if {$pa($fnam,$evv(CHANS)) != $chans} {
				Inf "The Chosen Files Do Not Have The Same Number Of Channels"
				return
			}
			if {$pa($fnam,$evv(DUR)) > $maxlen} {
				set maxlen $pa($fnam,$evv(DUR))
			}
			set interpsrc($n) $fnam
			incr n
		}
		set interpcnt $n
		set interpsrccnt $n

		set i 2
		while {$i <= 64} {
			lappend powstwo $i
			set i [expr $i * 2]
		}
	}
	set f .interp
	if [Dlg_Create $f "MAKE INTERPOLATED FILES" "set pr_interp -2" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.00 -bd $evv(SBDR)
		frame $f.0 -bd $evv(SBDR)
		frame $f.01 -bg $evv(POINT) -height 1
		frame $f.1 -bd $evv(SBDR)
		frame $f.1.1 -bd $evv(SBDR)
		frame $f.16 -bg $evv(POINT) -height 1
		frame $f.6 -bd $evv(SBDR)
		frame $f.6.1 -bd $evv(SBDR)
		frame $f.64 -bg $evv(POINT) -height 1
		frame $f.4 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.77 -bd $evv(SBDR)
		button $f.00.help -text "Help" -command {CDP_Specific_Usage $evv(TE_31) 0} -bg $evv(HELP) -highlightbackground [option get . background {}]
		pack $f.00.help -side left
		pack $f.00 -side top -fill x -expand true
		button $f.0.bi -text "Interp 2 Files" -command {set pr_interp 1} -width 20 -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f.0.bu -text "Interp All Files" -command {set pr_interp 9} -width 20 -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f.0.ba -text "Play In Order" -command {set pr_interp 3} -width 20 -highlightbackground [option get . background {}]
		button $f.0.bc -text "Conclude (Keep New)" -command {set pr_interp 0} -width 20 -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f.0.bq -text "Quit (Destroy New)" -command {set pr_interp -1} -width 20 -highlightbackground [option get . background {}]
		pack $f.0.bi $f.0.bu $f.0.ba -side left -padx 2
		pack $f.0.bq $f.0.bc -side right -padx 2
		button $f.1.bs -text "Play Last Interp Made" -command {set pr_interp 5} -width 20 -highlightbackground [option get . background {}]
		button $f.1.br -text "Restore Play Selection" -command {set pr_interp 8} -width 20 -highlightbackground [option get . background {}]
		label $f.1.1.lab -text "<<-- LAST INTERPOLATION MADE -->>" -fg $evv(SPECIAL)
		pack $f.1.1.lab -side top -pady 3
		button $f.1.bx -text "Delete Last Interps" -command {DeleteLastInterpFiles} -width 20 -highlightbackground [option get . background {}]
		pack $f.1.bs $f.1.br -side left -padx 2
		pack $f.1.bx -side right -padx 2
		pack $f.1.1 -side left -fill x -expand true
		button $f.6.bp -text "Play Selectd Files" -command {set pr_interp 2} -width 20 -highlightbackground [option get . background {}]
		button $f.6.bn -text "Play Non-Sel Files" -command {set pr_interp 6} -width 20 -highlightbackground [option get . background {}]
		label $f.6.1.lab -text "FILES\n<<- SELECTED ->>\nBELOW" -fg $evv(SPECIAL)
		pack $f.6.1.lab -side top -pady 3
		button $f.6.bd -text "Delete Selectd Files" -command {set pr_interp 4} -width 20 -highlightbackground [option get . background {}]
		button $f.6.bk -text "Delete Non-Sel Files" -command {set pr_interp 7} -width 20 -highlightbackground [option get . background {}]
		pack $f.6.bp $f.6.bn -side left -padx 2
		pack $f.6.bd $f.6.bk -side right -padx 2
		pack $f.6.1 -side left -fill x -expand true

		label $f.4.lab0 -text "Total Files created"
		entry $f.4.e0 -textvariable outbicnt -width 3 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f.4.lab -text "No. of interpd files "
		entry $f.4.e -textvariable inbicnt -width 3
		label $f.4.lab2 -text "Group Name"
		entry $f.4.e2 -textvariable inbiname -width 20
		label $f.4.lab3 -text "Skew "
		entry $f.4.e3 -textvariable intpskew -width 3
		pack $f.4.lab $f.4.e $f.4.lab2 $f.4.e2 $f.4.lab3 $f.4.e3 $f.4.lab0 $f.4.e0 -side left -padx 1 -anchor center
		if {[info exists shortwindows]} {
			Scrolled_Listbox $f.3.ll -width 80 -height 16 -selectmode extended
		} else {
			Scrolled_Listbox $f.3.ll -width 80 -height 24 -selectmode extended
		}
		pack $f.3.ll -side top
		label $f.lab1 -text "SELECT 2 ADJACENT FILES TO INTERPOLATE : SKEW 1 GIVES LINEAR INTERPOLATION" -fg $evv(SPECIAL)
		pack $f.0 $f.01 $f.1 $f.16 $f.6 $f.64 -side top -pady 2 -fill x -expand true
		pack $f.4 -side top -pady 2
		button $f.77.ren -text "Generically Rename New Files" -command GenInterp -highlightbackground [option get . background {}]
		label $f.77.ll -text "Generic Name"
		entry $f.77.e -textvariable genintname -width 20
		pack $f.77.ren $f.77.ll $f.77.e -side left -padx 3
		pack $f.lab1 -side top -anchor center
		pack $f.3 -side top -fill both -expand true
		pack $f.77 -side top -pady 2
		bind $f.4.e  <Right> {focus .interp.4.e2}
		bind $f.4.e2 <Right> {focus .interp.4.e3}
		bind $f.4.e3 <Right> {focus .interp.4.e}
		bind $f.4.e  <Left> {focus .interp.4.e3}
		bind $f.4.e2 <Left> {focus .interp.4.e}
		bind $f.4.e3 <Left> {focus .interp.4.e2}
		bind .interp <Control-Key-P> {UniversalPlay list .interp.3.ll.list}
		bind .interp <Control-Key-p> {UniversalPlay list .interp.3.ll.list}
		bind .interp <Key-space>	 {UniversalPlay list .interp.3.ll.list}
		bind .interp <Double-1>		 {UniversalPlay list .interp.3.ll.list}
	}
	ForceVal $f.4.e0 0
	.interp.3.ll.list delete 0 end
	if {$sl_real} {
		set n 0
		while {$n < $interpsrccnt} {
			.interp.3.ll.list insert end $interpsrc($n)
			incr n
		}
	}
	set deflen [string length $evv(DFLT_OUTNAME)]
	set interp_outlist {}
	set pr_interp 0
	set intpskew 1
	set inbiname ""
	set inbicnt ""
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_interp $f.4.e
	while {!$finished} {
		tkwait variable pr_interp
		switch -- $pr_interp {
			-2 {
				Inf "Please Close The Window By Using One Of The Buttons"
				continue
			}
			-1 {				;#	TERMINATE AND DELETE ALL THE INTERP FILES
				if {[llength $interp_outlist] > 0} {
					foreach fnam $interp_outlist {		
						if [catch {file delete $fnam} zit] {
							Inf "Cannot Delete File '$fnam'"
							continue
						}
					}
					set interp_outlist {}
				}
				break
			}
			0 {	
				break			;#	TERMINATE AND KEEP ALL THE INTERP FILES
			}
			1 {					;#	DO INTERPOLATION
				catch {unset interp_play_outlist}
				if {!$sl_real} {
					TellDoInterp
					continue
				}
				if {[string length $inbicnt] <= 0} {
					Inf "No Interpolation Count Entered"
					continue
				} 
				if {![regexp {^[0-9]+$} $inbicnt] || ($inbicnt <= 0) || ($inbicnt > 64)} {
					Inf "Invalid Interpolation Count Entered (Max 64)"
					continue
				}
				if {![IsNumeric $intpskew] || ($intpskew <= 0.0)} {
					Inf "Invalid Skew Value"
					continue
				}
				if {[Flteq $intpskew 1.0]} {
					set intpskew 1
				} else {
					set k [lsearch $powstwo $inbicnt]
					if {$k < 0} {
						Inf "When Skew Is Not Zero\nNumber Of Interpolated Files Must Be\nA Power Of 2\n(2, 4, 8, 16, 32 or 64)"
						continue
					}
				}
				if {$interpcnt == 2} {
					set i0 0
					set i1 1
				} else {
					set ilist [.interp.3.ll.list curselection]
					if {![info exists ilist] || ([llength $ilist] <= 0)} {
						Inf "No Files Selected"
						continue
					}	
					if {[llength $ilist] != 2} {
						Inf "Select Two Adjacent Files"
						continue
					}
					set i0 [lindex $ilist 0]	
					set i1 [lindex $ilist 1]
					set diff [expr $i1 - $i0]
					if {$diff  != 1} {
						Inf "Select Two Adjacent Files"
						continue
					}
				}
				if {[string length $inbiname] <= 0} {
					Inf "No Interpolation Name Entered"
					continue
				} 
				set inbiname [string tolower $inbiname]
				if {![ValidCDPRootname $inbiname]} {
					continue
				}
				set OK 1
				Block "Checking the Name"
				set len [string length $inbiname]
				foreach ofnam [glob -nocomplain *.*] {		;# Check name against all existing names
					set ofnam [file rootname [file tail $ofnam]]
					if {[string match $inbiname* $ofnam]} {
						set ofnam [string range $ofnam $len end]
						if [regexp {^[0-9]+$} $ofnam] {
							Inf "This Name Is Already In Use"
							set OK 0
							break
						}
					}
				}
				UnBlock
				if {!$OK} {
					continue
				}
				set totlen [expr $maxlen * $inbicnt]
				if {![CheckScoreTestDiskspace $totlen $srate]} {
					Inf "Insufficient Diskspace To Proceed"
					continue
				}
				if {[info exists fnam_0] && [info exists fnam_1] } {
					set last_fnam0 $fnam_0
					set last_fnam1 $fnam_1
				}
				set fnam_0 [.interp.3.ll.list get $i0]
				set fnam_1 [.interp.3.ll.list get $i1]
				catch {unset batch}
				if {$intpskew == 1.0} {
					set line [list submix inbetween 1 $fnam_0 $fnam_1 $evv(DFLT_OUTNAME) $inbicnt]
				} else {
					catch {unset skewlist}
					set denom $inbicnt
					incr denom
					set n 1
					set OK 1
					while {$n < $denom} {
						set skewval [expr pow((double($n)/double($denom)),$intpskew)]
						set k [string first "e" $skewval]
						if {$k >= 0} {
							Inf "Generated Skew Values Which Are Too Small\nDo The Interpolation In More Than One Stage"
							set OK 0
							break
						}
						lappend skewlist [expr pow((double($n)/double($denom)),$intpskew)]
						incr n
					}
					if {!$OK} {
						if {[info exists last_fnam0] && [info exists last_fnam1]} {
							set fnam0 $last_fnam0
							set fnam1 $last_fnam1
						} else {
							catch {unset fnam0}
							catch {unset fnam1}
						}
						continue
					}
					set skewfnam $evv(MACH_OUTFNAME)$evv(TEXT_EXT)
					if [catch {open $skewfnam w} zit] {
						Inf "Cannot Open Temporary File '$fnam' To Store Interpolation Ratios"
						if {[info exists last_fnam0] && [info exists last_fnam1]} {
							set fnam0 $last_fnam0
							set fnam1 $last_fnam1
						} else {
							catch {unset fnam0}
							catch {unset fnam1}
						}
						continue
					}
					foreach skewval $skewlist {
						puts $zit $skewval
					}
					close $zit
					set line [list submix inbetween 2 $fnam_0 $fnam_1 $evv(DFLT_OUTNAME) $skewfnam]
				}
				lappend batch $line
				set title "Doing Interpolation"
				set done 0
				if {[RunScoreTestBatchFile $batch $title]} {
					set done 1
					set outcnt 0
					catch {unset intp_templist}
					foreach fnam [glob -nocomplain $evv(DFLT_OUTNAME)*] {
						set nufnam $inbiname
						set nuno [string range $fnam $deflen end]
						while {[string match "0" [string index $nuno 0]] != 0} {
							set nuno [string range $nuno 1 end]
						}
						set nuext [file extension $nuno]
						set nuno [file rootname $nuno]
						if {[string length $nuno] <= 0} {
							set msg ""
							ClearTempFiles 0 $msg
							set msg "There Is Possibly (still) A Temporary File '$evv(DFLT_OUTNAME)0' On Your System"
							append msg "\nPossibly Open For Play or View."
							append msg "\n\nIf So, You Must Close Play or View Now\nOr Otherwise Delete This File\n\nThen Rerun The Interpolation"
							Inf $msg
							set outcnt 0
							break
						} 
						incr nuno -1
						append nufnam $nuno $nuext		;#	Transfer numbering from tempfile to name
						if [catch {file rename $fnam $nufnam} zit] {
							Inf "Cannot Rename Temporary File '$fnam'"
							if [catch {file delete $fnam} zit] {
								Inf "Cannot Delete Temporary File '$fnam'\n\nThis Will Prevent You From Making\nFurther Interpolations"
								set outcnt 0
								set finished 1
								break
							}
						} else {
							lappend intp_templist $nufnam
							incr outcnt
						}
					}
					if {$outcnt > 0} {
						set interp_outlist [concat $interp_outlist $intp_templist]
						foreach fnam [ReverseList $intp_templist] {
							.interp.3.ll.list insert $i1 $fnam
							incr interpcnt
						}
					} else {
						set done 0
					}
				}
				if {[info exists skewfnam] && [file exists $skewfnam]} {
					if [catch {file delete $skewfnam} zit] {
						Inf "Cannot Delete Temporary File '$fnam'\n\nThis Will Prevent You From Making\nFurther Interpolations"
						set outcnt 0
						set finished 1
						break
					}
				}
				if {$done} {
					catch {unset intp_last_ilist}
					set outbicnt [.interp.3.ll.list index end]
					incr outbicnt -2
					ForceVal .interp.4.e0 $outbicnt
				} else {
					if {[info exists last_fnam0] && [info exists last_fnam1]} {
						set fnam0 $last_fnam0
						set fnam1 $last_fnam1
					} else {
						catch {unset fnam0}
						catch {unset fnam1}
					}
					Inf "No Interpolations Made This Time Round"
				}
			}
			2 -
			5 -
			3 -
			6 {									
				switch -- $pr_interp {
					2 {							;# PLAY SELECTED FILES
						if {!$sl_real} {
							TellInterpPlaySelected
							continue
						}
						set ilist [.interp.3.ll.list curselection]
						if {![info exists ilist] || ([llength $ilist] <= 0)} {
							Inf "No Files Selected"
							continue
						}	
						set intp_last_ilist $ilist
					}
					3 {							;# PLAY ALL FILES
						if {!$sl_real} {
							TellInterpPlayAll
							continue
						}
						catch {unset ilist}
						set i 0
						foreach fnam [.interp.3.ll.list get 0 end] {
							lappend ilist $i
							incr i
						}
					} 
					5 {							;# PLAY LAST MADE INTERPOLATION SET

						if {!$sl_real} {
							TellInterpPlayLastMade
							continue
						}
						catch {unset zublist}
						if {[info exists interp_play_outlist]} {
							set zublist $interp_play_outlist
						} elseif {[info exists intp_templist]} {
							set zublist $intp_templist
						}
						if {[info exists fnam_0] && [info exists fnam_1] && [info exists zublist]} {
							set OK 1
							set asked 0
							set ilist $fnam_0
							foreach fnam $zublist {
								if {![file exists $fnam]} {
									if {!$asked} {
										set asked 1
										set msg "Some Of The Last Made Files No Longer Exist\n\nPlay What's Left ??"
										set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
										if {$choice == "no"} {
											set OK 0
											break
										}
									}
								} else {
									lappend ilist $fnam
								}
							}
							if {!$OK} {
								continue
							}
							lappend ilist $fnam_1
						} else {
							Inf "No Previous Interpolation Set Exists"
							continue
						}
					}
					6 {							;# PLAY FILES NOT SELECTED
						if {!$sl_real} {
							TellInterpPlayNotSel
							continue
						}
						catch {unset nuilist}
						catch {unset ilist}
						set nuilist [.interp.3.ll.list curselection]
						if {![info exists nuilist] || ([llength $nuilist] <= 0)} {
							Inf "No Files Selected"
							continue
						}	
						set intp_last_ilist $nuilist
						set i 0
						foreach fnam [.interp.3.ll.list get 0 end] {
							if {[lsearch $nuilist $i] < 0} {
								lappend ilist $i
							}
							incr i
						}
						if {![info exists ilist]} {
							Inf "No Files Left To Play"
							continue
						}	
					}
				}
				set len [llength $ilist]
				if {$len > 1} {
					set totlen [expr $maxlen * $len]
					if {![CheckScoreTestDiskspace $totlen $srate]} {
						Inf "Insufficient Diskspace To Join These Files"
						continue
					}
					catch {unset joinlist}
					if {$pr_interp == 5} {
						set joinlist $ilist
					} else {
						foreach i $ilist {
							lappend joinlist [.interp.3.ll.list get $i]
						}
					}
					set line "sfedit join "
					set outfilename $evv(DFLT_OUTNAME)
					append outfilename "0"
					set line [concat $line $joinlist $outfilename -w2]
					catch {unset batch}
					lappend batch $line
					set title "Joining Files"
					if {[RunScoreTestBatchFile $batch $title]} {
						append outfilename $evv(SNDFILE_EXT)
						PlaySndfile $outfilename 0			;# PLAY OUTPUT
						set msg "\n      Using The Interpolator May Generate Errors"
						ClearTempFiles 1 $msg
					} else {
						Inf "Failed To Join The Selected Files"
					}				
				} else {
					PlaySndfile [.interp.3.ll.list get [lindex $ilist 0]] 0
				}
			}
			4 {
				DeleteInterpFiles 0
			}
			7 {
				DeleteInterpFiles 1
			}
			8 {
				if {!$sl_real} {
					Inf "Specific Files Are Highlighted For Playing In Sequence.\n\nThis Button Returns To The Previous Set Of Highlighted Files.\nIn This Way, Different Selected Sets Of Files May Be Played And Compared."
					continue
				}
				if {![info exists intp_last_ilist]} {
					Inf "No Previous Play Selection With Current Files"
					continue
				}
				.interp.3.ll.list selection clear 0 end
				foreach i $intp_last_ilist {
					.interp.3.ll.list selection set $i
				}
			}
			9 {					;#	DO SEVERAL INTERPOLATIONS
				if {!$sl_real} {
					TellDoInterpMulti
					continue
				}
				if {[string length $inbicnt] <= 0} {
					Inf "No Interpolation Count Entered"
					continue
				} 
				if {![regexp {^[0-9]+$} $inbicnt] || ($inbicnt <= 0) || ($inbicnt > 16)} {
					Inf "Invalid Multi Interpolation Count Entered (Max 16)"
					continue
				}
				if {![IsNumeric $intpskew] || ($intpskew <= 0.0)} {
					Inf "Invalid Skew Value"
					continue
				}
				if {[Flteq $intpskew 1.0]} {
					set intpskew 1
				} else {
					set k [lsearch $powstwo $inbicnt]
					if {$k < 0} {
						Inf "When Skew Is Not Zero\nNumber Of Interpolated Files Must Be\nA Power Of 2\n(2, 4, 8, 16, 32 or 64)"
						continue
					}
				}
				catch {unset pairlist}
				if {$interpcnt == 2} {
					set pairlist [list 0 1]
				} else {
					set ilist [.interp.3.ll.list curselection]
					if {![info exists ilist] || ([llength $ilist] <= 0)} {
						Inf "No Files Selected"
						continue
					}	
					set ilen [llength $ilist]
					if {$ilen < 2} {
						Inf "Select At Least Two Adjacent Files"
						continue
					}
					set c0 0
					set c1 1
					set OK 1
					while {$c1 < $ilen} {
						set i0 [lindex $ilist $c0]	
						set i1 [lindex $ilist $c1]
						set diff [expr $i1 - $i0]
						if {$diff  != 1} {
							Inf "Select Adjacent Files"
							set OK 0 
							break
						}
						lappend pairlist $i0 $i1
						incr c0
						incr c1
					}
					if {!$OK} {
						continue
					}
				}
				set interp_num [expr [llength $pairlist] / 2]
				if {[string length $inbiname] <= 0} {
					Inf "No Interpolation Name Entered"
					continue
				} 
				set inbiname [string tolower $inbiname]
				if {![ValidCDPRootname $inbiname]} {
					continue
				}
				set OK 1
				Block "Checking the Name"
				set len [string length $inbiname]
				foreach ofnam [glob -nocomplain *.*] {		;# Check name against all existing names
					set ofnam [file rootname [file tail $ofnam]]
					if {[string match $inbiname* $ofnam]} {
						set ofnam [string range $ofnam $len end]
						if [regexp {^[0-9]+$} $ofnam] {
							Inf "This Name Is Already In Use"
							set OK 0
							break
						}
					}
				}
				UnBlock
				if {!$OK} {
					continue
				}
				set totlen [expr $maxlen * $inbicnt * $interp_num]
				if {![CheckScoreTestDiskspace $totlen $srate]} {
					Inf "Insufficient Diskspace To Proceed"
					continue
				}
				if {[info exists fnam_0] && [info exists fnam_1] } {
					set last_fnam0 $fnam_0
					set last_fnam1 $fnam_1
				}
				set fnam_0 [.interp.3.ll.list get [lindex $pairlist 0]]
				set fnam_1 [.interp.3.ll.list get [lindex $pairlist end]]
				if {$intpskew != 1.0} {
					catch {unset skewlist}
					set denom $inbicnt
					incr denom
					set n 1
					set OK 1
					while {$n < $denom} {
						set skewval [expr pow((double($n)/double($denom)),$intpskew)]
						set k [string first "e" $skewval]
						if {$k >= 0} {
							Inf "Generated Skew Values Which Are Too Small\nDo The Interpolation In More Than One Stage"
							set OK 0
							break
						}
						lappend skewlist [expr pow((double($n)/double($denom)),$intpskew)]
						incr n
					}
					if {!$OK} {
						if {[info exists last_fnam0] && [info exists last_fnam1]} {
							set fnam0 $last_fnam0
							set fnam1 $last_fnam1
						} else {
							catch {unset fnam0}
							catch {unset fnam1}
						}
						continue
					}
					set skewfnam $evv(MACH_OUTFNAME)$evv(TEXT_EXT)
					if [catch {open $skewfnam w} zit] {
						Inf "Cannot Open Temporary File '$fnam' To Store Interpolation Ratios"
						if {[info exists last_fnam0] && [info exists last_fnam1]} {
							set fnam0 $last_fnam0
							set fnam1 $last_fnam1
						} else {
							catch {unset fnam0}
							catch {unset fnam1}
						}
						continue
					}
					foreach skewval $skewlist {
						puts $zit $skewval
					}
					close $zit
				}
				set pair_cnt 0
				set fail_cnt 0
				set interp_play_outlist {}
				catch {unset nuno}
				set n 0
				set thisincr 0
				while {$n < $interp_num} {
					set m [expr $n * 2]
					set i [lindex $pairlist $m]
					incr i $thisincr
					set pairlist [lreplace $pairlist $m $m $i]
					incr m
					set i [lindex $pairlist $m]
					incr i $thisincr
					set pairlist [lreplace $pairlist $m $m $i]
					incr thisincr $inbicnt
					incr n
				}
				set total_intp_templist {}
				foreach {i0 i1} $pairlist {
					set fnam_0x [.interp.3.ll.list get $i0]
					set fnam_1x [.interp.3.ll.list get $i1]
					catch {unset batch}
					if {$intpskew == 1.0} {
						set line [list submix inbetween 1 $fnam_0x $fnam_1x $evv(DFLT_OUTNAME) $inbicnt]
					} else {
						set line [list submix inbetween 2 $fnam_0x $fnam_1x $evv(DFLT_OUTNAME) $skewfnam]
					}
					lappend batch $line
					set title "Doing Interpolation"
					set done 0
					set OK 1
					if {[RunScoreTestBatchFile $batch $title]} {
						set done 1
						set outcnt 0
						catch {unset intp_templist}
						foreach fnam [glob -nocomplain $evv(DFLT_OUTNAME)*] {
							if {$pair_cnt == 0} {
								set nufnam $inbiname
								set nuno [string range $fnam $deflen end]
								while {[string match "0" [string index $nuno 0]] != 0} {
									set nuno [string range $nuno 1 end]
								}
								set nuext [file extension $nuno]
								set nuno [file rootname $nuno]
								if {[string length $nuno] <= 0} {
									set msg ""
									ClearTempFiles 0 $msg
									set msg "There Is Possibly (still) A Temporary File '$evv(DFLT_OUTNAME)0' On Your System"
									append msg "\nPossibly Open For Play or View."
									append msg "\n\nIf So, You Must Close Play or View Now\nOr Otherwise Delete This File\n\nThen Rerun The Interpolation"
									Inf $msg
									set outcnt 0
									set OK 0
									break
								} 
								incr nuno -1
							} else {
								set nufnam $inbiname
								incr nuno
							}
							append nufnam $nuno $nuext		;#	Transfer numbering from tempfile to name
							if [catch {file rename $fnam $nufnam} zit] {
								Inf "Cannot Rename Temporary File '$fnam'"
								if [catch {file delete $fnam} zit] {
									Inf "Cannot Delete Temporary File '$fnam'\n\nThis Will Prevent You From Making\nFurther Interpolations"
									set outcnt 0
									set OK 0
									break
								}
							} else {
								lappend intp_templist $nufnam
								incr outcnt
							}
						}
						if {$outcnt > 0} {
							set interp_outlist [concat $interp_outlist $intp_templist]
							set total_intp_templist [concat $total_intp_templist $intp_templist]
							if {$pair_cnt < [expr $interp_num - 1]} {
								set interp_play_outlist [concat $interp_play_outlist $intp_templist $fnam_1x]
							} else {
								set interp_play_outlist [concat $interp_play_outlist $intp_templist]
							}
							foreach fnam [ReverseList $intp_templist] {
								.interp.3.ll.list insert $i1 $fnam
								incr interpcnt
							}
						} else {
							set done 0
						}
					}
					if {!$OK} {
						break
					}
					if {$done} {
						catch {unset intp_last_ilist}
						set outbicnt [.interp.3.ll.list index end]
						incr outbicnt -2
						ForceVal .interp.4.e0 $outbicnt
					} else {
						Inf "Interpolation Failed Between '$fnam_0x' and '$fnam_1x'"
						set OK 0
						break
					}
					incr pair_cnt
					set jj [expr $pair_cnt * 2]

				}
				if {!$OK} {
					set finished 1
					break
				}
				if {$fail_cnt == $interp_num} {
					if {[info exists last_fnam0] && [info exists last_fnam1]} {
						set fnam0 $last_fnam0
						set fnam1 $last_fnam1
					} else {
						catch {unset fnam0}
						catch {unset fnam1}
					}
				}	
				if {[info exists skewfnam] && [file exists $skewfnam]} {
					if [catch {file delete $skewfnam} zit] {
						Inf "Cannot Delete Temporary File '$fnam'\n\nThis Will Prevent You From Making\nFurther Interpolations"
						set outcnt 0
						set finished 1
						break
					}
				}
				set intp_templist $total_intp_templist
			}
		}
	}
	if {[llength $interp_outlist] > 0} {

		set interp_outlist {}
		foreach fnam [.interp.3.ll.list get 0 end] {
			lappend interp_outlist $fnam
		}
		set origlist $interp_outlist
		set n 0
		while {$n < $interpsrccnt} {
			set k [lsearch $interp_outlist $interpsrc($n)]
			if {$k >= 0} {
				set interp_outlist [lreplace $interp_outlist $k $k]
			}
			incr n
		}
		set interp_outlist [ReverseList $interp_outlist]
		foreach fnam $interp_outlist {
			if {[FileToWkspace $fnam 0 0 0 0 1] <= 0} {
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Delete Invalid File '$fnam'"
				}
			}
		}
		ClearAndSaveChoice
		set chpos -1
		foreach fnam $origlist {
			if {[file exists $fnam] && ([LstIndx $fnam $wl] >= 0)} {
				lappend chlist $fnam
				$ch insert end $fnam
				incr chcnt
			}
		}
		set interp_outlist [ReverseList $chlist]
		foreach fnam $interp_outlist {
			set k [LstIndx $fnam $wl]
			$wl delete $k
			$wl insert 0 $fnam

		}
	}
	set msg ""
	ClearTempFiles 0 $msg
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}


proc DeleteInterpFiles {unselected} {
	global interp_outlist interpsrc interpcnt wstk sl_real outbicnt interpsrccnt

	set del_cnt 0
	set ssrc_cnt 0
	if {!$sl_real} {
		if {$unselected} {
			Inf "Deletes All The Files Which Are Not Highlighted, In The Window Below"
		} else {
			Inf "Deletes All The Hioghlighted Files, In The Window Below"
		}
		return
	}

	set ilist [.interp.3.ll.list curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		Inf "No Files Selected"
		return
	}	
	if {$unselected} {
		set msg "Are You Sure You Want To DELETE ALL The Files Which Are\n\nNOT\n\nSELECTED ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set i 0
		foreach fnam [.interp.3.ll.list get 0 end] {
			set k [lsearch $ilist $i]
			if {$k < 0} {
				lappend nuilist $i
			}
			incr i
		}
		set ilist $nuilist
	} else {
		set msg "Are You Sure You Want To DELETE ALL The SELECTED Files ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	foreach i [lsort -integer -decreasing $ilist] {
		set fnam [.interp.3.ll.list get $i]
		set n 0
		set OK 1
		while {$n < $interpsrccnt} {
			if [string match $fnam $interpsrc($n)] {
				incr ssrc_cnt
				set OK 0
				break
			}
			incr n
		}
		if {!$OK} {
			continue
		}
		if [info exists interp_outlist] {
			set k [lsearch $interp_outlist $fnam]
			if {$k >= 0} {
				set interp_outlist [lreplace $interp_outlist $k $k]
			}
			incr del_cnt
		}
		if [catch {file delete $fnam} zit] {
			Inf "Cannot Delete File '$fnam'"
		}
		.interp.3.ll.list delete $i
		incr interpcnt -1
	}
	if {($del_cnt == 0) && ($ssrc_cnt > 0)} {
		Inf "You Cannot Delete The Original Source Files"
		return
	}
	set outbicnt [.interp.3.ll.list index end]
	incr outbicnt -2
	ForceVal .interp.4.e0 $outbicnt
}

proc DeleteLastInterpFiles {} {
	global interp_outlist intp_templist interpsrc interpsrccnt interpcnt intp_last_ilist wstk sl_real outbicnt

	if {!$sl_real} {
		Inf "The Interpolator Can Create One Set Of Interpolated Files,\nWhich It Lists In The Window Below,\nThen Create A Further Interpolated Set,\nInterpolating Between Two Adjacent Members\nOf The First Set Created (And So On).\nAt Each Stage, The Newly Created Files\nAre Added To The Listing In The Window.\n\nThis Button Allows You To Delete Solely\nThe Last Interpolations Made,\nRetaining Files Made In Previous Interpolations"
		return
	}	
	if {![info exists intp_templist]} {
		Inf "No Previous Interpolation Set Made"
		return
	}	
	set msg "Are You Sure You Want To DELETE ALL These Files ??"
	set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
	if {$choice == "no"} {
		return
	}
	set inital_cnt $interpcnt
	foreach fnam $intp_templist {
		set n 0
		set OK 1
		while {$n < $interpsrccnt} {
			if [string match $fnam $interpsrc($n)] {
				Inf "You Cannot Delete The Original Source File '$interpsrc($n)'"
				set OK 0
				break
			}
			incr n
		}
		if {!$OK} {
			continue
		}
		if [info exists interp_outlist] {
			set k [lsearch $interp_outlist $fnam]
			if {$k >= 0} {
				set interp_outlist [lreplace $interp_outlist $k $k]
			}
		}
		if [file exists $fnam] {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot Delete File '$fnam'"
			}
		}
		set i [LstIndx $fnam .interp.3.ll.list]
		if {$i >= 0} {
			.interp.3.ll.list delete $i
			incr interpcnt -1
		}
	}
	if {$interpcnt != $inital_cnt} {
		catch {unset intp_last_ilist}
	}
	set outbicnt [.interp.3.ll.list index end]
	incr outbicnt -2
	ForceVal .interp.4.e0 $outbicnt
}

proc TellDoInterp {} {
	Inf "The Interpolator Takes 2 (Highlighted) Adjacent Sounds In The Window Below\nAnd Creates The Specified Number Of Intermediate Files\nBy A Process Of Weighted Mixing (CDP Process 'submix inbetween')\n\nThe Process Can Be Repeated On Any 2 Adjacent Files\nIn The Resulting List (And So On)"
	return
}

proc TellDoInterpMulti {} {
	Inf "The Interpolator Takes Several (Highlighted) Adjacent Sounds In The Window Below\nAnd Creates The Specified Number Of Intermediate Files\nBy A Process Of Weighted Mixing (CDP Process 'submix inbetween')\n\nThe Process Can Be Repeated On Any 2 Adjacent Files\nIn The Resulting List (And So On)"
	return
}

proc TellInterpPlaySelected {} {
	Inf "Play, In Sequence, The Highlighted Files In The Window Below"
	return
}

proc TellInterpPlayAll {} {
	Inf "Play, In Sequence, All Files In The Window Below"
	return
}

proc TellInterpPlayLastMade {} {
	Inf "Play, In Sequence, The Last Set Of Interpolated Files Made"
	return
}

proc TellInterpPlayNotSel {} {
	Inf "Play, In Sequence, The Files In The Window Below Which Are Not Highlighted"
	return
}

#-------- Tempo-beat-calculator

proc ClikCalculator {} {
	global pr_clik clikstart clikbars clikbeats clikmm clikdenom cliknum clikout evv readonlyfg readonlybg oclcnt

	set oclcnt 0
	set f .klik
	if [Dlg_Create $f "TIME AND TEMPO CALCULATOR" "set pr_clik 0" -width 40 -borderwidth $evv(SBDR)] {
		frame $f.00 -bd $evv(SBDR)
		frame $f.001 -bg $evv(POINT) -height 1
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.11 -bg $evv(POINT) -height 1
		frame $f.2 -bd $evv(SBDR)
		frame $f.21  -bg $evv(POINT) -height 1
		frame $f.3 -bd $evv(SBDR)
		frame $f.3.a -bd $evv(SBDR)
		frame $f.31 -bg $evv(POINT) -height 1
		frame $f.4 -bd $evv(SBDR)
		frame $f.41 -bg $evv(POINT) -height 1
		frame $f.5 -bd $evv(SBDR)
		frame $f.51 -bg $evv(POINT) -height 1
		frame $f.6 -bd $evv(SBDR)
		label $f.0.t -text "START TIME"
		frame $f.7 -bd $evv(SBDR)
		button $f.00.calc -text "Add Bars" -width 14 -command {DoClickCalc 0} -highlightbackground [option get . background {}]
		button $f.00.calc2 -text "Add Crotchets" -width 14 -command {DoClickCalc 1} -highlightbackground [option get . background {}]
		button $f.00.quit -text "Close" -width 4 -command {set pr_clik 1} -highlightbackground [option get . background {}]
		entry $f.0.e -textvariable clikstart -width 12
		label $f.1.t -text "+" -font {times 32 bold}
		label $f.2.t -text "BAR COUNT  "
		label $f.2.t2 -text "CROTCHETS"
		entry $f.2.e -textvariable clikbars -width 11
		entry $f.2.e2 -textvariable clikbeats -width 11
		label $f.3.a.t -text "MM = "
		entry $f.3.a.e -textvariable clikmm -width 12
		label $f.4.t -text "METER\nuse -> or <- keys"
		entry $f.4.e1 -textvariable cliknum -width 3
		entry $f.4.e2 -textvariable clikdenom -width 3 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f.5.t -text "=" -font {times 32 bold}
		entry $f.6.e -textvariable clikout -width 16 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		button $f.6.b -text "Use as\nStart Time" -command ClickRecycle -highlightbackground [option get . background {}]
		entry $f.7.e -textvariable clikerr -width 80 -bd 0 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg

		pack $f.00.calc $f.00.calc2 -side left -padx 2
		pack $f.00.quit -side right
		pack $f.0.t $f.0.e -side top
		pack $f.1.t -side top
		pack $f.3.a.t $f.3.a.e -side left
		pack $f.3.a -side top
		pack $f.2.e $f.2.t -side left -fill x
		pack $f.2.e2 $f.2.t2 -side right -fill x
		pack $f.4.e1 $f.4.e2 $f.4.t -side left -fill x
		pack $f.5.t -side top
		pack $f.6.e $f.6.b -pady 2 -side top
		pack $f.7.e -side top
		pack $f.00 $f.001 $f.0 $f.1 $f.11 $f.3 $f.31 $f.2 $f.21 $f.4 $f.41 $f.5 $f.51 $f.6 $f.7 -side top -fill x -expand true

		bind $f <Left> {ScrollMeter 0}
		bind $f <Right> {ScrollMeter 1}

		bind $f.0.e <Up> {focus .klik.4.e1}
		bind $f.0.e <Down> {focus .klik.3.a.e}
		bind $f.3.a.e <Up> {focus .klik.0.e}
		bind $f.3.a.e <Down> {focus .klik.2.e}
		bind $f.2.e <Up> {focus .klik.3.a.e}
		bind $f.2.e <Down> {focus .klik.2.e2}
		bind $f.2.e2 <Up> {focus .klik.2.e}
		bind $f.2.e2 <Down> {focus .klik.4.e1}
		bind $f.4.e1 <Up> {focus .klik.2.e2}
		bind $f.4.e1 <Down> {focus .klik.0.e}
		bind <Escape> $f {set pr_clik 0}
	}
	wm resizable $f 1 1
	$f.7.e config -background [option get . background {}]
	ForceVal $f.4.e2 4
	set pr_clik 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_clik $f.0.e
	tkwait variable pr_clik
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc ScrollMeter {up} {
	global clikdenom
	if {$up} {
		set nuval $clikdenom
		set nuval [expr $nuval * 2]
		if {$nuval > 32} {
			set nuval 2
		}
		ForceVal .klik.4.e2 $nuval
	} else {
		set nuval $clikdenom
		set nuval [expr $nuval / 2]
		if {$nuval < 2} {
			set nuval 32
		}
		ForceVal .klik.4.e2 $nuval
	}
}
proc DoClickCalc {beats} {
	global clikstart clikbars clikbeats clikmm clikdenom cliknum clikout evv

	.klik.7.e config -readonlybackground [option get . background {}]
	set clikerr ""
	ForceVal .klik.7.e $clikerr
	set clikout ""
	ForceVal .klik.6.e $clikout
	if {![info exists clikstart] || ![IsNumeric $clikstart]} {
		set clikerr "Invalid Entry for START TIME"
		ForceVal .klik.7.e $clikerr
		.klik.7.e config -readonlybackground $evv(EMPH)
		return
	}
	if {![info exists clikmm] || ![IsNumeric $clikmm]} {
		set clikerr "Invalid Entry for METRONOME MARK"
		ForceVal .klik.7.e $clikerr
		.klik.7.e config -readonlybackground $evv(EMPH)
		return
	}
	if {$beats} {
		if {![info exists clikbeats] || ![IsPositiveNumber $clikbeats]} {
			set clikerr "Invalid Entry for CROTCHETS"
			ForceVal .klik.7.e $clikerr
			.klik.7.e config -readonlybackground $evv(EMPH)
			return
		}
		set beatcount $clikbeats
	} else {
		if {![info exists clikbars] || ![regexp {^[0-9]+$} $clikbars]} {
			set clikerr "Invalid Entry for BAR COUNT"
			ForceVal .klik.7.e $clikerr
			.klik.7.e config -readonlybackground $evv(EMPH)
			return
		}
		if {![info exists cliknum] || ![regexp {^[0-9]+$} $cliknum]} {
			set clikerr "Invalid Entry for METER NUMERATOR"
			ForceVal .klik.7.e $clikerr
			.klik.7.e config -readonlybackground $evv(EMPH)
			return
		}
		if {![info exists clikdenom] || ![regexp {^[0-9]+$} $clikdenom]} {
			set clikerr "Invalid Entry for METER DENOMINATOR"
			ForceVal .klik.7.e $clikerr
			.klik.7.e config -readonlybackground $evv(EMPH)
			return
		}
		set beatcount [expr $clikbars * $cliknum]
		set beatcount [expr (double($beatcount) * 4.0)/double($clikdenom)]
	}
	set time [expr $clikstart + ($beatcount * 60.0 / double($clikmm))]
	set time [DisplayToDecPlace $time 5]
	ForceVal .klik.6.e $time
	return
}

proc ClickRecycle {} {
	global clikout clikstart
	if {[info exists clikout] && ([string length $clikout] > 0)} {
		set clikstart $clikout
	}
}

#----- Allow files to be partitioned among lists

proc PartitionPlay {flist} {
	global ppr4 part_pll lastpplay ppart last_played play_partition_fname wstk do_parse_report wl evv
	global play_partition_gen_fname partiname dupl_mix dupl_vbx dupl_txt pll_selectt partmsg partstart shortwindows

	if {$dupl_mix || $dupl_vbx || $dupl_txt} {
		Inf "Duplicate Files On Chosen Files List: Cannot Proceed"
		return
	}
	if [GappedNameWarning $flist] {
		set msg "Some Filenames (or Directory Names) Contain Spaces\n\n"
		append msg "A List Of Soundfiles Containing Such Names\n"
		append msg "Will Not Be Recognised As A Soundfile Listing\n"
		append msg "By The Soundloom\n"
		WarningShow $msg
	}
	DeleteAllTemporaryFiles
	catch {unset partiname}
	catch {unset pll_selectt}
	set f .pplaylist
	if [Dlg_Create $f "PARTITION SOUNDS AMONG SOUNDLISTS" "set ppr4 0" -borderwidth $evv(BBDR)] {
		set aa 	   [frame $f.button0  -borderwidth $evv(SBDR)]
		set mm 	   [frame $f.buttonm  -borderwidth $evv(SBDR)]
		set bb 	   [frame $f.button1 -borderwidth $evv(SBDR)]
		set cc 	   [frame $f.button2 -borderwidth $evv(SBDR)]
		set dd 	   [frame $f.button3  -borderwidth $evv(SBDR)]
		set ee 	   [frame $f.button4 -borderwidth $evv(SBDR)]
		set ff 	   [frame $f.button5 -borderwidth $evv(SBDR)]
		frame $f.button6 -height 1 -bg $evv(POINT)
		set gg 	   [frame $f.button7 -borderwidth $evv(SBDR)]
		set hh 	   [frame $f.button9 -borderwidth $evv(SBDR)]
		set ii	   [frame $f.play -borderwidth $evv(SBDR)]
		button $aa.keep -text "Keep Partitions So Far" -command "set ppart 0; set ppr4 1" -highlightbackground [option get . background {}]
		button $aa.l1 -text "Set Generic Name for (remainder of) Partitions" -command "SetPartitionGenName" -highlightbackground [option get . background {}]
		label $aa.l2 -text "Generic Name  "
		entry $aa.e -textvariable play_partition_gen_fname -width 20
		button $aa.a -text "A" -bd 4 -command "PlaySndfile $evv(TESTFILE_A) 0" -width 2 -bg $evv(HELP) -highlightbackground [option get . background {}]
		button $aa.quit -text "Abandon Partitions" -command "set ppart 0; set ppr4 0" -highlightbackground [option get . background {}]
		pack $aa.keep $aa.l1 $aa.l2 $aa.e -side left -padx 2
		pack $aa.quit -side right -padx 1
		entry $mm.msg -textvariable partmsg -width 64
		pack $mm.msg -side top
		set n 1
		while {$n <= 10} {
			radiobutton $bb.r$n -variable ppart -text $n -value $n -command "PartitionPlayFile $n"
			pack $bb.r$n -side left -fill x -expand true
			incr n
		}
		while {$n <= 20} {
			radiobutton $cc.r$n -variable ppart -text $n -value $n -command "PartitionPlayFile $n"
			pack $cc.r$n -side left -fill x -expand true
			incr n
		}
		label $dd.sele -text "PRESS A PARTITION BUTTON ABOVE, TO DO THE ACTION SET BELOW"
		pack $dd.sele -side top -pady 2
		button $ee.get -text "Last File Played to Partition" -command "PartitionReconfig get" -width 29 -highlightbackground [option get . background {}]
		button $ee.see -text "See All Files in Partition" -command "PartitionReconfig see" -width 26 -highlightbackground [option get . background {}]
		button $ee.nam -text "(re)Name Partition" -command "PartitionReconfig name" -width 22 -highlightbackground [option get . background {}]
		button $ee.edi -text "Edit The Partition" -command "PartitionReconfig edit" -width 20 -highlightbackground [option get . background {}]
		button $ee.del -text "Delete The Partition" -command "PartitionReconfig delete" -width 20 -highlightbackground [option get . background {}]
		pack $ee.get $ee.see $ee.nam $ee.edi $ee.del -side left -padx 2 -pady 2
		button $ff.pla -text "Play Next" -command "PartitionPlayNext" -width 12  -highlightbackground [option get . background {}];# -bg $evv(EMPH)
		button $ff.pl2 -text "Play Again" -command "PartitionPlayAgain" -width 12  -highlightbackground [option get . background {}];# -bg $evv(EMPH)
		button $ff.pl3 -text "Play First" -command "PartitionPlayFirst" -width 12  -highlightbackground [option get . background {}];# -bg $evv(EMPH)
		button $ff.sel -text "Select Partition to List" -command "PartitionReconfig select" -width 25 -highlightbackground [option get . background {}]
		button $ff.cle -text "Clear Selection List" -command "ClearPartitionSelection" -width 25 -highlightbackground [option get . background {}]
		button $ff.mer -text "Merge Selected Partitions" -command "PartitionReconfig merge" -width 25 -highlightbackground [option get . background {}]
		pack $ff.pla $ff.pl2 $ff.pl3 -side left -padx 2
		pack $ff.mer $ff.cle $ff.sel -side right -padx 2 -pady 2
		button $gg.l0 -text "See All Partition Names" -command "SetAllPartitionNames" -highlightbackground [option get . background {}]
		button $gg.a -text "A" -bd 4 -command "PlaySndfile $evv(TESTFILE_A) 0" -width 2 -bg $evv(HELP) -highlightbackground [option get . background {}]
		pack $gg.l0 -side left -padx 3
		pack $gg.a -side right -padx 2
		label $hh.click -text "CLICK ON A SOUNDFILE TO PLAY IT"
		pack $hh.click -side left -padx 10
		if {[info exists shortwindows]} {
			set part_pll [Scrolled_Listbox $ii.playlist -width 76 -height 12 -selectmode single]
		} else {
			set part_pll [Scrolled_Listbox $ii.playlist -width 76 -height 24 -selectmode single]
		}
		pack $ii.playlist -side top -fill both -expand true
		pack $f.button0 -side top -fill x
		pack $f.buttonm -side top -fill x
		pack $f.button1 -side top -fill x -expand true
		pack $f.button2 -side top -fill x -expand true
		pack $f.button3 -side top -fill x
		pack $f.button4 -side top
		pack $f.button5 -side top -pady 2 -fill x -expand true
		pack $f.button6 -side top -fill x -expand true -pady 3
		pack $f.button7 -side top -fill x -expand true
		pack $f.button9 -side top -pady 2
		pack $f.play -side top -fill x
		bind $part_pll <ButtonRelease> {ClearMsgAndPlayPartitionFile}
		bind $f <Escape> {set set ppr4 0}
		bind $f <Return> {set set ppr4 1}
	}
	set partstart 1
	set partmsg ""
	.pplaylist.buttonm.msg config -background [option get . background {}]
	catch {unset last_played}
	PartitionReconfig get
	set ppart 0
	set play_partition_gen_fname ""
	wm resizable $f 1 1
	$part_pll delete 0 end
	if {![info exists lastpplay]} {
		set setsel 0
	} else {
		set setsel 1
	}
	set i 0
	foreach fnam $flist {
		$part_pll insert end $fnam
		if {$setsel && [string match $lastpplay $fnam]} {
			set iii $i
			set setsel 0
		}
		incr i
	}
	if {[info exists iii]} {
		$part_pll selection set $iii
		$part_pll yview moveto [expr double($iii)/double($i)]
	} else {
		$part_pll selection set 0
	}
	set ppr4 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f ppr4 $f.play.playlist
	while {!$finished} {
		tkwait variable ppr4
		switch -- $ppr4 {
			1 {
				catch {unset made}
				set n 1
				set thisext [GetTextfileExtension sndlist]
				while {$n <= 20} {
					set fnam $evv(DFLT_OUTNAME)
					append fnam $n $thisext
					if {[file exists $fnam]} {
						lappend made $n
					}
					incr n
				}
				if {[info exists made]} {
					set OK 1
					set msg "Partitions Exist That Have Not Been Named: These Will Not Be Saved: Proceed Anyway ?"
					if {[info exists partiname]} {
						catch {unset named}
						foreach n [array names partiname] {
							lappend named $n
						}
						set OK 1
						if {[info exists made]} {
							foreach n $made {
								if {[lsearch $named $n] < 0} {
									set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
									if {$choice == "no"} {
										set OK 0
										Inf "Choose A Generic Name For The Remaining Partitions, Or Name Them Individually"
									} 
									break
								}
							}
						}
					} else {
						set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							set OK 0
							Inf "Choose A Generic Name For The Remaining Partitions, Or Name Them Individually"
						} 
					}
					if {!$OK} {
						continue
					}
					Block "Completing Partitioning"
					set fnam $evv(DFLT_OUTNAME)
					set thisext [GetTextfileExtension sndlist]
					CompletePartinames $fnam $thisext
					UnBlock
				}
				break
			} 
			0 {
				set msg "Abandon Partitions ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set finished 1
			}
			2 {
				set msg "Finished Partitioning ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	if {[info exists last_played]} {
		set lastpplay $last_played
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc HelpPartition {} {

	set msg "Partition Sounds\n"
	append msg "\n"
	append msg "Place each sound in one of a number of categories.\n"
	append msg "\n"
	append msg "These categories may be anything you desire\n"
	append msg "e.g. \"short\", \"ornamented\", \"in Cmajor\" etc.\n"
	append msg "\n"
	append msg "The resulting soundlists will be stored in textfiles\n"
	append msg "known as \"orchestra files\" with extension \".orc\".\n"
	append msg "\n"
	append msg "Make your sound partitions before naming then.\n"
	append msg "\n"
	append msg "Proceed as follows ...\n"
	append msg "\n"
	append msg "(1)  Select (hence Play) by Clicking on sound in list.\n"
	append msg "\n"
	append msg "You can play the file again (use \"Play Again\")\n"
	append msg "or play the next file in list (use \"Play Next\")\n"
	append msg "or start at top of list with \"Play First\".\n"
	append msg "\n"
	append msg "(2)  After listening, select partition to put sound in\n"
	append msg "by clicking on a number-button in panel at top.\n"
	append msg "\n"
	append msg "You can choose NOT to put a file in any partition.\n"
	append msg "\n"
	append msg "(3)  After select/partition of all files you want to\n"
	append msg "\n"
	append msg "Either\n"
	append msg "\n"
	append msg "(A) Set a Name for each partition.\n"
	append msg "\n"
	append msg "(a)  Press the \"(re)Name the Partition\" button.\n"
	append msg "(b)  Select partition to name : click a partition number.\n"
	append msg "(c)  Sounds in partition are displayed in a new window.\n"
	append msg "(d)  Enter name from this new window, (saving it).\n"
	append msg "\"myname\" will become file \"myname.orc\".\n"
	append msg "(e)  Proceed to select another partition to name ..\n"
	append msg "\n"
	append msg "Or\n"
	append msg "\n"
	append msg "(A) Set a Generic Name for the partitions.\n"
	append msg "\n"
	append msg "On the Top page\n"
	append msg "(a)  Write (generic) name in box at top (e.g. \"myname\").\n"
	append msg "(b)  Press \"Select Generic Name\" button.\n"
	append msg "(c)  Output files named \"myname1.orc\" (for partition 1),\n"
	append msg "\"myname4.orc\" (for partition 4) and so on.\n"
	append msg "\n"
	Inf $msg
}

proc PartitionPlayFile {n} {
	global last_played ppart partiname partmsg evv

	if {![info exists last_played]} {
		Inf "No File Yet Played"
		set ppart 0
		return
	}
	set fnam $evv(DFLT_OUTNAME)
	append fnam $n [GetTextfileExtension sndlist]
	if {[file exists $fnam]} { 
		if [catch {open $fnam "r"} zit] {
			Inf "Cannot Open Temporary File '$fnam' To Append Further Sounds"
			set ppart 0
			return
		}
		while {[gets $zit item] >= 0} {
			lappend zlist $item
		}
		close $zit
		if {[lsearch $zlist $last_played] < 0} {
			lappend zlist $last_played 
		} else {
			Inf "File '$last_played' Is Already In This Partition"
			set ppart 0
			return
		}
	} else {
		set zlist [list $last_played]
	}
	if [catch {open $fnam "w"} zit] {
		Inf "Cannot Open Temporary File '$fnam' To Write Sounds"
		set ppart 0
		return
	}
	foreach item $zlist {
		puts $zit $item
	}
	if {[info exists partiname($n)]} {
		set nam '$partiname($n)'
	} else {
		set nam $n
	}
	set partmsg "$last_played PLACED IN PARTITION $nam"
	Inf "'$last_played' Placed In Partition '$nam'"
	close $zit
	set ppart 0
}

proc PartitionSeeFile {n} {
	global last_played wstk partiname evv

	if {[info exists partiname($n)] && [file exists $partiname($n)]} {
		if [catch {open $partiname($n) "r"} zit] {
			Inf "Cannot Open Existing File '$partiname($n)' To Read"
			set ppart 0
			return
		}
		while {[gets $zit item] >= 0} {
			lappend zlist $item
		}
		close $zit
	}
	set fnam $evv(DFLT_OUTNAME)
	append fnam $n [GetTextfileExtension sndlist]
	if {![file exists $fnam] && ![info exists zlist]} { 
		Inf "There Are No Sounds In This Partition"
		set ppart 0
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open Temporary File '$fnam' To Read"
		set ppart 0
		return
	}
	while {[gets $zit item] >= 0} {
		if {[info exists zlist] && ([lsearch $zlist $item] >= 0)} {
			continue
		}
		lappend zlist $item
	}
	close $zit
	if {[info exists zlist]} {
		set cnt 1
		set msg "Files In Partition $n\n[lindex $zlist 0]"
		foreach item [lrange $zlist 1 end] {
			incr cnt
			if {$cnt > 60} {
				append msg "    And More"
				break
			}
			append msg "    " $item
			if {[expr $cnt % 2] == 0} {
				append msg "\n"
			}
		}
	} else {
		set msg "No Files Found"
	}
	Inf $msg
	set msg "See Files In Other Partitions ?"
	set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
	if [string match no $choice] {
		catch {unset last_played}
		PartitionReconfig get
	}
	set ppart 0
}

#----- Allow files to be partitioned among lists

proc SwapPartitionPlay {} {
	global ppr44 partswap_pll1 partswap_pll2 pa playcnt wl chlist wstk rememd do_parse_report evv dupl_mix

	if {$dupl_mix} {
		Inf "Duplicate Files On Chosen Files List: Cannot Proceed"
		return
	}
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] <= 0)} {
		if {[info exists chlist]} {
			foreach item $chlist {
				set k [LstIndx $item $wl]
				if {$k >= 0} {
					lappend klist $k
				}
			}
			if {[info exists klist]} {
				$wl selection clear 0 end
				foreach i $klist {
					$wl selection set $i
				}
				set ilist [$wl curselection]
			}
		}
	}
	if {![info exists ilist] || ([llength $ilist] != 2)} {
		Inf "Choose Two Textfiles Which List Soundfiles"
		return
	}
	set fnam1 [$wl get [lindex $ilist 0]]
	set fnam2 [$wl get [lindex $ilist 1]]
	if {![info exists pa($fnam1,$evv(FTYP))] || ![IsASndlist $pa($fnam1,$evv(FTYP))]} {
		Inf "File '$fnam1' Is Not A List Of Soundfiles"
		return
	}
	if {![info exists pa($fnam2,$evv(FTYP))] || ![IsASndlist $pa($fnam2,$evv(FTYP))]} {
		Inf "File '$fnam2' Is Not A List Of Soundfiles"
		return
	}
	if [catch {open $fnam1 "r"} zit] {
		Inf "Cannot Open File '$fnam1'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			lappend list1 $line
		}
	}
	close $zit
	if [catch {open $fnam2 "r"} zit] {
		Inf "Cannot Open File '$fnam2'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] > 0} {
			lappend list2 $line
		}
	}
	close $zit
	set playcnt 0
	set f .partswap
	if [Dlg_Create $f "PLAY AND SWAP SOUNDFILES" "set ppr44 1" -borderwidth $evv(BBDR)] {
		set f1		[frame $f.1  -borderwidth $evv(SBDR)]	
		set f2		[frame $f.2  -borderwidth $evv(SBDR)]	
		set f21		[frame $f2.1  -borderwidth $evv(SBDR)]	
		set f22		[frame $f2.2  -borderwidth $evv(SBDR)]	
		set f211	[frame $f21.1  -borderwidth $evv(SBDR)]	
		set f212	[frame $f21.2  -borderwidth $evv(SBDR)]	
		set f213	[frame $f21.3  -borderwidth $evv(SBDR)]	
		set f221	[frame $f22.1  -borderwidth $evv(SBDR)]	
		set f222	[frame $f22.2  -borderwidth $evv(SBDR)]	
		set f223	[frame $f22.3  -borderwidth $evv(SBDR)]	
		button $f1.keep -text "Save New Lists" -command "set ppr44 1" -width 14 -highlightbackground [option get . background {}]
		button $f1.a -text "A" -bd 4 -command "PlaySndfile $evv(TESTFILE_A) 0" -width 2  -highlightbackground [option get . background {}] ;# -bg $evv(HELP)
		label $f1.dummy -text "        "
		button $f1.quit -text "Keep Orig Lists" -command "set ppr44 0" -width 14 -highlightbackground [option get . background {}]
		pack $f1.keep $f1.dummy $f1.a -side left
		pack $f1.quit -side right
		label $f212.ll -text ""
		pack $f212.ll -side top
		set partswap_pll1 [Scrolled_Listbox $f213.playlist -width 64 -height 36 -selectmode single]
		button $f211.play -text "Play Snd"    -command "PlaySelectedSndfile $partswap_pll1" -width 10 -highlightbackground [option get . background {}]
		button $f211.move -text "To Other List"    -command "PartSwap 1" -width 12 -highlightbackground [option get . background {}]
		label $f222.ll -text ""
		pack $f222.ll -side top
		set partswap_pll2 [Scrolled_Listbox $f223.playlist -width 64 -height 36 -selectmode single]
		button $f221.play -text "Play Snd"    -command "PlaySelectedSndfile $partswap_pll2" -width 10 -highlightbackground [option get . background {}]
		button $f221.move -text "To Other List"    -command "PartSwap 0" -width 12 -highlightbackground [option get . background {}]
		pack $f211.play $f211.move -side left -padx 6
		pack $f221.move $f221.play -side right -padx 6
		pack $f213.playlist -side top -fil both -expand true
		pack $f223.playlist -side top -fil both -expand true
		pack $f211 $f212 $f213 -side top -fill x -expand true
		pack $f221 $f222 $f223 -side top -fill x -expand true
		pack $f21 $f22 -side left -fill both -expand true
		pack $f1 $f2 -side top -fill x -expand true
		bind $f <Escape> {set ppr44 0}
		bind $f <Return> {set ppr44 1}
	}
	$f.2.1.2.ll config -text $fnam1
	$f.2.2.2.ll config -text $fnam2
	wm resizable $f 1 1
	$partswap_pll1 delete 0 end
	$partswap_pll2 delete 0 end
	foreach fnam $list1 {
		$partswap_pll1 insert end $fnam
	}
	foreach fnam $list2 {
		$partswap_pll2 insert end $fnam
	}
	set ppr44 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f ppr44 $partswap_pll1

	while {!$finished} {
		tkwait variable ppr44
		if {$ppr44 > 0} {
			set rename1_OK 1
			set rename2_OK 1
			set nufnam1 $evv(DFLT_OUTNAME)
			set thisext [GetTextfileExtension sndlist]
			append nufnam1 1 $thisext
			set nufnam2 $evv(DFLT_OUTNAME)
			append nufnam2 2 $thisext
			if [catch {open $nufnam1 "w"} zit] {
				Inf "Cannot Open 1st File To Write New Data"
				continue
			}
			foreach fnam [$partswap_pll1 get 0 end] {
				puts $zit $fnam	
			}
			close $zit
			if [catch {open $nufnam2 "w"} zit] {
				Inf "Cannot Open 2nd File To Write New Data"
				DeleteAllTemporaryFiles
				continue
			}
			foreach fnam [$partswap_pll2 get 0 end] {
				puts $zit $fnam
			}
			close $zit
			if [catch {file delete $fnam1} zit] {
				Inf "Cannot Remove Original 1st File, In Order To Store New Data"
				DeleteAllTemporaryFiles
				break
			}
			UpdateBakupLog $fnam1 delete 1
			if [catch {file rename $nufnam1 $fnam1} zit] {
				set rename1_OK 0
			}
			if [catch {file delete $fnam2} zit] {
				set rename2_OK 0
				set msg ""
				if {!$rename1_OK} {
					set msg "Cannot Rename The File '$nufnam1' to '$fnam1'\nAfter You Quit This Page\nRename This File Outside The CDP, Before Proceeding.\n\n"
				}
				append msg "Cannot Remove Original 2nd File, In Order To Store New Data\n\nYour New Data Is In '$nufnam2'\n\nAfter You Quit This Page\n\nRename '$nufnam2' to '$fnam2' Outside The CDP, Before Proceeding"
				catch {unset rememd}
				Inf $msg
				break
			}
			UpdateBakupLog $fnam2 delete 1
			if [catch {file rename $nufnam2 $fnam2} zit] {
				set rename2_OK 0
				set msg ""
				if {!$rename1_OK} {
					set msg "Cannot Rename The File '$nufnam1' to '$fnam1'\nAfter You Quit This Page\nRename This File Outside The CDP, Before Proceeding.\n\n"
				}
				Inf "Cannot Rename The File '$nufnam2' TO '$fnam2'\n\nAfter You Quit This Page\nRename '$nufnam2' To '$fnam2' Outside The CDP, Before Proceeding"
				catch {unset rememd}
			}
			if {$rename1_OK} {
				UpdateBakupLog $fnam1 create 1
				catch {file delete $nufnam1}
				set i [LstIndx $fnam1 $wl]
				set do_parse_report 1
				if {[DoParse $fnam1 $wl 0 0] <= 0} {
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] \
						-message "Spurious File '$fnam1' On Workspace: Delete It ?"]
					if {$choice == "yes"} {
						if [catch {file delete $fnam1} xx] {
							Inf "$xx\nCannot Remove File '$fnam1' : Ignoring It"
						} else {
							DummyHistory $fnam1 "DESTROYED"
							RemoveAllRefsToFile $fnam1 $i
						}
					}
				}
			}
			if {$rename2_OK} {
				UpdateBakupLog $fnam2 create 1
				catch {file delete $nufnam2}
				set i [LstIndx $fnam2 $wl]
				set do_parse_report 1
				if {[DoParse $fnam2 $wl 0 0] <= 0} {
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] \
						-message "Spurious File '$fnam2' On Workspace: Delete It ?"]
					if {$choice == "yes"} {
						if [catch {file delete $fnam2} xx] {
							Inf "$xx\nCannot Remove File '$fnam2' : Ignoring It"
						} else {
							DummyHistory $fnam2 "DESTROYED"
							RemoveAllRefsToFile $fnam2 $i
						}
					}
				}
			}
			break
		} else {
			DeleteAllTemporaryFiles
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc PartSwap {typ} {
	global partswap_pll1 partswap_pll2
	switch -- $typ {
		1 {
			set fromlisting $partswap_pll1
			set tolisting $partswap_pll2
		} 
		0 {
			set fromlisting $partswap_pll2
			set tolisting $partswap_pll1
		} 
	}
	set i [$fromlisting curselection]
	if {![info exists i] || ($i < 0)} {
		Inf "No Sound Selected"
		return
	}
	set fnam [$fromlisting get $i]
	$fromlisting delete $i
	$tolisting insert 0 $fnam
}

proc Booze {} {
	global pr_booze tipple evv

	set evv(DR_OUTDUR)	0
	set evv(DR_LOCUS)	1
	set evv(DR_AMBITUS)	2
	set evv(DR_STEP)	3
	set evv(DR_TICK)	4
	set evv(DR_CLKRND)	6

	set f .booze
	if [Dlg_Create $f "LOCUS OPTIONS" "set pr_booze 0" -width 60 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		frame $f.5 -bd $evv(SBDR)
		frame $f.6 -bd $evv(SBDR)
		frame $f.7 -bd $evv(SBDR)
		frame $f.8 -bd $evv(SBDR)
		button $f.0.q -text "Close" -command "set pr_booze 0" -highlightbackground [option get . background {}]
		pack $f.0.q -side top
		radiobutton $f.1.0 -variable tipple -text "Locus Reads Through Source At Given Rate"  -value 1 -command "SpeedLocus"
		radiobutton $f.2.0 -variable tipple -text "Locus Hops Forward To Fixed Places At Regular Times" -value 0 -command "TimeHopper"
		radiobutton $f.3.0 -variable tipple -text "Locus Hops To Fixed Places At Random"  -value 2 -command "RandomLocus"
		radiobutton $f.4.0 -variable tipple -text "Fixed Locus, Growing Or Shrinking Ambitus"  -value 3 -command "GrowingAmbitus"
		radiobutton $f.5.0 -variable tipple -text "Hopping Locus, Growing Or Shrinking Ambitus"  -value 4 -command "HopGrowingAmbitus"
		radiobutton $f.6.0 -variable tipple -text "Random Stepping Locus, Growing Or Shrinking Ambitus"  -value 5 -command "RandGrowingAmbitus"
		radiobutton $f.7.0 -variable tipple -text "Step Size Grows Or Shrinks With Ambitus"  -value 6 -command "StepToAmbitus"
		radiobutton $f.8.0 -variable tipple -text "Reads From Random Places At Each Clock Tick"  -value 7 -command "RandomRead"
		pack $f.1.0 -side left
		pack $f.2.0 -side left
		pack $f.3.0 -side left
		pack $f.4.0 -side left
		pack $f.5.0 -side left
		pack $f.6.0 -side left
		pack $f.7.0 -side left
		pack $f.8.0 -side left
		pack $f.0 $f.1 $f.2 $f.3 $f.4 $f.5 $f.6 $f.7 $f.8 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_booze 0}
	}
	set tipple -1
	set pr_booze 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_booze
	tkwait variable pr_booze
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc TimeHopper {} {
	global rememd pr_hop pr_booze hopdatainfile hoptext hopoutfile hopoutfilename hopinfiledur hoptickh hopinfilename 
	global wstk chlist wl pa prm tipple evv readonlyfg readonlybg
	global hp_lastgo

	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set hopinfilename [lindex $chlist 0]
	if {$pa($hopinfilename,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$hopinfilename' Is Not A Soundfile"
		return
	}
	set hopinfiledur $pa($hopinfilename,$evv(DUR))

	set f .thop
	if [Dlg_Create $f "STEP-ADVANCE LOCUS IN FILE" "set pr_hop 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.0aa -bd $evv(SBDR)
		frame $f.0a -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.2a -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		set hoptext [text $f.3.t -setgrid true -wrap word -width 76 -height 32 \
		-xscrollcommand "$f.3.sx set" -yscrollcommand "$f.3.sy set"]
		scrollbar $f.3.sy -orient vert  -command "$f.3.t yview"
		scrollbar $f.3.sx -orient horiz -command "$f.3.t xview"
		pack $f.3.t -side left -fill both -expand true
		pack $f.3.sy -side right -fill y
		button $f.0.ok -text "Finished" -command "set pr_hop 1" -highlightbackground [option get . background {}]
		label $f.0.ll -text "        Input Sound Duration    "
		entry $f.0.e -textvariable hopinfiledur -width 16 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		button $f.0.v -text "Sound View" -command "SnackDisplay $evv(SN_UNSORTED_TIMES) $hoptext $evv(TIME_OUT) 1" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_hop 0" -highlightbackground [option get . background {}]
		pack $f.0.ok $f.0.ll $f.0.e $f.0.v -side left
		pack $f.0.q -side right
		button $f.0aa.b -text "Restore Previous Values" -command RestoreTimeHop -highlightbackground [option get . background {}]
		pack $f.0aa.b -side top -pady 2
		label $f.0a.ll -text "LOCUS STEPPING TYPE"
		pack $f.0a.ll -side top
		radiobutton $f.1.sped -variable hopdatainfile \
			-text "DATA IS INPUTFILE POSITIONS: Step from position to position at speed given by Speed Multiplier" \
			-value 0 -command "HopSpeed 1 .thop.2a.z .thop.2.ll .thop.2.speed $hoptext"
		radiobutton $f.1.data -variable hopdatainfile \
			-text "DATA WILL BECOME POSITION-TIME PAIRS: Remain at each position for (associated) time given                     " \
			-value 1 -command "HopSpeed 0 .thop.2a.z .thop.2.ll .thop.2.speed $hoptext"
		pack $f.1.sped $f.1.data -side top -pady 2
		label $f.2.ll -text "" -width 16
		entry $f.2.speed -textvariable hoptickh -width 4 -bd 0 -state disabled -disabledbackground [option get . background {}]
		label $f.2.ll2 -text "Output Datafile Name"
		entry $f.2.fil -textvariable hopoutfilename -width 16
		pack $f.2.ll $f.2.speed $f.2.ll2 $f.2.fil -side left -padx 2
		pack $f.2.fil $f.2.ll2 -side right -padx 2
		button $f.2a.z -text "" -command "HopZero hoptext" -bd 0 -state disabled -width 16 -highlightbackground [option get . background {}]
		button $f.2a.c -text "Clear Display" -command "$hoptext delete 1.0 end" -width 16 -highlightbackground [option get . background {}]
		pack $f.2a.z $f.2a.c -side left -pady 2 -padx 4
		pack $f.0 $f.0a $f.0aa $f.1 $f.2 -side top -fill x -expand true -anchor w
		pack $f.2a -side top
		pack $f.3 -side top -fill x -expand true
		set hopoutfilename "locus"
		wm resizable $f 1 1
		bind $f <Escape> {set pr_hop 0}
	}
	.thop.2.ll config -text ""
	.thop.2.speed config -bd 0 -state disabled -disabledbackground [option get . background {}]
	set hoptickh ""
	ForceVal $f.2.speed $hoptickh
	$f.2a.z config -text "" -bd 0 -state disabled

	ForceVal $f.0.e $hopinfiledur
	$hoptext delete 1.0 end
	set hopdatainfile -1
	set pr_hop 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_hop
	while {!$finished} {
		tkwait variable pr_hop
		if {$pr_hop} {
			if {$hopdatainfile < 0} {
				Inf "No Locus Type Chosen"
				continue
			}
			set vals [$hoptext get 1.0 end]
			if {[llength $vals] <= 0} {
				Inf "No Data Has Been Entered"
				continue
			}
			if {([string length $hoptickh] <= 0) || ![IsNumeric $hoptickh] || ($hoptickh <= 0.0)} {
				if {$hopdatainfile} {
					Inf "Invalid Minimum Clocktick"
				} else {
					Inf "Invalid Speed Multiplier"
				}
				continue
			}
			set OK 1
			set sw 0
			set lastval -1.0
			set cnt 0
			foreach val $vals {
				if {![IsNumeric $val]} {
					Inf "Data Value '$val' Is Invalid"
					set OK 0
					break
				}
				if {$sw && $hopdatainfile} {
					if {$val <= $hoptickh} {
						Inf "Timestep ($val) Too Short"
						set OK 0
						break
					}
				} else {
					if {$val < 0.0 || $val >= $hopinfiledur} {
						Inf "Locus Position $val Is Not Inside Source File"
						set OK 0
						break
					}
					if {!$hopdatainfile && ($val <= $lastval)} {
						Inf "Locus Positions $lastval $val Do Not Advance Through File"
						set OK 0
						break
					}
				}
				set lastval $val
				set sw [expr !$sw]
				incr cnt
			}
			if {!$OK} {
				continue
			}
			if {[string length $hopoutfilename] <= 0} {
				Inf "No Datafile Name Entered"
				continue
			}
			if {![ValidCDPRootname $hopoutfilename]} {
				continue
			}
			set hopoutfile [string tolower $hopoutfilename]
			append hopoutfile [GetTextfileExtension brk]
			if {[file exists $hopoutfile]} {
				set msg "File '$hopoutfile' Already Exists: Overwrite It?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {![DeleteNonSndfileFromSystem $hopoutfile]} {
						continue
					}
				} else {
					continue
				}
			}	
			if [catch {open $hopoutfile "w"} zit] {
				Inf "Cannot Openfile '$hopoutfile' To Write Data"
				continue
			}
			catch {unset pairs}
			if {$hopdatainfile} {
				if {![IsEven $cnt]} {
					Inf "Data Not Correctly Paired For This Option"
					close $zit
					continue
				}
				set time 0.0
				set dur 0.0
				foreach {pos step} $vals {
					set dur [expr $dur + $step]
					set thispair [list $time $pos]
					lappend pairs $thispair
					set time [expr $time + $step]
					set subtime [expr $time - $evv(FLTERR)]
					set thispair [list $subtime $pos]
					lappend pairs $thispair
				}
				set thispair [list $time $pos]
				lappend pairs $thispair
				if {$time < $hopinfiledur} {
					set thispair [list $hopinfiledur $pos]
					lappend pairs $thispair
				}
			} else {
				set lastpos [lindex $vals 0]
				set time 0.0
				foreach pos [lrange $vals 1 end] {
					set thispair [list $time $lastpos]
					lappend pairs $thispair
					set step [expr $pos - $lastpos]
					set step [expr $step / $hoptickh]
					set time [expr $time + $step]
					set subtime [expr $time - $evv(FLTERR)]
					set thispair [list $subtime $lastpos]
					lappend pairs $thispair
					set lastpos $pos
				}
				set thispair [list $time $lastpos]
				lappend pairs $thispair
				if {$time < $hopinfiledur} {
					set time $hopinfiledur
				}
				set thispair [list $time $lastpos]
				lappend pairs $thispair
			}
			foreach pair $pairs {
				set line [lindex $pair 0]
				append line " " [lindex $pair 1]
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				continue
			}
			if {$hopdatainfile} {
				set prm($evv(DR_OUTDUR)) $dur
			} else {
				set prm($evv(DR_OUTDUR)) [expr $hopinfiledur / $hoptickh]
			}
			set prm($evv(DR_LOCUS)) $hopoutfile
			BakTimeHop
			set pr_booze 0
			break
		} else {
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Data File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
						DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			set tipple -1
			break
		}
	}		
	catch {unset hp_lastgo}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc HopSpeed {go v1 v2 v3 v4} {
	global prm evv hp_lastgo

	switch -- $go {
		1 {
			$v1 config -text "Insert Zero Value" -state normal -bd 2
			$v2 config -text "Speed Multiplier"
			$v3 config -bd 2 -state normal
			if {[info exists hp_lastgo] && ($hp_lastgo == 0)} {
				ForceVal $v3 ""
			}
		}
		0 {
			$v1 config -text "" -state disabled -bd 0
			$v2 config -text "Min Clockrate"
			$v3 config -bd 2 -state normal
			if {[IsNumeric $prm($evv(DR_TICK))] && [IsNumeric $prm($evv(DR_CLKRND))]} {
				set z [expr ($prm($evv(DR_CLKRND)) * $prm($evv(DR_TICK)) / 2.0)]
				ForceVal $v3 [expr $prm($evv(DR_TICK)) - $z]
			} elseif {[info exists hp_lastgo] && ($hp_lastgo == 1)} {
				ForceVal $v3 ""
			}
		}
	}
	set hp_lastgo $go
}

proc HopZero {listing} {
	global hoptext hoptextg hoptextr
	upvar $listing thislist
	$thislist insert 1.0 "0.0\n"
}

proc SpeedLocus {} {
	global pr_sploc hopinfiledur hopoutfilename hopoutfile hoptick splocstt splocend
	global prm chlist wl wstk pa rememd pr_booze tipple evv

	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set hopinfilename [lindex $chlist 0]
	if {$pa($hopinfilename,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$hopinfilename' Is Not A Soundfile"
		return
	}
	set hopinfiledur $pa($hopinfilename,$evv(DUR))

	set f .sploc
	if [Dlg_Create $f "LOCUS SPEED OF READING SOURCE" "set pr_sploc 0" -width 40 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		button $f.0.ok -text "Keep Data" -command "set pr_sploc 1" -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_sploc 0" -highlightbackground [option get . background {}]
		pack $f.0.ok -side left
		pack $f.0.q -side right
		label $f.1.ll -text "Speed of Reading   "
		entry $f.1.e -textvariable hoptick -width 12
		pack $f.1.ll $f.1.e -side left -padx 2
		label $f.2.ll -text "Start position of locus"
		entry $f.2.e -textvariable splocstt -width 12
		pack $f.2.ll $f.2.e -side left -padx 2
		label $f.3.ll -text "End position of locus"
		entry $f.3.e -textvariable splocend -width 12
		pack $f.3.ll $f.3.e -side left -padx 2
		label $f.4.ll -text "Datafile Name"
		entry $f.4.e -textvariable hopoutfilename -width 24
		pack $f.4.ll $f.4.e -side left -padx 2
		pack $f.0 -side top -pady 4 -fill x -expand true
		pack $f.1 $f.2 $f.3 $f.4 -side top -pady 4
		bind $f.1.e  <Up> {focus .sploc.4.e}
		bind $f.2.e  <Up> {focus .sploc.1.e}
		bind $f.3.e  <Up> {focus .sploc.2.e}
		bind $f.4.e  <Up> {focus .sploc.3.e}
		bind $f.1.e  <Down> {focus .sploc.2.e}
		bind $f.2.e  <Down> {focus .sploc.3.e}
		bind $f.3.e  <Down> {focus .sploc.4.e}
		bind $f.4.e  <Down> {focus .sploc.1.e}
		bind $f <Return> {set pr_sploc 1}
		bind $f <Escape> {set pr_sploc 0}
		wm resizable $f 1 1
	}
	set hopoutfilename ""
	set splocstt 0.0
	set splocend $pa($hopinfilename,$evv(DUR))
	set hoptick 1.0
	set pr_sploc 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_sploc $f.1.e
	while {!$finished} {
		tkwait variable pr_sploc
		if {$pr_sploc} {
			if {([string length $hoptick] <= 0) || ![IsNumeric $hoptick] || ($hoptick < 0.0)} {
				Inf "Invalid Speed"
				continue
			}
			if {([string length $splocstt] <= 0) || ![IsNumeric $splocstt] || ($splocstt < 0.0) || ($splocstt > $hopinfiledur)} {
				Inf "Invalid Locus Start Position"
				continue
			}
			if {([string length $splocend] <= 0) || ![IsNumeric $splocend] || ($splocend < 0.0) || ($splocend > $hopinfiledur)} {
				Inf "Invalid Locus End Position"
				continue
			}
			if {[Flteq $splocend $splocstt]} {
				Inf "Locus Cannot Start And End At The Same Point, In This Option"
				continue
			}
			if {![ValidCDPRootname $hopoutfilename]} {
				continue
			}
			set hopoutfile [string tolower $hopoutfilename]
			append hopoutfile [GetTextfileExtension brk]
			if {[file exists $hopoutfile]} {
				set msg "File '$hopoutfile' Already Exists: Overwrite It?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {![DeleteNonSndfileFromSystem $hopoutfile]} {
						continue
					}
				} else {
					continue
				}
			}	
			if [catch {open $hopoutfile "w"} zit] {
				Inf "Cannot Openfile '$hopoutfile' To Write Data"
				continue
			}
			set line "0.0 $splocstt"
			puts $zit $line
			set outdur [expr $splocend - $splocstt]
			if {$outdur < 0.0} {
				set outdur [expr -$outdur]
			}
			set endtime [expr $outdur / $hoptick]
			set line "$endtime   $splocend"
			puts $zit $line
			close $zit
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				continue
			}
			set prm($evv(DR_OUTDUR)) $endtime
			set prm($evv(DR_LOCUS)) $hopoutfile
			set pr_booze 0
			break
		} else {
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Data File $hopoutfile ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			set tipple -1
			break
		}
	}		
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc RandomLocus {} {
	global prm chlist wl wstk pa rememd pr_booze tipple hopperm evv
	global pr_hoprand hopsegcnt hoptimestep hoprand hopperm hopoutfilename hopoutfile hopinfiledur

	set outdur $prm($evv(DR_OUTDUR))
	if {![IsNumeric $outdur] || ($outdur <= 0.0)} {
		Inf "For This Option You Need To Specify An Outputfile Duration On The Parameters Page"
		set tipple -1
		return
	}
	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set fnam [lindex $chlist 0]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$fnam' Is Not A Soundfile"
		return
	}
	set hopinfiledur $pa($fnam,$evv(DUR))


	set f .hoprand
	if [Dlg_Create $f "LOCUS HOPS AT RANDOM" "set pr_hoprand 0" -width 40 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		button $f.0.ok -text "Keep Data" -command "set pr_hoprand 1" -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_hoprand 0" -highlightbackground [option get . background {}]
		pack $f.0.ok -side left
		pack $f.0.q -side right
		label $f.1.ll -text "Number of segments of source to hop randomly between"
		entry $f.1.e -textvariable hopsegcnt -width 8
		pack $f.1.ll $f.1.e -side left -padx 2
		label $f.2.ll -text "Average time between hops"
		entry $f.2.e -textvariable hoptimestep -width 8
		pack $f.2.ll $f.2.e -side left -padx 2
		label $f.3.ll -text "Randomisation of timesteps (0-1)"
		entry $f.3.e -textvariable hoprand -width 8
		pack $f.3.ll $f.3.e -side left -padx 2
		label $f.4.ll -text "Datafile Name"
		entry $f.4.e -textvariable hopoutfilename -width 24
		pack $f.4.ll $f.4.e -side left -padx 2
		pack $f.0 -side top -pady 4 -fill x -expand true
		pack $f.1 $f.2 $f.3 $f.4 -side top -pady 4
		bind $f.1.e  <Down> {focus .hoprand.2.e}
		bind $f.2.e  <Down> {focus .hoprand.3.e}
		bind $f.3.e  <Down> {focus .hoprand.4.e}
		bind $f.4.e  <Down> {focus .hoprand.1.e}
		bind $f.1.e  <Up> {focus .hoprand.4.e}
		bind $f.2.e  <Up> {focus .hoprand.1.e}
		bind $f.3.e  <Up> {focus .hoprand.2.e}
		bind $f.4.e  <Up> {focus .hoprand.3.e}
		bind $f <Return> {set pr_hoprand 1}
		bind $f <Escape> {set pr_hoprand 0}
		set hopsegcnt ""
		set hoptimestep ""
		set hoprand ""
		wm resizable $f 1 1
	}
	set hopoutfilename ""
	set pr_hoprand 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_hoprand $f.1.e
	while {!$finished} {
		tkwait variable pr_hoprand
		if {$pr_hoprand} {
			if {![regexp {^[0-9]+$} $hopsegcnt] || ($hopsegcnt < 1)} {
				Inf "Invalid Nuber Of Segments"
				continue
			}
			if {([string length $hoptimestep] <= 0) || ![IsNumeric $hoptimestep] || ($hoptimestep < 0.015)} {
				Inf "Invalid Time Between Hops"
				continue
			}
			if {([string length $hoprand] <= 0) || ![IsNumeric $hoprand] || ($hoprand < 0.0) || ($hoprand > 1.0)} {
				Inf "Invalid Randomisation Of Time Steps (Range 0-1)"
				continue
			}
			if {[string length $hopoutfilename] <= 0} {
				Inf "No Datafile Name Entered"
				continue
			}
			if {![ValidCDPRootname $hopoutfilename]} {
				continue
			}
			set hopoutfile [string tolower $hopoutfilename]
			append hopoutfile [GetTextfileExtension brk]
			if {[file exists $hopoutfile]} {
				set msg "File '$hopoutfile' Already Exists: Overwrite It?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {![DeleteNonSndfileFromSystem $hopoutfile]} {
						continue
					}
				} else {
					continue
				}
			}	
			if [catch {open $hopoutfile "w"} zit] {
				Inf "Cannot Openfile '$hopoutfile' To Write Data"
				continue
			}
			set maxloc [expr $hopinfiledur - 0.015]
			set seglen [expr $maxloc / $hopsegcnt]
			randperm $hopsegcnt
			set time 0.0
			set cnt 0
			catch {unset pairs}
			while {$time < $outdur} {
				set seg [lindex $hopperm $cnt]
				set baseval [expr $seg * $seglen]
				set val [expr rand() * $seglen]
				set pos [expr $val + $baseval]
				set thispair [list $time $pos]	
				lappend pairs $thispair
				if {$hoprand <= 0.0} {
					set time [expr $time + $hoptimestep]
				} else {
					set val [expr rand() * 2.0]
					set val [expr ($val - 1.0) / 2.0]
					set val [expr ($val * $hoprand) + 1.0]
					set val [expr $val * $hoptimestep]
					set time [expr $time + $val] 
				}
				incr cnt
				if {$cnt >= $hopsegcnt} {
					set lastpermval [lindex $hopperm end]
					while {1} {
						randperm $hopsegcnt
						if {[lindex $hopperm 0] != $lastpermval} {
							break
						}
					} 
					set cnt 0
				}
			}
			set seg [lindex $hopperm $cnt]
			set baseval [expr $seg * $seglen]
			set val [expr rand() * $seglen]
			set pos [expr $val + $baseval]
			set thispair [list $time $pos]	
			lappend pairs $thispair

			foreach pair $pairs {
				set line [lindex $pair 0]
				append line " " [lindex $pair 1]
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				continue
			}
			set prm($evv(DR_LOCUS)) $hopoutfile
			set pr_booze 0
			break
		} else {
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Data File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			set tipple -1
			break
		}
	}		
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc randperm {permlen} {
	global hopperm
	set hopperm {}
	set n 0
	set n_plus_1 1
	set endindex -1
	while {$n < $permlen} {
		set t [expr int(floor(rand() * $n_plus_1))]
		if {$t==$n} {
			set q [concat $n $hopperm]
			set hopperm $q
		} else {
			incr t
			if {$t > $endindex} {
				lappend hopperm $n
			} else {
				set hopperm [linsert $hopperm $t $n]
			}
		}
		incr n
		incr n_plus_1
		incr endindex
	}
}

proc GrowingAmbitus {} {
	global prm chlist wl wstk pa rememd pr_booze tipple hopperm actvhi evv
	global pr_growamb hopinfilename hopoutfilename hopoutfile hopoutfilename2 hopoutfile2 hopinfiledur
	global locpos ambstart ambend ambgrow stepfrac

	set outdur $prm($evv(DR_OUTDUR))
	if {![IsNumeric $outdur] || ($outdur <= 0.0)} {
		Inf "For This Option You Need To Specify An Outputfile Duration On The Parameters Page"
		set tipple -1
		return
	}
	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set hopinfilename [lindex $chlist 0]
	if {$pa($hopinfilename,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$hopinfilename' Is Not A Soundfile"
		return
	}
	set hopinfiledur $pa($hopinfilename,$evv(DUR))
	set locpos ""
	set f .growamb
	if [Dlg_Create $f "AMBITUS GROWTH" "set pr_growamb 0" -width 40 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.0a -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		frame $f.5 -bd $evv(SBDR)
		frame $f.6 -bd $evv(SBDR)
		frame $f.7 -bd $evv(SBDR)
		button $f.0.ok -text "Keep Data" -command "set pr_growamb 1" -highlightbackground [option get . background {}]
		button $f.0.v -text "Sound View" -command "SnackDisplay $evv(SN_SINGLETIME) .growamb.1.e $evv(TIME_OUT) 1" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_growamb 0" -highlightbackground [option get . background {}]
		pack $f.0.ok $f.0.v -side left
		pack $f.0.q -side right
		button $f.0a.r -text "Restore Previous Values" -command RestoreAmb -highlightbackground [option get . background {}]
		pack $f.0a.r -side top -pady 2
		label $f.1.ll -text "Locus position"
		entry $f.1.e -textvariable locpos -width 8
		pack $f.1.e $f.1.ll -side left -padx 2
		label $f.2.ll -text "Start size of ambitus"
		entry $f.2.e -textvariable ambstart -width 8
		pack $f.2.e $f.2.ll -side left -padx 2
		label $f.3.ll -text "End size of ambitus"
		entry $f.3.e -textvariable ambend -width 8
		pack $f.3.e $f.3.ll -side left -padx 2
		label $f.4.ll -text "Step size as fraction of ambitus (0 - 1) \[Set to 0 for no linkage\]"
		entry $f.4.e -textvariable stepfrac -width 8
		pack $f.4.e $f.4.ll -side left -padx 2
		label $f.5.ll -text "Time taken for ambitus change"
		entry $f.5.e -textvariable ambgrow -width 8
		pack $f.5.e $f.5.ll -side left -padx 2
		label $f.6.ll -text "Ambitus Datafile Name"
		entry $f.6.e -textvariable hopoutfilename -width 24
		pack $f.6.e $f.6.ll -side left -padx 2
		label $f.7.ll -text "Step Datafile Name"
		entry $f.7.e -textvariable hopoutfilename2 -width 24
		pack $f.7.e $f.7.ll -side left -padx 2
		pack $f.0 -side top -pady 4 -fill x -expand true
		pack $f.0a $f.1 $f.2 $f.3 $f.4 $f.5 $f.6 $f.7 -side top -pady 4 -fill x -expand true
		bind $f.1.e  <Down> {focus .growamb.2.e}
		bind $f.2.e  <Down> {focus .growamb.3.e}
		bind $f.3.e  <Down> {focus .growamb.4.e}
		bind $f.4.e  <Down> {focus .growamb.5.e}
		bind $f.5.e  <Down> {focus .growamb.6.e}
		bind $f.6.e  <Down> {focus .growamb.7.e}
		bind $f.7.e  <Down> {focus .growamb.1.e}
		bind $f.1.e  <Up> {focus .growamb.7.e}
		bind $f.2.e  <Up> {focus .growamb.1.e}
		bind $f.3.e  <Up> {focus .growamb.2.e}
		bind $f.4.e  <Up> {focus .growamb.3.e}
		bind $f.5.e  <Up> {focus .growamb.4.e}
		bind $f.6.e  <Up> {focus .growamb.5.e}
		bind $f.7.e  <Up> {focus .growamb.6.e}
		bind $f <Return> {set pr_growamb 1}
		bind $f <Escape> {set pr_growamb 0}
		wm resizable $f 1 1
	}
	set locpos ""
	set ambstart ""
	set ambend ""
	set amgrow ""
	set stepfrac ""
	set hopoutfilename "ambitus"
	set hopoutfilename2 "step"
	set pr_growamb 0
	set finished 0
	set fileopen 0
	set fileopen2 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_growamb $f.1.e
	while {!$finished} {
		tkwait variable pr_growamb
		if {$pr_growamb} {
			if {([string length $locpos] <= 0) || ![IsNumeric $locpos] || ($locpos < 0.0) || ($locpos > $hopinfiledur)} {
				Inf "Invalid Locus Position"
				continue
			}
			set halfdur [expr $hopinfiledur / 2.0]
			if {([string length $ambstart] <= 0) || ![IsNumeric $ambstart] || ($ambstart < 0.0) || ($ambstart > $halfdur)} {
				Inf "Invalid Ambitus Start Value (Range: 0 - half input file duration)"
				continue
			}
			if {([string length $ambend] <= 0) || ![IsNumeric $ambend] || ($ambend < 0.0) || ($ambend > $halfdur)} {
				Inf "Invalid Ambitus End Value (Range: 0 - half input file duration)"
				continue
			}
			if {([string length $stepfrac] <= 0) || ![IsNumeric $stepfrac] || ($stepfrac < 0.0) || ($stepfrac > 1.0)} {
				Inf "Invalid Step Size Fraction (0 - 1)"
				continue
			}
			if {([string length $ambgrow] <= 0) || ![IsNumeric $ambgrow] || ($ambgrow <= 0.015)} {
				Inf "Invalid Ambitus Growth Time"
				continue
			}
			if {$ambgrow > $outdur} {
				Inf "Ambitus Growth Time Is Longer Than Output Duration Given On Parameters Page"
				continue
			}
			if {!$fileopen} {
				if {[string length $hopoutfilename] <= 0} {
					Inf "No Locus Data File Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename]} {
					continue
				}
				set hopoutfile [string tolower $hopoutfilename]
				append hopoutfile [GetTextfileExtension brk]
				if {[file exists $hopoutfile]} {
					set msg "File '$hopoutfile' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen2 && ($stepfrac > 0.0)} {
				if {[string length $hopoutfilename2] <= 0} {
					Inf "No Step Data File Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename2]} {
					continue
				}
				set hopoutfile2 [string tolower $hopoutfilename2]
				append hopoutfile2 [GetTextfileExtension brk]
				if {[file exists $hopoutfile2]} {
					set msg "File '$hopoutfile2' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile2]} {
							continue
						}
					} else {
						continue
					}
				}
			}	
			if {!$fileopen} {
				if [catch {open $hopoutfile "w"} zit] {
					Inf "Cannot Open file '$hopoutfile' To Write Ambitus Data"
					continue
				}
				set fileopen 1
			}
			if {!$fileopen2 && ($stepfrac > 0.0)} {
				if [catch {open $hopoutfile2 "w"} zit2] {
					Inf "Cannot Open File '$hopoutfile2' To Write Step Data"
					catch {close zit}
					continue
				}
				set fileopen2 1
			}
			Block "Creating Data"
			set prm($evv(DR_LOCUS)) $locpos
			set line "0.0"
			append line " " $ambstart
			puts $zit $line
			set line $ambgrow
			append line " " $ambend
			puts $zit $line
			if {$outdur > $ambgrow} {
				set line $outdur
				append line " " $ambend
				puts $zit $line
			}
			close $zit
			set fileopen 0
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				catch {close $zit2}
				UnBlock
				continue
			}
			if {($ambstart > $actvhi($evv(DR_AMBITUS))) || ($ambend > $actvhi($evv(DR_AMBITUS)))} {
				SwitchRange $evv(DR_AMBITUS) $evv(DR_AMBITUS) 1 1
			}
			set prm($evv(DR_AMBITUS)) $hopoutfile

			if {$stepfrac > 0.0} {
				set line "0.0"
				append line " " [expr $ambstart * $stepfrac]
				puts $zit2 $line
				set line $ambgrow
				append line " " [expr $ambend * $stepfrac]
				puts $zit2 $line
				if {$outdur > $ambgrow} {
					set line $outdur
					append line " " [expr $ambend * $stepfrac]
					puts $zit2 $line
				}
				close $zit2
				if {[FileToWkspace $hopoutfile2 0 0 0 0 1] <= 0} {
					UnBlock
					continue
				}
				set lim [expr $actvhi($evv(DR_STEP)) * $stepfrac]
				if {($ambstart > $lim) || ($ambend > $lim)} {
					SwitchRange $evv(DR_STEP) $evv(DR_STEP) 1 1
				}
				set prm($evv(DR_STEP)) $hopoutfile2
			} elseif {$fileopen2} {
				catch {close $zit2}
				if {([string length $hopoutfilename2] > 0) && [info exists hopoutfile2] && [file exists $hopoutfile2]} {
					set msg "Destroy The Step File '$hopoutfile2' ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						DeleteNonSndfileFromSystem $hopoutfile2
					}
				}
			}
			BakupAmb
			UnBlock
			set pr_booze 0
			break
		} else {
			if {$fileopen} {
				catch {close $zit}
			}
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Ambitus File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			if {$fileopen2} {
				catch {close $zit2}
			}
			if {([string length $hopoutfilename2] > 0) && [info exists hopoutfile2] && [file exists $hopoutfile2]} {
				set msg "Destroy The Step File '$hopoutfile2' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile2
				}
			}
			set tipple -1
			break
		}
	}		
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc HopGrowingAmbitus {} {
	global rememd pr_booze hopdatainfileg hopoutfile hopoutfilename hopinfiledur hopinfilename wstk chlist wl pa prm tipple evv
	global hoptextg hopoutfilename2 hopoutfilename3 hopoutfile2 hopoutfile3 ambstartg ambendg stepfracg hoptick pr_hopga actvhi
	global ambsteady ambtstepg hp_lastgo
	global lasthoptick lastambstartg lastambendg laststepfracg lastambtstepg readonlyfg readonlybg

	set fileopen1 0
	set fileopen2 0
	set fileopen3 0
	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set hopinfilename [lindex $chlist 0]
	if {$pa($hopinfilename,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$hopinfilename' Is Not A Soundfile"
		return
	}
	set hopinfiledur $pa($hopinfilename,$evv(DUR))

	set f .thopg
	if [Dlg_Create $f "STEP-ADVANCE LOCUS IN FILE, GROW AMBITUS" "set pr_hopga 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.0a -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.2a -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		frame $f.5 -bd $evv(SBDR)
		frame $f.6 -bd $evv(SBDR)
		frame $f.7 -bd $evv(SBDR)
		frame $f.8 -bd $evv(SBDR)
		frame $f.9 -bd $evv(SBDR)
		frame $f.10 -bd $evv(SBDR)
		frame $f.11 -bd $evv(SBDR)
		set hoptextg [text $f.11.t -setgrid true -wrap word -width 76 -height 32 \
		-xscrollcommand "$f.11.sx set" -yscrollcommand "$f.11.sy set"]
		scrollbar $f.11.sy -orient vert  -command "$f.11.t yview"
		scrollbar $f.11.sx -orient horiz -command "$f.11.t xview"
		pack $f.11.t -side left -fill both -expand true
		pack $f.11.sy -side right -fill y
		button $f.0.ok -text "Finished" -command "set pr_hopga 1" -highlightbackground [option get . background {}]
		label $f.0.ll -text "        Input Sound Duration    "
		entry $f.0.e -textvariable hopinfiledur -width 16 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		button $f.0.v -text "Sound View" -command "SnackDisplay $evv(SN_UNSORTED_TIMES) $hoptextg $evv(TIME_OUT) 1" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_hopga 0" -highlightbackground [option get . background {}]
		pack $f.0.ok $f.0.ll $f.0.e $f.0.v -side left
		pack $f.0.q -side right
		button $f.0a.r -text "Restore Previous Run Values" -command RestoreAmbg -highlightbackground [option get . background {}]
		pack $f.0a.r -side top
		label $f.1.ll -text "LOCUS STEPPING TYPE"
		pack $f.1.ll -side top
		radiobutton $f.2.sped -variable hopdatainfileg \
			-text "DATA IS INPUTFILE POSITIONS: Step from position to position at speed given by Speed Multiplier" \
			-value 0 -command "HopSpeed 1 .thopg.10.z .thopg.3.ll .thopg.3.e $hoptextg"
		radiobutton $f.2.data -variable hopdatainfileg \
			-text "DATA WILL BECOME POSITION-TIME PAIRS: Remain at each position for (associated) time given                     " \
			-value 1 -command "HopSpeed 0 .thopg.10.z .thopg.3.ll .thopg.3.e $hoptextg"
		checkbutton $f.2a.b -variable ambsteady -text "Ambitus changes at fixed rate" -command "AmbiSteady "
		pack $f.2a.b -side left
		pack $f.2.sped $f.2.data -side top -pady 2
		label $f.3.ll -text "" -width 16
		entry $f.3.e -textvariable hoptick -width 4 -bd 0 -state disabled -disabledbackground [option get . background {}]
		pack $f.3.ll $f.3.e -side left -padx 2
		label $f.4.ll -text "Start size of ambitus"
		entry $f.4.e -textvariable ambstartg -width 8
		pack $f.4.e $f.4.ll -side left -padx 2
		label $f.5.ll -text "End size of ambitus"
		entry $f.5.e -textvariable ambendg -width 8
		pack $f.5.e $f.5.ll -side left -padx 2
		label $f.6.ll -text "Step size as fraction of ambitus (0 - 1) \[Set to 0 for no linkage\]"
		entry $f.6.e -textvariable stepfracg -width 8
		pack $f.6.e $f.6.ll -side left -padx 2

		label $f.7.ll -text "Locus Datafile Name"
		entry $f.7.e -textvariable hopoutfilename -width 16
		pack $f.7.e $f.7.ll -side left -padx 2
		label $f.8.ll -text "Ambitus Datafile Name"
		entry $f.8.e -textvariable hopoutfilename2 -width 16
		pack $f.8.e $f.8.ll -side left -padx 2
		label $f.9.ll -text "Step Datafile Name"
		entry $f.9.e -textvariable hopoutfilename3 -width 16
		pack $f.9.e $f.9.ll -side left -padx 2

		button $f.10.z -text "" -command "HopZero hoptextg" -bd 0 -state disabled -width 16 -highlightbackground [option get . background {}]
		button $f.10.c -text "Clear Display" -command "$hoptextg delete 1.0 end" -width 16 -highlightbackground [option get . background {}]
		label $f.10.ll -text "Duration of Ambitus Change" -width 26
		entry $f.10.e -textvariable ambtstepg -width 12 -disabledbackground [option get . background {}]
		pack $f.10.z $f.10.c $f.10.ll $f.10.e -side left -pady 2 -padx 4

		pack $f.0 -side top -fill x -expand true -anchor w
		pack $f.0a -side top
		pack $f.1 $f.2 -side top -fill x -expand true -anchor w
		pack $f.2a -side top
		pack $f.3 $f.4 $f.5 $f.6 $f.7 $f.8 $f.9 $f.10 -side top -fill x -expand true -anchor w
		pack $f.11 -side top -fill x -expand true

		bind $f.3.e  <Down> {focus .thopg.4.e}
		bind $f.4.e  <Down> {focus .thopg.5.e}
		bind $f.5.e  <Down> {focus .thopg.6.e}
		bind $f.6.e  <Down> {focus .thopg.7.e}
		bind $f.7.e  <Down> {focus .thopg.8.e}
		bind $f.8.e  <Down> {focus .thopg.9.e}
		bind $f.9.e  <Down> {LocFoc .thopg 0 0}
		bind $f.3.e  <Up> {LocFoc .thopg 1 1}
		bind $f.4.e  <Up> {LocFoc .thopg 1 0}
		bind $f.5.e  <Up> {focus .thopg.4.e}
		bind $f.6.e  <Up> {focus .thopg.5.e}
		bind $f.7.e  <Up> {focus .thopg.6.e}
		bind $f.8.e  <Up> {focus .thopg.7.e}
		bind $f.9.e  <Up> {focus .thopg.8.e}

		bind $f.10.e  <Down> {LocFoc .thopg 0 1}
		bind $f.10.e  <Up> {focus .thopg.9.e}
		bind $f <Return> {set pr_hopga 1}
		bind $f <Escape> {set pr_hopga 0}
		wm resizable $f 1 1
	}
	$f.3.e config -bd 0 -state disabled -disabledbackground [option get . background {}]
	$f.10.z config -text "" -bd 0 -state disabled
	$f.10.ll config -text ""
	$f.10.e config  -bd 0 -state disabled

	set hopoutfilename "locus"
	set hopoutfilename2 "ambitus"
	set hopoutfilename3 "step"
	ForceVal $f.0.e $hopinfiledur
	$hoptextg delete 1.0 end
	set hopdatainfileg -1
	set hoptick ""
	set ambstartg ""
	set ambendg ""
	set stepfracg ""
	set ambtstepg  ""
	set ambsteady 0
	AmbiSteady
	set pr_hopga 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_hopga $f.4.e
	while {!$finished} {
		tkwait variable pr_hopga
		if {$pr_hopga} {
			if {$hopdatainfileg < 0} {
				Inf "No Locus Type Chosen"
				continue
			}
			set vals [$hoptextg get 1.0 end]
			if {[llength $vals] <= 0} {
				Inf "No Data Has Been Entered"
				continue
			}
			if {([string length $hoptick] <= 0) || ![IsNumeric $hoptick] || ($hoptick <= 0.0)} {
				if {$hopdatainfileg} {
					Inf "Invalid Minimum Clocktick"
				} else {
					Inf "Invalid Speed Multiplier"
				}
				continue
			}
			set halfdur [expr $hopinfiledur / 2.0]
			if {([string length $ambstartg] <= 0) || ![IsNumeric $ambstartg] || ($ambstartg < 0.0) || ($ambstartg > $halfdur)} {
				Inf "Invalid Ambitus Start Value (Range 0 - half input file duration)"
				continue
			}
			if {([string length $ambendg] <= 0) || ![IsNumeric $ambendg] || ($ambendg < 0.0) || ($ambendg > $halfdur)} {
				Inf "Invalid Ambitus End Value (Range 0 - half input file duration)"
				continue
			}
			if {([string length $stepfracg] <= 0) || ![IsNumeric $stepfracg] || ($stepfracg < 0.0) || ($stepfracg > 1.0)} {
				Inf "Invalid Step Size Fraction (0 - 1)"
				continue
			}
			set stepsttg [expr $ambstartg * $stepfracg]
			set stependg [expr $ambendg * $stepfracg]

			if {$ambsteady} {
				if {([string length $ambtstepg] <= 0) || ![IsNumeric $ambtstepg] || ($ambtstepg < $evv(FLTERR))} {
					Inf "Invalid Duration Of Ambitus Change (> 0)"
					continue
				}
				set ambmoveg [expr $ambendg - $ambstartg]
			}
			set OK 1
			set sw 0
			set lastval -1.0
			set cnt 0
			foreach val $vals {
				if {![IsNumeric $val]} {
					Inf "Data Value '$val' Is Invalid"
					set OK 0
					break
				}
				if {$sw && $hopdatainfileg} {
					if {$val <= $hoptick} {
						Inf "Timestep ($val) Too SHORT"
						set OK 0
						break
					}
				} else {
					if {$val < 0.0 || $val >= $hopinfiledur} {
						Inf "Locus Position $val Is Not Inside Source File"
						set OK 0
						break
					}
					if {!$hopdatainfileg && ($val <= $lastval)} {
						Inf "Locus Positions $lastval $val Do Not Advance Through File"
						set OK 0
						break
					}
				}
				set lastval $val
				set sw [expr !$sw]
				incr cnt
			}
			if {!$OK} {
				continue
			}
			if {!$fileopen1} {
				if {[string length $hopoutfilename] <= 0} {
					Inf "No Locus Datafile Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename]} {
					continue
				}
				set hopoutfile [string tolower $hopoutfilename]
				append hopoutfile [GetTextfileExtension brk]
				if {[file exists $hopoutfile]} {
					set msg "File '$hopoutfile' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen2} {
				if {[string length $hopoutfilename2] <= 0} {
					Inf "No Ambitus Datafile Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename2]} {
					continue
				}
				set hopoutfile2 [string tolower $hopoutfilename2]
				append hopoutfile2 [GetTextfileExtension brk]
				if {[file exists $hopoutfile2]} {
					set msg "File '$hopoutfile2' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile2]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen3 && ($stepfracg > 0.0)} {
				if {[string length $hopoutfilename3] <= 0} {
					Inf "No Step Datafile Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename3]} {
					continue
				}
				set hopoutfile3 [string tolower $hopoutfilename3]
				append hopoutfile3 [GetTextfileExtension brk]
				if {[file exists $hopoutfile3]} {
					set msg "File '$hopoutfile3' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile3]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen1} {
				if [catch {open $hopoutfile "w"} zit] {
					Inf "Cannot Open File '$hopoutfile' To Write Locus Data"
					continue
				}
				set fileopen1 1
			}
			if {!$fileopen2} {
				if [catch {open $hopoutfile2 "w"} zit2] {
					Inf "Cannot Open File '$hopoutfile2' To Write Ambitus Data"
					catch {close zit}
					continue
				}
				set fileopen2 1
			}
			if {!$fileopen3 && ($stepfracg > 0.0)} {
				if [catch {open $hopoutfile3 "w"} zit3] {
					Inf "Cannot Open File $hopoutfile3 To Write Step Data"
					catch {close zit}
					catch {close zit2}
					continue
				}
				set fileopen3 1
			}
			catch {unset pairs}
			if {$hopdatainfileg} {
				if {![IsEven $cnt]} {
					Inf "Data Not Correctly Paired For This Option"
					close $zit
					catch {close zit2}
					catch {close zit3}
					continue
				}
				Block "Creating Data"
				set time 0.0
				set dur 0.0
				foreach {pos step} $vals {
					set dur [expr $dur + $step]
					set thispair [list $time $pos]
					lappend pairs $thispair
					set time [expr $time + $step]
					set subtime [expr $time - $evv(FLTERR)]
					set thispair [list $subtime $pos]
					lappend pairs $thispair
				}
				set thispair [list $time $pos]
				lappend pairs $thispair
				if {$time < $hopinfiledur} {
					set thispair [list $hopinfiledur $pos]
					lappend pairs $thispair
				}
			} else {
				Block "Creating Data"
				set lastpos [lindex $vals 0]
				set time 0.0
				foreach pos [lrange $vals 1 end] {
					set thispair [list $time $lastpos]
					lappend pairs $thispair
					set step [expr $pos - $lastpos]
					set step [expr $step / $hoptick]
					set time [expr $time + $step]
					set subtime [expr $time - $evv(FLTERR)]
					set thispair [list $subtime $lastpos]
					lappend pairs $thispair
					set lastpos $pos
				}
				set thispair [list $time $lastpos]
				lappend pairs $thispair
				if {$time < $hopinfiledur} {
					set time $hopinfiledur
				}
				set thispair [list $time $lastpos]
				lappend pairs $thispair
			}
			set sw 1
			if {$ambsteady} {
				set OK 1
				foreach pair $pairs {
					if {$sw} {
						set lasttime [lindex $pair 0]
					} else {
						set thistime [lindex $pair 0]
						set thisdur [expr $thistime - $lasttime]
						set timefrac [expr $thisdur / $ambtstepg]
						set amb_end [expr $ambmoveg * $timefrac]
						if {$amb_end < 0.0 || $amb_end >$halfdur} {
							Inf "Impossible Ambitus ($amb_end) Generated At Time $thistime : Alter Duration Of Ambitus Change ??"
							set OK 0
							break
						}
					}
					set sw [expr !$sw]
				}
				if {!$OK} {
					catch {close $zit}
					catch {close $zit2}
					catch {close $zit3}
					UnBlock
					continue
				}
				set sw 1
				foreach pair $pairs {
					set time [lindex $pair 0]
					set line $time
					append line " " [lindex $pair 1]
					puts $zit $line
					if {$sw} {
						set lasttime $time
						set line $time
						append line " " $ambstartg
						puts $zit2 $line
						if {$stepfracg > 0.0} {
							set line $time
							append line " " $stepsttg
							puts $zit3 $line
						}
					} else {
						set thisdur [expr $time - $lasttime]
						set timefrac [expr $thisdur / $ambtstepg]
						set amb_end [expr $ambmoveg * $timefrac]
						set line $time
						append line " " $amb_end
						puts $zit2 $line
						if {$stepfracg > 0.0} {
							set step_end [expr $amb_end * $stepfracg]
							set line $time
							append line " " $step_end
							puts $zit3 $line
						}
					}
					set sw [expr !$sw]
				}
			} else {
				foreach pair $pairs {
					set time [lindex $pair 0]
					set line $time
					append line " " [lindex $pair 1]
					puts $zit $line
					if {$sw} {
						set line $time
						append line " " $ambstartg
						puts $zit2 $line
						if {$stepfracg > 0.0} {
							set line $time
							append line " " $stepsttg
							puts $zit3 $line
						}
					} else {
						set line $time
						append line " " $ambendg
						puts $zit2 $line
						if {$stepfracg > 0.0} {
							set line $time
							append line " " $stependg
							puts $zit3 $line
						}
					}
					set sw [expr !$sw]
				}
			}
			close $zit
			set fileopen1 0
			close $zit2
			set fileopen2 0
			catch {close $zit3}
			set fileopen3 0
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				UnBlock
				continue
			}
			if {[FileToWkspace $hopoutfile2 0 0 0 0 1] <= 0} {
				UnBlock
				continue
			}
			if {$stepfracg > 0.0} {
				if {[FileToWkspace $hopoutfile3 0 0 0 0 1] <= 0} {
					UnBlock
					continue
				}
			}
			if {$hopdatainfileg} {
				set prm($evv(DR_OUTDUR)) $dur
			} else {
				set prm($evv(DR_OUTDUR)) [expr $hopinfiledur / $hoptick]
			}
			set prm($evv(DR_LOCUS)) $hopoutfile
			set prm($evv(DR_AMBITUS)) $hopoutfile2
			if {($ambstartg > $actvhi($evv(DR_AMBITUS))) || ($ambendg > $actvhi($evv(DR_AMBITUS)))} {
				SwitchRange $evv(DR_AMBITUS) $evv(DR_AMBITUS) 1 1
			}
			if {$stepfracg > 0.0} {
				set prm($evv(DR_STEP)) $hopoutfile3
				set lim [expr $actvhi($evv(DR_STEP)) * $stepfracg]
				if {($ambstartg > $lim) || ($ambendg > $lim)} {
					SwitchRange $evv(DR_STEP) $evv(DR_STEP) 1 1
				}
			}
			UnBlock
			set pr_booze 0
			BakupAmbg
			break
		} else {
			if {$fileopen1} {
				catch {close $zit}
			}
			if {$fileopen2} {
				catch {close $zit2}
			}
			if {$fileopen3} {
				catch {close $zit3}
			}
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Locus Data File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			if {([string length $hopoutfilename2] > 0) && [info exists hopoutfile2] && [file exists $hopoutfile2]} {
				set msg "Destroy The Ambitus Data File '$hopoutfile2' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile2
				}
			}
			if {([string length $hopoutfilename3] > 0) && [info exists hopoutfile3] && [file exists $hopoutfile3]} {
				set msg "Destroy The Step Data File '$hopoutfile3' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile3
				}
			}
			set tipple -1
			break
		}
	}		
	catch {unset hp_lastgo}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc AmbiSteady {} {
	global ambsteady ambtstepg
	switch -- $ambsteady {
		0 {
			.thopg.10.ll config -text ""
			set ambtstepg ""
			.thopg.10.e config -bd 0 -state disabled
		}
		1 {
			.thopg.10.ll config -text "Duration of Ambitus Change"
			set ambtstepg ""
			.thopg.10.e config -bd 2 -state normal
		}	
	}
}

proc BakupAmb {} {
	global lastambstart lastambend laststepfrac lastambgrow lastlocpos
	global ambstart ambend stepfrac ambgrow locpos

	if {[info exists locpos]} {
		set lastlocpos $locpos
	}
	if {[info exists ambstart]} {
		set lastambstart $ambstart
	}
	if {[info exists ambend]} {
		set lastambend $ambend
	}
	if {[info exists stepfrac]} {
		set laststepfrac $stepfrac
	}
	if {[info exists ambgrow]} {
		set lastambgrow $ambgrow
	}
}

proc RestoreAmb {} {
	global lastambstart lastambend laststepfrac lastambgrow lastlocpos
	global ambstart ambend stepfrac ambgrow locpos

	if {[info exists lastlocpos]} {
		set locpos $lastlocpos
	}
	if {[info exists lastambstart]} {
		set ambstart $lastambstart
	}
	if {[info exists lastambend]} {
		set ambend $lastambend
	}
	if {[info exists laststepfrac]} {
		set stepfrac $laststepfrac
	}
	if {[info exists lastambgrow]} {
		set ambgrow $lastambgrow
	}
}

proc BakupAmbg {} {
	global lasthopdatainfileg lasthoptick lastambstartg lastambendg laststepfracg lastambtstepg lastambsteady
	global hopdatainfileg hoptick ambstartg ambendg stepfracg ambtstepg ambsteady hopbakvalsg hoptextg

	if {$hopdatainfileg < 0} {
		return
	}
	set hopbakvalsg [$hoptextg get 1.0 end]
	set lasthopdatainfileg $hopdatainfileg
	if {[info exists ambsteady]} {
		set lastambsteady $ambsteady
	}
	if {[info exists hoptick]} {
		set lasthoptick $hoptick
	}
	if {[info exists ambstartg]} {
		set lastambstartg $ambstartg
	}
	if {[info exists ambendg]} {
		set lastambendg $ambendg
	}
	if {[info exists stepfracg]} {
		set laststepfracg $stepfracg
	}
	if {[info exists ambtstepg]} {
		set lastambtstepg $ambtstepg
	}
}

proc RestoreAmbg {} {
	global lasthopdatainfileg lasthoptick lastambstartg lastambendg laststepfracg lastambtstepg lastambsteady
	global hopdatainfileg hoptick ambstartg ambendg stepfracg ambtstepg ambsteady hopbakvalsg hoptextg

	if {[info exists lasthopdatainfileg] && ($lasthopdatainfileg >= 0)} {
		set hopdatainfileg $lasthopdatainfileg
		switch -- $hopdatainfileg {
			0 { HopSpeed 1 .thopg.10.z .thopg.3.ll .thopg.3.e $hoptextg}
			1 { HopSpeed 0 .thopg.10.z .thopg.3.ll .thopg.3.e $hoptextg}
		}
	}
	$hoptextg delete 1.0 end
	$hoptextg insert 1.0 $hopbakvalsg
	if {[info exists lastambsteady]} {
		set ambsteady $lastambsteady
		AmbiSteady
	}
	if {[info exists lasthoptick]} {
		set hoptick $lasthoptick
	}
	if {[info exists lastambstartg]} {
		set ambstartg $lastambstartg
	}
	if {[info exists lastambendg]} {
		set ambendg $lastambendg
	}
	if {[info exists laststepfracg]} {
		set stepfracg $laststepfracg
	}
	if {[info exists lastambtstepg] && ([string length $lastambtstepg] > 0)} {
		if {$ambsteady} {
			set ambtstepg $lastambtstepg
		}
	}
}

proc RandGrowingAmbitus {} {
	global rememd pr_booze hopoutfile hopoutfilename hopinfiledur hopinfilename wstk chlist wl pa prm tipple evv
	global hoptextr hopoutfilename2 hopoutfilename3 hopoutfile2 hopoutfile3 ambstartr ambendr stepfracr pr_hopgr actvhi
	global ambsteadyr ambtstepr
	global lasthopsegcntr lasthoptimestepr lasthoprandr lastambstartr lastambendr laststepfracr lastambtstepr
	global hopsegcntr hoptimestepr hoprandr hopperm readonlyfg readonlybg

	set fileopen1 0
	set fileopen2 0
	set fileopen3 0
	set outdur $prm($evv(DR_OUTDUR))
	if {![IsNumeric $outdur] || ($outdur <= 0.0)} {
		Inf "For This Option You Need To Specify An Outputfile Duration On The Parameters Page"
		set tipple -1
		return
	}
	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set hopinfilename [lindex $chlist 0]
	if {$pa($hopinfilename,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$hopinfilename' Is Not A Soundfile"
		return
	}
	set hopinfiledur $pa($hopinfilename,$evv(DUR))

	set f .thopr
	if [Dlg_Create $f "RANDOM-STEP LOCUS: GROW AMBITUS" "set pr_hopgr 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.0a -bd $evv(SBDR)
		frame $f.0b -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		frame $f.5 -bd $evv(SBDR)
		frame $f.6 -bd $evv(SBDR)
		frame $f.7 -bd $evv(SBDR)
		frame $f.8 -bd $evv(SBDR)
		frame $f.9 -bd $evv(SBDR)
		frame $f.10 -bd $evv(SBDR)
		button $f.0.ok -text "Finished" -command "set pr_hopgr 1" -highlightbackground [option get . background {}]
		label $f.0.ll -text "        Input Sound Duration    "
		entry $f.0.e -textvariable hopinfiledur -width 16 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		button $f.0.q -text "Abandon" -command "set pr_hopgr 0" -highlightbackground [option get . background {}]
		pack $f.0.ok $f.0.ll $f.0.e -side left
		pack $f.0.q -side right
		button $f.0a.r -text "Restore Previous Run Values" -command RestoreAmbR -highlightbackground [option get . background {}]
		pack $f.0a.r -side top
		checkbutton $f.0b.b -variable ambsteadyr -text "Ambitus changes at fixed rate" -command "AmbiSteadyR"
		pack $f.0b.b -side left
		label $f.1.ll -text "Number of segments of source to hop randomly between"
		entry $f.1.e -textvariable hopsegcntr -width 8
		pack $f.1.e $f.1.ll -side left -padx 2
		label $f.2.ll -text "Average time between hops"
		entry $f.2.e -textvariable hoptimestepr -width 8
		pack $f.2.e $f.2.ll -side left -padx 2
		label $f.3.ll -text "Randomisation of timesteps (0-1)"
		entry $f.3.e -textvariable hoprandr -width 8
		pack $f.3.e $f.3.ll -side left -padx 2
		label $f.4.ll -text "Start size of ambitus"
		entry $f.4.e -textvariable ambstartr -width 8
		pack $f.4.e $f.4.ll -side left -padx 2
		label $f.5.ll -text "End size of ambitus"
		entry $f.5.e -textvariable ambendr -width 8
		pack $f.5.e $f.5.ll -side left -padx 2
		label $f.6.ll -text "Step size as fraction of ambitus (0 - 1) \[Set to 0 for no linkage\]"
		entry $f.6.e -textvariable stepfracr -width 8
		pack $f.6.e $f.6.ll -side left -padx 2

		label $f.7.ll -text "Locus Datafile Name"
		entry $f.7.e -textvariable hopoutfilename -width 16
		pack $f.7.e $f.7.ll -side left -padx 2
		label $f.8.ll -text "Ambitus Datafile Name"
		entry $f.8.e -textvariable hopoutfilename2 -width 16
		pack $f.8.e $f.8.ll -side left -padx 2
		label $f.9.ll -text "Step Datafile Name"
		entry $f.9.e -textvariable hopoutfilename3 -width 16
		pack $f.9.e $f.9.ll -side left -padx 2

		label $f.10.ll -text "Duration of Ambitus Change" -width 26
		entry $f.10.e -textvariable ambtstepr -width 12 -disabledbackground [option get . background {}]
		pack $f.10.ll $f.10.e -side left -pady 2 -padx 4

		pack $f.0 -side top -fill x -expand true -anchor w
		pack $f.0a $f.0b -side top
		pack $f.1 $f.2 $f.3 $f.4 $f.5 $f.6 $f.7 $f.8 $f.9 $f.10 -side top -fill x -expand true -anchor w

		bind $f.1.e  <Down> {focus .thopr.2.e}
		bind $f.2.e  <Down> {focus .thopr.3.e}
		bind $f.3.e  <Down> {focus .thopr.4.e}
		bind $f.4.e  <Down> {focus .thopr.5.e}
		bind $f.5.e  <Down> {focus .thopr.6.e}
		bind $f.6.e  <Down> {focus .thopr.7.e}
		bind $f.7.e  <Down> {focus .thopr.8.e}
		bind $f.8.e  <Down> {focus .thopr.9.e}
		bind $f.1.e  <Up> {LocFoc .thopr 1 1}
		bind $f.2.e  <Up> {focus .thopr.1.e}
		bind $f.3.e  <Up> {focus .thopr.2.e}
		bind $f.4.e  <Up> {focus .thopr.3.e}
		bind $f.5.e  <Up> {focus .thopr.4.e}
		bind $f.6.e  <Up> {focus .thopr.5.e}
		bind $f.7.e  <Up> {focus .thopr.6.e}
		bind $f.8.e  <Up> {focus .thopr.7.e}
		bind $f.9.e  <Up> {focus .thopr.8.e}

		bind $f.9.e  <Down> {LocFoc .thopr 0 1}

		bind $f.10.e  <Up> {focus .thopr.9.e}
		bind $f.10.e  <Down> {focus .thopr.1.e}
		bind $f <Return> {set pr_hopgr 1}
		bind $f <Escape> {set pr_hopgr 0}
		wm resizable $f 1 1
	}
	$f.10.ll config -text ""
	set hopoutfilename "locus"
	set hopoutfilename2 "ambitus"
	set hopoutfilename3 "step"
	ForceVal $f.0.e $hopinfiledur
	set hopsegcntr ""
	set hoptimestepr ""
	set hoprandr ""
	set ambstartr ""
	set ambendr ""
	set stepfracr ""
	set ambtstepr  ""
	set ambsteadyr 0
	AmbiSteadyR
	set pr_hopgr 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_hopgr $f.1.e
	while {!$finished} {
		tkwait variable pr_hopgr
		if {$pr_hopgr} {
			set halfdur [expr $hopinfiledur / 2.0]


			if {![regexp {^[0-9]+$} $hopsegcntr] || ($hopsegcntr < 1)} {
				Inf "Invalid Nuber Of Segments"
				continue
			}
			if {([string length $hoptimestepr] <= 0) || ![IsNumeric $hoptimestepr] || ($hoptimestepr < 0.015)} {
				Inf "Invalid Time Between Hops"
				continue
			}
			if {([string length $hoprandr] <= 0) || ![IsNumeric $hoprandr] || ($hoprandr < 0.0) || ($hoprandr > 1.0)} {
				Inf "Invalid Randomisation Of Time Steps (Range 0-1)"
				continue
			}
			if {([string length $ambstartr] <= 0) || ![IsNumeric $ambstartr] || ($ambstartr < 0.0) || ($ambstartr > $halfdur)} {
				Inf "Invalid Ambitus Start Value (Range 0 - half input file duration)"
				continue
			}
			if {([string length $ambendr] <= 0) || ![IsNumeric $ambendr] || ($ambendr < 0.0) || ($ambendr > $halfdur)} {
				Inf "Invalid Ambitus End Value (Range 0 - half input file duration)"
				continue
			}
			if {([string length $stepfracr] <= 0) || ![IsNumeric $stepfracr] || ($stepfracr < 0.0) || ($stepfracr > 1.0)} {
				Inf "Invalid Step Size Fraction (0 - 1)"
				continue
			}
			set stepsttr [expr $ambstartr * $stepfracr]
			set stependr [expr $ambendr * $stepfracr]

			if {$ambsteadyr} {
				if {([string length $ambtstepr] <= 0) || ![IsNumeric $ambtstepr] || ($ambtstepr < $evv(FLTERR))} {
					Inf "Invalid Duration Of Ambitus Change (> 0)"
					continue
				}
				set ambmover [expr $ambendr - $ambstartr]
			}
			if {!$fileopen1} {
				if {[string length $hopoutfilename] <= 0} {
					Inf "No Locus Datafile Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename]} {
					continue
				}
				set hopoutfile [string tolower $hopoutfilename]
				append hopoutfile [GetTextfileExtension brk]
				if {[file exists $hopoutfile]} {
					set msg "File '$hopoutfile' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen2} {
				if {[string length $hopoutfilename2] <= 0} {
					Inf "No Ambitus Datafile Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename2]} {
					continue
				}
				set hopoutfile2 [string tolower $hopoutfilename2]
				append hopoutfile2 [GetTextfileExtension brk]
				if {[file exists $hopoutfile2]} {
					set msg "File '$hopoutfile2' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile2]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen3 && ($stepfracr > 0.0)} {
				if {[string length $hopoutfilename3] <= 0} {
					Inf "No Step Datafile Name Entered"
					continue
				}
				if {![ValidCDPRootname $hopoutfilename3]} {
					continue
				}
				set hopoutfile3 [string tolower $hopoutfilename3]
				append hopoutfile3 [GetTextfileExtension brk]
				if {[file exists $hopoutfile3]} {
					set msg "File '$hopoutfile3' Already Exists: Overwrite It?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![DeleteNonSndfileFromSystem $hopoutfile3]} {
							continue
						}
					} else {
						continue
					}
				}	
			}
			if {!$fileopen1} {
				if [catch {open $hopoutfile "w"} zit] {
					Inf "Cannot Open File '$hopoutfile' To Write Locus Data"
					continue
				}
				set fileopen1 1
			}
			if {!$fileopen2} {
				if [catch {open $hopoutfile2 "w"} zit2] {
					Inf "Cannot Open File '$hopoutfile2' To Write Ambitus Data"
					catch {close zit}
					continue
				}
				set fileopen2 1
			}
			if {!$fileopen3 && ($stepfracr > 0.0)} {
				if [catch {open $hopoutfile3 "w"} zit3] {
					Inf "Cannot Open File '$hopoutfile3' To Write Step Data"
					catch {close zit}
					catch {close zit2}
					continue
				}
				set fileopen3 1
			}
			Block "Creating Data"
			set maxloc [expr $hopinfiledur - 0.015]
			set seglen [expr $maxloc / $hopsegcntr]
			randperm $hopsegcntr
			set time 0.0
			set cnt 0
			catch {unset pairs}
			while {$time < $outdur} {
				set seg [lindex $hopperm $cnt]
				set baseval [expr $seg * $seglen]
				set val [expr rand() * $seglen]
				set pos [expr $val + $baseval]
				set thispair [list $time $pos]	
				lappend pairs $thispair
				if {$hoprandr <= 0.0} {
					set time [expr $time + $hoptimestepr]
				} else {
					set val [expr rand() * 2.0]
					set val [expr ($val - 1.0) / 2.0]
					set val [expr ($val * $hoprandr) + 1.0]
					set val [expr $val * $hoptimestepr]
					set time [expr $time + $val] 
				}
				incr cnt
				if {$cnt >= $hopsegcntr} {
					set lastpermval [lindex $hopperm end]
					while {1} {
						randperm $hopsegcntr
						if {[lindex $hopperm 0] != $lastpermval} {
							break
						}
					} 
					set cnt 0
				}
			}
			set seg [lindex $hopperm $cnt]
			set baseval [expr $seg * $seglen]
			set val [expr rand() * $seglen]
			set pos [expr $val + $baseval]
			set thispair [list $time $pos]	
			lappend pairs $thispair

			set sw 1
			if {$ambsteadyr} {
				set OK 1
				foreach pair $pairs {
					if {$sw} {
						set lasttime [lindex $pair 0]
					} else {
						set thistime [lindex $pair 0]
						set thisdur [expr $thistime - $lasttime]
						set timefrac [expr $thisdur / $ambtstepr]
						set amb_end [expr $ambmover * $timefrac]
						if {$amb_end < 0.0 || $amb_end >$halfdur} {
							Inf "Impossible Ambitus ($amb_end) Generated At Time $thistime : Alter Duration Of Ambitus Change ??"
							set OK 0
							break
						}
					}
					set sw [expr !$sw]
				}
				if {!$OK} {
					catch {close $zit}
					catch {close $zit2}
					catch {close $zit3}
					UnBlock
					continue
				}
				set sw 1
				foreach pair $pairs {
					set time [lindex $pair 0]
					set line $time
					append line " " [lindex $pair 1]
					puts $zit $line
					if {$sw} {
						set lasttime $time
						set line $time
						append line " " $ambstartr
						puts $zit2 $line
						if {$stepfracr > 0.0} {
							set line $time
							append line " " $stepsttr
							puts $zit3 $line
						}
					} else {
						set thisdur [expr $time - $lasttime]
						set timefrac [expr $thisdur / $ambtstepr]
						set amb_end [expr $ambmover * $timefrac]
						set line $time
						append line " " $amb_end
						puts $zit2 $line
						if {$stepfracr > 0.0} {
							set step_end [expr $amb_end * $stepfracr]
							set line $time
							append line " " $step_end
							puts $zit3 $line
						}
					}
					set sw [expr !$sw]
				}
			} else {
				foreach pair $pairs {
					set time [lindex $pair 0]
					set line $time
					append line " " [lindex $pair 1]
					puts $zit $line
					if {$sw} {
						set line $time
						append line " " $ambstartr
						puts $zit2 $line
						if {$stepfracr > 0.0} {
							set line $time
							append line " " $stepsttr
							puts $zit3 $line
						}
					} else {
						set line $time
						append line " " $ambendr
						puts $zit2 $line
						if {$stepfracr > 0.0} {
							set line $time
							append line " " $stependr
							puts $zit3 $line
						}
					}
					set sw [expr !$sw]
				}
			}
			close $zit
			set fileopen1 0
			close $zit2
			set fileopen2 0
			catch {close $zit3}
			set fileopen3 0
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				UnBlock
				continue
			}
			if {[FileToWkspace $hopoutfile2 0 0 0 0 1] <= 0} {
				UnBlock
				continue
			}
			if {$stepfracr > 0.0} {
				if {[FileToWkspace $hopoutfile3 0 0 0 0 1] <= 0} {
					UnBlock
					continue
				}
			}
			set prm($evv(DR_LOCUS)) $hopoutfile
			set prm($evv(DR_AMBITUS)) $hopoutfile2
			if {($ambstartr > $actvhi($evv(DR_AMBITUS))) || ($ambendr > $actvhi($evv(DR_AMBITUS)))} {
				SwitchRange $evv(DR_AMBITUS) $evv(DR_AMBITUS) 1 1
			}
			if {$stepfracr > 0.0} {
				set prm($evv(DR_STEP)) $hopoutfile3
				set lim [expr $actvhi($evv(DR_STEP)) * $stepfracr]
				if {($ambstartr > $lim) || ($ambendr > $lim)} {
					SwitchRange $evv(DR_STEP) $evv(DR_STEP) 1 1
				}
			}
			UnBlock
			set pr_booze 0
			BakupAmbR
			break
		} else {
			if {$fileopen1} {
				catch {close $zit}
			}
			if {$fileopen2} {
				catch {close $zit2}
			}
			if {$fileopen3} {
				catch {close $zit3}
			}
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Locus Data File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			if {([string length $hopoutfilename2] > 0) && [info exists hopoutfile2] && [file exists $hopoutfile2]} {
				set msg "Destroy The Ambitus Data File '$hopoutfile2' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile2
				}
			}
			if {([string length $hopoutfilename3] > 0) && [info exists hopoutfile3] && [file exists $hopoutfile3]} {
				set msg "Destroy The Step Data File '$hopoutfile3' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile3
				}
			}
			set tipple -1
			break
		}
	}		
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc AmbiSteadyR {} {
	global ambsteadyr ambtstepr
	switch -- $ambsteadyr {
		0 {
			.thopr.10.ll config -text ""
			set ambtstepr ""
			.thopr.10.e config -bd 0 -state disabled
		}
		1 {
			.thopr.10.ll config -text "Duration of Ambitus Change"
			set ambtstepr ""
			.thopr.10.e config -bd 2 -state normal
		}	
	}
}

proc BakupAmbR {} {
	global lastambstartr lastambendr laststepfracr lastambtstepr lastambsteadyr lastambtstepr
	global ambstartr ambendr stepfracr ambtstepr ambsteadyr
	global lasthopsegcntr lasthoptimestepr lasthoprandr 
	global hopsegcntr hoptimestepr hoprandr

 	if {[info exists hopsegcntr]} {
		set lasthopsegcntr $hopsegcntr
	}
	if {[info exists hoptimestepr]} {
		set lasthoptimestepr $hoptimestepr
	}
	if {[info exists hoprandr]} {
		set lasthoprandr $hoprandr
	}
	if {[info exists ambsteadyr]} {
		set lastambsteadyr $ambsteadyr
	}
	if {[info exists ambstartr]} {
		set lastambstartr $ambstartr
	}
	if {[info exists ambendr]} {
		set lastambendr $ambendr
	}
	if {[info exists stepfracr]} {
		set laststepfracr $stepfracr
	}
	if {[info exists ambtstepr]} {
		set lastambtstepr $ambtstepr
	}
}

proc RestoreAmbR {} {
	global lasthoptickr lastambstartr lastambendr laststepfracrrlastambtstepg lastambsteadyr lastambtstepr
	global ambstartr ambendr stepfracr ambtstepr ambsteadyr
	global lasthopsegcntr lasthoptimestepr lasthoprandr 
	global hopsegcntr hoptimestepr hoprandr

	if {[info exists lasthopsegcntr]} {
		set hopsegcntr $lasthopsegcntr
	}
	if {[info exists lasthoptimestepr]} {
		set hoptimestepr $lasthoptimestepr
	}
	if {[info exists lasthoprandr]} {
		set hoprandr $lasthoprandr
	}
	if {[info exists lastambsteadyr]} {
		set ambsteadyr $lastambsteadyr
		AmbiSteadyR
	}
	if {[info exists lastambstartr]} {
		set ambstartr $lastambstartr
	}
	if {[info exists lastambendr]} {
		set ambendr $lastambendr
	}
	if {[info exists laststepfracr]} {
		set stepfracr $laststepfracr
	}
	if {[info exists lastambtstepr] && ([string length $lastambtstepr] > 0)} {
		if {$ambsteadyr} {
			set ambtstepr $lastambtstepr
		}
	}
}

proc StepToAmbitus {} {
	global prm evv pr_stamb chlist stepfrac2 actvhi wl chlist pa hopoutfilename pr_booze tipple rememd wstk
	set ambit $prm($evv(DR_AMBITUS))
	if {[string length $ambit] <= 0} {
		Inf "You Must Give A Value (or A Datafile Of Values) To The Ambitus Parameter On The Parameters Page"
		return
	}
	if {[IsNumeric $ambit]} {
		if {$ambit < 0.0} {
			Inf "You Must Give A Valid Value (or A Datafile Of Values) To The Ambitus Parameter On The Parameters Page"
			return
		} elseif {$ambit == 0.0} {
			Inf "You Have Given The Value Zero To The Ambitus Parameter On The Parameters Page: This Process Would Merely Zero The Step Parameter"
			return
		}
	}
	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set fnam [lindex $chlist 0]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$fnam' Is Not A Soundfile"
		return
	}
	set halfdur [expr $pa($fnam,$evv(DUR)) / 2.0]
	set f .stamb
	if [Dlg_Create $f "LINK STEPSIZE TO AMBITUS SIZE" "set pr_stamb 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		button $f.0.ok -text "Apply" -command "set pr_stamb 1" -width 7 -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_stamb 0" -width 7 -highlightbackground [option get . background {}]
		pack $f.0.ok -side left
		pack $f.0.q -side right
		label $f.1.ll -text "RATIO OF STEP SIZE TO AMBITUS (Range 0 - 1)  "
		entry $f.1.e -textvariable stepfrac2 -width 16
		pack $f.1.ll $f.1.e -side left
		label $f.2.ll -text "Step Datafile Name"
		entry $f.2.e -textvariable hopoutfilename -width 16
		pack $f.2.e $f.2.ll -side right -padx 2
		pack $f.0 $f.1 $f.2 -side top -fill x -expand true -pady 4
		set stepfrac2 ""
		wm resizable $f 1 1
		bind $f <Escape> {set pr_stamb 0}
		bind $f <Return> {set pr_stamb 1}
	}
	set hopoutfilename ""
	if {[IsNumeric $ambit]} {
		$f.2.ll config -text ""
		$f.2.e config -state disabled -bd 0 -disabledbackground [option get . background {}]
	} else {
		$f.2.ll config -text "Step Datafile Name"
		$f.2.e config -state normal -bd 2
	}
	set pr_stamb 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_stamb
	while {!$finished} {
		tkwait variable pr_stamb
		if {$pr_stamb} {
			if {([string length $stepfrac2] <= 0) || ![IsNumeric $stepfrac2] || ($stepfrac2 < 0.0) || ($stepfrac2 > 1.0)} {
				Inf "Invalid Ratio (Range 0 - 1)"
				continue
			}
			if {[IsNumeric $ambit]} {
				set step [expr $ambit * $stepfrac2]
				set prm($evv(DR_STEP)) $step
				if {$step > $actvhi($evv(DR_STEP))} {
					SwitchRange $evv(DR_STEP) $evv(DR_STEP) 1 1
				}
				set pr_booze 0
				break
			}
			if {[string length $hopoutfilename] <= 0} {
				Inf "No Step Datafile Name Entered"
				continue
			}
			if {![ValidCDPRootname $hopoutfilename]} {
				continue
			}
			set hopoutfile [string tolower $hopoutfilename]
				append hopoutfile [GetTextfileExtension brk]
			if {[file exists $hopoutfile]} {
				set msg "File '$hopoutfile' Already Exists: Overwrite It?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {![DeleteNonSndfileFromSystem $hopoutfile]} {
						continue
					}
				} else {
					continue
				}
			}	
			if [catch {open $ambit "r"} zit] {
				Inf "Cannot Open Ambitus Data File '$ambit'"
				continue
			}
			catch {unset nulines}
			set linecnt 1
			set OK 1
			set lasttime 0.0
			while {[gets $zit line] >= 0} {
				catch {unset nuline}
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				set cnt 0
				foreach item $line {
					if {[string length $item] <= 0} {
						continue
					}
					if {![IsNumeric $item]} {
						Inf "The Item $item On Line $linecnt In The Ambitus File Is Not Numeric"
						set OK 0
						break
					}
					lappend nuline $item
					switch -- $cnt {
						0 {
							if {$linecnt == 1} {
								if {$item != 0.0} {
									Inf "first Value In Ambitus File Is Not At Time Zero"
									set OK 0
									break
								}
							} else {
								if {$item <= $lasttime} {
									Inf "Time Values Do Not Advance In Ambitus File (at Line $linecnt)"
									set OK 0
									break
								}
								set lasttime $item
							}
						}
						1 {
							if {$item < 0.0 || $item > $halfdur} {
								Inf "Ambitus Value ($item) On Line $linecnt Is Out Of Range (0 - $halfdur \[half duration of input file\])"
								set OK 0
								break
							}
						}
						default {
							Inf "Too Many Items On Line $linecnt Of The Ambitus Data File"
							set OK 0
							break
						}
					}
					incr cnt
				}
				if {!$OK} {
					break
				}
				if {$cnt != 2} {
					Inf "Line $linecnt Has Too Few Items"
					set OK 0
					break
				}
				lappend nulines $nuline
				incr linecnt
			}
			close $zit
			if {!$OK} {
				set pr_booze 0
				break
			}
			if [catch {open $hopoutfile "w"} zit] {
				Inf "Cannot Open File '$hopoutfile' To Write Step Data"
				continue
			}
			set maxval 0.0
			foreach nuline $nulines {
				set line [lindex $nuline 0]
				set val [expr [lindex $nuline 1] * $stepfrac2]
				if {$val > $maxval} {
					set maxval $val
				}
				append line " " $val
				puts $zit $line
			}	
			close $zit
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				continue
			}
			set prm($evv(DR_STEP)) $hopoutfile
			if {$maxval > $actvhi($evv(DR_STEP))} {
				SwitchRange $evv(DR_STEP) $evv(DR_STEP) 1 1
			}
			set pr_booze 0
			break
		} else {
			catch {close $zit}
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Step Data File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			set tipple -1
			break
		}
	}		
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc BakTimeHop {} {
	global hoptext hopdatainfile hoptickh
	global lasthoptext lasthopdatainfile lasthoptickh

	if {$hopdatainfile >= 0} {
		set lasthopdatainfile $hopdatainfile
	}
	set lasthoptext [$hoptext get 1.0 end]
	set lasthoptickh $hoptickh
}

proc RestoreTimeHop {} {
	global hoptext hopdatainfile hoptickh
	global lasthoptext lasthopdatainfile lasthoptickh

	if {[info exists lasthopdatainfile]} {
		set hopdatainfile $lasthopdatainfile
	}
	if {[info exists lasthoptext]} {
		$hoptext delete 1.0 end
		$hoptext insert 1.0 $lasthoptext
	}
	if {[info exists lasthoptickh]} {
		set hoptickh $lasthoptickh
	}
}

proc RandomRead {} {
	global prm evv pr_rrloc chlist rr_clokrate rr_startr rr_endr wl chlist pa hopoutfilename pr_booze tipple wstk rememd
	if {[llength $chlist] <= 0} {
		Inf "No Soundfile Selected"
		return
	}
	if {[llength $chlist] > 1} {
		Inf "More Than One File Selected"
		return
	}
	set fnam [lindex $chlist 0]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "The Selected File '$fnam' Is Not A Soundfile"
		return
	}
	if {([string length $prm($evv(DR_OUTDUR))] <= 0) || ![IsNumeric $prm($evv(DR_OUTDUR))] || ($prm($evv(DR_OUTDUR)) <= 0.0)} {
		Inf "You Must Give An Outputfile Duration On The Parameters Page"
		return
	}
	set outdur $prm($evv(DR_OUTDUR))
	set dur $pa($fnam,$evv(DUR))
	set f .rrloc
	if [Dlg_Create $f "READ AT RANDOM PLACES" "set pr_rrloc 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bd $evv(SBDR)
		button $f.0.ok -text "Apply" -command "set pr_rrloc 1" -width 7 -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon" -command "set pr_rrloc 0" -width 7 -highlightbackground [option get . background {}]
		pack $f.0.ok -side left
		pack $f.0.q -side right
		label $f.1.ll -text "Minimum Clockrate"
		entry $f.1.e -textvariable rr_clokrate -width 16
		pack $f.1.e $f.1.ll -side left
		label $f.2.ll -text "Start of Read Range"
		entry $f.2.e -textvariable rr_startr -width 16
		pack $f.2.e $f.2.ll -side left
		label $f.3.ll -text "End of Read Range"
		entry $f.3.e -textvariable rr_endr -width 16
		pack $f.3.e $f.3.ll -side left
		pack $f.1.ll $f.1.e -side left
		label $f.4.ll -text "Locus Datafile Name"
		entry $f.4.e -textvariable hopoutfilename -width 16
		pack $f.4.e $f.4.ll -side right -padx 2
		pack $f.0 $f.1 $f.2 $f.3 $f.4 -side top -fill x -expand true -pady 4
		bind $f.1.e <Down> {focus .rrloc.2.e}
		bind $f.2.e <Down> {focus .rrloc.3.e}
		bind $f.3.e <Down> {focus .rrloc.4.e}
		bind $f.4.e <Down> {focus .rrloc.1.e}
		bind $f.1.e <Up> {focus .rrloc.4.e}
		bind $f.2.e <Up> {focus .rrloc.1.e}
		bind $f.3.e <Up> {focus .rrloc.2.e}
		bind $f.4.e <Up> {focus .rrloc.3.e}
		bind $f <Return> {set pr_rrloc 1}
		bind $f <Escape> {set pr_rrloc 0}
		wm resizable $f 1 1
	}
	if {[IsNumeric $prm($evv(DR_TICK))] && [IsNumeric $prm($evv(DR_CLKRND))]} {
		set z [expr ($prm($evv(DR_TICK)) * $prm($evv(DR_CLKRND))) / 2.0]
		set rr_clokrate [expr $z + $prm($evv(DR_TICK))]
	} else {
		set rr_clokrate ""
	}
	set hopoutfilename ""
	set rr_startr 0.0
	set rr_endr $dur
	set pr_rrloc 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_rrloc $f.1.e
	while {!$finished} {
		tkwait variable pr_rrloc
		if {$pr_rrloc} {
			if {([string length $rr_clokrate] <= 0) || ![IsNumeric $rr_clokrate] || ($rr_clokrate < 0.015) || ($rr_clokrate > $dur)} {
				Inf "Invalid Minimum Clockrate (Range 0.015 - $dur)"
				continue
			}
			set effend [expr $dur - $rr_clokrate]
			if {([string length $rr_startr] <= 0) || ![IsNumeric $rr_startr] || ($rr_startr < 0.0) || ($rr_startr > $dur)} {
				Inf "Invalid Start Range (Range 0.0 - $effend \[file duration minus clocktick\])"
				continue
			} elseif {$rr_startr > $effend} {
				set rr_startr $effend
			}
			if {([string length $rr_endr] <= 0) || ![IsNumeric $rr_endr] || ($rr_endr < 0.0) || ($rr_endr > $dur)} {
				Inf "Invalid End Range (Range 0.0 - $effend \[file duration minus clocktick\])"
				continue
			} elseif {$rr_endr > $effend} {
				set rr_endr $effend
			}
			if {[Flteq $rr_startr $rr_endr]} {
				Inf "Range Is Zero: If This Is Correct, Use Locus  $rr_startr  Ambitus  0  Step  0"
				continue
			}
			if {$rr_endr < $rr_startr} {
				set temp $rr_endr
				set rr_endr $rr_startr
				set rr_startr $temp
			}
			if {[string length $hopoutfilename] <= 0} {
				Inf "No Step Datafile Name Entered"
				continue
			}
			if {![ValidCDPRootname $hopoutfilename]} {
				continue
			}
			set hopoutfile [string tolower $hopoutfilename]
			append hopoutfile [GetTextfileExtension brk]
			if {[file exists $hopoutfile]} {
				set msg "File '$hopoutfile' Already Exists: Overwrite It?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {![DeleteNonSndfileFromSystem $hopoutfile]} {
						continue
					}
				} else {
					continue
				}
			}	
			if [catch {open $hopoutfile "w"} zit] {
				Inf "Cannot Open File '$hopoutfile' To Write Step Data"
				continue
			}
			set range [expr $rr_endr - $rr_startr]
			set totdur 0.0
			set step [expr $rr_clokrate / 2.0]
			while {$totdur < $outdur} {
				set val [expr (rand() * $range) + $rr_startr]
				set line $totdur
				append line " " $val
				puts $zit $line
				set totdur [expr $totdur + $step]
			}
			close $zit
			if {[FileToWkspace $hopoutfile 0 0 0 0 1] <= 0} {
				continue
			}
			set prm($evv(DR_LOCUS)) $hopoutfile
			set prm($evv(DR_STEP))  0
			set prm($evv(DR_AMBITUS)) 0
			set pr_booze 0
			break
		} else {
			catch {close $zit}
			if {([string length $hopoutfilename] > 0) && [info exists hopoutfile] && [file exists $hopoutfile]} {
				set msg "Destroy The Locus Data File '$hopoutfile' ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					DeleteNonSndfileFromSystem $hopoutfile
				}
			}
			set tipple -1
			break
		}
	}		
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}


proc LocFoc {wdw up edge} {
	switch -- $wdw {
		".thopg" {
			if {$up} {
				if {$edge || [string match [$wdw.3.e cget -state] "disabled"]} {
					if {[string match [$wdw.10.e cget -state] "disabled"]} {
						focus $wdw.9.e
					} else {
						focus $wdw.10.e
					}
				} else {
					focus $wdw.3.e
				}
			} else {
				if {$edge || [string match [$wdw.10.e cget -state] "disabled"]} {
					if {[string match [$wdw.3.e cget -state] "disabled"]} {
						focus $wdw.4.e
					} else {
						focus $wdw.3.e
					}
				} else {
					focus $wdw.10.e
				}
			}
		}
		".thopr" {
			if {$up} {
				if {[string match [$wdw.10.e cget -state] "disabled"]} {
					focus $wdw.9.e
				} else {
					focus $wdw.10.e
				}
			} else {
				if {[string match [$wdw.10.e cget -state] "disabled"]} {
					focus $wdw.1.e
				} else {
					focus $wdw.10.e
				}
			}
		}
		".nt" {
			if {$up} {
				if {[string match [$wdw.b.he cget -state] "disabled"]} {
					focus $wdw.b.jje
				} elseif {$edge} {
					focus $wdw.b.re
				} else {
					focus $wdw.b.he
				}
			} else {
				if {[string match [$wdw.b.he cget -state] "disabled"]} {
					focus $wdw.b.qe
				} elseif {$edge} {
					focus $wdw.b.he
				} else {
					focus $wdw.b.re
				}
			}
		}
	}
}

#--- Generate individual name for partition file

proc SetPartitionName {n} {
	global pr_partitname partiname play_partition_fname ex_partition_fname wl pa ch chlist chcnt wstk rememd ppart evv
	global last_played readonlyfg readonlybg

	set fnam $evv(DFLT_OUTNAME)
	set thisext [GetTextfileExtension sndlist]
	append fnam $n $thisext
	if {![file exists $fnam]} {
		Inf "This Partition Has Not Been Used"
		set ppart 0
		PartitionReconfig get
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open Partition File '$fnam' To Read It"
		set ppart 0
		PartitionReconfig get
		return
	}
	set f .partitnames
	if [Dlg_Create $f "PARTITIONFILE NAME" "set pr_partitname 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.2
		frame $f.3
		frame $f.3.a
		frame $f.3.b
		button $f.0.k -text "Keep Name" -command "set pr_partitname 1" -highlightbackground [option get . background {}]
		button $f.0.q -text "Abandon Naming" -command "set pr_partitname 0" -width 13 -highlightbackground [option get . background {}]
		pack $f.0.k -side left
		pack $f.0.q -side right 
		pack $f.0 -side top -pady 2 -fill x -expand true
		label $f.2.nx -text "Existing Filename"
		entry $f.2.ex -textvariable ex_partition_fname -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f.2.n -text "New Filename"
		entry $f.2.e -textvariable play_partition_fname
		pack $f.2.n $f.2.e $f.2.nx $f.2.ex -side left -padx 2
		pack $f.2 -side top -pady 2
		label $f.3.a.t -text "DATA IN FILE"
		Scrolled_Listbox $f.3.a.ll -width 60 -height 24 -selectmode single
		pack $f.3.a.t $f.3.a.ll -side top -fill both -expand true
		label $f.3.b.t -text "KNOWN SOUND LISTINGS"
		Scrolled_Listbox $f.3.b.ll -width 60 -height 24 -selectmode single
		pack $f.3.b.t $f.3.b.ll -side top -fill both -expand true
		pack $f.3.a $f.3.b -side left -fill x -expand true
		pack $f.3 -side top
		bind $f.3.b.ll.list <ButtonRelease> {GetPartiName .partitnames.3.b.ll.list %y}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_partitname 0}
		bind $f <Return> {set pr_partitname 1}
	}
	set play_partition_fname ""
	$f.3.a.ll.list delete 0 end
	while {[gets $zit item] >= 0} {
		$f.3.a.ll.list insert end $item
	}
	close $zit
	$f.3.b.ll.list delete 0 end
	foreach item [$wl get 0 end] {
		if {[info exists pa($item,$evv(FTYP))] && [IsASndlist $pa($item,$evv(FTYP))]} {
			$f.3.b.ll.list insert end $item
		}
	}
	if {[info exists partiname($n)]} {
		$f.2.nx config -text "Existing Filename"
		$f.2.ex config -bd 2
		ForceVal $f.2.ex $partiname($n)
		$f.0.q config -text "Keep Old Name"
	} else {
		set ex_partition_fname ""
		$f.2.ex config -bd 0
		$f.2.nx config -text ""
		$f.0.q config -text "Abandon Naming"
	}
	set pr_partitname 0 
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_partitname $f.2.e
	while {!$finished} {
		tkwait variable pr_partitname
		if {$pr_partitname} {
			if {[string length $play_partition_fname] <= 0} {
				Inf "No Filename Entered"
				continue
			}
			set outname [string tolower $play_partition_fname]
			if {![ValidCDPRootname $outname]} {
				continue
			}
			append outname $thisext
			set OK 1
			foreach nam [$f.3.b.ll.list get 0 end] {
				if {[string match $outname $nam]} {
					set msg "Add The Files To The Existing Soundfile Listing '$nam' ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if [string match no $choice] {
						set OK 0 
						break
					}
				}
			}
			if {!$OK} {
				continue
			}
			set partiname($n) $outname
			if {[string length $ex_partition_fname] > 0} {
				$f.2.nx config -text "Existing Filename"
				$f.2.ex config -bd 2
				ForceVal $f.2.ex $partiname($n)
			}
			break
		} else {
			break
		}
	}
	set ppart 0
	if {[UnnamedPartitionFilesExist]} {
		set msg "(Re)Name Other Partitions ?"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if [string match no $choice] {
			catch {unset last_played}
			PartitionReconfig get
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Generate a generic name for partition files

proc SetPartitionGenName {} {
	global play_partition_gen_fname ppr4 wstk pa evv
	global background_listing remembd scores_refresh wl ch chlist chcnt partiname

	set thisext [GetTextfileExtension sndlist]
	if {[string length $play_partition_gen_fname] <= 0} {
		Inf "No Generic Filename Entered"
		return
	}
	set outname [string tolower $play_partition_gen_fname]
	if {![ValidCDPRootname $outname]} {
		return
	}
	set fnam $evv(DFLT_OUTNAME)
	set n 1
	set OK 1
	Block "Checking Names"
	while {$n <= 20} {
		set thisfnam $fnam
		append thisfnam $n $thisext
		if {[file exists $thisfnam]} {
			if {[info exists partiname($n)]} {
				incr n
				continue
			}
			set nufnam $outname
			append nufnam $n $thisext

			if {[info exists partiname]} {
				foreach m [array names partiname] {
					if {[string match $partiname($m) $nufnam]} {
						Inf "The Name '$nufnam' Is Already In Use For One Of The Partition Files"
						UnBlock
						return
					}
				}
			}
			if {[file exists $nufnam] && ![file isdirectory $nufnam]} {
				set ftyp [FindFileType $nufnam]
				if {[IsASndlist $ftyp]} {
					set msg "Soundlisting '$nufnam' Already Exists: Append Data To The Existing File ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if [string match no $choice] {
						Inf "Choose A Different Generic Name For The Partition Files"
						set OK 0
						break
					}
				} else {
					set msg "A File With The Name '$nufnam' Already Exists: Choose A Different Generic Name"
					set OK 0
					break
				}
			}
		}
		incr n
	}
	UnBlock
	if {!$OK} {
		return
	}
	set cnt 0
	set n 1
	Block "Naming Partition Files"
	while {$n <= 20} {
		set thisfnam $fnam
		append thisfnam $n $thisext
		if {[file exists $thisfnam]} {
			if {[info exists partiname($n)]} {
				incr n
				continue
			}
			set nufnam $outname
			append nufnam $n $thisext
			if {[file exists $nufnam]} {
				if [catch {open $thisfnam "r"} zit] {
					Inf "Cannot Open File '$thisfnam' To Read Data"
					lappend badfiles $nufnam
					incr n
					continue
				}
				catch {unset zfiles}
				catch {unset nu_files}
				while {[gets $zit item] >= 0} {
					lappend zfiles $item
				}
				close $zit
				if {[info exists zfiles]} {
					if [catch {open $nufnam "r"} zit] {
						Inf "Cannot Open File '$nufnam' To Read Existing Data"
						lappend badfiles $nufnam
						incr n
						continue
					}
					set zfilesa {}
					while {[gets $zit item] >= 0} {
						lappend zfilesa $zit
					}
					close $zit
					foreach item $zfiles {
						if {[lsearch $zfilesa $item] < 0} {
							lappend nu_files $item
						}
					}
					if [catch {open $nufnam "a"} zit] {
						Inf "Cannot Open File '$nufnam' To Append Data"
						lappend badfiles $nufnam
						incr n
						continue
					}
					foreach zfnam $nu_files {
						puts $zit $zfnam
					}
					close $zit
				}
				set i [LstIndx $nufnam $wl]
				if {$i < 0} {
					FileToWkspace $nufnam 0 0 0 0 1
				} else {
					DoParse $nufnam $wl 0 0
				}
				incr cnt
			} else {
				if [catch {file rename $thisfnam $nufnam} zit] {
					Inf "Cannot Rename File '$thisfnam' To '$nufnam'"
					lappend badfiles $nufnam
					incr n
					continue
				}
				FileToWkspace $nufnam 0 0 0 0 1
				incr cnt
			}
		}
		incr n
	}
	CompletePartinames $fnam $thisext
	if {[info exists badfiles]} {
		if {[llength $badfiles] == $cnt} {
			set msg "Failed To Save Any Partition Files"
		} else {
			set cnt 0
			set msg "Failed To Save The Following Partition Files\n\n"
			foreach fnam $badfiles {
				if {$cnt > 60} {
					append msg "AND MORE"
					break
				}
				append msg $fnam "   "
				incr cnt
			}
		}
		Inf $msg
	}
	UnBlock
	set ppr4 2
}

#----- Get name of existing soundfile listing from display

proc GetPartiName {w y} {
	global play_partition_fname
	set i [$w nearest $y]
	if {$i < 0} {
		return
	}
	set fnam [$w get $i]
	set play_partition_fname [file rootname $fnam]
}

#----- Complete Renaming of individually named partition files

proc CompletePartinames {fnam thisext} {
	global partiname wl 

	set OK 1
	foreach n [array names partiname] {
		set thisfnam $fnam
		append thisfnam $n $thisext
		if {[file exists $partiname($n)]} {
			catch {unset zlist}
			catch {unset zlista}
			catch {unset nu_list}
			if [catch {open $partiname($n) "r"} zit] {
				Inf "Cannot Open File '$partiname($n)' To Update It"
				set OK 0
				continue
			}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[llength $line] > 0} {
					lappend zlist $line
				}
			}
			close $zit
			if [catch {open $thisfnam "r"} zit] {
				Inf "Cannot Open File '$thisfnam' To Read New Data"
				set OK 0
				continue
			}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[llength $line] > 0} {
					lappend zlista $line
				}
			}
			close $zit
			foreach item $zlista {
				if {[lsearch $zlist $item] < 0} {
					lappend nu_list $item
				}
			}
			if {[info exists nu_list]} {
				if [catch {open $partiname($n) "a"} zit] {
					Inf "Cannot Open File '$partiname($n)' To Add New Data"
					set OK 0
					continue
				}
				foreach item $nu_list {
					puts $zit $item
				}
				close $zit
				set i [LstIndx $partiname($n) $wl]
				if {$i < 0} {
					FileToWkspace $partiname($n) 0 0 0 0 1
				} else {
					DoParse $partiname($n) $wl 0 0
				}
			}
		} else {
			if [catch {file rename $thisfnam $partiname($n)} zit] {
				Inf "Cannot Rename '$thisfnam' To '$partiname($n)': $zit"
				set OK 0
			} else {
				FileToWkspace $partiname($n) 0 0 0 0 1
			}
		}
	}
	return $OK
}


proc PartitionReconfig {val} {
	global ppart wstk parchoice partiname last_played partmsg evv
	set n 1
	set partmsg ""
	.pplaylist.buttonm.msg config -background [option get . background {}]
	switch -- $val {
		"get" {
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "PartitionPlayFile $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "PartitionPlayFile $n"
				incr n
			}
			.pplaylist.button4.get config -text "LAST FILE PLAYED TO PARTITION" -bg $evv(EMPH)
			.pplaylist.button4.see config -text "See All Files in Partition" -bg [option get . background {}]
			.pplaylist.button4.nam config -text "(re)Name The Partition" -bg [option get . background {}]
			.pplaylist.button4.del config -text "Delete The Partition" -bg [option get . background {}]
			.pplaylist.button4.edi config -text "Edit The Partition" -bg [option get . background {}]
			.pplaylist.button5.sel config -text "Select Partition to List" -bg [option get . background {}]
			.pplaylist.button5.mer config -text "Merge Selected Partitions" -bg [option get . background {}]
			.pplaylist.button5.cle config -text "Clear Selection List" -bg [option get . background {}]
			set ppart 0
		}
		"see" {
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "PartitionSeeFile $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "PartitionSeeFile $n"
				incr n
			}
			.pplaylist.button4.get config -text "Last File Played to Partition" -bg [option get . background {}]
			.pplaylist.button4.see config -text "SEE ALL FILES IN PARTITION" -bg $evv(EMPH)
			.pplaylist.button4.nam config -text "(re)Name The Partition" -bg [option get . background {}]
			.pplaylist.button4.del config -text "Delete The Partition" -bg [option get . background {}]
			.pplaylist.button4.edi config -text "Edit The Partition" -bg [option get . background {}]
			.pplaylist.button5.sel config -text "Select Partition to List" -bg [option get . background {}]
			.pplaylist.button5.mer config -text "Merge Selected Partitions" -bg [option get . background {}]
			.pplaylist.button5.cle config -text "Clear Selection List" -bg [option get . background {}]
			if {$ppart > 0} { 
				PartitionSeeFile $ppart
			}
		}
		"name" {
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "SetPartitionName $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "SetPartitionName $n"
				incr n
			}
			.pplaylist.button4.get config -text "Last File Played to Partition" -bg [option get . background {}]
			.pplaylist.button4.see config -text "See All Files in Partition" -bg [option get . background {}]
			.pplaylist.button4.nam config -text "(RE)NAME THE PARTITION" -bg $evv(EMPH)
			.pplaylist.button4.del config -text "Delete The Partition" -bg [option get . background {}]
			.pplaylist.button4.edi config -text "Edit The Partition" -bg [option get . background {}]
			.pplaylist.button5.sel config -text "Select Partition to List" -bg [option get . background {}]
			.pplaylist.button5.mer config -text "Merge Selected Partitions" -bg [option get . background {}]
			.pplaylist.button5.cle config -text "Clear Selection List" -bg [option get . background {}]
			if {$ppart > 0} { 
				SetPartitionName $ppart
			}
		}
		"delete" {
			set ppart 0
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "DelPartition $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "DelPartition $n"
				incr n
			}
			.pplaylist.button4.get config -text "Last File Played to Partition" -bg [option get . background {}]
			.pplaylist.button4.see config -text "See All Files in Partition" -bg [option get . background {}]
			.pplaylist.button4.nam config -text "(re)Name The Partition" -bg [option get . background {}]
			.pplaylist.button4.del config -text "DELETE THE PARTITION" -bg $evv(EMPH)
			.pplaylist.button4.edi config -text "Edit The Partition" -bg [option get . background {}]
			.pplaylist.button5.sel config -text "Select Partition to List" -bg [option get . background {}]
			.pplaylist.button5.mer config -text "Merge Selected Partitions" -bg [option get . background {}]
			.pplaylist.button5.cle config -text "Clear Selection List" -bg [option get . background {}]
		}
		"edit" {
			set ppart 0
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "EditPartition $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "EditPartition $n"
				incr n
			}
			.pplaylist.button4.get config -text "Last File Played to Partition" -bg [option get . background {}]
			.pplaylist.button4.see config -text "See All Files in Partition" -bg [option get . background {}]
			.pplaylist.button4.nam config -text "(re)Name The Partition" -bg [option get . background {}]
			.pplaylist.button4.del config -text "Delete The Partition" -bg [option get . background {}]
			.pplaylist.button4.edi config -text "EDIT THE PARTITION" -bg $evv(EMPH)
			.pplaylist.button5.sel config -text "Select Partition to List" -bg [option get . background {}]
			.pplaylist.button5.mer config -text "Merge Selected Partitions" -bg [option get . background {}]
			.pplaylist.button5.cle config -text "Clear Selection List" -bg [option get . background {}]
		}
		"select" {
			set ppart 0
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "SelectPartition $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "SelectPartition $n"
				incr n
			}
			.pplaylist.button4.get config -text "Last File Played to Partition" -bg [option get . background {}]
			.pplaylist.button4.see config -text "See All Files in Partition" -bg [option get . background {}]
			.pplaylist.button4.nam config -text "(re)Name The Partition" -bg [option get . background {}]
			.pplaylist.button4.del config -text "Delete The Partition" -bg [option get . background {}]
			.pplaylist.button4.edi config -text "Edit The Partition" -bg [option get . background {}]
			.pplaylist.button5.sel config -text "SELECT PARTITIONS TO LIST" -bg $evv(EMPH)
			.pplaylist.button5.mer config -text "MERGE SELECTED PARTITIONS" -bg $evv(EMPH)
			.pplaylist.button5.cle config -text "CLEAR SELECTION LIST" -bg $evv(EMPH)
		}
		"merge" {
			catch {unset last_played}
			if {[info exists parchoice]} {
				set msg "Merge Partitions....\n"
				foreach item $parchoice {
					append msg "    $item"
				}
				append msg "\n?????"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if [string match yes $choice] {
					set thisext [GetTextfileExtension sndlist]
					set OK 1
					foreach n $parchoice {
						set fnam $evv(DFLT_OUTNAME)
						append fnam $n $thisext
						if [catch {open $fnam "r"} zit] {
							Inf "Cannot Open Partition File	'$fnam' To Get Data To Merge"
							set OK 0
							break
						}
						while {[gets $zit item] >= 0} {
							lappend zlines $item
						}
						close $zit
					}
					if {$OK} {
						set fnam $evv(DFLT_OUTNAME)
						append fnam [lindex $parchoice 0] $thisext
						if [catch {open $fnam "w"} zit] {
							Inf "Cannot Open Partition File	'$fnam' To Write Merged Data"
						} else {
							foreach item $zlines {
								puts $zit $item
							}
							close $zit
							foreach n [lrange $parchoice 1 end] {
								set fnam $evv(DFLT_OUTNAME)
								append fnam $n $thisext
								if [catch {file delete $fnam} zit] {
									lappend badfiles $fnam
								}
								if {[info exists partiname($n)]} {
									unset partiname($n)
								}
							}
						}
					}
					if {[info exists badfiles]} {
						set msg "Could Not Delete Original Files\n"
						set cnt 0
						foreach item $badfiles {
							if {$cnt > 60} {
								append msg "AND MORE"
								break
							}	
							append msg $item "    "
							incr cnt
						}
						append msg "\nAfter Merging"
						Inf $msg
					}
				}
				unset parchoice
			} else {
				Inf "No Partitions Selected"
			}
			while {$n <= 10} {
				.pplaylist.button1.r$n config -command "PartitionPlayFile $n"
				incr n
			}
			while {$n <= 20} {
				.pplaylist.button2.r$n config -command "PartitionPlayFile $n"
				incr n
			}
			.pplaylist.button4.get config -text "LAST FILE PLAYED TO PARTITION" -bg $evv(EMPH)
			.pplaylist.button4.see config -text "See All Files in Partition" -bg [option get . background {}]
			.pplaylist.button4.nam config -text "(re)Name The Partition" -bg [option get . background {}]
			.pplaylist.button4.del config -text "Delete The Partition" -bg [option get . background {}]
			.pplaylist.button4.edi config -text "Edit The Partition" -bg [option get . background {}]
			.pplaylist.button5.sel config -text "Select Partition to List" -bg [option get . background {}]
			.pplaylist.button5.mer config -text "Merge Selected Partitions" -bg [option get . background {}]
			.pplaylist.button5.cle config -text "Clear Selection List" -bg [option get . background {}]
			set ppart 0
		}
	}
}

#----- See list of all partition names used so far

proc SetAllPartitionNames {} {
	global partiname
	if {[info exists partiname]} {
		foreach n [array names partiname] {
			lappend zlist $n [file rootname $partiname($n)]
		}
	}
	if {[info exists zlist]} {
		set len [llength $zlist]
		set len_less_two [expr $len - 2]
		set n 0
		while {$n < $len_less_two} {
			set nz [lindex $zlist $n]
			incr n
			set nn [lindex $zlist $n]
			incr n
			set m $n
			incr n -2
			while {$m < $len} {
				set mz [lindex $zlist $m]
				incr m
				set mn [lindex $zlist $m]
				incr m -1
				if {$mz < $nz} {
					set zlist [lreplace $m $m $nz]
					set zlist [lreplace $n $n $mz]
					incr n
					incr m
					set zlist [lreplace $m $m $nn]
					set zlist [lreplace $n $n $mm]
					set nz $mz
					set nn $mn
					incr n -1
					incr m -1
				}
				incr m 2
			}
			incr n 2
		}
		set msg "[lindex $zlist 0] : [lindex $zlist 1]"
		foreach {val name} [lrange $zlist 2 end] {
			append msg "\n$val : $name"
		}
	} else {
		set msg "No Partitions Have Been Named"
	}
	Inf $msg
	return
}

#----- Delete a selected partition-listing file

proc DelPartition {n} {
	global partiname last_played evv
	set thisext [GetTextfileExtension sndlist]
	set fnam $evv(DFLT_OUTNAME)
	append fnam $n $thisext
	if {[file exists $fnam]} {
		if [AreYouSure] {
			if [catch {file delete $fnam} zit] {
				Inf "Cannot Delete Temporary Partition File '$fnam'"
			} elseif {[info exists partiname($n)]} {
				unset partiname($n)
			}
		}
	} else {
		Inf "There Are No Sounds In This Partition"
	}
	catch {unset last_played}
	PartitionReconfig get
}

#--- Edit list of files in Partition file listing

proc EditPartition {n} {
	global partiname pr_partied partilines lastpartilines origpartilines wstk ppart evv
	set thisext [GetTextfileExtension sndlist]
	set fnam $evv(DFLT_OUTNAME)
	append fnam $n $thisext
	if {![file exists $fnam]} {
		Inf "There Are No Sounds In This Partition"
		set ppart 0
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open Temporary Partition File '$fnam' To Edit"
		set ppart 0
		return
	}
	catch {unset partilines}
	while {[gets $zit line] >= 0} {
		lappend partilines $line
	}
	close $zit
	if {![info exists partilines]} {
		Inf "There Are No Sounds In This Partition"
		set ppart 0
		return
	}
	set origpartilines $partilines
	set lastpartilines $partilines
	set f .edipar
	if [Dlg_Create $f "EDIT A PARTITION" "set pr_partied 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.1
		frame $f.2
		frame $f.3
		button $f.0.nu -text "Save New Data" -command "set pr_partied 1" -highlightbackground [option get . background {}]
		button $f.0.qu -text "Abandon Edit" -command "set pr_partied 0" -highlightbackground [option get . background {}]
		pack $f.0.nu -side left
		pack $f.0.qu -side right
		button $f.1.del -text "Delete File"  -command "ModParti del" -highlightbackground [option get . background {}]
		button $f.1.res -text "Restore File" -command "ModParti last" -highlightbackground [option get . background {}]
		button $f.1.all -text "Restore All"  -command "ModParti orig" -highlightbackground [option get . background {}]
		pack $f.1.del -side left
		pack $f.1.all $f.1.res -side right -padx 3
		button $f.2.play -text "Play File"   -command "ModParti play" -highlightbackground [option get . background {}]
		pack $f.2.play -side top -pady 2
		Scrolled_Listbox $f.3.ll -width 80 -height 24 -selectmode single
		pack $f.3.ll -side top -fill both -expand true
		pack $f.0 $f.1 -side top -pady 2 -fill x -expand true
		pack $f.2 $f.3 -side top
		wm resizable $f 1 1
		bind $f <Return> {set pr_partied 1}
		bind $f <Escape> {set pr_partied 0}
	}
	$f.3.ll.list delete 0 end
	foreach item $partilines {
		$f.3.ll.list insert end $item
	}
	set pr_partied 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_partied
	while {!$finished} {
		tkwait variable pr_partied
		if {$pr_partied} {
			if {[llength $partilines] == [llength $origpartilines]} {
				break
			} 
			if {[llength $partilines] <= 0} {
				set msg "There Are No Files Left In This Partition: Delete It ?"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Delete Partition File '$fnam'"
				} elseif {[info exists partiname($n)]} {
					unset partiname($n)
				}
				break
			}
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Open Partition File '$fnam' To Write New Data"
				continue
			}
			foreach item $partilines {
				puts $zit $item
			}
			close $zit
			break
		} else {
			break
		}
	}
	set ppart 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#---- Modify list of files in Partition file listing

proc ModParti {val} {
	global partilines lastpartilines origpartilines
	switch -- $val {
		"play" {
			set i [.edipar.3.ll.list curselection]
			if {$i < 0} {
				Inf "No Item Selected"
				return
			}
			PlaySndfile [.edipar.3.ll.list get $i] 0
			return
		}
		"del" {
			set i [.edipar.3.ll.list curselection]
			if {$i < 0} {
				Inf "No Item Selected"
				return
			}
			set lastpartilines $partilines 
			set partilines [lreplace $partilines $i $i]
		}
		"last" {
			set zz $partilines 
			set partilines $lastpartilines
			set lastpartilines $zz
		}
		"orig" {
			set lastpartilines $partilines
			set partilines $origpartilines
		}
	}
	.edipar.3.ll.list delete 0 end
	foreach item $partilines {
		.edipar.3.ll.list insert end $item
	}
}

proc SelectPartition {n} {
	global parchoice evv
	set thisext [GetTextfileExtension sndlist]
	set fnam $evv(DFLT_OUTNAME)
	append fnam $n $thisext
	if {![file exists $fnam]} {
		Inf "There Are No Sounds In This Partition"
		return
	}
	if {[info exists parchoice]} { 
		if {[lsearch $parchoice $n] >= 0} {
			return
		}
	}
	lappend parchoice $n
	set msg "Selected Partitions\n"
	foreach item $parchoice {
		append msg "$item   "
	}
	Inf $msg
}

proc ClearPartitionSelection {} {
	global parchoice ppart
	if {[info exists parchoice]} { 
		unset parchoice
		set ppart 0
		Inf "Selection Cleared"
	} else {
		Inf "No Selection List Exists"
	}
}

proc UnnamedPartitionFilesExist {} {
	global partiname evv
	set made {}
	set named {}
	set n 1
	set thisext [GetTextfileExtension sndlist]
	while {$n <= 20} {
		set fnam $evv(DFLT_OUTNAME)
		append fnam $n $thisext
		if {[file exists $fnam]} {
			lappend made $n
		}
		incr n
	}
	if {[info exists partiname]} {
		foreach n [array names partiname] {
			lappend named $n
		}
	}
	if {[llength $made] > [llength $named]} {
		return 1
	}
	return 0
}

###########################
# PLAY INDIVIDUAL CHANNEL #
###########################

proc PlayChan {} {
	global wl pr_playchan playchan_cmd1 playchan_cmd2 playchan_fnam playchan_chan pa evv
	set i [$wl curselection]
	if {$i < 0} {
		Inf "No Sound Selected"
		return
	}
	if {[llength $i] > 1} {
		Inf "Select A Single Sound"
		return
	}
	set fnam [$wl get $i]
	if {![info exists pa($fnam,$evv(FTYP))]} {
		Inf "Cannot Find Data On Selected Sound"
		return
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Selected File Is Not A Soundfile"
		return
	}
	set chans $pa($fnam,$evv(CHANS))
	if {$chans == 1} {
		Inf "Selected File Is Mono"
		return
	}
	set playchan_chan 0
	set playchan_fnam $evv(DFLT_OUTNAME)
	append playchan_fnam 0 $evv(SNDFILE_EXT)
	set playchan_cmd1 [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend playchan_cmd1 "copy" 1 $fnam $playchan_fnam
	set playchan_cmd2 [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend playchan_cmd2 "chans" 1 $playchan_fnam
	set f .playchan
	if [Dlg_Create $f "CHOOSE A CHANNEL" "set pr_playchan 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.00
		frame $f.1
		button $f.0.qu -text Close -command "set pr_playchan 0" -highlightbackground [option get . background {}]
		pack $f.0.qu -side top
		label $f.00.txt -text "SELECT THE CHANNEL WHICH YOU WANT TO HEAR"
		pack $f.00.txt -side top
		set n 1
		while {$n <= $chans} {
			radiobutton $f.1.r$n -variable playchan_chan -text $n -value $n -command "DoPlayChan"
			pack $f.1.r$n -side left
			incr n
		}
		pack $f.0 $f.00 $f.1 -side top -pady 2			 
		wm resizable $f 1 1
		bind $f <Escape> {set pr_playchan 0}
	}
	set pr_playchan 0
	set finished 0
	raise $f
	My_Grab 0 $f pr_playchan
	tkwait variable pr_playchan
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc DoPlayChan {} {
	global playchan_chan pr_playchan playchan_cmd1 playchan_cmd2 playchan_fnam CDPidrun CDP_cmd prg_dun prg_abortd wstk evv

	set batch_file {}
	lappend batch_file $playchan_cmd1
	set cmd $playchan_cmd2
	lappend cmd $playchan_chan
	lappend batch_file $cmd

	Block "Extracting Channel $playchan_chan"
	foreach line $batch_file {
		set CDP_cmd $line
		set CDPidrun 0
		set prg_dun 0
		set prg_abortd 0
		set sloom_cmd [linsert $CDP_cmd 1 "##"]
		if [catch {open "|$sloom_cmd"} CDPidrun] {
			Inf "$CDPidrun : Channel Extraction Failed"
			DeleteAllTemporaryFiles
			set pr_playchan 0
			UnBlock
			return
	   	} else {
	   		fileevent $CDPidrun readable "Display_PChan_Running_Info"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			Inf "Channel Extraction Failed"
			DeleteAllTemporaryFiles
			set pr_playchan 0
			UnBlock
			return
		}
	}
	if {$prg_dun} {
		set chtext "_c"
		append chtext $playchan_chan
		set fnam [file rootname $playchan_fnam]
		append fnam $chtext $evv(SNDFILE_EXT)
	}
	if {![file exists $fnam]} {
		Inf "Cannot Find Output File 'fnam' To Play"
		DeleteAllTemporaryFiles
		set pr_playchan 0
		UnBlock
		return
	}
	UnBlock
	PlaySndfile $fnam 0
	if [catch {file delete $fnam} zit] {
		Inf "Cannot Delete Temporary File '$fnam'"
	}		
	DeleteAllTemporaryFiles
	set pr_playchan 0
}

#------ Display info returned by running-batchfile in the the program-running display

proc Display_PChan_Running_Info {} {
	global CDPidrun prg_dun prg_abortd
	global bulk super_abort

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match INFO:* $line] {
			return
		} elseif [string match WARNING:* $line] {
			return
		} elseif [string match ERROR:* $line] {
			Inf $line
			set prg_abortd 1
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		} else {
			Inf $line
			set prg_abortd 1
			return
		}
	}
	update idletasks
}

#------ Display info returned by running-batchfile in the the program-running display

proc HandleProcessOutputWithOnlyErrorsDisplayed {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		}
	}
	update idletasks
}

#------ Display info returned by running-batchfile in the the program-running display

proc HandleProcessOutputWithOnlyMaxsampDisplayed {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages fofmaxsamp

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif {[string first "INFO: MAXSAMP" $line] >= 0} {
			set first [string first "INFO: MAXSAMP" $line]
			set fofmaxsamp [string range $line [expr $first + 14] end]
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		}
	}
	update idletasks
}

proc GenInterp {} {
	global interpsrccnt interpsrc genintname evv interp_outlist
	set cnt 0
	set icnt 0
	foreach fnam [.interp.3.ll.list get 0 end] {
		set n 0
		set OK 1
		while {$n < $interpsrccnt} {
			if [string match $fnam $interpsrc($n)] {
				set OK 0
				break
			}
			incr n
		}
		if {!$OK} {
			lappend zlist "#"
		} else {
			lappend zlist $fnam
			incr icnt
		}
		lappend all_list $fnam
		incr cnt
	}
	if {$icnt <= 0} {
		Inf "No Interpolated Files To Rename"
		return
	}
	if {[string length $genintname] <= 0} {
		Inf "No Filename Entered"
		return
	}
	set genintname [string tolower $genintname]
	if {![ValidCDPRootname $genintname]} {
		return
	}
	set len $icnt
	set i 0
	while {$i < $len} {
		set nuname $genintname
		append nuname $i $evv(SNDFILE_EXT)
		if {[file exists $nuname]} {
			Inf "A File With Name '$nuname' Already Exists: Choose A Different Generic Name."
			return
		}
		incr i
	}
	set len $cnt
	set i 0
	set j 1
	while {$i < $len} {
		set fnami [lindex $zlist $i]
		if {![string match $fnami "#"]} {
			set nuname $genintname
			append nuname $j $evv(SNDFILE_EXT)
			if [catch {file rename $fnami $nuname} zit] {
				Inf "Cannot Rename File '$fnami'"
			} else {
				set all_list [lreplace $all_list $i $i $nuname]
				.interp.3.ll.list delete $i
				.interp.3.ll.list insert $i $nuname
			}
			incr j
		}
		incr i
	}
	set interp_outlist $all_list
}

#---------- TIMELINE

proc EstablishTimeline {} {
	global pr_timeline timeline wl pa evv shortwindows
	global timeline_bys timeline_rat timeline_durset timeline_dur timeline_mbyrat
	global tl_lastx tl_zog vsvs_val orig_vsvs_val vscl readonlyfg readonlybg

	foreach fnam [$wl get 0 end] {
		lappend fnams $fnam
	}
	if [GappedNameWarning $fnams] {
		set msg "Some Filenames (or Directory Names) Contain Spaces.\n\n"
		append msg "Do Not Select These Files In The 'Timeline'\n"
		append msg "As A Mixfile Containing Such Names\n"
		append msg "Will Not Be Recognised As A Mixfile\n"
		append msg "By The Soundloom\n"
		WarningShow $msg
		return
	}
	catch {destroy .cpd}
	catch {destroy vsvs_val}
	catch {destroy timeline}
	set timeline(height) 200
	set timeline(width) 900
	set timeline(windowwidth) $timeline(width)
	set timeline(displaywidth) $timeline(width)
	set timeline(maxdur) 7200
	set timeline(mindur) .001
	catch {unset timeline(inmix)}
	set pr_timeline 0
	set f .timeline
	if [Dlg_Create $f "TIMELINE" "set pr_timeline 0" -borderwidth $evv(BBDR) -width $timeline(width)] {
		set help [frame $f.help -borderwidth $evv(SBDR)]
		frame $f.1 -height 1 -bg $evv(POINT)
		set butt [frame $f.buttons -borderwidth $evv(SBDR)]
		set titl [frame $f.titles -borderwidth $evv(SBDR)]
		frame $f.2 -height 2 -bg $evv(POINT)
		frame $f.dur
		set inp  [frame $f.input -borderwidth $evv(SBDR)]
		set tl   [frame $f.tl -borderwidth $evv(SBDR)]
		button $help.hlp -text "Info" -bg $evv(HELP) -command "TimelineHelp" -width 4 -highlightbackground [option get . background {}]
		label $help.dum -text "      "
		button $help.play -text "Play" -command "PlayTimeLine" -width 8 -highlightbackground [option get . background {}]
		label $help.from -text " from "
		entry $help.playe -textvariable timeline(playfrom) -width 6 
		label $help.secs -text " secs"
		label $help.level -text "Overall Gain"
		entry $help.gain -textvariable timeline(gain) -width 6 
		button $help.res -text Levels -command TLResetLevels -highlightbackground [option get . background {}]
		button $help.save -text "Save Mixfile" -command "SaveTimelineMix" -highlightbackground [option get . background {}]
		label $help.ll -text "Mixfile Name  "
		entry $help.e -textvariable timeline(mix) -width 24
		button $help.load -text "Load a Mixfile" -command TimelineFindMixfiles -highlightbackground [option get . background {}]
		label $help.dum2 -text "             "
		button $help.quit -text "Close" -command "set pr_timeline 0" -highlightbackground [option get . background {}]
		pack $help.hlp $help.dum $help.play $help.from $help.playe $help.secs $help.level $help.gain $help.res -side left -padx 1
		pack $help.quit $help.dum2 $help.load $help.e $help.ll $help.save  -side right -padx 1

		label $butt.z -text "Zoom "
		button $butt.zi -text "In" -command "ZoomTimeLine 0" -width 3 -highlightbackground [option get . background {}]
		button $butt.zo -text "Out" -command "ZoomTimeLine 1" -width 3 -highlightbackground [option get . background {}]
		button $butt.min -text "Minimise" -command "MinimiseTimeLine" -width 7 -highlightbackground [option get . background {}]
		button $butt.exp -text "Extend" -command "ExpandTimeLine 0" -width 6 -highlightbackground [option get . background {}]
		button $butt.con -text "Curtail" -command "ExpandTimeLine 1" -width 7 -highlightbackground [option get . background {}]
		label $butt.bysec -text "by "
		entry $butt.bys -textvariable timeline_bysec -width 6
		label $butt.bysec1 -text " secs"
		button $butt.ext -text "Stretch" -command "ExtendTimeLine" -width 7 -highlightbackground [option get . background {}]
		label $butt.byrat -text "ratio"
		entry $butt.byr -textvariable timeline_byrat -width 6
		button $butt.mstr -text "Stretch" -command "ExtendMarks" -width 7 -highlightbackground [option get . background {}]
		label $butt.mbyrat -text "ratio"
		entry $butt.mbyr -textvariable timeline_mbyrat -width 6
		button $butt.clear -text "Clear" -command "ClearTimeLine 1 1" -width 5 -highlightbackground [option get . background {}]
		label $butt.dum -text "            "
		pack $butt.z $butt.zi $butt.zo $butt.mstr $butt.mbyrat $butt.mbyr $butt.clear $butt.dum -side left -padx 2
		pack $butt.byr $butt.byrat $butt.ext $butt.bysec1 $butt.bys $butt.bysec $butt.con $butt.exp $butt.min -side right -padx 2
		frame $titl.1
		label $titl.1.marks -text "                    MARKS"
		pack $titl.1.marks -side top
		frame $titl.2
		label $titl.2.tline -text "TIMELINE                    "
		pack $titl.2.tline -side top
		pack $titl.1 $titl.2 -side left -fill x -expand true
		label $f.dur.ll -text "Timeline Duration"
		entry $f.dur.e -textvariable "timeline_dur" -width 10
		button $f.dur.set -text "Clear & Set" -command "SetTimelineDur 1 1" -highlightbackground [option get . background {}]
		label $f.dur.dum3 -text "       "
		button $f.dur.dur -text "Show Durs" -command "TLShowDurs" -highlightbackground [option get . background {}]
		label $f.dur.mous -text "CLICK: Make Timepoint on Timeline            SHIFT DRAG to move:            ALT CLICK to Delete" -fg $evv(SPECIAL)
		pack $f.dur.ll $f.dur.e $f.dur.set $f.dur.dum3 $f.dur.dur -side left -padx 2 
		pack $f.dur.mous -side right
		frame $inp.1
		frame $inp.2
		label $inp.1.rem -text "CLICK Below to Remove Sound from marker" -fg $evv(SPECIAL)
		label $inp.1.add -text "CLICK Below to Add/Change Sound at marker number " -fg $evv(SPECIAL)
		entry  $inp.1.e -textvariable timeline(no) -width 5 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		radiobutton $inp.1.zz -variable tl_zog -text zero -value -1 -command "TimelineUplist"
		radiobutton $inp.1.up -variable tl_zog -text next -value 0 -command "TimelineUplist"
		radiobutton $inp.1.dn -variable tl_zog -text previous -value 1 -command "TimelineUplist"
		pack $inp.1.rem -side left
		pack $inp.1.dn $inp.1.up $inp.1.zz $inp.1.e $inp.1.add -side right
		frame $inp.2.1
		frame $inp.2.2
		if {[info exists shortwindows]} {
			set timeline(sndlist) [Scrolled_Listbox $inp.2.1.ll -width 32 -height 13 -selectmode single]
			set timeline(srclist) [Scrolled_Listbox $inp.2.2.ll -width 32 -height 13 -selectmode single]
		} else {
			set timeline(sndlist) [Scrolled_Listbox $inp.2.1.ll -width 32 -height 18 -selectmode single]
			set timeline(srclist) [Scrolled_Listbox $inp.2.2.ll -width 32 -height 18 -selectmode single]
		}
		pack $inp.2.1.ll -side top -fill both -expand true
		pack $inp.2.2.ll -side top -fill both -expand true
		pack $inp.2.1 $inp.2.2 -side left -fill x -expand true
		pack $inp.1 $inp.2 -side top -pady 2 -fill x -expand true
		set timeline(can) [Scrolled_LR_Canvas $f.tl.can -width $timeline(width) -height $timeline(height) \
									-scrollregion "0 0 $timeline(width) $timeline(height)" -borderwidth 0 \
			-highlightthickness 1 -highlightbackground $evv(SPECIAL)]
		pack $f.tl.can -side top -fill x -expand true
		$timeline(can) create line 0 100 $timeline(width) 100 -tag axis -fill $evv(POINT)
		$timeline(can) create text 32 12 -text "TIMELINE" -fill $evv(POINT)
		pack $help -side top -fill x -expand true -pady 4
		pack $f.1 -side top -fill x -expand true
		pack $f.dur -side top -fill x -expand true -pady 4
		pack $tl -side top -fill x -expand true -pady 4
		pack $titl -side top -fill x -expand true
		pack $butt -side top -fill x -expand true -pady 4
		pack $f.2 -side top -fill x -expand true
		pack $inp -side top -fill x -expand true -pady 4
		wm resizable $f 1 1
		set timeline_durset 0
		set timeline(markhi) 60
		set timeline(marklo) 140
		bind $timeline(can) <ButtonPress-1>				{TlMakeTimeMark %x %y}
		bind $timeline(can) <Shift-ButtonPress-1>		{TlTimeMarkGet %x %y}
		bind $timeline(can)	<Shift-B1-Motion> 			{TlTimeMarkDrag %x}
		bind $timeline(can)	<ButtonRelease-1>	 		{TlTimeMarkSortAfterMove}
		bind $timeline(can)	<Shift-ButtonRelease-1>	 	{TlTimeMarkSortAfterMove}
		bind $timeline(can)	<Command-ButtonPress-1>			{TlTimeMarkDelete %x %y}
		bind $timeline(srclist) <ButtonRelease-1>		{TlUseSound $timeline(srclist)}
		bind $timeline(sndlist) <ButtonRelease-1>		{TimelineSoundRemove $timeline(sndlist)}
		bind .timeline <Control-Key-P> {UniversalPlay list $timeline(srclist)}
		bind .timeline <Control-Key-p> {UniversalPlay list $timeline(srclist)}
		bind .timeline <Key-space>	   {UniversalPlay list $timeline(srclist)}
		set timeline(snds) {}
		bind $f <Escape> {set pr_timeline 0}
	}
	set timeline(insnds) {}
	set timeline(gain) 1
	ResetTimelineScrollbar
	set timeline(no) 0
	set timeline(playfrom) 0
	ForceVal .timeline.input.1.e $timeline(no)
	set timeline(zoomfact) 0
	set timeline(mix) ""
	set timemarker(no) ""
	set tl_lastx -1
	set timeline_bysec ""
	set timeline_byrat ""
	$timeline(srclist) delete 0 end
	foreach fnam [$wl get 0 end] {
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			$timeline(srclist) insert end $fnam
		}
	}
	if {[info exists timeline(snds)] && ([llength $timeline(snds)] > 0)} {
		set remark_names 0
		set n 0
		foreach fnam $timeline(snds) {
			if {![file exists $fnam]} {
				set timeline(snds) [lreplace $timeline(snds) $n $n ""]
				$timeline(sndlist) delete $n
				$timeline(sndlist) insert $n $n
				set remark_names 1
			}
			incr n
		}
		if {$remark_names} {
			TimeMarkNumbers
		}
	}
	set pr_timeline 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_timeline $f.dur.e
	tkwait variable pr_timeline 
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	catch {destroy $vscl}
	catch {unset vsvs_val}
	catch {unset orig_vsvs_val}
}	 

#---- Remove a sound associated with a timeline marker

proc TimelineSoundRemove {w} {
	global timeline
	set i [$w curselection]
	if {$i < 0} {
		return
	}
	catch {$timeline(can) delete dur}
	set timeline(snds) [lreplace $timeline(snds) $i $i ""]
	set len [llength $timeline(marklist)]
	$timeline(sndlist) delete 0 end
	set z 0
	while {$z < $len} {
		set line $z
		append line "  " [lindex $timeline(snds) $z]
		$timeline(sndlist) insert end $line
		incr z
	}
	TimeMarkNumbers
}

#---- Play mix which timeline represents

proc PlayTimeLine {} {
	global timeline pa evv CDPidrun prg_dun prg_abortd timeline_dur wstk
	if {![CreateTimelineMixfile 1]} {
		return
	}
	if {[IsPositiveNumber $timeline(playfrom)] && ($timeline(playfrom) < $timeline_dur)} {
		if {$timeline(playfrom) >= $timeline(mixdur)} {
			Inf "Time To Play From Is Beyond End Of Mix Sounds"
			return
		}
		set pfrom $timeline(playfrom)
	} elseif {![IsNumeric $timeline(playfrom)] || ![Flteq $timeline(playfrom) 0.0]} {
		set msg "Invalid Time To Play From: Play All Of Mix ?"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	set nam cdptest00
	append nam [GetTextfileExtension mix]
	if [catch {open $nam "w"} zit] {
		Inf "Cannot Open Temporary File '$nam' To Do Mixing"
		return
	}
	foreach line $timeline(playmix) {
		puts $zit $line
	}
	close $zit
	set outnam $evv(DFLT_OUTNAME)
	append outnam 0
	append outnam $evv(SNDFILE_EXT)
	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	append cmd " mix $nam $outnam"
	if {[info exists pfrom]} {
		append cmd " -s$pfrom"
	}
	set CDPidrun 0
	set prg_dun 0
	set prg_abortd 0
	Block "Making the Mix"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "$CDPidrun : Failed To Do Mixing"
		if {[file exists $outnam]} {
			file stat $outnam filestatus
			if {$filestatus(ino) >= 0} {
				catch {close $filestatus(ino)}
			}
			catch {file delete $outnam}
			UnBlock
			return
		}
   	} else {
   		fileevent $CDPidrun readable "Display_Timeline_Mixing"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	UnBlock
	if {!$prg_dun} {
		Inf "Failed To Do Mixing"
		if {[file exists $outnam]} {
			file stat $outnam filestatus
			if {$filestatus(ino) >= 0} {
				catch {close $filestatus(ino)}
			}
			catch {file delete $outnam}
		}
		return
	} elseif {[file exists $outnam]} {
		PlaySndfile $outnam 0			;# PLAY OUTPUT
	}
	file stat $outnam filestatus
	if {$filestatus(ino) >= 0} {
		catch {close $filestatus(ino)}
	}
	catch {file delete $outnam}
}

#---- Save mixfile which timeline represents

proc SaveTimelineMix {} {
	global timeline wl pa files_deleted background_listing rememd wstk vsvs_val evv vscl vsvs_val orig_vsvs_val wstk last_outfile
	if {[string length $timeline(mix)] <= 0} {
		Inf "No Mixfile Name Entered"
		return
	}
	set nam [string tolower $timeline(mix)]
	if {![ValidCDPRootname $nam]} {
		return
	}
	append nam [GetTextfileExtension mix]
	if {[file exists $nam]} {
		set msg "DO YOU WANT TO OVERWRITE THE EXISTING FILE $nam ?"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		if {![DeleteNonSndfileFromSystem $nam]} {
			return
		} 
	}
	if {![CreateTimelineMixfile 0]} {
		return
	}
	if {[info exists timeline(inmix)] && ![info exists vsvs_val]} {
		TimelineSubstitutePanAndLevels
	}
	if [catch {open $nam "w"} zit] {
		Inf "Cannot Open File '$nam' To Store Mix"
		unset {timeline(mixlines)}
		return
	}
	foreach line $timeline(mixlines) {
		puts $zit $line
	}
	close $zit
	if {[FileToWkspace $nam 0 0 0 0 1] > 0} {
		Inf "File '$nam' Has Been Saved To The Workspace"
		set last_outfile $nam
	}
	MixMUpdate $nam 1
	unset {timeline(mixlines)}
	catch {destroy $vscl}
	catch {unset vsvs_val}
	catch {unset orig_vsvs_val}
}

#---- Stretch length of timeline

proc ExtendTimeLine {} {
	global timeline timeline_dur timeline_durset timeline_byrat evv
	if {!$timeline_durset} {
		Inf "Timeline Duration Not Set"
		return
	}
	if {![IsPositiveNumber $timeline_byrat]} {
		Inf "Invalid Stretch Ratio"
		return
	}
	if {($timeline_byrat < 0.1) || ($timeline_byrat > 10)} {
		Inf "Stretch Ratio Out Of Range (0.1 to 10)\nYou Can Do Two Succesive Stretches If Necessary"
		return
	}
	set new_timeline_dur [expr $timeline_dur * $timeline_byrat]
	set len 0
	if {[info exists timeline(marklist)]} {
		set len [llength $timeline(marklist)]
		if {($len > 0) && ($timeline_byrat < 1.0)} {
			set OK 1
			set z $len
			incr z -1
			while {$z >= 0} {
				set x [lindex $timeline(marklist) $z]
				set x [expr int(round($x / $timeline_byrat))]
				if {$x > $timeline(width)} {
					Inf "Marks Will Be Lost From The End Of The Display: Cannot Proceed"
					set OK 0
					break
				}
				incr z -1
			}
			if {!$OK} {
				return
			}
		}
	}
	catch {$timeline(can) delete dur}
	set timeline_dur $new_timeline_dur
	set timeline(width) [expr int(round($timeline(width) * $timeline_byrat))]
	if {$timeline(width) < $timeline(windowwidth)} {
		set subratio [expr double($timeline(width)) / double($timeline(windowwidth))]
		set timeline(width) $timeline(windowwidth)
		if {[info exists timeline(marklist)]} {
			set z 0
			while {$z < $len} {
				set thistag "#"
				append thistag $z
				set obj [$timeline(can) find withtag $thistag]
				set x [lindex $timeline(marklist) $z]
				set x [expr int(round($x / $subratio))]
				set timeline(marklist) [lreplace $timeline(marklist) $z $z $x]
				$timeline(can) delete $obj
				$timeline(can) create line $x $timeline(marklo) $x $timeline(markhi) -fill $evv(POINT) -tag $thistag
				incr z
			}
		}
	}
	ResetTimelineScrollbar
	$timeline(can) delete axis
	set axlen $timeline(width)
	$timeline(can) create line 0 100 $axlen 100 -tag axis -fill $evv(POINT)
	SetTimelineDur 0 0
	TimeMarkNumbers
	SetTimelineZoomfact
}

#---- Change length of timeline

proc ExpandTimeLine {contract} {
	global timeline timeline_dur timeline_durset timeline_bysec evv
	if {!$timeline_durset} {
		Inf "Timeline Duration Not Set"
		return
	}
	if {![IsPositiveNumber $timeline_bysec]} {
		if {$contract} {
			Inf "Invalid Time Contraction"
		} else {
			Inf "Invalid Time Extension"
		}
		return
	}
	if {$contract} {
		set t_bysec [expr -$timeline_bysec]
	} else {
		set t_bysec [expr $timeline_bysec]
	}
	set new_timeline_dur [expr $timeline_dur + $t_bysec]
	if {$new_timeline_dur > $timeline(maxdur)} {
		Inf "New Duration Exceeds 2 hours: Out Of Range"
		return
	} elseif {$new_timeline_dur < $timeline(mindur)} {
		Inf "New Duration Is Less Than a Millisecond: Out Of Range"
		return
	}
	set ratio [expr double($new_timeline_dur) / $timeline_dur]
	set new_timeline_width [expr int(round($timeline(width) * $ratio))]
	set len 0
	if {[info exists timeline(marklist)]} {
		set len [llength $timeline(marklist)]
		if {($len > 0) && $contract} {
			set OK 1
			set z $len
			incr z -1
			while {$z >= 0} {
				set x [lindex $timeline(marklist) $z]
				if {$x > $new_timeline_width} {
					Inf "Marks Will Be Lost From The End Of The Display: Cannot Proceed"
					set OK 0
					break
				}
				incr z -1
			}
			if {!$OK} {
				return
			}
		}
	}
	catch {$timeline(can) delete dur}
	set timeline_dur $new_timeline_dur
	set timeline(width) [expr int(round($timeline(width) * $ratio))]
	if {$timeline(width) < $timeline(windowwidth)} {
		set subratio [expr double($timeline(width)) / double($timeline(windowwidth))]
		set timeline(width) $timeline(windowwidth)
		set z 0
		while {$z < $len} {
			set thistag "#"
			append thistag $z
			set obj [$timeline(can) find withtag $thistag]
			set x [lindex $timeline(marklist) $z]
			set x [expr int(round($x / $subratio))]
			set timeline(marklist) [lreplace $timeline(marklist) $z $z $x]
			$timeline(can) delete $obj
			$timeline(can) create line $x $timeline(marklo) $x $timeline(markhi) -fill $evv(POINT) -tag $thistag
			incr z
		}
	}
	SetTimelineDur 0 0
	ResetTimelineScrollbar
	$timeline(can) delete axis
	set axlen $timeline(width)
	$timeline(can) create line 0 100 $axlen 100 -tag axis -fill $evv(POINT)
	TimeMarkNumbers
	SetTimelineZoomfact
}

#------ Scrolled Canvas, to display, and operate on, Instrument-Tree

proc Scrolled_LR_Canvas { c args } {
	global evv
	frame $c -borderwidth $evv(SBDR)
	eval {canvas $c.canvas -xscrollcommand [list $c.xscroll set] \
						   -highlightthickness 2 -borderwidth 0} $args
	scrollbar $c.xscroll -orient horizontal -command [list $c.canvas xview]
	grid $c.canvas -sticky news
	grid $c.xscroll -sticky ew
	grid rowconfigure $c 0 -weight 1 		;#	i.e. the scollbars keep their width
	grid columnconfigure $c 0 -weight 1
	return $c.canvas
}

#------ (re)Set Duration that timeline represents

proc SetTimelineDur {init clear_inmix} {
	global timeline_dur timeline_durset timeline evv

	if {$init} {
		ClearTimeLine 0 $clear_inmix
	}
	if {![IsPositiveNumber $timeline_dur]} {
		Inf "Invalid Timeline Duration"
		return
	}
	if {$timeline_dur > $timeline(maxdur)} {
		Inf "Duration too long (over 2 hours)"
		return
	}
	set timeline_dur [DecPlaces $timeline_dur 5]
	catch {$timeline(can) delete dura}
	$timeline(can) create text 150 12 -text "Duration : $timeline_dur" -tag dura -fill $evv(POINT)
	set timeline_durset 1
}

#------ Call the Timemark drawing routine

proc TlMakeTimeMark {x y} {
	global tl_lastx timeline_durset
	catch {unset timeline(anchor)}
	if {!$timeline_durset} {
		Inf "No Timeline Duration Has Been Set"
		return
	}
	if {$y < 0} {
		return
	}
	set x [GetTrueX $x]
	TlDrawTimeMark $x
	set tl_lastx -1
}

#------ Find closest marker to start dragging it

proc TlTimeMarkGet {x y} {
	global tl_tag tl_lastx timeline timeline_durset
	catch {unset timeline(anchor)}
	catch {$timeline(can) delete dur}
	if {!$timeline_durset} {
		Inf "No Timeline Duration Has Been Set"
		return
	}
	if {$y < 0} {
		return
	}
	set x [GetTrueX $x]
	if {![info exists timeline(marklist)] || ([llength $timeline(marklist)] <= 0)} {
		set tl_lastx -1
		return
	}
	set min [expr abs($x - [lindex $timeline(marklist) 0])]
	set minpos 0
	set cnt 1
	foreach val [lrange $timeline(marklist) 1 end] {
		set thismin [expr abs($x - $val)]
		if {$thismin < $min} {
			set min $thismin
			set minpos $cnt
		}
		incr cnt
	}
	set tl_tag "#"
	append tl_tag $minpos
	set thisobj [$timeline(can) find withtag $tl_tag]
	set val [lindex [$timeline(can) coords $thisobj] 0]
	if {![IsNumeric $val]} {
		unset tl_tag
		return
	}
	set tl_lastx [expr int(round($val))]
	set timeline(anchor) $tl_lastx
}

#----- Drag marker with mouse

proc TlTimeMarkDrag {x} {
	global tl_lastx timeline false_x
	if {($tl_lastx < 0) || ![info exists timeline(anchor)]} {
		return
	}
	set x [GetTrueX $x]
	if {[info exists false_x]} {
		if {($false_x < 0) || ($false_x >= $timeline(width))} {
			return
		}
	} elseif {($x < 0) || ($x >= $timeline(width))} {
		return
	}
	set moveby [expr $x - $timeline(anchor)]
	TlStep $moveby
	set timeline(anchor) $x
}

#------ Move marker by steps

proc TlStep {step} {
	global tl_lastx timeline tl_tag false_x evv

	if {$tl_lastx < 0} {
		set tl_lastx -1
		return
	} elseif {$tl_lastx == 0} {
		if {$step < 0} {
			return
		}
	} elseif {[info exists false_x]} {
		if {$false_x >= $timeline(width)} {
			if {$step > 0} {
				return
			}
		}
	} elseif {$tl_lastx >= $timeline(width)} {
		if {$step > 0} {
			return
		}
	}
	set tl_lastx [expr int(round($tl_lastx + $step))]
	$timeline(can) delete $tl_tag
	$timeline(can) create line $tl_lastx $timeline(marklo) $tl_lastx $timeline(markhi) -fill $evv(POINT) -tag $tl_tag
}

#------ Sort timeline markers when one is moved

proc TlTimeMarkSortAfterMove {} {
	global timeline
	if {![info exists timeline(anchor)]} {
		return
	}
	TlTimeMarkSort 1
	unset timeline(anchor)
}

#------ Sort timeline markers, once they have been created or moved

proc TlTimeMarkSort {postdrag} {
	global tl_tag timeline tl_lastx tl_orig tl_new tl_add

	if {![info exists tl_tag]} {
		return
	}
	catch {unset tl_orig}
	catch {unset tl_new}
	set ggg [string range $tl_tag 1 end]
	if {![info exists timeline(marklist)] || ([llength $timeline(marklist)] <= 0)} {
		if {$ggg < 0} {		;#	 If new mark
			set obj [$timeline(can) find withtag $tl_tag]
			$timeline(can) addtag "#0" withtag $tl_tag
			$timeline(can) dtag $obj $tl_tag
			set timeline(marklist) [lindex [$timeline(can) coords $obj] 0]
		}
		set tl_lastx -1
		catch {unset tl_tag}
		set tl_add 0
		TimeMarkNumbers
		return
	}
	set orig_listlen [llength $timeline(marklist)]
	set obj [$timeline(can) find withtag $tl_tag]
	set this_x [lindex [$timeline(can) coords $obj] 0]
	set cnt 0
	foreach x $timeline(marklist) {
		if {$this_x <= $x} {
			break
		}
		incr cnt
	}
	if {$cnt >= [llength $timeline(marklist)]} {	;#	Mark at end of list
		if {$ggg < 0} {
			set newtag "#"
			append newtag $cnt
			lappend timeline(marklist) $this_x
			set obj [$timeline(can) find withtag $tl_tag]
			$timeline(can) addtag $newtag withtag $tl_tag
			$timeline(can) dtag $obj $tl_tag
			unset tl_tag
			set tl_add $cnt
			TimeMarkNumbers
			return
		}
	}
	if {$postdrag} {
		if {($cnt == $ggg) || ($cnt == [expr $ggg + 1])} {	;#	Mark still at same position in list
			set timeline(marklist) [lreplace $timeline(marklist) $ggg $ggg $this_x]
			unset tl_tag
			TimeMarkNumbers
			return
		}
	} 
	set newpos $cnt
	set atend 0
	if {$cnt == [llength $timeline(marklist)]} {
		if {$postdrag} {
			incr newpos -1
		}
		set atend 1
	}
	if {$newpos < $ggg} {
		set timeline(marklist) [lreplace $timeline(marklist) $ggg $ggg]			;#	Delete orig
		set timeline(marklist) [linsert $timeline(marklist) $newpos $this_x]  ;#	Reinsert at position below
	} else {
		if {$atend} {
			lappend timeline(marklist) $this_x
		} else {
			set timeline(marklist) [linsert $timeline(marklist) $newpos $this_x]	;#	Insert at position above
		}
		if {$ggg >= 0} {									;#	If not a new mark
			set timeline(marklist) [lreplace $timeline(marklist) $ggg $ggg]		;#	Delete orig
		}
	}
	if {$ggg >= 0} {
		set newtag "#"
		append newtag -1										;# If not a new mark
		set obj [$timeline(can) find withtag $tl_tag]			;#	mark with a -1
		$timeline(can) addtag $newtag withtag $tl_tag
		$timeline(can) dtag $obj $tl_tag
	}
	if {$postdrag} {
		set tl_orig $ggg
		set tl_new $newpos
		if {$ggg < $newpos} {
			if {$atend} {
				incr newpos
			}
			set tl_orig $ggg
			set tl_new $newpos
			incr newpos -1
			set start [expr $ggg + 1]
			set top [expr $newpos + 1]
			set cnt $start
			while {$cnt < $top} {
				set oldtag "#"
				append oldtag $cnt
				set newtag "#"
				append newtag [expr $cnt - 1]
				set obj [$timeline(can) find withtag $oldtag]
				$timeline(can) addtag $newtag withtag $oldtag
				$timeline(can) dtag $obj $oldtag
				incr cnt
			}
		} else {
			set start $newpos
			set top $ggg
			set q $top
			incr q -1
			while {$q >= $cnt} {
				set oldtag "#"
				append oldtag $q
				set newtag "#"
				append newtag [expr $q + 1]
				set obj [$timeline(can) find withtag $oldtag]
				$timeline(can) addtag $newtag withtag $oldtag
				$timeline(can) dtag $obj $oldtag
				incr q -1
			}
		}
	} else {
		set tl_add $newpos
		set q $orig_listlen
		incr q -1
		while {$q >= $cnt} {
			set oldtag "#"
			append oldtag $q
			set newtag "#"
			append newtag [expr $q + 1]
			set obj [$timeline(can) find withtag $oldtag]
			$timeline(can) addtag $newtag withtag $oldtag
			$timeline(can) dtag $obj $oldtag
			incr q -1
		}
	}
	set oldtag "#"
	append oldtag -1
	set newtag "#"
	append newtag $newpos
	set obj [$timeline(can) find withtag $oldtag]
	$timeline(can) addtag $newtag withtag $oldtag
	$timeline(can) dtag $obj $oldtag
	set tl_lastx -1
	unset tl_tag
	TimeMarkNumbers
}

#--- Draw marker on Timeline

proc TlDrawTimeMark {x} {
	global timeline tl_tag false_x evv
	if {$x < 0} {
		set x 0
	} elseif {[info exists false_x]} {
		if {$false_x >= $timeline(width)} {
			set x $timeline(windowwidth)
			incr x -1
		}
	} elseif {$x >= $timeline(width)} {
		set x $timeline(width)
		incr x -1
	}
	set tl_tag "#"
	append tl_tag -1
	$timeline(can) create line $x $timeline(marklo) $x $timeline(markhi) -fill $evv(POINT) -tag $tl_tag
	TlTimeMarkSort 0
}

#--- Remove all timeline markers and associated sound info

proc ClearTimeLine {ask clear_insnds} {
	global wstk timeline vsvs_val tl_del
	if {$ask} {
		set msg "Are You Sure You Want To Clear The Timeline Display ?"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
	}
	if {$clear_insnds} {
		set timeline(insnds) {}
		catch {unset timeline(inmix)}
		set timeline(snds) {}
		catch {unset vsvs_vals}
		catch {unset orig_vsvs_vals}
	}
	catch {$timeline(can) delete dur}
	catch {unset timeline(mixlines)}
	catch {unset vsvs_val}
	if {[info exists timeline(marklist)] && ([llength $timeline(marklist)] > 0)} {
		set len [llength $timeline(marklist)]
		set cnt -1
		while {$cnt < $len} {
			set thistag "#"
			append thistag $cnt
			set obj [$timeline(can) find withtag $thistag]
			if {[llength $obj] > 0} {
				catch {$timeline(can) delete $obj}
			}
			incr cnt
		}
		catch {unset timeline(marklist)}
		set timeline(no) 0
		ForceVal .timeline.input.1.e $timeline(no)
		catch {unset tl_del}
		catch {$timeline(can) delete num}
		catch {$timeline(can) delete timer}
	}
	$timeline(sndlist) delete 0 end
	set timeline(width) $timeline(windowwidth)
	ResetTimelineScrollbar
}

#--- Delete a timeline marker

proc TlTimeMarkDelete {x y} {
	global tl_tag tl_lastx timeline timeline_durset tl_del vsvs_val
	catch {unset timeline(anchor)}

	if {!$timeline_durset} {
		Inf "No Timeline Duration Has Been Set"
		return
	}
	if {$y < 0} {
		return
	}
	catch {$timeline(can) delete dur}
	set x [GetTrueX $x]
	if {![info exists timeline(marklist)] || ([llength $timeline(marklist)] <= 0)} {
		set tl_lastx -1
		return
	}
	set min [expr abs($x - [lindex $timeline(marklist) 0])]
	set minpos 0
	set cnt 1
	foreach val [lrange $timeline(marklist) 1 end] {
		set thismin [expr abs($x - $val)]
		if {$thismin < $min} {
			set min $thismin
			set minpos $cnt
		}
		incr cnt
	}
	set z 0
	while {$z < [llength $timeline(marklist)]} {
		if {$z >= $minpos} {
			set oldtag "#"
			append oldtag $z
			if {$z == $minpos} {
				$timeline(can) delete $oldtag
			} else {
				set newtag "#"
				append newtag [expr $z - 1]
				set obj [$timeline(can) find withtag $oldtag]
				$timeline(can) addtag $newtag withtag $oldtag
				$timeline(can) dtag $obj $oldtag
			}
		}
		incr z
	}
	set timeline(marklist) [lreplace $timeline(marklist) $minpos $minpos]
	set tl_del $minpos
	TimeMarkNumbers
}

#---- (re)Number the markers on the Timeline diplay

proc TimeMarkNumbers {} {
	global timeline timeline_dur tl_orig tl_new tl_del tl_add evv
	catch {$timeline(can) delete num}
	catch {$timeline(can) delete timer}
	$timeline(sndlist) delete 0 end			
	if {![info exists timeline(marklist)] || ([llength $timeline(marklist)] <= 0)} {
		set timeline(no) 0
		catch {unset tl_del}
		ForceVal .timeline.input.1.e $timeline(no)
		return
	}
	if {[info exists tl_del]} {								;#	DELETED MARK
		set timeline(snds) [lreplace $timeline(snds) $tl_del $tl_del]
	} elseif {[info exists tl_add]} {						;#	NEW MARK
		set timeline(snds)	[linsert $timeline(snds) $tl_add ""]
		set timeline(no) $tl_add
	} elseif {[info exists tl_orig]} {						;#	MOVED MARK
		set old_snd [lindex $timeline(snds) $tl_orig]
		if {$tl_new > $tl_orig} {
			set timeline(snds) [linsert $timeline(snds) $tl_new $old_snd]
			set timeline(snds) [lreplace $timeline(snds) $tl_orig $tl_orig]
		} else {
			set timeline(snds) [lreplace $timeline(snds) $tl_orig $tl_orig]
			set timeline(snds) [linsert $timeline(snds) $tl_new $old_snd]
		}
	}
	set len [llength $timeline(marklist)]
	set timeratio [expr double($timeline_dur) / $timeline(width)]
	set z 0
	while {$z < $len} {
		set thissnd [lindex $timeline(snds) $z]
		set line $z
		append line "  " $thissnd
		$timeline(sndlist) insert end $line
		set thissnd [file rootname [file tail $thissnd]]
		if {[string length $thissnd] > 9} {
			set thissnd [string range $thissnd 0 8]
			append thissnd "..."
		}
		set time [lindex $timeline(marklist) $z]
		set time [FiveSigFig [expr $time * $timeratio]]
		set thistag "#"
		append thistag $z
		set obj [$timeline(can) find withtag $thistag]
		set x [lindex [$timeline(can) coords $obj] 0]
		$timeline(can) create text $x 48 -text $z -tag num -fill $evv(POINT)
		$timeline(can) create text $x 152 -text $thissnd -tag num -fill $evv(POINT) -anchor w
		$timeline(can) create text $x 170 -text $time -tag num -tag timer -fill $evv(POINT)
		incr z
	}
	RearrangeLevels
	catch {unset tl_orig}
	catch {unset tl_new}
	catch {unset tl_add}
	catch {unset tl_del}
	if {$timeline(no) >= [llength $timeline(marklist)]} {
		set timeline(no) 0
		ForceVal .timeline.input.1.e $timeline(no)
	}
}

#---- Select sound to associate with timeline marker

proc TlUseSound {w} {
	global timeline pa evv
	catch {unset timeline(anchor)}
	set i [$w curselection]
	if {$i < 0} {
		return
	}
	set fnam [$w get $i]
	if {![info exists timeline(marklist)]} {
		Inf "No Time Markers Exist"
		return
	}
	set len [llength $timeline(marklist)]
	if {![regexp {^[0-9]+$} $timeline(no)]} {
		Inf "Invalid Marker Number '$timeline(no)'"
		return
	}
	if {$timeline(no) >= $len} {
		Inf "Marker Number '$timeline(no)' Does Not Exist"
		return
	}
	set cnt 0
	foreach thisfnam $timeline(snds) {
		if {$cnt != $timeline(no)} {
			if {([string length $thisfnam] > 0) && [file exists $thisfnam]} {
				set srate $pa($thisfnam,$evv(SRATE))
				break
			}
		}
		incr cnt
	}
	if [info exists srate] {
		if {$pa($fnam,$evv(SRATE)) != $srate} {
			Inf "Incompatible sample rate ($pa($fnam,$evv(SRATE))): other files have srate $srate"
			return
		}
	}
	catch {$timeline(can) delete dur}
	set timeline(snds) [lreplace $timeline(snds) $timeline(no) $timeline(no) $fnam]
	$timeline(sndlist) delete 0 end			
	set z 0
	while {$z < $len} {
		set line $z
		append line "  " [lindex $timeline(snds) $z]
		$timeline(sndlist) insert end $line
		incr z
	}
	TimeMarkNumbers
}

#---- Converts screen coords to true "screen" coords, where display area is > ||  < actual window width

proc GetTrueX {x} {
	global timeline false_x
	if {$timeline(width) < $timeline(windowwidth)} {
		set ratio [expr double($timeline(width)) / $timeline(windowwidth)]
		set false_x [expr $x * $ratio]
	} else {
		catch {unset false_x}
		set bas [expr $timeline(width) * [lindex [$timeline(can) xview] 0]]
		set x [expr $x + $bas]
	}
	return $x
}

#---- Converts x true value to actual screen coords, where display area is > ||  < actual window width

proc GetInverseTrueX {x} {
	global timeline false_x
	if {$timeline(width) < $timeline(windowwidth)} {
		set ratio [expr double($timeline(windowwidth)) / $timeline(width)]
		set false_x [expr $x * $ratio]
	} else {
		catch {unset false_x}
		set x 
		set bas [expr $timeline(width) * [lindex [$timeline(can) xview] 0]]
		set x [expr $x - $bas]
	}
	return $x
}

#---- Creates lines for a mixfile, from timeline screen data

proc CreateTimelineMixfile {play} {
	global timeline pa evv timeline_dur vsvs_val wstk
	if {![info exists timeline(marklist)] || ([llength $timeline(marklist)] <=0)} {
		return 0
	}
	if {$play} {
		if {![IsPositiveNumber $timeline(gain)]} {
			Inf "Invalid Value For Gain"
			return 0
		}
		set gain $timeline(gain)
	} else {
		set gain 1.0
		if {[IsPositiveNumber $timeline(gain)] &&(($timeline(gain) < 1.0) || ($timeline(gain) > 1.0))} {
			set msg "Incorporate Overall Gain Of $timeline(gain) In Final Mix ?"
			set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				set gain $timeline(gain)
			}
		}
	}
	if {$play} {
		catch {unset timeline(playmix)}
	} else {
		catch {unset timeline(mixlines)}
	}
	set timeline(mixdur) 0.0
	if {![info exists timeline(snds)]} {
		Inf "No Sounds Specified"
		return 0
	}
	set len [llength $timeline(marklist)]
	set timeratio [expr double($timeline_dur) / $timeline(width)]

	set from_pre_existing_mix 0
	if {[llength $timeline(insnds)] > 0} {
		set from_pre_existing_mix 1
		foreach snd $timeline(snds) {		;#	Are all the output sounds derived from an input mixfile
			if {[string length $snd] <= 0} {
				continue
			}
			if {[lsearch $timeline(insnds) $snd] < 0} {
				set from_pre_existing_mix 0
				break
			}
		}
	}
	set n 0
	foreach snd $timeline(snds) {
		if {$from_pre_existing_mix} {
			set k [lsearch $timeline(insnds) $snd]
		}
		if {[string length $snd] <= 0} {
			continue
		}
		if [info exists vsvs_val($n)] {
			set level $vsvs_val($n)
		} elseif {$from_pre_existing_mix} {
			set level [lindex [lindex $timeline(inmix) $k] 3]
		} else {
			set level 1.0
		}
		if {$from_pre_existing_mix} {
			set tail [lrange [lindex $timeline(inmix) $k] 4 end]
			if {[llength $tail] > 1} {
				set level2 [lindex [lindex $timeline(inmix) $k] 5]
			} else {
				set level2 ""
			}
		} else {
			set tail ""
			set level2 ""
		}
		lappend levels $level
		lappend levels2 $level2
		lappend tails $tail
		incr n
	}
	set z 0
	set cnt 0
	while {$z < $len} {
		set snd [lindex $timeline(snds) $z]
		if {[string length $snd] <= 0} {
			incr z
			continue
		}
		set time [lindex $timeline(marklist) $z]
		set time [expr $time * $timeratio]
		if {![info exists pa($snd,$evv(FTYP))]} {
			Inf "Cannot Retrieve Information On Sound '$snd'"
			return 0
		}
		set chan $pa($snd,$evv(CHANS))
		if {$chan > 2} {
			Inf "'$snd' Has More Than 2 Channels\nThis Process Only Works With Mono & Stereo Files"
			return 0
		}
		lappend times $time
		lappend snds $snd
		lappend chans $chan
		set end($cnt) [expr $pa($snd,$evv(DUR)) + $time]
		if {$end($cnt) > $timeline(mixdur)} {
			set timeline(mixdur) $end($cnt)
		}
		incr cnt
		incr z
	}
	if {$cnt == 0} {
		Inf "No Sounds Specified"
		return 0
	}
	set z 0
	while {$z < $cnt} {
		set snd [lindex $snds $z]
		set time [lindex $times $z]
		set chan [lindex $chans $z]
		set level [lindex $levels $z]
		set level [expr $level * $gain]
		set line "$snd $time $chan $level"
		if {$from_pre_existing_mix} {
			set line [concat $line [lindex $tails $z]]
			set level2 [lindex $levels2 $z]
			if {[string length $level2] > 0} {
				set line [lreplace $line 5 5 $level]
			}
		}
		if {$play} {
			lappend timeline(playmix) $line
		} else {
			lappend timeline(mixlines) $line
		}
		incr z
	}
	if {$play} {
		if {![info exists timeline(playmix)]} {
			Inf "No Valid Soundfile Information Found"
			return 0
		}
	} else {
		if {![info exists timeline(mixlines)]} {
			Inf "No Valid Soundfile Information Found"
			return 0
		}
	}
	return 1
}

#------ Display info returned by Timeling mix creation prog

proc Display_Timeline_Mixing {} {
	global CDPidrun prg_dun prg_abortd evv
	global bulk super_abort

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match INFO:* $line] {
			return
		} elseif [string match WARNING:* $line] {
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		} elseif [string match ERROR:* $line] {
			Inf $line
			set prg_abortd 1
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		} elseif [string match TIME:* $line] {
			return
		} else {
			return
		}
	}
	update idletasks
}

#---- Reposition Timeline scrollbar if timeline is resized

proc ResetTimelineScrollbar {} {
	global timeline
	$timeline(can) config -scrollregion "0 0 $timeline(width) $timeline(height)"
	$timeline(can) xview moveto 1.0
	$timeline(can) xview moveto 0.0
}

#---- Test Routine

proc TlTest {z} {
	global timeline
	set testmsg "$z\n"
	set z 0
	while {$z < [llength $timeline(marklist)]} {
		set newtag "#"
		append newtag $z
		set obj [$timeline(can) find withtag $newtag]
		append testmsg "obj = $obj : tag = $newtag pos = [lindex [$timeline(can) coords $obj] 0]\n"
		incr z
	}
	append testmsg "timeline(marklist) = $timeline(marklist)"
	Inf $testmsg
}

#---- Stretch length of timeline

proc ZoomTimeLine {out} {
	global timeline timeline_dur timeline_durset evv
	if {!$timeline_durset} {
		Inf "Timeline Duration Not Set"
		return
	}
	if {$out} {
		if {$timeline(zoomfact) == 0} {
			if {$timeline(width) > $timeline(windowwidth)} {
				set ratio [expr double($timeline(windowwidth)) / double($timeline(width))]
			} else {
				Inf "No Further Zoom Possible"
				return
			}
		} else {
			set ratio 0.5
			incr timeline(zoomfact) -1
		}
	} else {
		if {$timeline(zoomfact) == 10} {
			Inf "No Further Zoom Possible"
			return
		}
		set ratio 2.0
		incr timeline(zoomfact)
	}
	catch {$timeline(can) delete dur}
	set timeline(width) [expr int(round($timeline(width) * $ratio))]
	ResetTimelineScrollbar
	$timeline(can) delete axis
	if {$timeline(width) < $timeline(windowwidth)} {
		set axlen $timeline(windowwidth)
	} else {
		set axlen $timeline(width)
	}
	$timeline(can) create line 0 100 $axlen 100 -tag axis -fill $evv(POINT)
	SetTimelineDur 0 0
	set z 0
	set len 0
	if {[info exists timeline(marklist)]} {
		set len [llength $timeline(marklist)]
	}
	while {$z < $len} {
		set thistag "#"
		append thistag $z
		set obj [$timeline(can) find withtag $thistag]
		set x [lindex $timeline(marklist) $z]
		set x [expr int(round($x * $ratio))]
		set timeline(marklist) [lreplace $timeline(marklist) $z $z $x]
		$timeline(can) delete $obj
		$timeline(can) create line $x $timeline(marklo) $x $timeline(markhi) -fill $evv(POINT) -tag $thistag
		incr z
	}
	TimeMarkNumbers
}

#---- Increment value in number box

proc TimelineUplist {} {
	global timeline tl_zog
	if {![info exists timeline(marklist)] || ($tl_zog < 0)} {
		set timeline(no) 0
		set tl_zog 0
	} else {
		if {$tl_zog} {
			set incval -1
		} else {
			set incval 1
		}
		set len [llength $timeline(marklist)]
		if {$len <= 0} {
			set timeline(no) 0
		}
		incr len -1
		if {$tl_zog} {
			incr timeline(no) -1
			if {$timeline(no) < 0} {
				set timeline(no) $len
			}
		} else {
			incr timeline(no)
			if {$timeline(no) > $len} {
				set timeline(no) 0
			}
		}
	}
	ForceVal .timeline.input.1.e $timeline(no)
}

proc TimelineHelp {} {
	set msg "TIMELINE\n"
	append msg "\n"
	append msg "The timeline is a tool for testing of\n"
	append msg "placement of sounds in time, and level setting.\n"
	append msg "\n"
	append msg "(1) CREATING A MIX\n"
	append msg "Associate sounds with (movable) time-markers\n"
	append msg "on a timeline, and play the resulting sequence.\n"
	append msg "\n"
	append msg "You can save what you hear as a mixfile\n"
	append msg "for further, more detailed, work.\n"
	append msg "\n"
	append msg "(2) REARRANGING AN EXISTING MIX\n"
	append msg "You can load an existing mixfile,\n"
	append msg "and move sounds about on the timeline.\n"
	append msg "\n"
	append msg "In this case, if you save the Timeline output\n"
	append msg "as a new mixfile, it will preserve other details\n"
	append msg "of the mix (differences in channel levels, panning).\n"
	append msg "\n"
	append msg "NB: In either case....\n"
	append msg "Zooming out too far will reduce the time-accuracy\n"
	append msg "of existing marks.\n"
	Inf $msg
}

#-----Load a mixfile

proc TimelineLoadMix {} {
	global timeline wl false_x pa evv timeline_dur vsvs_val wstk inmix_has_duplicates vsvs_val 

	catch {unset timeline(inmix)}
	catch {unset timeline(mixlines)}
	catch {unset vsvs_val}
	if {[string length $timeline(mix)] <= 0} {
		Inf "No Filename Entered"
		return
	}
	set mixname $timeline(mix)
	if {[string length [file extension $mixname]] <= 0} {
		append mixname [GetTextfileExtension mix]
	}
	if {![file exists $mixname]} {
		Inf "File '$mixname' Does Not Exist"
		return
	}
	if [catch {open $mixname "r"} zit] {
		Inf "Cannot Open Mixfile '$mixname' To Read Data"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		set line [split $line]
		set cnt 0
		catch {unset zline}
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			switch -- $cnt {
				0 {
					lappend snds $item
				}
				1 {
					lappend times $item
				}
				3 {
					lappend levels $item
				}
			}
			lappend zline $item
			incr cnt
		}
		if {$cnt < 4} {
			Inf "Invalid Mixfile"
			close $zit
			catch {unset timeline(inmix)}
			return
		}
		lappend timeline(inmix) $zline
	}
	close $zit
	set ccnt 0
	set inmix_has_duplicates 0
	foreach snd $snds {
		if {[LstIndx $snd $wl] < 0} {
			Inf "File '$snd' Is Not On The Workspace: Cannot Proceed"
			catch {unset timeline(inmix)}
			return
		}
		if {!$inmix_has_duplicates && ($ccnt > 0)} {
			foreach snd2 [lrange $snds 0 [expr $ccnt - 1]] {
				if [string match $snd $snd2] {
					catch {unset timeline(inmix)}
					set msg "This File Contains Duplicates Of The File '$snd'"
					append msg "\nIn Such Cases The Timeline Cannot Keep Track Of Which Copy Is Which"
					append msg "\nAnd Hence Cannot retain the Original Mixfile Pan And Level Data"
					append msg "\n\nThe Output Will Be A Mixfile With Standard Positions\nand Equal Levels For All Files"
					append msg "\n\nDo You Want To Proceed ??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						return
					} else {
						set inmix_has_duplicates 1
					}
				}
			}
		}
		incr ccnt
	}
	foreach time $times {
		if {![IsNumeric $time] || ($time < 0.0)} {
			Inf "Time $time Is Not Valid For A Mixfile: Cannot Proceed"
			catch {unset timeline(inmix)}
			set timeline(insnds) {}
			return
		}
	}
	ClearTimeLine 0 0
	set timeline(width) $timeline(windowwidth)
	catch {unset false_x}
	set end 0
	foreach snd $snds time $times {
		set thisend [expr $time + $pa($snd,$evv(DUR))]
		if {$thisend > $end} {
			set end $thisend
		}
	}
	set timeline_dur $end
	SetTimelineDur 1 0
	if {[info exists timeline(inmix)]} {
		set timeline(insnds) $snds
		set timeline(gain) 1
	}
	catch {unset timeline(marklist)}
	set ratio [expr double($timeline(width)) / $timeline_dur]
	foreach time $times {
		set x [expr int(round($time * $ratio))]
		TlDrawTimeMark $x
	}
	foreach time $times snd $snds {
		set x [expr int(round($time * $ratio))]
		set snd [file rootname [file tail $snd]]
		if {[string length $snd] > 9} {
			set snd [string range $snd 0 8]
			append snd "..."
		}
		$timeline(can) create text $x 152 -text $snd -tag num -fill $evv(POINT) -anchor w
	}
	set len [llength $snds]
	catch {unset timeline(snds)}
	$timeline(sndlist) delete 0 end			
	set z 0
	while {$z < $len} {
		set line $z
		set snd [lindex $snds $z]
		append line "  " $snd
		$timeline(sndlist) insert end $line
		lappend timeline(snds) $snd
		incr z
	}
	ResetTimelineScrollbar
	if {[info exists timeline(inmix)]} {
		set timeline(mixsnds) $timeline(inmix)
	}
	catch {unset vsvs_val}
}

#---- Stretch position of marks

proc ExtendMarks {} {
	global timeline timeline_durset timeline_mbyrat evv
	if {!$timeline_durset} {
		Inf "Timeline Duration Not Set"
		return
	}
	if {![info exists timeline(marklist)] || ([llength $timeline(marklist)] <= 0)} {
		Inf "No Timemarks Exist"
		return
	}
	if {![IsPositiveNumber $timeline_mbyrat]} {
		Inf "Invalid Stretch Ratio"
		return
	}
	if {($timeline_mbyrat < 0.1) || ($timeline_mbyrat > 10)} {
		Inf "Stretch Ratio Out Of Range (0.1 to 10)\nYou Can Do Two Succesive Stretches If Necessary"
		return
	}
	catch {$timeline(can) delete dur}
	set len [llength $timeline(marklist)]
	if {$timeline_mbyrat > 1.0} {
		set OK 1
		set z $len
		incr z -1
		while {$z >= 0} {
			set x [lindex $timeline(marklist) $z]
			set x [expr int(round($x * $timeline_mbyrat))]
			if {$x > $timeline(width)} {
				Inf "Marks Will Be Lost From The End Of The Display: Cannot Proceed"
				set OK 0
				break
			}
			incr z -1
		}
		if {!$OK} {
			return
		}
	}
	set z 0
	while {$z < $len} {
		set thistag "#"
		append thistag $z
		set obj [$timeline(can) find withtag $thistag]
		set x [lindex $timeline(marklist) $z]
		set x [expr int(round($x * $timeline_mbyrat))]
		set timeline(marklist) [lreplace $timeline(marklist) $z $z $x]
		$timeline(can) delete $obj
		$timeline(can) create line $x $timeline(marklo) $x $timeline(markhi) -fill $evv(POINT) -tag $thistag
		incr z
	}
	TimeMarkNumbers
}

proc MinimiseTimeLine {} {
	global timeline_dur timeline timeline_byrat

	set timetomarkratio [expr double($timeline_dur) / $timeline(width)]
	set lasttime [lindex $timeline(marklist) end]
	set lasttime [expr $lasttime * $timetomarkratio]
	set len [llength $timeline(marklist)]
	set len_plus_one [expr $len + 1]
	set ratio [expr double($len_plus_one)/double($len)]
	set lasttime [expr $lasttime * $ratio]
	if {$lasttime >= $timeline_dur} {
		return
	}
	catch {$timeline(can) delete dur}
	set timeratio [expr double($lasttime) / $timeline_dur]
	set zzz $timeline_byrat
	set timeline_byrat $timeratio
	ExtendTimeLine
	set timeline_byrat $zzz
}

proc TimelineSubstitutePanAndLevels {} {
	global timeline
	foreach outline $timeline(mixlines) {
		set outline [split $outline]
		set outfnam [lindex $outline 0]
		if {[string match [string index $outfnam 0] ";"]} {
			continue
		}
		foreach inline $timeline(inmix) {
			set infnam [lindex $inline 0]
			if {[string match $infnam $outfnam]} {
				set nuline [lrange $outline 0 1]
				set lineend [lrange $inline 2 end]				
				set nuline [concat $nuline $lineend]
				lappend nulines $nuline
				break
			}
		}
	}
	unset timeline(mixlines)
	foreach line $nulines {
		set line [join $line]
		lappend timeline(mixlines) $line
	}
}

proc TLShowDurs {} {
	global timeline timeline_dur pa evv

	if {![info exists timeline(marklist)]} {
		return
	}
	set timeratio [expr double($timeline(width)) / $timeline_dur]
	set len [llength $timeline(marklist)]
	set z 0
	while {$z < $len} {
		set fnam [lindex $timeline(snds) $z]
		if {[string length $fnam] <= 0} {
			incr z
			continue
		}
		set endx [expr int(round($pa($fnam,$evv(DUR)) * $timeratio))]
		set thistag "#"
		append thistag $z
		set obj [$timeline(can) find withtag $thistag]
		set coords [$timeline(can) coords $obj]
		set x [lindex $coords 0]
		set endx [expr int(round($x + $endx))]
		set coords [linsert $coords 2 $endx 100]
		eval {$timeline(can) create poly} $coords {-tag dur -stipple gray12 -fill $evv(POINT)}
		incr z
	}
}

proc SetTimelineZoomfact {} {
	global timeline evv
	set z [expr double($timeline(width)) / double($timeline(windowwidth))]
	set timeline(zoomfact) [expr int(round(log($z) * $evv(ONE_OVER_LN2)))]
}

proc TimelineFindMixfiles {} {
	global wl evv pa pr_tlmix wstk timeline
	foreach fnam [$wl get 0 end] {
		if {[IsAMixfile $pa($fnam,$evv(FTYP))]} {
			lappend mix_files $fnam
		}
	}
	if {![info exists mix_files]} {
		Inf "There Are No Mixfiles On The Workspace"
		return
	}
	if {[llength $mix_files] == 1} {
		set timeline(mix) $mix_files	
		TimelineLoadMix
		return
	}
	set callcentre [GetCentre [lindex $wstk end]]
	set f .tlmix
	if [Dlg_Create $f "MIXFILES" "set pr_tlmix 0" -borderwidth $evv(BBDR)] {
		button $f.quit -text "Close" -command "set pr_tlmix 0" -highlightbackground [option get . background {}]
		label $f.tell -text "Click on any Mixfile, to select it"
		pack $f.quit $f.tell -side top -pady 2
		Scrolled_Listbox $f.ll -width 32 -height 18 -selectmode single
		pack $f.ll -side top -fill both -expand true
		wm resizable $f 1 1
		bind $f.ll.list <ButtonRelease-1> {TimelineGrabMix}
		bind $f <Escape> {set pr_tlmix 0}
	}
	set pr_tlmix 0
	foreach fnam $mix_files {
		$f.ll.list insert end $fnam
	}
	raise $f
	update idletasks
	set geo [CentreOnCallingWindow $f $callcentre]
	My_Grab 0 $f pr_tlmix $f.ll.list
	wm geometry $f $geo
	tkwait variable pr_tlmix
	My_Release_to_Dialog $f
	if {$pr_tlmix} {
		TimelineLoadMix
	}
	Dlg_Dismiss $f
}

proc TimelineGrabMix {} {
	global timeline pr_tlmix
	set i [.tlmix.ll.list curselection]
	set timeline(mix) [.tlmix.ll.list get $i]
	set pr_tlmix 1
}

proc TLResetLevels {} {
	global timeline pr_tl_levels vscl vsvs_val wstk evv inmix_has_duplicates orig_vsvs_val tl_lev

	if {![info exists timeline(snds)]} {
		return
	}
	foreach item $timeline(snds) {
		if {[llength $item] <= 0} {
			Inf "Not Every Mark Has Been Assigned A Sound"
			return
		}
	}
	if {[info exists vsvs_val]} {
		foreach n [array names vsvs_val] {
			set orig_vsvs_val($n) $vsvs_val($n)
		}
	}
	if {![info exists inmix_has_duplicates]} {
		set inmix_has_duplicates 0
	}
	catch {unset timeline(origlevels)}
	if [info exists timeline(mixlines)] {
		set len [llength $timeline(snds)]
		set cnt 0
		foreach line $timeline(mixlines) {
			if {$cnt >= $len} {
				break
			}
			set level [lindex $line 2]
			lappend timeline(origlevels) $level
			incr cnt
		}
		while {$cnt < $len} {
			set level 1.0
			lappend timeline(origlevels) $level
			incr cnt
		}
	} else {
		if {[llength $timeline(snds)] <= 0} {
			Inf "No Sounds Chosen For Timeline"	
			return
		}
		set from_pre_existing_mix 1
		foreach snd $timeline(snds) {		;#	Are all the output sounds derived from an input mixfile
			if {[string length $snd] <= 0} {
				continue
			}
			if {[lsearch $timeline(insnds) $snd] < 0} {
				set from_pre_existing_mix 0
				break
			}
		}
		if {$from_pre_existing_mix} {
			foreach snd $timeline(snds) {
				if {[string length $snd] <=0} {
					continue
				}
				if {!$inmix_has_duplicates} {
					set k [lsearch $timeline(insnds) $snd]
					set level [lindex [lindex $timeline(inmix) $k] 3]
				} else {
					set level 1.0
				}
				lappend timeline(origlevels) $level
			}
		} else {
			foreach snd $timeline(snds) {
				if {[string length $snd] <=0} {
					continue
				}
				set level 1.0
				lappend timeline(origlevels) $level
			}
		}
	}
	if {[llength $timeline(origlevels)] > 25} {
		Inf "Too Many Sounds To Display"	
		return
	}
	set callcentre [GetCentre [lindex $wstk end]]
	set f .tl_levels
	if [Dlg_Create $f "LEVELS" "set pr_tl_levels 0" -borderwidth $evv(BBDR)] {
		frame $f.top -width 160
		button $f.top.q -text "Close" -command "set pr_tl_levels 0" -highlightbackground [option get . background {}]
		button $f.top.s -text "Keep Levels" -command "set pr_tl_levels 1" -highlightbackground [option get . background {}]
		button $f.top.ch1 -text "Flatten" -command {ResetTlLevels 0} -highlightbackground [option get . background {}]
		button $f.top.ch2 -text "Restore" -command {ResetTlLevels 1} -highlightbackground [option get . background {}]
		pack $f.top.s -side left
		pack $f.top.q $f.top.ch2 $f.top.ch1 -side right
		pack $f.top -side top -fill x -expand true
		set n 0
		set k 0
		while {$n < [llength $timeline(origlevels)]} {
			if {$n == 0} {
				frame $f.z
				label $f.z.ll -text ""
				label $f.z.ch -text "Flatten"
				label $f.z.ch2 -text "Restore"
				pack $f.z.ll $f.z.ch $f.z.ch2 -side top
				pack $f.z -side left -anchor n
			}
			frame $f.$n
			while {[string length [lindex $timeline(snds) $k]] <= 0} {
				incr k
			}
			label $f.$n.ll -text $k
			radiobutton $f.$n.ch -variable tl_lev($n) -command "TlNorm $n" -value 0
			radiobutton $f.$n.ch2 -variable tl_lev($n) -command "TlNorm $n" -value 1
			set tl_lev($n) 0
			incr k
			entry $f.$n.e -textvariable vsvs_val($n) -width 5
			set vscl($n) [MakeVertScale $f.$n $n [lindex $timeline(origlevels) $n]]
			pack $f.$n.ll $f.$n.ch $f.$n.ch2 $vscl($n) $f.$n.e -side top
			pack $f.$n -side left
			incr n
		}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_tl_levels 0}
		bind $f <Return> {set pr_tl_levels 1}
	}
	if {[info exists orig_vsvs_val]} {
		foreach n [array names orig_vsvs_val] {
			set vsvs_val($n) $orig_vsvs_val($n)
		}
	}
	set n 0
	while {$n < [llength $timeline(origlevels)]} {
		SetVsliderFromVal $n
		incr n
	}
	set pr_tl_levels 0
	raise $f
	update idletasks
	set geo [CentreLowOnCallingWindow $f $callcentre]
	My_Grab 0 $f pr_tl_levels
	wm geometry $f $geo
	tkwait variable pr_tl_levels
	if {$pr_tl_levels} {
		ResetTlmixLevels
	}
	My_Release_to_Dialog $f
	catch {destroy $vscl}
	catch {unset vsvs_val}
	catch {unset orig_vsvs_val}
	Dlg_Dismiss $f
}

proc MakeVertScale {f n lev} {
	global vsvs vsvs_val evv
	set scale_len $evv(SCALELEN)
	incr scale_len $evv(SLIDERSIZE)
	set w [canvas $f.$n -width $evv(SLIDERSIZE) -height $scale_len -highlightthickness 0]
	$w create rect 0 0 $evv(SLIDERSIZE) $scale_len -fill [option get . troughColor {}] -tag slide
	$w create rect 0 0 $evv(SLIDERSIZE) $evv(SLIDERSIZE) -fill $evv(PBAR_DONECOLOR) -width 2 -tag slider
	$w bind slider <Button-1> "VScaleMark %W %y $n"
	$w bind slider <Button1-Motion> "VScaleDrag %W %y $n"
	$w bind slide <ButtonRelease-1> "VScaleChange %W %y $n"
	set vsvs_val($n) $lev
	return $w
}

proc VScaleMark {w x n} {
	global vsvs vsmark
	set vsmark($n) $vsvs($n)
}

#------ Move slider on display, and reset val in entrybox

proc VScaleDrag {w y n} {
	global vsvs vsmark vsvs_val evv
	set y1 $vsmark($n)
	set vsmark($n) $y
	set dy [expr $y - $y1]
	if {$vsvs($n) + $dy < 0} {
		set dy -$vsvs($n)
	} elseif {$vsvs($n) + $dy > $evv(SCALELEN)} {
		set dy [expr $evv(SCALELEN) - $vsvs($n)]
	}
	$w move slider 0 $dy
	incr vsvs($n) $dy
	set vsvs_val($n) [SetValFromVslider $n]

}

proc SetValFromVslider {n} {
	global vsvs vscl evv

	set vsvs($n) [expr int(round([lindex [$vscl($n) coords slider] 1]))]
	set val [expr double($vsvs($n)) / $evv(SCALELEN)]
	set val [expr $val * 2.0]
	set val [expr 2.0 - $val]
	return $val
}

proc SetVsliderFromVal {n} {
	global vsvs vsvs_val vsmark vscl evv

	set val [expr $vsvs_val($n) / 2.0]
	set val [expr int(round($val * $evv(SCALELEN)))]
	set vsvs($n) [expr $evv(SCALELEN) -  $val]
	set y1 [expr $vsvs($n) + $evv(SLIDERSIZE)]
	if [catch {$vscl($n) coords slider 0 $vsvs($n) $evv(SLIDERSIZE) $y1} zit] {
		return
	}
	set vsmark($n) $vsvs($n)
}

#------ Move slider on display, and reset val in entrybox

proc VScaleChange {w y n} {
	global vsvs vsvs_val evv
	if {$y > $evv(SCALELEN)} {
		set y $evv(SCALELEN)
	}
	set dy [expr $y - $vsvs($n)]
	$w move slider 0 $dy
	set vsvs($n) [expr int(round ($y))]
	set vsvs_val($n) [SetValFromVslider $n]
}

proc ResetTlmixLevels {} {
	global timeline vsvs_val timeline_dur pa evv
	if [info exists timeline(mixlines)] {
		set n 0
		foreach line $timeline(mixlines) {
			set newlevel $vsvs_val($n)
			set line [lreplace $line 3 3 $newlevel]
			if {[llength $line] >= 6} {
				set origlevel [lindex $timeline(origlevels) $n]
				set ratio [expr $newlevel / double($origlevel)]
				set level [lindex $line 5]
				set level [expr $level * $ratio]
				set line [lreplace $line 5 5 $level]
			}
			lappend nulines $line
			incr n
		}
	} else {
		if {[llength $timeline(snds)] <= 0} {
			Inf "No Sounds Chosen For Timeline"	
			return
		}
		set from_pre_existing_mix 1
		foreach snd $timeline(snds) {		;#	Are all the output sounds derived from an input mixfile
			if {[string length $snd] <= 0} {
				continue
			}
			if {[lsearch $timeline(insnds) $snd] < 0} {
				set from_pre_existing_mix 0
				break
			}
		}
		set timeratio [expr double($timeline_dur) / $timeline(width)]
		set n 0
		foreach snd $timeline(snds) {
			if {[string length $snd] <= 0} {
				continue
			}
			set time [lindex $timeline(marklist) $n]
			set time [expr $time * double($timeratio)]
			if {$from_pre_existing_mix} {
				set k [lsearch $timeline(insnds) $snd]				
				set inline [lindex $timeline(inmix) $k]
				set line $snd
				lappend line $time
				lappend line $vsvs_val($n)
				if {[llength $inline] > 4} {
					lappend line [lindex $inline 4]
				}
				if {[llength $inline] > 5} {
					set origlevel [lindex $timeline(origlevels) $n]
					set ratio [expr $vsvs_val($n) / double($origlevel)]
					set level [lindex $inline 5]
					set level [expr $level * $ratio]
					lappend line $level
					lappend line [lindex $inline 6]
				}
			} else {
				set line [list $snd $time $pa($snd,$evv(CHANS)) $vsvs_val($n)]
			}
			lappend nulines $line
			incr n
		}
	}
	set timeline(mixlines) $nulines
}

proc CentreLowOnCallingWindow {win centre} {
	set xy [wm geometry $win]
	set xy [split $xy x+]
	set w [lindex $xy 0]
	set h [lindex $xy 1]
	set hw [expr $w/2]
	set x [expr [lindex $centre 0] - $hw]
	set y [lindex $centre 1]
	set geo $w
	append geo x $h + $x + $y
	return $geo
}

proc ResetTlLevels {restore} {
	global vsvs_val orig_vsvs_val
	if {![info exists vsvs_val]} {
		return
	}
	if {$restore} {
		if {![info exists orig_vsvs_val]} {
			return
		}
		set lenorig [llength [array names orig_vsvs_val]]
		set len [llength [array names vsvs_val]]
		set cnt 0
		foreach n [array names orig_vsvs_val] {
			if {$cnt >= $len} {
				break
			}
			set vsvs_val($n) $orig_vsvs_val($n)
			SetVsliderFromVal $n
			incr cnt
		}
		while {$cnt < $len}  {
			set vsvs_val($cnt) 1.0
			SetVsliderFromVal $cnt
			incr cnt
		}
	} else {
		foreach n [array names vsvs_val] {
			set orig_vsvs_val($n) $vsvs_val($n)
			set vsvs_val($n) 1.0
			SetVsliderFromVal $n
		}
	}
}

proc RearrangeLevels {} {
	global tl_del tl_add tl_orig tl_new timeline vsvs_val
	if {![info exists vsvs_val]} {
		return
	}
	set len [llength [array names vsvs_val]]
	if {[info exists tl_del]} {								;#	DELETED MARK
		incr len -1
		if {$tl_del > $len} {
			return
		}
		foreach n [array names vsvs_val] {
			if {$n > $tl_del} {
				set vsvs_val([expr $n - 1]) $vsvs_val($n)
			}
		}
		unset vsvs_val($len)		;# redundant
	} elseif {[info exists tl_add]} {						;#	NEW MARK
		if {$tl_add > [expr $len - 1]} {
			return
		}
		set n $len
		while {$n > $tl_add} {
			set vsvs_val($n) $vsvs_val([expr $n - 1]) 
			incr n -1
		}
		set vsvs_val($tl_add) 1.0
	} elseif {[info exists tl_orig]} {						;#	MOVED MARK
		if [info exists vsvs_val($tl_orig)] {
			set origlev $vsvs_val($tl_orig)	;# KEEP orig VALUE
		}
		if {$tl_new > $tl_orig} {
			if {![info exists vsvs_val($tl_orig)]} {
				return
			}
			if [info exists vsvs_val([expr $tl_new - 1])] {
				set do_replace 1
			}
			set len [llength [array names vsvs_val]]
			set n $len
			while {$n > $tl_new} {					;# INSERT NEW
				set vsvs_val($n) $vsvs_val([expr $n - 1]) 
				incr n -1
			}
			if [info exists do_replace] {			;# IF VAL HAS BEEN INSERTED, vsvs_val($tl_new) MUST EXIST
				set vsvs_val($n) $origlev
			}
			set len [llength [array names vsvs_val]]
			incr len -1
			set n $tl_orig
			while {$n < $len} {
				set vsvs_val($n) $vsvs_val([expr $n + 1])
				incr n
			}
			unset vsvs_val($len)					;# DUMP LAST VAL (REDUNDANT)
		} else {
			if {![info exists vsvs_val($tl_new)]} {
				return
			}
			set len [llength [array names vsvs_val]]
			if [info exists vsvs_val($tl_orig)] {
				foreach n [array names vsvs_val] {	;# DELETE ORIG
					if {$n > $tl_orig} {
						set vsvs_val([expr $n - 1]) $vsvs_val($n)
					}
				}
				incr len -1						;# DUMP LAST VAL (either ORIG or redundant)
				unset vsvs_val($len)
			}
			set len [llength [array names vsvs_val]]
			set n $len
			while {$n > $tl_new} {					;# INSERT NEW
				set vsvs_val($n) $vsvs_val([expr $n - 1]) 
				incr n -1
			}
			if {[info exists origlev]} {
				set vsvs_val($n) $origlev
			} else {
				set vsvs_val($n) 1.0
			}
		}
	}
}

proc TlNorm {n} {
	global vsvs_val orig_vsvs_val tl_lev
	if {$tl_lev($n)} {
		if [info exists orig_vsvs_val($n)] {
			set vsvs_val($n) $orig_vsvs_val($n)
			SetVsliderFromVal $n
		}
	} else {
		set orig_vsvs_val($n) $vsvs_val($n)
		set vsvs_val($n) 1.0
		SetVsliderFromVal $n
	}
}

proc PartitionPlayNext {} {
	global part_pll pll_selectt partmsg partstart
	set partmsg ""
	.pplaylist.buttonm.msg config -background [option get . background {}]
	if {$partstart} {
		set pll_selectt 0
		set partstart 0
	} else {
		set i [$part_pll curselection]
		if {$i > 0}  {
			set pll_selectt $i
			incr pll_selectt
		} elseif {![info exists pll_selectt]} {
			set pll_selectt 0
		} else {
			incr pll_selectt
		}
	}
	$part_pll yview moveto [expr double($pll_selectt)/double([$part_pll index end])]
	$part_pll selection clear 0 end
	$part_pll selection set $pll_selectt
	PlaySelectedSndfile $part_pll
}

proc PartitionPlayFirst {} {
	global part_pll pll_selectt partmsg partstart
	set partmsg ""
	set partstart 0
	.pplaylist.buttonm.msg config -background [option get . background {}]
	set pll_selectt 0
	$part_pll yview moveto [expr double($pll_selectt)/double([$part_pll index end])]
	$part_pll selection clear 0 end
	$part_pll selection set $pll_selectt
	PlaySelectedSndfile $part_pll
}

proc PartitionPlayAgain {} {
	global part_pll pll_selectt partmsg
	set partmsg ""
	.pplaylist.buttonm.msg config -background [option get . background {}]
	PlaySelectedSndfile $part_pll
}

proc ClearMsgAndPlayPartitionFile {} {
	global part_pll pll_selectt partmsg partstart
	if {$partstart} {
		set partstart 0
	}
	set partmsg ""
	set i [$part_pll curselection]
	if {$i >= 0} {
		set pll_selectt $i
	}
	.pplaylist.buttonm.msg config -background [option get . background {}]
	PlaySelectedSndfile $part_pll
}

proc GappedName {fnams} {
	foreach fnam $fnams {
		set fnam [string trim $fnam]
		set fnam [split $fnam]
		set k [llength $fnam]
		if {$k > 1} {
			Inf "This Option Will Not Work Where File Or Directory Name Contains Spaces"
			return 1
		}
	}
	return 0
}

proc GappedNameWarning {fnams} {
	foreach fnam $fnams {
		set fnam [string trim $fnam]
		set fnam [split $fnam]
		set k [llength $fnam]
		if {$k > 1} {
			return 1
		}
	}
	return 0
}

#---- Function that scatters pitch and amplitude in varibank filter file

proc ScatterFilter {} {
	global pr_sf sf_j sf_jj sf_h sf_a wstk wl pa evv wl wstk rememd sf_newname prm mu mmod last_outfile

	set srate 44100
	set nyq [expr $srate / 2.0]
	if {([string length $prm(0)] <= 0) || ![file exists $prm(0)]} {
		Inf "No Varibank Filter Data File Has Been Selected As A Parameter"
		return
	}
	set vfile $prm(0)
	if [catch {open $vfile "r"} zit] {
		Inf "Cannot Open File '$vfile'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		set line [split $line]
		catch {unset nuline}
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] > 0} {
				if {![IsNumeric $item] || ($item < 0.0)} {
					Inf "'$vfile' Is Not A Valid Filter Data File"
					close $zit
					return
				}
				lappend nuline $item
			}
		}
		if {[info exists nuline]} {
			set len [llength $nuline]
			if {![info exists filterlines]} {
				set truelen $len
			} else {
				if {$len != $truelen} {
					Inf "'$vfile' Is Not A Valid Filter Data File"
					close $zit
					return
				}
			}
			lappend filterlines $nuline
		}
	}
	close $zit
	if {![info exists filterlines]} {
		Inf "No Data In File $vfile"
		return
	}
	set cnt 0
	foreach line $filterlines {
		set thistime [lindex $line 0]
		if {$cnt == 0} {
			if {$thistime != 0.0} {
				Inf "Invalid Initial Time In File $vfile"
				return
			}
		} else {
			if {$thistime <= $lasttime} {
				Inf "Invalid Time Sequence ($lasttime  $thistime) In File $vfile"
				return
			}
		}
		set lasttime $thistime
		foreach {val amp} [lrange $line 1 end] {
			if {$mmod == 1} {
				if {($val < $evv(FLT_MINFRQ)) || ($val >= $nyq)} {
					Inf "Invalid Frequency Value ($val) In File $vfile"
					return
				}
			} else {
				if {($val < 0) || ($val > $mu(MIDIMAX))} {
					Inf "Invalid Midi Value ($val) In File $vfile"
					return
				}
			}
			if {($amp < 0.0) || ($amp > 1.0)} {
				Inf "INVALID AMPLITUDE VALUE ($val) In File $vfile"
				return
			}
		}
		incr cnt
	}
	set srate 44100
	set nyq [expr $srate / 2.0]
	set f .sf
	if [Dlg_Create $f "SCATTER FILTER DATA" "set pr_sf 0" -borderwidth $evv(SBDR)] {
		set a [frame $f.a]
		set b [frame $f.b]
		button $a.qu -text "Close" -command "set pr_sf 0" -highlightbackground [option get . background {}]
		button $a.do -text "Create" -command "set pr_sf 1" -highlightbackground [option get . background {}]
		label $a.ll -text "  Outfile Name "
		entry $a.e -textvariable sf_newname -width 24
		pack $a.do $a.ll $a.e -side left
		pack $a.qu -side right
		label $b.jll -text " pitch drift\n(0-6) semitones"
		entry $b.je -textvariable sf_j -width 4
		label $b.all -text " amplitude scatter (0-1)"
		entry $b.a -textvariable sf_a -width 4
		label $b.jjll -text " drift rate \n0.01-10 secs)"
		entry $b.jje -textvariable sf_jj -width 4
		label $b.hll -text " max no of harmonics (>0)"
		entry $b.he -textvariable sf_h -width 4
		pack $b.jll $b.je $b.all $b.a $b.jjll $b.jje $b.hll $b.he -side left

		pack $a -side top -fill x -expand true
		pack $b -side top -fill x -expand true -pady 4
		wm resizable $f 1 1
		set sf_j 0
		set sf_a 0
		set sf_jj 0.1
		set sf_h 200
		bind $f <Escape> {set pr_sf 0}
		bind $f <Return> {set pr_sf 1}
	}
	if {[regexp {^[0-9]+$} $prm(4)] && ($prm(4) > 0) && ($prm(4) <= 200)} {
		set sf_h $prm(4)
	} else {
		set sf_h ""
	}
	raise $f
	update idletasks
	StandardPosition $f
	set finished 0
	set pr_sf 0
	My_Grab 0 $f pr_sf $f.a.e
	while {!$finished} {
		tkwait variable pr_sf
		switch -- $pr_sf {
			1 {
				if {([string length $sf_j] <= 0) || ![IsNumeric $sf_j]} {
					Inf "Invalid Pitch Drift Value Given"
					continue
				}
				if {($sf_j < 0) || ($sf_j > 6)} {
					Inf "Pitch Drift Out Of Range (0 - 6 semitones)"
					continue
				}
				if {([string length $sf_jj] <= 0) || ![IsNumeric $sf_jj]} {
					Inf "Invalid Drift Rate Value Given"
					continue
				}
				if {($sf_jj < 0.01) || ($sf_jj > 100)} {
					Inf "Drift Rate Out Of Range (0.01 - 100 secs)"
					continue
				}
				if {([string length $sf_h] <= 0) || ![IsNumeric $sf_h]} {
					Inf "Invalid Max Harmonic Count Given"
					continue
				}
				if {($sf_h < 1) || ($sf_h > 200)} {
					Inf "Max Harmonic Count Out Of Range (1 - 200)"
					continue
				}
				if {![ValidCDPRootname $sf_newname]} {
					continue
				}
				set ofnam [string tolower $sf_newname]
				append ofnam $evv(TEXT_EXT)
				if {[file exists $ofnam]} {
					set msg "File '$ofnam' Exists: Overwrite It ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					} elseif {![DeleteNonSndfileFromSystem $ofnam]} {
						Inf "CANNOT DELETE FILE $ofnam"
						continue
					}
				}
				set jitrate [expr $sf_jj * 2.0 / 3.0]
				set maxfrq [expr ($nyq - 1.0) / $sf_h]
				Block "CREATING FILTER DATA"
				catch {unset outlines}
				set firstline [lindex $filterlines 0]
				lappend outlines $firstline
				set firsttime [lindex $firstline 0]
				foreach line [lrange $filterlines 1 end] {
					set timelim [lindex $line 0]
					set timestep [expr $timelim - $firsttime]
					set timeincr [expr (rand() * $jitrate) + $jitrate]
					set time [expr $firsttime + $timeincr]
					while {$time < $timelim} {
						set outline $time
						foreach {val1 amp1} [lrange $firstline 1 end] {val2 amp2} [lrange $line 1 end] {
							set timeratio [expr $timeincr / $timestep]
							if {$mmod == 1} {
								set val1 [HzToMidi $val1]
								set val2 [HzToMidi $val2]
							}
							set valdiff [expr $val2 - $val1]
							set valstep [expr $valdiff * $timeratio]
							set midi [expr $val1 + $valstep]
							set jitter [expr (rand() * 2.0) - 1.0]
							set jitter [expr $jitter * $sf_j]
							set this_oval [expr $midi + $jitter]
							if {($this_oval >= $mu(MIDIMAX)) || ($this_oval < 0)} {
								set this_oval [expr $midi - $jitter]
							}
							if {$mmod == 1} {
								set this_oval [DecPlaces [MidiToHz $this_oval] 3]
							} else {
								set this_oval [DecPlaces $this_oval 3]
							}
							set ampdiff [expr $amp2 - $amp1]
							set ampstep [expr $ampdiff * $timeratio]
							set amp [expr $amp1 + $ampstep]
							set ajitter [expr (rand() * 2.0) - 1.0]
							set ajitter [expr $ajitter * $sf_a]
							if {$ajitter > 0.0} {
								set gap [expr 1.0 - $amp]
								set ajitter [expr $gap * $ajitter]
								set thisamp [DecPlaces [expr $amp + $ajitter] 3]
							} else {
								set gap $amp
								set ajitter [expr $gap * $ajitter]
								set thisamp [DecPlaces [expr $amp - $ajitter] 3]
							}
							lappend outline $this_oval $thisamp
						}
						lappend outlines $outline
						set timeincr [expr $timeincr + ((rand() * $jitrate) + $jitrate)]
						set time [expr $firsttime + $timeincr]
					}
					lappend outlines $line
					set firstline $line
					set firsttime [lindex $firstline 0]
				}
				if [catch {open $ofnam "w"} zit] {
					Inf "CANNOT OPEN FILTER DATA FILE"
					UnBlock
					continue
				}
				foreach line $outlines {
					puts $zit $line
				}
				close $zit
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File '$ofnam' Is On The Workspace"
					set prm(0) $ofnam
					set last_outfile $ofnam
				}
				UnBlock
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#####################
# RHYTHM EXTRACTION #
#####################

proc ExtractRhythm {} {
	global pr_getrhy getrhywin getrhyno getrhynum getrhygap getrhyout getrhyfnam getrhynrm CDPidrun CDP_cmd prg_dun prg_abortd wl chlist wstk pa evv
	global simple_program_messages last_outfile

	set ilist [$wl curselection]
	if {([llength $ilist] != 1) || ([lindex $ilist 0] == -1)} {
		if {[info exists chlist] && ([llength $chlist] == 1)} {
			set fnam [lindex $chlist 0]
		} else {
			Inf "Select One File On Workspace Or Put It On Chosen Files List"
			return
		}
	} else {
		set fnam [$wl get [lindex $ilist 0]]
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Selected File '$fnam' Is Not A Soundfile"
		return
	}
	set f .getrhy
	if [Dlg_Create $f "EXTRACT RHYTHM" "set pr_getrhy 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.00 -height 1 -bg [option get . foreground {}]
		frame $f.1
		frame $f.10 -height 1 -bg [option get . foreground {}]
		frame $f.3
		frame $f.3a
		frame $f.3d -height 1 -bg [option get . foreground {}]
		frame $f.5
		frame $f.6
		button $f.0.do -text "Extract Rhythm" -command "set pr_getrhy 1" -width 14 -highlightbackground [option get . background {}]
		label $f.0.n -text "Output Data Filename"
		entry $f.0.e -textvariable getrhyfnam -width 24
		button $f.0.qu -text "Abandon" -command "set pr_getrhy 0" -width 14 -highlightbackground [option get . background {}]
		pack $f.0.do $f.0.n $f.0.e -side left -padx 2
		pack $f.0.qu -side right
		pack $f.0 -side top -fill x -expand true -pady 2
		pack $f.00 -side top -fill x -expand true -pady 4
		label $f.1.ll -text "Envelope-tracking windowsize (mS)" -width 35
		entry $f.1.e -textvariable getrhywin -width 6
		pack $f.1.ll $f.1.e -side left
		pack $f.1 -side top -pady 4
		pack $f.10 -side top -fill x -expand true -pady 4
		label $f.2a -text "OUTPUT DATA FORMAT"
		pack $f.2a -side top -pady 2
		label $f.2b -text "TIME-LIST OR (NON-TRANSPOSING) TRIPLES FOR SEQUENCER PROCESS"
		pack $f.2b -side top -pady 2
		radiobutton $f.3.t -variable getrhyout -text "List of Times" -value 0 -command "GetrhyNorm 0"
		radiobutton $f.3.s -variable getrhyout -text "Time-Trans-Level triple" -value 1 -command "GetrhyNorm 1"
		pack $f.3.t $f.3.s -side left 
		pack $f.3 -side top -pady 2
		radiobutton $f.3a.c -variable getrhynrm -text "" -value 1 -width 9 -state disabled
		radiobutton $f.3a.n -variable getrhynrm -text "" -value 2 -width 9 -state disabled
		pack $f.3a.c $f.3a.n -side left 
		pack $f.3a -side top -pady 2
		label $f.3b -text "" -fg $evv(SPECIAL)
		label $f.3c -text "" -fg $evv(SPECIAL)
		pack $f.3b $f.3c  -side top -pady 2
		pack $f.3d -side top -fill x -expand true -pady 4
		label $f.4 -text "OPTIONAL PARAMETERS"
		pack $f.4 -side top -pady 2
		label $f.5.ll -text "Number of attacks" -width 35
		entry $f.5.e -textvariable getrhyno -width 6
		pack $f.5.ll $f.5.e -side left
		pack $f.5 -side top -fill x -expand true -pady 2
		label $f.6.ll -text "Minimum gap between atks (secs)" -width 35
		entry $f.6.e -textvariable getrhygap -width 6
		pack $f.6.ll $f.6.e -side left
		pack $f.6 -side top -fill x -expand true -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_getrhy 0}
		bind $f <Return> {set pr_getrhy 1}
	}
	wm title $f "EXTRACT RHYTHM FROM $fnam"
	set finished 0
	set getrhyout 0
	set getrhynrm 0
	set getrhyno ""
	set getrhygap ""
	set getrhywin 100
	set pr_getrhy 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_getrhy
	while {!$finished} {
		tkwait variable pr_getrhy
		if {$pr_getrhy} {
			if {$getrhyout < 0} {
				Inf "No Output Data Format Specified"
				continue 
			}
			if {$getrhyout} {
				if {$getrhynrm <= 0} {
					Inf "Specify Expand Or Normalise"	
					continue 
				}
			}
			if {![IsNumeric $getrhywin] || ($getrhywin <= 5.0) || ($getrhywin > 10000)} {
				Inf "Invalid Window Size Value"	
				continue 
			}
			set getrhyno [string trim $getrhyno]
			if {[string length $getrhyno] <= 0} {
				set getrhynum 0
			} elseif {![regexp {^[0-9]+$} $getrhyno] || ($getrhyno <= 0)} {
				Inf "Invalid Number Of Attacks"	
				continue 
			} else {
				set getrhynum [StripLeadingZeros $getrhyno]
			}
			set getrhygap [string trim $getrhygap]
			if {[string length $getrhygap] <= 0} {
				set getrhygap 0
			} elseif {![IsNumeric $getrhygap] || ($getrhygap < 0.0)} {
				Inf "Invalid Minimum Gap Between Attacks"	
				continue 
			}
			if {[string length $getrhyfnam] <= 0} {
				Inf "No Name Entered For Output Data File"	
				continue 
			}
			set getrhyfnam [string tolower $getrhyfnam]
			if {![ValidCDPRootname $getrhyfnam]} {
				continue 
			}
			set outfnam $getrhyfnam$evv(TEXT_EXT)
			if {[file exists $outfnam]} {
				set msg "File '$outfnam' Already Exists: Overwrite It ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if {![DeleteNonSndfileFromSystem $outfnam]} {
					Inf "Can't Delete Existing File '$outfnam'"	
					continue 
				}
			}
			set envfnam $evv(DFLT_OUTNAME)
			append envfnam 0 $evv(TEXT_EXT)
			set CDP_cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend CDP_cmd "extract" 2 $fnam $envfnam $getrhywin -d0.0002
			Block "EXTRACTING PEAKS FROM $fnam"
			set CDPidrun 0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$CDP_cmd"} CDPidrun] {
				Inf "$CDPidrun : Peak Extraction Failed"
				DeleteAllTemporaryFiles
				UnBlock
				break
			} else {
	   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Peak Extraction Failed"
				set msg [AddSimpleMessages $msg]
				Inf $msg
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			if {![file exists $envfnam]} {
				Inf "Cannot Find Output Envelope File '$envfnam' To Extract Peaks"
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			UnBlock
			if [catch {open $envfnam "r"} zit] { 
				Inf "Cannot Open Temporary Envelope File To Read Peaks"	
				DeleteAllTemporaryFiles
				break 
			}
			
			;#	EXTRACT TIMES AND LEVELS IN ENVELOPE DATA

			catch {unset times}
			catch {unset vals}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0}  {
					continue
				}
				catch {unset nuline}
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] >= 0} {
						lappend nuline $item
					}
				}
				if {![info exists nuline] || ([llength $nuline] != 2)} {
					Inf "Invalid Data In Temporary Envelope File"	
					close $zit
					catch {unset times}
					catch {unset vals}
					DeleteAllTemporaryFiles
					break 
				}
				lappend times [lindex $nuline 0]
				lappend vals  [lindex $nuline 1]
			}
			close $zit
			if {![info exists times]}  {
				Inf "Invalid Data In Temporary Envelope File"	
				DeleteAllTemporaryFiles
				break 
			}
			;#	FIND PEAKS IN ENVELOPE DATA

			catch {unset peaks}
			catch {unset outtimes}
			catch {unset outvals}
			set lastval [lindex $vals 0]
			set cnt 0
			set gotpeak 0
			foreach val [lrange $vals 1 end] {
				if {$val < $lastval} {
					if {!$gotpeak} {
						lappend peaks $cnt
						set gotpeak 1
					}
				} elseif {$val > $lastval} {
					set gotpeak 0
				}
				set lastval $val
				incr cnt
			}	
			if {!$gotpeak} {
				lappend peaks [expr $cnt - 1]	
			}
			foreach peak $peaks {
				lappend outtimes [lindex $times $peak]
				lappend outvals  [lindex $vals $peak]
			}
			set pkcnt [llength $outtimes]

			if {$getrhygap > 0} {

			;#	REMOVE TOO CLOSE PEAKS

				set pkcnt [llength $outtimes]
				set m 0
				set n 1
				while {$n < $pkcnt} {
					set time [lindex $outtimes $n]
					set lasttime [lindex $outtimes $m]
					if {[expr $time - $lasttime] < $getrhygap} {
						set valm [lindex $outvals $m]
						set valn [lindex $outvals $n]
						if {$valm < $valn} {
							set outtimes [lreplace $outtimes $m $m]
							set outvals  [lreplace $outvals  $m $m]
						} else {
							set outtimes [lreplace $outtimes $n $n]
							set outvals  [lreplace $outvals  $n $n]
						}
						incr pkcnt -1
					} else {
						incr m
						incr n
					}
				}
			}
			if {$getrhynum > 0} {
				if {$pkcnt < $getrhynum} {
					set msg "Number Of Peaks Found Is Less Than $getrhynum (Specified): Is This OK?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				} elseif {$pkcnt > $getrhynum} {

					;#	SELECT MOST PROMINENT PEAKS, IF NESS

					set peakindex -1
					set peakranking $outvals
					set n 0
					while {$n < $pkcnt} {
						set maxpeak [lindex $peakranking 0]
						set maxloc 0
						set cnt 1
						foreach val [lrange $peakranking 1 end] {
							if {$val > $maxpeak} {
								set maxpeak $val
								set maxloc $cnt
							}
							incr cnt
						}
						set peakranking [lreplace $peakranking $maxloc $maxloc $peakindex]
						incr peakindex -1
						incr n
					}
					catch {unset nupkr} 
					foreach pkr $peakranking {
						lappend nupkr [expr -$pkr]
					}
					set peakranking $nupkr
					set n 0
					while {$n < $pkcnt} {
						set thisrank [lindex $peakranking $n]
						if {$thisrank > $getrhynum} {
							set outtimes [lreplace $outtimes $n $n]
							set outvals  [lreplace $outvals  $n $n]
							incr pkcnt -1
						} else {
							incr n
						}
					}
				}
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write Peaks Data"
				DeleteAllTemporaryFiles
				break
			}
			if {$getrhyout} {
				catch {unset nuvals}
				set maxval [lindex $outvals 0]
				foreach val [lrange $outvals 1 end] {
					if {$val > $maxval} {
						set maxval $val
					}
				}
				if {$maxval <= 0} {
					Inf "Cannot Find Maximum Peak Level"
					DeleteAllTemporaryFiles
					break
				}
				if {$getrhynrm == 2} {	;#	NORMALISE
					foreach val [lrange $outvals 0 end] {
						lappend nuvals [expr double($val) / double($maxval)]
					}
				} else {				;#	EXPAND
					set expander [expr 1.0 - $maxval]
					foreach val [lrange $outvals 0 end] {
						set nuval [expr double($val) + $expander]
						if {$nuval > 1.0} {
							set nuval 1.0
						}
						lappend nuvals $nuval
					}
				}
				set outvals $nuvals
				foreach time $outtimes val $outvals {
					set line [list $time 0 $val]
					puts $zit $line
				}
			} else {
				foreach time $outtimes {
					puts $zit $time
				}
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "Output Data Is In File '$getrhyfnam'"
				set last_outfile $outfnam
			}
			break
		} else {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc GetrhyNorm {norm} {
	if {$norm} {
		.getrhy.3a.c config -text "Expand" -state normal
		.getrhy.3a.n config -text "Normalise" -state normal
		.getrhy.3b config -text "Expand raises peaks by same amount, so loudest is at full level"
		.getrhy.3c config -text "Normalise scales all peak levels, so loudest is at full level"
	} else {
		.getrhy.3a.c config -text "" -state disabled
		.getrhy.3a.n config -text "" -state disabled
		.getrhy.3b config -text ""
		.getrhy.3c config -text ""
	}
}

#########################################################
# SHRINKING SYLLABLES IN A WORD, WHILE RETAINING RHYTHM #
#########################################################
#
# Inputs are the src sound, a textfile of the attacktimes and the cut syllables
#
# LOGIC HERE IS
# 
# If syllable longer than 0.17 shrink to 0.14 secs
# if vowel-to-sibillant ("as") shrink vowel half (assumed half length) by 3/4 of this, and sibil half by 5/4 of this
# If sibillant-to-vowel, other way round.
# If sib-vowel-sib, similar proportionality
# IF plosive-vowel, don't shrink plosive part
# If syllable (or remainder of it after plosive) less than 0.13, DON'T shrink
# If between 0.17 and 0.13 force user to input required val
#

proc RhythmicSyllableShrink {} {
	global pr_rhshrink prg_dun prg_abortd CDPidrun wl total_wksp_cnt rememd wstk chlist wl pa evv
	global rhsh rhshas rhshrink rhshredo rhshedit rhshdur rhshshrunk rhshfnam simple_program_messages last_outfile

	set evv(SYLLAB_SHRINK_ABOVE)	0.17		;#	SYLLABLES ABOVE THIS DURATION WILL SHRINK
	set evv(SYLLAB_NOSHRINK_BELOW)	0.13		;#	SYLLABLES BELOW THIS DURATION WILL NOT SHRINK
	set evv(SYLLAB_SHRUNK_DUR)		0.14		;#	SYLLABLE SHRUNK TO THIS DURATION
	set evv(DFLT_PLOSIVE_DUR)		0.05		;#	DEFAULT DURATION OF (NON-SHRINKABLE) PLOSIVE, TO SKIP BEFORE SHRINKING REMAINDER OF SYLLABLE

	set gottextfile 0
	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		Inf "Put Selected Files On Chosen List"
		return
	}
	if {[llength $chlist] < 4} {
		ShrinkHelp
	}
	set src -1
	set maxdur 0.0
	set syllabs {}
	foreach fnam $chlist {
		if {![info exists pa($fnam,$evv(FTYP))]} {
			Inf "No Properties Exist For File '$fnam'"	
			return
		}
		set ftyp $pa($fnam,$evv(FTYP))
		if {$ftyp & $evv(IS_A_TEXTFILE)} {
			if {$gottextfile} {
				Inf "Use One Textfile (of Attack Times) With A Set Of Soundfiles"
				return
			} else {
				set atktimes $fnam
				set gottextfile 1
			}
		} elseif {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			if {$pa($fnam,$evv(CHANS)) != 1} {
				Inf "File '$fnam' Is Not A Mono Soundfile"	
				return
			} else {
				if {$pa($fnam,$evv(DUR)) >= $maxdur} {
					set maxdur $pa($fnam,$evv(DUR))
					set src [llength $syllabs]
				}
				lappend syllabs $fnam
			}
		} else {
			Inf "Use One Textfile (Of Attack Times) With A Set Of Soundfiles"
			return
		}
	}
	if {$src < 0} {
		Inf "Programming Error Finding Source Sound"
		return
	}
	set srcsnd [lindex $syllabs $src]
	set syllabs [lreplace $syllabs $src $src]
	if [catch {open $atktimes "r"} zit] {
		Inf "Cannot Open Attack Times Data File"	
		return
	}
	set cnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {![IsNumeric $line]} {
			Inf "Wrong Data Format For Attack Times (One Time On Each Line)"
			close $zit
			return
		}
		if {$cnt == 0} {
			if {$line < 0.0} {
				Inf "Wrong Data Format For Attack Times (Times Must Be >= Zero)"
				close $zit
				return
			}
		} else {
			if {$line <= $lasttime} {
				Inf "Attack Times Not Increasing At '$line'"
				close $zit
				return
			}
		}
		lappend times $line
		set lasttime $line
		incr cnt
	}
	close $zit
	if {![info exists times]} {
		Inf "No Data In File '$atktimes'"
		return
	}
	set atkfile $atktimes
	set rhsh(atktimes) $times
	if {[llength $syllabs] != [llength $rhsh(atktimes)]} {
		Inf "Counts Of Syllables And Of Attack Times Do Not Tally"	
		return
	}
	set len [llength $rhsh(atktimes)]
	set len_plus_one [expr $len + 1]
	set rhshfnam($len_plus_one) $atkfile
	set rhsh(maxdur)	$evv(SYLLAB_SHRINK_ABOVE)
	set rhsh(mindur)	$evv(SYLLAB_NOSHRINK_BELOW)
	set rhsh(shrunkdur) $evv(SYLLAB_SHRUNK_DUR)
	set rhsh(plosdur)	$evv(DFLT_PLOSIVE_DUR)
	set rhsh(basfnam)	$evv(DFLT_OUTNAME)
	set mixfnam			$evv(DFLT_OUTNAME)$evv(TEXT_EXT)
	set shrunkfnam		$evv(DFLT_OUTNAME)$evv(SNDFILE_EXT)
	set bothfnam		$evv(MACH_OUTFNAME)$evv(SNDFILE_EXT)
	set bothmixfnam		$evv(MACH_OUTFNAME)$evv(TEXT_EXT)
	set f .rhshrink

	if [Dlg_Create $f "SHRINK SYLLABLES" "set pr_rhshrink 0" -borderwidth $evv(BBDR)] {
		frame $f.a
		button $f.a.quit -text "Abandon"    -command "set pr_rhshrink 0" -highlightbackground [option get . background {}]
		button $f.a.help -text "Help" -command "ShrinkHelp" -bg $evv(HELP) -highlightbackground [option get . background {}]
		button $f.a.set  -text "Set Params" -command "set pr_rhshrink 1" -highlightbackground [option get . background {}]
		button $f.a.doit -text "Do Shrink"  -command "set pr_rhshrink 2" -highlightbackground [option get . background {}]
		button $f.a.save -text "Save Ouput" -command "set pr_rhshrink 3" -highlightbackground [option get . background {}]
		label $f.a.fname -text "Output Filename "
		entry $f.a.e -textvariable rhsh(outfnam) -width 16
		pack $f.a.help $f.a.set $f.a.doit $f.a.save $f.a.fname $f.a.e -side left -padx 2
		pack $f.a.quit -side right
		pack $f.a -side top -fill x -expand true
		frame $f.a0 -bg $evv(POINT) -height 1
		pack $f.a0 -side top -fill x -expand true -pady 2
		frame $f.b
		label $f.b.ref -text "REF VALS : shrink syllabs > "
		entry $f.b.max -textvariable rhsh(maxdur) -width 4
		label $f.b.mnl -text "keep syllabs < "
		entry $f.b.min -textvariable rhsh(mindur) -width 4
		label $f.b.shl -text "shrunk duration "
		entry $f.b.shr -textvariable rhsh(shrunkdur) -width 4
		label $f.b.pll -text "plosive dur "
		entry $f.b.plo -textvariable rhsh(plosdur) -width 4
		pack $f.b.ref $f.b.max $f.b.mnl $f.b.min $f.b.shl $f.b.shr $f.b.pll $f.b.plo -side left
		pack $f.b -side top
		frame $f.b0 -bg $evv(POINT) -height 1
		pack $f.b0 -side top -fill x -expand true -pady 2
		frame $f.c
		label $f.c.ll -text SOUND
		grid $f.c.ll -row 0 -column 0
		label $f.c.lla -text ""
		grid $f.c.lla -row 0 -column 1
		label $f.c.llb -text "ba"
		grid $f.c.llb -row 0 -column 2
		label $f.c.llc -text "bas"
		grid $f.c.llc -row 0 -column 3
		label $f.c.lld -text "as"
		grid $f.c.lld -row 0 -column 4
		label $f.c.lle -text "sa"
		grid $f.c.lle -row 0 -column 5
		label $f.c.llf -text "sas"
		grid $f.c.llf -row 0 -column 6
		label $f.c.llg -text "Dur"
		grid $f.c.llg -row 0 -column 7
		label $f.c.llsh -text "Shrink"
		grid $f.c.llsh -row 0 -column 8
		label $f.c.llrd -text "Redo"
		grid $f.c.llrd -row 0 -column 9
		label $f.c.lled -text "Edit"
		grid $f.c.lled -row 0 -column 10
		label $f.c.llnk -text "SHRUNK"
		grid $f.c.llnk -row 0 -column 11
		set n 1	
		foreach fnam $syllabs {
			button $f.c.ll$n -text [file rootname [file tail $fnam]] -command "PlaySndfile $fnam 0" -bg $evv(HELP) -highlightbackground [option get . background {}]
			grid $f.c.ll$n -row $n -column 0
			radiobutton $f.c.xx$n  -text "" -variable rhshas($n) -value 0
			grid $f.c.xx$n -row $n -column 1
			radiobutton $f.c.ba$n  -text "" -variable rhshas($n) -value 1
			grid $f.c.ba$n -row $n -column 2
			radiobutton $f.c.bas$n  -text "" -variable rhshas($n) -value 2
			grid $f.c.bas$n -row $n -column 3
			radiobutton $f.c.as$n  -text "" -variable rhshas($n) -value 3
			grid $f.c.as$n -row $n -column 4
			radiobutton $f.c.sa$n  -text "" -variable rhshas($n) -value 4
			grid $f.c.sa$n -row $n -column 5
			radiobutton $f.c.sas$n -text "" -variable rhshas($n) -value 5
			grid $f.c.sas$n -row $n -column 6
			set rhshas($n) 0
			entry $f.c.d$n -textvariable rhshdur($n) -width 4 -state readonly
			set rhshdur($n) [DecPlaces $pa($fnam,$evv(DUR)) 2]
			grid $f.c.d$n -row $n -column 7
			entry $f.c.sh$n -textvariable rhshrink($n) -width 12
			set rhshrink($n) ""
			grid $f.c.sh$n -row $n -column 8
			checkbutton $f.c.re$n -text "" -variable rhshredo($n)
			set rhshredo($n) 1
			$f.c.re$n config -state disabled
			grid $f.c.re$n -row $n -column 9
			radiobutton $f.c.ed$n -text "" -variable rhshedit($n) -command "EditShrink $n $len; set rhshedit($n) 0"
			grid $f.c.ed$n -row $n -column 10
			button $f.c.out$n -text [file rootname [file tail $fnam]] -command {} -bg $evv(HELP) -highlightbackground [option get . background {}]
			grid $f.c.out$n -row $n -column 11
			incr n
		}
		button $f.c.src -text "Play Source" -command "PlaySndfile $srcsnd 0" -bg $evv(HELP) -highlightbackground [option get . background {}]
		grid $f.c.src -row $n -column 0
		button $f.c.both -text "" -width [string length "Play Both"] -command {} -bg $evv(HELP) -highlightbackground [option get . background {}]
		grid $f.c.both -row $n -column 2 -columnspan 2
		button $f.c.off -text "Offset" -command "set pr_rhshrink 4" -highlightbackground [option get . background {}]
		grid $f.c.off -row $n -column 4 -columnspan 2
		entry  $f.c.offset -textvariable rhsh(offset) -state readonly -width 4
		set rhsh(offset) [DecPlaces [lindex $rhsh(atktimes) 0] 2]
		grid $f.c.offset -row $n -column 6 -columnspan 2 
		button $f.c.atkfile -text "Atk Times" -width 11 -command {} -highlightbackground [option get . background {}]
		grid $f.c.atkfile -row $n -column 8
		radiobutton $f.c.edatk -text "" -variable rhshedit($n) -command "EditShrink $n $len; set rhshedit($n) 0"
		grid $f.c.edatk -row $n -column 10
		set rhshedit($n) 1
		button $f.c.out0 -text "" -width [string length "Shrunk Phrase"] -command {} -bg $evv(HELP) -highlightbackground [option get . background {}]
		grid $f.c.out0 -row $n -column 11
		pack $f.c -side top -fill x -expand true
		bind $f.c.offset <Shift-ButtonRelease-1> {IncrRhshOffset 1}
		bind $f.c.offset <ButtonRelease-1> {IncrRhshOffset 0}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_rhshrink 0}
	}
	set rhsh(paramset) 0
	set rhsh(outfnam) ""
	set finished 0
	set pr_rhshrink 0
	raise .rhshrink
	update idletasks
	StandardPosition2 .rhshrink
	set finished 0
	My_Grab 0 $f pr_rhshrink
	while {!$finished} {
		tkwait variable pr_rhshrink
		switch -- $pr_rhshrink {
			0 {
				if {[AreYouSure]} {
					set finished 1
				}
			}
			1 {			;#	SET SHRINK PARAMS
				set OK 1
				set n 1
				foreach fnam $syllabs {
					if {$rhshdur($n) > $rhsh(maxdur)} {
						set shrink [expr $rhsh(shrunkdur)/$rhshdur($n)]
						set ashr [expr ($shrink * 3.0)/4.0]
						set sshr [expr ($shrink * 5.0)/4.0]
					} elseif {$rhshdur($n) < $rhsh(mindur)} {
						set shrink -1
					} else {
						set shrink "?"
					}
					set rhshfnam($n) $rhsh(basfnam)
					append rhshfnam($n) $n $evv(TEXT_EXT)
					set halfdur  [expr $rhshdur($n) / 2.0]
					set thirddur [expr $rhshdur($n) / 3.0]
					set twothirddur [expr $thirddur * 2.0]
					if {![string match $shrink  "?"]} {
						if {$shrink > 0} {
							switch -- $rhshas($n) {
								1 {		;# PLOSIVE -> VOWEL
									set remain [expr $rhshdur($n) - $rhsh(plosdur)]
									if {$remain <= $rhsh(mindur)} {
										set shrink -1
										if [file exists $rhshfnam($n)] {
											if [catch {file delete $rhshfnam($n)} zit] {
												Inf "Cannot Delete Breakpoint File '$rhshfnam($n)'"
												set OK 0
												break
											}
										}
									} else {
										if [catch {open $rhshfnam($n) "w"} zit] {
											Inf "Cannot Open File '$rhshfnam($n)' To Write Breakpoint Data For File '$fnam'"
											set OK 0
											break
										}
										set line [list 0 1]
										puts $zit $line
										set line [list $rhsh(plosdur) 1]
										puts $zit $line
										set shrink [expr $rhsh(mindur) / $remain]
										set line [list [expr $rhsh(plosdur) + 0.01] $shrink]
										puts $zit $line
										set line [list $rhshdur($n) $shrink]
										puts $zit $line
										close $zit
										set rhshrink($n) $rhshfnam($n)
									}
								}
								2 {		;# PLOSIVE -> VOWEL -> SIBILLANT
									set remain [expr $rhshdur($n) - $rhsh(plosdur)]
									if {$remain <= $rhsh(mindur)} {
										set shrink -1
										if [file exists $rhshfnam($n)] {
											if [catch {file delete $rhshfnam($n)} zit] {
												Inf "Cannot Delete Breakpoint File '$rhshfnam($n)'"
												set OK 0
												break
											}
										}
									} else {
										if [catch {open $rhshfnam($n) "w"} zit] {
											Inf "Cannot Open File '$rhshfnam($n)' To Write Breakpoint Data For File '$fnam'"
											set OK 0
											break
										}
										set line [list 0 1]
										puts $zit $line
										set line [list $rhsh(plosdur) 1]
										puts $zit $line
										set line [list [expr $rhsh(plosdur) + 0.01] $ashr]
										puts $zit $line
										set halfdur  [expr ($remain / 2.0) + $rhsh(plosdur)]
										set shrink [expr $rhsh(mindur) / $remain]
										set ashr [expr ($shrink * 3.0)/4.0]
										set sshr [expr ($shrink * 5.0)/4.0]
										set line [list [expr $halfdur - 0.01] $ashr]
										puts $zit $line
										set line [list [expr $halfdur + 0.01] $sshr]
										puts $zit $line
										set line [list $rhshdur($n) $sshr]
										puts $zit $line
										close $zit
										set rhshrink($n) $rhshfnam($n)
									}
								}
								3 {		;#	VOWEL -> SIBILLANT
									if [catch {open $rhshfnam($n) "w"} zit] {
										Inf "Cannot Open File '$rhshfnam($n)' To Write Breakpoint Data For File '$fnam'"
										set OK 0
										break
									}
									set line [list 0 $ashr]
									puts $zit $line
									set line [list [expr $halfdur - 0.01] $ashr]
									puts $zit $line
									set line [list [expr $halfdur + 0.01] $sshr]
									puts $zit $line
									set line [list $rhshdur($n) $sshr]
									puts $zit $line
									close $zit
									set rhshrink($n) $rhshfnam($n)
								}
								4 {		;#	SIBILLANT -> VOWEL
									if [catch {open $rhshfnam($n) "w"} zit] {
										Inf "Cannot Open File '$rhshfnam($n)' To Write Breakpoint Data For File '$fnam'"
										continue
									}
									set line [list 0 $sshr]
									puts $zit $line
									set line [list [expr $halfdur - 0.01] $sshr]
									puts $zit $line
									set line [list [expr $halfdur + 0.01] $ashr]
									puts $zit $line
									set line [list $rhshdur($n) $ashr]
									puts $zit $line
									close $zit
									set rhshrink($n) $rhshfnam($n)
								}
								5 {		;#	SIBILLANT -> VOWEL -> SIBILLANT
									if [catch {open $rhshfnam($n) "w"} zit] {
										Inf "Cannot Open File '$rhshfnam($n)' To Write Breakpoint Data For File '$fnam'"
										continue
									}
									set line [list 0 $sshr]
									puts $zit $line
									set line [list [expr $thirddur - 0.01] $sshr]
									puts $zit $line
									set line [list [expr $thirdur + 0.01] $ashr]
									puts $zit $line
									set line [list [expr $twothirddur - 0.01] $ashr]
									puts $zit $line
									set line [list [expr $twothirddur + 0.01] $sshr]
									puts $zit $line
									set line [list $rhshdur($n) $sshr]
									puts $zit $line
									close $zit
									set rhshrink($n) $rhshfnam($n)
								}
								0 {
									if [file exists $rhshfnam($n)] {
										if [catch {file delete $rhshfnam($n)} zit] {
											Inf "Cannot Delete Breakpoint File '$rhshfnam($n)'"
											set OK 0
											break
										}
									}
									set rhshrink($n) $shrink
								}
							}
						} else {
							if [file exists $rhshfnam($n)] {
								if [catch {file delete $rhshfnam($n)} zit] {
									Inf "Cannot Delete Breakpoint File '$rhshfnam($n)'"
									set OK 0
									break
								}
							}
							set rhshrink($n) ""
						}
					}
					incr n
				}
				set rhsh(paramset) $OK
				continue
			}
			2 {
				.rhshrink.c.out0 config -command {} -text ""
				.rhshrink.c.both config -command {} -text ""
				if {!$rhsh(paramset)} {
					Inf "Parameters Not Yet Set Correctly"
					continue
				}
				if {[llength $syllabs] != [llength $rhsh(atktimes)]} {
					Inf "Counts Of Syllables And Of Attack Times Do Not Tally"	
					continue
				}
				set n 1
				set OK 1
				foreach fnam $syllabs {		;#	CHECK ALL STRETCH VALUES ARE VALIDLY SET
					if {$rhshredo($n)} {
						if {[string length $rhshrink($n)] > 0} {
							if {[IsNumeric $rhshrink($n)]} {
								if {$rhshrink($n) < .1} {
									Inf "Invalid Shrink Value For File [file rootname [file tail $fnam]]"
									set OK 0
									break
								} 
							} elseif {![file exists $rhshrink($n)]} {
								Inf "Invalid Shrink Value For File [file rootname [file tail $fnam]]"
								set OK 0
								break
							} 
						}
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				Block "Doing Syllable Shrink"
				set OK 1
				set n 1
				catch {unset mixlines}
				foreach fnam $syllabs time $rhsh(atktimes) {
					if {!$rhshredo($n)} {
						if {![info exists mixline($n)]} {
							Inf "Error In Program Logic 1:  mixline($n) Does Not Already Exist"
							set OK 0
							break
						}
						lappend mixlines $mixline($n)
					} else {
						if {[string length $rhshrink($n)] <= 0} {		;#	IF NO SHRINKING, PUT SRC IN MIXFILE
							set mixline($n) [list $fnam $time 1 1 C]
							.rhshrink.c.out$n config -command "PlaySndfile $fnam 0"
							set rhshshrunk($n) 0
						} else {										;#	ELSE TIME-SHRINK THE SYLLABLE
							set preoutstrnam($n) $rhsh(basfnam)
							append preoutstrnam($n) "_prestr_" $n $evv(SNDFILE_EXT)
							set outstrnam($n) $rhsh(basfnam)
							append outstrnam($n) "_str_" $n $evv(SNDFILE_EXT)
							set rhshstranafnam($n) $rhsh(basfnam)
;# 2023							
							append rhshstranafnam($n) "_strana_" $n $evv(ANALFILE_OUT_EXT)
							set rhshanafnam($n) $rhsh(basfnam)
;# 2023
							append rhshanafnam($n) "_ana_" $n $evv(ANALFILE_OUT_EXT)
							if {![file exists $rhshanafnam($n)]} {		;# ONLY RECONSTRUCT THE ANALYSIS FILE IF IT DOESN'T ALREADY EXIST
								set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
								lappend cmd anal 1 $fnam $rhshanafnam($n) -c1024 -o3
								set prg_dun 0
								set prg_abortd 0
								catch {unset simple_program_messages}
								if [catch {open "|$cmd"} CDPidrun] {
									ErrShow "Cannot Create Analysis File For '[file rootname [file tail $fnam]]': $CDPidrun"
									catch {unset CDPidrun}
									set OK 0
									break
								} else {
									fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
								}
								vwait prg_dun
								if {$prg_abortd} {
									set prg_dun 0
								}
								if {!$prg_dun} {
									set msg "Cannot Create Analysis File For '[file rootname [file tail $fnam]]'"
									set msg [AddSimpleMessages $msg]
									ErrShow $msg
									set OK 0
									break
								}
							}											;#	SHRINK THE ANALYSIS FILE
							if {[file exists $rhshstranafnam($n)]} {
								if [catch {file delete $rhshstranafnam($n)} zit] {
									Inf "Cannot Delete Existing Shrunken Analysis File Of '[file rootname [file tail $fnam]]' In '$rhshstranafnam($n)'"
									set OK 0
									break
								}
							}
							if {[file exists $preoutstrnam($n)]} {
								if [catch {file delete $preoutstrnam($n)} zit] {
									Inf "Cannot Delete Existing Shrunken Pre-Dovetailed '[file rootname [file tail $fnam]]' In '$preoutstrnam($n)'"
									set OK 0
									break
								}
							}
							if {[file exists $outstrnam($n)]} {
								if [catch {file delete $outstrnam($n)} zit] {
									Inf "Cannot Delete Existing Shrunken '[file rootname [file tail $fnam]]' In '$outstrnam($n)'"
									set OK 0
									break
								}
							}
							set cmd [file join $evv(CDPROGRAM_DIR) stretch]
							lappend cmd time 1 $rhshanafnam($n) $rhshstranafnam($n) $rhshrink($n)
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							if [catch {open "|$cmd"} CDPidrun] {
								ErrShow "Cannot Shrink '[file rootname [file tail $fnam]]': $CDPidrun"
								catch {unset CDPidrun}
								set OK 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Cannot Shrink '[file rootname [file tail $fnam]]'"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
								set OK 0
								break
							}											;#	CONVERT SHRUNK ANALYSIS FILE TO SOUNDFILE
							set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
							lappend cmd synth $rhshstranafnam($n) $preoutstrnam($n)
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							if [catch {open "|$cmd"} CDPidrun] {
								ErrShow "Cannot Create Shrunken '[file rootname [file tail $fnam]]' Sound From Analysis File: $CDPidrun"
								catch {unset CDPidrun}
								set OK 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Cannot Create Shrunken '[file rootname [file tail $fnam]]' Sound From Analysis File"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
								set OK 0
								break
							}											;#	DOVETAIL END OF SHRUNKEN SNDFILE
							set cmd [file join $evv(CDPROGRAM_DIR) envel]
							lappend cmd dovetail 1 $preoutstrnam($n) $outstrnam($n) 0.0 0.02 1 1 -t0
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							if [catch {open "|$cmd"} CDPidrun] {
								ErrShow "Cannot Dovetail End Of Shrunken '[file rootname [file tail $fnam]]' Sound From Analysis File: $CDPidrun"
								catch {unset CDPidrun}
								set OK 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Cannot Dovetail End Of Shrunken '[file rootname [file tail $fnam]]' Sound"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
								set OK 0
								break
							}

							set mixline($n) [list $outstrnam($n) $time 1 1 C]
							.rhshrink.c.out$n config -command "PlaySndfile $outstrnam($n) 0"
							set rhshshrunk($n) 1
						}
						lappend mixlines $mixline($n)
					}
					incr n
				}
				if {!$OK} {
					UnBlock
					continue
				}
				set OK 0
				set n 1
				foreach fnam $syllabs {
					if {$rhshshrunk($n)} {
						set OK 1
						break
					}
					incr n
				}
				if {!$OK} {
					Inf "No Syllables Have Been Shrunk"
					UnBlock
					continue
				}
				if {[file exists $shrunkfnam]} {
					if [catch {file delete $shrunkfnam} zit] {
						Inf "Cannot Delete Existing Shrunk File '$shrunkfnam'"
						UnBlock
						continue
					}
				}
				set badboth 0
				if {[file exists $bothfnam]} {
					if [catch {file delete $bothfnam} zit] {
						Inf "Cannot Delete Existing Shrunk + Source Mixed Soundfile '$bothfnam'"
						set badboth 1
					}
				}
				if {[file exists $bothmixfnam]} {
					if [catch {file delete $bothmixfnam} zit] {
						Inf "Cannot Delete Mixfile '$bothmixfnam' For Shrunk + Source Sound Mix"
						set badboth 1
					}
				}
				if {[file exists $mixfnam]} {
					if [catch {file delete $mixfnam} zit] {
						Inf "Cannot Delete Existing Mixfile '$mixfnam'"
						UnBlock
						continue
					}
				}
				if [catch {open $mixfnam "w"} zit] {
					Inf "Cannot Open File '$mixfnam' To Create Mix For Shrunk Sound Sequence"
					UnBlock
					continue
				}
				foreach line $mixlines {
					puts $zit $line
				}
				close $zit	
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd mix $mixfnam $shrunkfnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Create Final Shrunk Sequence: $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg  "Cannot Create Final Shrunk Sequence"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {![file exists $bothfnam]} {
					if [catch {open $bothmixfnam "w"} zit] {
						ErrShow "Cannot Create Mixfile To Mix Src And Shrunk File"
					} else {
						set rhsh(origoffset) $rhsh(offset)
						set line [list $srcsnd 0 1 .2 C]
						puts $zit $line
						set line [list $shrunkfnam $rhsh(offset) 1 .8 C]
						puts $zit $line
						close $zit
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd mix $bothmixfnam $bothfnam
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Cannot Mix Shrunk Sequence With Source: $CDPidrun"
							catch {unset CDPidrun}
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Cannot Mix Shrunk Sequence With Source"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
							}
						}
					}
				}
				foreach name [array names rhshredo] {		;#	ONCE WE'VE DONE THE FIRST OUTPUT, ENABLE THE "redo" BUTTONS
					$f.c.re$name config -state normal				
				}
				.rhshrink.c.out0 config -command "PlaySndfile $shrunkfnam 0" -text "Shrunk Phrase"
				if {!$badboth && [file exists $bothfnam]} {
					.rhshrink.c.both config -command "PlaySndfile $bothfnam 0" -text "Play Both"
				}
				UnBlock
			}
			3 {
				if {[string length $rhsh(outfnam)] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $rhsh(outfnam)]} {
					continue
				}
				if {![file exists $shrunkfnam]} {
					Inf "No Output Sound To Save"
					continue
				}
				set outfnam $rhsh(outfnam)
				append outfnam $evv(SNDFILE_EXT)
				set outmixfnam $rhsh(outfnam)
				append outmixfnam [GetTextfileExtension mix]
				if {[file exists $outfnam]} {
					set msg "File '$outfnam' Already Exists: Do You Want To Overwrite It??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					} elseif [catch {file delete $outfnam} zit] {
						Inf "Cannot Delete Existing File $outfnam"
						continue
					} else {
						DataManage delete $outfnam
						set i [LstIndx $outfnam $wl]
						if {$i >= 0} {
							PurgeArray $outfnam
							RemoveFromChosenlist $outfnam
							incr total_wksp_cnt -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				if {[file exists $outmixfnam]} {
					set msg "File '$outmixfnam' Already Exists: Do You Want To Overwrite It??"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					} elseif [catch {file delete $outmixfnam} zit] {
						Inf "Cannot Delete Existing File $outmixfnam"
						continue
					} else {
						set i [LstIndx $outmixfnam $wl]
						if {$i >= 0} {
							PurgeArray $outmixfnam
							RemoveFromChosenlist $outmixfnam
							incr total_wksp_cnt -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				Block "Outputting Data and Sounds"
				set OK 1
				set n 1
				catch {unset outmixlines}
				catch {unset report}
				catch {unset last_outfile_x}
				foreach fnam $syllabs {
					if {$rhshshrunk($n)} {			;#	IF A FILE HAS BEEN SHRUNK: RENAME TEMP SHRUNK FILE AND OUTPUT TO WORKSPACE, MODIFYING MIXFILE LINE ACCORDINGLY
						set newname [file rootname [file tail $fnam]]
						append newname "_shrunk" $evv(SNDFILE_EXT)
						if {[file exists $newname]} {
							set msg "File '$newname' Already Exists: Do You Want To Overwrite It??"
							set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
							if {$choice == "no"} {
								set OK 0
								break
							} elseif [catch {file delete $newname} zit] {
								Inf "Cannot Delete Existing File '$newname'"
								set OK 0
								break
							} else {
								set i [LstIndx $newname $wl]
								if {$i >= 0} {
									PurgeArray $newname
									RemoveFromChosenlist $newname
									incr total_wksp_cnt -1
									$wl delete $i
									catch {unset rememd}
								}
							}
						}
						if [catch {file rename $outstrnam($n) $newname} zit] {
							Inf "Cannot Rename Shrunk '$fnam' Syllable ($outstrnam($n)) To '$newname'"
							set OK 0
							break
						}
						if {[FileToWkspace $newname 0 0 0 0 1] > 0} {
							lappend last_outfile_x $newname
						}
						lappend report $newname
						set mixline($n) [lreplace $mixline($n) 0 0 $newname]
					}
					lappend outmixlines $mixline($n)	;#	OUTMIXLINES USE NON-TEMPORARY FILES ONLY
					incr n
				}
				if {!$OK} {
					if {[info exists report]} {
						DoShrinkReport $report
					}
					UnBlock
					continue
				}
				if [catch {file rename $shrunkfnam $outfnam} zit] {
					Inf "Cannot Rename Output File '$shrunkfnam' To '$outfnam'"
					if {[info exists report]} {
						DoShrinkReport $report
					}
					if {[info exists last_outfile_x]} {
						set last_outfile $last_outfile_x
					}
					UnBlock
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					set last_outfile_x $outfnam
				}
				lappend report $outfnam
				if [catch {open $outmixfnam "w"} zit] {
					Inf "Cannot Open Output Output Mixfile '$outmixfnam'"
					if {[info exists report]} {
						DoShrinkReport $report
					}
					if {[info exists last_outfile_x]} {
						set last_outfile $last_outfile_x
					}
					UnBlock
					continue
				}
				foreach line $outmixlines {
					puts $zit $line
				}
				close $zit	
				if {[FileToWkspace $outmixfnam 0 0 0 0 1] > 0} {
					set last_outfile $outmixfnam
				}
				lappend report $outmixfnam
				UnBlock
				set finished 1
			}
			4 {
				if {![file exists $bothfnam]} {
					continue
				}
				if {$rhsh(origoffset) == $rhsh(offset)} {
					Inf "No Change In Offset"	
					continue						
				}
				set bothbakfnam $evv(DFLT_OUTNAME)
				append bothbakfnam "_bak" $evv(SNDFILE_EXT)
				if [catch {file delete $bothbakfnam} zit] {
					Inf "Cannot Make Backup Copy Of Existing Shrunk + Source Mixed Soundfile '$bothfnam'"
					continue
				}
				if [catch {file rename $bothfnam $bothbakfnam} zit] {
					Inf "Cannot Make Backup Copy Of Existing Shrunk + Source Mixed Soundfile '$bothfnam'"
					continue
				}
				if {[file exists $bothmixfnam]} {
					if [catch {file delete $bothmixfnam} zit] {
						Inf "Cannot Delete Mixfile '$bothmixfnam' For Shrunk + Source Sound Mix"
						continue
					}
				}
				if [catch {open $bothmixfnam "w"} zit] {
					ErrShow "Cannot Create Mixfile To Mix Src And Shrunk File"
					if [catch {file rename $bothbakfnam $bothfnam} zit] {
						Inf "Cannot Restore Original Shrunk + Source Mixed Soundfile '$bothfnam'"
						continue
					}
				} else {
					set line [list $srcsnd 0 1 .2 C]
					puts $zit $line
					set line [list $shrunkfnam $rhsh(offset) 1 .8 C]
					puts $zit $line
					close $zit
					set cmd [file join $evv(CDPROGRAM_DIR) submix]
					lappend cmd mix $bothmixfnam $bothfnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Mix Shrunk Sequence With Source: $CDPidrun"
						if [catch {file rename $bothbakfnam $bothfnam} zit] {
							Inf "Cannot Restore Original Shrunk + Source Mixed Soundfile '$bothfnam'"
						}
						catch {unset CDPidrun}
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Cannot Mix Shrunk Sequence With Source"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							if [catch {file rename $bothbakfnam $bothfnam} zit] {
								Inf "Cannot Restore Original Shrunk + Source Mixed Soundfile '$bothfnam'"
							}
						}
					}
				}
				set rhsh(origoffset) $rhsh(offset)
			}
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	if [info exists report] {
		DoShrinkReport $report
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#--- Edit brkpntfile for shrinking a syllable OR edit attack_times

proc EditShrink {n len} {
	global from_shrink rhshfnam rhsh evv
	if {![file exists $rhshfnam($n)]} {
		Inf "No File To Edit"
		return
	}
	set from_shrink $n
	ReadFile
	set from_shrink 0
	if {$n > $len} {	;#	THIS IS ATK-TIMES FILE
		if [catch {open $rhshfnam($n) "r"} zit] {
			Inf "Cannot Open Attack-Times File To Read Edited Values"
			return
		}
		set cnt 0
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			if {![IsNumeric $line]} {
				Inf "Wrong Data Format For Attack Times (One Time On Each Line)"
				close $zit
				return
			}
			if {$cnt == 0} {
				if {$line < 0.0} {
					Inf "Wrong Data Format For Attack Times (Times Must Be >= Zero)"
					close $zit
					return
				}
			} else {
				if {$line <= $lasttime} {
					Inf "Attack Times Not Increasing At '$line'"
					close $zit
					return
				}
			}
			lappend times $line
			set lasttime $line
			incr cnt
		}
		close $zit
		if {![info exists times]} {
			Inf "NO DATA IN FILE '$rhshfnam($n)'"
			return
		}
		if {[llength $times] != $len} {
			Inf "Incorrect Number Of Attack Times In Attack-Times File"
			return
		}
		set rhsh(atktimes) $times		
	}
}
	
#--- Report files output by shrink process

proc DoShrinkReport {report} {
	set msg "The Following Files Have Been Placed On The Workspace\n\n"
	foreach fnam $report {
		append msg $fnam "\n"
	}
	Inf $msg
}

#--- Help info

proc ShrinkHelp {} {
	set msg "SHRINKING SYLLABLES IN A PHRASE, WHILE RETAINING ITS RHYTHM\n"
	append msg "\n"
	append msg "THE INPUTS ARE\n"
	append msg "1)   a textfile of the attacktimes of the syllables in the original phrase.\n"
	append msg "2)   the Source Sound (MONO).\n"
	append msg "3)   the cut syllables themselves (MONO).\n"
	append msg "\n"
	append msg "Syllables which are long enough are shrunk\n"
	append msg "taking account of (unshrinkable) plosives and (less shrinkable) sibillants.\n"
	append msg "\n"
	append msg "THE OUTPUTS ARE\n"
	append msg "1)    The shrunken syllables (if any).\n"
	append msg "2)    A mixfile for reassembling them in the rhythm of the source.\n"
	append msg "3)    A reassembly of the original phrase using the shrunken syllables.\n"
	append msg "\n"
	append msg "YOU CAN ALSO HEAR A MIX OF SOURCE AND -SHRUNK VERSION (\"Play Both\")\n"
	append msg "\n"
	append msg "The starttime-offset in this mix Can be adjusted....\n"
	append msg "1)    MouseClick on Value to lower it.\n"
	append msg "2)    Shift-MouseClick to raise it.\n"
	append msg "3)    PRESS OFFSET BUTTON TO REMIX with new offset.\n"
	Inf $msg
}

#------ Change Offsettime between srcf and shrunkmix

proc IncrRhshOffset {up} {
	global rhsh
	if {$up} {
		set rhsh(offset) [expr $rhsh(offset) + 0.01]
	} else {
		set rhsh(offset) [expr $rhsh(offset) - 0.01]
		if {$rhsh(offset) < 0.0} {
			set rhsh(offset) 0.0
		}
	}
	set rhsh(offset) [DecPlaces $rhsh(offset) 2]
}

#--- Generalised timewarping of text-data files (mixfiles, brkpnt files, timelists)

proc DataWarp {} {
	global wl chlist chused total_wksp_cnt rememd pr_warpwarp ww_fnam pa wstk evv last_outfile

	if {![info exists chlist] || ([llength $chlist] != 2)} {
		Inf "Select A Data File (mix, brkpnt data or timelist) And A Timewarp Breakpoint File"
		return
	}
	set datafile [lindex $chlist 0]
	set warpfile [lindex $chlist 1]

	set ftyp $pa($warpfile,$evv(FTYP))
	if {![IsABrkfile $ftyp]} {
		Inf "'$warpfile' Is Not A Valid Warp-data File\n\nSelect A Data File (mix, brkpnt data or timelist) And A Timewarp Breakpoint File"	
		return
	}
	set ftyp $pa($datafile,$evv(FTYP))
	if {![IsABrkfile $ftyp] && ![IsAMixfile $ftyp] && !($ftyp & $evv(NUMLIST))} {
		Inf "'$datafile' Is Not A Valid Filetype To Be Time-Warped\n\nSelect A Data File (mix, brkpnt data or timelist) And A Timewarp Breakpoint File"	
		return
	}
	set output_exists 0


	set f .warpwarp
	if [Dlg_Create $f "TIME-WARP DATA FILE" "set pr_warpwarp 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_warpwarp 0" -highlightbackground [option get . background {}]
		button $f.0.d -text "Do Warp" -command "set pr_warpwarp 1" -highlightbackground [option get . background {}]
		pack $f.0.d -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Output Filename "
		entry $f.1.e -textvariable ww_fnam -width 16
		pack $f.1.ll $f.1.e -side left
		pack $f.1 -side top
		wm resizable $f 1 1
		bind $f <Escape> {set pr_warpwarp 0}
		bind $f <Return> {set pr_warpwarp 1}
	}
	set pr_warpwarp 0
	set ww_fnam ""
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_warpwarp $f.1.e
	set finished 0
	while {!$finished} {
		tkwait variable pr_warpwarp
		if {$pr_warpwarp} {
			if {[string length $ww_fnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $ww_fnam]} {
				continue
			}
			set ext [file extension $datafile]
			set outfnam [string tolower $ww_fnam]
			append outfnam $ext
			set is_delete 0
			if {[file exists $outfnam]} {
				if {![CouetteAllowsDelete $outfnam]} {
					continue
				}
				set msg "File '$outfnam' Already Exists: Overwrite It ?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set is_delete 1
			}
			if {!$output_exists} {
				if [catch {open $warpfile "r"} zit] {
					Inf "Cannot Open File '$warpfile'"
					continue
				}
				set OK 1
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					set isval 0
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] <= 0} {
							continue
						}
						if {$isval} {
							if {$item <= 0.0} {
								Inf "Zero Timewarp: Impossible"
								set OK 0
								break
							} else {
								set item [expr 1.0 / $item]
							} 
						}
						lappend brk $item
						set isval [expr !$isval]
					}
				}
				close $zit
				if {!$OK} {
					continue
				}
				if [catch {open $datafile "r"} zit] {
					Inf "Cannot Open File '$datafile'"
					continue
				}
				set linecnt 0
				catch {unset nulines}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					set cnt 0
					catch {unset nuline}
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] <= 0} {
							continue
						}
						if {[IsAMixfile $ftyp]} {
							if {$cnt == 0} {
								if {[string match [string index $item 0] ";"]} {
									set iscomment 1
								} else {
									set iscomment 0
								}
								lappend comments $iscomment
							} elseif {($cnt == 1) && !$iscomment} {
								lappend tabtimes $item
							}
						} elseif {[IsABrkfile $ftyp]} {
							if {$cnt == 0} {
								lappend tabtimes $item
								set iscomment 0
								lappend comments $iscomment
							}
						} elseif {$ftyp & $evv(NUMLIST)} {
							if {$cnt > 0} {
								Inf "Times In This Type Of Datafile Must Be On Separate Lines"
								close $zit
								return
							} elseif {$linecnt == 0} {
								set lasttime $item
								if {$lasttime < 0.0} {
									Inf "Times In Datafile Must Be >= 0"
									close $zit
									return
								}
							} elseif {$item <= $lasttime} {
								Inf "Times In Datafile Must Increase"
								close $zit
								return
							}
							set lasttime $item
							lappend tabtimes $item
							set iscomment 0
							lappend comments $iscomment
						}
						lappend nuline $item
						incr cnt
					}
					lappend nulines $nuline
					incr linecnt
				}
				close $zit
				set tabtimes [DataWarpCore $tabtimes $brk 1]
				set linecnt 0
				set tabindex 0
				set len [llength $nulines]
				while {$linecnt < $len} {
					set line	  [lindex $nulines  $linecnt]
					set iscomment [lindex $comments $linecnt]
					if {[IsAMixfile $ftyp]} {
						if {!$iscomment} {
							set line [lreplace $line 1 1 [lindex $tabtimes $tabindex]]
							set nulines [lreplace $nulines $linecnt $linecnt $line]
							incr tabindex
						}
					} elseif {[IsABrkfile $ftyp]} {
						set line [lreplace $line 0 0 [lindex $tabtimes $tabindex]]
						set nulines [lreplace $nulines $linecnt $linecnt $line]
						incr tabindex
					} elseif {$ftyp & $evv(NUMLIST)} {
						set nulines [lreplace $nulines $linecnt $linecnt [lindex $tabtimes $tabindex]]
						incr tabindex
					}
					incr linecnt
				}
				set output_exists 1
			}
			if {$is_delete} {
				if [catch {file delete $outfnam} zit] {
					Inf "Cannot Delete Existing File '$outfnam'"
					continue
				} else {
					DataManage delete $outfnam
					set i [LstIndx $outfnam $wl]
					if {$i >= 0} {
						PurgeArray $outfnam
						RemoveFromChosenlist $outfnam
						incr total_wksp_cnt -1
						$wl delete $i
						catch {unset rememd}
					}
				}
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write The New Data"
				continue
			}
			foreach line $nulines {
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "Warped File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set chused $chlist
			SaveMetaProcessFilesUsed
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#----- Function to integrate the time-stretching function, to generate the new  time-valus in the timepdata table

proc DataWarpCore {tabtimes warpbrk algo} {

	set evv(CONTROL_SRATE) 1000

	set tablen [llength $tabtimes]
	set tabindex 0											;#	GET FIRST TIME IN TIME-DATA TABLE
	set tabtime [lindex $tabtimes $tabindex]
	set totaloutdur_samps 0.0								;#	ACCUMULATES OUTPUT-DURATION (MULTIPLIED BY SAMPLE-RATE)
	set intimeincr [expr 1.0 / $evv(CONTROL_SRATE)]			;#	TIME INCREMENT AT EACH SAMPLE-TIME ADVANCE
	set warpbrklen [llength $warpbrk]
	set warpbrkindex 0
	set lasttime	[lindex $warpbrk $warpbrkindex]			;#	INITIAL TIME AND STRETCH IN WARP-TABLE -> LASTVALS
	incr warpbrkindex
	set laststretch [lindex $warpbrk $warpbrkindex]
	incr warpbrkindex
	set done 0
	set intime 0.0
	switch -- $algo {
		1 {			;#	TIMESQUEEZE ALGORITHM AS USED IN BRASSAGE
			while {!$done} {
				set thistime [lindex $warpbrk $warpbrkindex]		;#	PAIR THIS WARPTABLE VAL-TIME-SET WITH LAST
				incr warpbrkindex
				set thisstretch [lindex $warpbrk $warpbrkindex]
				incr warpbrkindex
				set timestep	[expr $thistime - $lasttime]		;#	FIND DURATION OF THIS WARP-BRKPNT SEGMENT
				set stretchstep [expr $thisstretch - $laststretch]	;#	FIND CHANGE IN (STRETCH) VALUE OVER THIS SEG
				set xdrange [expr $timestep * $evv(CONTROL_SRATE)]	;#	FIND NUMBER OF SAMPLING STEPS DURING THIS DURATION
				set xrange  [expr int(floor($xdrange))]				;#	NUMBER OF WHOLE SAMPLING STEPS
				set remnant [expr $xdrange - $xrange]				;#	ANY FRAGMENT OF SAMPLING STEPS AT END
				set stretchincr [expr double($stretchstep) / double($xdrange)]
																	;#	FIND INCREMENT IN STRETCHVAL FOR EACH SAMPLE STEP
				set stretch $laststretch
				set intime $lasttime								;#	SET INITIAL VALUE OF STRETCH & INPUT-TIME FOR THIS BRKPNT PAIR
				set x 0
				while {$x < $xrange} {								;#	ADVANCE, ONE SAMPLE AT A TIME
					if {$tabtime <= $intime} {						;#	IF WE'VE REACHED A TIME IN INPUT DATA TABLE, RESET IT AS CORRESPONDING OUTPUT TIME
						set outtime  [expr $totaloutdur_samps / double($evv(CONTROL_SRATE))]
						set last_tabintime $tabtime
						set last_taboutime $outtime
						set tabtimes [lreplace $tabtimes $tabindex $tabindex $outtime]
						incr tabindex
						if {$tabindex >= $tablen} {					;#	IF WE'RE AT END OF INPUT DATA TABLE, QUIT
							set done 1
							break
						}											;#	ELSE ADVANCE TO NEXT TIME IN INPUT DATA TABLE
						set tabtime [lindex $tabtimes $tabindex]
					}
					set dur [expr 1.0 / $stretch]					;#	CALCULATE DURATION FROM STRETCH AT THIS SAMPLE
					set totaloutdur_samps [expr $totaloutdur_samps + $dur]	;#	ACCUMUALTE TOTAL OUTPUT DURATION
					set stretch [expr $stretch + $stretchincr]		
					set intime  [expr $intime + $intimeincr]		;#	RESET STRETCH AND INTIME FOR NEXT SAMPLE IN LOOP
					incr x
				}
				if {$done} {
					break
				}
				if {$remnant > 0} {									;#	IF ANY PART-SAMPLE AT END......
					if {$tabtime <= $intime} {
						set outtime [expr $totaloutdur_samps / double($evv(CONTROL_SRATE))]
						set last_tabintime $tabtime
						set last_taboutime $outtime
						set tabtimes [lreplace $tabtimes $tabindex $tabindex $outtime]
						incr tabindex
						if {$tabindex >= $tablen} {
							set done 1
							break
						}
						set tabtime [lindex $tabtimes $tabindex]
					}
					set dur [expr (1.0 / $thisstretch) * $remnant]		;#	CALCULATE DURATION OF PARTSAMPLE, BASED ON FINAL STRETCH
					set totaloutdur_samps [expr $totaloutdur_samps + $dur]	;#	BUT ONLY OVER PART OF A SAMPLE
				}
				if {$warpbrkindex >= $warpbrklen} {						;#	IF WE'VE RUN OUT OF WARP-TABLE VALUES, QUIT THE LOOP
					break
				}
				set lasttime $thistime
				set laststretch $thisstretch
			}
		}
		2 {		;#	TIMESTRETCH ALGORITHM AS USED IN PVOC, GIVES SAME RESULT AS ALGO-1 BUT DOES not CORREPSOND TO PVOC TSTRETCHING!!

			set tabsamptime [expr $tabtime * $evv(CONTROL_SRATE)]
			set totaloutsampdur 0
			set lastsamptime [expr round($lasttime * $evv(CONTROL_SRATE))]
			set lastdur $laststretch
			while {!$done} {
				set thistime [lindex $warpbrk $warpbrkindex]
				incr warpbrkindex
				set thisstretch [lindex $warpbrk $warpbrkindex]
				incr warpbrkindex
				set thissamptime [expr round($thistime * $evv(CONTROL_SRATE))]
				set warpsegdur_in_insamps [expr $thissamptime - $lastsamptime]
				set thisdur $thisstretch
				set intime $lasttime
				set durdiff [expr $thisdur - $lastdur]
				if {[Flteq $durdiff 0.0]} {										;#	IF NO CHANGE IN TSTRETCH VALUE
					set dcount [expr double($warpsegdur_in_insamps)/$lastdur]
					set count [expr int(round(abs($dcount)))]
					set dur [expr double($warpsegdur_in_insamps)/double($count)]
					set n 0
					set this_timeincr [expr $intimeincr * $dur]
					while {$n < $count} {
						if {$tabtime <= $intime} {
							set outtime [expr $totaloutsampdur + $n]			;#	SIMPLE CALC OF OUTPUT POS
							set outtime [expr double($outtime) / double($evv(CONTROL_SRATE))]
							set last_tabintime $tabtime
							set last_taboutime $outtime
							set tabtimes [lreplace $tabtimes $tabindex $tabindex $outtime]
							incr tabindex
							if {$tabindex >= $tablen} {
								set done 1
								break
							}
							set tabtime [lindex $tabtimes $tabindex]
							set tabsamptime [expr $tabtime * $evv(CONTROL_SRATE)]
						}
						set intime [expr $intime + $this_timeincr]
						incr n
					}
					set totaloutsampdur [expr $totaloutsampdur + $n]	
				} else {											;#	CHANGING TSTRETCH, USE EXPONENTIAL CALC (as ANAL STRETCH CODE)
					set insamptime [expr $lasttime * $evv(CONTROL_SRATE)]

					set dcount [expr double($lastdur)/double($thisdur)]
					set dcount [expr log($dcount)]
					set dcount [expr $dcount * double($warpsegdur_in_insamps)/$durdiff]
					set count [expr int(round(abs($dcount)))]

					set param0 [expr $thisdur - $lastdur]
					set param1 [expr $param0/double($warpsegdur_in_insamps)]
					set param2 [expr $lastdur * double($warpsegdur_in_insamps)]

					set positions {}								;#	CREATE AN ARRAY OF OUT TIMES CORRESPONDING TO INITIMES
					set n 0
					while {$n < $count} {
						set pos [expr $param1 * double($n)]
						set pos [expr (exp($pos) * $param2) - $param2]
						set pos [expr $pos / $param0]
						lappend positions $pos
						incr n
					}	
					if {$dcount > 0.0} {
						set positions [ReverseWarpPositions $positions]		;#	REVERSE ORDER
					}
					set n 0
					set thissec_starttime $insamptime
					while {$n < $count} {
						set dur [lindex $positions $n]					;#	ACCUMULUATE OUTPUT DUR CONTINUALLY
						set insamptime [expr $thissec_starttime + $dur]
						if {$tabsamptime <= $insamptime} {
							set outtime [expr double($totaloutsampdur) / double($evv(CONTROL_SRATE))]
							set last_tabintime $tabtime
							set last_taboutime $outtime
							set tabtimes [lreplace $tabtimes $tabindex $tabindex $outtime]
							incr tabindex
							if {$tabindex >= $tablen} {
								set done 1
								break
							}
							set tabtime [lindex $tabtimes $tabindex]
							set tabsamptime [expr $tabtime * double($evv(CONTROL_SRATE))]
						}
						incr n
						incr totaloutsampdur
					}
				}
				if {$warpbrkindex >= $warpbrklen} {						;#	IF WE'VE RUN OUT OF WARP-TABLE VALUES, QUIT THE LOOP
					break
				}
				set lasttime $thistime
				set lastdur $thisdur
				set lastsamptime $thissamptime
			}
		}
	}
	if {!$done} {												;# IF AT END OF WARP-TABLE BUT NOT AT END OF DATA TABLE
		set lastdur [expr 1.0 / $thisstretch]					;# FIND FINAL DURATION-MUTIPLIER OF WARP TABLE
		set n $tabindex										
		while {$n < $tablen} {									;#	FOR ALL REMAINING TIMES IN DATA TABLE
			set time [lindex $tabtimes $n]		
			set timestep [expr $time - $last_tabintime]			;#	FIND TIMESTEP FROM LAST TABLE-INPPUTTIME-TO-HAVE-BEEN-MODIFIED
			set timestep [expr $timestep * $lastdur]			;#	ALTER THE TIMESTEP BY THE FINAL WARPING VALUE
			set time [expr $last_taboutime + $timestep]			;#	RESET THE TABLE TIME AS AN OUTPUT TIME, USING THIS TIMESTEP
			set tabtimes [lreplace $tabtimes $n $n $time]		;#	THEN REPLACE INTIME BY OUTTIME IN DATA TABLE
			incr n
		}
	}
	return $tabtimes
}

proc ReverseWarpPositions {positions} {

	set startpos [lindex $positions 0]
	set lastpos $startpos
	foreach pos [lrange $positions 1 end] {
		lappend diffs [expr $pos - $lastpos]
		set lastpos $pos
	}
	set diffs [ReverseList $diffs]
	set newpos $startpos
	lappend newpositions $newpos
	foreach diff $diffs {
		set newpos [expr $newpos + $diff]
		lappend newpositions $newpos
	}
	return $newpositions
}

##########################################################
# REPLACE ALL SOUND, EXCEPT SPECIFIED EVENTS, BY SILENCE #
##########################################################

proc EventIsolator {tomix} {
	global isofnam isosplice isocuts pr_isolate chlist total_wksp_cnt prg_dun prg_abortd CDPidrun wstk chused pa evv wl rememd
	global blist_change background_listing isotag isooff simple_program_messages last_outfile
	if {![info exists chlist] || ([llength $chlist] != 1)} {
		set ilist [$wl curselection]
		if {([lindex $ilist 0] == -1) || ([llength $ilist] != 1)} {
			Inf "Select A Single Soundfile"
			return
		}
		set fnam [$wl get [lindex $ilist 0]]
	} else {
		set ischused 1		
		set fnam [lindex $chlist 0]
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	set chans $pa($fnam,$evv(CHANS))
	set srate [expr double($pa($fnam,$evv(SRATE)))]
	set invsrate [expr 1.0 / $srate]
	set mixfnam	$evv(DFLT_OUTNAME)
	append mixfnam 1 $evv(TEXT_EXT)
	set bakfnam	$evv(MACH_OUTFNAME)
	append bakfnam 1 $evv(TEXT_EXT)
	set silfil $evv(MACH_OUTFNAME)
	append silfil $evv(SNDFILE_EXT)
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0

	set f .isolate
	if [Dlg_Create $f "ISOLATE SPECIFIED EVENTS" "set pr_isolate 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.1
		frame $f.2
		frame $f.3
		button $f.0.do -text "Create Outfile" -command "set pr_isolate 1" -highlightbackground [option get . background {}]
		button $f.0.sv -text "Sound View" -command "SnackDisplay $evv(SN_TIMEPAIRS) isolate 0 $fnam" -bd 2 -state normal -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		pack $f.0.do $f.0.sv -side left -padx 2
		button $f.0.q -text "Quit" -command "set pr_isolate 0" -highlightbackground [option get . background {}]
		pack $f.0.q -side right
		label $f.1.ll -text "Use \"Sound View\" to specify which parts of sound to isolate" -fg $evv(SPECIAL)
		pack $f.1.ll -side top -pady 2
		if {$tomix} {
			label $f.2.fn -text "Mixfile Name "
		} else {
			label $f.2.fn -text "Output Filename "
		}
		entry $f.2.e -textvariable isofnam -width 16
		label $f.2.sll -text "Splicelen (mS) "
		entry $f.2.spl -textvariable isosplice
		pack $f.2.fn $f.2.e $f.2.sll $f.2.spl -side left -pady 2
		pack $f.0 -side top -fill x -expand true
		pack $f.1 $f.2 -side top
		if {$tomix} {
			label $f.3.xt -text "Cut Files Nametag"
			entry $f.3.xe -textvariable isotag -width 6
			label $f.3.to -text "Time Offset (only needed if ADDING data to existing mixfile)"
			entry $f.3.of -textvariable isooff -width 6
			pack $f.3.xt $f.3.xe $f.3.to $f.3.of -side left -pady 2
			pack $f.3 -side top
		}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_isolate 0}
		bind $f <Return> {set pr_isolate 1}
	}
	wm title $f "ISOLATE SPECIFIED EVENTS IN FILE [file rootname [file tail $fnam]]"
	set isosplice 15
	set isooff 0
	set isotag "iso"
	set isofnam ""
	catch {unset isocuts}
	set pr_isolate 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_isolate $f.2.e
	set finished 0
	while {!$finished} {
		tkwait variable pr_isolate
		if {$pr_isolate} {
			if {![info exists isocuts] ||([llength $isocuts] <= 0)} {
				Inf "No Retained Segments Specified (use \"Sound View\")"	
				continue
			}
			catch {unset mixtimes}
			catch {unset isotimes}
			set len 0
			foreach line $isocuts {
				set starttime [expr double([lindex $line 0]) * $invsrate]
				lappend mixtimes $starttime
				incr len
			}
			set len_less_one [expr $len - 1]
			set n 0
			while {$n < $len_less_one} {
				set mix_n [lindex $mixtimes $n]
				set cut_n [lindex $isocuts $n]
				set m $n
				incr m
				while {$m < $len} {
					set mix_m [lindex $mixtimes $m]
					set cut_m [lindex $isocuts $m]
					if {$mix_m < $mix_n} {
						set mixtimes [lreplace $mixtimes $m $m $mix_n]
						set mixtimes [lreplace $mixtimes $n $n $mix_m]
						set mix_n $mix_m
						set isocuts [lreplace $isocuts $m $m $cut_n]
						set isocuts [lreplace $isocuts $n $n $cut_m]
						set cut_n $cut_m
					}
					incr m
				}
				incr n
			}
			foreach line $isocuts starttime $mixtimes {
				set endtime [expr double([lindex $line 1]) * $invsrate]
				lappend isotimes $starttime $endtime
				incr len
			}
			if {$tomix} {
				if {[string length $isooff] <= 0} {
					Inf "No Offset Time Entered"
					continue
				}
				if {![IsNumeric $isooff] || ($isooff < 0.0)} {
					Inf "Invalid Offset Time Entered"
					continue
				}
				if {[string length $isotag] <= 0} {
					Inf "No Cut Files Nametag Entered"
					continue
				}
				if {![regexp {^[a-zA-Z]+$} $isotag]} {
					Inf "Invalid Cut Files Nametag Entered (Must Be Alphabetic)"
					continue
				}
				set isotag [string tolower $isotag]
				set OK 1
				set n 0
				catch {unset mixcutfnams}
				set basnam [file rootname $fnam]
				foreach {startcut endcut} $isotimes {
					set thisofnam $basnam
					append thisofnam "_" $isotag $n $evv(SNDFILE_EXT)
					if {[file exists $thisofnam]} {
						Inf "You Cannot Overwrite The Existing File '$thisofnam'\n\nChoose A Different Name-Tag\nOr Delete The Existing File(s)"
						set OK 0
						break
					}
					lappend mixcutfnams $thisofnam
					incr n
				}
				set silcutfnam $basnam
				append silcutfnam "_" $isotag $n $evv(SNDFILE_EXT)
				if {!$OK} {
					continue
				}
			}
			if {[string length $isosplice] <= 0} {
				Inf "No Splice Length Entered"
				continue
			}
			if {![IsNumeric $isosplice] || ($isosplice < 0)} {
				Inf "Invalid Splice Length Entered"
				continue
			}
			set splicelen  [expr $isosplice * $evv(MS_TO_SECS)]
			if {$splicelen >= [expr $pa($fnam,$evv(DUR)) / 2.0]} {
				Inf "Splice Length Too Long For Input Sound"
				continue
			}
			if {[string length $isofnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $isofnam]} {
				continue
			}
			set outfnam [string tolower $isofnam]
			if {$tomix} {
				append outfnam [GetTextfileExtension mix]
				catch {unset existing_mixlines}
			} else {
				append outfnam $evv(SNDFILE_EXT)
			}
			set query_overwrite 0
			if {[file exists $outfnam]} {
				set query_overwrite 1
				if {$tomix} {
					if {![info exists pa($outfnam,$evv(FTYP))]} {
						set ftyp [FindFileType $fnam]
					} else {
						set ftyp $pa($outfnam,$evv(FTYP))
					}
					if {[IsAMixfile $ftyp]} {
						set msg "Append New Sounds To File '$outfnam' ?"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "yes"} {
							if [catch {file copy $outfnam $bakfnam} zit] {
								set msg "Failed To Back Up Existing Mixfile '$outfnam': Continue Anyway ?"
								set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
								if {$choice == "no"} {
									continue
								}
							}
							catch {unset existing_mixlines}
							if [catch {open $outfnam "r"} zit] {
								Inf "Cannot Open Existing Mixfile '$outfnam'"
								continue
							}
							while {[gets $zit line] >= 0} {
								lappend existing_mixlines $line
							}
							close $zit
							set query_overwrite 0
						}
					}
				}
				if {$query_overwrite} {
					set msg "File '$outfnam' Already Exists: Overwrite It ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				set i [LstIndx $outfnam $wl]
				set blist_change 0
				if {![DeleteFileFromSystem $outfnam 0 1]} {
					Inf "Cannot Delete Existing File '$outfnam'"
					continue
				} else {
					DummyHistory $outfnam "DESTROYED"
					if {$tomix} {
						MixMPurge 1
					} else {
						if {[IsInAMixfile $outfnam]} {
							if {[MixM_ManagedDeletion $outfnam]} {
								MixMStore
							}
						}
						if {$blist_change} {
							SaveBL $background_listing
						}
					}
					if {$i >= 0} {
						WkspCnt [$wl get $i] -1
						$wl delete $i
						catch {unset rememd}
					}
				}
			}
			Block "CREATING ISOLATED-SOUNDS OUTPUT"
			if {!$tomix || ![info exists existing_mixlines]} {	;#	ONLY CREATE SILENCE PADDING IF NOT A MIX OUTPUT
				set cmd [file join $evv(CDPROGRAM_DIR) synth]	;#	OR IS A MIX OUTPUT, AND NOT APPENDING TO AN EXISTING MIX
				lappend cmd silence $silfil $srate $chans [lindex $isotimes end]
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Create Dummy Silentfile To Pad Output: $CDPidrun"
					catch {unset CDPidrun}
					RestoreOrigMixfile $tomix $bakfnam $outfnam
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Create Dummy Silentfile To Pad Output"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					RestoreOrigMixfile $tomix $bakfnam $outfnam
					UnBlock
					continue
				}
			}
			set OK 1
			set n 0
			catch {unset ofnams}
			foreach {startcut endcut} $isotimes {
				set thisofnam $evv(DFLT_OUTNAME)$n
				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd cut 1 $fnam $thisofnam $startcut $endcut -w$isosplice
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Do Edit [expr $n + 1] Of Soundfile '$fnam': $CDPidrun"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Do Edit [expr $n + 1] Of Soundfile '$fnam'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				lappend ofnams $thisofnam
				incr n
			}
			if {!$OK} {
				RestoreOrigMixfile $tomix $bakfnam $outfnam
				UnBlock
				continue
			}
			if [catch {open $mixfnam "w"} zit] {
				Inf "Cannot Open File '$mixfnam' To Write Mixing Data"	
				RestoreOrigMixfile $tomix $bakfnam $outfnam
				UnBlock
				continue
			}
			if {$tomix} {
				if {[file exists $silfil]} {
					if {[catch {file rename $silfil $silcutfnam} zit2]} {
						Inf "Cannot Rename Silence Padding File '$silfil' To '$silcutfnam' For The Mixfile"
						close $zit
						UnBlock
						continue
					}
#REDUNDANT ??
					DataManage delete $silcutfnam
					set silfil $silcutfnam
				}
				set OK 1
				foreach ofnam $ofnams mixcutfnam $mixcutfnams {
					if [catch {file rename $ofnam$evv(SNDFILE_EXT) $mixcutfnam} zit2] {
						Inf "Cannot Rename File '$ofnam' To '$mixcutfnam' For The Mixfile\n\nSaving Existing Cutfiles And Returning To Workspace"
						set OK 0
						break
					}
				}
				if {!$OK} {
					close $zit
					RestoreOrigMixfile $tomix $bakfnam $outfnam
					catch {unset last_outfile_x}
					foreach mixcutfnam $mixcutfnams {
						if {[file exists $mixcutfnam]} {
							UpdateBakupLog $mixcutfnam create 1
							if {[FileToWkspace $mixcutfnam 0 0 0 0 1] > 0} {
								lappend last_outfile_x $mixcutfnam
							}
						}
					} 
					if {[info exists last_outfile_x]} {
						set last_outfile $last_outfile_x
					}
					UnBlock
					break
				}
				set ofnams $mixcutfnams
				catch {unset nutims}
				foreach tim $mixtimes {
					lappend nutims [expr $tim + $isooff]
				}
				set mixtimes $nutims

			} else {
				catch {unset nu_ofnams}
				foreach ofnam $ofnams {
					lappend nu_ofnams $ofnam$evv(SNDFILE_EXT)
				}
				set ofnams $nu_ofnams
			}
			if {$tomix} {
				if {[file exists $silfil]} {
					set line [list $silfil 0 1 1 C]
					puts $zit $line
				}
				if {[info exists existing_mixlines]} {
					foreach line $existing_mixlines {
						puts $zit $line
					}
				}
			} else {
				set line [list $silfil 0 1 1 C]
				puts $zit $line
			}
			foreach ofnam $ofnams time $mixtimes {
				set line $ofnam
				lappend line $time $chans 1
				if {$chans < 2} {
					lappend line "C"
				}
				puts $zit $line
			}
			close $zit
			if {$tomix} {
				UnBlock
				if [catch {file rename $mixfnam $outfnam} zit] {
					set msg "Cannot Rename Temporary Mixfile '$mixfnam' To '$outfnam'\n\n"
					append msg "Rename This File Outside The Soundloom, Before Quitting This Dialog Box"
					Inf $msg
				}
				foreach mixcutfnam $mixcutfnams {
					UpdateBakupLog $mixcutfnam create 0
					FileToWkspace $mixcutfnam 0 0 0 0 1
				} 
				UpdateBakupLog $outfnam create 1
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					set msg "Mixfile '$outfnam' And The Edited Soundfiles Are Now On The Workspace"
					set last_outfile $outfnam
				}
				if {[file exists $silfil]} {
					append msg "\n\nThe File '$silfil' Is A Silent File To Force Start Of Sounds In File To Correct Time"
				}
				Inf $msg
				break
			}
			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd mix $mixfnam $outfnam
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Cannot Create Isolated-Sounds Output: $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Cannot Create Isolated-Sounds Output"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			UpdateBakupLog $outfnam create 1
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is Now On The Workspace"
				set last_outfile $outfnam
			}
			UnBlock
			if {[info exists ischused]} {
				set chused $fnam
				SaveMetaProcessFilesUsed
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f 
	destroy $f
}

#----- Restore a backdup mixfile, if necessary

proc RestoreOrigMixfile {tomix bakfnam mixfnam} {
	if {$tomix && [file exists $bakfnam]} {
		if [catch {file rename $bakfnam $mixfnam} zit] {
			set msg "CANNOT RESTORE ORIGINAL MIXFILE '$mixfnam'\n\n"
			append msg "ORIGINAL DATA IS IN FILE '$bakfnam'\n\n"
			append msg "RENAME THIS FILE OUTSIDE THE SOUNDLOOM, BEFORE QUITTING THIS DIALOG BOX"
			Inf $msg
		}
	}
}

########################################
# SYNCHRONISE TWO SOUNDS AT TIME MARKS #
########################################

proc SynchroniseSoundsAtTimeMarks {mode} {
	global symafnam symasamps pr_syncmarks syncmarkfil symaoffset chlist total_wksp_cnt rememd prg_dun prg_abortd CDPidrun wstk wl pa evv
	global chused symagotnew syncpulse syncMM symaunitdotted symasoften simple_program_messages isolate_adj
	global blist_change background_listing last_outfile
	switch -- $mode {
		0 {
			if {![info exists chlist] || ([llength $chlist] != 2)} {
				set ilist [$wl curselection]
				if {[llength $ilist] != 2} {
					Inf "Select Two Soundfiles"
					return
				}
				set fnam1 [$wl get [lindex $ilist 0]]
				set fnam2 [$wl get [lindex $ilist 1]]
			} else {
				set ischused 1
				set fnam1 [lindex $chlist 0]
				set fnam2 [lindex $chlist 1]
			}
			if {($pa($fnam1,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam2,$evv(FTYP)) != $evv(SNDFILE))} {
				Inf "Select (Two) Soundfiles"
				return
			}
			set chans $pa($fnam2,$evv(CHANS))
			set srate $pa($fnam2,$evv(SRATE))
		}
		3 {
			if {![info exists chlist] || ([llength $chlist] != 2)} {
				set ilist [$wl curselection]
				if {[llength $ilist] != 2} {
					Inf "Select One Soundfile And One List Of Times"
					return
				}
				set fnam1 [$wl get [lindex $ilist 0]]
				set fnam2 [$wl get [lindex $ilist 1]]
			} else {
				set ischused 1
				set fnam1 [lindex $chlist 0]
				set fnam2 [lindex $chlist 1]
			}
			if {($pa($fnam1,$evv(FTYP)) != $evv(SNDFILE)) && ($pa($fnam2,$evv(FTYP)) != $evv(SNDFILE))} {
				Inf "Select One Soundfile And One List Of Times"
				return
			}
			if {![IsAListofNumbers $pa($fnam1,$evv(FTYP))] && ![IsAListofNumbers $pa($fnam2,$evv(FTYP))]} {
				Inf "Select One Soundfile And One List Of Times"
				return
			}
			if {$pa($fnam1,$evv(FTYP)) != $evv(SNDFILE)} {
				set numfnam $fnam1
				set fnam1 $fnam2
			} else {
				set numfnam $fnam2
			}
			if [catch {open $numfnam "r"} zit] {
				Inf "Cannot Open File '$numfnam' To Read Timing Information"
				return
			}
			catch {unset symatimes(2)}
			set cnt 0
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					if {$cnt == 0} {
						if {$item < 0.0} {
							Inf "Invalid (Negative) Time In File '$numfnam'"
							close $zit
							return
						}
					} else {
						if {$item <= $lasttime} {
							Inf "Times Not In Increasing Order In File '$numfnam'"
							close $zit
							catch {unset symatimes(2)}
							return
						}
					}
					lappend symatimes(2) $item
					set lasttime $item
					incr cnt
				}
			}
			close $zit
			if {![info exists symatimes(2)] || ([llength $symatimes(2)] <= 2)} {
				Inf "Insufficient Data In File '$numfnam'"
				return
			}
			set chans $pa($fnam1,$evv(CHANS))
			set srate $pa($fnam1,$evv(SRATE))
		}
		4 {
			if {![info exists chlist] || ([llength $chlist] < 2)} {
				Inf "Select Two Or More Soundfiles"
				return
			}
			foreach fnam $chlist {
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					Inf "Not All The Selected Files Are Soundfiles"
					return
				}
			}
			set fnam1 [lindex $chlist 0]
			catch {unset symasamps}
			if {![LoadExistingSymaInfo $fnam1 1]} {
				Inf "No Timemark Information For File '$fnam1' Exists"
				return
			}
			Block "CREATING TIMEMARKS"
			foreach fnam [lrange $chlist 1 end] {
				set infofnam [file join $evv(URES_DIR) "_syma_"]
				append infofnam [file rootname [file tail $fnam]] $evv(TEXT_EXT)
				if {[file exists $infofnam]} {
					set msg "Timemark Information Already Exists For File '$fnam'. Overwrite It ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						UnBlock
						continue
					}
				}
				if {[catch {open $infofnam "w"} zit]} {
					Inf "Cannot Open File '$infofnam' To Write Timemark Data"
					UnBlock
					continue
				}
				foreach line $symasamps(1) {
					puts $zit $line
				}
				close $zit
			}
			set chused $chlist
			SaveMetaProcessFilesUsed
			UnBlock
			Inf "Timemarks Created"
			return
		}
		5 {
			if {![info exists chlist] || ([llength $chlist] != 3)} {
				Inf "Select Three Soundfiles"
				return
			}
			foreach fnam $chlist {
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					Inf "Not All The Selected Files Are Soundfiles"
					return
				}
			}
			set fnam2 [lindex $chlist 2]
			catch {unset symasamps}
			if {![LoadExistingSymaInfo $fnam2 2]} {
				Inf "No Timemark Information For File '$fnam2' Exists"
				return
			}
			set fnam2 [lindex $chlist 1]
			set fnam1 [lindex $chlist 0]
			set chused $chlist
			SaveMetaProcessFilesUsed
			set chans $pa($fnam2,$evv(CHANS))
			set srate $pa($fnam2,$evv(SRATE))
		}
		6 {
			if {![info exists chlist] || ([llength $chlist] != 1)} {
				set i [$wl curselection]
				if {([llength $i] != 1) || ($i == -1)} {
					Inf "Select A Soundfile"
					return
				}
				set fnam1 [$wl get $i]
			} else {
				set ischused 1
				set fnam1 [lindex $chlist 0]
			}
			if {$pa($fnam1,$evv(FTYP)) != $evv(SNDFILE)} {
				Inf "Select A Soundfile"
				return
			}
			set infofnam [file join $evv(URES_DIR) "_syma_"]
			append infofnam [file rootname [file tail $fnam1]] $evv(TEXT_EXT)
			if {[file exists $infofnam]} {
				set msg "Timemark Information Already Exists For File '$fnam1'. Overwrite It ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					return
				}
			}
			set fnam2 0
			set chans $pa($fnam1,$evv(CHANS))
			set srate $pa($fnam1,$evv(SRATE))
		}
		default {
			if {![info exists chlist] || ([llength $chlist] != 1)} {
				set ilist [$wl curselection]
				if {([llength $ilist] != 1) || ([lindex $ilist 0] == -1)} {
					Inf "Select One Soundfile"
					return
				}
				set fnam1 [$wl get [lindex $ilist 0]]
			} else {
				set ischused 1
				set fnam1 [lindex $chlist 0]
			}
			if {$pa($fnam1,$evv(FTYP)) != $evv(SNDFILE)} {
				Inf "Select A Soundfile"
				return
			}
			set chans $pa($fnam1,$evv(CHANS))
			set srate $pa($fnam1,$evv(SRATE))
			set fnam2 0
		}
	}
	set origfnam2 $fnam2
	set invsrate [expr 1.0 / $srate]
	if {$chans > 1} {
		Inf "This Facility Only Works With Mono Files For The Moment"
		return
	}
	set analfnam $evv(DFLT_OUTNAME)
;# 2023
	append analfnam 0 $evv(ANALFILE_OUT_EXT)
	set stretchfnam $evv(DFLT_OUTNAME)
	append stretchfnam 1 $evv(TEXT_EXT)
	set strfnam $evv(DFLT_OUTNAME)
;# 2023
	append strfnam 1 $evv(ANALFILE_OUT_EXT)
	set strfnam2 $evv(DFLT_OUTNAME)
	append strfnam2 2 $evv(SNDFILE_EXT)
	set silfil $evv(DFLT_OUTNAME)
	append silfil 3 $evv(SNDFILE_EXT)
	set silfil2 $evv(DFLT_OUTNAME) 
	append silfil2 4 $evv(SNDFILE_EXT)
	set extendfil $evv(DFLT_OUTNAME) 
	append extendfil 5 $evv(SNDFILE_EXT)
	set play2fnam $evv(DFLT_OUTNAME)
	append play2fnam 6 $evv(SNDFILE_EXT)

	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	set syncmarkfil 0
	set syncmarkpurge 0
	set f .isolate
	if [Dlg_Create $f "WARP FILE" "set pr_syncmarks 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.1
		frame $f.2
		frame $f.3
		frame $f.4
		frame $f.44
		frame $f.4a -bg $evv(POINT) -height 1
		frame $f.5
		button $f.0.do -text "Create Outfile" -command "set pr_syncmarks 1" -highlightbackground [option get . background {}]
		pack $f.0.do -side left
		if {$mode != 5} {
			button $f.0.sv -text "Sound View" -command "GetSyncMarksDataFromSoundView $fnam1 $fnam2" -bd 2 -state normal -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
			pack $f.0.sv -side left -padx 2
		}
		button $f.0.q -text "Quit" -command "set pr_syncmarks 0" -highlightbackground [option get . background {}]
		pack $f.0.q -side right
		if {$mode != 5} {
			label $f.1.ll -text "Use \"Sound View\" to set synchronisation points in sounds" -fg $evv(SPECIAL)
			pack $f.1.ll -side top -pady 2
		}
		switch -- $mode {
			0 {
				label $f.2.ll -text "Mark sync points for file : "
				grid $f.2.ll -column 0 -row 0
				radiobutton $f.2.1 -text "1        " -variable syncmarkfil -value 0
				grid $f.2.1 -column 1 -row 0
				radiobutton $f.2.2 -text "2        " -variable syncmarkfil -value 1
				grid $f.2.2 -column 2 -row 0
				frame $f.4.0 
				label $f.4.0.0 -text "Set \"Sync\"" -fg $evv(SPECIAL)
				frame $f.4.1 
				label $f.4.1.1 -text "if sounds sync at first syncmark and ALSO at time zero." -fg $evv(SPECIAL)
				frame $f.4.2 
				label $f.4.2.2 -text ""
				frame $f.4.3 
				label $f.4.3.3 -text "Set \"Offset\"" -fg $evv(SPECIAL)
				frame $f.4.4 
				label $f.4.4.4 -text "if sounds sync at first syncmark but NOT (necessarily) at time zero." -fg $evv(SPECIAL)
				frame $f.4.5 
				label $f.4.5.5 -text ""
				label $f.44.ll -text "stretch adjust "
				entry $f.44.e -textvariable isolate_adj -width 6
				button $f.44.pp -text "Play Output With Src" -command "set pr_syncmarks 4" -bg $evv(HELP) -highlightbackground [option get . background {}]
				pack $f.44.ll $f.44.e $f.44.pp -side left -padx 2
				set isolate_adj 0.0
			}
			1 {
				label $f.2.ll -text "Sync to : "
				grid $f.2.ll -column 0 -row 0
				radiobutton $f.2.1 -text "average pulse" -variable syncpulse -value 0
				grid $f.2.1 -column 1 -row 0
				radiobutton $f.2.2 -text "MM given" -variable syncpulse -value 1
				grid $f.2.2 -column 2 -row 0
				label $f.2.mll -text "MM ="
				grid $f.2.mll -column 3 -row 0
				entry $f.2.mm -textvariable syncMM -width 4
				grid $f.2.mm -column 4 -row 0
				set syncMM ""
				frame $f.4.0 
				label $f.4.0.0 -text "Set \"Sync\"" -fg $evv(SPECIAL)
				frame $f.4.1 
				label $f.4.1.1 -text "if 1st marked event can be displaced relative to zero time." -fg $evv(SPECIAL)
				frame $f.4.2 
				label $f.4.2.2 -text ""
				frame $f.4.3 
				label $f.4.3.3 -text "Set \"Offset\"" -fg $evv(SPECIAL)
				frame $f.4.4 
				label $f.4.4.4 -text "if it is to remain where it is relative to zero time." -fg $evv(SPECIAL)
				frame $f.4.5 
				label $f.4.5.5 -text ""
			}
			2 {
				label $f.2.ll -text "Time Unit : "
				grid $f.2.ll -column 0 -row 0
				radiobutton $f.2.1 -text "crotchet" -variable symaunitdotted -value 0
				grid $f.2.1 -column 1 -row 0
				radiobutton $f.2.2 -text "dotted crotchet" -variable symaunitdotted -value 1
				grid $f.2.2 -column 2 -row 0
				label $f.2.mll -text "MM ="
				grid $f.2.mll -column 3 -row 0
				entry $f.2.mm -textvariable syncMM -width 4
				set syncMM ""
				grid $f.2.mm -column 4 -row 0
				checkbutton $f.2.soft -text "soften" -variable symasoften
				grid $f.2.soft -column 5 -row 0
				set symasoften 0
				set symaunitdotted 0
				frame $f.4.0 
				label $f.4.0.0 -text "Set \"Offset\"" -fg $evv(SPECIAL)
				frame $f.4.1 
				label $f.4.1.1 -text "if 1st marked event is NOT at time zero." -fg $evv(SPECIAL)
				frame $f.4.2 
				label $f.4.2.2 -text ""
				frame $f.4.3 
				label $f.4.3.3 -text "\"Soften\"" -fg $evv(SPECIAL)
				frame $f.4.4 
				label $f.4.4.4 -text "makes dotted rhythms less 'spiky'." -fg $evv(SPECIAL)
				frame $f.4.5 
				label $f.4.5.5 -text ""
			}
			3 -
			5 {
				label $f.2.ll -text ""
				grid $f.2.ll -column 0 -row 0
				frame $f.4.0 
				label $f.4.0.0 -text "Set \"Offset\"" -fg $evv(SPECIAL)
				frame $f.4.1 
				label $f.4.1.1 -text "if 1st marked event is NOT at time zero." -fg $evv(SPECIAL)
				frame $f.4.2 
				label $f.4.2.2 -text ""
				frame $f.4.3 
				label $f.4.3.3 -text ""
				frame $f.4.4 
				label $f.4.4.4 -text ""
				frame $f.4.5 
				label $f.4.5.5 -text ""
			}
			6 {
				label $f.2.ll -text ""
				grid $f.2.ll -column 0 -row 0
				frame $f.4.0 
				label $f.4.0.0 -text ""
				frame $f.4.1 
				label $f.4.1.1 -text ""
				frame $f.4.2 
				label $f.4.2.2 -text ""
				frame $f.4.3 
				label $f.4.3.3 -text ""
				frame $f.4.4 
				label $f.4.4.4 -text ""
				frame $f.4.5 
				label $f.4.5.5 -text ""
			}
		}
		pack $f.4.0.0 -side left
		pack $f.4.0 -side top -fill x -expand true
		pack $f.4.1.1 -side left
		pack $f.4.1 -side top -fill x -expand true
		pack $f.4.2.2 -side left
		pack $f.4.2 -side top -fill x -expand true
		pack $f.4.3.3 -side left
		pack $f.4.3 -side top -fill x -expand true
		pack $f.4.4.4 -side left
		pack $f.4.4 -side top -fill x -expand true
		pack $f.4.5.5 -side left
		pack $f.4.5 -side top -fill x -expand true
		if {$mode != 6} {
			label $f.2.lla -text "First marked points are : "
			grid $f.2.lla -column 0 -row 1
			radiobutton $f.2.1a -text syncd  -variable symaoffset -value 0
			grid $f.2.1a -column 1 -row 1
			radiobutton $f.2.2a -text offset -variable symaoffset -value 1
			grid $f.2.2a -column 2 -row 1
			label $f.3.fn -text "Output Filename "
			entry $f.3.e -textvariable symafnam -width 16
			pack $f.3.fn $f.3.e -side left -pady 2
		}
		label $f.5.0 -text  "Purge time-mark information : " -fg $evv(QUIT_COLOR)
		radiobutton $f.5.1 -text "some" -variable syncmarkpurge -value 1 -fg $evv(QUIT_COLOR) -command "set pr_syncmarks 3"
		radiobutton $f.5.2 -text "ALL" -variable syncmarkpurge -value 0 -fg $evv(QUIT_COLOR) -command "set pr_syncmarks 2"
		pack $f.5.0 $f.5.1 $f.5.2 -side left
		pack $f.0 -side top -fill x -expand true
		pack $f.1 $f.2 $f.3 -side top
		pack $f.4 -side top -fill x -expand true
		pack $f.44 -side top -pady 2  
		pack $f.4a -side top -fill x -expand true -pady 2
		pack $f.5 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_syncmarks 0}
	}
	catch {unset symagotnew}
	if {$mode != 5} {
		catch {unset symasamps}
	}
	catch {unset issymainfo}
	if {[LoadExistingSymaInfo $fnam1 1]} {
		set issymainfo(1) 1
	}
	if {($mode == 0) || ($mode == 5)} {
		if {[LoadExistingSymaInfo $fnam2 2]} {
			set issymainfo(2) 1
		}
	}
	set symaoffset 0
	set syncpulse -1
	set syncmarkfil 0
	if {$mode == 0} {
		wm title $f "WARP FILE [file rootname [file tail $fnam2]]"
	} else {
		wm title $f "WARP FILE [file rootname [file tail $fnam1]]"
	}
	set symafnam ""
	set pr_syncmarks 0
	raise $f
	update idletasks
	StandardPosition $f
	if {$mode == 6} {
		My_Grab 0 $f pr_syncmarks
	} else {
		My_Grab 0 $f pr_syncmarks $f.3.e
	}
	set end_silence_added 0
	set finished 0
	while {!$finished} {
		tkwait variable pr_syncmarks
		switch -- $pr_syncmarks {
			3 {
				set msg "Are You Sure You Want To Permanently Destroy The Time-Mark Information For Some Soundfiles ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				PurgeSymaInfoFiles 0
			}
			2 {
				set msg "Are You Sure You Want To Permanently Destroy All The Time-Mark Information For All Soundfiles !! ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				PurgeSymaInfoFiles 1
			}
			1 {
				if {$mode != 6} {
					if {$mode == 0} {
						DeleteAllTemporaryFilesWhichAreNotCDPOutput except $analfnam
						if {![IsNumeric $isolate_adj] || ($isolate_adj > 1.0) || ($isolate_adj < -1.0)} {
							Inf "Stretch Adjust Out Of Range"
							continue
						}
					}
					if {[string length $symafnam] <= 0} {
						Inf "No Output Filename Entered"
						continue
					}
					if {![ValidCDPRootname $symafnam]} {
						continue
					}
					set outfnam [string tolower $symafnam]
					append outfnam $evv(SNDFILE_EXT)

					if {[file exists $outfnam]} {
						set msg "FILE '$outfnam' Already Exists: Overwrite It ?"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
						set i [LstIndx $outfnam $wl]
						set blist_change 0
						if {![DeleteFileFromSystem $outfnam 0 1]} {
							Inf "Cannot Delete Existing File '$outfnam'"
							continue
						} else {
							DummyHistory $outfnam "DESTROYED"
							if {[IsInAMixfile $outfnam]} {
								if {[MixM_ManagedDeletion $outfnam]} {
									MixMStore
								}
							}
							if {$blist_change} {
								SaveBL $background_listing
							}
							if {$i >= 0} {
								WkspCnt [$wl get $i] -1
								$wl delete $i
								catch {unset rememd}
							}
						}
					}
				}
				catch {unset symatimes(1)}
				if {$mode != 3} {
					catch {unset symatimes(2)}
				}
				if {![info exists symasamps(1)] || ([llength $symasamps(1)] <= 0)} {
					Inf "No Times Marked In File 1 (Use \"Sound View\")"	
					continue
				}
				if {[lindex $symasamps(1) 0] != 0} {
					set symasamps(1) [concat 0 $symasamps(1)]
				}
				if {$mode == 6} {		;#	WRITE ENTERED TIMEMARKS
					set infofnam [file join $evv(URES_DIR) "_syma_"]
					append infofnam [file rootname [file tail $fnam1]] $evv(TEXT_EXT)
					if {[catch {open $infofnam "w"} zit]} {
						Inf "Cannot Open File '$infofnam' To Write Timemark Data"
						continue
					}
					foreach line $symasamps(1) {
						puts $zit $line
					}
					close $zit
					if {[info exists ischused]} {
						set chused $chlist
						SaveMetaProcessFilesUsed
					}
					Inf "Timemark Created"
					break
				}
				foreach val1 $symasamps(1) {
					set symatime [expr double($val1) * $invsrate]
					lappend symatimes(1) $symatime
				}
				set OK 1
				set len [llength $symatimes(1)]
				set len_less_one [expr $len - 1]
				set n 0
				while {$n < $len_less_one} {
					set tim_n [lindex $symatimes(1) $n]
					set m $n
					incr m
					while {$m < $len} {
						set tim_m [lindex $symatimes(1) $m]
						if {[Flteq $tim_n $tim_m]} {
							Inf "Duplicated Time-Points In First File"
							set OK 0
							break
						} elseif {$tim_m < $tim_n} {
							set $symatimes(1) [lreplace $symatimes(1) $m $m $tim_n]
							set $symatimes(1) [lreplace $symatimes(1) $n $n $tim_m]
							set tim_n $tim_m
						}
						if {!$OK} {
							break
						}
						incr m
					}
					if {!$OK} {
						break
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				switch -- $mode {
					0 -
					5 {				;#	SYNC TMARKS IN ONE FILE TO TMARKS IN OTHER

						if {![info exists symasamps(2)] || ([llength $symasamps(2)] <= 0)} {
							Inf "No Times Marked In File 2 (Use \"Sound View\")"
							continue
						}
						if {[lindex $symasamps(2) 0] != 0} {
							set symasamps(2) [concat 0 $symasamps(2)]
						}
						set len1 [llength $symasamps(1)] 
						set len2 [llength $symasamps(2)]
						if {$len1 > $len2} {
							set minlen $len2
						} else {
							set minlen $len1
						}
						incr minlen -1
						set symatimes(1) [lrange $symatimes(1) 0 $minlen]
						set symasamps(2) [lrange $symasamps(2) 0 $minlen]

						foreach val2 $symasamps(2) {
							set symatime [expr double($val2) * $invsrate]
							lappend symatimes(2) $symatime
						}
						set OK 1
						set len $minlen
						set len_less_one [expr $len - 1]
						set n 0
						while {$n < $len_less_one} {
							set tim_n [lindex $symatimes(2) $n]
							set m $n
							incr m
							while {$m < $len} {
								set tim_m [lindex $symatimes(2) $m]
								if {[Flteq $tim_n $tim_m]} {
									Inf "Duplicated Time-Points In Second File"
									set OK 0
									break
								} elseif {$tim_m < $tim_n} {
									set $symatimes(2) [lreplace $symatimes(2) $m $m $tim_n]
									set $symatimes(2) [lreplace $symatimes(2) $n $n $tim_m]
									set tim_n $tim_m
								}
								if {!$OK} {
									break
								}
								incr m
							}
							if {!$OK} {
								break
							}
							incr n
						}
						if {!$OK} {
							continue
						}
					}
					1 {		;#	SYNC FILE AT TMARKS TO PULSE

						set len [llength $symatimes(1)]
						switch -- $syncpulse {
							0 {
								if {$symaoffset} {
									set div [expr $len - 2]
									set tottime [expr [lindex $symatimes(1) end] - [lindex $symatimes(1) 1]]
								} else {
									set div [expr $len - 1]
									set tottime [expr [lindex $symatimes(1) end] - [lindex $symatimes(1) 0]]
								}
								set timestep [expr $tottime/double($div)]
							}
							1 {
								if {[string length $syncMM] <= 0} {
									Inf "No Metronome Mark Entered"	
									continue
								}
								if {![IsNumeric $syncMM] || ($syncMM < 10) || ($syncMM > 400)} {
									Inf "Invalid Metronome Mark"		
									continue
								}
								set timestep [expr 60.0/double($syncMM)]
							}
							default {
								Inf "Type Of Pulse Syncing Is Not Specified"	
								continue
							}
						}
						set n 0 
						lappend symatimes(2) [lindex $symatimes(1) $n]
						incr n
						if {$n < $len} {
							if {$symaoffset} {
								lappend symatimes(2) [lindex $symatimes(1) $n]
								incr n
							}
						}
						set lasttime [lindex $symatimes(2) end]
						while {$n < $len} {
							lappend symatimes(2) [expr $lasttime + $timestep]
							set lasttime [lindex $symatimes(2) end]
							incr n
						}
						set temp $symatimes(2)
						set symatimes(2) $symatimes(1)
						set symatimes(1) $temp
					}
					2 {			;#	SYNC FILE AT TMARKS TO RHYTHM

						set symatimes(2) [DecodeRhythmToProportions $fnam1]
						if {[llength $symatimes(2)] <= 0} {
							continue
						}
						if {$symaoffset} {
							set valoffset [lindex $symatimes(1) 1]
							foreach val $symatimes(2) {
								set nuval [expr $val + $valoffset]
								lappend nuvals $nuval
							}
							set symatimes(2) [concat 0.0 $nuvals]
							set symaoffset 0
						}
						set len1 [llength $symatimes(1)] 
						set len2 [llength $symatimes(2)]
						if {$len1 > $len2} {
							set minlen $len2
						} else {
							set minlen $len1
						}
						incr minlen -1
						set symatimes(1) [lrange $symatimes(1) 0 $minlen]
						set symatimes(2) [lrange $symatimes(2) 0 $minlen]
						set temp $symatimes(2)
						set symatimes(2) $symatimes(1)
						set symatimes(1) $temp
					}
					3 {			;#	SYNC FILE AT TMARKS TO TIMECUES

						if {$symaoffset} {
							set valoffset [lindex $symatimes(1) 1]
							foreach val $symatimes(2) {
								set nuval [expr $val + $valoffset]
								lappend nuvals $nuval
							}
							set symatimes(2) [concat 0.0 $nuvals]
							set symaoffset 0
						}
						set len1 [llength $symatimes(1)] 
						set len2 [llength $symatimes(2)]
						if {$len1 > $len2} {
							set minlen $len2
						} else {
							set minlen $len1
						}
						incr minlen -1
						set symatimes(1) [lrange $symatimes(1) 0 $minlen]
						set symatimes(2) [lrange $symatimes(2) 0 $minlen]
						set temp $symatimes(2)
						set symatimes(2) $symatimes(1)
						set symatimes(1) $temp
					}
				}
				catch {unset outvals}
				set cnt 0
				set lasttime1 [lindex $symatimes(1) 0]
				set lasttime2 [lindex $symatimes(2) 0]
				set thistime1 [lindex $symatimes(1) 1]
				set thistime2 [lindex $symatimes(2) 1]
				catch {unset offlen}
				if {$symaoffset} {
					set offlen [expr $thistime1 - $thistime2]
					if {$offlen < 0} {
						set msg "Cannot Offset 2nd File By A Negative Amount\n"
						append msg "You Can Offset Sound 1 When Remixing With The Warped Sound\n"
						append msg "Using An Offset Time Of [expr -$offlen] Seconds\n\n"
						append msg "Do You Want To Proceed ??"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						} else {
							unset offlen
						}
					} elseif {[Flteq $offlen 0.0]} {
						unset offlen
					}
				}
				set diff1 [expr double($thistime1) - double($lasttime1)]
				set diff2 [expr double($thistime2) - double($lasttime2)]
				set OK 1
				foreach time1 [lrange $symatimes(1) 2 end] time2 [lrange $symatimes(2) 2 end] {
					if {$cnt == 0} {
						set time $lasttime2
					} else {
						set time [expr $lasttime2 + 0.002]
					}
					if {($cnt == 0) && $symaoffset} {
						set ratio 1
					} else {
						set ratio [expr $diff1 / $diff2]
						if {($mode == 0) && ![Flteq $isolate_adj 0.0]} {
							set ratio [expr $ratio + $isolate_adj]
							if {$ratio <= $evv(FLTERR)} {
								Inf "Stretch Adjustment Incompatible With Data Generated"
								set OK 0
								break
							}
						}
					}
					lappend outvals $time $ratio
					set time [expr $thistime2 - 0.002]
					lappend outvals $time $ratio
					set diff1 [expr double($time1) - double($thistime1)]
					set diff2 [expr double($time2) - double($thistime2)]
					set lasttime2 $thistime2
					set thistime1 $time1
					set thistime2 $time2
					incr cnt
				}
				if {!$OK} {
					continue
				}
				if {$cnt == 0} {
					set time $lasttime2
				} else {
					set time [expr $lasttime2 + 0.002]
				}
				set ratio [expr $diff1 / $diff2]
				if {($mode == 0) && ![Flteq $isolate_adj 0.0]} {
					set ratio [expr $ratio + $isolate_adj]
					if {$ratio <= $evv(FLTERR)} {
						Inf "Stretch Adjustment Incompatible With Data Generated"
						continue
					}
				}
				lappend outvals $time $ratio
				set time [expr $thistime2 - 0.002]
				lappend outvals $time $ratio
				set time [expr $thistime2 + 0.002]
				lappend outvals $time 1.0
				lappend outvals 10000 1.0
				if [catch {open $stretchfnam "w"} zit] {
					Inf "Cannot Open File '$stretchfnam' To Write Time-Stretching Values"
					UnBlock
					continue
				}
				foreach {time stretch} $outvals {
					set line $time
					append line "   " $stretch
					puts $zit $line
				}
				close $zit
				if {$mode == 0} {
					Block "TIMEWARPING THE SECOND SOUND"
				} else {
					Block "TIMEWARPING THE SOUND"
					set fnam2 $fnam1
# SEE NOTE @@@ BELOW
				}
				set origfnam2 $fnam2
				if {$end_silence_added == 0} {		;#	IF NOT EVEN TRIED TO ADD END-SILENCE
					AddSilenceToEndOfFile $fnam2 $silfil2 $extendfil
					if {[file exists $extendfil]} {
						set fnam2 $extendfil
						set end_silence_added 1		;#	SUCCEEDED IN ADDING END-SILENCE
					} else {
						set end_silence_added -1	;#	DON'T TRY TO ADD END-SILENCE AGAIN
					}
				}
				if {![file exists $analfnam]} {
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $fnam2 $analfnam -c1024 -o3
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Create Analysis File From Source: $CDPidrun"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Create Analysis File From Source"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
				}
				set cmd [file join $evv(CDPROGRAM_DIR) stretch]
				lappend cmd time 1 $analfnam $strfnam $stretchfnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Stretch The Analysis File: $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Stretch The Analysis File"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				if {[info exists offlen]} {
					lappend cmd synth $strfnam $strfnam2
				} else {
					lappend cmd synth $strfnam $outfnam
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Create Output File '$outfnam': $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Create Output File '$outfnam'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {[info exists offlen]} {
					set cmd [file join $evv(CDPROGRAM_DIR) synth]
					lappend cmd silence $silfil $srate $chans $offlen
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Create Offsetting Silence: $CDPidrun"
						catch {unset CDPidrun}
						UnBlock 
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Create Offsetting Silence"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd join $silfil $strfnam2 $outfnam -w0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Join Silence To Start Of Stretched Sound: $CDPidrun"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Join Silence To Start Of Stretched Sound"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
				}
				catch {unset last_outfile_x}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile_x $outfnam
				}
				UnBlock
				if {[info exists ischused]} {
					if {($mode == 0) || ($mode == 3)} {
						set chused [list $fnam1 $origfnam2]
					} else {
						set chused $fnam1
					}
					SaveMetaProcessFilesUsed
				}
				if {[info exists symagotnew]} {
					set msg "Do You Want To Store Any Of The Marked Points ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {$mode == 0} {
							set thisfile "File One"
						} else {
							set thisfile "File"
						}
						if {[info exists symagotnew(1)]} {
							if {[info exists issymainfo(1)]}  {
								set msg "There Is Already Stored Info For $thisfile: Replace It ??"
							} else {
								set msg "Store Marked Points For $thisfile ??"
							}
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set infofnam [file join $evv(URES_DIR) "_syma_"]
								append infofnam [file rootname [file tail $fnam1]] $evv(TEXT_EXT)
								if [catch {open $infofnam "w"} zit] {
									Inf "Cannot Open File To Store Marked Points For $thisfile"
								} else {
									foreach val $symasamps(1) {
										puts $zit $val
									}
									close $zit
								}
							}
						}

# NOTE @@@
# CARE: ALL MODES EXCEPT 0 & 5 PRODUCE NO symagotnew(2) AS ONLY 1 IS SNDFILE USED
# SO THE CODE BELOW DOESN'T RESPOND IN THOSE MODES, AND THUS USING origfnam2 DOESN'T MATTER.
# IMPORTANT BECAUSE IN THOSE MODES origfnam2 = fnam2 ACTUALLY GETS THE NAME OF fnam1 !!!! 

						if {[info exists symagotnew(2)]} {
							if {[info exists issymainfo(2)]}  {
								set msg "There Is Already Stored Info For File Two: Replace It ??"
							} else {
								set msg "Store Marked Points For File Two ??"
							}
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set infofnam [file join $evv(URES_DIR) "_syma_"]
								append infofnam [file rootname [file tail $origfnam2]] $evv(TEXT_EXT)
								if [catch {open $infofnam "w"} zit] {
									Inf "Cannot Open File To Store Marked Points For File 2"
								} else {
									foreach val $symasamps(2) {
										puts $zit $val
									}
									close $zit
								}
							}
						}
					}
				}
				if {$mode != 0} {
					if {[info exists last_outfile_x]} {
						set last_outfile $last_outfile_x
					}
					set finished 1
				}
			}
			4 {
				if {![file exists $play2fnam]} {
					if {![info exists outfnam] || ![file exists $outfnam]} {
						Inf "No Output File Generated"
						continue
					}
					set cmd [file join $evv(CDPROGRAM_DIR) submix]
					lappend cmd interleave $fnam1 $outfnam $play2fnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Mix The Two Sounds: $CDPidrun"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Mix The Two Sounds"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
				}
				PlaySndfile $play2fnam 0
			}			
			0 {
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}


proc GetSyncMarksDataFromSoundView {fnam1 fnam2} {
	global symasamps syncmarkfil symagotnew evv
	if {$syncmarkfil} {
		SnackDisplay $evv(SN_TIMESLIST) syncmarks2 0 $fnam2
		if {[info exists symasamps(0)]} {
			set symasamps(2) $symasamps(0)
			set symagotnew(2) 1
		}
	} else {
		SnackDisplay $evv(SN_TIMESLIST) syncmarks2 0 $fnam1
		if {[info exists symasamps(0)]} {
			set symasamps(1) $symasamps(0)
			set symagotnew(1) 1
		}
	}
}

#---- Remove some or all timemark data files (about synchronsation time-points)

proc PurgeSymaInfoFiles {purge} {
	global pr_symapurg evv
	if {$purge} {
		foreach fnam [glob -nocomplain [file join $evv(URES_DIR) _syma_*]] {
			catch {file delete $fnam}
		}
		return
	}
	set f .symapurg
	if [Dlg_Create $f "PURGE SYNC-MARK INFO" "set pr_symapurg 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.do -text "Purge Marks" -command "set pr_symapurg 1" -highlightbackground [option get . background {}]
		button $f.0.qu -text "Quit" -command "set pr_symapurg 0" -highlightbackground [option get . background {}]
		pack $f.0.do -side left
		pack $f.0.qu -side right
		pack $f.0 -side top -fill x -expand true
		label $f.1 -text "Select items to remove with mouse" -fg $evv(SPECIAL)
		pack $f.1 -side top
		Scrolled_Listbox $f.2 -width 32 -height 18 -selectmode extended
		pack $f.2 -side top -fill both -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_symapurg 1}
		bind $f <Escape> {set pr_symapurg 0}
	}
	$f.2.list delete 0 end
	foreach fnam [glob -nocomplain [file join $evv(URES_DIR) _syma_*]] {
		lappend fnams $fnam
		set nam [string range [file rootname [file tail $fnam]] 6 end]
		$f.2.list insert end $nam
	}
	set pr_symapurg 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_symapurg $f.2.list
	set finished 0
	while {!$finished} {
		tkwait variable pr_symapurg
		if {$pr_symapurg} {
			set ilist [$f.2.list curselection]
			if {([llength $ilist] <= 0) || ([lindex $ilist 0] == -1)} {
				Inf "No Items Selected For Removal"
				continue
			}
			set ilist [ReverseList $ilist]
			foreach i $ilist {
				set fnam [lindex $fnams $i]
				catch {file delete $fnam}
				$f.2.list delete $i
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#--- Load any info about synchronsation times

proc LoadExistingSymaInfo {fnam n} {
	global symasamps evv 
	set returnval 0
	set infofnam [file join $evv(URES_DIR) "_syma_"]
	append infofnam [file rootname [file tail $fnam]] $evv(TEXT_EXT)
	if {![file exists $infofnam]} {
		return 0
	}
	if {![catch {open $infofnam "r"} zit]} {
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			set line [split $line]
			set cnt 0
			catch {unset nuline}
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend symasamps($n) $item			 
			}
		}
		close $zit
	}
	return 1
}

#--- Generate Rhythm from graphics, and convert to time values

proc DecodeRhythmToProportions {fnam} {
	global rh_encoding symasoften symadur

	EstablishRhythmPropDisplay $fnam 1
	if {![info exists rh_encoding]} {
		return {}
	}
	set endindex -1
	set symadur {}
	set len [string length $rh_encoding]
	if {$len <= 0} {
		return {}
	}
	set k 0
	set j 1
	while {$k < $len} {
		set item [string index $rh_encoding $k]
		switch -- $item {
			"|" -
			"."	-
			":"	-
			","	{
				set code $item
				set kincr 1
			}
			default {
				set code [string range $rh_encoding $k $j]
				set kincr 2
			}
		}
		set endindex [DecodeRhythmicUnitToProportions $code $endindex]
		incr k $kincr
		incr j $kincr
	}
	if {[llength $symadur] <= 0} {
		return {}
	}
	set outtimes 0.0
	set lasttime [lindex $outtimes end]
	foreach dur $symadur {
		set val [expr $lasttime + $dur]				;#	EACH DURATION SPECIFIES START OF NEXT EVENT
		lappend outtimes $val
		set lasttime [lindex $outtimes end]
	}
	set len [llength $outtimes]
	incr len -2										;#	THERE IS NO EVENT AT END OF LAST PROPORTION
	set outtimes [lrange $outtimes 0 $len]	;#	SO ELIMINATE LAST VAL	
	return $outtimes
}

#---- Convert rhythmic encoding to time-values

proc DecodeRhythmicUnitToProportions {code endindex} {
	global syncMM symaunitdotted symasoften symadur
	set timestep [expr 60.0/double($syncMM)]
	if {$symaunitdotted} { ;#	metric unit = dotted crotchet
		switch -- $code {
			"b"		{set unitmult 1.0}
			"c"		{set unitmult 0.5}
			"d"		{set unitmult 1.333333333}
			"z"		{set unitmult 1.0}
			default {set unitmult 0.666666667}
		}
	} else  {		;#	metric unit = crotchet
		switch -- [string index $code 0] {
			"b"		{set unitmult 1.5}
			"c"		{set unitmult 0.75}
			"d"		{set unitmult 2.0}
			"z"		{set unitmult 1.5}
			default	{set unitmult 1.0}
		}
	}

	switch -- $code {
		"w4" { set vals 4.0 }
		"x4" { set vals 2.0 }				
		"w6" { set vals 6.0 }
		"x6" { set vals 3.0 }
		"a0" { set vals 1.0 }
		"z0" { set vals 0.25 }
		"a1" { set vals [list .5 .5] }
		"a2" {
			if {$symasoften} {
				set vals [list .66666667 .33333333]
			} else {
				set vals [list .75 .25]
			}
		}
		"a3" {
			if {$symasoften} {
				set vals [list .3333 .66666667]
			} else {
				set vals [list .25 .75]
			}
		}
		"a4"	{set vals [list .5 .25 .25]}
		"a5"	{set vals [list .25 .25 .5]}
		"a6"	{set vals [list .25 .5 .25]}
		"a7"	{set vals [list .25 .25 .25 .25]}
		"a8"	{set vals [list .5 .5 .5 .5]}
		"a9"	{set vals [list .25 .25]}
		"f1"	{set vals [list .16666667 .16666667 .33333333 .33333333]}
		"f2"	{set vals [list .33333333 .16666667 .16666667 .33333333]}
		"f3"	{set vals [list .33333333 .33333333 .16666667 .16666667]}
		"f4"	{set vals [list .16666667 .16666667 .16666667 .16666667 .33333333]}
		"f5"	{set vals [list .33333333 .16666667 .16666667 .16666667 .16666667]}
		"f6"	{set vals [list .16666667 .16666667 .16666667 .16666667 .16666667 .16666667]}
		"f7"	{set vals [list .16666667 .16666667 .16666667]}
		"."	-
		":"	-
		","	{	;#	RESTS
			if {$endindex >= 0} {
				switch -- $code {
					"."	{set addon .5}
					":"	{set addon .25}
					","	{set addon 1}
				}
				set oldval [lindex $symadur $endindex]
				set newval [expr $oldval + ($addon * $unitmult)]
				set $symadur [lreplace $symadur $endindex $endindex $newval]
			}
		}
		"|" {
			;# Bar
		}
		default {	;#	b,c,d,e
			if {[string length $code] < 2} {
				Inf "UNKNOWN CODE ITEM '$code'"
				return $endindex
			}
			switch  -- [string index $code 1] {
				1 { set vals [list .33333333 .33333333 .33333333] }
				2 { set vals [list .66666667 .33333333] }
				3 { set vals [list .33333333 .66666667] }
				4 {
					if {$symasoften} {
						set vals [list .44444444 .22222222 .33333333]
					} else {
						set vals [list .5 .16666667 .33333333]
					}
				}
				5 {
					if {$symasoften} {
						set vals [list .22222222 .44444444 .33333333]
					} else {
						set vals [list .16666667 .5 .33333333]
					}
				}
				6	{
					if {$symasoften} {
						set vals [list .33333333 .44444444 .22222222]
					} else {
						set vals [list .33333333 .5 .16666667]
					}
				}
				7 { set vals [list .5 .33333333 .16666667] }
				8 { set vals [list .16666667 .33333333 .5] }
				9 {
					switch -- [string index $code 0]   {
						"b" { set vals .33333333 }
						"c" { set vals .16666667}
						default {
							Inf "UNKNOWN CODE ITEM '$code'"
							return $endindex
						}
					}
				}
				default {
					Inf "UNKNOWN CODE ITEM '$code'"
					return $endindex
				}
			}
		}
	}
	if [info exists vals] {
		foreach val $vals {
			set val [expr $val * $unitmult * $timestep]
			lappend symadur $val
			incr endindex
		}
	}
	return $endindex
}

#--- Generate Rhythm from graphics, and convert to time values

proc RerhythmMixfile {} {
	global rh_encoding symadur pr_rhmix rhmixfnam evv wstk wl pa al_wksp_cnt rememd syncMM symaunitdotted symasoften chused last_outfile
	if {![info exists chlist] || ([llength $chlist] != 1)} {
		set ilist [$wl curselection]
		if {([llength $ilist] != 1) || ([lindex $ilist 0] == -1)} {
			Inf "Select One Mixfile"
			return
		}
		set fnam [$wl get [lindex $ilist 0]]
	} else {
		set ischused 1
		set fnam [lindex $chlist 0]
	}
	if {![IsAMixfile $pa($fnam,$evv(FTYP))]} {
		Inf "Select A Mixfile"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File '$fnam'"
		return
	}
	set commentcnt 0
	set linecnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			set comment [list $linecnt $line]
			lappend comments $comment
			incr commentcnt
			incr linecnt
			continue
		}
		set line [split $line]
		set cnt 0
		catch {unset linend}
		foreach item $line {
			if {[string length $item] <= 0} {
				continue
			}
			switch -- $cnt {
				0 {
					lappend fnams $item
				}
				1 {
					lappend times $item
				}
				default {
					lappend linend $item
				}
			}
			incr cnt
		}
		lappend linends $linend	
		incr linecnt
	}
	close $zit
	set timeslen [llength $times]
	set f .rhmix
	if [Dlg_Create $f "RHYTHMICISE" "set pr_rhmix 0" -width 60 -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		button $f.0.qq -text "Abandon" -command "set pr_rhmix 0" -highlightbackground [option get . background {}]
		button $f.0.do -text "Rhythmicise" -command "set pr_rhmix 1" -highlightbackground [option get . background {}]
		pack $f.0.qq -side right
		pack $f.0.do -side left
		pack $f.0 -side top -fill x -expand true
		label $f.1.ll -text "Outfile Name "
		entry $f.1.e -textvariable rhmixfnam -width 16
		pack $f.1.ll $f.1.e -side left
		pack $f.1 -side top
		label $f.2.ll -text "Time Unit : "
		grid $f.2.ll -column 0 -row 0
		radiobutton $f.2.1 -text "crotchet" -variable symaunitdotted -value 0
		grid $f.2.1 -column 1 -row 0
		radiobutton $f.2.2 -text "dotted crotchet" -variable symaunitdotted -value 1
		grid $f.2.2 -column 2 -row 0
		label $f.2.mll -text "MM ="
		grid $f.2.mll -column 3 -row 0
		entry $f.2.mm -textvariable syncMM -width 4
		set syncMM ""
		grid $f.2.mm -column 4 -row 0
		checkbutton $f.2.soft -text "soften" -variable symasoften
		grid $f.2.soft -column 5 -row 0
		pack $f.2 -side top
		set symasoften 0
		set symaunitdotted 0
		wm resizable $f 1 1
		bind $f <Escape> {set pr_rhmix 0}
		bind $f <Return> {set pr_rhmix 1}
	}
	set syncMM ""
	set symaunitdotted 0
	set symasoften 0
	wm title $f "RHYTHMICISE [file rootname [file tail $fnam]]"
	set rhmixfnam ""
	set pr_rhmix 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_rhmix
	set finished 0
	while {!$finished} {
		tkwait variable pr_rhmix
		if {$pr_rhmix} {	
			if {[string length $rhmixfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $rhmixfnam]} {
				continue
			}
			set outfnam [string tolower $rhmixfnam]
			append outfnam [GetTextfileExtension mix]
			if {[string match $fnam $outfnam]} {
				Inf "You Cannot Overwrite The Input Mixfile"	
				continue
			}
			if {[file exists $outfnam]} {
				set msg "File '$outfnam' Already Exists: Overwrite It ?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set i [LstIndx $outfnam $wl]
				if {![DeleteFileFromSystem $outfnam 0 1]} {
					Inf "Cannot Delete Existing File '$outfnam'"
					continue
				} else {
					DummyHistory $outfnam "DESTROYED"
					MixMDelete $outfnam 1
					if {$i >= 0} {
						WkspCnt [$wl get $i] -1
						$wl delete $i
						catch {unset rememd}
					}
				}
			}
			EstablishRhythmPropDisplay $fnam 0
			if {![info exists rh_encoding]} {
				continue
			}
			set endindex -1
			set symadur {}
			set len [string length $rh_encoding]
			if {$len <= 0} {
				continue
			}
			set k 0
			set j 1
			while {$k < $len} {
				set item [string index $rh_encoding $k]
				switch -- $item {
					"|" -
					"."	-
					":"	-
					","	{
						set code $item
						set kincr 1
					}
					default {
						set code [string range $rh_encoding $k $j]
						set kincr 2
					}
				}
				set endindex [DecodeRhythmicUnitToProportions $code $endindex]
				incr k $kincr
				incr j $kincr
			}
			if {[llength $symadur] <= 0} {
				continue
			}
			set outtimes 0.0
			set lasttime [lindex $outtimes end]
			foreach dur $symadur {
				set val [expr $lasttime + $dur]		;#	EACH DURATION SPECIFIES START OF NEXT EVENT
				lappend outtimes $val
				set lasttime [lindex $outtimes end]
			}
			set len [llength $outtimes]
			incr len -2								;#	THERE IS NO EVENT AT END OF LAST PROPORTION
			set outtimes [lrange $outtimes 0 $len]	;#	SO ELIMINATE LAST VAL	

			if {[llength $outtimes] < $timeslen} {
				Inf "Insufficient Times Specified"
				continue
			}
			incr timeslen -1
			set outtimes [lrange $outtimes 0 $timeslen]
			set linecnt 0
			set whichcomment 0
			foreach fnam $fnams time $outtimes linend $linends {
				if {$whichcomment < $commentcnt} {
					set thiscomment [lindex $comments $whichcomment]
					set commentline [lindex $thiscomment 0]
					if {$commentcnt == $linecnt} {
						lappend nulines [lindex $thiscomment 1]
						incr whichcomment
						incr linecnt
					}
				}
				set line [concat $fnam $time $linend]
				lappend nulines $line
				incr linecnt
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write Output Mix Data"
				continue
			}
			foreach line $nulines {
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			if {[info exists ischused]} {
				set chused $chlist
				SaveMetaProcessFilesUsed
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#---- Create a list of timings using rhythm-graphics, and variable MM

proc CreateTimeCues {} {
	global symasoften pr_timecues evv symaunitdotted syncMM tc_absdur tc_adddur tc_fnam rh_encoding symadur propfiles_list wstk wl rememd ocl last_outfile
	set symasoften 0
	set f .timecues
	if [Dlg_Create $f "CREATE TIMECUES" "set pr_timecues 0" -width 60 -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.0a -bg $evv(POINT) -height 1
		frame $f.1
		frame $f.1a -bg $evv(POINT) -height 1
		frame $f.2
		frame $f.3
		frame $f.3a -bg $evv(POINT) -height 1
		frame $f.4
		frame $f.5
		frame $f.5a -bg $evv(POINT) -height 1
		frame $f.6
		frame $f.7
		frame $f.7a -bg $evv(POINT) -height 1
		frame $f.8
		frame $f.9
		button $f.0.0 -text "Keep Timecues" -command "set pr_timecues 6" -width 16 -highlightbackground [option get . background {}]
		button $f.0.1 -text "Start Again" -command "set pr_timecues 5" -width 16 -highlightbackground [option get . background {}]
		button $f.0.2 -text "Erase Last Entry" -command "set pr_timecues 4" -width 16 -highlightbackground [option get . background {}]
		button $f.0.3 -text "Suggestions" -command TimeCuesHelp -bg $evv(HELP) -width 16 -highlightbackground [option get . background {}]
		button $f.0.dum -text "" -command {} -bd 0 -width 14 -highlightbackground [option get . background {}]
		button $f.0.4 -text "Abandon" -command "set pr_timecues 0" -width 14 -highlightbackground [option get . background {}]
		pack $f.0.0 -side left -padx 2
		pack $f.0.4 $f.0.dum $f.0.3 $f.0.1 $f.0.2 -side right -padx 2
		pack $f.0 -side top -fill x -expand true 
		pack $f.0a -side top -fill x -expand true -pady 3
		button $f.1.0 -text "Enter Rhythm" -command "set pr_timecues 1" -width 12 -highlightbackground [option get . background {}]
		button $f.1.1 -text "Enter Event" -command "set pr_timecues 2"  -width 12 -highlightbackground [option get . background {}]
		button $f.1.2 -text "Tapout Times" -command "set pr_timecues 3" -width 12 -highlightbackground [option get . background {}]
		pack $f.1.0 $f.1.1 $f.1.2 -side left -padx 12 -pady 4
		pack $f.1 -side top -pady 4 
		pack $f.1a -side top -fill x -expand true -pady 3
		label $f.2.ll -text "TIME UNIT OF NEXT RHYTHM ENTERED"
		pack $f.2.ll -side left
		pack $f.2 -side top -pady 4
		radiobutton $f.3.1 -text "crotchet" -variable symaunitdotted -value 0
		radiobutton $f.3.2 -text "dotted crotchet" -variable symaunitdotted -value 1
		checkbutton $f.3.3 -text "soften" -variable symasoften
		label $f.3.ll -text "MM "
		entry $f.3.e -textvariable syncMM -width 12
		pack $f.3.1 $f.3.2 $f.3.ll $f.3.e $f.3.3 -side left
		pack $f.3 -side top
		pack $f.3a -side top -fill x -expand true -pady 3
		label $f.4.ll -text "EVENT OR REST OF SPECIFIC DURATION"
		pack $f.4.ll -side left
		pack $f.4 -side top -pady 4
		label $f.5.ll -text "Duration (secs) "
		entry $f.5.e -textvariable tc_absdur -width 12
		radiobutton $f.5.r1 -text "Event" -variable tc_adddur -value 1
		radiobutton $f.5.r0 -text "Rest"  -variable tc_adddur -value 0
		pack $f.5.ll $f.5.e $f.5.r1 $f.5.r0 -side left
		pack $f.5 -side top
		pack $f.5a -side top -fill x -expand true -pady 3
		label $f.6.ll -text "GET TIMES BETWEEN MOUSE CLICKS"
		pack $f.6.ll -side left
		pack $f.6 -side top -pady 4
		label $f.7.ll -text "e.g. for 2 events, make 3 taps"
		pack $f.7.ll -side left
		pack $f.7 -side top
		pack $f.7a -side top -fill x -expand true -pady 3
		label $f.8.ll -text "OUTPUT DATA"
		pack $f.8.ll -side left
		pack $f.8 -side top -pady 4
		label $f.9.ll -text "Filename "
		entry $f.9.e -textvariable tc_fnam -width 12
		pack $f.9.ll $f.9.e -side left
		pack $f.9 -side top
		wm resizable $f 1 1
		bind $f <Escape> {set pr_timecues 0}
		bind $f <Return> {set pr_timecues 6}
	}
	set tc_fnam ""
	set tc_absdur ""
	set symaunitdotted -1
	set syncMM ""
	set pr_timecues 0
	set entry_ends 0.0
	set tc_outtimes 0.0
	set lasttime 0.0
	set lasttimeineventisanonset {}
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_timecues
	set finished 0
	while {!$finished} {
		set tc_adddur -1
		tkwait variable pr_timecues
		switch -- $pr_timecues {
			0 {
				set finished 1
			}
			1 {	;#	ENTER RHYTHM FROM GRAPHICS DISPLAY
				if {$symaunitdotted < 0} {
					Inf "No Rhythm Unit Specified"
					continue
				}
				if {[string length $syncMM] <= 0} {
					Inf "No Metronome Mark Specified"
					continue
				}
				if {![IsNumeric $syncMM] || ($syncMM < 10) || ($syncMM > 400)} {
					Inf "Invalid Metronome Mark"		
					continue
				}
				EstablishRhythmPropDisplay 0 0
				if {![info exists rh_encoding] || ([string length $rh_encoding] <= 0)} {
					catch {unset rh_encoding}
					continue
				}
				set symadur {}
				set endindex -1
				set len [string length $rh_encoding]
				if {$len <= 0} {
					return {}
				}
				set k 0
				set j 1
				while {$k < $len} {
					set item [string index $rh_encoding $k]
					switch -- $item {
						"|" -
						"."	-
						":"	-
						","	{
							set code $item
							set kincr 1
						}
						default {
							set code [string range $rh_encoding $k $j]
							set kincr 2
						}
					}
					set endindex [DecodeRhythmicUnitToProportions $code $endindex]
					incr k $kincr
					incr j $kincr
				}
				if {[llength $symadur] <= 0} {
					continue
				}
				set lasttime [lindex $tc_outtimes end]
				foreach dur $symadur {
					set val [expr $lasttime + $dur]				;#	EACH DURATION SPECIFIES START OF NEXT EVENT
					lappend tc_outtimes $val
					set lasttime [lindex $tc_outtimes end]
				}
				lappend entry_ends $lasttime
				lappend lasttimeineventisanonset 0
				$f.0.0 config -bg $evv(EMPH)
			}
			2 {	;#	ENTER SINGLE EVENT (OR REST) OF GIVEN DURATION
				if {([string length $tc_absdur] <= 0) || ![IsNumeric $tc_absdur] || ($tc_absdur <= 0.0)} {
					Inf "Invalid Duration Entered"
					continue
				}
				if {$tc_adddur < 0} {
					Inf "Specify Event Or Rest"
					continue
				}
				set time [expr $lasttime + $tc_absdur]
				if {$tc_adddur} {
					lappend tc_outtimes $time
					set lasttime [lindex $tc_outtimes end]
					lappend entry_ends $lasttime
					lappend lasttimeineventisanonset 0
					Inf "Timed Event Added"
				} else {
					if {[llength $tc_outtimes ] <= 1} {
						Inf "No Rests Permitted At Start Of Pattern"
						continue
					}
					set tc_outtimes [lreplace $tc_outtimes end end $time]	;#	REST EXTENDS PREVIOUS DURATION
					if {![lindex $lasttimeineventisanonset end]} {
						set pos [expr [llength $tc_outtimes] - 1]			;#	IF PREVIOUS EVENT WAS NOT TAPPED-IN
						if {[info exists restpos]} {						;#	SAVE POSITION AND VALUE OF REST
							set k [lsearch $restpos $pos]					;#	IN CASE USER DELETES A 'REST' EVENT
							if {$k >= 0} {
								set oldrest [lindex $rests $k]				;#	IF ALREADY A REST HERE, EXTEND ITS DURATION
								set rest [expr $oldrest + $tc_absdur]
								set rests [lreplace $rests $k $k $rest]
								Inf "Timed Rest Added"
							} else {
								lappend restpos $pos						;#	ELSE STORE DURATION AND LOCATION OF REST
								lappend rests $tc_absdur
								Inf "Timed Rest Added"
							}
						} else {
							lappend restpos $pos								
							lappend rests $tc_absdur
							Inf "Timed Rest Added"
						}
					} else {		;#	TAPPED-IN EVENTS ARE ONSET TIMES, WHILE ALL OTHER ENTRIES SPECIFY EVENT DURATIONS.
									;#	HENCE LAST ENTRY OF A TAPPED-PATTERN HAS NO SPECIFIED DURATION (JUST AN ONSET TIME).
									;#	IF A REST IS ADDED TO END OF TAPPED TIME IT THEN SPECIFIES A DURATION FOR THE FINAL EVENT
									;#	SO TAPPED PATTERN IS CONVERTED TO THE (SAME) DURATION FORMAT AS OTHER ENTRIES
									;#	AND NO LONGER NEEDS TO BE FLAGGED AS AN onset EVENT.
									;#	THIS FLAGGING IS SIGNIFICANT, AS, IF LAST PATTERN ENTERED IS BY TAPPING,
									;#	FINAL VALUE IS AN EVENT onset AND MUST BE RETAINED,
									;#	WHEREAS, IN ALL OTHER CASES, FINAL VALUE IS duration OF FINAL EVENT AND IS NOT RETAINED.
									;#	
									;#	THE REST ADDED HERE IS HENCE ABSORBED INTO THE TAPPED PATTERN, 
									;#	(CONVERTING IT INTO A TRUE DURATION-PATTERN)
									;#	AND IS NOT FLAGGED AS AN ACTUAL REST (FOR POSSIBLE ERASURE).

						set lasttimeineventisanonset [lreplace $lasttimeineventisanonset end end 0]
						Inf "Tapped Rhythm Extended By (Non-Erasable) Rest"
					}
					set lasttime [lindex $tc_outtimes end]
					set entry_ends [lreplace $entry_ends end end $lasttime]
				}
				$f.0.0 config -bg $evv(EMPH)
			}
			3 {	;# TAP OUT TIMES WITH MOUSE
				DoTimer
				if {![info exists ocl]} {
					Inf "No Times Tapped In"
					continue
				}
				if {[llength $ocl] < 2} {
					Inf "Insufficient Times Tapped In (Need At Least 2)"
					continue
				}
				set ocl [lrange $ocl 1 end]
				foreach time $ocl {
					set val [expr $lasttime + $time]	;#	HERE EACH VALUE SPECIFIES onset TIME OF NEXT EVENT
					lappend tc_outtimes $val
				}
				set lasttime [lindex $tc_outtimes end]
				lappend entry_ends $lasttime
				$f.0.0 config -bg $evv(EMPH)
				lappend lasttimeineventisanonset 1		;#	FLAG THAT LAST ENTRY IS AN onset TIME, RATHER THAN LOCATION OF END OF AN EVENT
			}
			4 { ;# ERASE LAST
				if {$lasttime <= 0.0} {
					Inf "No More Events To Erase"
					continue
				}
				set done 0
				if {[info exists rests]} {
					set	pos [lindex $restpos end]
					set ult [expr [llength $tc_outtimes] - 1]
					if {$pos == $ult} {
						set rest [lindex $rests end]
						set time [lindex $tc_outtimes end]
						set time [expr $time - $rest]
						set tc_outtimes [lreplace $tc_outtimes end end $time]
						set last_entry_end [lindex $entry_ends end]
						set last_entry_end [expr $last_entry_end - $rest]
						set entry_ends [lreplace $entry_ends end end $last_entry_end]
						set len [llength $rests]
						set penult [expr $len - 2]
						if {$penult >= 0} {
							set rests   [lrange $rests   0 $penult]
							set restpos [lrange $restpos 0 $penult]
						} else {
							unset rests
							unset restpos
						}
						Inf "Last Rest Erased"
						set done 1
					}
				}
				if {!$done} {
					set len [llength $entry_ends]
					set penult [expr $len - 2]
					if {$penult >= 0} {
						set last_entry_end [lindex $entry_ends $penult]
						set k [lsearch $tc_outtimes $last_entry_end]
						if {$k >= 0} {
							set tc_outtimes [lrange $tc_outtimes 0 $k]
							set lasttime [lindex $tc_outtimes end]
							set entry_ends [lrange $entry_ends 0 $penult]
							set len [llength $lasttimeineventisanonset]
							set penult [expr $len - 2]
							if {$penult >= 0} {
								set lasttimeineventisanonset [lrange $lasttimeineventisanonset 0 $penult]
							} else {
								set lasttimeineventisanonset {}
							}
							Inf "Last Event Erased"
						}
					}
				}
				if {[llength $tc_outtimes] <= 1} {
					$f.0.0 config -bg [	option get . background {}]
				}
			}
			5 {	;# RESTART
				set lasttime 0.0
				set entry_ends 0.0
				set tc_outtimes 0.0
				catch {unset rests}
				catch {unset restpos}
				set lasttimeineventisanonset {}
				$f.0.0 config -bg [	option get . background {}]
				Inf "Restarted"
			}
			6 {	;#	CONCLUDE
				if {[llength $tc_outtimes] <= 1} {
					Inf "No Timecues To Save"
					continue
				}
				if {[string length $tc_fnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $tc_fnam]} {
					continue
				}
				set outfnam [string tolower $tc_fnam]
				append outfnam $evv(TEXT_EXT)
				if {[file exists $outfnam]} {
					set ftyp [FindFileType $outfnam]
					if {[IsAMixfile $ftyp]} {
						Inf "You Cannot Delete This Mixfile"
						continue
					} elseif {[info exists propfiles_list] && ([lsearch $propfiles_list $outfnam] >= 0)} {
						Inf "You Cannot Delete This Properties File"
						continue
					} else {
						set msg "File '$outfnam' Already Exists: Overwrite It ?"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
						if {![DeleteNonSndfileFromSystem $outfnam]} {
							Inf "CANNOT DELETE EXISTING FILE '$outfnam'"
							continue
						}
					}
				}
				if [catch {open $outfnam "w"} zit] {
					Inf "Cannot Open File '$outfnam' To Write The Timecues Data"
					continue
				}
				set lastentryisanonset [lindex $lasttimeineventisanonset end]
				if {!$lastentryisanonset} {				;#	THERE IS NO EVENT AT LAST VALUE (it specifies end of duration of last event)
					set len [llength $tc_outtimes]		;#	SO IT IS ELIMINATED.	
					set penult [expr $len - 2]			;#	WHEREAS LAST tapped-in ENTRY REPRESENTS AN EVENT onset, SO IT IS RETAINED.
					set tc_outtimes [lrange $tc_outtimes 0 $penult]
				}									
				foreach val $tc_outtimes {
					puts $zit $val
				}
				close $zit
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc TimeCuesHelp {} {
	set msg "TIME CUES CAN ALSO BE CREATED\n"
	append msg "\n"
	append msg "1)   Using the Table Editor \"Create\" functions\n"
	append msg "2)   By Typing values directly to a table (Workspace or Table Editor).\n"
	append msg "\n"
	append msg "TIME CUES CAN BE MANIPULATED\n"
	append msg "\n"
	append msg "1)   Using the various functions on the Table Editor.\n"
	append msg "2)   By directly editing the text (Workspace or Table Editor).\n"
	Inf $msg
}

#--- Transpos Sndfiles to pitch of first at the corresponding timemarks ... option to sync file times at timemarks

proc TransposToPitch_SyncingAtTimeMarks {dosync} {
	global chlist pa evv mu pr_synctrans sytrwhich sytrtag chused symasamps symatimes blist_change synctrfmnts wstk wl last_outfile

	set msg "Select 2 Or More Soundfiles And Their Associated Frq Brkpnt Data\nPlace The File To Sync-To First In The List\nPlace The Brkpnt Data Associated With Any Sndfile Immediately After That Sndfile In The List"
	if {![info exists chlist] || ([llength $chlist] < 4)} {
		Inf $msg
		return
	}
	if {![IsEven [llength $chlist]]} {
		Inf $msg
		return
	}
	set datacnt 0
	foreach {fnamsnd fnbambrk} $chlist {
		set ftyp $pa($fnamsnd,$evv(FTYP))
		if {$datacnt == 0} {
			set srate $pa($fnamsnd,$evv(SRATE))
			set invsrate [expr 1.0 / $srate]
		} elseif {$srate != $pa($fnamsnd,$evv(SRATE))} {
			Inf "Soundfiles Are Not At Same Sample-Rate"
			return
		}
		if {$ftyp == $evv(SNDFILE)} {
			lappend fnamsnds $fnamsnd
			lappend outfnams [file rootname [file tail $fnamsnd]]
		} else {
			Inf $msg
			return
		}
		set ftyp $pa($fnbambrk,$evv(FTYP))
		if {![IsABrkfile $ftyp] \
		|| ($pa($fnbambrk,$evv(MAXBRK)) > [MidiToHz $mu(MIDIMAX)]) \
		|| ($pa($fnbambrk,$evv(MINBRK)) < [MidiToHz $mu(MIDIMIN)]) } {
			set msg2 "Invalid File Type Selected ($fnam).\n"
			append msg2 "$msg"
			Inf $msg2
			return
		}
		lappend fnambrks $fnbambrk
		incr datacnt
	}
	catch {unset symatimes}
	catch {unset symasamps}
	set n 1
	foreach fnam $fnamsnds {
		LoadExistingSymaInfo $fnam $n
		if {[info exists symasamps($n)]} {
			foreach sampcnt $symasamps($n) {
				lappend symatimes($n) [expr $sampcnt * $invsrate]
			}
		}
		incr n
	}
	if {[info exists symasamps]} {
		if {[llength [array names symasamps]] > 1} {
			set existxt "(Timemarks exist for Files "
		} else {
			set existxt "(Timemark exists for File "
		}
		foreach nam [array names symasamps] {
			append existxt $nam "  "
		}
		set len [string length $existxt]
		incr len -3
		set existxt [string range $existxt 0 $len]
		append existxt ")"
	}
	set n 0
	foreach fnam $fnambrks {
		if [catch {open $fnam "r"} zit] {
			Inf "Cannot Open File '$fnam' To Read Frq Brkpnt Data"
			return
		}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] <= 0} {
					continue
				}
				lappend frqdata($n) $item			 
			}
		}
		close $zit
		if {![info exists frqdata($n)]} {
			Inf "No Data Retrieved From File '$fnam'"
			return
		}
		incr n
	}
	set ischused 1
	set f .synctrans	
	if [Dlg_Create $f "TRANSPOSE AT TIMEMARKS" "set pr_synctrans 0" -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.00 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bg $evv(POINT) -height 1
		frame $f.5 -bd $evv(SBDR)
		button $f.0.qq -text "Quit" -command "set pr_synctrans 0" -highlightbackground [option get . background {}]
		pack $f.0.qq -side right
		button $f.0.do -text "Transpose" -command "set pr_synctrans 1" -highlightbackground [option get . background {}]
		button $f.0.sv -text "Sound View" -command "set pr_synctrans 2" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		pack $f.0.do $f.0.sv -side left -padx 2
		checkbutton $f.0.fmnt -text "Try to retain formants" -variable synctrfmnts
		pack $f.0.fmnt -side left -padx 30
		pack $f.0 -side top -fill x -expand true
		if {[info exists existxt]} {
			label $f.00.ex -text $existxt -fg $evv(SPECIAL)
			pack $f.00.ex -side left -padx 2
			pack $f.00 -side top
		}
		label $f.1.ll -text "Assign Timemarks to File (Use \"Sound View\")"
		pack $f.1.ll -side left
		set n 1
		while {$n <= $datacnt} {
			radiobutton $f.1.r$n -text $n -variable sytrwhich -value $n
			pack $f.1.r$n -side left
			incr n
		}
		pack $f.1 -side top
		label $f.2 -text "Outfiles take names of corresponding infiles, each followed by a 'tag'" -fg $evv(SPECIAL) -width 100
		pack $f.2 -side top
		label $f.3.ll -text "Outfile Tag "
		entry $f.3.e -textvariable sytrtag -width 16
		pack $f.3.ll $f.3.e -side left
		pack $f.3 -side top
		pack $f.4 -side top -fill x -expand true -pady 4
		button $f.5.1 -text "Save Timemarks?" -command "set pr_synctrans 3" -highlightbackground [option get . background {}]
		pack $f.5.1 -side left
		pack $f.5 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_synctrans 0}
	}
	set synctrfmnts 0
	set sytrwhich 0
	set n 1
	while {$n <= $datacnt} {
		if {[lsearch [array names symasamps] $n] < 0} {
			set sytrwhich $n
			break
		}
		incr n
	}
	if {$dosync} {
		wm title $f "TRANSPOSE & SYNC AT TIMEMARKS TO FILE '[file rootname [file tail [lindex $fnamsnds 0]]]'"
	} else {
		wm title $f "TRANSPOSE AT TIMEMARKS TO FILE '[file rootname [file tail [lindex $fnamsnds 0]]]'"
	}
	if {![info exists sytrtag]} {
		set sytrtag ""
	}
	set delallsyrtag 0
	set pr_synctrans 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_synctrans
	set finished 0
	while {!$finished} {
		tkwait variable pr_synctrans
		switch -- $pr_synctrans {	
			0 {
				set finished 1
			}
			1 {
				set n 1
				catch {unset badtimes}
				while {$n <= $datacnt} {
					if {![info exists symatimes($n)]} {
						if {[info exists symasamps($n)]} {
							foreach sampcnt $symasamps($n) {
								lappend symatimes($n) [expr $sampcnt * $invsrate]
							}
						} else {
							lappend badtimes $n
						}
					}
					incr n
				}
				if {[info exists badtimes]} {
					set msg "Timemarks Have Not Been Assigned To\nFiles  "
					foreach val $badtimes {
						append msg $val "  "
					}
					Inf $msg
					continue
				}
				if {[string length $sytrtag] <= 0} {
					Inf "No Name Tag Entered"
					continue
				}
				set sytrtag [string tolower $sytrtag]
				if {![ValidCDPRootname $sytrtag]} {
					continue
				}
				;#	CHECK WHETHER ANY OF OUTPUT FILES ALREADY EXIST

				set out_fnams 0	;#	NO OUTPUT FILENAME NEEDED FOR 1ST INFILE
				set OK 1
				set n 1
				while {$n < $datacnt} {
					set outfnam	[lindex $outfnams $n]
					append outfnam "_" $sytrtag $evv(SNDFILE_EXT)
					if {[file exists $outfnam]} {
						if {$delallsyrtag != 1} {
							set msg "File '$outfnam' Already Exists. Overwrite It ??"
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "no"} {
								set OK 0
								break
							}
						}
						set i [LstIndx $outfnam $wl]
						set blist_change 0
						if {![DeleteFileFromSystem $outfnam 0 1]} {
							Inf "Cannot Delete Existing File '$outfnam'"
							set OK 0
							break
						} else {
							DummyHistory $outfnam "DESTROYED"
							if {[IsInAMixfile $outfnam]} {
								if {[MixM_ManagedDeletion $outfnam]} {
									MixMStore
								}
							}
							if {$blist_change} {
								SaveBL $background_listing
							}
							if {$i >= 0} {
								WkspCnt [$wl get $i] -1
								$wl delete $i
								catch {unset rememd}
							}
						}
						if {($delallsyrtag == 0) && ($datacnt > 2)} {
							set msg "Do You Wish To Delete All Other Existing '_$sytrtag' Files Related To Your Input Sounds ??"
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set delallsyrtag 1
							} else {
								set delallsyrtag -1	;#	i.e. Question has been asked, and answer is 'No' (don't ask again)
							}
						}
					}
					lappend out_fnams $outfnam
					incr n
				}
				if {!$OK} {
					continue
				}
				set n 1
				set m 2
				set tmarktemplate $symatimes(1)
				set frqtemplate  $frqdata(0)
				set dur $pa([lindex $fnamsnds 0],$evv(DUR))
				catch {unset last_outfile_x}
				while {$n < $datacnt} {
					DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
					set infnam  [lindex $fnamsnds $n]
					set infrqs  $frqdata($n)
					set infdur $pa($infnam,$evv(DUR))
					set outfnam [lindex $out_fnams $n]
					WarpFileFrqAtTimemarks $tmarktemplate $symatimes($m) $frqtemplate $infrqs $dur $infdur $infnam $outfnam $dosync $synctrfmnts
					if {[file exists $outfnam]} {
						FileToWkspace $outfnam 0 0 0 0 1
						lappend last_outfile_x $outfnam
						set filestowkspace 1
					}
					incr n
					incr m
				}
				if {[info exists filestowkspace]} {
					Inf "Warped Files With Tag '$sytrtag' Are On The Workspace"
					set last_outfile $last_outfile_x
				}
				if {[info exists ischused]} {
					set chused $chlist
					SaveMetaProcessFilesUsed
					unset ischused			;# PREVENT CHOSEN FILES LAST DATA BEING SAVED MORE THAN ONCE
				}
			}
			2 {
				if {!$sytrwhich} {
					Inf "No Soundfile Selected"
					continue
				}
				set thissnd [lindex $fnamsnds [expr $sytrwhich - 1]]
				if {[info exists symatimes($sytrwhich)]} {
					set msg "Timemark Information Already Exists For File '$thissnd'. Override It ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				catch {unset symasamps(0)}
				SnackDisplay $evv(SN_TIMESLIST) syncmarks3 0 $thissnd
				if {![info exists symasamps(0)]} {
					continue
				}
				catch {unset symatimes($sytrwhich)}
				catch {unset symasamps($sytrwhich)}
				foreach sampcnt $symasamps(0) {
					lappend symasamps($sytrwhich) $sampcnt
					lappend symatimes($sytrwhich) [expr $sampcnt * $invsrate]
				}
			}
			3 {
				if {![info exists symasamps]} {
					Inf "No Timemarks To Save"
					continue
				}
				Block "Saving Timemarks"
				set n 1
				foreach fnam $fnamsnds {
					if {![info exists symasamps($n)]} {
						incr n
						continue
					}
					set infofnam [file join $evv(URES_DIR) "_syma_"]
					append infofnam [file rootname [file tail $fnam]] $evv(TEXT_EXT)
					if {[file exists $infofnam]} {
						set msg "Timemark Information Already Exists For File '$fnam'. Overwrite It ??"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							incr n
							continue
						}
					}
					if {[catch {open $infofnam "w"} zit]} {
						Inf "Cannot Open File To Write Timemark Data For File '$fnam'"
						incr n
						continue
					}
					foreach line $symasamps($n) {
						puts $zit $line
					}
					set saved_tm 1
					close $zit
					incr n
				}
				UnBlock
				if {[info exists saved_tm]} {
					Inf "Time Marks Saved"
					unset saved_tm
				} else { 
					Inf "No Time Marks Have Been Saved"
				}
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#--- Transpos Single Snd to pitch of templatefile at corresponding timemarks ... option to sync file times at timemarks

proc WarpFileFrqAtTimemarks {tmarktemplate tmarks frqtemplate infrqs dur1 dur2 infnam outfnam dosync keepformants} {
	global evv prg_dun prg_abortd CDPidrun simple_program_messages

	set analfnam $evv(DFLT_OUTNAME)
;# 2023
	append analfnam 0 $evv(ANALFILE_OUT_EXT)		;#	ANALYSIS OF FILE TO WARP
	set strfnam $evv(DFLT_OUTNAME)
;# 2023
	append strfnam 1 $evv(ANALFILE_OUT_EXT)		;#	TIMESTRETCHED ANALYSIS FILE (IF REQUIRED)
	set transfnam $evv(DFLT_OUTNAME)
;# 2023
	append transfnam 2 $evv(ANALFILE_OUT_EXT)	;#	TRANSPOSED ANALYSIS FILE
	set prenvfnam $evv(DFLT_OUTNAME)
	append prenvfnam 3 $evv(SNDFILE_EXT)	;#	RESYNTHESIZED FILE, PRIOR TO DOVETAILING (IF REQUIRED)
	set transbrkfnam $evv(DFLT_OUTNAME)
	append transbrkfnam 0 $evv(TEXT_EXT)	;#	TRANSPOSITION DATA
	set tstrbrkfnam $evv(DFLT_OUTNAME)		
	append tstrbrkfnam 1 $evv(TEXT_EXT)		;#	TIMESTRETCH DATA
	set silfil $evv(MACH_OUTFNAME)			
	append silfil 0 $evv(SNDFILE_EXT)		;#	SILENCE TO ADD TO FILE END, IF TSTRETCH HAPPENING
	set extendfil $evv(MACH_OUTFNAME)
	append extendfil 1 $evv(SNDFILE_EXT)	;#	INFILE EXTENDED WITH SILENCE

	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0

	;#	IF NECESSARY, TRIM ONE TIMEMARK SET SO BOTH ARE OF SAME LENGTH

	set ttlen [llength $tmarktemplate]
	set tmlen [llength $tmarks]
	if {$tmlen < $ttlen} {
		incr tmlen -1
		set tmarktemplate [lrange $tmarktemplate 0 $tmlen]
	} elseif {$tmlen > $ttlen} {
		incr ttlen -1
		set tmarks [lrange $tmarks 0 $ttlen]
	}

	;#	ADD DURATION OF EACH SOUND TO END OF TIMELISTS, SO WARPING REACHES TO END OF FILES

	set origtmarks $tmarktemplate
	if {![Flteq [lindex $origtmarks 0] 0.0]} {
		set origtmarks [concat 0 $origtmarks]
	}
	lappend origtmarks $dur1
	set warptmarks $tmarks
	if {![Flteq [lindex $warptmarks 0] 0.0]} {
		set warptmarks [concat 0 $warptmarks]
	}
	lappend warptmarks $dur2

	;#	DO THE WARP; src REFERS TO THE REFERENCE SOUND: warp REFERS TO THE SOUND TO BE WARPED

	set warpfrqlen [llength $infrqs]

	set lastsrctmark  [lindex $origtmarks 0]
	set lastwarptmark [lindex $warptmarks 0]
	set n 0
	foreach thissrctmark [lrange $origtmarks 1 end] thiswarptmark [lrange $warptmarks 1 end] {
		set srcstep  [expr $thissrctmark  - $lastsrctmark ]
		set warpstep [expr $thiswarptmark - $lastwarptmark]
		set warpratio [expr $srcstep / $warpstep]	;#	Converts timestep in warpfile to corresponding timestep in srcfile
		
			;#	SEARCH warpfile FREQ DATA BETWEEN 2 TMARKS, GENERATING TRANSPOSITION DATA
	
		if {$n < $warpfrqlen} {
			while {$n < $warpfrqlen} {
				set time [lindex $infrqs $n]
				set timestep [expr $time - $lastwarptmark]
				incr n
				set frq  [lindex $infrqs $n]
				incr n
				if {$time >= $thiswarptmark} {
					break
				}
				set srcstep [expr $timestep * $warpratio]
				set srctime [expr $lastsrctmark + $srcstep]
				if {[info exists lastsrctime] && ($srctime < $lastsrctime)} {
					Inf "WARPFILE TIMINGS OUT OF SEQUENCE: WARP TOO EXTREME"
					return
				}
				set lastsrctime $srctime
				set srcfrq [GetValAtTimeInBrkpntData $srctime $frqtemplate]
				set transpos [expr $srcfrq / $frq]
				if {$dosync} {
					
					;# IF warp FILE IS TO BE TIMEWARPED TO SAME TIMEFRAME AS src TRANSPOS TAKES PLACE AT TIME-IN-srcfile

					set line [list $srctime $transpos]

				} else {

					;# IF warp FILE IS NOT TO BE TIMEWARPED, TRANSPOS TAKES PLACE AT TIME-IN-warpfile

					set line [list $time $transpos]
				}
				lappend transplines $line
			}
		} else {

			;#	IF RUN OFF END OF FRQ DATA (SHOULD NOT HAPPEN), RETAIN LAST TRANSPOS VALUE
		
			if {$dosync} {
				set line [list $thissrctmark $transpos]
			} else {
				set line [list $thiswarptmark $transpos]
			}
			lappend transplines $line
		}
		set lastsrctmark $thissrctmark
		set lastwarptmark $thiswarptmark
	}
		;#	ADD LINE AT END TO ENSURE ALL OF END OF FILE GETS TRANSPOSED
	set line [lreplace $line 0 0 10000.0]
	lappend transplines $line

	if [catch {open $transbrkfnam "w"} zit] {
		Inf "Cannot Open Temporary File '$transbrkfnam' To Write Transposition Data\n\nCannot Create Sound '$outfnam'"
		return
	}
	Block "Warping The File"
	foreach line $transplines {
		puts $zit $line
	}
	close $zit


		;#	ENSURE TIMEWARP WORKS AT FILE END BY ADDING SILENCE

	set inf_nam $infnam
	if {$dosync} {
		if {![AddSilenceToEndOfFile $infnam $silfil $extendfil]} {
			Inf "Failed To Add Padding Silence To End Of File [file rootname [file tail $infnam]]"
			UnBlock
			return
		}
		set infnam $extendfil
	}

			;#	ANALYSE THE FILE TO BE WARPED

	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd anal 1 $infnam $analfnam -c1024 -o3
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Cannot Create Analysis File From [file rootname [file tail $inf_nam]]: $CDPidrun"
		catch {unset CDPidrun}
		UnBlock
		return
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Cannot Create Analysis File From [file rootname [file tail $inf_nam]]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return
	}
	if {![file exists $analfnam]} {
		ErrShow "Cannot Create Analysis File From [file rootname [file tail $inf_nam]]"
		UnBlock
		return
	}

	if {$dosync} {

		;#	CREATE THE TIMEWARPING DATA

		set origtmarks $tmarktemplate
		if {![Flteq [lindex $origtmarks 0] 0.0]} {
			set origtmarks [concat 0 $origtmarks]
		}
		set warptmarks $tmarks
		if {![Flteq [lindex $warptmarks 0] 0.0]} {
			set warptmarks [concat 0 $warptmarks]
		}
		catch {unset outvals}
		set cnt 0
		set lasttime1 [lindex $origtmarks 0]
		set lasttime2 [lindex $warptmarks 0]
		set thistime1 [lindex $origtmarks 1]
		set thistime2 [lindex $warptmarks 1]
		set diff1 [expr double($thistime1) - double($lasttime1)]
		set diff2 [expr double($thistime2) - double($lasttime2)]
		foreach time1 [lrange $origtmarks 2 end] time2 [lrange $warptmarks 2 end] {
			if {$cnt == 0} {
				set time $lasttime2
			} else {
				set time [expr $lasttime2 + 0.002]
			}
			set ratio [expr $diff1 / $diff2]
			lappend outvals $time $ratio
			set time [expr $thistime2 - 0.002]
			lappend outvals $time $ratio
			set diff1 [expr double($time1) - double($thistime1)]
			set diff2 [expr double($time2) - double($thistime2)]
			set lasttime2 $thistime2
			set thistime1 $time1
			set thistime2 $time2
			incr cnt
		}
		if {$cnt == 0} {
			set time $lasttime2
		} else {
			set time [expr $lasttime2 + 0.002]
		}
		set ratio [expr $diff1 / $diff2]
		lappend outvals $time $ratio
		set time [expr $thistime2 - 0.002]
		lappend outvals $time $ratio
		set time [expr $thistime2 + 0.002]
		lappend outvals $time 1.0
		lappend outvals 10000 1.0
		if [catch {open $tstrbrkfnam "w"} zit] {
			Inf "Cannot Open File '$tstrbrkfnam' To Write Time-Stretching Values"
			UnBlock
			return
		}
		foreach {time stretch} $outvals {
			set line $time
			append line "   " $stretch
			puts $zit $line
		}
		close $zit

		;#	TIMEWARP THE FILE

		set cmd [file join $evv(CDPROGRAM_DIR) stretch]
		lappend cmd time 1 $analfnam $strfnam $tstrbrkfnam
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "Cannot Timestretch The Analysis File: $CDPidrun"
			catch {unset CDPidrun}
			UnBlock
			return
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Cannot Timestretch The Analysis File"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			UnBlock
			return
		}

		;#	REPLACE THE ORIGINAL ANALYSIS FILE BY THE TIME-WARPED FILE

		if [catch {file delete $analfnam} zit] {
			Inf "Cannot Delete The Intermediate Analysis File"
			UnBlock
			return
		}
		if [catch {file rename $strfnam $analfnam} zit] {
			Inf "Cannot Rename The Intermediate Timestretched File"
			UnBlock
			return
		}
	}

	;#	DO THE FREQUENCY WARPING

	set cmd [file join $evv(CDPROGRAM_DIR) repitch]
	if {$keepformants} {
		lappend cmd transposef 1 $analfnam $transfnam -p4 $transbrkfnam -l5 -h22050  
	} else {
		lappend cmd transpose 1 $analfnam $transfnam $transbrkfnam -l5 -h22050 
	}
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Failed To Transpose File [file rootname [file tail $inf_nam]]: $CDPidrun"
		catch {unset CDPidrun}
		UnBlock
		return
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Transpose File [file rootname [file tail $inf_nam]]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return
	}
	if {![file exists $transfnam]} {
		ErrShow "Failed To Transpose File [file rootname [file tail $inf_nam]]"
		UnBlock
		return
	}
	
	;#	DO THE FINAL RESYNTHESIS

	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	if {$dosync} {
		lappend cmd synth $transfnam $prenvfnam
		set testout $prenvfnam
	} else {
		lappend cmd synth $transfnam $outfnam
		set testout $outfnam
	}
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Failed To Resynth Transposed Analysis File For [file rootname [file tail $inf_nam]]: $CDPidrun"
		catch {unset CDPidrun}
		UnBlock
		return
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Resynth Transposed Analysis File For [file rootname [file tail $inf_nam]]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return
	}
	if {![file exists $testout]} {
		ErrShow "Failed To Resynth Transposed Analysis File For [file rootname [file tail $inf_nam]]"
		UnBlock
		return
	}
	if {$dosync} {

	;#	IF FILE TIME-STRETCHED, DO DOVETAILING

		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd dovetail 1 $prenvfnam $outfnam 0.0 0.02 1 1 -t0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "Failed To Dovetail Output File From [file rootname [file tail $inf_nam]]: $CDPidrun"
			catch {unset CDPidrun}
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun || ![file exists $outfnam]} {
				set msg "Failed To Dovetail Output File From [file rootname [file tail $inf_nam]]"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
			}
		}
		if {!$prg_dun || ![file exists $outfnam]} {
			if [catch {file rename $prenvfnam $outfnam} zit] {
				Inf "Failed To Rename The Non-Dovetailed Output: Transposition Failed For File [file rootname [file tail $inf_nam]]"
			}
		}
	}
	UnBlock
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	return
}

#--- Read value at specified time, by linear interpolation in brkfile time-val data

proc GetValAtTimeInBrkpntData {goaltime brkdata} {
	set lasttime [lindex $brkdata 0]
	set lastval  [lindex $brkdata 1]
	foreach {thistime thisval} [lrange $brkdata 2 end] {
		if {($goaltime >= $lasttime) && ($goaltime < $thistime)} {
			set timestep [expr $thistime - $lasttime]
			set timediff [expr $goaltime - $lasttime]
			set timeratio [expr $timediff / $timestep]
			set valdiff [expr $thisval - $lastval]
			set outval [expr $valdiff * $timeratio]
			set outval [expr $outval + $lastval]
			break
		}
		set lasttime $thistime
		set lastval $thisval
	}
	if {![info exists outval]} {
		set outval [lindex $brkdata end]
	}
	return $outval
}

#------ Extract max levels close to timemarks, normalise, and output as list.

proc LevelsAtTimeMarks {} {
	global pr_synlev chlist wl chused pa evv last_outfile
	global wstk rememd symasamps symatimes CDPidrun prg_dun prg_abortd simple_program_messages
	 
	if {![info exists chlist] || ([llength $chlist] != 1)} {
		set ilist [$wl curselection]
		if {([llength $ilist] != 1) || ([lindex $ilist 0] == -1)} {
			Inf "Select One Soundfile"
			return
		}
		set fnam [$wl get [lindex $ilist 0]]
	} else {
		set ischused 1
		set fnam [lindex $chlist 0]
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Select One Soundfile"
		return
	}
	set outfnam [file rootname [file tail $fnam]]
	append outfnam "_pks" $evv(TEXT_EXT)
	if {[file exists $outfnam]} {
		set msg "Output File $outfnam Already Exists: Overwrite It?"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		if {![DeleteNonSndfileFromSystem $outfnam]} {
			return
		}
	}
	set srate $pa($fnam,$evv(SRATE))
	set invsrate [expr 1.0 / $srate]
	LoadExistingSymaInfo $fnam 1
	set tmarks_exist 0
	if {[info exists symasamps(1)]} {
		catch {unset symatimes(1)} 
		foreach sampcnt $symasamps(1) {
			lappend symatimes(1) [expr $sampcnt * $invsrate]
		}
		set tmarks_exist 1
	}
	set f .synlev
	if [Dlg_Create $f "LEVELS AT TIMEMARKS" "set pr_synlev 0" -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bg $evv(POINT) -height 1
		frame $f.3 -bd $evv(SBDR)
		button $f.0.qq -text "Quit" -command "set pr_synlev 0" -highlightbackground [option get . background {}]
		pack $f.0.qq -side right
		button $f.0.do -text "Get Levels" -command "set pr_synlev 1" -highlightbackground [option get . background {}]
		button $f.0.sv -text "Sound View" -command "set pr_synlev 2" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		pack $f.0.do $f.0.sv -side left -padx 2
		pack $f.0 -side top -fill x -expand true
		label $f.1.1 -text "If necessary, specify Timemarks from \"Sound View\"" -fg $evv(SPECIAL) -width 100
		label $f.1.2 -text "Outfile takes name of corresponding infile, followed by '_pks'" -fg $evv(SPECIAL) -width 100
		pack $f.1.1 -side top
		pack $f.1.2 -side top
		pack $f.1 -side top
		pack $f.2 -side top -fill x -expand true -pady 4
		button $f.3.1 -text "Save Timemarks?" -command "set pr_synlev 3" -highlightbackground [option get . background {}]
		pack $f.3.1 -side left
		pack $f.3 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_synlev 1}
		bind $f <Escape> {set pr_synlev 0}
	}
	wm title $f "LEVELS AT TIMEMARKS FOR FILE '[file rootname [file tail $fnam]]'"
	set pr_synlev 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_synlev
	set finished 0
	while {!$finished} {
		DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
		tkwait variable pr_synlev
		switch -- $pr_synlev {
			0 {
				set finished 1
			}
			1 {
				if {![info exists symatimes(1)]} {
					Inf "No Timemarks Specified"
					continue
				}
				set envfnam $evv(DFLT_OUTNAME)
				append envfnam $evv(TEXT_EXT)
				set CDP_cmd [file join $evv(CDPROGRAM_DIR) envel]
				lappend CDP_cmd extract 2 $fnam $envfnam 50
				Block "Extracting Peaks From $fnam"
				set CDPidrun 0
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$CDP_cmd"} CDPidrun] {
					Inf "Envelope Extraction Failed : $CDPidrun"
					DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
					UnBlock
					continue
				} else {
	   				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Envelope Extraction Failed"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
					UnBlock
					continue
				}
				if {![file exists $envfnam]} {
					Inf "Cannot Find Output Envelope File '$envfnam' To Extract Peaks"
					DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
					UnBlock
					continue
				}
				set levels [GetTimemarkLevels $envfnam $symatimes(1) $pa($fnam,$evv(DUR))]
				if {[llength $levels] <= 0} {
					Inf "Cannot Write Peaks Data: No Peaks Found"
					UnBlock
					continue
				}
				if [catch {open $outfnam "w"} zit] {
					Inf "Cannot Open File '$outfnam' To Write Pitch Data"
					UnBlock
					continue
				}
				foreach level $levels {
					puts $zit $level
				}
				close $zit
				UnBlock
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "Peaks File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
				if {[info exists ischused]} {
					set chused $chlist
					SaveMetaProcessFilesUsed
					unset ischused	;#	AVOID SAVING Chosen-Files-List twice
				}
			}
			2 {
				if {$tmarks_exist} {
					set msg "Timemarks For This File Already Exist: Ignore Them ?"
					set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				SnackDisplay $evv(SN_TIMESLIST) syncmarks4 0 $fnam
				if {[info exists symasamps(0)]} {
					set tmarks_exist 0
					catch {unset symasamps(1)}
					catch {unset symatimes(1)}
					foreach sampcnt $symasamps(0) {
						lappend symasamps(1) $sampcnt
						lappend symatimes(1) [expr $sampcnt * $invsrate]
					}
				}
			}
			3 {
				if {![info exists symasamps(1)]} {
					Inf "No Timemarks To Save"
					continue
				}
				set infofnam [file join $evv(URES_DIR) "_syma_"]
				append infofnam [file rootname [file tail $fnam]] $evv(TEXT_EXT)
				if {[file exists $infofnam]} {
					set msg "Timemark Information Already Exists For File '$fnam'. Overwrite It ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				if {[catch {open $infofnam "w"} zit]} {
					Inf "Cannot Open File To Write Timemark Data For File '$fnam'"
					continue
				}
				foreach line $symasamps(1) {
					puts $zit $line
				}
				close $zit
				Inf "Timemarks Saved"
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#--- Pad end of snd (WHICH MUST BE ON WORKSPACE) with silence and return with SAME NAME: (to force tstretch to work!)

proc AddSilenceToEndOfFile {fnam silfil extendfil} {
	global pa evv prg_dun prg_abortd CDPidrun simple_program_messages

	set	srate $pa($fnam,$evv(SRATE))
	set	chans $pa($fnam,$evv(CHANS))

	set cmd [file join $evv(CDPROGRAM_DIR) synth]
	lappend cmd silence $silfil $srate $chans 0.1
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Failed To Synthesize Silent File To Extend File [file rootname [file tail $fnam]]: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Synthesize Silent File To Extend File [file rootname [file tail $fnam]]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $silfil]} {
		ErrShow "Failed To Synthesize Silent File To Extend File [file rootname [file tail $fnam]]"
		return 0
	}
	set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
	lappend cmd join $fnam $silfil $extendfil -w0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Cannot Join Silence To End Of File [file rootname [file tail $fnam]]: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Cannot Join Silence To End Of File [file rootname [file tail $fnam]]"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		return 0
	}
	if {![file exists $extendfil]} {
		ErrShow "Failed To Join Silence To End Of File [file rootname [file tail $fnam]]"
		return 0
	}
	return 1
}

#---- Remember files used by meta processes, so they can be recalled on CHosen Files listing.

proc SaveMetaProcessFilesUsed {} {
	global chlist chused last_chused
	if [info exists chlist] {
		if {[info exists chused]} {
			set last_chused $chused
		}
		set chused $chlist
		SetLastMixfile $chlist
	}
}

#--- Sync Several Sndfiles to timemarks of 1st

proc SyncSeveralFilesAtTimemarks {} {
	global chlist pa evv pr_syncmulti symulwhich symultag symasamps symatimes last_outfile
	global chused blist_change wl background_listing rememd wstk prg_dun prg_abortd CDPidrun simple_program_messages

	if {![info exists chlist] || ([llength $chlist] < 2)} {
		Inf "Select 2 Or More Soundfiles On Chosen Files List"
		return
	}
	set fnamsnds $chlist
	set datacnt 0
	foreach fnamsnd $fnamsnds {
		if {$pa($fnamsnd,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Select Soundfiles Only"
			return
		}
		if {$datacnt == 0} {
			set fnam1 $fnamsnd
			set srate $pa($fnam1,$evv(SRATE))
			set chans $pa($fnam1,$evv(CHANS))
			if {$chans > 1} {
				Inf "This Facility Only Works With Mono Files For The Moment"
				return
			}
			set invsrate [expr 1.0 / $srate]
		} else {
			if {$srate != $pa($fnamsnd,$evv(SRATE))} {
				Inf "Soundfiles Are Not At Same Sample-Rate"
				return
			}
			if {$chans != $pa($fnamsnd,$evv(CHANS))} {
				Inf "Soundfiles Do Not Have Same Number Of Channels"
				return
			}
		}
		incr datacnt
	}
	catch {unset symasamps}
	set cnt 1
	foreach fnam $fnamsnds {
		if {[LoadExistingSymaInfo $fnam $cnt]} {
			if {![info exists existxt]} {
				set existxt "(Timemarks exist for Files"
			}		
			append existxt "  " $cnt
		}
		incr cnt
	}
	if {[info exists existxt]} {
		append existxt ")"
	}
	set analfnam $evv(DFLT_OUTNAME)
;# 2023
	append analfnam 0 $evv(ANALFILE_OUT_EXT)
	set stretchfnam $evv(DFLT_OUTNAME)
	append stretchfnam 1 $evv(TEXT_EXT)
;# 2023 (RWD) new lines from SL 17.0.6
    set analstrfnam $evv(DFLT_OUTNAME)
;# 2023
;# 2023 UNUSED VARIABLES REMOVED
	set silfil $evv(DFLT_OUTNAME)
	append silfil 3 $evv(SNDFILE_EXT)
	set silfil2 $evv(DFLT_OUTNAME) 
	append silfil2 4 $evv(SNDFILE_EXT)
	set extendfil $evv(DFLT_OUTNAME) 
	append extendfil 5 $evv(SNDFILE_EXT)
	set syncfnam $evv(DFLT_OUTNAME)
	append syncfnam 2 $evv(TEXT_EXT)

	set f .syncmulti
	if [Dlg_Create $f "SYNCHRONISE MANY FILES AT TIMEMARKS" "set pr_syncmulti 0" -borderwidth $evv(SBDR)] {
		frame $f.0 -bd $evv(SBDR)
		frame $f.00 -bd $evv(SBDR)
		frame $f.1 -bd $evv(SBDR)
		frame $f.2 -bd $evv(SBDR)
		frame $f.3 -bd $evv(SBDR)
		frame $f.4 -bg $evv(POINT) -height 1
		frame $f.5 -bd $evv(SBDR)
		button $f.0.qq -text "Quit" -command "set pr_syncmulti 0" -highlightbackground [option get . background {}]
		pack $f.0.qq -side right
		button $f.0.do -text "Create Warpfiles" -command "set pr_syncmulti 1" -highlightbackground [option get . background {}]
		button $f.0.h -text "Help" -command "HelpSync" -bg $evv(HELP)
		button $f.0.sv -text "Sound View" -command "set pr_syncmulti 2" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		pack $f.0.do $f.0.h $f.0.sv -side left -padx 2
		pack $f.0 -side top -fill x -expand true
		if {[info exists existxt]} {
			label $f.00.ex -text $existxt -fg $evv(SPECIAL)
			pack $f.00.ex -side left -padx 2
			pack $f.00 -side top
		}
		label $f.1.ll -text "Assign Timemarks to File (Use \"Sound View\")"
		frame $f.1.r
		label $f.1.r.ll -text "SELECT FILE"
		pack $f.1.r.ll -side left
		set n 1
		while {$n <= $datacnt} {
			radiobutton $f.1.r.r$n -text $n -variable symulwhich -value $n
			pack $f.1.r.r$n -side left
			incr n
		}
		pack $f.1.ll $f.1.r -side top -pady 2
		pack $f.1 -side top
		label $f.2x -text "Outfiles take names of corresponding infiles, each followed by a 'tag'" -fg $evv(SPECIAL) -width 100
		pack $f.2x -side top
		label $f.3.ll -text "Outfile Tag "
		entry $f.3.e -textvariable symultag -width 16
		pack $f.3.ll $f.3.e -side left
		pack $f.3 -side top
		button $f.5.1 -text "Save Timemarks?" -command "set pr_syncmulti 3" -highlightbackground [option get . background {}]
		pack $f.5.1 -side left
		pack $f.5 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_syncmulti 0}
	}
	wm title $f "SYNC AT TIMEMARKS TO FILE '[file rootname [file tail $fnam1]]'"
	set symulwhich 0
	set n 1
	while {$n <= $datacnt} {
		if {[lsearch [array names symasamps] $n] < 0} {
			set symulwhich $n
			break
		}
		incr n
	}
	if {![info exists symultag]} {
		set symultag ""
	}
	set delallsymultag 0
	set pr_syncmulti 0
	catch {unset symatimes}
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_syncmulti
	set finished 0
	while {!$finished} {
		tkwait variable pr_syncmulti
		switch -- $pr_syncmulti {	
			0 {
				set finished 1
			}
			1 {

				;#	CHECK FOR EXISTING SYNCHRONISATION DATA FOR INPUT FILES

				set n 1
				catch {unset badtimes}
				while {$n <= $datacnt} {
					if {![info exists symasamps($n)]} {
						lappend badtimes $n
					}
					incr n
				}
				if {[info exists badtimes]} {
					set msg "Timemarks Have Not Been Assigned To\nFiles  "
					foreach val $badtimes {
						append msg $val "  "
					}
					Inf $msg
					continue
				}
				if {[string length $symultag] <= 0} {
					Inf "No Name Tag Entered"
					continue
				}
				set symultag [string tolower $symultag]
				if {![ValidCDPRootname $symultag]} {
					continue
				}
				;#	CHECK WHETHER ANY OF OUTPUT FILES ALREADY EXIST

				set out_fnams 0	;#	NO OUTPUT FILENAME NEEDED FOR 1ST INFILE
				set OK 1
				set n 1
				while {$n < $datacnt} {
					set outfnam	[file rootname [file tail [lindex $fnamsnds $n]]]
					append outfnam "_" $symultag $evv(SNDFILE_EXT)
					if {[file exists $outfnam]} {
						if {$delallsymultag != 1} {
							set msg "File '$outfnam' Already Exists. Overwrite It ??"
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "no"} {
								set OK 0
								break
							}
						}
						set i [LstIndx $outfnam $wl]
						set blist_change 0
						if {![DeleteFileFromSystem $outfnam 0 1]} {
							Inf "Cannot Delete Existing File '$outfnam'"
							set OK 0
							break
						} else {
							DummyHistory $outfnam "DESTROYED"
							if {[IsInAMixfile $outfnam]} {
								if {[MixM_ManagedDeletion $outfnam]} {
									MixMStore
								}
							}
							if {$blist_change} {
								SaveBL $background_listing
							}
							if {$i >= 0} {
								WkspCnt [$wl get $i] -1
								$wl delete $i
								catch {unset rememd}
							}
						}
						if {($delallsymultag == 0) && ($datacnt > 2)} {
							set msg "Do You Wish To Delete All Other Existing '_$symultag' Files Related To Your Input Sounds ??"
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								set delallsymultag 1
							} else {
								set delallsymultag -1	;#	i.e. Question has been asked, and answer is 'No' (don't ask again)
							}
						}
					}
					lappend out_fnams $outfnam
					incr n
				}
				if {!$OK} {
					continue
				}

				;#	GET SYNCHRONISATION DATA FOR INPUT FILES WHICH HAVE NO EXISTING DATA (OR WHERE DATA IS TO BE RENEWED)

				set OK 1
				set n 1
				while {$n <= $datacnt} {
					if {![info exists symasamps($n)] || ([llength $symasamps($n)] <= 0)} {
						Inf "No Times Marked In File $n (use \"Sound View\")"
						set OK 0
						break
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				set OK 1
				set k 1

				;#	CHECK ALL SYNCHRONISATION DATA (MONOTONICALLY INCREASING FROM >= 0.0)

				while {$k <= $datacnt} {
					set len 0
					catch {unset symatimes($k)} 
					foreach val2 $symasamps($k) {
						set symatime [expr double($val2) * $invsrate]
						lappend symatimes($k) $symatime
						incr len
					}
					set OK 1
					set len_less_one [expr $len - 1]
					set n 0
					while {$n < $len_less_one} {
						set tim_n [lindex $symatimes($k) $n]
						set m $n
						incr m
						while {$m < $len} {
							set tim_m [lindex $symatimes($k) $m]
							if {[Flteq $tim_n $tim_m]} {
								Inf "Duplicated Time-points In File [lindex $fnamsnds [expr $k - 1]]"
								set OK 0
								break
							} elseif {$tim_m < $tim_n} {
								set $symatimes($k) [lreplace $symatimes($k) $m $m $tim_n]
								set $symatimes($k) [lreplace $symatimes($k) $n $n $tim_m]
								set tim_n $tim_m
							}
							if {!$OK} {
								break
							}
							incr m
						}
						if {!$OK} {
							break
						}
						incr n
					}
					if {!$OK} {
						break
					}
					incr k
				}
				if {!$OK} {
					continue
				}
				set OK 1

				#	IF FILES HAVE DIFFERENT NUMBERS OF SYNC-POINTS, USE THE SMALLEST SET (IGNORE POINTS BEYOND THERE)

				set minlen 1000000
				set n 1
				while {$n <= $datacnt} {
					set len [llength $symatimes($n)]
					if {$len < $minlen} {
						set minlen $len
					}
					incr n
				}
				incr minlen -1
				set n 1
				while {$n <= $datacnt} {
					set symatimes($n) [lrange $symatimes($n) 0 $minlen]
					incr n
				}
				incr minlen
				set m 0

				;#	CREATE A MASTER SYNC-LIST OF ALL TIME-CORRESPONDENCES IN ALL INFILES

				catch {unset synclines}
				while {$m < $minlen} {
					catch {unset line}
					set n 1
					while {$n <= $datacnt} {
						lappend line [lindex $symatimes($n) $m]
						incr n
					}
					lappend synclines $line
					incr m
				}
				;#	TIMEWARP ALL FILES (EXCEPT FIRST IN LIST) TO SYNC TO TIMES IN FIRST

				Block "TIMEWARPING THE SOUNDS"
				set m 1
				set n 2
				catch {unset last_outfile_x}
				while {$n <= $datacnt} {
					DeleteAllTemporaryFiles

					;#	SELECT INPUT AND OUTPUT NAMES FOR THIS PASS

					set fnam2   [lindex $fnamsnds  $m]
					set outfnam [lindex $out_fnams $m]

					;#	CREATE SYNCING DATA FOR THIS PARTICULAR FILE

					if {[IsEven $n]} {
						wm title .blocker "TIMEWARPING FILE [file rootname [file tail $fnam2]]"
					} else {
						wm title .blocker "NOW TIMEWARPING FILE [file rootname [file tail $fnam2]]"
					}
					catch {unset nulines}
					foreach line $synclines {
						set nuline [lindex $line 0]
						lappend nuline [lindex $line $m]
						lappend nulines $nuline
					}
					if [catch {open $syncfnam "w"} zit] {
						Inf "Cannot Open File $offnam To Write Syncing Data"
						set OK 0
						break
					}
					foreach line $nulines {
						puts $zit $line
					}
					close $zit

					;#	CREATE ANALYSIS FILE

					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $fnam2 $analfnam -c1024 -o3
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Create Analysis File From $fnam2: $CDPidrun"
						catch {unset CDPidrun}
						incr n
						incr m
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Create Analysis File From $fnam2"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						incr n
						incr m
						continue
					}

					;#	CREATE SYNCD VERSION

					set cmd [file join $evv(CDPROGRAM_DIR) specnu]
					lappend cmd sync $analfnam $strfnam $syncfnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Stretch The Analysis File For File $fnam2: $CDPidrun"
						catch {unset CDPidrun}
						incr n
						incr m
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Stretch The Analysis File For File $fnam2"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						incr n
						incr m
						continue
					}

					;#	RECONVERT TO WAV FILE

					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd synth $strfnam $outfnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Create Output File '$outfnam': $CDPidrun"
						catch {unset CDPidrun}
						incr n
						incr m
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Create Output File '$outfnam'"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						incr n
						incr m
						continue
					}
					if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
						lappend last_outfile_x $outfnam
					}
					set outfiles 1
					incr n
					incr m
				}
				UnBlock
				if [info exists outfiles] {
					Inf "Warped Files Are On The Workspace"
					if {[info exists last_outfile_x]} {
						set last_outfile $last_outfile_x
					}
					set chused $chlist
					SaveMetaProcessFilesUsed
				}
			}
			2 {
				if {!$symulwhich} {
					Inf "No Soundfile Selected"
					continue
				}
				set thissnd [lindex $fnamsnds [expr $symulwhich - 1]]
				if {[info exists symasamps($symulwhich)]} {
					set msg "Timemark Information Already Exists For File '$thissnd'. Override It ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
				}
				catch {unset symasamps(0)}
				SnackDisplay $evv(SN_TIMESLIST) syncmarks5 0 $thissnd
				if {![info exists symasamps(0)]} {
					continue
				}
				catch {unset symatimes($symulwhich)}
				catch {unset symasamps($symulwhich)}
				foreach sampcnt $symasamps(0) {
					lappend symasamps($symulwhich) $sampcnt
					lappend symatimes($symulwhich) [expr $sampcnt * $invsrate]
				}
				Inf "Timemark Information Ready For File [file rootname [file tail $thissnd]]"
			}
			3 {
				if {![info exists symasamps]} {
					Inf "No Timemarks To Save"
					continue
				}
				Block "SAVING TIMEMARKS"
				set n 1
				foreach fnam $fnamsnds {
					if {![info exists symasamps($n)]} {
						incr n
						continue
					}
					set infofnam [file join $evv(URES_DIR) "_syma_"]
					append infofnam [file rootname [file tail $fnam]] $evv(TEXT_EXT)
					if {[file exists $infofnam]} {
						set msg "Timemark Information Already Exists For File '$fnam'. Overwrite It ??"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							incr n
							continue
						}
					}
					if {[catch {open $infofnam "w"} zit]} {
						Inf "Cannot Open File To Write Timemark Data For File '$fnam'"
						incr n
						continue
					}
					foreach line $symasamps($n) {
						puts $zit $line
					}
					set saved_tm 1
					close $zit
					incr n
				}
				UnBlock
				if {[info exists saved_tm]} {
					Inf "Time Marks Saved"
					unset saved_tm
				} else { 
					Inf "No Time Marks Have Been Saved"
				}
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#----- Isolate peaks in a specified frequency band of a sound and create outfile (or mixfile) of peaks only.

proc SpectralEventIsolator {} {
	global pa evv wl chlist readonlyfg readonlybg mu wstk last_outfile
	global pr_speciso specisobot specisotop specisoscan spectomix specisotag orig_specisotag specisooff orig_specisooff specisofnam speciso_nyquist
	global specisoskt specisospl orig_specisospl simple_program_messages prg_dun prg_abortd CDPidrun specisopkf orig_specisoscan orig_specisopkf 
	global orig_specisobot orig_specisotop orig_specisoskt specisoinv

	set got 0
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] != 1) || ([lindex $ilist 0] == -1)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Soundfile Or Place One On The Chosen Files List"
			return
		}
		set fnam [lindex $chlist 0]
	} else {
		set fnam [$wl get [lindex $ilist 0]]
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			if {![info exists chlist] || ([llength $chlist] != 1)} {
				Inf "Select A Soundfile Or Place One On The Chosen Files List"
				return
			}
			set fnam [lindex $chlist 0]
		}
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	set srate $pa($fnam,$evv(SRATE))
	set speciso_nyquist [expr int(round(double($srate)/2.0))]
	set chans $pa($fnam,$evv(CHANS))
	set monoconvert 0
	if {$chans > 1} {
		set monoconvert 1
	}

			;#	ESTABLISH INITIAL VALUES

	if {[info exists orig_specisobot]} {
		set specisobot $orig_specisobot
	} else {
		set specisobot 4000
	}
	if {[info exists orig_specisotop]} {
		set specisotop $orig_specisotop
	} else {
		set specisotop $speciso_nyquist
	}
	if {[info exists orig_specisoscan]} {
		set specisoscan $orig_specisoscan
	} else {
		set specisoscan 10
	}
	if {[info exists orig_specisopkf]} {
		set specisopkf $orig_specisopkf 
	} else {
		set specisopkf 3
	}
	if {[info exists orig_specisoskt]} {
		set specisoskt $orig_specisoskt 
	} else {
		set specisoskt 20
	}
	if {![info exists orig_specisooff]} {
		set orig_specisooff 0
	}
	if {![info exists orig_specisospl]} {
		set orig_specisospl 15
	}

	set monofnam $evv(MACH_OUTFNAME)		;#	IF MONO CONVERSION NECESSARY, THE MONO FILE OUTPUT
	append monofnam 0 $evv(SNDFILE_EXT)
	set bakfnam $evv(MACH_OUTFNAME)			;#	IF APPENDING DATA TO EXISTING MIXFILE, BAKUP COPY OF ORIG MIXFILE, 
	append bakfnam 1 $evv(SNDFILE_EXT)
	set silfil $evv(DFLT_OUTNAME)			;#	THE SILENCE TO ADD TO SOURCE END TO ENSURE PVOC SYNTH DOES NOT CLIP END
	append silfil 0 $evv(SNDFILE_EXT)
	set extendfil $evv(DFLT_OUTNAME)		;#	THE SOURCEFILE EXTENED WITH SILENCE
	append extendfil 1 $evv(SNDFILE_EXT)
	set analfnam $evv(DFLT_OUTNAME)			;#	THE ANALYSIS FILE FROM (MONOED) SOURCE (WITH SILENT EXTENSION)
;# 2023
	append analfnam 2 $evv(ANALFILE_OUT_EXT)
	set filtanalfnam $evv(DFLT_OUTNAME)		;#	THE FILTERED ANALYSIS FILE
;# 2023
	append filtanalfnam 3 $evv(ANALFILE_OUT_EXT)
	set filtfnam $evv(DFLT_OUTNAME)			;#	THE RESYNTHESIZED FILTERED SOURCE
	append filtfnam 4 $evv(SNDFILE_EXT)
	set envfnam $evv(DFLT_OUTNAME)			;#	THE (TEXT) ENVELOPE OF THE FILTERED FILE
	append envfnam 5 $evv(TEXT_EXT)
	set gatefnam $evv(DFLT_OUTNAME)			;#	THE GATING ENVELOPE DERIVED FROM THE ENVELOPE
	append gatefnam 6 $evv(TEXT_EXT)
	set sndoutfnam $evv(DFLT_OUTNAME)		;#	THE GATED OUTPUT FILE IS OUTPUT IS A SOUNDFILE
	append sndoutfnam 7 $evv(SNDFILE_EXT)
	set mixsilfil $evv(DFLT_OUTNAME)		;#	THE SILENCE TO ADD TO MIXFILE TO ENSURE ITEMS OCCUR AT CORRECT TIME IN MIX
	append mixsilfil 8 $evv(SNDFILE_EXT)
	set mixoutfnam $evv(DFLT_OUTNAME)		;#	THE OUTPUT MIXFILE
	append mixoutfnam 9 $evv(TEXT_EXT)
	set elefnam $evv(DFLT_OUTNAME)			;#	GENERIC SNDFILENAME FOR CUT ELEMENTS IN MIXFILE (add n to end of each)
	append elefnam 0_

	set f .speciso
	if [Dlg_Create $f "ISOLATE EVENTS FROM FILE [file rootname [file tail $fnam]] BY SPECTRAL ANALYSIS" "set pr_speciso 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0]
		set f1 [frame $f.1]
		set f2 [frame $f.2]
		set f3 [frame $f.3]
		set f4 [frame $f.4]
		set f5 [frame $f.5]
		button $f0.qq -text "Abandon" -command "set pr_speciso 0" -highlightbackground [option get . background {}]
		button $f0.hh -text "Help" -command "SpecIsoHelp" -bg $evv(HELP) -highlightbackground [option get . background {}]
		pack $f0.qq $f0.hh -side right -padx 2
		button $f0.do -text "Isolate Peaks" -command "set specisoinv 0; set pr_speciso 1" -highlightbackground [option get . background {}]
		button $f0.od -text "Silence Peaks" -command "set specisoinv 1; set pr_speciso 1" -highlightbackground [option get . background {}]
		pack $f0.do $f0.od -side left -padx 2
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Frequency band to focus in : Bottom "
		entry $f1.bot -textvariable specisobot -width 8 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f1.ll2 -text " Top "
		entry $f1.top -textvariable specisotop -width 8 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f1.ll3 -text " Filter Skirtwidth "
		entry $f1.skt -textvariable specisoskt -width 8 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		pack $f1.ll $f1.bot $f1.ll2 $f1.top $f1.ll3 $f1.skt -side left
		pack $f1 -side top -pady 2
		label $f2.ll1 -text "Up/Down Arrows Change Bottom Frq : Left/Right Arrows change Top Frequency bo 100 Hz" -fg $evv(SPECIAL)
		label $f2.ll2 -text "Shift      Up/Down/Left/Right change frequency by 1000 Hz" -fg $evv(SPECIAL)
		label $f2.ll3 -text "Control Up/Down/Left/Right change frequency by 10 Hz    " -fg $evv(SPECIAL)
		label $f2.ll4 -text "Command        Up/Down/Left/Right change frequency by 1 Hz      " -fg $evv(SPECIAL)
		pack $f2.ll1 $f2.ll2 $f2.ll3 $f2.ll4 -side top
		pack $f2 -side top -pady 2
		label $f3.ll -text "Local-Average scan-range "
		entry $f3.scan -textvariable specisoscan -width 8 
		label $f3.pp -text "Peaking Factor "
		entry $f3.pk -textvariable specisopkf -width 4
		label $f3.ll2 -text "OUTPUT AS "
		radiobutton $f3.r1 -text soundfile -variable spectomix -value 0 -command SpecIsoMix
		radiobutton $f3.r2 -text mixfile -variable spectomix -value 1 -command SpecIsoMix
		pack $f3.ll $f3.scan $f3.pp $f3.pk -side left
		pack $f3.r2 $f3.r1 $f3.ll2 -side right
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "" -width 24
		entry $f4.tag -textvariable specisotag -width 6 -bd 0
		label $f4.ll1 -text "" -width 12
		entry $f4.spl -textvariable specisospl -width 6 -bd 0
		label $f4.ll2 -text "" -width 44
		entry $f4.off -textvariable specisooff -width 6 -bd 0
		pack $f4.ll $f4.tag $f4.ll1 $f4.spl $f4.ll2 $f4.off -side left
		pack $f4 -side top -pady 2
		label $f5.ll -text "Output Filename "
		entry $f5.fnam -textvariable specisofnam -width 16
		pack $f5.fnam $f5.ll -side right
		pack $f5 -side top -fill x -expand true -pady 2
		bind $f <Up> {SpecIsoFrq bot 100 1}
		bind $f <Control-Up> {SpecIsoFrq bot 10 1}
		bind $f <Shift-Up> {SpecIsoFrq bot 1000 1}
		bind $f <Command-Up> {SpecIsoFrq bot 1 1}
		bind $f <Down> {SpecIsoFrq bot 100 0}
		bind $f <Control-Down> {SpecIsoFrq bot 10 0}
		bind $f <Shift-Down> {SpecIsoFrq bot 1000 0}
		bind $f <Command-Down> {SpecIsoFrq bot 1 0}
		bind $f <Right> {SpecIsoFrq top 100 1}
		bind $f <Control-Right> {SpecIsoFrq top 10 1}
		bind $f <Shift-Right> {SpecIsoFrq top 1000 1}
		bind $f <Command-Right> {SpecIsoFrq top 1 1}
		bind $f <Left> {SpecIsoFrq top 100 0}
		bind $f <Control-Left> {SpecIsoFrq top 10 0}
		bind $f <Shift-Left> {SpecIsoFrq top 1000 0}
		bind $f <Command-Left> {SpecIsoFrq top 1 0}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_speciso 0}
	}
	set spectomix 0
	set specisoinv 0
	set specisooff ""
	set specisospl ""
	set specisotag ""
	if {![info exists orig_specisotag]} {
		set orig_specisotag "spi"  
	}
	set specisofnam ""
	set pr_speciso 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_speciso
	set finished 0
	while {!$finished} {
		tkwait variable pr_speciso
		if {$pr_speciso == 0} {
			break
		}
		if {$specisotop == $specisobot} {
			Inf "Frequency Band Too Narrow"
			continue
		} elseif {$specisotop < $specisobot} {
			set temp $specisotop 
			set specisotop $specisobot
			set specisobot $temp
		}
		if {([string length $specisoskt] <= 0) || ![IsNumeric $specisoskt] || ($specisoskt < 0.0) || ($specisoskt >= [expr double($speciso_nyquist)/2.0])} {
			Inf "Invalid Filter Skirt Width"
			continue
		}
		if {![regexp {^[0-9]+$} $specisoscan] || ($specisoscan < 2)} {
			Inf "Invalid Local-Average Scan-Range"
			continue
		}
		if {![regexp {^[0-9]+$} $specisopkf] || ($specisopkf < 1)} {
			Inf "Invalid Peaking Factor"
			continue
		}
		if {[string length $specisofnam] <= 0} {
			Inf "No Output File Name Entered"
			continue
		}
		if {![ValidCDPRootname $specisofnam]} {
			continue
		}
		set outfnam [string tolower $specisofnam]
		set dir [file dirname $fnam]
		if [string match $dir "."] {
			set dir ""
		}
		set outfnam [file join $dir $outfnam]
		if {$spectomix} {
			append outfnam [GetTextfileExtension mix]
		} else {
			append outfnam $evv(SNDFILE_EXT)
		}
		if {$spectomix} {

				;#	IF MIXFILE OUT, CHECK EXTRA PARAMS AND CHECK IF ANY POSSIBLE OUT SNDFILES ALREADY EXIST

			if {([string length $specisospl] <= 0) || ![IsNumeric $specisospl] || ($specisospl < 0.0) || ($specisospl >= 200.0)} {
				Inf "Invalid Splicelen"
				continue
			}
			if {([string length $specisooff] <= 0) || ![IsNumeric $specisooff] || ($specisooff < 0.0)} {
				Inf "Invalid Offset Time"
				continue
			}
			if {![regexp {^[a-zA-Z]+$} $specisotag]} {
				Inf "Invalid Soundfile Tag (Must Be Alphabetic)"
				continue
			}
			set specisotag [string tolower $specisotag]
			set tagtest "_"
			append tagtest $specisotag
			set taglen [string length $tagtest]
			set dir [file dirname $fnam]
			set OK 1
			foreach filename [glob -nocomplain [file join $dir *]] {
				set name [file rootname [file tail $filename]]
				set namelen [string length $name]
				set k [string first $tagtest $name]
				if {$k > 0} {
					set j [expr $k + $taglen]
					if {$j < $namelen} {
						set teststr [string range $name $j end]
						if {[regexp {^[0-9]+$} $teststr]} {
							set OK 0
							break
						}
					}
				}
			}
			if {!$OK} {
				set msg "Sounds With The Nametag '$tagtest' Already Exist\n\nChoose A Different Tag\nOr Delete The Existing Tagged Files In "
				if {$dir == "."} {
					append msg "The Cdp Base Directory"
				} else {
					append msg "Directory '$dir'"
				}
				Inf $msg
				continue
			}
		} elseif {[string match $outfnam $fnam]} {
			Inf "You Cannot Overwrite The Input File"
			continue
		}

		;#	CHECK IF OUTFILE ALREADY EXISTS, OPTIONS TO RESTART, TO DELETE IT, OR (IF MIXFILE) TO APPEND TO IT

		set query_overwrite 0
		if {[file exists $outfnam]} {
			set query_overwrite 1
			if {$spectomix} {
				if {![info exists pa($outfnam,$evv(FTYP))]} {
					set ftyp [FindFileType $fnam]
				} else {
					set ftyp $pa($outfnam,$evv(FTYP))
				}
				if {[IsAMixfile $ftyp]} {
					set msg "Append New Sounds To File '$outfnam' ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						if {![file exists $bakfnam]} {
							if [catch {file copy $outfnam $bakfnam} zit] {
								set msg "Failed To Back Up Existing Mixfile '$outfnam': Continue Anyway ?"
								set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
								if {$choice == "no"} {
									continue
								}
							}
						}
						if {![info exists existing_mixlines]} {
							catch {unset existing_mixlines}
							if [catch {open $outfnam "r"} zit] {
								Inf "Cannot Open Existing Mixfile '$outfnam'"
								continue
							}
							while {[gets $zit line] >= 0} {
								lappend existing_mixlines $line
							}
							close $zit
						}
						set query_overwrite 0
						set speciso_append 1
					} else {
						catch {unset speciso_append}
					}
				}
			}
			if {$query_overwrite} {
				set msg "File '$outfnam' Already Exists: Overwrite It ?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
			}
			set i [LstIndx $outfnam $wl]
			set blist_change 0
			if {![DeleteFileFromSystem $outfnam 0 1]} {
				Inf "Cannot Delete Existing File '$outfnam'"
				continue
			} else {
				DummyHistory $outfnam "DESTROYED"
				if {$spectomix} {
					MixMPurge 1
				} else {
					if {[IsInAMixfile $outfnam]} {
						if {[MixM_ManagedDeletion $outfnam]} {
							MixMStore
						}
					}
					if {$blist_change} {
						SaveBL $background_listing
					}
				}
				if {$i >= 0} {
					WkspCnt [$wl get $i] -1
					$wl delete $i
					catch {unset rememd}
				}
			}
		}

						;#	CREATE THE ANALYSIS FILE (IF NOT DONE IN PREVIOUS PASS)

		Block "Isolating Events"
		if {![file exists $analfnam]} {
			set fnam2 $fnam
		
						;#	CREATE MONO VERSION OF SOURCE IF NECESSARY

			if {$monoconvert} {
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 4 $silfil $fnam $monofnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Convert Input File To Mono: $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Convert Input File To Mono"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				set fnam2 $monofnam
			}
							;#	ADD SILENCE TO END OF (MONOFIED) SOURCE

			AddSilenceToEndOfFile $fnam2 $silfil $extendfil
			if {[file exists $extendfil]} {
				set fnam2 $extendfil
			}
								;#	CREATE ANALYSIS FILE

			set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
			lappend cmd anal 1 $fnam2 $analfnam -c1024 -o3
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Cannot Create Analysis File From $fnam: $CDPidrun"
				catch {unset CDPidrun}
				set OK 0
				UnBlock
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Cannot Create Analysis File From $fnam"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				UnBlock
				break
			}
		}
								;#	FILTER THE ANALYSIS FILE

		set cmd [file join $evv(CDPROGRAM_DIR) hilite]
		lappend cmd filter 7 $analfnam $filtanalfnam $specisobot $specisotop $specisoskt
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "Cannot Filter Analysis File From $fnam: $CDPidrun"
			catch {unset CDPidrun}
			set OK 0
			UnBlock
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Cannot Filter Analysis File From $fnam"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			UnBlock
			break
		}
								;#	RESYNTH THE FILTERED SOUND

		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd synth $filtanalfnam $filtfnam
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "Cannot Resynthesize The Filtered Sound: $CDPidrun"
			catch {unset CDPidrun}
			set OK 0
			UnBlock
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Cannot Resynthesize The Filtered Sound"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			UnBlock
			break
		}
								;#	GET ENVELOPE OF FILTERED SOUND

		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd extract 2 $filtfnam $envfnam 50 -d0.0002
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			ErrShow "Cannot Extract Envelope From Filtered Sound: $CDPidrun"
			catch {unset CDPidrun}
			set OK 0
			UnBlock
			break
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Cannot Extract Envelope From Filtered Sound"
			set msg [AddSimpleMessages $msg]
			ErrShow $msg
			set OK 0
			UnBlock
			break
		}												
		if {!$spectomix} {
									;#	IF SOUNDFILE OUTPUT

							;#	CREATE GATING FILE FROM ENVELOPE

			set process_worked [CreateGateEnvelFromEnvelope $envfnam $gatefnam $specisoscan $specisopkf $specisoinv 0] 
			if {![file exists $gatefnam]} {				
				if {$process_worked} {
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except $analfnam
					UnBlock
					continue
				}
				UnBlock
				break
			}											
								;#	GATE THE ORIGINAL SOUND

			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd impose 3 $fnam $gatefnam $sndoutfnam
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Cannot Gate Original Sound To Isolate Found Peaks: $CDPidrun"
				catch {unset CDPidrun}
				set OK 0
				UnBlock
				break
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Cannot Gate Original Sound To Isolate Found Peaks"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				set OK 0
				UnBlock
				break
			}
			if [catch {file rename $sndoutfnam $outfnam} zit] {
				set msg "Cannot Rename Outfile '$sndoutfnam' To '$outfnam'\n\n"
				append msg "Rename This File Outside The Soundloom, Before Quitting This Dialog Box"
				Inf $msg
			}
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "'$outfnam' Is Now On The Workspace"
				set last_outfile $outfnam
			}
			UnBlock
			break

		} else {
									;#	IF MIXFILE OUTPUT
		
							;#	CREATE GATE FUNCTION FROM ENVELOPE

			set cuttimes [CreateGateEnvelFromEnvelope $envfnam $gatefnam $specisoscan $specisopkf $specisoinv 1] 
			if {[llength $cuttimes] == 1} {
				set process_worked [lindex $cuttimes 0]
				if {$process_worked} {
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except $analfnam
					UnBlock
					continue
				}
				UnBlock
				break
			}
							;#	CREATE OUTPUT-NAMES FOR SOUNDFILES IN MIX

			catch {unset mixcutfnams} 
			set len [llength $cuttimes]
			set len [expr $len / 2]
			set n 0
			while {$n < $len} {
				set mixcutfnam [file rootname $fnam]
				append mixcutfnam "_" $specisotag $n $evv(SNDFILE_EXT)
				lappend mixcutfnams $mixcutfnam
				incr n
			}

			if {![info exists speciso_append]} {

					;#	IF PADDING SILENCE NEEDED AT MIXSTART, CREATE SILENT FILE

				set firsttime [lindex $cuttimes 0]			
				if {$firsttime > 0.0} {
					set cmd [file join $evv(CDPROGRAM_DIR) synth]
					lappend cmd silence $mixsilfil $srate $chans [expr $firsttime + 1.0]
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Create Offsetting Silence For Final Mix: $CDPidrun"
						catch {unset CDPidrun}
						UnBlock
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Create Offsetting Silence For Final Mix"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						DeleteAllTemporaryFilesWhichAreNotCDPOutput except [list $analfnam $bakfnam]
						UnBlock
						continue
					}

					;#	SILENT FILE WILL GET OUTPUT-NAME WITH INDEX > CUT FILE INDECES

					set silcutfnam [file rootname $fnam]
					append silcutfnam "_" $specisotag $len $evv(SNDFILE_EXT)

				}
			}
							;#	CUT THE INDIVIDUAL SOUNDFILES TO GO IN MIX

			set twosplices [expr double($specisospl * 2.0)/1000.0]
			catch {unset ofnams}
			catch {unset mixtimes}
			set n 0
			foreach {starttime endtime} $cuttimes {
				lappend mixtimes $starttime
				set thisofnam $elefnam$n$evv(SNDFILE_EXT)
							
							;#	CHECKING SPLICELEN IS OK FOR EACH ELEMENT

				set sndlen [expr $endtime - $starttime]	
				if {$sndlen <= $twosplices} {
					set splicelen [expr ($sndlen / 4.0) * 1000.0]
				} else {
					set splicelen $specisospl
				}
				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd cut 1 $fnam $thisofnam $starttime $endtime -w$splicelen
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Do Edit [expr $n + 1] Of Soundfile '$fnam': $CDPidrun"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Do Edit [expr $n + 1] Of Soundfile '$fnam'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0
					break
				}
				lappend ofnams $thisofnam
				incr n
			}
			if {!$OK} {
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except [list $analfnam $bakfnam]
				UnBlock
				continue
			}
										;#	CREATE MIXFILE

			if [catch {open $mixoutfnam "w"} zit] {
				Inf "Cannot Open File '$mixoutfnam' To Write Mixing Data"	
				if {[info exists speciso_append]} {
					RestoreOrigMixfile 1 $bakfnam $outfnam
				}
				UnBlock
				continue
			}

						;#	GIVE THE SILENT PADDING FILE ITS TRUE OUTPUT NAME

			if {[file exists $mixsilfil]} {
				if {[catch {file rename $mixsilfil $silcutfnam} zit2]} {
					Inf "Cannot Rename Silence Padding File '$mixsilfil' To '$silcutfnam' For The Mixfile"
					close $zit
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except [list $analfnam $bakfnam]
					UnBlock
					continue
				}
#REDUNDANT ??
				DataManage delete $silcutfnam
				set mixsilfil $silcutfnam
			}

					;#	RENAME THE CUT SOUNDFILES FOR MIX, WITH THEIR OUTPUT NAMES

			set OK 1
			foreach ofnam $ofnams mixcutfnam $mixcutfnams {
				if [catch {file rename $ofnam $mixcutfnam} zit2] {
					Inf "Cannot Rename File '$ofnam' To '$mixcutfnam' For The Mixfile\n\nSaving Existing Cutfiles And Returning To Workspace"
					set OK 0
					break
				}
				DataManage delete $mixcutfnam
			}

					;#	IF RENAMING FAILS DELETE THE RENAMED FILES AND QUIT

			if {!$OK} {
				close $zit
				if {[info exists speciso_append]} {
					RestoreOrigMixfile 1 $bakfnam $outfnam
				}
				foreach mixcutfnam $mixcutfnams {
					if {[file exists $mixcutfnam]} {
						catch {file delete $mixcutfnam}
					}
				}
				if {[file exists $mixsilfil]} {
					catch {file delete $mixsilfil}
				}
				UnBlock
				break
			}
					;#	WRITE THE MIXFILE LINES

			set ofnams $mixcutfnams
			catch {unset nutims}

					;#	OFFSET TIMES IN MIX, IF NESS

			foreach tim $mixtimes {
				lappend nutims [expr $tim + $specisooff]
			}
			set mixtimes $nutims

					;#	WRITE SILENCE PADDING FILE IF IT EXISTS

			if {[file exists $mixsilfil]} {
				set line [list $mixsilfil 0 1 1 C]
				puts $zit $line
			}
					;#	IF APPENDING TO EXISTING MIX, WRITE EXISTING MIX LINES

			if {[info exists existing_mixlines]} {
				foreach line $existing_mixlines {
					puts $zit $line
				}
			}
					;#	WRITE NEW MIX LINES

			foreach ofnam $ofnams time $mixtimes {
				set line $ofnam
				lappend line $time $chans 1
				if {$chans < 2} {
					lappend line "C"
				}
				puts $zit $line
			}
			close $zit

					;#	GIVE MIXFILE ITS OUTPUT NAME

			if [catch {file rename $mixoutfnam $outfnam} zit] {
				set msg "Cannot Rename Temporary Mixfile '$mixoutfnam' To '$outfnam'\n\n"
				append msg "Rename This File Outside The Soundloom, Before Quitting This Dialog Box"
				Inf $msg
			}
					;#	PUT ALL FILES ON WORKSPACE

			foreach mixcutfnam $mixcutfnams {
				FileToWkspace $mixcutfnam 0 0 0 0 1
			} 
			if {[file exists $mixsilfil]} {
				FileToWkspace $mixsilfil 0 0 0 0 1
			}
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				set msg "Mixfile '$outfnam' And The Edited Soundfiles Are Now On The Workspace"
				set last_outfile $outfnam
			}
			if {[file exists $mixsilfil]} {
				append msg "\n\nThe File '$mixsilfil' Is A Silent File To Force Start Of Sounds In File To Correct Time"
			}
			Inf $msg
			UnBlock
			break
		}
	}
	set orig_specisobot  $specisobot 
	set orig_specisotop  $specisotop 
	set orig_specisoscan $specisoscan 
	set orig_specisopkf  $specisopkf 
	set orig_specisoskt  $specisoskt 
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#--- Swap from soundfile output to mixfile output of process which isolates peaks from file by spectral analysis

proc SpecIsoMix {} {
	global spectomix readonlyfg readonlybg specisooff specisotag orig_specisooff orig_specisotag specisospl orig_specisospl
	switch -- $spectomix {
		0 {
			.speciso.4.ll  config -text ""
			.speciso.4.tag config -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			.speciso.4.ll1  config -text ""
			.speciso.4.spl config -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			.speciso.4.ll2 config -text ""
			.speciso.4.off config -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			set orig_specisotag $specisotag
			set specisotag ""
			set orig_specisospl $specisospl
			set specisospl ""
			set orig_specisooff $specisooff
			set specisooff ""
		}
		1 {
			.speciso.4.ll  config -text "Tag for Sndfile outputs "
			.speciso.4.tag config -bd 2 -bd 2 -state normal
			.speciso.4.ll1  config -text "Splices (mS)"
			.speciso.4.spl config -bd 2 -state normal
			.speciso.4.ll2 config -text "Time Offset (if adding to existing mixfile) "
			.speciso.4.off config -bd 2 -state normal
			if {[info exists orig_specisooff]} {
				set specisooff $orig_specisooff
			}
			if {[info exists orig_specisospl]} {
				set specisospl $orig_specisospl
			}
			if {[info exists orig_specisotag]} {
				set specisotag $orig_specisotag
			}
		}
	}
}

#--- Help for isolating events from file by spectral analysis

proc SpecIsoHelp {} {
	set msg "ISOLATING EVENTS FROM FILE BY SPECTRAL ANALYSIS\n"
	append msg "\n"
	append msg "Process first filters out the defined frq band,\n"
	append msg "then extracts envelope of the filtered sound.\n"
	append msg "\n"
	append msg "Then uses peaks in envelope to define a gating function,\n"
	append msg "which, applied to the original sound, isolates peaks\n"
	append msg "(in specified frq band) within an otherwise silent file.\n"
	append msg "Also you can keep original sound, with peaks silenced.\n"
	append msg "\n"
	append msg "Alternatively peaks can be saved as separate soundfiles,\n"
	append msg "with a mixfile to remix them at original time positions.\n"
	append msg "\n"
	append msg "The separate-peak sndfiles given tag to add to end of\n"
	append msg "sourcefile name, and are then numbered consecutively.\n"
	append msg "\n"
	append msg "Also possible to add peaks of current file\n"
	append msg "to a mixfile of peaks from a previous file,\n"
	append msg "defining a time-offset at which to begin new peak-data.\n"
	append msg "(this is starttime where complete srcfile would begin.\n"
	append msg "New peaks each further offset from this starttime,\n"
	append msg "exactly as they are offset from zero in source snd).\n"
	append msg "\n"
	append msg "Gating function created by comparing level of\n"
	append msg "each individual envelope point with local average.\n"
	append msg "Points lying above local average represent local peaks\n"
	append msg "If \"peaking factor\" greater than 1, peaks only\n"
	append msg "counted if above \[local-average * peaking-factor\].\n"
	append msg "These peaks then used to define gating function.\n"
	append msg "\n"
	append msg "\"Averaging scan-range\"= no. of envpnts in localrange.\n"
	Inf $msg
}

#------ Change frqband values for speciso window

proc SpecIsoFrq {var step up} {
	global specisobot specisotop speciso_nyquist mu
	if {$var == "bot"} {
		set paramval $specisobot 
	} else {
		set paramval $specisotop 
	}
	if {!$up}  {
		set step [expr -$step]
	}
	set paramval [expr $paramval + $step]
	if {$step > 0} {
		if {$paramval > $speciso_nyquist} {
			set paramval $speciso_nyquist
		}
	} elseif {$paramval < $mu(MINPITCH)} {
		set paramval 0
	}
	if {$var == "bot"} {
		set specisobot $paramval
	} else {
		set specisotop $paramval
	}
}

#------ Use envelope to generate gating envelope

proc CreateGateEnvelFromEnvelope {envfnam gatefnam scan peakfactor inv cuts} {
	if [catch {open $envfnam "r"} zit] {
		Inf "Cannot Open Envelope Data File"
		return 0
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		set line [split $line]
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			lappend envel $item
		}
	}
	close $zit
	if {![info exists envel] || ![IsEven [llength $envel]]} {
		Inf "Problem With Data In Envelope Data File"
		return 0
	}
	set len [expr [llength $envel]/2]
	set scanlim [expr $len - $scan]
	if {$scanlim < 0} {
		Inf "Too Few Data Points In Envelope Using These Parameters"
		return 1
	}
	set halfscan2 [expr $scan / 2]
	set halfscan1 [expr $scan - $halfscan2]
	set scanmin [expr $halfscan1 - 1]
	set cnt 0
	set endscan $halfscan2
	set havepeak 0
	foreach {time val} $envel {				;#	CREATE RAW GATE (envel = 1 if above average, 0 if below)
		if {$cnt < $scanmin} {
			set j 0
			set k $scan
		} elseif {$endscan >= $len} {
			set j $scanlim 
			set k $len
		} else {
			set j [expr $cnt - $scanmin]
			set k [expr $j + $scan]
		}
		set jj [expr ($j * 2) + 1]
		set kk [expr ($k * 2) + 1]
		set sum 0.0
		while {$jj < $kk} {
			set sum [expr $sum + [lindex $envel $jj]]
			incr jj 2
		}
		set average [expr $sum / double($scan)]
		set peakfloor [expr $average * $peakfactor]
		if {$val > $peakfloor} {
			lappend outvals $time 1
			set havepeak 1
		} else {
			lappend outvals $time 0
		}			
		incr cnt
		incr endscan
	}
	if {![info exists outvals]} {
		Inf "Problem 1 With Gate-Generating Process"
		return 0
	}
	if {!$havepeak} {
		Inf "No Peaks Are Found With These Parameters"
		return 1
	}
	set lastt -2
	set lastv -1
	set thist 0
	set thisv 1
	set nextt 2
	set nextv 3
	set len [llength $outvals]
	while {$nextt < $len} {										;#	SMOOTH KINKS IN GATE FILE
		if {$lastt < 0} {
			set thisval [lindex $outvals $thisv]
			set nextval [lindex $outvals $nextv]
			set thistim [lindex $outvals $thist]
			set nexttim [lindex $outvals $nextt]
			if {($thisval == 1) && ($nextval == 0)} {			;#	1 0 at start ... --> 1 1 0
				set newtime [expr $nexttim / 2.0]
				set outvals [linsert $outvals $nextt $newtime 1]		
				incr len 2
			}
		} elseif {$nextt >= $len} {
			set lastval [lindex $outvals $lastv]
			set thisval [lindex $outvals $thisv]
			set lasttim [lindex $outvals $lastt]
			set thistim [lindex $outvals $thist]
			if {($lastval == 0) && ($thisval == 1)} {			;#	0 1 at end --> 0 1 1
				set timestep [expr ($thistim - $lasttim) / 2.0]
				set newtime [expr $lasttim + $timestep]
				set outvals [linsert $outvals $lastt $newtime 1]		
			}
			break
		} else {
			set lastval [lindex $outvals $lastv]
			set thisval [lindex $outvals $thisv]
			set nextval [lindex $outvals $nextv]
			set lasttim [lindex $outvals $lastt]
			set thistim [lindex $outvals $thist]
			set nexttim [lindex $outvals $nextt]
			if {($lastval == 0) && ($thisval == 1) && ($nextval == 0)} {	;#	     0   1   0
				set timestep [expr ($nexttim - $thistim) / 2.0]
				set newtime [expr $thistim + $timestep]						;#  -->  0   1 1 0
				set outvals [linsert $outvals $nextt $newtime 1]		

				set timestep [expr ($thistim - $lasttim) / 2.0]				;#	-->	 0 1   1 0
				set newtime [expr $lasttim + $timestep]
				set outvals [lreplace $outvals $thist $thist $newtime]		
				incr len 2
			}
		}
		incr lastt 2
		incr lastv 2
		incr thist 2
		incr thisv 2
		incr nextt 2
		incr nextv 2
	}
	if {![info exists outvals]} {
		Inf "Problem 2 With Gate-Generating Process"
		return 0
	}
	if {$inv} {
		foreach {time val} $outvals {
			set val [expr !$val]
			lappend nuvals $time $val
		}
		set outvals $nuvals
	}

	if {$cuts} {					;#	CONVERT GATE INFO TO EDIT INFO
		set len [llength $outvals]
		set lastt -2
		set lastv -1
		set thist 0
		set thisv 1
		while {$thist <= $len} {
			if {$lastt < 0} {						;#	AT START  1-> : cut at start
				set thisval [lindex $outvals $thisv]
				if {$thisval > 0} {
					lappend cutvals 0.0
				}
			} elseif {$thist >= $len} {				;#	AT END	  ->1 : cut at end
				set lastval [lindex $outvals $lastv]
				if {$lastval > 0} {
					lappend cutvals [lindex $outvals $lastt]
					break
				}
			} else {
				set lastval [lindex $outvals $lastv]
				set thisval [lindex $outvals $thisv]
				if {($lastval == 0) && ($thisval == 1)} {		;#	0->1	: cut at time of 0-val
					lappend cutvals [lindex $outvals $lastt]
				} elseif {($lastval == 1) && ($thisval == 0)} {	;#	1->0	: cut at time of 0-val
					lappend cutvals [lindex $outvals $thist]
				}
			}
			incr lastt 2
			incr lastv 2
			incr thist 2
			incr thisv 2
		}
		if {![info exists cutvals]} {
			Inf "Problem 3 With Gate-Generating Process"
			return 0
		}
		return $cutvals
	}	
	if [catch {open $gatefnam "w"} zit] {
		Inf "Cannot Open Gating Data File"
		return 0
	}
	foreach {time val} $outvals {
		set line [list $time $val]
		puts $zit $line
	}
	close $zit
	return 1
}

#---- Transfers CDP Error messages to TCL dialog-box display

proc AddSimpleMessages {msg} {
	global simple_program_messages
	if {[info exists simple_program_messages]} {
		append msg "\n"
		foreach item $simple_program_messages {
			append msg "\n" $item
		}
	}
	return $msg
}

#########################
#	FOF RECONSTRUCTION  #
#########################

#------ FOF Extract/Reconstruct Dialogue Box

proc FofReco {extract} {
	global fofisocuts pr_fofex fofexclude fofexfnam blist_change background_listing rememd chlist wstk pa evv wl
	global prg_dun prg_abortd simple_program_messages CDPidrun fofexnorm fofexgain readonlyfg readonlybg fofexgainbak 
	global fofmode lastfofmode fofexdb fofexno fofexnobak fofextime fofexdur
	global fofexno2 fofexno3 fofexno2bak fofexno3bak fofexlofrq fofexhifrq fofexlolev fofexhilev
	global fofexlofrqbak fofexhifrqbak fofexlolevbak fofexhilevbak fofunitcnt fofunitlen fofbankfnam fofdubl fofnotwin
	global fofenvget fofenvset foforndur fofpadj fofstacdur fofdecexp fofefnam fofpfnam
	global fofeo fofpo fofpq fofpqs fofpno fofenvstac fofenvexp fofother fofsrc fofmaxsamp foftw foftwq foftworn
	global foftstrpfnam foftstrefnam last_outfile

	catch {unset fofsrc}
	set fofenvget 0
	set fofenvset 0
	set foforndur ""
	set fofpadj ""
	set fofstacdur ""
	set fofdecexp ""
	set fofdubl 1
	set fofnotwin 0
	set fofexlofrq ""
	set fofexhifrq ""
	set fofexlolev ""
	set fofexhilev ""
	set fofexlofrqbak 55
	set fofexhifrqbak 880
	set fofexlolevbak .1
	set fofexhilevbak 1
	set fofexno ""
	set fofexno2bak 1
	set fofexno3bak 1
	set fofexno2 ""
	set fofexno3 ""
	set fofexnobak 1
	set fofexdb 0
	set fofextime 0
	set fofmode 0
	set lastfofmode 1
	set fofexnorm 0
	set fofexgain ""
	set fofexgainbak 1.0

	set fofcntfnam $evv(DFLT_OUTNAME)
	append fofcntfnam 0 $evv(TEXT_EXT)		;#	Info on FOF-segement length in input sndfile to "reconstruct"

	;#	No 1 is reserved for FOF-info file passed from "extract" to "reconstruct"

	set fofisocutsfile $evv(DFLT_OUTNAME)
	append fofisocutsfile 2 $evv(TEXT_EXT)	;#	Info on sndfile areas to exclude frrom FOF-extraction
	set fofpq $evv(DFLT_OUTNAME)
	append fofpq 3 $evv(TEXT_EXT)			;#	Quantised pitch-contour
	set fofpqs $evv(DFLT_OUTNAME)
	append fofpqs 4 $evv(TEXT_EXT)			;#	Quantised-and-sustained pitch-contour
	set fofpno $evv(DFLT_OUTNAME)
	append fofpno 5 $evv(TEXT_EXT)			;#	Quantised-and-sustained pitch-contour with ornaments removed
	set fofenvstac $evv(DFLT_OUTNAME)
	append fofenvstac 6 $evv(TEXT_EXT)		;#	Staccato loudness contour
	set fofenvexp $evv(DFLT_OUTNAME)
	append fofenvexp 7 $evv(TEXT_EXT)		;#	Exponential-decays loudness contour
	set foftstrpfnam $evv(DFLT_OUTNAME)
	append foftstrpfnam 8 $evv(TEXT_EXT)	;#	A time-stretched version of pitch-contour
	set foftstrefnam $evv(DFLT_OUTNAME)
	append foftstrefnam 9 $evv(TEXT_EXT)	;#	A time-stretched version of loudness-contour	

	set fofbank $evv(DFLT_OUTNAME)
	append fofbank 0 $evv(SNDFILE_EXT)		;#	Input (or recycled from extract) fofbank file
	set analfnam $evv(DFLT_OUTNAME)
;# 2023
	append analfnam 1 $evv(ANALFILE_OUT_EXT)		;#	Temporary analysis file, for pitch extraction (when no prior pitch info exists)
	set dumfnam $evv(DFLT_OUTNAME)
	append dumfnam 2 $evv(SNDFILE_EXT)		;#	Dummy extra outfile generated in pitch-extraction
	set fofconoutfnam $evv(DFLT_OUTNAME)
	append fofconoutfnam 3 $evv(SNDFILE_EXT)	;#	Output from FOF reconstruct
	set fofother $evv(DFLT_OUTNAME)
	append fofother 4 $evv(SNDFILE_EXT)		;#	Intermediate file where FOF-reconstruct needs to be re-enveloped

	catch {unset fofisocuts}

						;#	CHECK THE INPUT FILES
	if {$extract} {
		if {$extract == 2} {
			set msg "Select A Mono Soundfile\n"
			if {![info exists chlist] || ([llength $chlist] != 1)} {
				Inf $msg
				return
			}
		} else {
			set msg "Select\n\n"
			append msg "1) One Mono Soundfile\n"
			append msg "         And (Optionally)\n"
			append msg "2) A Textfile Listing Areas To Exclude From The FOF-Extraction (As Samplecount Pairs)\n\n"
			if {![info exists chlist] || ([llength $chlist] < 1) || ([llength $chlist] > 2)} {
				Inf $msg
				return
			}
		}
		set fnam [lindex $chlist 0]
		if {[llength $chlist] > 1} {
			set exfnam [lindex $chlist 1]
		}
		set ftyp $pa($fnam,$evv(FTYP))
		if {$ftyp != $evv(SNDFILE)} {
			if {[llength $chlist] > 1} {
				set temp $fnam
				set fnam $exfnam
				set exfnam $temp
				set ftyp $pa($fnam,$evv(FTYP))
				if {$ftyp != $evv(SNDFILE)} {
					Inf $msg
					return
				} 
			} else {
				Inf $msg
				return
			}
		}
		set chans $pa($fnam,$evv(CHANS))
		set srate $pa($fnam,$evv(SRATE))
		if {$chans != 1} {
			Inf "This Operation Only Works With Mono Soundfiles"
			return
		}
		if {[llength $chlist] > 1} {
			set ftyp $pa($exfnam,$evv(FTYP))
			if {!([IsABrkfile $ftyp] || [IsAListofNumbers $ftyp] || ($pa($exfnam,$evv(NUMSIZE)) != 2)) } {
				Inf "The 2nd File Must Be A Textfile Listing Areas To Exclude From The FOF-Extraction (As Samplecount Pairs)"
				return
			}
		}
		set fofexdur $pa($fnam,$evv(DUR))
	} else {
		set msg "Select\n\n"
		append msg "1) One Mono Soundfile Of Extracted FOFs\n"
		append msg "2) A Textfile Of Information About The Extracted-FOF Data\n"
		append msg "3) A Textfile Of Pitch Brkpnt Data\n"
		append msg "And Optionally\n"
		append msg "4) A Textfile Of Loudness Brkpnt Data\n\n"
		append msg "In That Order"
		if {![info exists chlist] || ([llength $chlist] < 3) || ([llength $chlist] > 4)} {
			Inf $msg
			return
		}
		set ifnam  [lindex $chlist 0]
		set iifnam [lindex $chlist 1]
		set fofpfnam  [lindex $chlist 2]
		if {[llength $chlist] > 3} {
			set fofefnam  [lindex $chlist 3]
		} else {
			set fofefnam 1			;#	PRODUCE UNENVELOPED OUTPUT
		}
		set ftyp $pa($ifnam,$evv(FTYP))
		if {$ftyp != $evv(SNDFILE)} {
			Inf $msg
			return
		}
		set chans $pa($ifnam,$evv(CHANS))
		if {$chans != 1} {
			Inf "This Operation Only Works With Mono, Extracted-FOF Soundfiles"
			return
		}
		set srate $pa($ifnam,$evv(SRATE))
		set nyquist [expr $srate / 2]
		if {![IsAListofNumbers $pa($iifnam,$evv(FTYP))]} {
			Inf "The 2nd File Must Be A Textfile Contain Information About The Extracted-FOFS File"
			return
		}
		if [catch {open $iifnam "r"} zit] {
			Inf "Cannot Open File '$iifnam' To Check Data"
			return
		}
		set cnt 0
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			set line [split $line]
			set position [lindex $line 0]
			set size [lindex $line end]
			if {$cnt > 0} {
				if {$position < $lastposition} {
					Inf "FOF Positions (column 1) Are Not Increasing In File '$iifnam'"
					close $zit
					return
				}
				if {$size >= $lastsize} {
					Inf "FOF Sizes (column 2) Are Not Decreasing In File '$iifnam'"
					close $zit
					return
				}
			} elseif {($position <= 0) || ($size <= 0)} {
				Inf "Invalid Values In File '$iifnam'"
				close $zit
				return
			}
			set lastposition $position
			set lastsize $size
			incr cnt
		}
		close $zit
		if {![IsABrkfile $pa($fofpfnam,$evv(FTYP))]} {
			Inf "The 3rd File Must Be A Textfile Of Pitch-Brkpnt Data"
			return
		}
		if {($pa($fofpfnam,$evv(MINBRK)) < -2) || ($pa($fofpfnam,$evv(MAXBRK)) >= $nyquist)} {
			Inf "Invalid Values In File '$fofpfnam'"
			return
		}
		if {[llength $chlist] > 3} {
			if {![IsABrkfile $pa($fofefnam,$evv(FTYP))]} {
				Inf "The 4th File Must Be A Textfile Of Loudness-Brkpnt Data"
				return
			}
			if {($pa($fofefnam,$evv(MINBRK)) < 0) || ($pa($fofefnam,$evv(MAXBRK)) > 1)} {
				Inf "Invalid Values In File '$fofefnam'"
				return
			}
		}
		if {![GetFofUnitlen $srate $ifnam $fofcntfnam]} {
			return
		}
		set fofbankfnam $ifnam

	}
	set fofexclude -1
	set pr_fofexclude -0
	set f .fofex
	if [Dlg_Create $f "" "set pr_fofex 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.1
		frame $f.2
		frame $f.3
		frame $f.4
		frame $f.5
		frame $f.6
		button $f.0.q -text "Quit" -command "set pr_fofex 0" -highlightbackground [option get . background {}]
		if {$extract && ([info exists exfnam] || ($extract == 2))} {
			button $f.0.x -text "Extract FOFs" -command "set pr_fofex 1" -bd 2 -highlightbackground [option get . background {}]
			button $f.0.ev -text "" -width 15 -bd 0 -command {} -highlightbackground [option get . background {}]
		} else {
			button $f.0.x -text "" -width 21 -bd 0 -command {} -highlightbackground [option get . background {}]
			button $f.0.ev -text "" -width 15 -bd 0 -command {} -highlightbackground [option get . background {}]
		}
		if {$extract} {
			if {$extract == 2} {
				button $f.0.help -text Help -command "FofexHelp 1" -bg $evv(HELP) -highlightbackground [option get . background {}]
			} else {
				button $f.0.help -text Help -command "FofexHelp 0" -bg $evv(HELP) -highlightbackground [option get . background {}]
			}
			button $f.0.p -text "" -width 11 -command {} -bd 0 -highlightbackground [option get . background {}]
			button $f.0.s -text "" -width 11 -command {} -bd 0 -highlightbackground [option get . background {}]
		} else {
			button $f.0.help -text Help -command "FofexHelp 2" -bg $evv(HELP) -highlightbackground [option get . background {}]
			button $f.0.p -text "Play Output" -command "set pr_fofex 6" -bd 2 -highlightbackground [option get . background {}]
			button $f.0.s -text "Save Output" -command "set pr_fofex 7" -bd 2 -highlightbackground [option get . background {}]
		}
		label $f.0.dbll -text "FOFs in Groups of " -width 18
		entry $f.0.dbl -textvariable fofdubl -width 3 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		checkbutton $f.0.win -text "No FOF windowing" -variable fofnotwin -width 16
		button $f.0.src -text "Play Src" -command FofGetPlaySrc -width 8 -highlightbackground [option get . background {}]
		if {$extract} {
			$f.0.src config -text "" -command {} -bd 0
		} else {
			$f.0.win config -text "" -state disabled
			$f.0.dbll config -text ""
			set fofdubl ""
			$f.0.dbl config -bd 0
		}
		button $f.0.sv -text "" -command {} -bd 0 -bg [option get . background {}] -highlightbackground [option get . background {}]
		pack $f.0.q $f.0.sv -side right -padx 6
		pack $f.0.help $f.0.x $f.0.ev $f.0.p $f.0.s $f.0.dbll $f.0.dbl $f.0.win $f.0.src -side left -padx 2
		if {$extract} {
			pack $f.0.win -side left -padx 2
		}
		pack $f.0.src -side left -padx 2
		pack $f.0 -side top -fill x -expand true
		if {$extract} {
			if {$extract == 1} {
				if {![info exists exfnam]} {
					radiobutton $f.1.r1 -variable fofexclude -text "set sections to exclude" -value 1 -command "set pr_fofex 3"
					radiobutton $f.1.r2 -variable fofexclude -text "no exclusions" -value 0 -command "set pr_fofex 3"
					pack $f.1.r2 $f.1.r1 -side right
				} else {
					label $f.1.dum -text "" -width 60
					pack $f.1.dum -side right
				}
				label $f.1.ll -text "min level to keep(dB) " -width 24
				entry $f.1.e -textvariable fofexdb -width 6 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			} else {
				label $f.1.dum -text "" -width 60
				pack $f.1.dum -side right
				label $f.1.ll -text "Time of FOF(group) " -width 24
				entry $f.1.e -textvariable fofextime -width 6 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			}
			pack $f.1.e $f.1.ll -side right
			button $f.1.savep -text "" -bd 0 -command {} -width 22 -highlightbackground [option get . background {}]
			button $f.1.savex -text "" -bd 0 -command {} -width 22 -highlightbackground [option get . background {}]
			button $f.1.saveo -text "" -bd 0 -command {} -width 22 -highlightbackground [option get . background {}]
			pack $f.1.saveo $f.1.savex $f.1.savep -side left
			pack $f.1 -side top -fill x -expand true -pady 3
		} else {
			button $f.1.savep -text "Save Contour Data" -bd 2 -command SaveCurrentFOFContourFiles -highlightbackground [option get . background {}]
			pack $f.1.savep -side left
			pack $f.1 -side top -fill x -expand true -pady 3
			$f.0.x config -text "Reconstruct with FOFs" -command "set pr_fofex 2" -bd 2
			$f.0.ev config -text "with every FOF" -command "set pr_fofex 10" -bd 2
		}
		checkbutton $f.2.n -text Equalise -variable fofexnorm -command FOFEqualisationGain
		label $f.2.ll -text "Overall Gain (0-1) " -width 19
		entry $f.2.e -textvariable fofexgain -width 4 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f.2.ll2 -text "FOF number "  -width 19
		entry $f.2.e2 -textvariable fofexno -width 4 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		pack $f.2.n $f.2.ll $f.2.e $f.2.ll2 $f.2.e2 -side left
		pack $f.2 -side top -fill x -expand true
		entry $f.3.e -textvariable fofexfnam -width 16
		label $f.3.ll -text "Outfile Name"
		label $f.3.dum -text "" -width 10
		label $f.3.fof2 -text "" -width 8
		entry $f.3.e2 -textvariable fofexno2 -width 4 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f.3.fof3 -text "" -width 8
		entry $f.3.e3 -textvariable fofexno3 -width 4 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f.3.minf -text "" -width 8
		entry $f.3.e4 -textvariable fofexlofrq -width 4 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f.3.maxf -text "" -width 8
		entry $f.3.e5 -textvariable fofexhifrq -width 4 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f.3.minl -text "" -width 8
		entry $f.3.e6 -textvariable fofexlolev -width 4 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		label $f.3.maxl -text "" -width 8
		entry $f.3.e7 -textvariable fofexhilev -width 8 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
		pack $f.3.e $f.3.ll $f.3.dum $f.3.fof2 $f.3.e2 $f.3.fof3 $f.3.e3 -side left -padx 3 -pady 3
		pack $f.3.minf $f.3.e4 $f.3.maxf $f.3.e5 $f.3.minl $f.3.e6 $f.3.maxl $f.3.e7 -side left -padx 3 -pady 3
		pack $f.3 -side top -fill x -expand true
		radiobutton $f.4.1 -variable fofmode -text "1 FOF" -value 1 -command "FofMode" -width 4
		radiobutton $f.4.2 -variable fofmode -text "All" -value 2 -command "FofMode" -width 3
		radiobutton $f.4.3 -variable fofmode -text "All Lo" -value 3 -command "FofMode" -width 6
		radiobutton $f.4.4 -variable fofmode -text "All Mid" -value 4 -command "FofMode" -width 7
		radiobutton $f.4.5 -variable fofmode -text "All Hi" -value 5 -command "FofMode" -width 6
		radiobutton $f.4.6 -variable fofmode -text "2 FOFs pitchvary" -value 6 -command "FofMode" -width 17
		radiobutton $f.4.7 -variable fofmode -text "3 FOFs pch+level vary" -value 7 -command "FofMode" -width 21
		pack $f.4.1 $f.4.2 $f.4.3 $f.4.4 $f.4.5 $f.4.6 $f.4.7 -side left
		pack $f.4 -side top
		label $f.4a -text ""	-fg $evv(SPECIAL)
		pack $f.4a -side top
		frame $f.5.1
		frame $f.5.2
		label $f.5.1.1 -text ""	-fg $evv(SPECIAL)
		label $f.5.1.2 -text ""	-fg $evv(SPECIAL)
		label $f.5.1.3 -text ""	-fg $evv(SPECIAL)
		label $f.5.1.4 -text ""
		pack $f.5.1.1 -side top -anchor w
		pack $f.5.1.2 -side top -anchor w
		pack $f.5.1.3 -side top -anchor w
		pack $f.5.1.4 -side top -anchor w
		label $f.5.2.1 -text ""	-fg $evv(SPECIAL)
		label $f.5.2.2 -text ""	-fg $evv(SPECIAL)
		label $f.5.2.3 -text "" -fg $evv(SPECIAL)
		label $f.5.2.4 -text ""	-fg $evv(SPECIAL)
		pack $f.5.2.1 -side top -anchor w
		pack $f.5.2.2 -side top -anchor w
		pack $f.5.2.3 -side top -anchor w
		pack $f.5.2.4 -side top -anchor w
		pack $f.5.1 $f.5.2 -side left
		pack $f.5 -side top
		if {$extract} {
			$f.5.1.1 config -text "Group count : Right/Left Arrows"
			if {$extract == 2} {
				$f.5.2.1 config -text "Time +- 1.0     : Up/Down Arrows"
				$f.5.2.2 config -text "Time +- 0.1     : Shift Up/Down Arrows"
				$f.5.2.3 config -text "Time +- 0.01   : Control Up/Down Arrows"
				$f.5.2.4 config -text "Time +- 0.001 : Command Up/Down Arrows"
			} else {
				$f.5.1.2 config -text "Level in dBs  : Up/Down Arrows"
			}
			label $f.6.00 -text "" -anchor w
			label $f.6.0 -text "" -anchor w
			frame $f.6.1
			radiobutton $f.6.1.g -variable fofenvget -text "" -value 1 -command {} -width 13 -anchor w -state disabled
			label $f.6.1.c -text ""
			pack $f.6.1.g $f.6.1.c -side left
			frame $f.6.2
			radiobutton $f.6.2.g -variable fofenvget -text "" -value 2 -command {} -width 17 -anchor w -state disabled
			radiobutton $f.6.2.s -variable fofenvset -text "" -value 2 -command {} -state disabled
			pack $f.6.2.g $f.6.2.s -side left
			frame $f.6.3
			radiobutton $f.6.3.g -variable fofenvget -text "" -value 2 -command {} -width 17 -anchor w -state disabled
			radiobutton $f.6.3.s -variable fofenvset -text "" -value 3 -command {} -state disabled
			label $f.6.3.ll -text ""
			entry $f.6.3.e -textvariable fofpadj -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			pack $f.6.3.g $f.6.3.s $f.6.3.e $f.6.3.ll -side left
			frame $f.6.4
			radiobutton $f.6.4.g -variable fofenvget -text "" -value 4 -command {} -width 17 -anchor w -state disabled
			radiobutton $f.6.4.s -variable fofenvset -text "" -value 4 -command {} -state disabled
			label $f.6.4.ll -text "  "
			entry $f.6.4.e -textvariable foforndur -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			pack $f.6.4.g $f.6.4.s $f.6.4.e $f.6.4.ll -side left
			frame $f.6.5
			radiobutton $f.6.5.g -variable fofenvget -text "" -value 5 -command {} -width 17 -anchor w -state disabled
			radiobutton $f.6.5.s -variable fofenvset -text "" -value 5 -command {} -state disabled
			label $f.6.5.ll -text ""
			entry $f.6.5.e -textvariable fofstacdur -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			pack $f.6.5.g $f.6.5.s $f.6.5.e $f.6.5.ll -side left
			frame $f.6.6
			radiobutton $f.6.6.g -variable fofenvget -text "" -value 6 -command {} -width 17 -anchor w -state disabled
			radiobutton $f.6.6.s -variable fofenvset -text "" -value 6 -command {} -state disabled
			label $f.6.6.ll -text "  Decay Exponent"
			entry $f.6.6.e -textvariable fofdecexp -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			pack $f.6.6.g $f.6.6.s $f.6.6.e $f.6.6.ll -side left
			frame $f.6.7
			radiobutton $f.6.7.g -variable fofenvget -text "" -value 7 -command {} -width 17 -anchor w -state disabled
			radiobutton $f.6.7.s -variable fofenvset -text "" -value 7 -command {} -state disabled
			label $f.6.7.ll -text "" -width 17 -anchor w
			entry $f.6.7.e -textvariable foftw -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			label $f.6.7.ll2 -text "" -width 19 -anchor w
			entry $f.6.7.e2 -textvariable foftworn -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			label $f.6.7.ll3 -text "" -width 14 -anchor w
			entry $f.6.7.e3 -textvariable foftwq -width 6 -bd 0 -state readonly -fg $readonlyfg -readonlybackground $readonlybg
			pack $f.6.7.g $f.6.7.s $f.6.7.e $f.6.7.ll $f.6.7.e2 $f.6.7.ll2  $f.6.7.e3 $f.6.7.ll3 -side left
		} else {
			set fofenvget 1
			$f.4a config -text "GAIN  Up/Down Arrows : Shift Up/Down for small increments"
			label $f.6.00 -text "PITCH/LOUDNESS CONTOUR" -anchor w
			label $f.6.0 -text "REVERT TO" -anchor w
			frame $f.6.1
			radiobutton $f.6.1.g -variable fofenvget -text "Original" -value 1 -command "FofGetEnv" -width 13 -anchor w
			label $f.6.1.c -text "CONVERT TO"
			pack $f.6.1.g $f.6.1.c -side left
			frame $f.6.2
			radiobutton $f.6.2.g -variable fofenvget -text "Quantised" -value 2 -command "FofGetEnv" -width 17 -anchor w
			radiobutton $f.6.2.s -variable fofenvset -text "" -value 2 -command "FofModifyEnv"
			pack $f.6.2.g $f.6.2.s -side left
			frame $f.6.3
			radiobutton $f.6.3.g -variable fofenvget -text "Quantised+Sustain" -value 2 -command "FofGetEnv" -width 17 -anchor w
			radiobutton $f.6.3.s -variable fofenvset -text "" -value 3 -command "FofModifyEnv"
			label $f.6.3.ll -text "  Pitch Adjust (semitones)"
			entry $f.6.3.e -textvariable fofpadj -width 6
			pack $f.6.3.g $f.6.3.s $f.6.3.e $f.6.3.ll -side left
			frame $f.6.4
			radiobutton $f.6.4.g -variable fofenvget -text "Ornaments Removed" -value 4 -command "FofGetEnv" -width 17 -anchor w
			radiobutton $f.6.4.s -variable fofenvset -text "" -value 4 -command "FofModifyEnv"
			label $f.6.4.ll -text "  Max Ornament Dur"
			entry $f.6.4.e -textvariable foforndur -width 6
			pack $f.6.4.g $f.6.4.s $f.6.4.e $f.6.4.ll -side left
			frame $f.6.5
			radiobutton $f.6.5.g -variable fofenvget -text "Staccato" -value 5 -command "FofGetEnv" -width 17 -anchor w
			radiobutton $f.6.5.s -variable fofenvset -text "" -value 5 -command "FofModifyEnv"
			label $f.6.5.ll -text "  Max Staccato Dur"
			entry $f.6.5.e -textvariable fofstacdur -width 6
			pack $f.6.5.g $f.6.5.s $f.6.5.e $f.6.5.ll -side left
			frame $f.6.6
			radiobutton $f.6.6.g -variable fofenvget -text "With Decay" -value 6 -command "FofGetEnv" -width 17 -anchor w
			radiobutton $f.6.6.s -variable fofenvset -text "" -value 6 -command "FofModifyEnv"
			label $f.6.6.ll -text "  Decay Exponent"
			entry $f.6.6.e -textvariable fofdecexp -width 6
			pack $f.6.6.g $f.6.6.s $f.6.6.e $f.6.6.ll -side left
			frame $f.6.7
			radiobutton $f.6.7.g -variable fofenvget -text "Time Warp" -value 7 -command "FofGetEnv" -width 17 -anchor w
			radiobutton $f.6.7.s -variable fofenvset -text "" -value 7 -command "FofModifyEnv"
			label $f.6.7.ll -text "Warp Factor  " -width 17 -anchor w
			entry $f.6.7.e -textvariable foftw -width 6
			label $f.6.7.ll2 -text "Max Ornament Size  " -width 19 -anchor w
			entry $f.6.7.e2 -textvariable foftworn -width 6
			label $f.6.7.ll3 -text "Quantise Time " -width 14 -anchor w
			entry $f.6.7.e3 -textvariable foftwq -width 6
			pack $f.6.7.g $f.6.7.s $f.6.7.e $f.6.7.ll $f.6.7.e2 $f.6.7.ll2  $f.6.7.e3 $f.6.7.ll3 -side left
		}
		pack $f.6.00 $f.6.0 $f.6.1 $f.6.2 $f.6.3 $f.6.4 $f.6.5 $f.6.6 $f.6.7 -side top -fill x -expand true

		pack $f.6 -side top -fill both -expand true

		wm resizable $f 1 1
		bind $f <Escape> {set pr_fofex 0}
	}
	if {$extract} {
		wm title $f "EXTRACT FOFS FOR RECONSTRUCTION FROM FILE '[file rootname [file tail $fnam]]'"
		$f.2.n config -text "" -state disabled
		$f.2.ll config -text ""
		$f.2.e config -bd 0
		$f.2.ll2 config -text ""
		$f.2.e2 config -bd 0
		$f.4.1 config -text "" -state disabled
		$f.4.2 config -text "" -state disabled
		$f.4.3 config -text "" -state disabled
		$f.4.4 config -text "" -state disabled
		$f.4.5 config -text "" -state disabled
		$f.4.6 config -text "" -state disabled
		$f.4.7 config -text "" -state disabled
		if {$extract == 2} {
			bind $f <Up> {FofexTime 0 0}
			bind $f <Down> {FofexTime 1 0}
			bind $f <Shift-Up> {FofexTime 0 1}
			bind $f <Shift-Down> {FofexTime 1 1}
			bind $f <Control-Up> {FofexTime 0 2}
			bind $f <Control-Down> {FofexTime 1 2}
			bind $f <Command-Up> {FofexTime 0 3}
			bind $f <Command-Down> {FofexTime 1 3}
		} else {
			bind $f <Up> {FofexDb 0}
			bind $f <Down> {FofexDb 1}
		}
		bind $f <Right> {FofGrouping 0}
		bind $f <Left> {FofGrouping 1}
	} else {
		wm title $f "RECONSTRUCTION SOUND FROM FOFS '[file rootname [file tail $ifnam]]'"
		set fofexgain $fofexgainbak
		set fofexdb ""
		set fofextime ""
		bind $f <Up> {FofexGain 0 0}
		bind $f <Down> {FofexGain 1 0}
		bind $f <Shift-Up> {FofexGain 0 1}
		bind $f <Shift-Down> {FofexGain 1 1}
		set fofexno $fofexnobak
		set fofpo $fofpfnam						;#	Store names of original contour files
		set fofeo $fofefnam
		set foforndur $evv(FOFEX_ORNDUR)		;#	Set default vals for envelope modifiers
		set foftworn  $evv(FOFEX_ORNDUR)
		set fofpadj 0.0
		set fofstacdur $evv(FOFEX_STACDUR)
		set fofdecexp $evv(FOFEX_DECEXP)
		set foftw $evv(FOFEX_TW)
		set foftwq $evv(FOFEX_TWQ)
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0

	set fofexfnam ""
	set pr_fofex 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_fofex
	set finished 0
	while {!$finished} {
		tkwait variable pr_fofex
		switch -- $pr_fofex {
			0 {
				set finished 1
			}
			1 {				;#	FOF EXTRACTION

				$f.0.x config -bg [option get . background {}]
				$f.0.ev config -bg [option get . background {}]
				DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
				set fofpfnam [file rootname $fnam]
				append fofpfnam $evv(FREQ_TAG) [GetTextfileExtension brk]

							;#	IF AN APPROPRIATE PITCHDATA FILE DOES NOT EXIST, EXTRACT PITCH DATA, AND SAVE IT

				Block "Extracting FOFs"	
				catch {unset last_outfile_x}
				if {![file exists $fofpfnam]} {
					set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
					lappend cmd anal 1 $fnam $analfnam -c1024 -o3
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Create Analysis File For '[file rootname [file tail $fnam]]': $CDPidrun"
						catch {unset CDPidrun}
						continue
						UnBlock
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Create Analysis File For '[file rootname [file tail $fnam]]'"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) repitch]
					lappend cmd getpitch 2 $analfnam $dumfnam $fofpfnam -t1 -g2 -s80 -n5 -l30 -h2756 -d.25
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Get Pitch From Analysis File $analfnam: $CDPidrun"
						catch {unset CDPidrun}
						UnBlock
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Get Pitch From Analysis File $analfnam: $CDPidrun"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						catch {file delete $fofpfnam}
						UnBlock
						break
					}
					if {[FileToWkspace $fofpfnam 0 0 0 0 1] > 0} {
						lappend last_outfile_x $fofpfnam
					}
				}
				set fofefnam [file rootname $fnam]
				append fofefnam $evv(ENV_TAG) [GetTextfileExtension brk]

							;#	IF AN APPROPRIATE ENVELOPE FILE DOES NOT EXIST, EXTRACT ENVELOPE DATA, AND SAVE IT

				if {![file exists $fofefnam]} {
					set cmd [file join $evv(CDPROGRAM_DIR) envel]
					lappend cmd extract 2 $fnam $fofefnam 50 -d0.0002
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Extract Loudness Contour From File '[file rootname [file tail $fnam]]': $CDPidrun"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Extract Loudness Contour From File '[file rootname [file tail $fnam]]'"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						break
					}
					if {[FileToWkspace $fofefnam 0 0 0 0 1] > 0} {
						lappend last_outfile_x $fofefnam
					}
				}
							;#	IF WE HAVE SELECTED FOF-EXCLUSION-ZONES FROM SOUND VIEW
							;#	(OR HAVE PREVIOUSLY DONE THIS IN THIS CURRENT-USE OF THE DIALOGUE-BOX)
							;#	SAVE THESE TO A TEMPORARY FILE AND USE THEM IN THE FOF-EXTRACT PROCESS

				if {[info exists fofisocuts]} {
					set fofisocuts [FofisocutSort $fofisocuts]
					if [catch {open $fofisocutsfile "w"} zit] {
						Inf "Cannot Open Temporary File '$fofisocutsfile' To Write FOF-Exclusion Areas Data"
						UnBlock
						break
					}
					foreach line $fofisocuts {
						puts $zit $line				
					}
					close $zit
					set cmd [file join $evv(CDPROGRAM_DIR) fofex]
					lappend cmd extract 1 $fnam $fofbank $fofisocutsfile $fofpfnam $fofexdb $fofdubl

				} else {	;#	IF WE HAVE NOT DEFINED FOF-EXCLUSION ZONES WITH SOUND VIEW, WE MAY EITHER NOT WANT THEM
							;#	OR WE HAVE ENTERED THIS DATA AS A TEXTFILE ON CHOSEN FILES LIST (exfnam).
							;#	DO THE FOF EXTRACTION IN EITHER CASE

					set cmd [file join $evv(CDPROGRAM_DIR) fofex]
					if {[info exists exfnam]} {
						lappend cmd extract 1 $fnam $fofbank $exfnam $fofpfnam $fofexdb $fofdubl
					} else {
						if {$extract == 2} {
							lappend cmd extract 2 $fnam $fofbank $fofpfnam $fofextime $fofdubl
						} else {
							lappend cmd extract 1 $fnam $fofbank 0 $fofpfnam $fofexdb $fofdubl
						}
					}
				}
				if {$fofnotwin} {
					lappend cmd -w
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Extract FOFS From File '[file rootname [file tail $fnam]]': $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Extract FOFS From File '[file rootname [file tail $fnam]]'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					break
				}
				if {[info exists last_outfile_x]} {
					set last_outfile $last_outfile_x
				}
				UnBlock
						;#	REFORM THE WINDOW TO PERMIT IMMEDIATE USE OF 'RECONSTRUCT'

				$f.0.x config -text "Reconstruct with FOFs" -command "set pr_fofex 2" -bd 2 -bg $evv(EMPH)
				$f.0.ev config -text "with every FOF" -command "set pr_fofex 10" -bd 2 -bg $evv(EMPH)
				$f.0.sv config -text "" -command {} -bd 0 -bg [option get . background {}]
				$f.1.savep config -text "Save Contour Data" -bd 2 -command SaveCurrentFOFContourFiles
				$f.1.saveo config -text "Save Extraction Output" -bd 2 -command "set pr_fofex 4"
				$f.1.savex config -text "Save Exclude-Area Data" -bd 2 -command "set pr_fofex 5"
				$f.1.ll config -text ""
				$f.1.e config -bd 0
				catch {$f.1.r1 config -text "" -state disabled}
				catch {$f.1.r2 config -text "" -state disabled}
				$f.2.n config -text "Equalise FOF levels" -state normal
				$f.2.ll config -text "Overall Gain (0-1) "
				$f.2.e config -bd 2
				$f.2.ll2 config -text "FOF number "
				$f.2.e2 config -bd 2
				bind $f <Up> {}
				bind $f <Down> {}
				bind $f <Shift-Up> {}
				bind $f <Shift-Down> {}
				bind $f <Control-Up> {}
				bind $f <Control-Down> {}
				bind $f <Command-Up> {}
				bind $f <Command-Down> {}
				bind $f <Right> {}
				bind $f <Left> {}
				bind $f <Up> {FofexGain 0 0}
				bind $f <Down> {FofexGain 1 0}
				bind $f <Shift-Up> {FofexGain 0 1}
				bind $f <Shift-Down> {FofexGain 1 1}
				$f.5.1.2 config -text ""
				$f.5.2.1 config -text ""
				$f.5.2.2 config -text ""
				$f.5.2.3 config -text ""
				$f.5.2.4 config -text ""
				if {$extract == 1} {
					$f.4.1 config -text "1 FOF"    -state normal
					$f.4.2 config -text "All"      -state normal
					$f.4.3 config -text "All Low"  -state normal
					$f.4.4 config -text "All Mid"  -state normal
					$f.4.5 config -text "All Hi" -state normal
					$f.4.6 config -text "2 FOFs pitchvary" -state normal
					$f.4.7 config -text "3 FOFs pch+level vary" -state normal
					$f.5.1.1 config -text ""
				} else {
					set fofmode 1
					.fofex.5.1.1 config -text "FOF1  Right/Left Arrows"
					.fofex.2.ll2 config -text "FOF number"  
					.fofex.2.e2 config -bd 2
					set fofexno $fofexnobak
					bind .fofex <Right> {}
					bind .fofex <Left> {}
					bind .fofex <Right> {FofexNo 0 0}
					bind .fofex <Left> {FofexNo 1 0}
				}
				$f.6.00 config -text "PITCH/LOUDNESS CONTOUR"
				$f.6.0 config -text "REVERT TO"
				$f.6.1.g config -text "Original" -command "FofGetEnv" -state normal
				$f.6.1.c config -text "CONVERT TO"
				$f.6.2.g config -text "Quantised" -command "FofGetEnv" -state normal
				$f.6.2.s config -text "" -command "FofModifyEnv" -state normal
				$f.6.3.g config -text "Quantised+Sustain" -command "FofGetEnv" -state normal
				$f.6.3.s config -command "FofModifyEnv" -state normal
				$f.6.3.ll config -text "  Pitch Adjust (semitones)"
				$f.6.3.e config -bd 2
				$f.6.4.g config -text "Ornaments Removed" -command "FofGetEnv" -state normal
				$f.6.4.s config -text "" -command "FofModifyEnv" -state normal
				$f.6.4.ll config -text "  Max Ornament Dur"
				$f.6.4.e config -bd 2
				$f.6.5.g config -text "Staccato" -command "FofGetEnv" -state normal
				$f.6.5.s config -text "" -command "FofModifyEnv" -state normal
				$f.6.5.ll config -text "  Max Staccato Dur"
				$f.6.5.e config -bd 2
				$f.6.6.g config -text "With Decay" -command "FofGetEnv" -state normal
				$f.6.6.s config -text "" -command "FofModifyEnv" -state normal
				$f.6.6.ll config -text "  Decay Exponent"
				$f.6.6.e config -bd 2
				$f.6.7.g config -text "Time Warp" -command "FofGetEnv" -state normal
				$f.6.7.s config -text "" -command "FofModifyEnv" -state normal
				$f.6.7.ll config -text "Warp Factor  "
				$f.6.7.e config -bd 2
				$f.6.7.ll2 config -text "Max Ornament Size  "
				$f.6.7.e2 config -bd 2
				$f.6.7.ll3 config -text "Quantise Time "
				$f.6.7.e3 config -bd 2
				$f.4a config -text "GAIN  Up/Down Arrows : Shift Up/Down for small increments"
				$f.0.src config -text "Play Src" -command FofGetPlaySrc -bd 2
				set fofsrc $fnam
				set fofenvget 1
				set foforndur $evv(FOFEX_ORNDUR)		;#	Set default vals for envelope modifiers
				set foftworn  $evv(FOFEX_ORNDUR)
				set fofpadj 0.0
				set fofstacdur $evv(FOFEX_STACDUR)
				set fofdecexp $evv(FOFEX_DECEXP)
				set foftw $evv(FOFEX_TW)
				set foftwq $evv(FOFEX_TWQ)
				set fofexdb ""
				set fofextime ""
				set fofexgain $fofexgainbak
				set ifnam $fofbank					;#	SETS UP INPUT SNDFILE FOR "reconstruct", if it is to be used.
				set fofbankfnam $ifnam				;#	SETS UP GLOBAL NAME ACCESSED BY FofMode
				set iifnam $evv(DFLT_OUTNAME)
				append iifnam 1 $evv(TEXT_EXT)

				set fofpo $fofpfnam	;#	Store names of original contour files
				set fofeo $fofefnam

				$f.0.help config -command "FofexHelp 3"
				$f.0.p config -text "Play Output" -command "set pr_fofex 6" -bd 2
				$f.0.s config -text "Save Output" -command "set pr_fofex 7" -bd 2

				set fofdubl ""
				$f.0.dbll config -text ""
				$f.0.dbl config -bd 0
				set fofnotwin 0
				$f.0.win config -text "" -state disabled

				;#	GET FOFUNITLEN

				if {[DoParse $ifnam 0 0 0] <= 0} {
					UnBlock 
					set msg "\nFailed To Get Properties Of Output FOFbank File."
					append msg "\nThese Are Needed If You Want To Utilise The FOFBank Now, And You Need The \"Sound View\" Option."
					append msg "\n\nContinue Anyway ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						break
					}
				} else {				
					if {![GetFofUnitlen $srate $ifnam $fofcntfnam]} {
						break
					}
				}
			}
			2 {
					;#	RECONSTRUCT SOUND FROM PITCH-(TEXT)-DATA AND FOF-BANK

				set keeplist [list $ifnam $iifnam $fofpfnam $fofefnam $fofeo $fofpo $fofpq $fofpqs $fofpno $fofenvstac $fofenvexp $foftstrpfnam $foftstrefnam $fofother]
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $keeplist
				Block "Constructing with FOFs"	
				set cmd [file join $evv(CDPROGRAM_DIR) fofex]
				switch -- $fofmode {
					1 {
						lappend cmd construct $fofmode $ifnam $fofconoutfnam $iifnam $fofpfnam $fofefnam $fofexgain $fofexno
					}
					2 -
					3 -
					4 -
					5 {
						lappend cmd construct $fofmode $ifnam $fofconoutfnam $iifnam $fofpfnam $fofefnam $fofexgain
					}
					6 {
						lappend cmd construct $fofmode $ifnam $fofconoutfnam $iifnam $fofpfnam $fofefnam $fofexgain
						lappend cmd $fofexno $fofexno2 $fofexlofrq $fofexhifrq 
					}
					7 {
						lappend cmd construct $fofmode $ifnam $fofconoutfnam $iifnam $fofpfnam $fofefnam $fofexgain
						lappend cmd $fofexno $fofexno2 $fofexno3 $fofexlofrq $fofexhifrq $fofexlolev $fofexhilev
					}
					default {
						Inf "NO MODE SET"
						UnBlock
						continue
					}
				}
				if {$fofmode != 1} {
					if {$fofexnorm} {
						lappend cmd -n
					} 
				}
				set prg_dun 0
				set prg_abortd 0
				catch {unset fofmaxsamp}
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Reconstruct Sound With FOFs: $CDPidrun"
					catch {unset CDPidrun}
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except $keeplist
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyMaxsampDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Reconstruct Sound With FOFs"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except $keeplist
				}
				if {[info exists fofmaxsamp] && ($fofmaxsamp > 1.0)} {
					set fofexgain [expr ($fofexgain / $fofmaxsamp) - 0.05]
					Inf "Too Loud: Rerun With Newly Set Gain"
					UnBlock
					continue
				}
				if {[string match $fofefnam $fofenvstac] || [string match $fofefnam $fofenvexp]} {
					if {![string match $fofeo 1]} {

						;#	WHERE A STACCATO OR DECAY ENVELOPE HAS BEEN APPLIED, NOW APPLY THE CONTOUR ENVELOPE

						if {[file exists $fofother]} {
							if [catch {file delete $fofother} zit] {
								ErrShow "Failed To Apply Input-Contour To Staccato Or Decay-Enveloped File"
								UnBlock
								continue
							}			
						}
						if [catch {file rename $fofconoutfnam $fofother} zit] {
							ErrShow "Failed To Apply Input-Contour To Staccato Or Decay-Enveloped File"
							UnBlock
							continue
						}			
						set cmd [file join $evv(CDPROGRAM_DIR) envel]
						lappend cmd impose 3 $fofother $fofeo $fofconoutfnam
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							catch {unset CDPidrun}
							ErrShow "Failed To Apply Input-Contour To Staccato Or Decay-Enveloped File"
							catch {file rename $fofother $fofconoutfnam}
							DeleteAllTemporaryFilesWhichAreNotCDPOutput except $keeplist
							UnBlock
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Apply Input-Contour To Staccato Or Decay-Enveloped File"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							catch {file delete $fofconoutfnam}
							catch {file rename $fofother $fofconoutfnam}
							DeleteAllTemporaryFilesWhichAreNotCDPOutput except $keeplist
						}
					}
				}
				UnBlock
				continue
			}
			3 {		;#	SET UP EXTRACT-FOFS BUTTON AND (POSSIBLY) "SOUND VIEW" BUTTON

				if {$fofexclude} {
					catch {unset fofisocuts}
					$f.0.sv config -text "Sound View" -command "SnackDisplay $evv(SN_TIMEPAIRS) fofisolate 0 $fnam" -bd 2 -bg $evv(SNCOLOR)
				} else {
					$f.0.sv config -text "" -command {} -bd 0 -bg [option get . background {}]
				}
				$f.0.x config -text "Extract FOFs" -command "set pr_fofex 1" -bd 2
				$f.0.ev config -text "" -command {} -bd 0
			}
			4 {		;#	SAVE FOF-BANK AND FOF-BANK DATA-FILE

				if {[string length $fofexfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fofexfnam]} {
					continue
				}
				set outfnam  [string tolower $fofexfnam]
				set outfnam1 $outfnam
				set outfnam2 $outfnam
				append outfnam1 $evv(SNDFILE_EXT)
				append outfnam2 $evv(TEXT_EXT)
				if {[file exists $outfnam1] || [file exists $outfnam2]} {
					Inf "One Or Both Of Files '$outfnam1' And '$outfnam2' Already Exists.\n\nChoose A Different Name"
					continue
				}
				if [catch {file rename $ifnam $outfnam1} zit] {
					set msg "Cannot Rename Temporary File '$ifnam' To '$outfnam1'\n\n"
					append msg "Do This Now, Outside The Loom, Before Closing This Dialog Box"
					Inf $msg
				}
				if [catch {file rename $iifnam $outfnam2} zit] {
					set msg "Cannot Rename Temporary File '$iifnam' To '$outfnam2'\n\n"
					append msg "Do This Now, Outside The Loom, Before Closing This Dialog Box"
					Inf $msg
				}
				set ifnam $outfnam1		;#	SET UP THE FILES FOR POSSIBLE INPUT TO 'reconstruct'
				set iifnam $outfnam2
				catch {unset last_outfile}
				if {[FileToWkspace $outfnam2 0 0 0 0 1] > 0} {
					Inf "File '$outfnam2' Is On The Workspace"
					lappend last_outfile $outfnam2
				}
				if {[FileToWkspace $outfnam1 0 0 0 0 1] > 0} {
					Inf "File '$outfnam1' Is On The Workspace"
					lappend last_outfile $outfnam1
				}
			}		
			5 {		;#	SAVES FOF-EXCLUSION-ZONES FILE

				if {[string length $fofexfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fofexfnam]} {
					continue
				}
				set outfnam [string tolower $fofexfnam]
				append outfnam $evv(TEXT_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Already Exists.\n\nChoose A Different Name"
					continue
				}
				if [catch {file rename $fofisocutsfile $outfnam} zit] {
					set msg "Cannot Rename Temporary File '$fofisocutsfile' To '$outfnam'\n\n"
					append msg "If You Need To Retain This Information\nRename This File Now, Outside The Loom, Before Closing This Dialog Box"
					Inf $msg
				}
				set exfnam $outfnam				;#	REPLACE DATA FROM SOUNDVIEW
				catch {unset fofisocuts}		;#	BY FILE TO WHICH IT HAS BEEN WRITTEN, IN CASE THERE'S ANOTHER PASS OF 'EXTRACT'
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
			}
			6 {		;#	PLAY FOF-CONSTRUCT OUTPUT

				if {![file exists $fofconoutfnam]} {
					Inf "No Output File To Play"
					continue
				}
				PlaySndfile $fofconoutfnam 0
			}
			7 {		;#	SAVE FOF-CONSTRUCT OUTPUT

				if {![file exists $fofconoutfnam]} {
					Inf "No Output File To Save"
					continue
				}
				if {[string length $fofexfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fofexfnam]} {
					continue
				}
				set outfnam  [string tolower $fofexfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					set msg "File '$outfnam' Already Exists. Overwrite It?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					set i [LstIndx $outfnam $wl]
					set blist_change 0
					if {![DeleteFileFromSystem $outfnam 0 1]} {
						Inf "Cannot Delete Existing File '$outfnam'"
						continue
					} else {
						DummyHistory $outfnam "DESTROYED"
						if {[IsInAMixfile $outfnam]} {
							if {[MixM_ManagedDeletion $outfnam]} {
								MixMStore
							}
						}
						if {$blist_change} {
							SaveBL $background_listing
						}
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				if [catch {file rename $fofconoutfnam $outfnam} zit] {
					Inf "Cannot Rename The Output File"
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
			}
			10 {
				if {[string length $fofexfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fofexfnam]} {
					continue
				}
				set generic_outfnam [string tolower $fofexfnam]
				set k 1
				set OK 1
				while {$k <= $fofunitcnt} {
					set outfnam $generic_outfnam
					append outfnam "_fof_" $k
					append outfnam $evv(SNDFILE_EXT)
					if {[file exists $outfnam]} {
						Inf "Some Files With This Generic Outname Already Exist : Choose A Different Name"
						set OK 0
						break
					}
					incr k
				}
				if {!$OK} {
					continue
				}
				set orig_fofmode $fofmode
				set fofmode 1

					;#	RECONSTRUCT SOUND FROM PITCH-(TEXT)-DATA AND FOF-BANK FOR EVERY FOF

				set msg "There Are $fofunitcnt FOFs : This May Take Some Time : Are You Sure You Want To Proceed ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set keeplist [list $ifnam $iifnam $fofpfnam $fofefnam $fofeo $fofpo $fofpq $fofpqs $fofpno $fofenvstac $fofenvexp $foftstrpfnam $foftstrefnam $fofother]
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $keeplist
				
				set fofex_origgain $fofexgain
				set k 1
				set j 5
				set badouts {}
				set badreconstrs {}
				catch {unset badenvs}
				Block "Constructing with FOFS"	
				while {$k <= $fofunitcnt} {
					catch {unset CDPidrun}
					set OK 0
					set fofexgain $fofex_origgain
					set runcnt 0
					wm title .blocker "Constructing with FOF $k"	
					set fofmultifnam $evv(DFLT_OUTNAME)
					append fofmultifnam $j $evv(SNDFILE_EXT)	;#	Output from FOF reconstruct
					incr j
					while {!$OK} {
						if {$runcnt > 1} {
							lappend badouts $k
							set OK -1
							break
						}
						set cmd [file join $evv(CDPROGRAM_DIR) fofex]
						lappend cmd construct $fofmode $ifnam $fofmultifnam $iifnam $fofpfnam $fofefnam $fofexgain $k
						set prg_dun 0
						set prg_abortd 0
						catch {unset fofmaxsamp}
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							lappend badreconstrs $k
							catch {unset CDPidrun}
							set OK -1
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyMaxsampDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							lappend badreconstrs $k
							set OK -1
							break
						}
						if {[info exists fofmaxsamp] && ($fofmaxsamp > 1.0)} {
							set fofexgain [expr ($fofexgain / $fofmaxsamp) - 0.05]
							if [catch {file delete $fofmultifnam} zit] {
								lappend badouts $k
								set OK -1
								break
							}
						} else {
							set OK 1
						}
						incr runcnt
					}
					if {$OK < 0} {
						incr k
						continue
					}
					if {[string match $fofefnam $fofenvstac] || [string match $fofefnam $fofenvexp]} {
						if {![string match $fofeo 1]} {

							;#	WHERE A STACCATO OR DECAY ENVELOPE HAS BEEN APPLIED, NOW APPLY THE CONTOUR ENVELOPE

							if {[file exists $fofother]} {
								if [catch {file delete $fofother} zit] {
									Inf "Cannot Delete Intermedate Temporary File '$fofother' : Cannot Envelope Further Fof Files"
									while {$k <= $fofunitcnt} {
										lappend badenvs $k
										incr k
									}
									break
								}			
							}
							if [catch {file rename $fofmultifnam $fofother} zit] {
								lappend badenvs $k
								incr k
								continue
							}			
							set cmd [file join $evv(CDPROGRAM_DIR) envel]
							lappend cmd impose 3 $fofother $fofeo $fofmultifnam
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							if [catch {open "|$cmd"} CDPidrun] {
								catch {unset CDPidrun}
								if [catch {file rename $fofother $fofmultifnam} zit] {
									lappend badouts $k
								} else {
									lappend badenvs $k
								}
								incr k
								continue
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								catch {file delete $fofmultifnam}
								if [catch {file rename $fofother $fofmultifnam} zit] {
									lappend badouts $k	
								}
							}
						}
					}
					incr k
				}

				if {[llength $badreconstrs] > 0} {
					if {[llength $badreconstrs] >= [expr $fofunitcnt - 1]} { 
						Inf "No FOF-Files Were Successfully Constructed"
						UnBlock
						set fofmode $orig_fofmode
						continue
					} else {
						Inf "Failed To Generate [llength $badreconstrs] FOF-Files"
					}
				}
				set badouts [concat $badouts $badreconstrs]

				if {[info exists badenvs]} {
					set msg "Some FOF-Outputs Could Not Be Enveloped : Do You Want To Keep These ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						set badouts [concat $badouts $badenvs]
					}
				}
				if {[llength $badouts] >= [expr $fofunitcnt - 1]} {
					Inf "No FOF-Files Were Successfully Generated"
					UnBlock
					set fofmode $orig_fofmode
					continue
				}

				;#	RENAME EXCEPT BADOUTS
		
				wm title .blocker "RENAMING OUTPUT FOF FILES AND PLACING ON WORKSPACE"
				set k 1
				set j 5
				set isdone 0
				catch {unset badnames}
				catch {unset true_outfiles}
				while {$k <= $fofunitcnt} {
					if {[lsearch $badouts $k] >= 0} {
						incr k
						incr j
						continue
					}
					set fofmultifnam $evv(DFLT_OUTNAME)
					append fofmultifnam $j $evv(SNDFILE_EXT)	;#	Output from FOF reconstruct
					if {![file exists $fofmultifnam]} {
						incr k
						incr j
						continue
					}
					set outfnam $generic_outfnam
					append outfnam "_fof_" $k
					append outfnam $evv(SNDFILE_EXT)
					if [catch {file rename $fofmultifnam $outfnam} zit] {
						lappend badnames $k
						incr j
						incr k
						continue
					}
					lappend true_outfiles $outfnam
					set isdone 1
					incr j
					incr k
				}
				set msg ""
				if {$isdone} {
				catch {unset last_outfile}
					set true_outfiles [ReverseList $true_outfiles]
					foreach fnam $true_outfiles {
						FileToWkspace $fnam 0 0 0 0 1
						lappend last_outfile $fnam
					}
					set msgnam $generic_outfnam
					append msgnam _fof_N
					append msg "[llength $true_outfiles] '$msgnam' Files Are On The Workspace\n\n"
				} else {
					append msg "No FOF Files Generated\n\n"
				}
				if {[llength $badouts] > 0} {
					append msg "[llength $badouts] FOF Files Failed To Be Reconstructed\n\n"
				}
				if {[info exists badnames]} {
					append msg "Renaming Of Temporary Files Failed For [llength $badnames] FOF Files\n\n"
				}
				Inf $msg
				UnBlock
				break
			}
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
	DoChoiceBak
}

#---- Control overall gain for FOF reconstruction, using Up/Down Keys

proc FofexGain {down shift} {
	global fofexgain
	if {$down} {
		if {$fofexgain <= 0.001} {
			return
		}
		if {$shift} {
			set fofexgain [expr $fofexgain - 0.01]
		} else {
			set fofexgain [expr $fofexgain - 0.1]
		}
		if {$fofexgain < 0.001} {
			set fofexgain 0.001
		}
	} else {
		if {$fofexgain >= 1.0} {
			return
		}
		if {$shift} {
			set fofexgain [expr $fofexgain + 0.01]
		} else {
			set fofexgain [expr $fofexgain + 0.1]
		}
		if {$fofexgain > 1.0} {
			set fofexgain 1.0
		}
	}
}

#---- Control fofexno for lowest or highest FOFs (number of FOF to use, counting up from 1 or down from 0) with Left/Right Keys

proc FofexNo {down hi} {
	global fofexno fofunitcnt
	if {$down} {
		if {$hi} {
			if {$fofexno <= 0} {
				return
			}
		} else {
			if {$fofexno <= 1} {
				return
			}
		}
		incr fofexno -1
		if {$fofexno < 1} {
			set fofexno 1
		}
	} else {
		if {$fofexno >= $fofunitcnt} {
			return
		}
		incr fofexno
		if {$fofexno > $fofunitcnt} {
			set fofexno $fofunitcnt
		}
	}
}

#---- Control fofexno2

proc FofexNo2 {down} {
	global fofexno2 fofunitcnt
	if {$down} {
		if {$fofexno2 <= 1} {
			return
		}
		incr fofexno2 -1
		if {$fofexno2 < 1} {
			set fofexno2 1
		}
	} else {
		if {$fofexno2 >= $fofunitcnt} {
			return
		}
		incr fofexno2
		if {$fofexno2 > $fofunitcnt} {
			set fofexno2 $fofunitcnt
		}
	}
}

#---- Control fofexno3

proc FofexNo3 {down} {
	global fofexno3 fofunitcnt
	if {$down} {
		if {$fofexno3 <= 1} {
			return
		}
		incr fofexno3 -1
		if {$fofexno3 < 1} {
			set fofexno3 1
		}
	} else {
		if {$fofexno3 >= $fofunitcnt} {
			return
		}
		incr fofexno3
		if {$fofexno3 > $fofunitcnt} {
			set fofexno3 $fofunitcnt
		}
	}
}

proc FofexLofrq {down} {
	global fofexlofrq
	if {$down} {
		if {$fofexlofrq <= 0} {
			return
		}
		incr fofexlofrq -5
		if {$fofexlofrq < 0} {
			set fofexlofrq 0
		}
	} else {
		if {$fofexlofrq >= 2500} {
			return
		}
		incr fofexlofrq 5
		if {$fofexlofrq > 2500} {
			set fofexlofrq 2500
		}
	}
}

proc FofexHifrq {down} {
	global fofexhifrq
	if {$down} {
		if {$fofexhifrq <= 0} {
			return
		}
		incr fofexhifrq -5
		if {$fofexhifrq < 0} {
			set fofexhifrq 0
		}
	} else {
		if {$fofexhifrq >= 2500} {
			return
		}
		incr fofexhifrq 5
		if {$fofexhifrq > 2500} {
			set fofexhifrq 2500
		}
	}
}

proc FofexLolev {down} {
	global fofexlolev
	if {$down} {
		if {$fofexlolev <= 0} {
			return
		}
		set fofexlolev [expr $fofexlolev - 0.01]
		if {$fofexlolev  < 0} {
			set fofexlolev  0
		}
	} else {
		if {$fofexlolev >= 1.0} {
			return
		}
		set fofexlolev [expr $fofexlolev + 0.01]
		if {$fofexlolev > 1.0} {
			set fofexlolev 1.0
		}
	}
}

proc FofexHilev {down} {
	global fofexhilev
	if {$down} {
		if {$fofexhilev <= 0} {
			return
		}
		set fofexhilev [expr $fofexhilev - 0.01]
		if {$fofexhilev  < 0} {
			set fofexhilev  0
		}
	} else {
		if {$fofexhilev >= 1.0} {
			return
		}
		set fofexhilev [expr $fofexhilev + 0.01]
		if {$fofexhilev > 1.0} {
			set fofexhilev 1.0
		}
	}
}

#---- Control fofexdb (level range of FOFs to keep) with Up/Down Keys

proc FofexDb {down} {
	global fofexdb
	if {$down} {
		if {$fofexdb <= -96} {
			return
		}
		incr fofexdb -1
	} else {
		if {$fofexdb >= 0} {
			return
		}
		incr fofexdb
	}
}

#---- Control fofextime (level range of FOFs to keep) with Up/Down Keys

proc FofexTime {down shift} {
	global fofextime fofexdur
	if {$down} {
		if {$fofextime > 0} {
			switch -- $shift {
				3 {
					set fofextime [expr $fofextime - 0.001]
				} 
				2 {
					set fofextime [expr $fofextime - 0.01]
				} 
				1 {
					set fofextime [expr $fofextime - 0.1]
				}
				0 {
					set fofextime [expr $fofextime - 1.0]
				}
			}
			if {$fofextime < 0.0} {
				set fofextime 0.0
			}
		}
	} elseif {$fofextime < $fofexdur} {
		switch -- $shift {
			3 {
				set fofextime [expr $fofextime + 0.001]
			} 
			2 {
				set fofextime [expr $fofextime + 0.01]
			} 
			1 {
				set fofextime [expr $fofextime + 0.1]
			} 
			0 {
				set fofextime [expr $fofextime + 1.0]
			}
		}
		if {$fofextime > $fofexdur} {
			set fofextime $fofexdur
		}
	}
}

#---- Adjust FOF-construction display for different modes

proc FofMode {} {
	global fofmode
	global lastfofmode fofexno fofexnobak fofbankfnam
	global fofexno2 fofexno2bak fofexno3 fofexno3bak fofexlofrq fofexlofrqbak fofexhifrq fofexhifrqbak 
	global fofexlolev fofexlolevbak fofexhilev fofexhilevbak fofunitlen evv

	if {$lastfofmode == 1} {
		if {[string length $fofexno] > 0} {
			set fofexnobak $fofexno
		}
		set fofexno ""
	} elseif {$lastfofmode == 6} {
		if {[string length $fofexno] > 0} {
			set fofexnobak $fofexno
		}
		if {[string length $fofexno2] > 0} {
			set fofexno2bak $fofexno2
		}
		if {[string length $fofexlofrq] > 0} {
			set fofexlofrqbak $fofexlofrq
		}
		if {[string length $fofexhifrq] > 0} {
			set fofexhifrqbak $fofexhifrq
		}
	} elseif {$lastfofmode == 7} {
		if {[string length $fofexno] > 0} {
			set fofexnobak $fofexno
		}
		if {[string length $fofexno2] > 0} {
			set fofexno2bak $fofexno2
		}
		if {[string length $fofexno3] > 0} {
			set fofexno3bak $fofexno3
		}
		if {[string length $fofexlofrq] > 0} {
			set fofexlofrqbak $fofexlofrq
		}
		if {[string length $fofexhifrq] > 0} {
			set fofexhifrqbak $fofexhifrq
		}
		if {[string length $fofexlolev] > 0} {
			set fofexlolevbak $fofexlolev
		}
		if {[string length $fofexhilev] > 0} {
			set fofexhilevbak $fofexhilev
		}
	}
	if {($fofmode == 1) || ($fofmode == 6) || ($fofmode == 7)} {
		if {[info exists fofunitlen]} {
			.fofex.0.sv config -text "SndView Only" -command "SnackDisplay 0 $evv(SN_FROM_FOFCNSTR_NO_OUTPUT) $fofunitlen $fofbankfnam" -bd 2 -bg $evv(SNCOLOROFF)
		}
	} else {
		.fofex.0.sv config -text "" -command {} -bd 0 -bg [option get . background {}]
	}
	set fofexno ""
	set fofexno2 ""
	set fofexno3 ""
	set fofexlofrq ""
	set fofexhifrq ""
	set fofexlolev ""
	set fofexhilev ""
	bind .fofex <Command-Up> {}
	bind .fofex <Command-Down> {}
	.fofex.3.fof2 config -text ""
	.fofex.3.e2   config -bd 0
	.fofex.3.fof3 config -text ""
	.fofex.3.e3   config -bd 0 
	.fofex.3.minf config -text ""
	.fofex.3.e4   config -bd 0 
	.fofex.3.maxf config -text ""
	.fofex.3.e5   config -bd 0 
	.fofex.3.minl config -text ""
	.fofex.3.e6   config -bd 0 
	.fofex.3.maxl config -text ""
	.fofex.3.e7   config -bd 0 
	bind .fofex <Right> {}
	bind .fofex <Left> {}
	bind .fofex <Shift-Right> {}
	bind .fofex <Shift-Left> {}
	bind .fofex <Control-Up> {}
	bind .fofex <Control-Down> {}
	bind .fofex <Control-Right> {}
	bind .fofex <Control-Left> {}
	bind .fofex <Control-Shift-Up> {}
	bind .fofex <Control-Shift-Down> {}
	bind .fofex <Command-Shift-Up> {}
	bind .fofex <Command-Shift-Down> {}
	.fofex.5.1.1 config -text ""
	.fofex.5.1.2 config -text ""
	.fofex.5.1.3 config -text ""
	.fofex.5.2.1 config -text ""
	.fofex.5.2.2 config -text ""
	.fofex.5.2.3 config -text ""
	.fofex.5.2.4 config -text ""
	if {$fofmode == 1} {
		.fofex.5.1.1 config -text "FOF1  Right/Left Arrows"
		.fofex.2.ll2 config -text "FOF number"  
		.fofex.2.e2 config -bd 2
		set fofexno $fofexnobak
		bind .fofex <Right> {FofexNo 0 0}
		bind .fofex <Left> {FofexNo 1 0}
	} elseif {$fofmode == 6} {
		.fofex.2.ll2 config -text "FOF number"  
		.fofex.2.e2 config -bd 2 -textvariable fofexno
		set fofexno $fofexnobak
		.fofex.3.fof2 config -text "2nd FOF"
		.fofex.3.e2 config -bd 2
		set fofexno2 $fofexno2bak
		.fofex.3.minf config -text "min frq"
		.fofex.3.e4   config -bd 2
		set fofexlofrq $fofexlofrqbak
		.fofex.3.maxf config -text "max frq"
		.fofex.3.e5   config -bd 2
		set fofexhifrq $fofexhifrqbak
		bind .fofex <Right> {FofexNo 0 0}
		bind .fofex <Left> {FofexNo 1 0}
		bind .fofex <Shift-Right> {FofexNo2 0}
		bind .fofex <Shift-Left> {FofexNo2 1}
		bind .fofex <Control-Up> {FofexLofrq 0}
		bind .fofex <Control-Down> {FofexLofrq  1}
		bind .fofex <Command-Up> {FofexHifrq 0}
		bind .fofex <Command-Down> {FofexHifrq  1}
		.fofex.5.1.1 config -text "FOF1  Right/Left Arrows"
		.fofex.5.1.2 config -text "FOF2  Shift Right/Left Arrows                         "
		.fofex.5.2.1 config -text "Lowest freq of quality-vary range    : Control Up/Down"
		.fofex.5.2.2 config -text "Highest freq of quality-vary range   : Command Up/Down"
	} elseif {$fofmode == 7} {
		.fofex.2.ll2 config -text "FOF number"  
		.fofex.2.e2 config -bd 2 -textvariable fofexno
		set fofexno $fofexnobak
		.fofex.3.fof2 config -text "2nd FOF"
		.fofex.3.e2 config -bd 2
		set fofexno2 $fofexno2bak
		.fofex.3.fof3 config -text "3rd FOF"
		.fofex.3.e3 config -bd 2
		set fofexno3 $fofexno3bak
		.fofex.3.minf config -text "min frq"
		.fofex.3.e4   config -bd 2
		set fofexlofrq $fofexlofrqbak
		.fofex.3.maxf config -text "max frq"
		.fofex.3.e5   config -bd 2
		set fofexhifrq $fofexhifrqbak
		.fofex.3.minl config -text "minlevel"
		.fofex.3.e6   config -bd 2
		set fofexlolev $fofexlolevbak
		.fofex.3.maxl config -text "maxlevel"
		.fofex.3.e7   config -bd 2
		set fofexhilev $fofexhilevbak
		bind .fofex <Right> {FofexNo 0 0}
		bind .fofex <Left> {FofexNo 1 0}
		bind .fofex <Shift-Right> {FofexNo2 0}
		bind .fofex <Shift-Left> {FofexNo2 1}
		bind .fofex <Control-Right> {FofexNo3 0}
		bind .fofex <Control-Left> {FofexNo3 1}
		bind .fofex <Control-Up> {FofexLofrq 0}
		bind .fofex <Control-Down> {FofexLofrq  1}
		bind .fofex <Command-Up> {FofexHifrq 0}
		bind .fofex <Command-Down> {FofexHifrq  1}
		bind .fofex <Control-Shift-Up> {FofexLolev 0}
		bind .fofex <Control-Shift-Down> {FofexLolev  1}
		bind .fofex <Command-Shift-Up> {FofexHilev 0}
		bind .fofex <Command-Shift-Down> {FofexHilev 1}
		.fofex.5.1.1 config -text "FOF1  Right/Left Arrows"
		.fofex.5.1.2 config -text "FOF2  Shift Right/Left Arrows                         "
		.fofex.5.1.3 config -text "FOF3  Control Right/Left Arrows"
		.fofex.5.2.1 config -text "Lowest freq of quality-vary range    : Control Up/Down"
		.fofex.5.2.2 config -text "Highest freq of quality-vary range   : Command Up/Down"
		.fofex.5.2.3 config -text "Lowest level of quality-vary range   : Shift Control Up/Down"
		.fofex.5.2.4 config -text "Highest level of quality-vary range  : Shift Command Up/Down"
	} else {
		.fofex.2.ll2 config -text ""  
		.fofex.2.e2 config -bd 0
	}
	set lastfofmode $fofmode
}

#---- Adjust output gain for FOF-construction, if FOFs are equalised in level

proc FOFEqualisationGain {} {
	global fofexgain fofexnorm
	if {$fofexnorm} {
		set fofexgain [expr $fofexgain / 2.0]
	} else {
		set fofexgain [expr $fofexgain * 2.0]
		if {$fofexgain > 1.0} {
			set fofexgain 1.0
		}
	}
}

#--- Sort data returned from "Sound View" into time-incresing order

proc FofisocutSort {cuts} {

	set len [llength $cuts]
	set len_less_one [expr $len - 1]
	set n 0 
	while {$n < $len_less_one} {			;#	SORT START OF CUTS INTO INCREASING TIME ORDER
		set cut_n [lindex $cuts $n]
		set start_n [lindex $cut_n 0]
		set m $n
		incr m 1
		while {$m < $len} {
			set cut_m [lindex $cuts $m]
			set start_m [lindex $cut_m 0]
			if {$start_m < $start_n} {
				set cuts [lreplace $cuts $n $n $cut_m]
				set cuts [lreplace $cuts $m $m $cut_n]
				set cut_n   $cut_m
				set start_n $start_m
			}
			incr m
		}
		incr n
	}
	set lastend -1
	foreach cut $cuts {
		set cutstart [lindex $cut 0]
		set cutend   [lindex $cut 1]
		if {$cutstart > $lastend} {		;#	IF NEXT CUT DOES NOT OVERLAP LAST, STORE IT
			lappend nucuts $cut
		} elseif {$lastend < $cutend} {	;#	IF IT OVERLAPS, IF IT'S END IS BEYOND END OF LAST, REPLACE EXISTING CUT'S END BY THIS END
			set nucuts [lreplace $cut 1 1 $cutend]
		}								;#	OTHERWISE THIS VUT IS COMPLETELY INCLUDED IN THE PRIOR CUT, SO IGNORE
		set lastend $cutend
	}
	return $nucuts
}

#---- Get length of FOF elements in fofbank file

proc GetFofUnitlen {srate ifnam ffnam} {
	global evv prg_dun prg_abortd simple_program_messages CDPidrun wstk fofunitlen fofunitcnt pa

	set OK 1
	set cmd [file join $evv(CDPROGRAM_DIR) fofex]
	lappend cmd construct 8 $ifnam $ffnam
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		set OK 0
		set msg "Cannot Retrieve FOF-Element Size (For \"Sound View\" Display) From File '[file rootname [file tail $ifnam]]'"
		catch {unset CDPidrun}
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set OK 0
			set msg "Cannot Retrieve FOF-Element Size (For \"Sound View\" Display) From File '[file rootname [file tail $ifnam]]'"
			set msg [AddSimpleMessages $msg]
		}
	}
	if {!$OK} {
		if {[string first "is not a FOFbank file" $msg] > 0} {
			Inf $msg
			return 0
		}
		append msg "\n\nContinue Anyway ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return 0
		} 
	} else {
		if [catch {open $ffnam "r"} zit] {
			set msg "\n\nCannot Read Size Of FOF-Elements For Special \"Sound View\" Display Mode: Continue Anyway ??"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return 0
			} 
		}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			set line [split $line]
			set fofunitlen [lindex $line 0]
			set fofunitcnt [lindex $line end]
			break
		}
		close $zit
		if {![regexp {^[0-9]+$} $fofunitlen] || ![regexp {^[0-9]+$} $fofunitcnt] \
		|| ($fofunitcnt < 1) || ([expr $fofunitlen * ($fofunitcnt + 1)] != $pa($ifnam,$evv(INSAMS)))} {
			set msg "Invalid FOF-Element Size Retrieved (Used For For Special \"Sound View\" Display Mode): Continue Anyway ??"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return 0
			} else {
				unset fofunitlen
			}
		}
	}
	return 1
}

#---- Select type of Pitch or Loudness Contours before FOF-based reconstruction

proc FofGetEnv {} {
	global fofenvget fofenvset
	global fofeo fofpo fofpq fofpqs fofpno fofenvstac fofenvexp fofpfnam fofefnam foftstrpfnam foftstrefnam
	switch -- $fofenvget {
		1 {
			set fofpfnam $fofpo
			set fofefnam $fofeo
		}
		2 {
			if [file exists $fofpq] {
				set fofpfnam $fofpq
			} else {
				Inf "Quantised Pitch Contour Does Not Yet Exist"
			}
		}
		3 {
			if [file exists $fofpqs] {
				set fofpfnam $fofpqs
			} else {
				Inf "Sustained Quantised Pitch Contour Does Not Yet Exist"
			}
		}
		4 {
			if [file exists $fofpno] {
				set fofpfnam $fofpno
			} else {
				Inf "Pitch Contour With No Ornaments Does Not Yet Exist"
			}
		}
		5 {
			if [file exists $fofenvstac] {
				set fofefnam $fofenvstac
			} else {
				Inf "Staccato Envelope Does Not Yet Exist"
			}
		}
		6 {
			if [file exists $fofenvexp] {
				set fofefnam $fofenvexp
			} else {
				Inf "Envelope With Decays Does Not Yet Exist"
			}
		}
		7 {
			if {[file exists $foftstrpfnam] && [file exists $foftstrefnam]} {
				set fofefnam $foftstrefnam
				set fofpfnam $foftstrpfnam
			} else {
				Inf "One Or Both Of The Time-Stretch Envelopes Does Not Yet Exist"
			}
		}
	}
	set fofenvset 0
}

#---- Modify Pitch or Loudness Contours before FOF-based reconstruction

proc FofModifyEnv {} {
	global fofenvget fofenvset fofpadj foforndur fofstacdur fofdecexp foftw foftwq foftworn
	global fofpo fofeo fofpq fofpqs fofpno fofenvstac fofenvexp fofpfnam fofefnam foftstrpfnam foftstrefnam


	switch -- $fofenvset {
		2 -
		3 {
			set fnam $fofpo
		}
		4 { 
			if {![file exists $fofpqs]} {
				Inf "Create Sustained Quantised Pitch Contour First"
				set fofenvset 0
				return
			}
			set fnam $fofpqs
		}
		5 - 
		6 {
			if {!([file exists $fofpqs] || [file exists $fofpno])} {
				Inf "Create Sustained Quantised Pitch Contour (With Or Without Supressed Ornaments) First"
				set fofenvset 0
				return
			}
			if {[string match $fofpfnam $fofpqs]} {
				set fnam $fofpqs
			} elseif {[string match $fofpfnam $fofpno]} {
				set fnam $fofpno
			} elseif {[file exists $fofpqs] && [file exists $fofpno]} {
				Inf "Select Quantised Pitch Contour File, With Or Without Suppressed Ornaments"
				set fofenvset 0
				return
			} elseif {[file exists $fofpqs]} {
				set fnam $fofpqs
				set fofpfnam $fofpqs
			} else {
				set fnam $fofpno
				set fofpfnam $fofpno
			}
		}
		7 {
			if {![IsNumeric $foftw] || ($foftw <= 1.0) || ($foftw > 200.0)} {
				Inf "Invalid Time Warp Value (Range >1.0 to 200.0)"
				set fofenvset 0
				return
			}
			if {![IsNumeric $foftworn] || ($foftworn < 0.0)} {
				Inf "Invalid Maximum Ornament Size"
				set fofenvset 0
				return
			}
			if {[string length $foftwq] > 0} {
				if {![IsNumeric $foftwq] || ($foftwq < 0.0)} {
					Inf "Invalid Time Warp Quantisation Value (>= 0.0)"
					set fofenvset 0
					return
				}
			}
			set fnam $fofpfnam
			if {![string match $fofefnam "1"]} {
				set fnam2 $fofefnam
			}
		}
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File To Read Original Envelope"
		set fofenvset 0
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		set line [split $line]
		lappend times [lindex $line 0]
		lappend vals  [lindex $line end]
	}
	close $zit

	if {[info exists fnam2]} {
		if [catch {open $fnam2 "r"} zit] {
			Inf "Cannot Open File To Read Other Existing Contour"
			set fofenvset 0
			return
		}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			set line [split $line]
			lappend times2 [lindex $line 0]
			lappend vals2  [lindex $line end]
		}
		close $zit
	}

	switch -- $fofenvset {
		2 {
			if {[file exists $fofpq]} {
				if [catch {file delete $fofpq} zit] {
					Inf "Cannot Delete Existing Quantised Pitch Data File"
					set fofenvset 0
					return
				}
			}
			;#	QUANTISE
			foreach val $vals {
				if {$val > 0.0} {
					set val [expr int(round([HzToMidi $val]))]
					set val [expr [MidiToHz $val]]
				}
				lappend nuvals $val
			}
			set nutimes $times
			set len [llength $nuvals]
			# REMOVE TRIPLES (QUADR ETC.)
			set j 0
			set m 1
			set n 2
			while {$n < $len} {
				set preval  [lindex $nuvals $j]
				set lastval [lindex $nuvals $m]
				set thisval [lindex $nuvals $n]
				if {($lastval == $preval) && ($thisval == $lastval)}  {
					set nutimes [lreplace $nutimes $m $m]
					set nuvals  [lreplace $nuvals  $m $m]
					incr len -1
				} else {
					incr j
					incr m
					incr n
				}
			}
			if [catch {open  $fofpq "w"} zit] {
				Inf "Cannot Open File '$fofpq' To Write Quantised Pitch Data File"
				set fofenvset 0
				return
			}
			foreach time $nutimes val $nuvals {
				set line [list $time $val]
				puts $zit $line
			}
			close $zit
			set fofefnam $fofeo			;#	ORIGINAL LOUDNESS
			set fofpfnam $fofpq			;#	QUANTISED PITCH
			Inf "Quantisation Complete"
		}
		3 {
			if {![IsNumeric $fofpadj] || ($fofpadj > 6) || ($fofpadj < -6)} {
				Inf "Invalid Pitch-Adjustment"
				set fofenvset 0
				return
			}
			if {[file exists $fofpqs]} {
				if [catch {file delete $fofpqs} zit] {
					Inf "Cannot Delete Existing Sustained-Quantised Pitch Data File"
					set fofenvset 0
					return
				}
			}
			;#	QUANTISE
			foreach val $vals {
				if {$val > 0.0} {
					set val [expr int(round([HzToMidi $val]))]
					set val [expr $val + $fofpadj]
					set val [expr [MidiToHz $val]]
				}
				lappend nuvals $val
			}
			set vals $nuvals
			unset nuvals
			;#	SUSTAIN
			set ccnt 0
			foreach time $times val $vals {
				if {$ccnt} {
					if {$val != $lastval} {
						set nutime [expr $time - 0.01]
						if {$nutime > $lasttime} {
							lappend nutimes $nutime
							lappend nuvals $lastval
						}
					}
				}
				lappend nutimes $time
				lappend nuvals $val
				set lastval $val
				set lasttime $time
				incr ccnt
			}
			# REMOVE TRIPLES (QUADR ETC.)
			set len [llength $nuvals]
			set j 0
			set m 1
			set n 2
			while {$n < $len} {
				set preval  [lindex $nuvals $j]
				set lastval [lindex $nuvals $m]
				set thisval [lindex $nuvals $n]
				if {($lastval == $preval) && ($thisval == $lastval)}  {
					set nutimes [lreplace $nutimes $m $m]
					set nuvals  [lreplace $nuvals  $m $m]
					incr len -1
				} else {
					incr j
					incr m
					incr n
				}
			}
			if [catch {open $fofpqs "w"} zit] {
				Inf "Cannot Open File '$fofpqs' To Write Sustained-Quantised Pitch Data File"
				set fofenvset 0
				return
			}
			foreach time $nutimes val $nuvals {
				set line [list $time $val]
				puts $zit $line
			}
			close $zit
			set fofpfnam $fofpqs		;#	OUTPUT PITCH SUSTAINED-QUANTISED
			set fofefnam $fofeo			;#	ORIGINAL LOUDNESS CONTOUR
			Inf "Sustain-Quantisation Complete"
		}
		4 {
			if {![IsNumeric $foforndur] || ($foforndur <= 0.0)} {
				Inf "Invalid Ornament Duration"
				set fofenvset 0
				return
			}
			set len [llength $vals]
			set j 0
			set m 1
			set n 2
			while {$n < $len} {
				set pretim  [lindex $times $j]
				set lasttim [lindex $times $m]
				set thistim [lindex $times $n]
				set preval  [lindex $vals $j]
				set lastval [lindex $vals $m]
				set thisval [lindex $vals $n]
				if {($lastval != $preval) && ($thisval != $lastval)} {	;#	ELIMINATE SINGLE VALS
					set nutime [expr $thistim - 0.01]
					if {$nutime > $pretim} {
						set times [lreplace $times $j $j $nutime]
					}
					set times [lreplace $times $m $m]
					set vals [lreplace $vals $m $m]
					incr len -1
				} elseif  {($lastval == $preval) && ([expr $lasttim - $pretim] < $foforndur)}  {	;#	ELIMINATE TOO SHORT VALS
					set done 1
					set times [lreplace $times $n $n $pretim]
					set times [lreplace $times $j $m]
					set vals [lreplace $vals $j $m]
					incr len -2
				} else {
					incr j
					incr m
					incr n
				}
			}
			if [catch {open  $fofpno "w"} zit] {
				Inf "Cannot Open File '$fofpno' To Write Pitch-Contour With Suppressed Ornaments"
				set fofenvset 0
				return
			}
			foreach time $times val $vals {
				set line [list $time $val]
				puts $zit $line
			}
			close $zit

			set fofpfnam $fofpno		;#	OUTPUT PITCH SUPPRESSED ORNAMENTS
			set fofefnam $fofeo			;#	ORIGINAL LOUDNESS CONTOUR
			Inf "Ornaments Suppressed"
		}
		5 {
			if {![IsNumeric $fofstacdur] || ($fofstacdur <= 0.0)} {
				Inf "Invalid Staccato Duration"
				set fofenvset 0
				return
			}
			set done 0
			lappend nutimes 0
			lappend nuvals 1
			set len [llength $vals]
			set j 0
			set m 1
			set n 2
			while {$n < $len} {
				set pretim  [lindex $times $j]
				set lasttim [lindex $times $m]
				set thistim [lindex $times $n]
				set preval  [lindex $vals $j]
				set lastval [lindex $vals $m]
				set thisval [lindex $vals $n]
				if  {$lastval == $preval} {
					set dur1 [expr $lasttim - $pretim]
					set dur2 [expr $thistim - $lasttim]
					if {$dur1 > $fofstacdur + 0.01}  {
						set done 1
						lappend nutimes $pretim
						lappend nuvals  1
						lappend nutimes [expr $pretim + $fofstacdur]
						lappend nuvals  0
						lappend nutimes $lasttim
						lappend nuvals  0
						lappend nutimes $thistim
						lappend nuvals  1
					}
				}
				incr j
				incr m
				incr n
			}
			if {[lindex $nutimes end] != $thistim} {
				lappend nuvals [lindex $nuvals end]
				lappend nutimes $thistim
			}
			if {!$done} {
				Inf "No Staccato Generated"
				set fofenvset 0
				return
			}
			;# REMOVE DUPLICATE TIMES
			set len [llength $nuvals]
			set m 0
			set n 1
			while {$n < $len} {
				set lasttim [lindex $nutimes $m]
				set thistim [lindex $nutimes $n]
				if {$thistim == $lasttim}  {
					set nutimes [lreplace $nutimes $m $m]
					set nuvals  [lreplace $nuvals  $m $m]
					incr len -1
				} else {
					incr m
					incr n
				}
			}
			if [catch {open  $fofenvstac "w"} zit] {
				Inf "Cannot Open File '$fofenvstac' To Write Staccato Contour"
				set fofenvset 0
				return
			}
			foreach time $nutimes val $nuvals {
				set line [list $time $val]
				puts $zit $line
			}
			close $zit
			set fofefnam $fofenvstac
			Inf "Staccato Done"
		}
		6 {
			if {![IsNumeric $fofdecexp] || ($fofdecexp <= 0.0)} {
				Inf "Invalid Decay Exponent"
				set fofenvset 0
				return
			}
			set done 0
			lappend nutimes 0
			lappend nuvals 1
			set len [llength $vals]
			set m 0
			set n 1
			while {$n < $len} {
				set lasttim [lindex $times $m]
				set thistim [lindex $times $n]
				set lastval [lindex $vals $m]
				set thisval [lindex $vals $n]
				lappend nutimes $lasttim
				lappend nuvals 1
				if  {$lastval == $thisval} {
					set dur [expr $thistim - $lasttim]
					if {$dur > 0.01}  {
						set done 1
						lappend nutimes [expr $lasttim + ($dur/3.0)]
						lappend nuvals  [expr pow(0.6666,$fofdecexp)]
						lappend nutimes [expr $lasttim + ($dur/1.5)]
						lappend nuvals  [expr pow(0.3333,$fofdecexp)]
						lappend nutimes $thistim
						lappend nuvals  0
					}
				}
				incr n
				incr m
			}
			if {[lindex $nutimes end] != $thistim} {
				lappend nuvals [lindex $nuvals end]
				lappend nutimes $thistim
			}
			if {!$done} {
				Inf "No Decays Generated"
				set fofenvset 0
				return
			}
			# REMOVE TRIPLES (QUADR ETC.)
			set len [llength $nuvals]
			set j 0
			set m 1
			set n 2
			while {$n < $len} {
				set preval  [lindex $nuvals $j]
				set lastval [lindex $nuvals $m]
				set thisval [lindex $nuvals $n]
				if {($lastval == $preval) && ($thisval == $lastval)}  {
					set nutimes [lreplace $nutimes $m $m]
					set nuvals  [lreplace $nuvals  $m $m]
					incr len -1
				} else {
					incr j
					incr m
					incr n
				}
			}
			;# REMOVE DUPLICATE TIMES
			set len [llength $nuvals]
			set m 0
			set n 1
			while {$n < $len} {
				set lasttim [lindex $nutimes $m]
				set thistim [lindex $nutimes $n]
				if {$thistim == $lasttim}  {
					set nutimes [lreplace $nutimes $m $m]
					set nuvals  [lreplace $nuvals  $m $m]
					incr len -1
				} else {
					incr m
					incr n
				}
			}
			if [catch {open  $fofenvexp "w"} zit] {
				Inf "Cannot Open File '$fofenvexp' To Write Decay Contours"
				set fofenvset 0
				return
			}
			foreach time $nutimes val $nuvals {
				set line [list $time $val]
				puts $zit $line
			}
			close $zit
			Inf "Decay Envelopes Done"
			set fofefnam $fofenvexp
		}
		7 {
			set ccnt 0 
			set isorn 0
			set len [llength $times]			
			set m 0
			set n 1
			while {$n < $len} {			;#	MARK START(1) AND END(0) OF STRETCHABLE PORTIONS OF PFILE, PAIRING THE TIME-INDEX WITH THE 1/0 MARKER
				set thistim [lindex $times $n]
				set lasttim [lindex $times $m]
				if {[expr $thistim - $lasttim] <= $foftworn} {	;#	IF THIS EVENT AN ORNAMENT
					if {!$isorn} {								;#	IF NOT ALREADY IN ORNAMENT, MARK END OF EVENT AS START OF STRETCHABLE SIGNAL
						lappend svals $n 1				
						incr ccnt 2
					} else {									;#	ELSE, IF ALREADY IN ORNAMENTS
						set indx [expr $ccnt - 3]				;#	MOVE PREVIOUS START OF STRETCHABLES TO HERE
						set svals [lrange $svals 0 $indx]
						lappend svals $n 1
					}
					set isorn 1
				} else {										;#	THIS EVENT IS STRETCHABLE
					if {!$isorn} {
						if {$ccnt == 0} {						;#	IF AT START OF FILE,
							lappend svals $m 1					;#	MARK STARTOF FILE AS STRETCHABLE-SECTION START
							incr ccnt 2
							lappend svals $n 0					;#	MARK END OF THIS SEGMENT AS START OF NON-STRETCHABLE
							incr ccnt 2
						} else {
							set indx [expr $ccnt - 3]			;#	IF NOT IN ORNAMENT, BUT NOT AT START OF FILE
							set svals [lrange $svals 0 $indx]	;#	MOVE END OF STRETCHABLE-SEG TO END OF THIS SEG
							lappend svals $n 0
						}
					} else {									;#	IF IN ORNAMENT	
						lappend svals $n 0						;#	MARK END OF THIS SEG AS END OF STRETCHABLE
						incr ccnt 2
					}
					set isorn 0
				}
				incr n
				incr m
			}
			if {![info exists svals]} {
				Inf "No Stretchability"
				set fofenvset 0
				return
			}
			set OK 0
			foreach val $svals {
				if {$val > 0} {
					set OK 1
					break
				}
			}
			if {!$OK} {
				Inf "No Stretchability"
				set fofenvset 0
				return
			}
			set slen [llength $svals]
			set slen_less_one [expr $slen - 1]
			set nutimes $times
			set n 0
			set k 1
			if {![Flteq $foftwq 0.0]} {
				set qwtfof [expr 1.0/$foftwq]
			}
											;#	STRETCH THE PFILE
			while {$k < $slen_less_one} {
				if {[lindex $svals $k] > 0} {					;#	TIME-STRETCHABLE SEGMENT
					set enddindx [lindex $svals [expr $k + 1]]	;#	FIND ITS END
					set endd [lindex $times $enddindx]
					set nuendd [expr $endd * $foftw]
					if {![Flteq $foftwq 0.0]} {
						set ticks [expr int(round($nuendd * $qwtfof))]
						set nuendd [expr $foftwq * double($ticks)]
					}
					set durincr [expr $nuendd - $endd]
					while {$enddindx < $len} {					;#	MOVE IT RELATIVE TO START OF FILE....
						set tim [lindex $times $enddindx]		;#	AND MOVE UP ALL FOLLOWING SEGS IN OUTPUT (IN CASE ANY OF THEM ARE ORNAMENTS)
						set tim [expr $tim + $durincr]			;#	(REAL STRETCHABLE SEGEMENTS WILL BE REPOSITIONED IN SUBSEQUENT PASSES)
						set nutimes [lreplace $nutimes $enddindx $enddindx $tim]
						incr enddindx
					}
				}
				incr k 2
			}
			if {[info exists times2]} {
				set len2 [llength $times2]
				set done 0
				set n 0
				set k 1
				while {$k < $slen_less_one} {
					if {[lindex $svals $k] > 0} {					;#	INSERT THE MARKED (TIME-STRETCHABLE) TIME-POINTS OF THE PFILE
						set strtindx [lindex $svals [expr $k - 1]]	;#	AMONGST THE ENVELOPE-BRKPOINT VALS
						set enddindx [lindex $svals [expr $k + 1]]
						set strt [lindex $times $strtindx]
						set endd [lindex $times $enddindx]
						set time2 [lindex $times2 $n]
						while {$time2 < $strt} {
							incr n
							if {$n >= $len2} {
								set done 1
								break
							}
							set time2 [lindex $times2 $n]
						}
						if {$done} {
								set times2 [linsert $times2 end $strt]
								set nuval  [lindex $vals2 end]
								set vals2  [linsert $vals2 end $nuval]
								incr len2
						} else {
							if {[Flteq $time2 $strt]} {
								set times2 [lreplace $times2 $n $n $strt]
							} else {
								set lastval [lindex $vals2 [expr $n - 1]]
								set thisval [lindex $vals2 $n]
								set valdiff [expr $thisval - $lastval]
								set lasttime [lindex $times2 [expr $n - 1]]
								set thistime [lindex $times2 $n]
								set timediff [expr $thistime - $lasttime]
								set ratio [expr double($strt - $lasttime)/double($timediff)]
								set nuval [expr $valdiff * $ratio]
								set nuval [expr $nuval + $lastval]
								set times2 [linsert $times2 $n $strt]
								set vals2  [linsert $vals2 $n $nuval]
								incr len2
							}
						}
						lappend nusvals $n 1	;#	MARK START OF TSTRETCH SEG IN ENVELOPE FILE
						set time2 $strt
						while {$time2 < $endd} {
							incr n
							if {$n >= $len2} {
								set done 1
								break
							}
							set time2 [lindex $times2 $n]
						}
						if {$done} {
							set times2 [linsert $times2 end $endd]
							set nuval  [lindex $vals2 end]
							set vals2  [linsert $vals2 end $nuval]
							incr len2
						} else {
							if {[Flteq $time2 $endd]} {
								set times2 [lreplace $times2 $n $n $endd]
							} else {
								set lastval [lindex $vals2 [expr $n - 1]]
								set thisval [lindex $vals2 $n]
								set valdiff [expr $thisval - $lastval]
								set lasttime [lindex $times2 [expr $n - 1]]
								set thistime [lindex $times2 $n]
								set timediff [expr $thistime - $lasttime]
								set ratio [expr double($endd - $lasttime)/double($timediff)]
								set nuval [expr $valdiff * $ratio]
								set nuval [expr $nuval + $lastval]
								set times2 [linsert $times2 $n $endd]
								set vals2  [linsert $vals2 $n $nuval]
								incr len2
							}
						}
						lappend nusvals $n 0	;#	MARK END OF TSTRETCH SEG IN ENVELOPE FILE
					}
					incr k 2
				}
				set nutimes2 $times2
				set slen [llength $nusvals]
				set slen_less_one [expr $slen - 1]
				set k 1
				while {$k < $slen_less_one} {
					if {[lindex $nusvals $k] > 0} {
						set strtindx [lindex $nusvals [expr $k - 1]]		;#	START OF TIME-STRETCHABLE SEGMENT
						set enddindx [lindex $nusvals [expr $k + 1]]		;#	END OF TIME-STRETCHABLE SEGMENT
						set strt [lindex $times2 $strtindx]
						if {![Flteq $foftwq 0.0]} {							;#	QUANTISE, IF ASKED FOR
							if {($strtindx > 0) && ([expr $strtindx + 1] < $len2)}  {
								set ticks [expr int(round($strt * $qwtfof))]
								set nustrt [expr $foftwq * double($ticks)]
								if {($nustrt > [lindex $nutimes2 [expr $strtindx - 1]]) && ($nustrt < [lindex $nutimes2 [expr $strtindx + 1]]) } {
									set $nutimes2 [lreplace $nutimes2 $strtindx $nustrt]
								}
							}
						}
						set j $strtindx
						incr j
						while {$j <= $enddindx} {							;#	EXPAND BY STRETCH FACTOR ALL TIMES WITHIN TIME-STRETCHABLE SEG OF times2
							set thistime [lindex $times2 $j]				;#	PUTTING OUTPUTS INTO nutimes2
							set nutime [expr $thistime * $foftw]
							set nutimes2 [lreplace $nutimes2 $j $j $nutime]
							incr j
						}
						set durincr [expr $nutime - $thistime]

						incr enddindx
						while {$enddindx < $len2} {
							set tim [lindex $times2 $enddindx]				;#	AND MOVE UP ALL FOLLOWING SEGS IN OUTPUT (IN CASE ANY OF THEM ARE ORNAMENTS)
							set tim [expr $tim + $durincr]					;#	(REAL STRETCHABLE SEGEMENTS WILL BE REPOSITIONED IN SUBSEQUENT PASSES)
							set nutimes2 [lreplace $nutimes2 $enddindx $enddindx $tim]
							incr enddindx
						}
					}
					incr k 2
				}
			}
			if [catch {open  $foftstrpfnam "w"} zit] {
				Inf "Cannot Open File '$foftstrpfnam' To Write Time-Stretch Pitch-Contours"
				set fofenvset 0
				return
			}
			foreach time $nutimes val $vals {
				set line [list $time $val]
				puts $zit $line
			}
			close $zit
			if {[info exists times2]} {
				if [catch {open  $foftstrefnam "w"} zit] {
					Inf "Cannot Open File '$foftstrefnam' To Write Time-Stretch Loudness-Contours"
					set fofenvset 0
					return
				}
				foreach time $nutimes2 val $vals2 {
					set line [list $time $val]
					puts $zit $line
				}
				close $zit
				set fofefnam $foftstrefnam
			}
			set fofpfnam $foftstrpfnam

			Inf "Time-Stretch Contouring-Files Done"
		}
	}
}

#---- Play src of FOFs, if known, or allow user to specify it and then play it (remembering it)

proc FofGetPlaySrc {} {
	global fofsrc wl pr_gfofs gfofslist pa evv
	if {![info exists fofsrc]} {
		set f .gfofs
		if [Dlg_Create $f "FIND SOURCE SND" "set pr_gfofs 0" -borderwidth $evv(SBDR)] {
			button $f.0 -text "Quit" -command "set pr_gfofs 0" -highlightbackground [option get . background {}]
			pack  $f.0 -side top -pady 2
			label $f.1 -text "Select Source with Mouse" -fg $evv(SPECIAL)
			pack $f.1 -side top -pady 2
			set gfofslist [Scrolled_Listbox $f.2 -width 80 -height 32 -selectmode single]
			pack $f.2 -side top -fill both -expand true
			bind $gfofslist <ButtonRelease-1> {set pr_gfofs 1}
			wm resizable $f 1 1
			bind $f <Escape> {set pr_gfofs 0}
		}
		$gfofslist delete 0 end
		foreach fnam [$wl get 0 end] {
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				$gfofslist insert end $fnam
			}
		}
		set pr_gfofs 0
		set finished 0
		raise $f
		update idletasks
		StandardPosition $f
		My_Grab 0 $f pr_gfofs
		set finished 0
		while {!$finished} {
			tkwait variable pr_gfofs
			if {$pr_gfofs} {
				set i [$gfofslist curselection]
				if {$i < 0} {
					Inf "No Sound Selected"
					continue
				} else {
					set fofsrc [$gfofslist get $i]
				}
				break
			} else {
				break
			}
		}
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
		destroy $f
	}
	if {[info exists fofsrc]} {
		.fofex.0.src config -text "Play Src"
		PlaySndfile $fofsrc 0
	}
}

#--- Change val of Fof Grouping

proc FofGrouping {down} {
	global fofdubl evv
	if {$down} {
		if {$fofdubl > 1} {
			incr fofdubl -1
		}
	} else {
		if {$fofdubl < $evv(FOFGPMAX) } {
			incr fofdubl
		}
	}
}

#----- Save intermediate contyour files in FOF reconstruct

proc SaveCurrentFOFContourFiles {} {
	global fofpfnam fofefnam fofpo fofeo pr_fofcontour fofcoefnam fofcopfnam fofenvstac fofenvexp
	global wstk wl rememd evv last_outfile
	set gotp 0
	set gote 0
	set msg ""
	if {[string match $fofpfnam $fofpo]} {
		append msg "Current Pitch Contour File ($fofpo) Already Saved\n"
		set gotp 1
	}
	if {[string match $fofefnam $fofeo]} {
		append msg "Current Loudness Contour File ($fofeo) Already Saved\n"
		set gote 1
	}
	if {$gote || $gotp} {
		Inf $msg
	}
	if {$gote && $gotp} {
		return
	}
	set fofcopfnam ""
	set fofcoefnam ""
	set f .fofcontour
	if [Dlg_Create $f "SAVE CONTOUR FILES" "set pr_fofcontour 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Quit" -command "set pr_fofcontour 0" -highlightbackground [option get . background {}]
		button $f.0.s -text "Save Contour Files" -command "set pr_fofcontour 1" -highlightbackground [option get . background {}]
		pack  $f.0.q -side right
		pack  $f.0.s -side left
		pack  $f.0 -side top -fill x -expand true
		if {!$gotp} {
			frame $f.1
			label $f.1.ll -text "Frequency Contour Filename " -width 27
			entry $f.1.e -textvariable fofcopfnam -width 16
			pack $f.1.ll $f.1.e -side left
			pack $f.1 -side top
		}

		if {!$gote} {
			frame $f.2
			label $f.2.ll -text "Loudness Contour Filename " -width 27
			entry $f.2.e -textvariable fofcoefnam -width 16
			pack $f.2.ll $f.2.e -side left
			pack $f.2 -side top
		}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_fofcontour 0}
		bind $f <Return> {set pr_fofcontour 1}
	}
	set pr_fofcontour 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_fofcontour
	set finished 0
	while {!$finished} {
		tkwait variable pr_fofcontour
		if {$pr_fofcontour} {
			catch {unset last_outfile_x}
			if {!$gotp} {
				if {[string length $fofcopfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fofcopfnam]} {
					continue
				}
				set outfnam  [string tolower $fofcopfnam]
				append outfnam [GetTextfileExtension brk]
				if {[file exists $outfnam]} {
					set msg "File '$outfnam' Already Exists. Overwrite It?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					set i [LstIndx $outfnam $wl]
					if {![DeleteFileFromSystem $outfnam 0 1]} {
						Inf "Cannot Delete Existing File '$outfnam'"
						continue
					} else {
						DummyHistory $outfnam "DESTROYED"
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				if [catch {file copy $fofpfnam $outfnam} zit] {
					Inf "Cannot Rename The Pitch Contour File"
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					lappend last_outfile_x $outfnam
				}
			}
			if {!$gote} {
				if {[string length $fofcoefnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fofcoefnam]} {
					continue
				}
				set outfnam  [string tolower $fofcoefnam]
				append outfnam [GetTextfileExtension brk]
				if {[file exists $outfnam]} {
					set msg "File '$outfnam' Already Exists. Overwrite It?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					set i [LstIndx $outfnam $wl]
					if {![DeleteFileFromSystem $outfnam 0 1]} {
						Inf "Cannot Delete Existing File '$outfnam'"
						continue
					} else {
						DummyHistory $outfnam "DESTROYED"
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				if [catch {file copy $fofefnam $outfnam} zit] {
					Inf "Cannot Save Loudness Contour File"
					continue
				}
				if {[string match $fofefnam $fofenvstac] || [string match $fofefnam $fofenvexp]} {
					set msg "This Envelope File Does Not Include The Effect Of The Envelope Of The Original Contour File\n\n"
					append msg "These May Be Combined In The \"Table Editor\""
					Inf $msg
				}

				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					lappend last_outfile_x $outfnam
				}
			}
			if {[info exists last_outfile_x]} {
				set last_outfile $last_outfile_x
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#---- Help info on FOF reconstruction

proc FofexHelp {typ} {
	global evv
	if {$typ >= 2} {
		append msg "CONSTRUCT SOUND USING EXTRACTED FOFs\n"
		append msg "\n"
		if {$typ == 3} {
			append msg "Use Extract FOFs to resynthesize the original sound.\n"
		} else {
			append msg "Use FOFbank file + infofile (from \"Extract FOFs\")\n"
			append msg "a pitch brkpntfile + optional loudness envelope\n"
			append msg "(all entered from Chosen Files list)\n"
			append msg "to synthesize new sound, using FOFs in FOFbank.\n"
		}
		append msg "\n"
		append msg "a) Force FOFs to the same level with \"Equalise\"\n"
		append msg "\n"
		append msg "b) Set overall attenuation with \"Overall Gain\"\n"
		append msg "        Program reports when the output clips.\n"
		append msg "        (Shift) Up/Down Arrow Keys change this value.\n"
		append msg "\n"
		append msg "c) Where individual FOFs used, alter vals in boxes\n"
		append msg "        with arrow keys (explanation will be displayed).\n"
		append msg "\n"
		append msg "        To decide on specific FOFs, use Sound View\n"
		append msg "        at Max Zoom. Display steps from FOF to FOF,\n"
		append msg "        with Cntrl-Command-Click, & number of (hilighted)\n"
		append msg "        FOF is displayed. With very large FOFs,\n"
		append msg "        zoom out, Cntrl-Command-Click to L or R, zoom in.\n"
		append msg "\n"
		Inf $msg
		set  msg "CONSTRUCTION MODES\n"
		append msg "\n"
		append msg "1) FOF used specified by number. Lowest is 1.\n"
		append msg "\n"
		append msg "2) FOF used is sum of FOFs in FOFbank.\n"
		append msg "\n"
		append msg "3) FOF used sum of FOFs in lowest range of FOFbank.\n"
		append msg "\n"
		append msg "4) FOF used sum of FOFs in middle range of FOFbank.\n"
		append msg "\n"
		append msg "5) FOF used sum of FOFs in highest range of FOFbank.\n"
		append msg "\n"
		append msg "6) 2 FOFs chosen: balance dictated by pitch.\n"
		append msg "\n"
		append msg "7) 3 FOFs chosen: balance dictated by pitch/loudness.\n"
		append msg "\n"
		Inf $msg
		set msg "MODIFYING PITCH, LOUDNESS CONTOUR, & TIME-STRETCHING\n"
		append msg "\n"
		append msg "Pitch & loudness contour of individual pitch-events\n"
		append msg "may be modified, and the entire sound time-stretched.\n"
		append msg "\n"
		append msg "1)  Quantise pitches to tempered scale.\n"
		append msg "\n"
		append msg "2)  Quantise pitches & sustain until onset of next.\n"
		append msg "\n"
		append msg "3)  Remove ornaments (v.short events) from (2).\n"
		append msg "\n"
		append msg "4)  Make events staccato.\n"
		append msg "\n"
		append msg "5)  Add decaying envelope to events.\n"
		append msg "\n"
		append msg "6)  Time-stretch any of these\n"
		append msg "          (ornaments remain at original durations).\n"
		append msg "\n"
		Inf $msg
	} else {
		set msg "EXTRACT FOFS TO USE TO CONSTRUCT A NEW SOUND\n"
		append msg "\n"
		append msg "Extracts FOFs from mono (vocal) sound.\n"
		append msg "\n"
		if {$typ == 0} {
			append msg "With just a Sndfile on Chosen List, SELECT\n"
			append msg "   \"sections to exclude\" or \"no exclusions\".\n"
			append msg "   Exclude areas in sound where FOFs unlikely\n"
			append msg "   (sibillants, silences etc.)\n"
			append msg "   using \"Sound View\" to mark excluded areas.\n"
			append msg "\n"
			append msg "   Alternatively list excluded area\n"
			append msg "   (as sample-time pairs) in a textfile.\n"
			append msg "   & place on Chosen Files list, after sndfile.\n"
			append msg "\n"
		}
		append msg "1) Process generates, or uses existing,\n"
		append msg "        pitch brkpntfile with name of soundfile\n"
		append msg "        + tag \"$evv(FREQ_TAG)\".\n"
		append msg "\n"
		append msg "b) Process generates, or uses existing,\n"
		append msg "        loudness brkpntfile with name of soundfile\n"
		append msg "        + tag \"$evv(ENV_TAG)\".\n"
		append msg "\n"
		append msg "c) You can force FOFs to be \"grouped\"\n"
		append msg "       i.e. extracted as pairs, triples etc.\n"
		append msg "\n"
		append msg "d) FOFs normally windowed when extracted.\n"
		append msg "       Tick the box to prevent windowing.\n"
		append msg "\n"
		if {$typ == 0} {
			append msg "e) Can exclude FOFs which fall N dBs or more\n"
			append msg "      below level of loudest FOF.\n"
			append msg "      N.B. A value of ZERO RETAINS ALL FOFs.\n"
			append msg "\n"
		}
		append msg "You may then construct output sound (using\n"
		append msg "pitch-contour of input) and/or save extracted\n"
		append msg "data to use later, e.g. with new pitch-contour.\n"
		append msg "\n"
		append msg "Output stored in special soundfile, a FOFbank file.\n"
		append msg "Process also generates textfile of information\n"
		append msg "about contents of FOFbank file.\n"
		Inf $msg
	}
}

##############################################################
# CREATING CANONIC MIX, FROM PROPERTY MOTIF-DATA FILTER FILE #
##############################################################

proc ExtractCanonicTimeStep {} {
	global pr_canon canonstart canonlen canoncycs canonmix maxcanonstart maxcanonlen readonlyfg readonlybg wstk wl chlist rememd pa evv last_outfile

	set gotfile 0
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam $chlist
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set gotfile 1
		}
	}
	if {!$gotfile} {
		set i [$wl curselection]
		if {([llength $i] != 1) || ($i < 0)} {
			Inf "Select A Single Soundfile"
			return
		}
		set fnam [$wl get $i]
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Select A Single Soundfile"
			return
		}
	}
	set chans $pa($fnam,$evv(CHANS))
	set fifnam [file rootname $fnam]
	append fifnam $evv(FILT_TAG) $evv(TEXT_EXT)
	if {![file exists $fifnam]} {
		Inf "File '$fifnam' Does Not Exist: No Note-Timing Data"
		return
	}
	if [catch {open $fifnam "r"} zit] {
		Inf "Cannot Open File '$fifnam' To Read Timing Data"
		return 0
	}
	set lasttime -1
	set isstart 1
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {	
			continue
		}
		set line [split $line]
		set cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] > 0} {	
				switch -- $cnt {
					0 {
						if {![IsNumeric $item] || ($item < 0.0) || ($item < $lasttime)} {
							Inf "Invalid Data In File '$fifnam'"
							close $zit
							return
						}
						if {$isstart} {
							set lasttime $item
							lappend times $item
						}
					}
					1 {
						if {$isstart} {
							set lastmidi $item	
						} elseif {![Flteq $item $lastmidi]} {
							Inf "Invalid Data In File '$fifnam'"
							close $zit
							return
						}
					}
				}
			}
			incr cnt
		}
		set isstart [expr !$isstart]
	}
	if {![info exists times]} {
		Inf "No Valid Data In File '$fifnam'"
		return
	}
	set len [llength $times]
	set len_less_one [expr $len - 1]
	set maxcanonstart $len_less_one
	set maxcanonlen $len_less_one
	set canoncycs 2
	set canonstart 1
	set canonlen $maxcanonlen
	set f .canon
	if [Dlg_Create $f "CREATE CANONIC MIXFILE FROM [file rootname [file tail $fnam]]" "set pr_canon 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		button $f0.ok -text "Make Canon" -command "set pr_canon 1" -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_canon 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f.1 -text "Gap between Start and End notes defines canon delay" -fg $evv(SPECIAL)
		pack $f.1 -side top -pady 4
		entry $f2.e -textvariable canonstart -width 2 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f2.ll -text " Start Note (Up/Dn Arrows)"
		pack $f2.e $f2.ll -side left -padx 2 -fill x -expand true
		entry $f3.e -textvariable canonlen -width 2 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f3.ll -text " End Note (Control Up/Dn Arrows)"
		pack $f3.e $f3.ll -side left -padx 2
		entry $f4.e -textvariable canoncycs -width 2 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f4.ll -text " No of repeats (Shift Up/Dn Arrows)"
		pack $f4.e $f4.ll -side left -padx 2
		entry $f5.e -textvariable canonmix -width 16
		label $f5.ll -text " Mix outfile name"
		pack $f5.e $f5.ll -side left -padx 2
		pack $f2 $f3 $f4 $f5 -side top -fill x -expand true -pady 2
		bind $f <Up> {IncrCanonStart 0}
		bind $f <Down> {IncrCanonStart 1}
		bind $f <Control-Up> {IncrCanonLen 0}
		bind $f <Control-Down> {IncrCanonLen 1}
		bind $f <Shift-Up> {IncrCanonCycs 0}
		bind $f <Shift-Down> {IncrCanonCycs 1}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_canon 0}
		bind $f <Return> {set pr_canon 1}
	}
	set pr_canon 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_canon
	while {!$finished} {
		tkwait variable pr_canon
		if {$pr_canon} {
			set startnote [expr $canonstart - 1]
			set syncnote [expr $startnote + $canonlen]
			if {$syncnote >= $len} {
				Inf "Insufficent Notes In Motif To Create Canon With These Parameters"
				continue
			}
			if {[string length $canonmix] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $canonmix]} {
				continue
			}
			set outfnam [string tolower $canonmix]
			append outfnam [GetTextfileExtension mix]
			if {[file exists $outfnam]} {
				set msg "File '$outfnam' Already Exists: Overwrite It ?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				} else {
					set i [LstIndx $outfnam $wl]
					UpdateIfAMix $outfnam 1
					if {![DeleteFileFromSystem $outfnam 0 1]} {
						set msg "Cannot Delete Original File '$outfnam'"
						continue
					} else {
						DummyHistory $outfnam "DESTROYED"
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
			}
			set time0 [lindex $times $startnote]
			set time1 [lindex $times $syncnote]
			set diff [expr double($time1) - double($time0)]
			set thistime 0.0
			set n 0
			catch {unset outlines}
			while {$n < $canoncycs} {
				set line $fnam
				append line " " $thistime " " $chans " 1.0"
				if {$chans == 1} {
					append line " C"
				}
				lappend outlines $line
				set thistime [expr $thistime + $diff]
				incr n
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write The Mixfile Data"	
				continue
			}
			foreach line $outlines {
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] <= 0} {
				Inf "File '$outfnam' Has Been Created But Is Not On The Workspace"
			} else {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
		} else {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc IncrCanonStart {down} {
	global canonstart maxcanonstart
	if {$down} {
		if {$canonstart <= 1} {
			return
		}
		incr canonstart -1
	} else {
		if {$canonstart >= $maxcanonstart} {
			return
		}
		incr canonstart
	}
}

proc IncrCanonLen {down} {
	global canonlen maxcanonlen
	if {$down} {
		if {$canonlen <= 1} {
			return
		}
		incr canonlen -1
	} else {
		if {$canonlen >= $maxcanonlen} {
			return
		}
		incr canonlen
	}
}

proc IncrCanonCycs {down} {
	global canoncycs maxcanoncycs
	if {$down} {
		if {$canoncycs <= 2} {
			return
		}
		incr canoncycs -1
	} else {
		if {$canoncycs >= 256} {
			return
		}
		incr canoncycs
	}
}

#----- Emphasizes specified events in file, using an envelope of short peaks of specified half-width

proc EventsEmphasize {} {
	global chlist pa evv emphatimes pr_rss2 rss2hw rss2fnam rss2finam rss2w prg_dun prg_abortd simple_program_messages CDPidrun emphset emphrand evemhw
	global emph_fnam emphfnam emphbrk rss2xfinam released prg_dun prg_abortd simple_program_messages CDPidrun emphdat last_outfile

	if {![info exists chlist] || ([llength $chlist] != 1)} {
		Inf "Put Selected Soundfile On Chosen List"
		return
	}
	set fnam [lindex $chlist 0]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Put Selected Soundfile On Chosen List"
		return
	}
	set emphenv $evv(DFLT_OUTNAME)$evv(TEXT_EXT)
	catch {unset emphatimes}
	set f .rss2
	if [Dlg_Create $f "EMPHASIZE EVENTS" "set pr_rss2 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f00 [frame $f.00] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5]
		set f6 [frame $f.6]

		button $f0.ok -text "Do Emphasis" -command "set pr_rss2 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		label $f0.ll -text "Outfile Soundfile Name "
		entry $f0.e -textvariable rss2fnam -width 16
		button $f0.quit -text "Quit" -command "set pr_rss2 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.ll $f0.e -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true

		frame $f.a -bg $evv(POINT) -height 1
		pack $f.a -side top -fill x -expand true -pady 2

		set msg "Define Times of events-to-emphasize\nusing\"Sound View\" : OR enter data as textfile"
		if {[info exists released(peakfind)]} {
			append msg " : OR Derive from sound"
		}
		label $f.1 -text $msg -fg $evv(SPECIAL)
		pack $f.1 -side top -pady 1

		frame $f00.0
		button $f00.0.sv -text "Sound View"  -command "SnackDisplay $evv(SN_TIMESLIST) emphasize 1 0" -bd 2 -bg $evv(SNCOLOR) -width 18 -highlightbackground [option get . background {}]
		button $f00.0.o -text "Save Times to file" -command "set pr_rss2 2" -width 18 -highlightbackground [option get . background {}]
		pack $f00.0.sv $f00.0.o -side left -padx 2
		frame $f00.1
		button $f00.1.i -text "Use Times from Textfile" -command "set pr_rss2 3" -width 24 -highlightbackground [option get . background {}]
		checkbutton $f00.1.b -variable emphdat -text "(<-Get)Datafile Name" -command "set pr_rss2 5" -width 20
		entry $f00.1.e -textvariable rss2finam  -width 24
		pack $f00.1.i $f00.1.b $f00.1.e -side left -padx 2 
		if {[info exists released(peakfind)]} {
			frame $f00.2
			button $f00.2.i -text "Derive Times from Sound" -command "set pr_rss2 4" -width 24 -highlightbackground [option get . background {}]
			label $f00.2.ll -text "Output Datafile Name" -width 24
			entry $f00.2.e -textvariable rss2xfinam  -width 24
			pack $f00.2.i $f00.2.ll $f00.2.e -side left -padx 2 
		}
		pack $f00.0 $f00.1 $f00.2 -side top -pady 4

		pack $f00 -side top -fill x -expand true -pady 2

		pack $f2 -side top -pady 2
		frame $f.22 -bg $evv(POINT) -height 1
		pack $f.22 -side top -fill x -expand true -pady 3

		label $f.33 -text "Define Emphasized-Event halfwidth (secs) " -fg $evv(SPECIAL)
		pack $f.33 -side top -pady 2

		label $f.34 -text "ENTER A FIXED VALUE FOR ALL HALFWIDTHS "
		pack $f.34 -side top -pady 2

		entry $f3.e -textvariable rss2hw -width 6
		checkbutton $f3.b -variable emphset -text "Set all widths" -command EvEmphSet
		pack $f3.e $f3.b -side left -padx 2
		pack $f3 -side top -pady 2

		label $f4.ll -text "ENTER DIFFERENT HALFWIDTHS FOR EACH EVENT"
		pack $f4.ll -side top -pady 2
		frame $f4.1
		frame $f4.2
		frame $f4.3
		frame $f4.4
		set n 1
		while {$n <= 5} {
			frame $f4.1.$n
			label $f4.1.$n.ll -text $n -width 2
			entry $f4.1.$n.e -textvariable evemhw($n) -width 6
			set evemhw($n) ""
			pack $f4.1.$n.ll $f4.1.$n.e -side left
			pack $f4.1.$n -side top
			incr n
		}
		while {$n <= 10} {
			frame $f4.2.$n
			label $f4.2.$n.ll -text $n -width 2
			entry $f4.2.$n.e -textvariable evemhw($n) -width 6
			set evemhw($n) ""
			pack $f4.2.$n.ll $f4.2.$n.e -side left
			pack $f4.2.$n -side top
			incr n
		}
		while {$n <= 15} {
			frame $f4.3.$n
			label $f4.3.$n.ll -text $n -width 2
			entry $f4.3.$n.e -textvariable evemhw($n) -width 6
			set evemhw($n) ""
			pack $f4.3.$n.ll $f4.3.$n.e -side left
			pack $f4.3.$n -side top
			incr n
		}
		while {$n <= 20} {
			frame $f4.4.$n
			label $f4.4.$n.ll -text $n -width 2
			entry $f4.4.$n.e -textvariable evemhw($n) -width 6
			set evemhw($n) ""
			pack $f4.4.$n.ll $f4.4.$n.e -side left
			pack $f4.4.$n -side top
			incr n
		}
		pack $f4.1 $f4.2 $f4.3 $f4.4 -side left
		pack $f4 -side top -pady 2
		label $f5.ll -text "RANDOMISE DURATIONS BETWEEN MIN AND MAX VALUES ENTERED ABOVE"
		checkbutton $f5.b -variable emphrand -text "Randomise" -command EvEmphRand
		pack $f5.ll $f5.b -side top -pady 2
		pack $f5 -side top -pady 2
		label $f6.ll -text "CONTROL HALFWIDTH WITH BRKPNTFILE"
		frame $f6.b
		frame $f6.b.b
		radiobutton $f6.b.b.b1 -variable emphbrk -text "Use brkpntfile" -command "EvEmphBrk 0" -width 24 -value 2
		radiobutton $f6.b.b.b2 -variable emphbrk -text "Create brkpntfile" -command "EvEmphBrk 1" -width 24 -value 1
		pack $f6.b.b.b1 $f6.b.b.b2 -side left -padx 2
		frame $f6.b.c
		label $f6.b.c.ll -text "Output Brkfile Name" -width 20
		entry $f6.b.c.e -textvariable emph_fnam -width 24
		pack $f6.b.c.ll $f6.b.c.e -side left -padx 2
		pack $f6.b.b $f6.b.c -side top -pady 2
		pack $f6.ll $f6.b -side top -pady 2
		pack $f6 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_rss2 0}
	}
	set emphdat 0
	set emphset 0
	set emphbrk 0
	set emphrand 0
	set dur $pa($fnam,$evv(DUR))
	set rss2fnam ""
	set rss2hw 0.02
	set pr_rss2 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_rss2
	while {!$finished} {
		tkwait variable pr_rss2
		switch -- $pr_rss2 {
			1 {
				DeleteAllTemporaryFiles
				if {![info exists emphatimes]} {
					Inf "No Event Times Marked"
					continue
				}
				set OK 1
				set kk 0
				if {$emphbrk} {
					if {![file exists $emphfnam]} {
						Inf "No Brkpoint Data Created"
						continue
					}
				} else {
					foreach n [array names evemhw] {
						if {![IsNumeric $evemhw($n)] || ($evemhw($n) <= $evv(FLTERR))} {
							Inf "Invalid Event-Halfwidth $n"
							set OK 0
							break
						}
						incr kk
					}
					if {!$OK} {
						continue
					}
				}
				set rss2w [expr $rss2hw * 2.0]
				if {[string length $rss2fnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				} 
				set outfnam [string tolower $rss2fnam]
				if {![ValidCDPRootname $outfnam]} {
					continue
				}
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Already Exists: Choose A Different Name"
					continue
				}
				set len [llength $emphatimes]
				if {$len <= 0} {
					Inf "No Event Times Specified"	
					continue
				}
				set lastevemhw 0.0
				set lasttime 0.0
				catch {unset envtimes}
				set n 1
				set nn 1
				foreach time $emphatimes {
					if {$emphbrk} {
						set ev_hfw [ReadEmphaBrk $time]
					} else {
						set ev_hfw $evemhw($nn)
					}
					set gap [expr $lastevemhw + $ev_hfw]
					if {[expr $time - $lasttime] > $gap} {
						if {$n == 1} {
							lappend envtimes $lasttime 0.0
						} else {
							lappend envtimes $lasttime 1.0
							lappend envtimes [expr $lasttime + $lastevemhw] 0.0
						}
						lappend envtimes [expr $time - $ev_hfw] 0.0
					} else {
						lappend envtimes $lasttime 1.0
					}
					set lasttime $time
					set lastevemhw $ev_hfw
					incr n
					incr nn
					if {$nn > $kk} {
						set nn 1
					}
				}
				lappend envtimes $time 1.0
				if {[expr $dur - $time] > $lastevemhw} {
					lappend envtimes [expr $time + $lastevemhw] 0.0
				}
				lappend envtimes $dur 0.0
				lappend envtimes [expr $dur + 1.0] 0.0

				Block "Creating Emphasized Sound"
				if [catch {open $emphenv "w"} zit] {
					Inf "Cannot Open Temporary File '$emphenv' To Write Envelope Data"
					UnBlock
					continue
				}
				foreach {time val} $envtimes {
					set line [list $time $val]
					puts $zit $line
				}
				close $zit
				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd loudness 1 $fnam $outfnam $emphenv
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Envelope '[file rootname [file tail $fnam]]': $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Envelope '[file rootname [file tail $fnam]]'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				UnBlock
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					set last_outfile $outfnam
				}
				Inf "File '$outfnam' Has Been Created"
			} 
			2 {
				if {[string length $rss2fnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				} 
				set outfnam [string tolower $rss2fnam]
				if {![ValidCDPRootname $outfnam]} {
					continue
				}
				append outfnam $evv(TEXT_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Already Exists: Choose A Different Name"
					continue
				}
				set len [llength $emphatimes]
				if {$len <= 0} {
					Inf "No Event Times Specified"	
					continue
				}
				if [catch {open $outfnam "w"} zit] {
					Inf "Cannot Open File '$outfnam' To Write Emphasis-Times"
					continue
				}
				foreach tim $emphatimes {
					puts $zit $tim
				}
				close $zit
				if {[FileToWkspace $outfnam 0 0 0 0 1]} {
					set last_outfile $outfnam
				}
				Inf "Times Saved"
			}
			3 {
				set infnam [string tolower $rss2finam]
				if {[string length $infnam] <= 0} {
					Inf "No Input Filename Entered"	
					continue
				}
				if {![ValidCdpFilename [file rootname $infnam] 1]} {
					continue
				}
				set ext [file extension $infnam]
				if {[string length $ext] <= 0} {
					append infnam $evv(TEXT_EXT)
				}
				if {![file exists $infnam] || [file isdirectory $infnam]} {
					Inf "File '$infnam' Does Not Exist"
					continue
				}
				set ftyp [FindFileType $infnam]
				if {![IsAListofNumbers $ftyp]} {
					Inf "File '$infnam' Is Not A List Of Times"
					continue
				}
				if [catch {open $infnam "r"} zit] {
					Inf "Cannot Open File '$infnam' To Read List Of Times"
					continue
				}
				set OK 1
				set cnt 0
				catch {unset outimes}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {[string length $line] <= 0} {
						continue
					}
					set line [split $line]
					foreach item $line {
						set item [string trim $item]
						if {[string length $item] <= 0} {
							continue
						}
						if {![IsNumeric $item]} {
							Inf "File '$infnam' Is Not A List Of Times"
							set OK 0
							break
						}
						if {$cnt == 0} {
							if {$item < 0.0} {
								Inf "Negative Time In File '$infnam'"
								set OK 0
								break
							}
						} else {
							if {$item <= $lastime} {
								Inf "Times Do Not Increase In File '$infnam'"
								set OK 0
								break
							}
						}
						if {$item > $dur} {
							set OK -1
							break
						}
						lappend outimes $item
						set lastime $item
						incr cnt
					}
					if {$OK != 1} {
						break
					}
				}
				close $zit
				if {$OK == 0} {
					continue
				}
				if {![info exists outimes]} {
					Inf "No Valid Data Found In File '$infnam'"
					continue
				}
				set emphatimes $outimes
				Inf "Got Times"
			}
			4 {
				set getfnam [string tolower $rss2xfinam]
				if {[string length $getfnam] <= 0} {
					Inf "No Peakdata Outputfile Name Entered"
					continue
				}
				if {![ValidCDPRootname $getfnam]} {
					continue
				}
				append getfnam $evv(TEXT_EXT)
				if {[file exists $getfnam]} {
					Inf "File '$getfnam' Already Exists: Choose A Different Name"
					continue
				}
				Block "Finding Times of Peaks"
				set cmd [file join $evv(CDPROGRAM_DIR) peakfind]
				lappend cmd peakfind $fnam $getfnam 100 -t0
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Extract Peaks Of '[file rootname [file tail $fnam]]': $CDPidrun"
					catch {unset CDPidrun}
					if {[file exists $getfnam]} {
						catch {file delete $getfnam}
					}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Extract Peaks Of '[file rootname [file tail $fnam]]'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					if {[file exists $getfnam]} {
						catch {file delete $getfnam}
					}
					UnBlock
					continue
				}
				UnBlock
				if {[FileToWkspace $getfnam 0 0 0 0 1] > 0} {
					set last_outfile $getfnam
				}
				if [catch {open $getfnam "r"} zit] {
					Inf "Cannot Open File '$getfnam' To Read Peak Time Data"
					continue
				}
				catch {unset outimes}
				while {[gets $zit line] >= 0} {
					set val [string trim $line]
					if {[string length $val] > 0} {
						lappend outimes $val
					}
				}
				close $zit
				if {![info exists outimes]} {
					Inf "No Valid Data Found In File '$getfnam'"
					continue
				}
				set emphatimes $outimes
				Inf "GOT TIMES"
			}
			5 {
				GetEmphDataFromWkspace
				if {[string length $rss2finam] < 0} {
					set emphdat 0
				}
			}
			0 {
				break
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Various functions to set up emphasis-halfwidths

proc GetEmphDataFromWkspace {} {
	global rss2finam pr_gememphd wl pa evv
	set f .getemphd
	foreach fnam [$wl get 0 end] {
		if {![info exists pa($fnam,$evv(FTYP))]} {
			continue
		}
		set ftyp $pa($fnam,$evv(FTYP))
		if {[IsAListofNumbers $ftyp] || ($ftyp == $evv(POSITIVE_BRKFILE))} {
			lappend fnams $fnam
		}
	}
	if {![info exists fnams]} {
		Inf "No Appropriate Files Found On Workspace"
		set rss2finam ""
		return
	}
	if [Dlg_Create $f "GET EMPHASIS FILE" "set pr_gememphd 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		button $f0.ok -text "Get File" -command "set pr_gememphd 1" -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_gememphd 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f.a -text "Select file from list below" -fg $evv(SPECIAL)
		pack $f.a -side top -pady 2
		Scrolled_Listbox $f.1.ll -width 80 -height 24 -selectmode single
		pack $f.1.ll -side top
		pack $f1 -side top -fill both -expand true
		wm resizable $f 1 1
		bind $f <Return> {set pr_gememphd 1}
		bind $f <Escape> {set pr_gememphd 0}
	}
	$f.1.ll.list delete 0 end
	foreach fnam $fnams {
		$f.1.ll.list insert end $fnam
	}
	set pr_gememphd 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_gememphd
	while {!$finished} {
		tkwait variable pr_gememphd
		if {$pr_gememphd} {
			set i [$f.1.ll.list curselection]
			if {![info exists i] || ($i < 0)} {
				Inf "No File Selected"
				continue
			}
			set rss2finam [$f.1.ll.list get $i]
			break
		} else {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc EvEmphSet {} {
	global evemhw rss2hw emphset evv
	if {![IsNumeric $rss2hw] || ($rss2hw <= $evv(FLTERR))} {
		Inf "Invalid Event-Halfwidth"
		set emphset 0
		return
	}
	set n 1
	while {$n <= 20} {
		set evemhw($n) $rss2hw
		incr n
	}
	set emphset 0
}

proc EvEmphRand {} {
	global evemhw emphrand evv
	set minval 100000.0
	set maxval 0.0
	if {![info exists evemhw]} {
		Inf "No Event-Halfwidth Values Entered"
		set emphrand 0
		return
	}
	foreach name [array names evemhw] {
		if {![IsNumeric $evemhw($name)] || ($evemhw($name) <= $evv(FLTERR))} {
			continue
		} else {
			if {$evemhw($name) < $minval} {
				set minval $evemhw($name)
				set minset 1
			} elseif {$evemhw($name) > $maxval} {
				set maxval $evemhw($name)
				set maxset 1
			}
		}
	}
	if {!([info exists minset] && [info exists maxset])} {
		Inf "You Have Not Set Two Valid Halfwidth Values (Above)"
		set emphrand 0
		return
	}
	set range [expr $maxval - $minval]
	set n 1
	while {$n <= 20} {
		set val [expr rand() * $range]
		set val [expr $minval + $val]
		set evemhw($n) $val
		incr n
	}
	set emphrand 0
}

proc EvEmphBrk {create} {
	global pr_emphbrk emphbrk from_emph emph_brkpnts emph_fnam emphfnam pa wstk wl rememd evv

	if {[string length $emph_fnam] <= 0} {
		Inf "No Output Brkpnt File Name Entered"
		set emphbrk 0
		return
	}
	set emphfnam [string tolower $emph_fnam]
	if {![ValidCDPRootname $emphfnam]} {
		set emphbrk 0
		return
	}
	append emphfnam [GetTextfileExtension brk]
	if {$create} {
		if {[file exists $emphfnam]} {
			set msg "File '$emphfnam' Already Exists: Overwrite It ??"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				set emphbrk 0
				return
			} else {
				set i [LstIndx $emphfnam $wl]
				UpdateIfAMix $emphfnam 1
				if {![DeleteFileFromSystem $emphfnam 0 1]} {
					set msg "Cannot Delete Original File '$emphfnam'"
					set emphbrk 0
					return
				} else {
					DummyHistory $emphfnam "DESTROYED"
					if {$i >= 0} {
						WkspCnt [$wl get $i] -1
						$wl delete $i
						catch {unset rememd}
					}
				}
			}
		}
		set from_emph 1
		Dlg_MakeTextfile 0 0
		unset from_emph
		if {![file exists $emphfnam]} {
			set emphbrk 0
			return
		}
	} else {
		if {![file exists $emphfnam]} {
			Inf "File '$emphnam Does Not Exist"
			set emphbrk 0
			return
		}
	} 
	if {![IsABrkfile $pa($emphfnam,$evv(FTYP))] \
	|| ([expr $pa($emphfnam,$evv(LINECNT)) * 2] != $pa($emphfnam,$evv(NUMSIZE))) \
	|| ($pa($emphfnam,$evv(MINBRK)) < $evv(FLTERR))} {
		Inf "File '$emphfnam' Is Not A Valid Breakpoint File For Emphasis Halfwidth Times (Vals Must Be > 0.0)"
		set emphbrk 0
		return
	}
	if {[file exists $emphfnam]} {
		if [catch {open $emphfnam "r"} zit] {
			Inf "Cannot Open Brkpoint File For Emphasis Halfwidth Times"
			set emphbrk 0
			return
		}
		set emph_brkpnts {}
		while {[gets $zit line] >= 0} {
			set line [string trim $line]
			if {[string length $line] <= 0} {
				continue
			}
			catch {unset nuline}
			set line [split $line]
			foreach item $line {
				set item [string trim $item]
				if {[string length $item] > 0} {
					lappend nuline $item
				}
			}
			set emph_brkpnts [concat $emph_brkpnts $nuline]
		}
		close $zit
		set len [llength $emph_brkpnts] 
		if {($len <= 0) || ![IsEven $len]} {
			Inf "Invalid Data In Brkpoint File For Emphasis Halfwidth Times"
			unset emph_brkpnts
			set emphbrk 0
			return
		}
		if {[lindex $emph_brkpnts 0] != 0.0} {		;#	FORCE VALUE AT ZERO TIME
			set line [0.0 [lindex $emph_brkpnts 1]]
			set emph_brkpnts [concat $emph_brkpnts $line]
		}
	}
}

proc ReadEmphaBrk {readtime} {
	global emph_brkpnts
	set lasttime 0
	set lastval [lindex $emph_brkpnts 1]
	if {$readtime <= 0.0} {
		return $lastval
	}
	foreach {time val} $emph_brkpnts {
		if {$time >= $readtime} {
			if {$time == $readtime} {
				return $val
			}
			set timediff [expr $readtime - $lasttime]
			set timestep [expr $time - $lasttime]
			set timeratio [expr double($timediff)/double($timestep)]
			set valstep [expr ($val - $lastval) * $timeratio]
			set val [expr $lastval + $valstep]
			return $val
		}
		set lasttime $time
		set lastval $val
	}
	return $val		;#	If input time beyond end of brkfile, return lastval in brkfile
}

#---- Matches levels of events isolated-by-silence within a soundfile.

proc MatchIsolates {} {
	global chlist pa evv pr_iso isofnam prg_dun prg_abortd simple_program_messages CDPidrun last_outfile

	if {![info exists chlist] || ([llength $chlist] != 1)} {
		Inf "Put Selected Soundfile On Chosen List"
		return
	}
	set fnam [lindex $chlist 0]
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Put Selected Soundfile On Chosen List"
		return
	}
	set isoenv $evv(DFLT_OUTNAME)
	append isoenv 0 $evv(TEXT_EXT)
	set isoenv2 $evv(DFLT_OUTNAME)
	append isoenv2 1 $evv(TEXT_EXT)
	set f .iso
	if [Dlg_Create $f "MATCH LEVEL OF ISOLATED EVENTS" "set pr_iso 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		button $f0.ok -text "Do Matching" -command "set pr_iso 1" -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_iso 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Outfile name "
		entry $f1.e -textvariable isofnam -width 16
		pack $f1.ll $f1.e -side left -padx 2
		pack $f1 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_iso 0}
		bind $f <Return> {set pr_iso 1}
	}
	set isofnam ""
	set pr_iso 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_iso
	while {!$finished} {
		DeleteAllTemporaryFilesWhichAreNotCDPOutput except $isoenv
		tkwait variable pr_iso
		if {$pr_iso} {
			set outfnam [string tolower $isofnam]
			if {![ValidCDPRootname $outfnam]} {
				continue
			}
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Already Exists: Choose A Different Name"
				continue
			}
			if {![file exists $isoenv]} {
				set cmd [file join $evv(CDPROGRAM_DIR) envel]
				lappend cmd extract 2 $fnam $isoenv 20
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Find Envelope Of '[file rootname [file tail $fnam]]': $CDPidrun"
					catch {unset CDPidrun}
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Find Envelope Of '[file rootname [file tail $fnam]]'"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					continue
				}
			}
			if [catch {open $isoenv "r"} zit] {
				Inf "Cannot Open File '$isoenv' To Read Envelope Of Source Sound"
				continue
			}
			while {[gets $zit line] >= 0} {
				catch {unset nuline}
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				set cnt 0
				foreach item $line {
					if {[string length $item] <= 0} {
						continue
					}
					lappend env $item
				}
			}
			close $zit
			set n 0
			set ingap 1
			catch {unset maxloc}
			foreach {time val} $env {	;#	FIND LOCAL MAXIMA OF PEAKS
				if {$val <= 0.0} {
					if {!$ingap} {
						set maxloc($n) $maxamp
						incr n
						set ingap 1
					}
				} else {
					if {$ingap} {
						set maxamp $val
						set ingap 0
					} else {
						if {$val > $maxamp} {
							set maxamp $val
						}
					}
				}
			}
			if {$val > 0.0} {			;#	STORE FINAL VAL IF ENVELOPE NOT ZERO AT END
				set maxloc($n) $maxamp
			}
			set len $n
			set locmax $maxloc(0)
			set n 1
			while {$n < $len} {
				if {$maxloc($n) > $locmax} {	;#	FIND GLOBAL  MAX VALUE
					set locmax $maxloc($n)
				}
				incr n
			}
			set n 0
			while {$n < $len} {					;#	NORMALISE LOCAL-PEAK MAX VALUES
				set maxloc($n) [expr $maxloc($n)/$locmax]
				incr n
			}
			catch {unset nuvals}
			set ingap 1	
			set n 0
			foreach {time val} $env {			;#	CREATE ENVELOPE TO MAKE ORIG-ENVELOPE-PEAKS EQUAL
				if {$val <= 0.0} {
					if {!$ingap} {
						incr n
						set ingap 1
					}
					set val 1.0
				} else {
					if {$ingap} {
						set ingap 0
					}
					set val [expr 1.0/$maxloc($n)]
				}
				lappend nuvals $time $val
			}
			if [catch {open $isoenv2 "w"} zit] {
				Inf "Cannot Open File '$isoenv2' To Write Envelope To Apply To Source Sound"
				continue
			}
			foreach {time val} $nuvals {
				puts $zit [list $time $val]
			}
			close $zit
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd loudness 1 $fnam $outfnam $isoenv2
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Cannot Envelope '[file rootname [file tail $fnam]]': $CDPidrun"
				catch {unset CDPidrun}
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Cannot Envelope '[file rootname [file tail $fnam]]'"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				continue
			}
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				set last_outfile $outfnam
			}
			Inf "File '$outfnam' Has Been Created"
		} else {
			break
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Get an envelope by first getting a precise envelope and then time-averaging it, then 

proc TimeAveragedEnvelope {} {
	global newenvfnam pr_newenv newenvsmall newenvlarge newenvdflt newenv_x newenv_max
	global blist_change background_listing rememd CDPidrun prg_dun simple_program_messages prg_abortd wstk wl chlist pa evv
	global maxsamp_line CDPmaxId done_maxsamp last_outfile

	set i [$wl curselection]
	if {([llength $i] > 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			if {($i < 0) && ([$wl index end] >= 0)} {
				set fnam [$wl get 0]
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					Inf "'$fnam' Is Not A Soundfile"
					return
				}
				set newei 0
			} else {
				Inf "Select A Single Workspace Soundfile"
				return
			}
		} else {
			set fnam [lindex $chlist 0]
			set newei [LstIndx $fnam $wl]
			if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
				Inf "'$fnam' Is Not A Soundfile"
				return
			}
		}
	} else {
		set newei $i
		set fnam [$wl get $i]
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			if {![info exists chlist] || ([llength $chlist] != 1)} {
				Inf "'$fnam' Is Not A Soundfile"
				return
			} else {
				set fnam [lindex $chlist 0]
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					Inf "'$fnam' Is Not A Soundfile"
					return
				}
				set newei [LstIndx $fnam $wl]
			}
		}
	}
	if {[info exists newei]} {
		$wl selection set $newei
	}
	DeleteAllTemporaryFiles
	set smallenv $evv(DFLT_OUTNAME)
	append smallenv 0 $evv(TEXT_EXT)
	set largenv $evv(DFLT_OUTNAME)
	append largenv 1 $evv(TEXT_EXT)
	set taetest $evv(DFLT_OUTNAME)
	append taetest 2 $evv(SNDFILE_EXT)
	set taenv $evv(DFLT_OUTNAME)
	append taenv 2 $evv(TEXT_EXT)
	set evv(NEWENVDFLT) 50
	set f .newenv
	if [Dlg_Create $f "EXTRACT TIME-AVERAGED ENVELOPE" "set pr_newenv 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.ok -text "Create Envelope" -command "set pr_newenv 1" -highlightbackground [option get . background {}]
		button $f0.sv -text "SndView Only" -command "SnackDisplay 0 $evv(SN_FROM_SMOOTHER_NO_OUTPUT) 0 $fnam" -bd 2 -bg $evv(SNCOLOROFF) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_newenv 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.sv -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		radiobutton $f1.0 -variable newenvdflt -text "Default" -value 1 -command "set newenvsmall $evv(NEWENVDFLT); set newenvdflt 0"
		label $f1.ll1 -text "Original Envsize (mS) "
		entry $f1.e1 -textvariable newenvsmall -width 8
		label $f1.ll2 -text "Averaged Envsize (mS) "
		entry $f1.e2 -textvariable newenvlarge -width 8
		pack $f1.0 $f1.ll1 $f1.e1 $f1.ll2 $f1.e2 -side left -padx 2
		pack $f1 -side top -pady 2
		label $f2.ll1 -text "Expansion (>=1) "
		entry $f2.e1 -textvariable newenv_x -width 8
		label $f2.ll2 -text "Max Level (>0-1) "
		entry $f2.e2 -textvariable newenv_max -width 8
		pack $f2.ll1 $f2.e1 $f2.ll2 $f2.e2 -side left -padx 2
		pack $f2 -side top -pady 2
		label $f3.ll -text "Outfile name "
		entry $f3.e -textvariable newenvfnam -width 16
		pack $f3.ll $f3.e -side left -padx 2
		pack $f3 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_newenv 0}
		bind $f <Return> {set pr_newenv 1}
	}
	set newenvdflt 0
	if {![info exists newenvsmall]} {
		set newenvsmall $evv(NEWENVDFLT)
	}
	if {![info exists newenvlarge]} {
		set newenvlarge 2000
	}
	set newenvfnam ""
	set pr_newenv 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_newenv
	while {!$finished} {
		tkwait variable pr_newenv
		if {$pr_newenv} {
			if {[string length $newenvfnam] <= 0} {
				Inf "No Output File Name Entered"
				continue
			} 
			set ofnam [string tolower $newenvfnam]
			if {![ValidCDPRootname $ofnam]} {
				continue
			}
			append ofnam $evv(SNDFILE_EXT)
			if {[file exists $ofnam]} {
				set msg "File '$ofnam' Already Exists. Overwrite It?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				set i [LstIndx $ofnam $wl]
				set blist_change 0
				if {![DeleteFileFromSystem $ofnam 0 1]} {
					Inf "Cannot Delete Existing File '$ofnam'"
					continue
				} else {
					DummyHistory $ofnam "DESTROYED"
					if {[IsInAMixfile $ofnam]} {
						if {[MixM_ManagedDeletion $ofnam]} {
							MixMStore
						}
					}
					if {$blist_change} {
						SaveBL $background_listing
					}
					if {$i >= 0} {
						WkspCnt [$wl get $i] -1
						$wl delete $i
						catch {unset rememd}
					}
				}
			}
			if {![IsNumeric $newenvsmall] || ($newenvsmall <= 0)} {
				Inf "Invalid Original Envsize"
				continue
			} 
			if {![IsNumeric $newenvlarge] || ($newenvlarge <= 0)} {
				Inf "Invalid Averaged Envsize"
				continue
			} 
			if {$newenvlarge <= [expr $newenvsmall * 2.0]} {
				Inf "Averaged Envsize Too Small Relative To Original Envsize"
				continue
			} 
			if {![IsNumeric $newenv_x] || ($newenv_x < 1.0)} {
				Inf "Invalid Expansion (>= 1.0)"
				continue
			} 
			if {![IsNumeric $newenv_max] || ($newenv_max < $evv(FLTERR)) || ($newenv_max > 1.0)} {
				Inf "Invalid Maximum (>0-1)"
				continue
			}
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd "extract" 2 $fnam $smallenv $newenvsmall -d0.0002
			Block "EXTRACTING ORIGINAL ENVELOPE FROM '$fnam'"
			set CDPidrun 0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "$CDPidrun : Original Envelope Extraction Failed"
				DeleteAllTemporaryFiles
				UnBlock
				break
			} else {
	   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Original Envelope Extraction Failed"
				set msg [AddSimpleMessages $msg]
				Inf $msg
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			if {![file exists $smallenv]} {
				Inf "Cannot Find Output Envelope File '$smallenv' To Do Time-Averaging"
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			UnBlock
			if [catch {open $smallenv "r"} zit] {
				Inf "Cannot Open Envelope File '$smallenv' To Do Time-Averaging"
				continue
			}
			set OK 1
			set smallwincnt 0
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				set cnt 0
				foreach item $line {
					if {[string length $item] <= 0} {
						continue
					}
					if {![IsNumeric $item]} {
						Inf "Invalid Original Envelope File Extracted"
						set OK 0
						break
					}
					if {$cnt == 0} {
						if {$smallwincnt == 0} {
							if {$item < 0.0} {
								Inf "Invalid Time Value In Envelope File"
								set OK 0
								break
							}
						} else {
							if {$item <= $lasttime} {
								Inf "Times Do Not Increase In Originally Extracted Envelope File"
								set OK 0
								break
							}
						}
						set lasttime $item
					} else {
						lappend vals $item
					}
					lappend invals $item
					incr cnt
				}
				if {!$OK} {
					break
				}
				if {$cnt != 2} {
					Inf "Invalid Line In Originally Extracted Envelope File"
					set OK 0
					break
				}
				incr smallwincnt
			}
			close $zit
			if {!$OK} {
				continue
			}
			if {$smallwincnt <= 0} {
				Inf "Invalid Original Envelope File Extracted"
				continue
			}
			set shrinkratio [expr int(round(double($newenvlarge)/double($newenvsmall)))]	;#	Window averaging value
			if {[IsEven $shrinkratio]} {
				incr shrinkratio
			}
			if {$smallwincnt < $shrinkratio} {
				Inf "File Too Short To Average Envelope With These Parameters"
				continue
			}
			set halfsmallwin [expr $shrinkratio / 2]
			set lastlargewin [expr $smallwincnt - 1 - $halfsmallwin]
			set lastsmallwin [expr $smallwincnt - 1]
			set n $halfsmallwin
			while {$n <= $lastlargewin} {						;#	Do smoothing where there are a valid number of windows
				set endwin   [expr $n + $halfsmallwin]	
				set startwin [expr $n - $halfsmallwin]	
				set envsum 0.0
				set j 0
				set k $startwin
				while {$k <= $endwin} {
					set envsum [expr $envsum + [lindex $vals $k]]
					incr k
					incr j
				}
				set outval [expr $envsum / double($j)]
				if {[string first "e" $outval] >= 0} {
					set outval 0.0
				}
				lappend outvals $outval
				incr n
			}
			set startval [lindex $outvals 0]
			set k 0
			catch {unset zort}
			while {$k < $halfsmallwin} {						;#	Smooth to edges
				lappend zort $startval
				incr k
			}
			set outvals [concat $zort $outvals]

			set endval [lindex $outvals end]
			set k 0
			catch {unset zort}
			while {$k < $halfsmallwin} {
				lappend zort $endval
				incr k
			}
			set outvals [concat $outvals $zort]

			set smoothvals $outvals
			set newenv_xx [expr ($newenv_x - 1.0)/$newenv_x]
			set maxval 0.0
			catch {unset vals}
			foreach val $smoothvals {
				if {$val > $maxval} {
					set maxval $val
				}
				lappend vals $val
			}
			if {$maxval <= $evv(FLTERR)} {
				Inf "Envelope Levels Too Low To Do Expansion"
				break
			}
			set newenv_scale [expr $newenv_max / $maxval]	;#	Scales up final envelope to required max level  

			catch {unset expvals}
			foreach val $vals {
				set val [expr $val / $maxval]			;#	Normalise
				set valtop [expr 1.0 - $val]			;#	Get distance from top
				if {$valtop <= 0.0} {					;#	If a maximum, set
					set val $maxval						;#		else
				} else {								;#	squeeze distance from top
					set valtop [expr $valtop * $newenv_xx]
					set val [expr $val + $valtop]		;#	add this to orig value
					set val [expr $val * $newenv_max]	;#	Scale to required max outlevel
					set val [expr $val * $maxval]		;#	Scale to required max outlevel
				}
				if {[string first "e" $val] >= 0} {
					set val 0.0
				}
				lappend expvals $val					;#	This produces a desired expanded envelope
			}
			catch {unset outvals}
			set haszeros 0
			foreach sval $smoothvals eval $expvals {	;#	Now generate a smoothing envelope by dividing expanded env by non-expanded env
				if {$sval < $evv(FLTERR)} {
					set outval 0.0
					set haszeros 1
				} else {
					set outval [expr $eval / $sval]
				}
				lappend outvals $outval
			}
			set zeros_from_timezero 0					;#	Smooth zeros!!
			if {$haszeros} {
				set cnt 0
				set subcnt -1
				set len [llength $outvals]
				set len_less_one [expr $len - 1]
				while {$cnt < $len} {
					set val [lindex $outvals $cnt]
					if {$val <= 0.0} {											;#	If there's a zero value in envelope
						if {$cnt == 0} {										;#	If at time zero, mark it, and keep it
							set zeros_from_timezero 1
							incr cnt
							continue
						} 
						if {($cnt != $len_less_one) && !$zeros_from_timezero} {	;#	If not at last entry, and don't have all zeros up to here from time-zero
							set preval [lindex $outvals $subcnt]				;#	Note previous non-zero value
							set k $cnt
							incr k												
							while {$k < $len} {									;#	Search from here for next non-zero value
								set postval [lindex $outvals $k]
								if {$postval > 0.0} {							;#	Once we find a non-zero value in the future
									set diff [expr $postval - $preval]			;#	interpolate across the (set of) zero(s)
									set step [expr $k - $cnt + 1]
									set step [expr $diff / double($step)]
									set interpend $k
									set j $cnt
									set thisval $preval
									while {$j < $interpend} {
										set thisval [expr $thisval + $step]
										set outvals [lreplace $outvals $j $j $thisval]
										incr j
									}
									set cnt $interpend							;#	Set the loop pointer to after the interp									
									break										;#	and continue looking for zeros in future	
								}
								incr k
							}													
							if {$k == $len} {									;#	If we've got to end without encountering a non-zero value.
								break											;#	Keep all these terminal zeros
							}
						}															
					} else {													;#	Once we encounter a non-zero value 	
						set zeros_from_timezero 0								;#	unset 'zeros_from_timezero' flag
					}
					incr cnt
					incr subcnt
				}
			}
			foreach {time inval} $invals outval $outvals {
				set nuval [list $time $outval]
				lappend nuvals $nuval
			}
			if [catch {open $largenv "w"} zit] {
				Inf "Failed To Open File '$largenv' To Write Envelope"
				continue
			}
			foreach line $nuvals {
				puts $zit $line
			}
			close $zit

			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd "impose" 3 $fnam $largenv $taetest
			Block "Initial Smoothing Of '$fnam'"
			set CDPidrun 0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "$CDPidrun : Initial Smoothing Failed"
				DeleteAllTemporaryFiles
				UnBlock
				break
			} else {
	   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Initial Smoothing Failed"
				set msg [AddSimpleMessages $msg]
				Inf $msg
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			if {![file exists $taetest]} {
				Inf "Cannot Find Initial Smoothed File '$taetest'"
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			UnBlock

			catch {unset maxsamp_line}
			Block "Finding Max Sample In Initially Smoothed File"
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			if {[ProgMissing $cmd "'maxsamp2$evv(EXEC)' Is Not On Your System. Cannot Search For Maximum Samples In File."]} {
				UnBlock
				break
			}
			catch {unset maxsamp_line}
			set done_maxsamp 0
			lappend cmd $taetest
			if [catch {open "|$cmd"} CDPmaxId] {
				Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
				UnBlock
				break
	   		} else {
	   			fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
			}
	 		vwait done_maxsamp
			if {![info exists maxsamp_line]} {
				Inf "Cannot Retrieve Maximum Sample Information For '$taetest'"
				UnBlock
				continue
			}
			UnBlock
			set maxoutsamp [lindex $maxsamp_line 0]
			if {$maxoutsamp < $evv(FLTERR)} {
				Inf "Insufficient Level In Initially Enveloped Outfile"
				break
			}
			set newenv_scale [expr $newenv_max / $maxoutsamp]
			catch {unset nuvals}
			foreach {time inval} $invals outval $outvals {
				set outval [expr $outval * $newenv_scale]
				set nuval [list $time $outval]
				lappend nuvals $nuval
			}
			if [catch {file delete $largenv} zit] {
				Inf "Cannot Delete Initial Enveloping File"
				break
			}
			if [catch {open $largenv "w"} zit] {
				Inf "Failed To Open File '$largenv' To Write Final Envelope"
				continue
			}
			foreach line $nuvals {
				puts $zit $line
			}
			close $zit

			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd "impose" 3 $fnam $largenv $ofnam
			Block "Final Smoothing Of '$fnam'"
			set CDPidrun 0
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "$CDPidrun : Final Smoothing Failed"
				DeleteAllTemporaryFiles
				UnBlock
				break
			} else {
	   			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Final Smoothing Failed"
				set msg [AddSimpleMessages $msg]
				Inf $msg
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			if {![file exists $ofnam]} {
				Inf "Cannot Find Smoothed File '$ofnam'"
				DeleteAllTemporaryFiles
				UnBlock
				break
			}
			UnBlock
			if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
				Inf "File '$ofnam' Is On The Workspace"
				set last_outfile $ofnam
			} else {
				Inf "File '$ofnam' Is In The Base Directory"
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Isolate peak in file(s), using an envelope

proc IsolatePeak {} {
	global chlist iarisetime last_outfile pr_ia iahw iatag prg_dun prg_abortd simple_program_messages CDPidrun pa evv

	set iarisetime_dflt 0.01	;#	RISE TIME TO PEAK
	set aiwin 10.0				;#	WINDOW SIZE FOR PEAK EXTRACTION
	if {![info exists chlist] || ([llength $chlist] < 0)} {
		Inf "Put Selected Soundfiles On Chosen List"
		return
	}
	foreach fnam $chlist {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Soundfiles Only"
			return
		}
	}
	if {![info exists iarisetime]} {
		set iarisetime $iarisetime_dflt
	}
	set f .isopeak
	if [Dlg_Create $f "ISOLATE PEAK" "set pr_ia 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.ok -text "Isolate" -command "set pr_ia 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_ia 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Attack halfwidth (secs) "
		entry $f1.e -textvariable iahw -width 6
		pack $f1.ll $f1.e -side left -padx 2
		pack $f1 -side top -pady 2
		label $f2.ll -text "Envelope risetime "
		entry $f2.e -textvariable iarisetime -width 6
		pack $f2.ll $f2.e -side left -padx 2
		pack $f2 -side top -pady 2
		label $f3.ll -text "Outfile tag (added to infile name(s)) "
		entry $f3.e -textvariable iatag -width 16
		pack $f3.ll $f3.e -side left -padx 2
		pack $f3 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_ia 0}
		bind $f <Return> {set pr_ia 1}
	}
	set iatag ""
	set iahw 0.02
	set pr_ia 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_ia
	while {!$finished} {
		tkwait variable pr_ia
		switch -- $pr_ia {
			1 {
				DeleteAllTemporaryFiles
				if {![IsNumeric $iahw] || ($iahw < 0)} {
					Inf "Invalid Event-Halfwidth ($iahw)"
					continue
				}
				set peakwidth [expr $iahw * 2.0]
				if {![IsNumeric $iarisetime] || ($iarisetime < 0.001)} {
					Inf "Invalid Envelope Risetime (Must Be >= 0.001 secs)"
					continue
				}
				if {[string length $iatag] <= 0} {
					Inf "No Output Filename Tag"
					continue
				} 
				set iatag [string tolower $iatag]
				if {![regexp {^[a-z0-9]+$} $iatag]} {
					Inf "Name Tag Must Contain Only Letters And/Or Numbers"
					continue
				}
				set OK 1
				catch {unset iadur}
				catch {unset badfiles}
				set mindur [expr $peakwidth + (2 * $iarisetime)]
				set cnt 0
				foreach fnam $chlist {
					set outfnam [file rootname [file tail $fnam]]
					append outfnam "_" $iatag $evv(SNDFILE_EXT)
					if {[file exists $outfnam]} {
						Inf "File '$outfnam' Already Exists: Choose A Different Tag"
						set OK 0
						break
					}
					set iadur($fnam) $pa($fnam,$evv(DUR))
					if {$iadur($fnam) <= $mindur} {
						lappend badfiles $fnam
					}
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam $cnt $evv(TEXT_EXT)
					if {[file exists $envfnam]} {
						Inf "Temporary File '$envfnam' Already Exists: Cannot Proceed"
						set OK 0
						break
					}
					incr cnt
				}
				if {!$OK} {
					continue
				}
				if {[info exists badfiles]} {
					set msg "The Following Files Are Too Short (With Added Risetimes) For The Attack-Width Specified\n\n"
					set cnt 0
					foreach badf $badfiles {
						append msg $badf "\n"
						incr cnt
						if {$cnt >= 20} {
							append msg "AND MORE"
							break
						}
					}
					Inf $msg
					continue
				}
				if {![info exists iapeak]} {
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam 00 $evv(TEXT_EXT)
					set OK 1
					Block "Finding All File Peaks"
					foreach fnam $chlist {
						if {[file exists $envfnam]} {
							if [catch {file delete $envfnam} zit] {
								Inf "Cannot Delete Temporary Envelope File '$envfnam' Used For Finding File Peaks"
								set OK 0
								break
							}
						}
						set CDP_cmd [file join $evv(CDPROGRAM_DIR) envel]
						lappend CDP_cmd "extract" 2 $fnam $envfnam $aiwin -d0.0002
						set CDPidrun 0
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$CDP_cmd"} CDPidrun] {
							Inf "$CDPidrun : Peak Extraction Failed For File '[file rootname [file tail $fnam]]'"
							set OK 0
							break
						} else {
	   						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Peak Extraction Failed For File '$fnam'"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						if {![file exists $envfnam]} {
							Inf "Cannot Find Output Envelope File '$envfnam' To Extract Peaks Of File '[file rootname [file tail $fnam]]'"
							set OK 0
							break
						}
						if [catch {open $envfnam "r"} zit] { 
							Inf "Cannot Open Temporary Envelope File To Read Peaks Of File '[file rootname [file tail $fnam]]'"	
							set OK 0
							break 
						}
						
						;#	EXTRACT PEAK TIME IN ENVELOPE DATA
						catch {unset times}
						catch {unset vals}
						while {[gets $zit line] >= 0} {
							set line [string trim $line]
							if {[string length $line] <= 0}  {
								continue
							}
							catch {unset nuline}
							foreach item $line {
								set item [string trim $item]
								if {[string length $item] >= 0} {
									lappend nuline $item
								}
							}
							if {![info exists nuline] || ([llength $nuline] != 2)} {
								Inf "Invalid Data In Peak-Search Envelope File For File '[file rootname [file tail $fnam]]'"	
								close $zit
								set OK 0
								break 
							}
							lappend times [lindex $nuline 0]
							lappend vals  [lindex $nuline 1]
						}
						if {!$OK} {
							break
						}
						close $zit
						if {![info exists times]}  {
							Inf "Invalid Data In Peak-Search Envelope File For File '[file rootname [file tail $fnam]]'"	
							set OK 0
							break 
						}
						set peakval [lindex $vals 0]
						set peaktime [lindex $times 0]
						set cnt 1
						foreach val [lrange $vals 1 end] {
							if {$val > $peakval} {
								set peakval $val
								set peaktime [lindex $times $cnt]
							}
							incr cnt
						}
						set iapeak($fnam) $peaktime
					}
					UnBlock
					if {!$OK} {
						break
					}
				}
				set risedur [expr $iarisetime + $iahw]
				set cnt 0
				Block "WRITING ENVELOPING FILES"
				foreach fnam $chlist {
					catch {unset iaenvtimes}
					set sttrise [expr $iapeak($fnam) - $risedur]
					set endrise [expr $iapeak($fnam) - $iahw]
					set sttfall [expr $iapeak($fnam) + $iahw]
					set endfall [expr $iapeak($fnam) + $iahw + $risedur]
					set endtime [expr $iadur($fnam) + 1.0]
					if {$sttrise <= 0.0} {
						lappend iaenvtimes 0.0 1.0
					} else {
						lappend iaenvtimes 0.0 0.0
						lappend iaenvtimes $sttrise	0.0
						lappend iaenvtimes $endrise	1.0
					}
					if {$endfall >= $iadur($fnam)} {
						lappend iaenvtimes $endtime 1.0
					} else {
						if {$iahw > 0.0} {
							lappend iaenvtimes $sttfall	1.0
						}
						lappend iaenvtimes $endfall	0.0
						lappend iaenvtimes $endtime 0.0
					}
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam $cnt $evv(TEXT_EXT)
					if [catch {open $envfnam "w"} zit] {
						Inf "Cannot Open Temporary File '$envfnam' To Write Envelope Data For '[file rootname [file tail $fnam]]'"
						incr cnt
						continue
					}
					foreach {time val} $iaenvtimes {
						set line [list $time $val]
						puts $zit $line
					}
					close $zit
					incr cnt
				}
				UnBlock
				set cnt 0
				set done 0
				Block "ISOLATING PEAKS"
				foreach fnam $chlist {
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam $cnt $evv(TEXT_EXT)
					if {![file exists $envfnam]} {
						incr cnt
						continue
					}
					set outfnam [file rootname [file tail $fnam]]
					append outfnam "_" $iatag $evv(SNDFILE_EXT)

					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $fnam $outfnam $envfnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Envelope '[file rootname [file tail $fnam]]': $CDPidrun"
						catch {unset CDPidrun}
						incr cnt
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Envelope '[file rootname [file tail $fnam]]'"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						incr cnt
						continue
					}
					if {!$done} {
						catch {unset last_outfile}						
					}
					lappend last_outfile $outfnam
					set done 1
					FileToWkspace $outfnam 0 0 0 0 1
					incr cnt
				}
				UnBlock 
				if {$done} {
					Inf "Files Have Been Created"
					break
				}
			}
			0 {
				break
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Isolate pitches in file(s), using an envelope

proc IsolatePitches {} {
	global chlist iprisetime last_outfile pr_ip iptag ipval prg_dun prg_abortd simple_program_messages CDPidrun ipinv pa evv

	set iprisetime_dflt 0.01	;#	RISE TIME TO PITCH
	if {![info exists iprisetime]} {
		set iprisetime $iprisetime_dflt
	}
	if {![info exists chlist] || ([llength $chlist] < 0)} {
		Inf "Put Selected Soundfiles On Chosen List"
		return
	}
	foreach fnam $chlist {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Soundfiles Only"
			return
		}
		set vfiltdata($fnam) [GetMonophonicPairedValueMidiVarifiltFile $fnam]
		if {[llength $vfiltdata($fnam)] > 0} {
			lappend dolist $fnam
		}
	}
	if {![info exists dolist]} {
		Inf "None Of These Files Have Appropriate Varibank Filter Data Associated With Them"
			return
	}
	set f .isopitch
	if [Dlg_Create $f "ISOLATE PITCHES" "set pr_ip 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		button $f0.ok -text "Isolate" -command "set pr_ip 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		checkbutton $f0.inv -variable ipinv -text "Keep all EXCEPT pitches" -command "set ipinv 1"
		button $f0.quit -text "Quit" -command "set pr_ip 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.inv -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Envelope risetime "
		entry $f1.e -textvariable iprisetime -width 6
		pack $f1.ll $f1.e -side left -padx 2
		pack $f1 -side top -pady 2
		label $f2.ll -text "MIDI PITCHES TO ISOLATE"
		button $f2.clr -text "Clear All" -command ClearIsop -highlightbackground [option get . background {}]
		pack $f2.ll $f2.clr -side left -padx 4
		pack $f2 -side top -pady 2
		set n 1
		while {$n <= 12} {
			frame $f3.$n
			label $f3.$n.ll -text $n -width 2
			entry $f3.$n.e -textvariable ipval($n) -width 6
			button $f3.$n.cl -text Clear -command "set ipval($n) \"\"" -highlightbackground [option get . background {}]
			set ipval($n) ""
			pack $f3.$n.ll $f3.$n.e $f3.$n.cl -side left
			pack $f3.$n -side top
			incr n
		}
		pack $f3 -side top -pady 2
		label $f4.ll -text "Outfile tag (added to infile name(s)) "
		entry $f4.e -textvariable iptag -width 16
		pack $f4.ll $f4.e -side left -padx 2
		pack $f4 -side top -pady 2
		wm resizable $f 1 1
		bind $f <Escape> {set pr_ip 0}
		bind $f <Return> {set pr_ip 1}
	}
	set ipinv 0
	set iptag ""
	set pr_ip 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_ip
	while {!$finished} {
		tkwait variable pr_ip
		switch -- $pr_ip {
			1 {
				DeleteAllTemporaryFiles
				if {![IsNumeric $iprisetime] || ($iprisetime < 0.001)} {
					Inf "Invalid Envelope Risetime (Must Be >= 0.001 secs)"
					continue
				}
				set mindur [expr $iprisetime * 2.0]
				if {[string length $iptag] <= 0} {
					Inf "No Output Filename Tag"
					continue
				} 
				set iptag [string tolower $iptag]
				if {![regexp {^[a-z0-9]+$} $iptag]} {
					Inf "Name Tag Must Contain Only Letters And/Or Numbers"
					continue
				}
				catch {unset ptoget}
				set OK 1
				set n 1
				while {$n <= 12} {
					if {[string length $ipval($n)] > 0} {
						if {![IsNumeric $ipval($n)] || ($ipval($n) < 0.0) || ($ipval($n) > 127.0)} {
							Inf "Invalid Midi Value $n ($ipval($n))"
							set OK 0
							break
						}
					}
					lappend ptoget $ipval($n)
					incr n
				}
				if {!$OK} {
					continue
				}
				if {![info exists ptoget]} {
					Inf "No Midi Pitch Values To Search For"
					continue
				}
				set OK 1
				set cnt 0
				foreach fnam $dolist {
					set outfnam [file rootname [file tail $fnam]]
					append outfnam "_" $iptag $evv(SNDFILE_EXT)
					if {[file exists $outfnam]} {
						Inf "File '$outfnam' Already Exists: Choose A Different Tag"
						set OK 0
						break
					}
					set ipdur($fnam) $pa($fnam,$evv(DUR))
					if {$ipdur($fnam) <= $mindur} {
						Inf "File '$fnam' Is Too Short For The Envelope Risetimes Specified"
						set OK 0
						break
					}
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam $cnt $evv(TEXT_EXT)
					if {[file exists $envfnam]} {
						Inf "Temporary File '$envfnam' Already Exists: Cannot Proceed"
						set OK 0
						break
					}
					incr cnt
				}
				if {!$OK} {
					continue
				}
				set cnt 0
				Block "WRITING ENVELOPING FILES"
				catch {unset nudolist}
				foreach fnam $dolist {
					set endtime [expr $ipdur($fnam) + 1.0]
					set endlimit [expr $ipdur($fnam) - $iprisetime]
					set inpitches 0
					catch {unset ipenvtimes}
					set lastofftime -1
					foreach {time midival} $vfiltdata($fnam) {
						if {[lsearch $ptoget $midival] >= 0} {	;#	IF THIS IS ONE OF THE DESIRED PITCHES
							if {!$inpitches} {			
								set thisontime [expr $time - $iprisetime]
								if {![info exists ipenvtimes]} {
									if {$thisontime <= 0.0} {
										lappend ipenvtimes 0.0 1.0
									} else {	
										lappend ipenvtimes 0.0 0.0
										lappend ipenvtimes $thisontime 0.0
										lappend ipenvtimes $time 1.0
									}
								} else {
									if {$thisontime <= $lastofftime} {
										set len [llength $ipenvtimes]
										incr len -3		;#	DELETE LAST OFF-POINT IF TOO CLOSE
										set ipenvtimes [lrange $ipenvtimes 0 $len]
										lappend ipenvtimes $time 1.0
									} else {
										lappend ipenvtimes $thisontime 0.0
										lappend ipenvtimes $time 1.0
									}
								}
								set inpitches 1
							}
						} else {
							if {$inpitches} {
								set lastofftime [expr $time + $iprisetime]
								if {$lastofftime > $endlimit} {
									lappend ipenvtimes $endtime 1.0
									break
								} else {	
									lappend ipenvtimes $time 1.0
									lappend ipenvtimes $lastofftime 0.0
								}
								set inpitches 0
							}
						}
					}
					if {![info exists ipenvtimes]} {
						continue
					}
					set OK 0
					foreach {time val} $ipenvtimes {
						if {$val > 0.0} {
							set OK 1
							break
						}
					}
					if {!$OK} {
						continue
					}
					set len [llength $ipenvtimes]
					incr len -2
					if {[lindex $ipenvtimes $len] != $endtime} {
						incr len
						set lastval [lindex $ipenvtimes $len]
						lappend ipenvtimes $endtime $lastval
					}
					if {$ipinv} {
						catch {unset invvals}
						foreach {time val} $ipenvtimes {
							if {$val == 0.0} {
								lappend invvals $time 1.0
							} else {
								lappend invvals $time 0.0
							}
						}
						set ipenvtimes $invvals
					}
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam $cnt $evv(TEXT_EXT)
					if [catch {open $envfnam "w"} zit] {
						Inf "Cannot Open Temporary File '$envfnam' To Write Envelope Data For '[file rootname [file tail $fnam]]'"
						set finished 1
						break
					}
					foreach {time val} $ipenvtimes {
						set line [list $time $val]
						puts $zit $line
					}
					close $zit
					lappend nudolist $fnam
					incr cnt
				}
				UnBlock
				if {$finished} {
					break
				}
				if {![info exists nudolist]} {
					Inf "None Of These Files Contain These Pitches"
					break
				}
				set dolist $nudolist
				set cnt 0
				set done 0
				Block "ISOLATING PITCHES"
				foreach fnam $dolist {
					set envfnam $evv(DFLT_OUTNAME)
					append envfnam $cnt $evv(TEXT_EXT)
					if {![file exists $envfnam]} {
						incr cnt
						continue
					}
					set outfnam [file rootname [file tail $fnam]]
					append outfnam "_" $iptag $evv(SNDFILE_EXT)

					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $fnam $outfnam $envfnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Envelope '[file rootname [file tail $fnam]]': $CDPidrun"
						catch {unset CDPidrun}
						incr cnt
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot Envelope '[file rootname [file tail $fnam]]'"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						incr cnt
						continue
					}
					if {!$done} {
						catch {unset last_outfile}						
					}
					lappend last_outfile $outfnam
					set done 1
					FileToWkspace $outfnam 0 0 0 0 1
					incr cnt
				}
				UnBlock 
				if {$done} {
					Inf "Files Have Been Created"
					break
				}
			}
			0 {
				break
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc ClearIsop {} {
	global ipval
	set n 1
	while {$n <= 12} {
		set ipval($n) ""
		incr n
	}
}

#--- Check syntax of a monophonic varibank filter file

proc GetMonophonicPairedValueMidiVarifiltFile {fnam} {
	global evv 
	set fltfnam [file rootname $fnam]
	append fltfnam $evv(FILT_TAG) $evv(TEXT_EXT)
	if {![file exists $fltfnam]} {
		Inf "Varibank Filter File ($fltfnam) Corresponding To Soundfile '$fnam' Does Not Exist"
		return {}
	}
	if [catch {open $fltfnam "r"} zit] {
		Inf "Cannot Open File '$ltfnam' To Check It Is A Valid Varibank Filter File"	
		return {}
	}
	set nulines {}
	set linecnt 1
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		set line [split $line]
		catch {unset nuline}
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item]} {
				Inf "Invalid Varibank (Midi) Filter File Line\n\n($line)\n\nIn File '$fltfnam'"
				close $zit
				return {}
			}
			lappend nuline $item
		}
		if {![info exists nuline]} {
			Inf "Invalid (Empty) Varibank (Midi) Filter File Line\n\n($line)\n\nIn File '$fltfnam'"
			close $zit
			return {}
		}
		if {[llength $nuline] != 3} {
			Inf "Varibank (Midi) Filter File Lines Must Have (Just) 3 Values In File '$fltfnam'"
			close $zit
			return {}
		}
		set time [lindex $nuline 0]
		if {$linecnt == 1} {
			if {$time != 0.0} {
				Inf "Invalid First Time Value In File '$fltfnam'"
				close $zit
				return {}
			}
		} elseif {$time <= $lasttime} {
			Inf "Time Value Does Not Advance On Line $linecnt In File '$fltfnam'"
			close $zit
			return {}
		}
		set lasttime $time
		set midival [lindex $nuline 1]
		if {($midival < 0)  || ($midival > 127)} {
			Inf "Invalid Midi Value For Varibank (Midi) Filter File Line\n\n($nuline)\n\nIn File '$fltfnam'"
			close $zit
			return {}
		}
		set ampval [lindex $nuline 2]
		if {($ampval < 0.0)  || ($ampval > 1.0)} {
			Inf "Invalid Amplitude Value For Varibank (Midi) Filter File Line\n\n($nuline)\n\nIn File '$fltfnam'"
			close $zit
			return {}
		}
		set nulines [concat $nulines [lrange $nuline 0 1]]	;#	DITCH AMPLITUDE VALUES
		incr linecnt
	}
	close $zit
	if {$linecnt < 2} {
		Inf "Insufficient Data Lines In Varibank (Midi) Filter File '$fltfnam'"
		return {}
	}
	if {$linecnt > 2} {		;# SMOOTH OUT REPEATED NOTES (i.e. more than 2 of same values in a row)
		set outlist [lrange $nulines 0 1]
		set lastmidi [lindex $nulines 1]
		set endtimindx 0
		foreach {time midival} [lrange $nulines 2 end] {
			if {$midival == $lastmidi} {
				if {[info exists sameval]} {
					set outlist [lreplace $outlist $endtimindx $endtimindx $time]
				} else {
					set sameval $midival
					lappend outlist $midival $time
					incr endtimindx 2 
				}
			} else {
				lappend outlist $time $midival
				incr endtimindx 2
				catch {unset sameval}
				set lastmidi $midival
			}
		}
	}
	return $nulines
}

#----- Retime by editing

proc MMTrim {new} {
	global pr_mmtrim wl chlist mmtrimval mmsynctimes mmtrimfnam mmtrimsplice prg_dun prg_abortd CDPidrun mmtrimtimes wstk pa evv last_outfile
	global done_maxsamp CDPmaxId maxsamp_line simple_program_messages blist_change background_listing rememd mmtrimdove

	set cutsfile $evv(DFLT_OUTNAME)
	append cutsfile 0 $evv(TEXT_EXT)
	set insertsfile $evv(DFLT_OUTNAME)
	append insertsfile 1 $evv(TEXT_EXT)
	set outfnam1 $evv(DFLT_OUTNAME)
	append outfnam1 1 $evv(SNDFILE_EXT)
	set outfnam2 $evv(DFLT_OUTNAME)
	append outfnam2 2 $evv(SNDFILE_EXT)

	set evv(SYLLAB_DOVETAIL) 0.005

	set isrhythm 0
	set OK 0
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
		if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
			set OK 1
		}
	}
	if {!$OK} {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) == $evv(SNDFILE)} {
				set OK 1
			}
		}
	}
	if {!$OK} {
		Inf "Select One Soundfile"
		return
	}
	catch {unset mmtrimtimes}
	set f .mmtrim
	if [Dlg_Create $f "SYNC TO MM" "set pr_mmtrim 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		button $f0.ok -text "Retime" -command "set pr_mmtrim 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.sv -text "Sound View" -command "SnackDisplay $evv(SN_TIMESLIST) mmtrim 0 $fnam" -bd 2 -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		if {$new} {
			button $f0.sd -text "Save Cutdata" -command "set pr_mmtrim 2"
		}
		button $f0.quit -text "Abandon" -command "set pr_mmtrim 0" -highlightbackground [option get . background {}]
		if {$new} {
			pack $f0.ok $f0.sv $f0.sd -side left -padx 2
		} else {
			pack $f0.ok $f0.sv -side left -padx 2
		}
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Mark peaks and troughs using 'Sound View' : start and end with a peak" -fg $evv(SPECIAL)
		pack $f1.ll -side left
		pack $f1 -side top -pady 2
		entry $f2.e -textvariable mmtrimval -width 16
		label $f2.ll -text "MM (20-6000) OR beat dur in secs (0.01 to <1) OR filename (list of times)"
		pack $f2.e $f2.ll -side left -padx 2
		entry $f3.e -textvariable mmtrimsplice -width 16
		label $f3.ll -text " Splice Length (mS) (min 3)"
		pack $f3.e $f3.ll -side left -padx 2
		entry $f4.e -textvariable mmtrimfnam -width 16
		label $f4.ll -text " Output Filename"
		pack $f4.e $f4.ll -side left -padx 2
		if {$new} {
			checkbutton $f4.ch -variable mmtrimdove -text "Syllable dovetailing"
			pack $f4.ch -side right 
		}
		pack $f2 $f3 $f4 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f.2.e <Down> {focus .mmtrim.3.e}
		bind $f.3.e <Down> {focus .mmtrim.4.e}
		bind $f.4.e <Down> {focus .mmtrim.2.e}
		bind $f.2.e <Up> {focus .mmtrim.4.e}
		bind $f.3.e <Up> {focus .mmtrim.2.e}
		bind $f.4.e <Up> {focus .mmtrim.3.e}
		bind $f <Escape> {set pr_mmtrim 0}
		bind $f <Return> {set pr_mmtrim 1}
	}
	if {$new} {
		.mmtrim.1.ll config -text "Mark onsets and troughs using 'Sound View' : start and end with a trough"
		set mmtrimdove 1
	} else {
		.mmtrim.1.ll config -text "Mark peaks and troughs using 'Sound View' : start and end with a peak"
	}
	if {$new} {
		set dfnam [file rootname $fnam]
		append dfnam "_rhythmdata" $evv(TEXT_EXT)
		if {[file exists $dfnam]} {
			set msg "Rhythmicise_data For This File Exists: Load It ?"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				if [catch {open $dfnam "r"} zit] {
					Inf "Cannot Open The Existing Datafile $dfnam"
				} else {
					catch {unset indata}
					set OK 1
					set cnt 0
					while {[gets $zit line] >= 0} {
						set line [string trim $line]
						if {[string length $line] <= 0} {
							continue
						}
						if {[string match [string index $line 0] ";"]} {
							continue
						}
						set line [split $line]
						catch {unset nuline}
						foreach item $line {
							set item [string trim $item]
							if {[string length $item] <= 0} {
								continue
							}
							if {![IsNumeric $item] || ($item < 0.0)} {
								Inf "Value $item Is Not A Valid Time, In File $dfnam"
								set OK 0
								break
							}
							lappend indata $item
							if {$cnt > 0} {
								if {$item <= $lasttime} {
									Inf "Times $item & $lasttime Are Not In Increasing Order, In File $dfnam"
									set OK 0
									break
								}
							}
							set lasttime $item
							incr cnt
						}
						if {!$OK} {
							break
						}
					}
					close $zit
					if {[IsEven $cnt]} {
						Inf "Invalid Data In File $dfnam: Must Be Pairs Of Troughs And Onsets, Plus A Final Trough"
						set OK 0
					} 
					if {$OK} {
						set mmtrimtimes $indata
						Inf "Data Loaded"
					}
				}
			} else {
				set msg "Destroy The Existing Rhythmcise_data ?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					if {![DeleteFileFromSystem $dfnam 0 1]} {
						Inf "Cannot Delete Existing File '$ofnam'"
						continue
					} else {
						DummyHistory $dfnam "DESTROYED"
						set i [LstIndx $dfnam $wl]
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
			}
		}
	}
	set pr_mmtrim 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mmtrim
	while {!$finished} {
		tkwait variable pr_mmtrim
		switch -- $pr_mmtrim {
			1 {
				if {![info exists mmtrimtimes]} {
					Inf "No Synchronising Times Entered (use 'Sound View')"
					continue
				}
				set len [llength $mmtrimtimes]
				if {$new} {
					if {($len < 3) || [IsEven $len]} {
						Inf "Synchronising Times Invalid : Start And End With Trough : Mark Peaks Between Troughs"
						continue
					}
					set evcnt [expr ($cnt-1)/2]
					if {$evcnt > 998} {
						Inf "Too Many Events To Rhythmicise: Max Number Of Events = 998"
						continue
					}
				} else {
					if {($len < 3) || [IsEven $len]} {
						Inf "Synchronising Times Invalid : Start And End With Peak : Mark Troughs Between Peaks"
						continue
					}
					set evcnt [expr ($cnt+1)/2]
				}
				catch {unset rhythm}
				if {![IsNumeric $mmtrimval]} {
					if {![file exists $mmtrimval]} {
						Inf "File $mmtrimval Does Not Exist"
						continue
					}
					if [catch {open $mmtrimval "r"} zit] {
						Inf "Cannot Open File File $mmtrimval"
						continue
					}
					set OK 1
					set cnt 0
					while {[gets $zit line] >= 0} {
						set line [string trim $line]
						if {[string length $line] <= 0} {
							continue
						}
						if {[string match [string index $line 0] ";"]} {
							continue
						}
						set line [split $line]
						foreach item $line {
							set item [string trim $item]
							if {[string length $item] <= 0} {
								continue
							}
							if {![IsNumeric $item] || ($item < 0.0)} {
								Inf "Value $item Is Not A Valid Time, In File $mmtrimval"
								set OK 0
								break
							}
							lappend rhythm $item
							if {$cnt > 0} {
								if {$item <= $lasttime} {
									Inf "Times $item & $lasttime Are Not In Increasing Order, In File $mmtrimval"
									set OK 0
									break
								}
							}
							set lasttime $item
							incr cnt
							if {$cnt >= $evcnt} {
								set OK 0
								break
							}
						}
						if {!$OK} {
							break
						}
					}
					close $zit
					if {$cnt < $evcnt} {
						Inf "Too Few Rhythm Times ($cnt) For The Number Of Events ($evcnt)"
						continue
					}
					set rhcnt $cnt
					set sttrhym [lindex $rhythm 0]
					if {$sttrhym != 0.0} {
						set n 0
						while {$n < $rhcnt} {
							set val [lindex $rhythm $n]
							set val [expr $val - $sttrhym]
							if {$val < 0.0} {
								set val 0.0
							}
							set rhythm [lreplace $rhythm $n $n $val]
							incr n
						}
					}
					set isrhythm 1

				} else {
					if {![IsNumeric $mmtrimval] || ($mmtrimval <= 0.01) || (($mmtrimval >= 1) && ($mmtrimval < 20))} {
						Inf "Invalid MM Value"
						continue
					}
					if {$mmtrimval < 1.0} {
						set mmdur $mmtrimval
					} else {
						set mmdur [expr 60.0 / double($mmtrimval)]
					}
				}
				if	{![IsNumeric $mmtrimsplice] || ($mmtrimsplice < 3) } {
					Inf "Invalid Splice Length"
					continue
				}
				set splen [expr double($mmtrimsplice) * $evv(MS_TO_SECS)]
				if {[string length $mmtrimfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				set mmtrimfnam [string tolower $mmtrimfnam]
				if {![ValidCDPRootname $mmtrimfnam]} {
					continue
				}
				set ofnam $mmtrimfnam
				append ofnam $evv(SNDFILE_EXT)

				if {[file exists $ofnam]} {
					set msg "File $ofnam Already Exists : Overwrite It ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					if {![DeleteFileFromSystem $ofnam 0 1]} {
						Inf "Cannot Delete The Existing File $ofnam"
						continue
					}
					set blist_change 0
					if {![DeleteFileFromSystem $ofnam 0 1]} {
						Inf "Cannot Delete Existing File '$ofnam'"
						continue
					} else {
						DummyHistory $ofnam "DESTROYED"
						if {[IsInAMixfile $ofnam]} {
							if {[MixM_ManagedDeletion $ofnam]} {
								MixMStore
							}
						}
						if {$blist_change} {
							SaveBL $background_listing
						}

						set i [LstIndx $ofnam $wl]
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}

				;#	GET PARAMS FOR CUTS OR INSERTS

				catch {unset cuttimes}
				catch {unset inserttimes}

				if {$new} {
					catch {unset cutsets}
					set trof [lindex $mmtrimtimes 0]
					if {$mmtrimdove} {
						set trof [expr $trof - $evv(SYLLAB_DOVETAIL)]
						if {$trof < 0.0} {
							set trof 0.0
						}
					}
					set xmmtrimtimes [lrange $mmtrimtimes 1 end]
					foreach	{peaktime sniptime} $xmmtrimtimes {
						set endcut $sniptime
						if {$mmtrimdove} {
							set endcut [expr $endcut + $evv(SYLLAB_DOVETAIL)]
							if {$endcut >= $pa($fnam,$evv(DUR))} {
								set endcut [expr $pa($fnam,$evv(DUR)) - $evv(FLTERR)]
							}
						}
						set cutset [list $trof $peaktime $endcut]
						lappend cutsets $cutset
						set trof $sniptime
						if {$mmtrimdove} {
							set trof [expr $trof - $evv(SYLLAB_DOVETAIL)]
							if {$trof < 0.0} {
								set trof 0.0
							}
						}
					}
					DeleteAllTemporaryFilesWhichAreNotCDPOutput text 0
					Block "Retiming Sound"
					if [catch {open $cutsfile "w"} zit] {
						Inf "Cannot Open Temporary Textfile To Write Cut Times Data"
						UnBlock
						continue
					}
					foreach line $cutsets {					;#	LIST STARTTIME AND ENDTIME OF EACH SEGMENT
						set thisline [lindex $line 0]
						lappend thisline [lindex $line 2]
						puts $zit $thisline 
					}
					close $zit

					set cutscnt [llength $cutsets]
					set outfnamgeneric $evv(DFLT_OUTNAME)
					append outfnamgeneric $evv(SNDFILE_EXT)
					set n 1
					while {$n <= $cutscnt} {							;#	SET UP ADDITIONAL OUTFILE NAMES
						set outfnam($n) $evv(DFLT_OUTNAME)
						append outfnam($n) $n $evv(SNDFILE_EXT)
						incr n
					}

					;#	CUT THE ELEMENTS FROM THE SOURCE

					DeleteAllTemporaryFilesWhichAreNotCDPOutput snd 0
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit$evv(EXEC)]
					lappend cmd cutmany 1 $fnam $outfnamgeneric $cutsfile $mmtrimsplice

					set prg_dun 0
					set prg_abortd 0
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Edit Segments From Src File"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Edit Segment(s) From Src File"
						UnBlock
						continue
					}
					set OK 1
					set n 1
					while {$n <= $cutscnt} {
						if {![file exists $outfnam($n)]} {
							Inf "Failed To Generate Segment Number $n"
							set OK 0
							break
						}
						incr n
					}
					if {!$OK} {
						UnBlock
						continue
					}
					
					set firstset  [lindex $cutsets 0]
					set firststrt [lindex $firstset 0]
					set firstpeak [lindex $firstset 1]
					set offset [expr $firstpeak - $firststrt]
					set mmtime $offset
					if {$isrhythm && ($offset > 0.0)} {
						set n 0
						while {$n < $rhcnt} {
							set val [lindex $rhythm $n]
							set val [expr $val + $offset]
							set rhythm [lreplace $rhythm $n $n $val]
							incr n
						}
					}
							
					;#	WRITE THE MIX LINES

					set ochans $pa($fnam,$evv(CHANS))
					set n 1
					catch {unset mixlines}
					foreach cutset $cutsets {					
						foreach	{strttime peaktime sniptime} $cutset {
							set thisoffset [expr $peaktime - $strttime]					
							set thistime [expr $mmtime - $thisoffset]
							if {$thistime < 0.0} {
								set thistime 0.0
							}
							set mixline [list $outfnam($n) $thistime]
							lappend mixline $ochans
							if {$ochans > 2} {
								set k 1
								while {$k <= $ochans} {
									set rout $k
									append rout ":" $k
									lappend mixline $rout
									lappend mixline "1.0"
									incr k
								}
							} else {
								lappend mixline 1.0
							}
						}
						lappend mixlines $mixline
						if {$isrhythm} {
							set mmtime [lindex $rhythm $n]
						} else {
							set mmtime [expr $mmtime + $mmdur]
						}
						incr n
					}
					set mixfile $evv(DFLT_OUTNAME)
					if {$ochans > 2} {
						append mixfile [GetTextfileExtension mmx]
					} else {			
						append mixfile [GetTextfileExtension mix]
					}
					if [catch {open $mixfile "w"} zit] {
						Inf "Cannot Open Mixfile To Set Up Retiming Of Source Segments"
						UnBlock
						continue
					}
					foreach line $mixlines {
						puts $zit $line 
					}
					close $zit

					set outfnam0 $evv(DFLT_OUTNAME)
					append outfnam0 0 $evv(SNDFILE_EXT)

					if {$ochans > 2} {
						set cmd [file join $evv(CDPROGRAM_DIR) newmix]
						lappend cmd multichan $mixfile $outfnam0
					} else {
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd mix $mixfile $outfnam0
					}
					set origcmd $cmd
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}

					wm title .blocker  "Mixing the retimed sequence"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Run The Mix Of The Retimed Sequence"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Mix Retimed Sequence"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					if {![file exists $outfnam0]} {
						Inf "Mixing Retimed Sequence Produced No Output"
						UnBlock
						continue
					}
					wm title .blocker "PLEASE WAIT:        CHECKING LEVEL OF OUTPUT"
					set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
					lappend cmd $outfnam0
					set prg_dun 0
					set prg_abortd 0
					set done_maxsamp 0
					catch {unset maxsamp_line}
					if [catch {open "|$cmd"} CDPmaxId] {
						catch {unset CDPmaxId}
						Inf "Failed To Find (And Adjust) Maximum Level Of Output : $CDPmaxId"
						UnBlock
						continue
					} else {
						fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					}
					vwait done_maxsamp
					if {!$done_maxsamp || ![info exists maxsamp_line]} {
						set msg "Failure To Find (And Adjust) Maximum Level Of Output"
						ErrShow $msg
						UnBlock
						continue
					}
					catch {close CDPmaxId}
					set maxlev [lindex $maxsamp_line 0]
					if {$maxlev <= 0.0} {
						set msg "Output has zero level"
						ErrShow $msg
						UnBlock
						continue
					}
					if {$maxlev > 0.95} {
						set adjustor [expr 0.95/$maxlev]
						set gain "-g"
						append gain $adjustor
						wm title .blocker "PLEASE WAIT:        REMIXING FOR BETTER LEVEL"
						set k 0
						if [catch {file delete $outfnam0} zit] {
							Inf "Cannot Delete Original Mix"
							UnBlock
							continue
						}
						set cmd $origcmd
						lappend cmd $gain
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							catch {unset CDPidrun}
							ErrShow "Cannot Do New Remix Of File: $CDPidrun"
							DeleteAllTemporaryFiles 
							UnBlock
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Do New Remix Of File:"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							DeleteAllTemporaryFiles
							UnBlock
							continue
						}
						if {![file exists $outfnam0]} {
							Inf "No Output File Generated On 2nd Pass"
							DeleteAllTemporaryFiles
							UnBlock
							continue
						}
					}
					if [catch {file rename $outfnam0 $ofnam} zit] {
						set msg "Cannot Rename Output Soundfile: Output Sound Is In File '$outfnam0'\n\n"
						append msg "Rename It Now, Outside The Loom, Before Closing This Dialogue Box\n\n"
						append msg "Or You Will Lose It"
						Inf $msg
						UnBlock
						continue
					}
				} else {
					set n 2
					set snippos 1
					set lastpeaktime [lindex $mmtrimtimes 0]
					set badcuts 0
					while {$n < $len} {
						set peaktime [lindex $mmtrimtimes $n]
						set sniptime [lindex $mmtrimtimes $snippos]
						set dur [expr $peaktime - $lastpeaktime]
						set diff [expr $dur - $mmdur]
						if {$diff < 0} {
							set diff [expr -$diff]
						}
						if {$dur > $mmdur} {
							if {$dur > [expr $mmdur + $splen]} {
								set hdiff [expr $diff/2.0]
								set bakstep [expr $sniptime - $hdiff]
								if {$bakstep < 0.0} {
									set cutpair [list $sniptime [expr $sniptime + $diff]]
								} else {
									set cutpair [list $bakstep [expr $sniptime + $hdiff]]
								}
								lappend cuttimes $cutpair
							} else {
								incr badcuts
							}
						} else {
							set insertpair [list $sniptime $diff]
							lappend inserttimes $insertpair
						}
						set lastpeaktime $peaktime
						incr snippos 2
						incr n 2
					}
					if {$badcuts} {
						set msg "$badcuts Edits Were Too Short For Splice Length : Continue ??"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
					}

					;#	IF CUTS AND INSERTS COEXIST : ADJUST INSERTS TO TALLY WITH ALREADY-CUT FILE

					if {[info exists cuttimes] && [info exists inserttimes]} {
						set cutsum 0.0
						catch {unset imoves}
						set len [llength $inserttimes]
						foreach thiscut $cuttimes {
							set time [lindex $thiscut 0]				;#	FIND TIME OF THIS EXCISION
							set dur	 [expr [lindex $thiscut 1] - $time]	;#	AND EXCISION DURATION
							set cutsum [expr $cutsum + $dur]			;#	FIND THE SUM OF ALL EXCISIONS, AT THIS TIME
							set n 0
							while {$n < $len} {							;#	FIND THE FIRST TIME IN INSERT-TIMES WHICH IS BEYOND THE EXCISION TIME
								set thisinsert [lindex $inserttimes $n]
								set itime [lindex $thisinsert 0]
								if {$itime > $time} {					;#	STORE THIS INSERT-TIME LOCATION, AND THE EXCISION-SUM ADJUST AT THIS POINT
									lappend imoves [list $n $cutsum]
									break
								}
								incr n
							}
						}
						if {[info exists imoves]} {
							set imlen [llength $imoves]
							set n 0
							set m 1
							while {$n < $imlen} {						;#	FOR EACH LISTED TIME-ADJUST
								set thisadj [lindex $imoves $n]			
								set k [lindex $thisadj 0]				;#	GET THE FIRST INSERTTIME LOCATION AT WHICH THIS PARTICULAR TIME-ADJUST IS MADE
								set cutsum [lindex $thisadj 1]			;#	GET THE TIME-ADJUST
								if {$m < $imlen} {
									set nextadj [lindex $imoves $m]		;#	GET THE NEXT TME-ADJUST LOCATION
									set j [lindex $nextadj 0]			;#	OR
								} else {								;#	THE END OF THE INSERT-TIMES LIST
									set j [llength $inserttimes]
								}
								set z $k
								while {$z < $j} {						;#	ADJUST EVERY INSERT-TIME, WITHIN THE DEFINED RANGE, BY THE TIME-ADJUST	
									set thisinsert [lindex $inserttimes $z]
									set itime [lindex $thisinsert 0]
									set itime [expr $itime - $cutsum]
									set thisinsert [lreplace $thisinsert 0 0 $itime]
									set inserttimes [lreplace $inserttimes $z $z $thisinsert] 
									incr z
								}
								incr n
								incr m
							}
						}
					}

					;#	WRITE CUTS DATA TO TEMPORARY TEXTFILES

					DeleteAllTemporaryFilesWhichAreNotCDPOutput text 0
					Block "RETIMING SOUND"
					if {[info exists cuttimes]} {
						if [catch {open $cutsfile "w"} zit] {
							Inf "Cannot Open Temporary Textfile To Write Cut Times Data"
							UnBlock
							continue
						}
						foreach line $cuttimes {
							puts $zit $line
						}
						close $zit
					}
					if {[info exists inserttimes]} {
						if [catch {open $insertsfile "w"} zit] {
							Inf "Cannot Open Temporary Textfile To Write Insert Times Data"
							UnBlock
							continue
						}
						foreach line $inserttimes {
							puts $zit $line
						}
						close $zit
					}

					;#	RUN PROGRAMS

					DeleteAllTemporaryFilesWhichAreNotCDPOutput snd 0
					if {[info exists cuttimes]} {
						set cmd [file join $evv(CDPROGRAM_DIR) sfedit$evv(EXEC)]
						lappend cmd excises 1 $fnam $outfnam1 $cutsfile -w$mmtrimsplice

						set prg_dun 0
						set prg_abortd 0
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Cannot Edit Area(s) Out Of File"
							catch {unset CDPidrun}
							UnBlock
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Cannot Edit Area(s) Out Of File"
							UnBlock
							continue
						}
					} else {
						if [catch {file copy $fnam $outfnam1} zit] {
							Inf "Cannot Copy Input File To Temporary Backup"
							UnBlock
							continue
						}
					}
					if {[info exists inserttimes]} {
						catch {unset CDPidrun}
						set cmd [file join $evv(CDPROGRAM_DIR) manysil$evv(EXEC)]
						lappend cmd manysil $outfnam1 $outfnam2 $insertsfile $mmtrimsplice
						set prg_dun 0
						set prg_abortd 0
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Cannot Insert Silences Into File"
							catch {unset CDPidrun}
							UnBlock
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Cannot Insert Silences Into File"
							UnBlock
							continue
						}
						set outfnam3 $outfnam2
					} else {
						set outfnam3 $outfnam1
					}
					if [catch {file rename $outfnam3 $ofnam} zit] {
						set msg "Cannot Rename Output Soundfile: Output Sound Is In File '$outfnam3'\n\n"
						append msg "Rename It Now, Outside The Loom, Before Closing This Dialogue Box\n\n"
						append msg "Or You Will Lose It"
						Inf $msg
						UnBlock
						continue
					}
				}
				DataManage delete $ofnam
				if {[FileToWkspace $ofnam 0 0 0 0 1] <= 0} {
					UnBlock
					continue
				}
				UnBlock
				Inf "'$ofnam' Is On The Workspace"
				set last_outfile $ofnam
				set finished 1
			}
			2 {
				if {![info exists mmtrimtimes]} {
					Inf "No Data To Save"
					continue
				}
				set dfnam [file rootname [file tail $fnam]]
				append dfnam "_rhythmdata" $evv(TEXT_EXT)
				if {[file exists $dfnam]} {
					set msg "File $dfnam Aready Exists: Overwrite It ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					if {![DeleteFileFromSystem $dfnam 0 1]} {
						Inf "Cannot Delete The Existing File $dfnam"
						continue
					}
				}
				if [catch {open $dfnam "w"} zit] {
					Inf "Cannot Open Textfile To Write Cut-Data For Rhythmicise"
					continue
				}
				foreach {strttime peaktime cliptime} $mmtrimtimes {
					set line [list $strttime $peaktime $cliptime]
					puts $zit $line
				}
				close $zit
				if {[FileToWkspace $dfnam 0 0 0 0 1] <= 0} {
					continue
				}
				Inf "'$dfnam' Is On The Workspace"
				set last_outfile $dfnam
				continue
			}
			0 {
				set finished 1
			}
		}
	}	
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#---- Design a vfilter data file, by extracting harmonics from a pitched analysis file

proc ExtractVfilterFromAnalData {} {
	global pr_anavf anavf_intune anavf_hcnt anavf_lofrq anavf_hifrq anavf_fnam wstk pa evv
	global CDPidrun prg_dun prg_abortd simple_program_messages wl chlist last_outfile

	set vfnam $evv(DFLT_OUTNAME)
	append vfnam $evv(TEXT_EXT)

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Choose A Single Analysis File, From A Sound Which Is Pitched"
			return
		}
		set fnam [lindex $chlist 0]
	} else {
		set fnam [$wl get $i]
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(ANALFILE)} {
		Inf "Choose A Single Analysis File, From A Sound Which Is Pitched"
		return
	}
	set nyquist $pa($fnam,$evv(NYQUIST))

	set f .anavf
	if [Dlg_Create $f "EXTRACT VARIBANK FILTER" "set pr_anavf 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		button $f0.ok -text "Get Filter Data" -command "set pr_anavf 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_anavf 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Semitone error in tuning of harmonics "
		entry $f1.e -textvariable anavf_intune -width 6
		pack $f1.ll $f1.e -side left -padx 2
		pack $f1 -side top -pady 2
		label $f2.ll -text "No. of harmonics which confirm pitch found "
		entry $f2.e -textvariable anavf_hcnt -width 6
		pack $f2.ll $f2.e -side left -padx 2
		pack $f2 -side top -pady 2
		label $f3.ll -text "Minimum pitch expected (Hz) "
		entry $f3.e -textvariable anavf_lofrq -width 16
		pack $f3.ll $f3.e -side left -padx 2
		pack $f3 -side top -pady 2
		label $f4.ll -text "Maximum pitch expected (Hz) "
		entry $f4.e -textvariable anavf_hifrq -width 16
		pack $f4.ll $f4.e -side left -padx 2
		pack $f4 -side top -pady 2
		label $f5.ll -text "Output Filename "
		entry $f5.e -textvariable anavf_fnam -width 16
		pack $f5.ll $f5.e -side left -padx 2
		pack $f5 -side top -pady 2
		wm resizable $f 1 1
		bind $f1.e <Down> {focus .anavf.2.e}
		bind $f2.e <Down> {focus .anavf.3.e}
		bind $f3.e <Down> {focus .anavf.4.e}
		bind $f4.e <Down> {focus .anavf.5.e}
		bind $f5.e <Down> {focus .anavf.1.e}
		bind $f1.e <Up> {focus .anavf.5.e}
		bind $f2.e <Up> {focus .anavf.1.e}
		bind $f3.e <Up> {focus .anavf.2.e}
		bind $f4.e <Up> {focus .anavf.3.e}
		bind $f5.e <Up> {focus .anavf.4.e}
		bind $f <Escape> {set pr_anavf 0}
		bind $f <Return> {set pr_anavf 1}
	}
	set anavf_intune 1		;#	set default
	set anavf_hcnt 5		;#	set default
	set anavf_lofrq ""
	set anavf_hifrq ""
	set anavf_fnam ""
	set pr_anavf 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_anavf $f.3.e
	while {!$finished} {
		tkwait variable pr_anavf
		if {$pr_anavf} {
			if {[string length $anavf_fnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $anavf_fnam]} {
				continue
			}
			set outfnam [string tolower $anavf_fnam]
			append outfnam $evv(TEXT_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Already Exists: Please Choose A Different Name"
				continue
			}
			if {[string length $anavf_intune] <= 0} {
				Inf "No Semitone-Error Entered"
				continue
			}
			if {![IsNumeric $anavf_intune] || ($anavf_intune <= 0.0)} {
				Inf "Invalid Semitone-Error Entered"
				continue
			}
			if {[Flteq $anavf_intune 0.0] || ($anavf_intune > 3.0)} {
				set msg "Improbable Semitone-Error Entered: Do You Really Mean This ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
			}
			if {[string length $anavf_hcnt] <= 0} {
				Inf "No Harmonics-Count Entered"
				continue
			}
			if {![regexp {^[0-9]+$} $anavf_hcnt] || ($anavf_hcnt <= 0) || ($anavf_hcnt > 8)} {
				Inf "Invalid Harmonics-Count Entered (Integer 1-8)"
				continue
			}
			if {[string length $anavf_lofrq] <= 0} {
				Inf "No Minimum-Pitch Entered"
				continue
			}
			if {![IsNumeric $anavf_lofrq] || ($anavf_lofrq <= 13.0) || ($anavf_lofrq >= $nyquist)} {
				Inf "Invalid Minimum-Pitch Entered (Min 13 Hz)"
				continue
			}
			if {[string length $anavf_hifrq] <= 0} {
				Inf "No Maximum-Pitch Entered"
				continue
			}
			if {![IsNumeric $anavf_hifrq] || ($anavf_hifrq <= 13.0) || ($anavf_hifrq >= $nyquist)} {
				Inf "Invalid Maximum-Pitch Entered (Min 13 Hz)"
				continue
			}
			if {$anavf_hifrq < $anavf_lofrq} {
				set temp $anavf_hifrq
				set anavf_hifrq $anavf_lofrq
				set anavf_lofrq $temp
			}
			DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
			set cmd [file join $evv(CDPROGRAM_DIR) specnu]
			lappend cmd makevfilt $fnam $vfnam $anavf_intune $anavf_hcnt $anavf_lofrq $anavf_hifrq
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			Block "Extracting Filter Data"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Cannot Extract Filter Data"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Cannot Extract Filter Data"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			UnBlock
			Block "Rationalising Filter Data"

			if [catch {open $vfnam "r"} zit] {
				Inf "Cannot Open Temporary Filter Data File To Rationalise Data"
				continue
			}

			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				catch {unset  nuline}
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] > 0} {
						lappend nuline $item
					}
				}
				lappend vfdata $nuline
			}
			close $zit

			set filelen 0
			foreach line $vfdata {
				lappend roots [lindex $line 1]			;#	Get fundamental of each line
				incr filelen
			}
			set changed 0
			set lastroot [lindex $roots 0]
			set m 0
			set n 1
			while {$n < $filelen} {						;#	Insert any missing roots (amp zero)
				set thisroot [lindex $roots $n]
				set rootratio [expr double($thisroot) / double($lastroot)]
				if {$rootratio > 1.5} {
					set changed 1
					set thisroot [expr $thisroot / 2.0]
					set line [lindex $vfdata $n]
					set line [linsert $line 1 $thisroot 0.0]
					set vfdata [lreplace $vfdata $n $n $line]
				} elseif {$rootratio < 0.75} {
					set changed 1
					set lastroot [expr $lastroot / 2.0]
					set line [lindex $vfdata $m]
					set line [linsert $line 1 $lastroot 0.0]
					set vfdata [lreplace $vfdata $m $m $line]
				}
				set lastroot $thisroot
				incr m
				incr n
			}
			if {$changed} {								;#	If roots have been adjusted
				unset roots								;#	Get fundamental of each line, anew
				foreach line $vfdata {
					lappend roots [lindex $line 1]
				}
			}
			set all_hnos {}
			set linecnt 0
			while {$linecnt < $filelen} {				;#	Extract harmonic-numbers from data
				set line_hnos($linecnt) {}
				set line [lindex $vfdata $linecnt]
				set root [lindex $roots $linecnt]
				set len [llength $line]
				set cc 3
				while {$cc < $len} {					;#	For every frq entry above the root
					set val [lindex $line $cc]			;#	Calc its harmonic number
					set hno [expr int(round(double($val) / double($root)))]	
					if {[lsearch $all_hnos $hno] < 0} {
						lappend all_hnos $hno			;#	Store all harmonic-numbers used in file
					}
					if {[lsearch $line_hnos($linecnt) $hno] >= 0} {	;# Eliminate duplicate harmonics (should eliminate least loud, but this will do)
						set line [lreplace $line $cc [expr $cc + 1]]
						set vfdata [lreplace $vfdata $linecnt $linecnt $line]
						incr len -2
					} else {
						lappend line_hnos($linecnt) $hno	;#	Store harmonic numbers used in this line
						incr cc 2
					}
				}
				incr linecnt
			}
			set all_hnos [lsort -integer -increasing $all_hnos]		;#	Sort all-harmonic-numbers used in file, into ascending order
			set all_hnos_len [llength $all_hnos]
			set linecnt 0
			while {$linecnt < $filelen} {
				set changed 0
				set line [lindex $vfdata $linecnt]					;#	For each line
				set len [llength $line]
				set root [lindex $roots $linecnt]					;#	Get root frequency
				set these_hnos $line_hnos($linecnt)					;#	Get associated harmonic numbers
				set all_hcnt 0
				set cc 3											;#	Set location of first harmonic entry in line
				set local_h_index 0									;#	Get first harmonic in list of harmonics-in-line
				while {$cc < $len} {								;#	For every harmonic entry in the line
					set harmonic_in_line [lindex $these_hnos $local_h_index]
					set next_hno [lindex $all_hnos $all_hcnt]		;#	Get next harmonic in list of all-harmonics-in-file
					incr all_hcnt

					if {$harmonic_in_line != $next_hno} {
						set changed 1								;#	While harmonic-in-line is not the next harmonic in list of all-harmonics-in-file
						set frq [expr $root * double($next_hno)]	;#	Insert zero-amp entry into line, for this missing harmonic
						set line [linsert $line $cc $frq 0.0]
						incr len 2									;#	And increase length of line
						incr cc 2									;#	As we have inserted new values at cc, increase location in line
					} else {										;#	Otherwise
						incr local_h_index							;#	Go to next harmonic-in-line
						incr cc 2									;#	Go to next location in line
					}
				}

				while {$all_hcnt < $all_hnos_len} {				;#	Insert any harmonics missing at line end
					set changed 1
					set next_hno [lindex $all_hnos $all_hcnt]
					set frq [expr $root * double($next_hno)]
					lappend line $frq 0.0
					incr all_hcnt
				}
				if {$changed} {
					set vfdata [lreplace $vfdata $linecnt $linecnt $line]
				}
				incr linecnt
			}
				;#	FIND ANY TIME-DUPLICATED LINES, AND ELIMINATE

			set lasttime [lindex [lindex $vfdata 0] 0]
 			set linecnt 1
			while {$linecnt < $filelen} {
				set line [lindex $vfdata $linecnt]					;#	For each line
				set time [lindex $line 0]
				if {$time == $lasttime} {
					set vfdata [lreplace $vfdata $linecnt $linecnt]
					incr filelen -1
				} else {
					incr linecnt
				}
				set lasttime $time
			}

				;#	FIND ANY DATA ABOVE THE NYQUIST, ELIMINATE ALL COLUMNS CONTANING IT

			set linecnt 0
			set linelen [llength [lindex $vfdata 0]]
			set orig_linelen $linelen
			while {$linecnt < $filelen} {
				set line [lindex $vfdata $linecnt]					;#	For each line
				set cc 1
				while {$cc < $linelen} {
					if {[lindex $line $cc] >= $nyquist} {
						set linelen $cc								;#	i.e. only search this far in further lines
						break
					}
					incr cc 2
				}
				incr linecnt
			}
			if {$linelen < $orig_linelen} {
				incr linelen -1
				set linecnt 0
				while {$linecnt < $filelen} {
					set line [lindex $vfdata $linecnt]
					set line [lrange $line 0 $linelen]
					set vfdata [lreplace $vfdata $linecnt $linecnt $line]
					incr linecnt
				}
			}
				;#	NORMALISE THE DATA

			set linelen [llength [lindex $vfdata 0]]
			set maxamp 0.0
			foreach line $vfdata {
				set cc 2
				while {$cc < $linelen} {
					set val [lindex $line $cc]
					if {$val > $maxamp} {
						set maxamp $val
					}
					incr cc 2
				}
			}
			if {($maxamp > 0.0) && ($maxamp < 1.0)} {
				set normer [expr 1.0 / $maxamp]
				set linecnt 0
				while {$linecnt < $filelen} {
					set line [lindex $vfdata $linecnt]
					set cc 2
					while {$cc < $linelen} {
						set val [lindex $line $cc]
						set val [expr $val * $normer]
						set line [lreplace $line $cc $cc $val]
						incr cc 2
					}
					set vfdata [lreplace $vfdata $linecnt $linecnt $line]
					incr linecnt
				}
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write The Filter Data"
				UnBlock
				continue
			}
			foreach line $vfdata {
				puts $zit $line
			}
			close $zit
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				set last_outfile $outfnam
			}
			Inf "Filter File '$outfnam' Has Been Created"
			set finished 1
		} else {
			break
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-------

proc AdjustVfiltToPitchofSrc {} {
	global prg_dun prg_abortd simple_program_messages CDPidrun evv wl chlist pa last_outfile
	global pr_avftpos avftpos_intune avftpos_hcnt avftpos_lofrq avftpos_hifrq avftpos_fnam avftpos_chk
	set afnam $evv(DFLT_OUTNAME)
;# 2023
	append afnam 0 $evv(ANALFILE_OUT_EXT)
	set pdatafnam $evv(DFLT_OUTNAME)
	append pdatafnam 0 $evv(TEXT_EXT)
	set dummy $evv(DFLT_OUTNAME)
	append dummy 1 $evv(SNDFILE_EXT)
	
	set ilist [$wl curselection]
	if {[llength $ilist] != 2} {
		if {![info exists chlist] || ([llength $chlist] != 2)} {
			Inf "Select A Mono Soundfile And A Varibank Filter File"
			return
		}
		set pfnam [lindex $chlist 0]
		set vfnam [lindex $chlist 1]
	} else {
		set pfnam [$wl get [lindex $ilist 0]]
		set vfnam [$wl get [lindex $ilist 1]]
	}
	if {$pa($pfnam,$evv(FTYP)) != $evv(SNDFILE)} {
		if {$pa($vfnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Select A Mono Soundfile And A Varibank Filter File"
			return
		} else {
			set temp $pfnam
			set pfnam $vfnam
			set vfnam $temp
		}
	}
	if {$pa($pfnam,$evv(CHANS)) != 1} {
		Inf "Select A Mono Soundfile And A Varibank Filter File"
		return
	}
	set nyquist [expr $pa($pfnam,$evv(SRATE)) / 2.0]

	if {![IsAListofNumbers $pa($vfnam,$evv(FTYP))]} {
		Inf "Select A Mono Soundfile And Varibank Filter File"
		return
	}
	if [catch {open $vfnam "r"} zit] {
		Inf "Cannot Open File '$vfnam'"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
#FEB 2022
		if {[string length $line] <= 0} {
			continue
		} elseif {[string match [string index $line 0] ";"]} {
			continue
		}
		set line [split $line]
		catch {unset nuline}
		set lasttime -1
		set c_cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item]} {
				Inf "This Process Only Works With Filter Varibank Data."
				return
			}
			if {[IsEven $c_cnt]} {
				if {$item < 0.0} {
					Inf "This Process Only Works With Filter Varibank Data."
					return
				}
				if {$c_cnt == 0} {
					if {$item < $lasttime} {
						Inf "This Process Only Works With Filter Varibank Data."
						return
					}
					set lasttime $item
				}
			} else {
				if {($item > 12544) || ($item < 13)} {
					Inf "Frq Value ($item) Out Of Range On Line $line_ccnt"
	 				return
				}
			}
			lappend nuline $item
			incr c_cnt
		}
		if {[IsEven $c_cnt]} {
			Inf "This Process Only Works With Filter Varibank Data."
	 		return
		}
		lappend vfdata $nuline	
	}

	set f .avftpos
	if [Dlg_Create $f "ADJUST PITCH OF VARIBANK FILTER" "set pr_avftpos 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f4a [frame $f.4a] 
		set f5 [frame $f.5] 
		button $f0.ok -text "Adjust Filter Data" -command "set pr_avftpos 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_avftpos 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Semitone error in tuning of harmonics "
		entry $f1.e -textvariable avftpos_intune -width 6
		pack $f1.ll $f1.e -side left -padx 2
		pack $f1 -side top -pady 2
		label $f2.ll -text "No. of harmonics which confirm pitch found "
		entry $f2.e -textvariable avftpos_hcnt -width 6
		pack $f2.ll $f2.e -side left -padx 2
		pack $f2 -side top -pady 2
		label $f3.ll -text "Minimum pitch expected (Hz) "
		entry $f3.e -textvariable avftpos_lofrq -width 16
		pack $f3.ll $f3.e -side left -padx 2
		pack $f3 -side top -pady 2
		label $f4.ll -text "Maximum pitch expected (Hz) "
		entry $f4.e -textvariable avftpos_hifrq -width 16
		pack $f4.ll $f4.e -side left -padx 2
		pack $f4 -side top -pady 2
		checkbutton $f4a.cb -variable avftpos_chk -text "Equalise level at all times"
		pack $f4a.cb -side left -padx 2
		pack $f4a -side top -pady 2
		label $f5.ll -text "Output Filename "
		entry $f5.e -textvariable avftpos_fnam -width 16
		pack $f5.ll $f5.e -side left -padx 2
		pack $f5 -side top -pady 2
		wm resizable $f 1 1
		bind $f1.e <Down> {focus .avftpos.2.e}
		bind $f2.e <Down> {focus .avftpos.3.e}
		bind $f3.e <Down> {focus .avftpos.4.e}
		bind $f4.e <Down> {focus .avftpos.5.e}
		bind $f5.e <Down> {focus .avftpos.1.e}
		bind $f1.e <Up> {focus .avftpos.5.e}
		bind $f2.e <Up> {focus .avftpos.1.e}
		bind $f3.e <Up> {focus .avftpos.2.e}
		bind $f4.e <Up> {focus .avftpos.3.e}
		bind $f5.e <Up> {focus .avftpos.4.e}
		bind $f <Escape> {set pr_avftpos 0}
		bind $f <Return> {set pr_avftpos 1}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	set avftpos_intune 1	;#	set default
	set avftpos_hcnt 5		;#	set default
	set avftpos_lofrq ""
	set avftpos_hifrq ""
	set avftpos_fnam ""
	set avftpos_chk 1
	set pr_avftpos 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_avftpos $f.3.e
	while {!$finished} {
		tkwait variable pr_avftpos
		if {$pr_avftpos} {
			if {[string length $avftpos_fnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $avftpos_fnam]} {
				continue
			}
			set outfnam [string tolower $avftpos_fnam]
			append outfnam $evv(TEXT_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Already Exists: Please Choose A Different Name"
				continue
			}
			if {[string length $avftpos_intune] <= 0} {
				Inf "No Semitone-Error Entered"
				continue
			}
			if {![IsNumeric $avftpos_intune] || ($avftpos_intune <= 0.0)} {
				Inf "Invalid Semitone-Error Entered"
				continue
			}
			if {[Flteq $avftpos_intune 0.0] || ($avftpos_intune > 3.0)} {
				set msg "Improbable Semitone-Error Entered: Do You Really Mean This ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
			}
			if {[string length $avftpos_hcnt] <= 0} {
				Inf "No Harmonics-Count Entered"
				continue
			}
			if {![regexp {^[0-9]+$} $avftpos_hcnt] || ($avftpos_hcnt <= 0) || ($avftpos_hcnt > 8)} {
				Inf "Invalid Harmonics-Count Entered (Integer 1-8)"
				continue
			}
			if {[string length $avftpos_lofrq] <= 0} {
				Inf "No Minimum-Pitch Entered"
				continue
			}
			if {![IsNumeric $avftpos_lofrq] || ($avftpos_lofrq <= 13.0) || ($avftpos_lofrq >= $nyquist)} {
				Inf "Invalid Minimum-Pitch Entered (Min 13 Hz)"
				continue
			}
			if {[string length $avftpos_hifrq] <= 0} {
				Inf "No Maximum-Pitch Entered"
				continue
			}
			if {![IsNumeric $avftpos_hifrq] || ($avftpos_hifrq <= 13.0) || ($avftpos_hifrq >= $nyquist)} {
				Inf "Invalid Maximum-Pitch Entered (Min 13 Hz)"
				continue
			}
			if {$avftpos_hifrq < $avftpos_lofrq} {
				set temp $avftpos_hifrq
				set avftpos_hifrq $avftpos_lofrq
				set avftpos_lofrq $temp
			}

				;#	GET SPECTRUM

			if {![file exists $afnam]} {
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd anal 1 $pfnam $afnam -c1024 -o3
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				Block "Analysing Soundfile"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Extract Spectrum"
					catch {unset CDPidrun}
					UnBlock
					DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Extract Spectrum"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
					continue
				}
				UnBlock
			}
				;#	GET PITCH DATA

			set cmd [file join $evv(CDPROGRAM_DIR) repitch]
			lappend cmd getpitch 2 $afnam $dummy $pdatafnam -t$avftpos_intune -g2 -s80 -n$avftpos_hcnt -l$avftpos_lofrq -h$avftpos_hifrq -d.25
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			Block "Extracting Pitch"
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Cannot Extract Pitch"
				catch {unset CDPidrun}
				UnBlock
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $afnam
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Cannot Extract Pitch"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $afnam
				continue
			}
			UnBlock
			Block "Transposing Data"
			if [catch {open $pdatafnam "r"} zit] {
				Inf "Cannot Open File '$pdatafnam' To Read Extracted Pitch Data"
				UnBlock
				continue
			}
			catch {unset pdata}
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				catch {unset nuline}
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] > 0} {
						lappend nuline $item
					}
				}
				lappend pdata $nuline
			}
			close $zit
			if {![info exists pdata]} {
				Inf "No Data In Extracted Pitch File"
				UnBlock
				continue
			}

			;#	DO THE TRANSPOSITION

			set firstpval [HzToMidi [lindex [lindex $pdata 0] 1]]
			set endpval	  [HzToMidi [lindex [lindex $pdata end] 1]]
			set vlinelen [llength [lindex $vfdata 0]]
			set datalen [llength $vfdata]
			set datacnt 0
			while {$datacnt < $datalen} {
				set vline [lindex $vfdata $datacnt]
				set pdata_val $endpval		;#		DEFAULT, IF WE RUN OUT OF VALUES IN PITCHDATA FILE
				set lastptime 0
				set lastpval $firstpval
				set vtime [lindex $vline 0]
				foreach pline $pdata {
					set ptime [lindex $pline 0]
					set pval  [HzToMidi [lindex $pline 1]]
					if {$ptime <= $vtime} {
						set lastptime $ptime
						set lastpval  $pval
						continue
					}
					set timestep [expr $ptime - $lastptime]
					set valstep  [expr $pval - $lastpval]
					set ratio [expr ($vtime - $lastptime) / $timestep]
					set valstep [expr $valstep * $ratio]
					set pdata_val [expr $lastpval + $valstep]
					break
				}
				set pdata_val [MidiToHz $pdata_val]
				set v_frq [lindex $vline 1]
				set transpos [expr $pdata_val / $v_frq]
				set cc 1
				while {$cc < $vlinelen} {
					set val [lindex $vline $cc]
					set val [expr $val * $transpos]
					set vline [lreplace $vline $cc $cc $val]
					incr cc 2
				}
				set vfdata [lreplace $vfdata $datacnt $datacnt $vline]
				incr datacnt
			}

			;#	EXTEND FILTER IF NESS, TO COVER MORE TIME IN SOUND

			set v_frq [lindex $vline 1]
			foreach pline $pdata {
				set ptime [lindex $pline 0]
				if {$ptime > $vtime} {
					set pval [lindex $pline 1]
					set transpos [expr $pval / $v_frq]
					set cc 1
					set nuvline [lreplace $vline 0 0 $ptime]
					while {$cc < $vlinelen} {
						set val [lindex $nuvline $cc]
						set val [expr $val * $transpos]
						set nuvline [lreplace $nuvline $cc $cc $val]
						incr cc 2
					}
					lappend vfdata $nuvline
					incr datalen
				}
			}

			;#	ELIMINATE TIME-DUPLICATED LINES

			set datacnt 1
			set lasttime [lindex [lindex $vfdata 0] 0]
			while {$datacnt < $datalen} {
				set vline [lindex $vfdata $datacnt]
				set time [lindex $vline 0]
				if {$time == $lasttime} {
					set vfdata [lreplace $vfdata $datacnt $datacnt]
					incr datalen -1
				} else {
					incr datacnt
				}
				set lasttime $time
			}

			;#	EQUALISE LEVEL OVER FILTER, IF DEMANDED


			if {$avftpos_chk} {
				set datacnt 0
				set maxlevel 0.0
				while {$datacnt < $datalen} {
					set vline [lindex $vfdata $datacnt]
					set cc 2
					while {$cc < $vlinelen} {
						set val [lindex $vline $cc]
						if {$val > $maxlevel} {
							set maxlevel $val
						}
						incr cc 2
					}
					incr datacnt
				}
				if {$maxlevel < 1.0} {
					set maxlevel 1.0
				}
				set datacnt 0
				while {$datacnt < $datalen} {
					set vline [lindex $vfdata $datacnt]
					set maxlinelevel 0.0
					set cc 2
					while {$cc < $vlinelen} {
						set val [lindex $vline $cc]
						if {$val > $maxlinelevel} {
							set maxlinelevel $val
						}
						incr cc 2
					}
					if {($maxlinelevel < $maxlevel) && ($maxlinelevel > 0.0)} {
						set normer [expr $maxlevel / $maxlinelevel]
						set cc 2
						while {$cc < $vlinelen} {
							set val [lindex $vline $cc]
							set val [expr $val * $normer]
							set vline [lreplace $vline $cc $cc $val]
							incr cc 2
						}
						set vfdata [lreplace $vfdata $datacnt $datacnt $vline]
					}
					incr datacnt
				}
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write The Filter Data"
				UnBlock
				continue
			}
			foreach line $vfdata {
				puts $zit $line
			}
			close $zit
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				set last_outfile $outfnam
				Inf "Filter File '$outfnam' Is On The Workspace"
			}
			set finished 1
		} else {
			break
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-------  Create Resonance Tail

proc ResTail {} {
	global prg_dun prg_abortd simple_program_messages CDPidrun CDPmaxId evv wl chlist pa restailff restailfflo restailffhi
	global pr_restail restailstt restailend restailgain restailmult restailechos restailbal restailfnam maxsamp_line done_maxsamp
	global restailgain_x restailmult_x restailechos_x restailbal_x origresfnam readonlyfg readonlybg last_outfile
	global restailstt_x restailend_x wstk
 	set tailfnam $evv(DFLT_OUTNAME)
	append tailfnam 0 $evv(SNDFILE_EXT)
	set tailfenv $evv(DFLT_OUTNAME)
	append tailfenv 1 $evv(TEXT_EXT)
	set resfnam $evv(DFLT_OUTNAME)
	append resfnam 2 $evv(SNDFILE_EXT)
	set mixfnam $evv(DFLT_OUTNAME)
	append mixfnam 3 $evv(SNDFILE_EXT)
	set mixtxt $evv(DFLT_OUTNAME)
	append mixtxt 4 $evv(TEXT_EXT)
	set filtfnam $evv(DFLT_OUTNAME)
	append filtfnam 5 $evv(SNDFILE_EXT)
	set origresfnam $evv(DFLT_OUTNAME)
	append origresfnam 6 $evv(SNDFILE_EXT)
	set origmixfnam $evv(DFLT_OUTNAME)
	append origmixfnam 7 $evv(SNDFILE_EXT)
	set ilist [$wl curselection]
	if {[llength $ilist] != 1} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "SELECT A SOUNDFILE"
			return
		}
		set fnam [lindex $chlist 0]
	} else {
		set i [lindex $ilist 0]
		if {$i == -1} {
			Inf "Select A Soundfile"
			return
		}
		set fnam [$wl get $i]
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	if {$pa($fnam,$evv(CHANS)) > 2} {
		Inf "Select A Mono Or Stereo Soundfile"
		return
	}
	set chans    $pa($fnam,$evv(CHANS))
	set duration $pa($fnam,$evv(DUR))

	set f .restail
	if [Dlg_Create $f "RESONATE TAIL OF SOUND" "set pr_restail 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f00 [frame $f.00] 
		set f1 [frame $f.1] 
		set f1a [frame $f.1a  -bg $evv(POINT) -height 1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		button $f0.ok -text "Create Tail" -command "set pr_restail 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.save -text "Save Output" -command "set pr_restail 4" -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_restail 0" -highlightbackground [option get . background {}]
		button $f0.help -text "Help" -command "ResTailHelp" -bg $evv(HELP) -highlightbackground [option get . background {}]
		pack $f0.ok $f0.help $f0.save -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		frame $f00.sv 
		button $f00.sv.1 -text "Select Segment" -command "SnackDisplay $evv(SN_TIMEPAIRS) restail 1 $fnam" -bd 2 -bg $evv(SNCOLOR) -width 14 -highlightbackground [option get . background {}]
		button $f00.sv.2 -text "Play Source" -command "PlaySndfile  $fnam 0" -width 14 -highlightbackground [option get . background {}]
		pack $f00.sv.1 $f00.sv.2 -side left -padx 2
		label $f00.ll -text "Select region to resonate, using \"Select Segment\"" -fg $evv(SPECIAL) -highlightbackground [option get . background {}]
		pack $f00.sv $f00.ll -side top -pady 2
		pack $f00 -side top -pady 2
		button $f1.play -text "Play Output Mix" -command "set pr_restail 2" -highlightbackground [option get . background {}]
		button $f1.play2 -text "Play Res Tail Only" -command "set pr_restail 3" -highlightbackground [option get . background {}]
		menubutton $f1.filt -text "Filter Tail" -menu $f1.filt.menu -relief raised
		button $f1.rest -text "Restore Unfiltered Output" -command "set pr_restail 6" -highlightbackground [option get . background {}]
		set m [menu $f1.filt.menu -tearoff 0]
		$m add command -label "Lopas  Pass 3000 Stop 3500" -command "set restailff 3000; set pr_restail 5" -foreground black
		$m add command -label "Lopas  Pass 2000 Stop 2500" -command "set restailff 2000; set pr_restail 5" -foreground black
		$m add command -label "Lopas  Pass 1000 Stop 1500" -command "set restailff 1000; set pr_restail 5" -foreground black
		$m add command -label "Hipas  Pass 550 Stop 500"   -command "set restailff 550;  set pr_restail 5" -foreground black
		$m add command -label "Hipas  Pass 450 Stop 400"   -command "set restailff 450;  set pr_restail 5" -foreground black
		$m add command -label "Hipas  Pass 350 Stop 300"   -command "set restailff 350;  set pr_restail 5" -foreground black
		$m add command -label "Hipas  Pass 250 Stop 200"   -command "set restailff 250;  set pr_restail 5" -foreground black
		$m add command -label "Hipas  Pass 200 Stop 150"   -command "set restailff 200;  set pr_restail 5" -foreground black
		$m add command -label "Hipas  Pass 150 Stop 100"   -command "set restailff 150;  set pr_restail 5" -foreground black
		pack $f1.play $f1.play2 -side left -padx 2		
		pack $f1.rest $f1.filt -side right -padx 2
		pack $f1 -side top -fill x -expand true
		pack $f1a -side top -fill x -expand true -pady 4
		label $f2.ll -text "START of end-portion to resonate "
		entry $f2.e -textvariable restailstt -width 16
		label $f2.ll2 -text "END of end-portion to resonate "
		entry $f2.e2 -textvariable restailend -width 16
		pack $f2.ll $f2.e $f2.ll2 $f2.e2 -side left -padx 2
		pack $f2 -side top -pady 2 -anchor w
		label $f3.ll -text "Stadium size multiplier"
		entry $f3.e -textvariable restailmult -width 6
		pack $f3.ll $f3.e -side left -padx 2
		label $f3.ll2 -text "Number of echos"
		entry $f3.e2 -textvariable restailechos -width 6
		pack $f3.ll2 $f3.e2 -side left -padx 2
		label $f3.ll3 -text "Output Gain for Reverb creation "
		entry $f3.e3 -textvariable restailgain -width 16
		pack $f3.ll3 $f3.e3 -side left -padx 2
		pack $f3 -side top -pady 2 -anchor w
		label $f4.ll -text "Level of reverb in final mix "
		entry $f4.e -textvariable restailbal -width 16
		pack $f4.ll $f4.e -side left -padx 2
		pack $f4 -side top -pady 2 -anchor w
		label $f5.ll -text "Output Filename "
		entry $f5.e -textvariable restailfnam -width 40
		pack $f5.ll $f5.e -side left -padx 2
		pack $f5 -side top -pady 2 -fill x -expand true
		label $f6.ll -text "\"Control\" + \"Up\", \"Down\", \"Left\", \"Right\" arrows move between entry boxes." -fg $evv(SPECIAL)
		pack $f6.ll -side top -pady 4
		pack $f.6 -side top -pady 4
		wm resizable $f 1 1
		SetMostOfRestail
		bind $f2.e  <Control-Right> {focus .restail.2.e2}
		bind $f2.e  <Control-Left>  {focus .restail.2.e2}
		bind $f2.e2 <Control-Left>  {focus .restail.2.e}
		bind $f2.e2 <Control-Right> {focus .restail.2.e}

		bind $f3.e  <Control-Right> {focus .restail.3.e2}
		bind $f3.e2 <Control-Right> {focus .restail.3.e3}
		bind $f3.e3 <Control-Right> {focus .restail.3.e}
		bind $f3.e  <Control-Left>  {focus .restail.3.e3}
		bind $f3.e2 <Control-Left>  {focus .restail.3.e}
		bind $f3.e3 <Control-Left>  {focus .restail.3.e2}

		bind $f4.e  <Control-Left>  {focus .restail.3.e}
		bind $f4.e  <Control-Right> {focus .restail.3.e2}
		bind $f5.e  <Control-Right> {focus .restail.3.e3}

		bind $f2.e  <Control-Down> {focus .restail.3.e}
		bind $f2.e2 <Control-Down> {focus .restail.3.e3}
		bind $f3.e  <Control-Down> {focus .restail.4.e}
		bind $f3.e2 <Control-Down> {focus .restail.4.e}
		bind $f3.e3 <Control-Down> {focus .restail.4.e}
		bind $f4.e  <Control-Down> {focus .restail.5.e}
		bind $f5.e  <Control-Down> {focus .restail.2.e}

		bind $f2.e  <Control-Up> {focus .restail.5.e}
		bind $f2.e2 <Control-Up> {focus .restail.5.e}
		bind $f3.e  <Control-Up> {focus .restail.2.e}
		bind $f3.e2 <Control-Up> {focus .restail.2.e}
		bind $f3.e3 <Control-Up> {focus .restail.2.e2}
		bind $f4.e  <Control-Up> {focus .restail.3.e}
		bind $f5.e  <Control-Up> {focus .restail.4.e}

		bind $f <Control-Key-s> {set pr_restail 4}
		bind $f <Control-Key-S> {set pr_restail 4}
		bind $f <Key-space> {set pr_restail 2}
		bind $f <Return> {set pr_restail 1}
		bind $f <Escape> {set pr_restail 0}
	}
	.restail.00.sv.1 config -command "SnackDisplay $evv(SN_TIMEPAIRS) restail 1 $fnam"
	.restail.00.sv.2 config -command "PlaySndfile  $fnam 0"
	set restailstt ""			;#	These params scrubbed on every call,
	set restailend ""			;#	to ensure values relevant to current src are set

	set restailfnam [file rootname [file tail $fnam]]
	append restailfnam "_revend"
	set pr_restail 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_restail $f.2.e
	while {!$finished} {
		tkwait variable pr_restail
		switch -- $pr_restail {
			1 {
				if {[string length $restailfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $restailfnam]} {
					continue
				}
				set outfnam [string tolower $restailfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Already Exists: Please Choose A Different Name"
					continue
				}
				if {[string length $restailgain] <= 0} {
					set msg "No Output Gain For Reverb Creation Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetRestail
					}
					continue
				}
				if {![IsNumeric $restailgain] || ($restailgain <= 0.0) || ($restailgain > 1.0)} {
					Inf "Invalid Output Gain For Reverb Creation (Range  > 0.0 To  1.0)"
					continue
				}
				if {[string length $restailstt] <= 0} {
					set msg "No Tail Start Time Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetRestail
					}
					continue
				}
				if {![IsNumeric $restailstt] || ($restailstt < 0.0) || ($restailstt >= $duration)} {
					Inf "Invalid Tail Start Time (Range  0.0 TO < $duration)"
					continue
				}
				if {[string length $restailend] <= 0} {
					set msg "No Tail End Time Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetRestail
					}
					continue
				}
				if {![IsNumeric $restailend] || ($restailend <= $restailstt)} {
					Inf "Invalid Tail End Time (Range  > $restailstt TO $duration)"
					continue
				}
				if {$restailend > $duration} {
					set restailend $duration
				}
				if {[string length $restailmult] <= 0} {
					set msg "No Stadium Multiplier Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetRestail
					}
					continue
				}
				if {![IsNumeric $restailmult] || ($restailmult < 0.1) || ($restailmult > 100)} {
					Inf "Invalid Stadium Multiplier (Range  0.1 TO 100)"
					continue
				}
				if {[string length $restailechos] <= 0} {
					set msg "No Echo Count Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetRestail
					}
					continue
				}
				if {![IsNumeric $restailechos] || ($restailechos < 2) || ($restailechos > 1000)} {
					Inf "Invalid Echo Count (Range  2 TO 1000)"
					continue
				}
				if {[string length $restailbal] <= 0} {
					set msg "No Reverb Level Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetRestail
					}
					continue
				}
				if {![IsNumeric $restailbal] || ($restailbal <= 0.0) || ($restailbal > 1.0)} {
					Inf "Invalid Reverb Level (Range  > 0 To  1)"
					continue
				}
				set doenv 0
				set docut 0
				if {[info exists lastrestailstt]} {
					if {($restailstt != $lastrestailstt) || ($restailend != $lastrestailend)} {
						set doenv 1
						set docut 1
					} 
				}
				if {![file exists $tailfenv]} {
					set doenv 1
				}
				if {![file exists $tailfnam]} {
					set docut 1
				}
				if {$doenv} {
					if {[file exists $tailfenv]} {
						if [catch {file delete $tailfenv} zit] {
							Inf "Cannot Delete Existing Temporary Envelope File '$tailfenv'"
							continue
						}
					}
					if {[file exists $tailfnam]} {
						if [catch {file delete $tailfnam} zit] {
							Inf "Cannot Delete Existing Temporary Cut File '$tailfnam'"
							continue
						}
					}
					if {[file exists $resfnam]} {
						if [catch {file delete $resfnam} zit] {
							Inf "Cannot Delete Existing Temporary Resonated File '$resfnam'"
							continue
						}
					}
					if [catch {open $tailfenv "w"} zit] {
						Inf "Cannot Open Temporary Envelope File '$tailfenv'"
						continue
					}
					set time 0.0
					set sttsplice [expr $restailstt - 0.003]
					if {$restailstt > 0.003} {
						set line "0.0 0.0"
						puts $zit $line
						set line $sttsplice
						append line " " 0.0
						puts $zit $line
					} else {
						set line "0.0 1.0"
						puts $zit $line
					}
					set line $restailstt
					append line " " 1.0
					puts $zit $line
					set line $restailend
					append line " " 1.0
					puts $zit $line
					set endsplice [expr $restailend + 0.003]
					set veryend [expr $duration + 1.0]
					if {$endsplice < $duration} {
						set line $endsplice
						append line " " 0.0
						puts $zit $line
						set line $veryend
						append line " " 0.0
						puts $zit $line
					} else {
						set line $veryend
						append line " " 1.0
						puts $zit $line
					}
					close $zit
					set lastrestailstt $restailstt
					set lastrestailend $restailend
				}
				if {$docut} {
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd cut 1 $fnam $tailfnam $restailstt $restailend -w3
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					Block "Cutting Tail"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Cut Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Cut Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					UnBlock
					if {![file exists $tailfnam]} {
						Inf "Failed To Cut Tail"
						continue
					}
				}
				set dores 0
				if {$docut} {
					set dores 1
				}
				if {[info exists lastrestailgain]} {
					if {($restailgain != $lastrestailgain) || ($restailechos != $lastrestailechos) || ($restailmult != $lastrestailmult)} {
						set dores 1
					} 
				}
				if {![file exists $resfnam] || [file exists $origmixfnam]} {	;#	i.e. either no resfile esists, or res file has been previously altered
					catch {file delete $origmixfnam}
					catch {file delete $origresfnam}
					set dores 1
				}
				if {$dores} {
					if {[file exists $resfnam]} {
						if [catch {file delete $resfnam} zit] {
							Inf "Cannot Delete Existing Temporary Resonated File '$resfnam'"
							continue
						}
					}
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd revecho 3 $tailfnam $resfnam -g$restailgain -r1.0 -s$restailmult -e$restailechos
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					Block "Resonating Tail"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Resonate Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Resonate Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					UnBlock
					if {![file exists $resfnam]} {
						Inf "Failed To Resonate Tail"
						continue
					}
					set lastrestailgain $restailgain
					set lastrestailechos $restailechos
					set lastrestailmult $restailmult 

					Block "Finding Max Sample In Output"
					set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
					if {[ProgMissing $cmd "'maxsamp2$evv(EXEC)' Is Not On Your System. Cannot Search For Maximum Samples In File."]} {
						UnBlock
						continue
					}
					catch {unset maxsamp_line}
					set done_maxsamp 0
					lappend cmd $resfnam
					if [catch {open "|$cmd"} CDPmaxId] {
						Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
						UnBlock
						continue
	   				} else {
	   					fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					}
	 				vwait done_maxsamp
					if {![info exists maxsamp_line]} {
						Inf "Cannot Retrieve Maximum Sample Information"
						UnBlock
						continue
					}
					UnBlock
					set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
					if {$maxoutsamp < $evv(FLTERR)} {
						Inf "Insufficient Level In Output File"
						continue
					} elseif {$maxoutsamp > 0.98} {
						Inf "Output Level Too High : Reduce Gain"
						continue
					}
				}
				if {[file exists $mixtxt]} {
					if [catch {file delete $mixtxt} zit] {
						Inf "Cannot Delete Existing Temporary Mix Data File '$mixtxt'"
						UnBlock
						continue
					}
				}
				if {$restailbal >= 1.0} {
					if [catch {file delete $mixfnam} zit] {
						Inf "Cannot Delete Existing Output Mix '$mixfnam'"
						continue
					}
					if [catch {file copy $resfnam $mixfnam} zit] {
						Inf "Cannot Copy Resonance Mix To Output"
						continue
					}
					if {[DoParse $resfnam 0 0 0] <= 0} {
						continue
					}
					set mixdur $pa($resfnam,$evv(DUR))
				} else {
					set makemix 0
					if {[info exists lastrestailbal] && ($lastrestailbal != $restailbal)} {
						set makemix 1
					}
					if {![file exists $mixtxt]} {
						set makemix 1
					}
					Block "Creating and Checking Reverb Mix"
					if {$makemix} {
						if [catch {open $mixtxt "w"} zit] {
							Inf "Cannot Open Temporary Mix Data File '$mixtxt'"
							UnBlock
							continue
						}
						set level [expr 1.0 - $restailbal]
						switch -- $chans {
							1 {
								set line "$fnam 0.0 $chans $level C"
								puts $zit $line
								set line "$resfnam $restailstt 2 $restailbal"
								puts $zit $line
							}
							2 {
								set line "$fnam 0.0 $chans $level"
								puts $zit $line
								set line "$resfnam $restailstt 2 $restailbal"
								puts $zit $line
							}
						}
						close $zit
						set lastrestailbal $restailbal
					}
					if {[DoParse $mixtxt 0 0 0] <= 0} {
						UnBlock
						continue
					}
					set mixdur $pa($mixtxt,$evv(DUR))
					UnBlock
					if {[file exists $mixfnam]} {
						if [catch {file delete $mixfnam} zit] {
							Inf "Cannot Delete Existing Temporary Mix Output File '$mixfnam'"
							continue
						}
					}
					set cmd [file join $evv(CDPROGRAM_DIR) submix]
					lappend cmd mix $mixtxt $mixfnam -s0 -e$mixdur -g1.0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					Block "Mixing Resonance to Original"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Mix-In Resonant Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Mix-In Resonant Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					UnBlock
					if {![file exists $mixfnam]} {
						Inf "Failed To Mix-In Resonant Tail"
						continue
					}
				}
				if {[file exists $mixfnam]}  {
					if {[file exists $origmixfnam]}  {
						catch {file delete $origmixfnam}
					}
					catch {file copy $mixfnam $origmixfnam}
				}
			}
			2 {	;#	PLAY
				if {![file exists $mixfnam]} {
					Inf "No Output File To Play"
					continue
				}
				PlaySndfile $mixfnam 0
			}
			3 {	;#	PLAY
				if {![file exists $resfnam]} {
					Inf "No Resonant Tail To Play"
					continue
				}
				PlaySndfile $resfnam 0
			}
			4 { ;#	SAVE
				if {![file exists $mixfnam]} {
					Inf "No Output File To Save"
					continue
				}
				if [catch {file rename $mixfnam $outfnam} zit] {
					Inf "Cannot Rename The Output File"
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					set last_outfile $outfnam
					set msg "Tail Resonated File '$outfnam' Is On The Workspace : Quit now ??""
				}
				set restailgain_x $restailgain
				set restailmult_x $restailmult
				set restailechos_x $restailechos
				set restailbal_x $restailbal
				set restailstt_x $restailstt
				set restailend_x $restailend
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "yes"} {
					set finished 1
				}
			} 
			5 { ;# FILTER
				if {![file exists $resfnam]} {
					Inf "No Resonance File To Filter"
					continue
				}
				if {[file exists $filtfnam]} {
					if [catch {file delete $filtfnam} zit] {
						Inf "Cannot Delete Existing Filter File"
						continue
					}
				}
				if {[file exists $origresfnam]} {
					if [catch {file delete $origresfnam} zit] {
						Inf "Cannot Delete Backup File"
						continue
					}
				}
				if [catch {file copy $resfnam $origresfnam} zit] {
					Inf "Cannot Backup Existing Resonance File"
					continue
				}
				if [catch {file rename $resfnam $filtfnam} zit] {
					Inf "Cannot Move Existing Resonance File For Filtering"
					continue
				}
				switch -- $restailff {
					3000 {
						set restailfflo 3000 
						set restaillfhi 3500
					}
					2000 {
						set restailfflo 2000 
						set restaillfhi 2500
					}
					1000 {
						set restailfflo 1000 
						set restaillfhi 1500
					}
					550 {
						set restailfflo 550 
						set restaillfhi 500
					}
					450 {
						set restailfflo 450 
						set restaillfhi 400
					}
					350 {
						set restailfflo 350 
						set restaillfhi 300
					}
					250 {
						set restailfflo 250 
						set restaillfhi 200
					}
					200 {
						set restailfflo 200 
						set restaillfhi 150
					}
					150 {
						set restailfflo 150 
						set restaillfhi 100
					}
				}
				set filtextension 1.0
				set cmd [file join $evv(CDPROGRAM_DIR) filter]
				lappend cmd lohi 1 $filtfnam $resfnam -96 $restailfflo $restaillfhi -t$filtextension -s1
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				Block "Filtering Output"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Filter Resonance File"
					catch {file rename $filtfnam $resfnam}
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Filter Resonance File"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					catch {file delete $filtfnam}
					catch {file delete $resfnam}
					catch {file rename $origresfnam $resfnam}
					UnBlock
					continue
				}
				if {![file exists $resfnam]} {
					Inf "Failed To Filter Resonance File"
					catch {file delete $filtfnam}
					catch {file rename $origresfnam $resfnam}
					UnBlock
					continue
				}
				UnBlock
				catch {file delete $origresfnam}
				catch {file delete $mixfnam}
				if {![file exists $mixtxt]} {
					if [catch {file copy $resfnam $mixfnam} zit] {
						Inf "Cannot Copy Resonance Mix To Output"
						continue
					}
					if {[DoParse $resfnam 0 0 0] <= 0} {
						continue
					}
					set mixdur $pa($resfnam,$evv(DUR))
				} else {					
					set cmd [file join $evv(CDPROGRAM_DIR) submix]
					lappend cmd mix $mixtxt $mixfnam -s0 -e[expr $mixdur + $filtextension] -g1.0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					Block "Mixing Resonance to Original"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Mix-In Resonant Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Mix-In Resonant Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					UnBlock
					if {![file exists $mixfnam]} {
						Inf "Failed To Mix-In Resonant Tail"
						continue
					}
				}
			}
			6 {
				if {![file exists $origmixfnam]} {
					Inf "No Previous File To Restore"
					continue
				}
				if [catch {file delete $mixfnam} zit] {
					Inf "Cannot Delete Existing Output"
					continue
				}
				if [catch {file copy $origmixfnam $mixfnam} zit] {
					Inf "Cannot Retrieve Original Output"
					continue
				}
				Inf "Original Output Restored"
			}
			0 {
				break
			}
		}
	}
	if {[info exists pa($mixtxt,$evv(DUR))]} {
		PurgeArray $mixtxt
	}
	if {[info exists pa($resfnam,$evv(DUR))]} {
		PurgeArray $mixtxt
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc SaveRestailVals {} {
	global restailgain_x restailmult_x restailechos_x restailbal_x restailstt_x restailend_x evv
	set fnam [file join $evv(URES_DIR) restail$evv(CDP_EXT)]
	if {[info exists restailgain_x] && [info exists restailmult_x] && [info exists restailechos_x] && [info exists restailbal_x]} {
		if [catch {open $fnam "w"} zit] {
			Inf "Cannot Save Tail Resonance Values"
			return
		}
		puts $zit $restailgain_x
		puts $zit $restailmult_x
		puts $zit $restailechos_x
		puts $zit $restailbal_x
		puts $zit $restailstt_x 
		puts $zit $restailend_x
		close $zit
	}
}

proc LoadRestailVals {} {
	global restailgain_x restailmult_x restailechos_x restailbal_x restailstt_x restailend_x evv
	set fnam [file join $evv(URES_DIR) restail$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {open $fnam "r"} zit] {
			Inf "Cannot Load Tail Resonance Values"
			return
		}
		set cnt 0
		while {[gets $zit line] >= 0} {
			switch -- $cnt {
				0 { set restailgain_x $line }
				1 { set restailmult_x $line }
				2 { set restailechos_x $line }
				3 { set restailbal_x $line }
				4 { set restailstt_x $line }
				5 { set restailend_x $line }
			}
			incr cnt
		}
		close $zit
		if {$cnt != 6} {
			set baddata 1
		} elseif {![IsNumeric $restailgain_x] || ![IsNumeric $restailmult_x] || ![IsNumeric $restailechos_x] \
			   || ![IsNumeric $restailbal_x]  || ![IsNumeric $restailstt_x]  || ![IsNumeric $restailend_x]} {
			set baddata 1
		} elseif {($restailgain_x <= 0.0) || ($restailgain_x > 1.0)} {
			set baddata 1
		} elseif {($restailmult_x < 0.1) || ($restailmult_x > 100)} {
			set baddata 1
		} elseif {($restailechos_x <= 2) || ($restailechos_x > 1000)} {
			set baddata 1
		} elseif {($restailbal_x <= 0.0) || ($restailbal_x > 1.0)} {
			set baddata 1
		} elseif {($restailstt_x < 0.0) || ($restailstt_x >= $restailend_x)} {
			set baddata 1
		}
		if {[info exists baddata]} {
			Inf "Corrupted Tail-Resonance Data In File '$fnam'"
			catch {unset restailgain_x}
			catch {unset restailmult_x}
			catch {unset restailechos_x}
			catch {unset restailbal_x}
			catch {unset restailstt_x}
			catch {unset restailend_x}
			catch {file delete $fnam} zit
		}
	}
}

proc SetRestail {} {
	global restailgain restailgain_x restailmult restailmult_x restailechos restailechos_x  restailbal restailbal_x
	global restailstt_x restailend_x restailstt restailend

	if [info exists restailgain_x] {
		set restailgain $restailgain_x
	} 			
	if [info exists restailmult_x] {
		set restailmult $restailmult_x
	}
	if [info exists restailechos_x] {
		set restailechos $restailechos_x
	}			
	if [info exists restailbal_x] {
		set restailbal $restailbal_x
	}
	if [info exists restailstt_x] {
		set restailstt $restailstt_x
	}
	if [info exists restailend_x] {
		set restailend $restailend_x
	}
}

proc SetMostOfRestail {} {
	global restailgain restailgain_x restailmult restailmult_x restailechos restailechos_x  restailbal restailbal_x

	if [info exists restailgain_x] {
		set restailgain $restailgain_x
	} else {
		set restailgain ""
	}
	if [info exists restailmult_x] {
		set restailmult $restailmult_x
	} else {
		set restailmult ""
	}
	if [info exists restailechos_x] {
		set restailechos $restailechos_x
	} else {			
		set restailechos ""
	}
	if [info exists restailbal_x] {
		set restailbal $restailbal_x
	} else {
		set restailbal ""
	}
}


##################
#  BYTE REVERSAL #
##################

proc HelpOnByteReversal {} {
	set msg "                 BYTE REVERSAL\n"
	append msg "\n"
	append msg "Intel based MACs store file-data in a different way to other systems.\n"
	append msg "\n"
	append msg "To make existing soundfiles compatible with an Intel based MAC\n"
	append msg "run the directories containing those sounds through this\n"
	append msg "\"byte reversal\" procedure.\n"
	append msg "\n"
	append msg "You can store the new-format files in a new directory\n"
	append msg "or overwrite the existing soundfiles (CARE!).\n"
	append msg "\n"
	append msg "You are advised to copy the files to be byte-reversed\n"
	append msg "into a temporary directory (which may have subdirectories).\n"
	append msg "\n"
	append msg "WARNING: Byte-reversed soundfiles will not be recognised\n"
	append msg "                 by other hardware platforms.\n"
	append msg "\n"
	append msg "\n"
	append msg "\n"
	Inf $msg
}

proc ByteReversal {} {
	global wksp_dirname pr_bytetyb bytetyb_dir bytetyb_nudir bytetyb_dosubs bytetyb_datcop wstk evv
	global simple_program_messages prg_dun prg_abortd CDPidrun wksp_dirname bytr_fnams
	set f .bytetyb
	if [Dlg_Create $f "BYTE REVERSAL" "set pr_bytetyb 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Do Byte Reverse" -command "set pr_bytetyb 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.h -text "Help" -command HelpOnByteReversal -bg $evv(HELP) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_bytetyb 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f.0.h -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Current Directory of Sounds "
		entry $f1.e -textvariable bytetyb_dir -width 24
		checkbutton $f1.sub -variable bytetyb_dosubs -text "Apply to All Subdirs"
		button $f1.get -text "Get Dir" -command "DoListingOfDirectories br1" -highlightbackground [option get . background {}]
		pack $f1.e $f1.ll -side left
		pack $f1.sub $f1.get -side right
		pack $f1 -side top -pady 2 -fill x -expand true

		label $f2.ll -text "Goal Directory for Sounds "
		entry $f2.e -textvariable bytetyb_nudir -width 24
		checkbutton $f2.dat -variable bytetyb_datcop -text "Also copy datafiles"
		button $f2.get -text "Get Dir" -command "DoListingOfDirectories br2" -highlightbackground [option get . background {}]
		pack $f2.e $f2.ll -side left
		pack $f2.dat $f2.get -side right
		pack $f2 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_bytetyb 0}
		bind $f <Return> {set pr_bytetyb 1}
	}
	if {[info exists wksp_dirname] && [file exists $wksp_dirname] && [file isdirectory $wksp_dirname]} {
		set bytetyb_dir $wksp_dirname
		set bytetyb_nudir $wksp_dirname
	} else {
		set bytetyb_dir ""
		set bytetyb_nudir ""
	}
	set bytetyb_dosubs 0
	set bytetyb_datcop 0
	set pr_bytetyb 0
	set finished 0
	catch {unset bytr_fnams}
	set homedir [pwd]
	set homeskip [string length $homedir]
	incr homeskip
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_bytetyb
	
	while {!$finished} {
		set sndsysfiles_updated 0
		set files_updated 0
		catch {unset baddirs}
		catch {unset badfiles}
		tkwait variable pr_bytetyb
		if {$pr_bytetyb} {
			if {[string length $bytetyb_dir] <= 0} {
				Inf "No Current-Directory Name Entered"
				continue
			}
			set origdir [string tolower $bytetyb_dir]
			if {[string first ":" $origdir] < 0} {
				set basicorigdir $origdir
				set origdir [file join $homedir $origdir]
			} else {
				set k [string first $homedir $origdir]
				if {$k == 0} {
					set basicorigdir [string range $origdir $homeskip end]
				}
			}
			if {![file exists $origdir] || ![file isdirectory $origdir]} {
				Inf "Directory '$bytetyb_dir' Does Not Exist"
				continue
			}
			if {[string length $bytetyb_nudir] <= 0} {
				Inf "No Goal-Directory Name Entered"
				continue
			}
			set goaldir [string tolower $bytetyb_nudir]
			if {[string first ":" $goaldir] < 0} {
				set basicgoaldir $goaldir
				set goaldir [file join $homedir $goaldir]
			} else {
				set k [string first $homedir $goaldir]
				if {$k == 0} {
					set basicgoaldir [string range $goaldir $homeskip end]
				}
			}
			set existingdir 0
			set nudir 0
			if {[file exists $goaldir]} {
				if {![file isdirectory $goaldir]} {
					Inf "'$bytetyb_nudir' Is The Name Of An Existing File: Please Choose A Different Name"
					continue
				} else {
					if {[string match $goaldir $origdir]} {
						set msg "Are You Certain That You Want To Overwrite The Existing Files In Directory '$origdir' ?"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
					} else {
						set msg "Use The Existing Directory '$bytetyb_nudir' Overwriting Any Existing Files With The Same Names As The New Files ?"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							continue
						}
						set existingdir 1
					}
				}
			} else {
				set msg "Create A New Directory '$bytetyb_nudir' ?"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if [catch {file mkdir $goaldir} result] {
					Inf "Cannot Create Directory '$bytetyb_nudir'"
					continue
				}
				set nudir 1
			}
			set origdirskip [string length $origdir]
			incr origdirskip
			set OK 1
			if {$existingdir && $bytetyb_dosubs} {
				set bytr_fnams {}
				set bytr_fnams [SearchDirectoriesForBrFiles $origdir $bytetyb_dosubs $bytr_fnams]
				foreach fnam $bytr_fnams {
					if {[file isdirectory $fnam]} {
						set subdir [string range $fnam $origdirskip end]
						set nusubdir [file join $goaldir $subdir]
						if {[file exists $nusubdir] && ![file isdirectory $nusubdir]} {
							lappend baddirs $fnam
							set msg "'$nusubdir' Is The Name Of An Existing File, So Cannot Be Used As A New Subdirectory Name.\n\n"
							append msg "Please Choose A New Goal Directory\n"
							Inf $msg
							set OK 0
							break
						}
					}
				}
			}
			if {!$OK} {
				continue
			}
			if {![info exists bytr_fnams]} {
				set bytr_fnams {}
				set bytr_fnams [SearchDirectoriesForBrFiles $origdir $bytetyb_dosubs $bytr_fnams]
			}
			set bytr_fnams [SortBrFilesAndDirs $bytr_fnams]		;#	Puts new dirs firsst in list, so these are created before attempt made to use them
			set outfnam $evv(DFLT_OUTNAME)$evv(SNDFILE_EXT)
			Block "Doing Byte Reversal"
			foreach fnam $bytr_fnams {
				if {[file isdirectory $fnam]} {
					if {!$bytetyb_dosubs || !($nudir || $existingdir)} {
						continue
					} elseif {[info exists baddirs] && ([lsearch $baddirs $fnam] >= 0)} {
						continue
					}
					set subdir [string range $fnam $origdirskip end]
					set nusubdir [file join $goaldir $subdir]
					if {![file exists $nusubdir]} {
						if [catch {file mkdir $nusubdir} result] {
							if {![info exists baddirs] || ([lsearch $baddirs $fnam] < 0)} {
								lappend baddirs $fnam
							}
							set msg "Cannot Create New Subdirectory '$nusubdir'\n\n"
							append msg "Files In Subdirectory '$fnam' Will Not Be Byte-Reversed"
							Inf $msg
							continue
						}
					}
					continue
				} else {	;#	Not a subdirectory
					set olddir [file dirname $fnam]
					if {[info exists baddirs] && ([lsearch $baddirs $olddir] >= 0)} {
						continue
					}
					set subdirplusfnam [string range $fnam $origdirskip end]
					set nuname [file join $goaldir $subdirplusfnam]
				}
				set ftyp [FindFileType $fnam]

				if {[IsASndsysFile $ftyp]} {
					set cmd [file join $evv(CDPROGRAM_DIR) cdpconv]
					lappend cmd $fnam $outfnam
					catch {unset simple_program_messages}
					set prg_dun 0
					set prg_abortd 0
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Run Byte-Reverse Program"
						catch {unset CDPidrun}
						lappend badfiles $fnam
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed Do Byte-Reversal"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						lappend badfiles $fnam
						continue
					}
					if {![file exists $outfnam]} {
						Inf "Failed Do Byte-Reversal"
						lappend badfiles $fnam
						continue
					}
				} elseif {$bytetyb_datcop && ($nudir || $existingdir)} {
					if [catch {file copy $fnam $outfnam} zit] {
						lappend badfiles $fnam
						continue
					}
				} else {
					continue
				}
				incr files_updated

				catch {file delete $nuname}			;#	Delete any existing file with original filename
				if [catch {file rename $outfnam $nuname} zit] {
					if [catch {file delete $outfnam} zit] {
						Inf "Failed To Delete Intermediate Temporary File: Cannot Continue"	
						set finished 1
						break
					}
				}
				DataManage delete $nuname
			}
			UnBlock
			set msg ""
			if {$files_updated == 0} {
				set msg "No Files Were Processed"
			} else {
				Inf "Byte Reversal Complete\n\n"
				if {[info exists baddirs]} {
					append msg "Files In The Following Directories Were Not Updated\n\n"
					set n 0
					set len [llength $baddirs]
					while {$n < $len} {
						if {$n >= 20} {
							append msg "And More\n\n"
							break
						}
						append msg [lindex $baddirs $n] "\n"
						incr n
					}
				}
			}
			if {[info exists badfiles]} {
				append msg "The Following Files Were Not Updated\n\n"
				set n 0
				set len [llength $badfiles]
				while {$n < $len} {
					if {$n >= 20} {
						append msg "And More"
						break
					}
					append msg [lindex $badfiles $n] "\n"
					incr n
				}
			}
			if {[string length $msg] > 0} {
				Inf $msg
			}
			if {$files_updated} {
				if {$nudir || $existingdir} {
					UpdateRecentDirs $basicgoaldir
				}
				UpdateRecentDirs $basicorigdir
			}
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc IsASndsysFile {ftyp} {
	return [expr $ftyp & 31]
}

#--- Search Directories for filename containing given searchstring

proc SearchDirectoriesForBrFiles {dirname getsubdirs bytr_fnams} {
	
	foreach fnam [glob -nocomplain [file join $dirname *]] {
		if {[file isdirectory $fnam]} {
			if {$getsubdirs} {
				lappend bytr_fnams $fnam
				set bytr_fnams [SearchDirectoriesForBrFiles $fnam $getsubdirs $bytr_fnams]
				continue
			}
		} else {
			lappend bytr_fnams $fnam
		}
	}
	return $bytr_fnams
}

#----- Put dirs at start of list

proc SortBrFilesAndDirs {fnams} {

	set dirs {}
	set files {}
	foreach fnam $fnams {
		if {[file isdirectory $fnam]} {
			lappend dirs $fnam
		} else {
			lappend files $fnam
		}
	}
	set fnams [concat $dirs $fnams]
	return $fnams
}

#-------- Temporarily while this doesn't work directly on Loom !!

proc DoMchshred {} {
	global pr_mchsh mchshfnam mchshcnt mchshlen mchshscat mchshochans wl chlist evv wsk pa CDPidrun simple_program_messages prg_dun prg_abortd
	global last_outfile
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Single Soundfile From The Workspace"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Single Soundfile From The Workspace"
		return
	}
	set inchans $pa($fnam,$evv(CHANS))
	if {$inchans == 1} {
		set mode 1
	} else {
		set mode 2
	}
	set durlim [expr ($pa($fnam,$evv(DUR)) / 2.0) - $evv(FLTERR)]
	set f .mchsh
	if [Dlg_Create $f "MULTICHANNEL SHRED" "set pr_mchsh 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		button $f0.ok -text "Shred" -command "set pr_mchsh 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mchsh 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Number of shreds (Range 1 - (1000 x outchans))"
		entry $f1.e -textvariable  mchshcnt -width 6
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Chunk size (secs) (Range 0.01 to $durlim)"
		entry $f2.e -textvariable  mchshlen -width 6
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Chunksize scatter (range 0-10) "
		entry $f3.e -textvariable  mchshscat -width 6
		pack $f3.e $f3.ll -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		if {$mode == 1} {
			label $f4.ll -text "Number of outchans (2-16)"
			entry $f4.e -textvariable  mchshochans -width 6
			pack $f4.e $f4.ll -side left
			pack $f4 -side top -pady 2 -fill x -expand true
		}
		label $f5.ll -text "Outfile name "
		entry $f5.e -textvariable  mchshfnam -width 20
		pack $f5.ll $f5.e -side left
		pack $f5 -side top -pady 2
		wm resizable $f 1 1
		bind .mchsh.1.e <Down> {focus .mchsh.2.e}
		bind .mchsh.2.e <Down> {focus .mchsh.3.e}
		if {$mode == 1} {
			bind .mchsh.3.e <Down> {focus .mchsh.4.e}
			bind .mchsh.4.e <Down> {focus .mchsh.5.e}
		} else { 
			bind .mchsh.3.e <Down> {focus .mchsh.5.e}
		}
		bind .mchsh.5.e <Down> {focus .mchsh.1.e}
		bind .mchsh.1.e <Up> {focus .mchsh.5.e}
		bind .mchsh.2.e <Up> {focus .mchsh.1.e}
		bind .mchsh.3.e <Up> {focus .mchsh.2.e}
		if {$mode == 1} {
			bind .mchsh.4.e <Up> {focus .mchsh.3.e}
			bind .mchsh.5.e <Up> {focus .mchsh.4.e}
		} else {
			bind .mchsh.5.e <Up> {focus .mchsh.3.e}
		}
		bind $f <Escape> {set pr_mchsh 0}
		bind $f <Return> {set pr_mchsh 1}
	}
	set pr_mchsh 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchsh $f1.e
	while {!$finished} {
		tkwait variable pr_mchsh
		if {$pr_mchsh} {
			if {[string length $mchshfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $mchshfnam]} {
				continue
			}
			set outfnam [string tolower $mchshfnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $mchshfnam]} {
				Inf "File '$mchshfnam' Already Exists: Please Choose A Different Name"
				continue
			}
			if {$mode == 1} {
				if {[string length $mchshochans] <= 0} {
					Inf "No Number Of Outchannels Entered"
					continue
				}
				if {![IsNumeric $mchshochans] || ![regexp {^[0-9]+$} $mchshochans] || ($mchshochans < 2) || ($mchshochans > 16)} {
					Inf "Invalid Number Of Outchannels Entered"
					continue
				}
			}
			if {[info exists mchshochans]} {
				set maxmchshcnt [expr 1000 * $mchshochans]
			} else {
				set maxmchshcnt [expr 1000 * $inchans]
			}
			if {[string length $mchshcnt] <= 0} {
				Inf "No Shred Count Entered"
				continue
			}
			if {![IsNumeric $mchshcnt] || ![regexp {^[0-9]+$} $mchshcnt] || ($mchshcnt < 1) || ($mchshcnt > $maxmchshcnt)} {
				Inf "Invalid Shred Count Entered"
				continue
			}
			if {[string length $mchshlen] <= 0} {
				Inf "No Chunksize Entered"
				continue
			}
			if {![IsNumeric $mchshlen] || ($mchshlen < 0.01) || ($mchshlen > $durlim)} {
				Inf "Invalid Chunksize Entered"
				continue
			}
			if {[string length $mchshscat] <= 0} {
				Inf "No Chunksize Scatter Entered"
				continue
			}
			if {![IsNumeric $mchshscat] || ($mchshscat < 0.0) || ($mchshscat > 10.0)} {
				Inf "Invalid Chunksize Scatter Entered"
				continue
			}
			Block "Shredding"
			set cmd [file join $evv(CDPROGRAM_DIR) mchshred]
			lappend cmd shred $mode $fnam $outfnam $mchshcnt $mchshlen $mchshscat
			if {$mode == 1} {
				lappend cmd $mchshochans
			}
			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Run Multichannel Shred Program"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleShredProcessOutput"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed Do Run Multichannel Shred Program"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

#------ Display info returned by running-batchfile in the the program-running display

proc HandleShredProcessOutput {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages

	if [eof $CDPidrun] {
		set prg_dun 1
		catch {close $CDPidrun}
		return
	} else {
		gets $CDPidrun line
		set line [string trim $line]
		if [string match ERROR:* $line] {
			lappend simple_program_messages $line
			set prg_abortd 1
			return
		} elseif [string match INFO:* $line] {
			wm title .blocker "PLEASE WAIT:        SHRED [string range $line 6 end]"
			return
		} elseif [string match END:* $line] {
			set prg_dun 1
			return
		}
	}
	update idletasks
}

#-------- Temporarily if this doesn't work directly on Loom !!

proc DoMchzig {} {
	global pr_zzig 	zzigochans zzigsplen zzigmode zzigstt zzigend zzigdur zzigmin zzigmax zzigseed zzigfnam zzigdata
	global wl chlist evv wsk pa CDPidrun simple_program_messages prg_dun prg_abortd last_outfile zzignoadj

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Single Soundfile From The Workspace"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Single Soundfile From The Workspace"
		return
	}
	set duration $pa($fnam,$evv(DUR))
	set zzigmode 0
	set f .zzig
	if [Dlg_Create $f "MULTICHANNEL ZIGZAG" "set pr_zzig 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		set f7 [frame $f.7] 
		set f8 [frame $f.8] 
		set f9 [frame $f.9] 
		set f9a [frame $f.9a] 
		set f9b [frame $f.9b] 
		set f10 [frame $f.10] 
		button $f0.ok -text "Zigzag" -command "set pr_zzig 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_zzig 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f6.ll -text "Output channels"
		entry $f6.e -textvariable  zzigochans -width 12
		pack $f6.e $f6.ll -side left
		pack $f6 -side top -pady 2 -fill x -expand true
		label $f7.ll -text "Splice length (mS) (Range 1-5000)"
		entry $f7.e -textvariable  zzigsplen -width 12
		pack $f7.e $f7.ll -side left
		pack $f7 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Mode"
		radiobutton $f3.r0 -variable zzigmode -text "Random" -value 0 -command "ResetMzigInterface"
		radiobutton $f3.r1 -variable zzigmode -text "User Defined" -value 1 -command "ResetMzigInterface"
		pack $f3.r0 $f3.r1 $f3.ll -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f1.ll -text "Starttime of area to zigzag (Range 0 - duration)"
		entry $f1.e -textvariable  zzigstt -width 12
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Endtime of area to zigzag (Range 0 - duration)"
		entry $f2.e -textvariable  zzigend -width 12
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Minimum duration of output"
		entry $f4.e -textvariable  zzigdur -width 12
		pack $f4.e $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		label $f5.ll -text "Minimum zig length"
		entry $f5.e -textvariable  zzigmin -width 12
		pack $f5.e $f5.ll -side left
		pack $f5 -side top -pady 2 -fill x -expand true
		label $f8.ll -text "Maximum zig length"
		entry $f8.e -textvariable  zzigmax -width 12
		pack $f8.e $f8.ll -side left
		pack $f8 -side top -pady 2 -fill x -expand true
		label $f9.ll -text "Random Seed (always different = 0)"
		entry $f9.e -textvariable  zzigseed -width 12
		pack $f9.e $f9.ll -side left
		pack $f9 -side top -pady 2 -fill x -expand true
		label $f9a.ll -text "Zig timings file"
		entry $f9a.e -textvariable zzigdata -width 12
		pack $f9a.e $f9a.ll -side left
		pack $f9a -side top -pady 2 -fill x -expand true
		checkbutton $f9b.ch -variable zzignoadj -text "No pans between adjacent output chans"
		pack $f9b.ch -side left
		pack $f9b -side top -pady 2 -fill x -expand true
		label $f10.ll -text "Output Filename"
		entry $f10.e -textvariable  zzigfnam -width 12
		pack $f10.ll $f10.e -side left
		pack $f10 -side top -pady 2
		bind .zzig.7.e <Up> {focus .zzig.6.e}
		if {$zzigmode == 0} {
			bind .zzig.6.e <Up> {focus .zzig.10.e}
			bind .zzig.1.e <Up> {focus .zzig.7.e}
			bind .zzig.2.e <Up> {focus .zzig.1.e}
			bind .zzig.4.e <Up> {focus .zzig.2.e}
			bind .zzig.5.e <Up> {focus .zzig.4.e}
			bind .zzig.8.e <Up> {focus .zzig.5.e}
			bind .zzig.9.e <Up> {focus .zzig.8.e}
			bind .zzig.10.e <Up> {focus .zzig.9.e}
		} else {
			bind .zzig.6.e <Up> {focus .zzig.9a.e}
			bind .zzig.9a.e <Up> {focus .zzig.7.e}
		}
		bind .zzig.6.e <Down> {focus .zzig.7.e}
		if {$zzigmode == 0} {
			bind .zzig.7.e <Down> {focus .zzig.1.e}
			bind .zzig.1.e <Down> {focus .zzig.2.e}
			bind .zzig.2.e <Down> {focus .zzig.4.e}
			bind .zzig.4.e <Down> {focus .zzig.5.e}
			bind .zzig.5.e <Down> {focus .zzig.8.e}
			bind .zzig.8.e <Down> {focus .zzig.9.e}
			bind .zzig.9.e <Down> {focus .zzig.10.e}
			bind .zzig.10.e <Down> {focus .zzig.6.e}
		} else {
			bind .zzig.7.e <Down> {focus .zzig.9a.e}
			bind .zzig.9a.e <Down> {focus .zzig.6.e}
		}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_zzig 0}
		bind $f <Return> {set pr_zzig 1}
	}
	set zzignoadj 0
	set zzigsplen 15
	set zzigstt 0
	set zzigend $duration
	set zzigdur [expr $duration * 2.0]
	set zzigmin .031
	set zzigmax 2.0
	set zzigochans 8
	set zzigseed 0
	set pr_zzig 0
	.zzig.9a.ll config -text ""
	.zzig.9a.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_zzig $f1.e
	while {!$finished} {
		tkwait variable pr_zzig
		if {$pr_zzig} {
			if {[string length $zzigfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $zzigfnam]} {
				continue
			}
			set outfnam [string tolower $zzigfnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $zzigfnam]} {
				Inf "File '$zzigfnam' Already Exists: Please Choose A Different Name"
				continue
			}
			if {![IsNumeric $zzigsplen] || ($zzigsplen < 1) || ($zzigsplen > 5000)} {
				Inf "Invalid Splice Length Entered"
				continue
			}
			if {![IsNumeric $zzigochans] || ![regexp {^[0-9]+$} $zzigochans] || ($zzigochans < 2) || ($zzigochans > 16)} {
				Inf "Invalid Number Of Outchannels Entered"
				continue
			}
			if {$zzigmode == 0} {
				if {![IsNumeric $zzigstt] ||  ($zzigstt < 0.0) || ($zzigstt > $duration)} {
					Inf "Invalid Zig Area Start Time Entered"
					continue
				}
				if {![IsNumeric $zzigend] ||  ($zzigend < 0.0) || ($zzigend > $duration)} {
					Inf "Invalid Zig Area End Time Entered"
					continue
				}
				set zigarea [expr $zzigend - $zzigstt]
				if {$zigarea < 0.0} {
					Inf "Incompatible Zig-Area Start And End Time Entered"
					continue
				}
				if {![IsNumeric $zzigdur] ||  ($zzigdur < 0.0)} {
					Inf "Invalid Output Duration Entered"
					continue
				}
				if {![IsNumeric $zzigmin] ||  ($zzigmin < 0.0) || ($zzigmin > $zigarea)} {
					Inf "Minimum Zig Time Invalid Or Too Large For Zig-Area"
					continue
				}
				if {![IsNumeric $zzigmax] ||  ($zzigmax < 0.0)} {
					Inf "Maximum Zig Time Invalid"
					continue
				}
				if {$zzigmax < $zzigmin} {
					Inf "Incompatible Zigtime Minimum And Maximum"
					continue
				}
				if {![IsNumeric $zzigseed] || ![regexp {^[0-9]+$} $zzigseed] || ($zzigseed < 0)} {
					Inf "Invalid Seed Value Entered"
					continue
				}
			} else {
				if {[string length $zzigdata] <= 0} {
					Inf "No Zigtime Data Filename Entered"
					continue
				}
				if {![file exists $zzigdata] || ([LstIndx $zzigdata $wl] < 0)} {
					Inf "Data File '$zzigdata' Is Not On The Workspace"
					continue
				}
				if {!($pa($zzigdata,$evv(FTYP)) & $evv(NUMLIST))) || ($pa($zzigdata,$evv(MINNUM)) < 0)} {
					Inf "Data File '$zzigdata' Is Not A List Of Times"
					continue
				}
			}
			Block "ZigZagging"
			set cmd [file join $evv(CDPROGRAM_DIR) mchzig]
			if {$zzigmode == 0} {
				lappend cmd zag 1 $fnam $outfnam $zzigstt $zzigend $zzigdur $zzigmin $zzigochans -s$zzigsplen -m$zzigmax -r$zzigseed
			} else {
				lappend cmd zag 2 $fnam $outfnam $zzigdata -s$zzigsplen
			}
			if {$zzignoadj} {
				lappend cmd "-a"
			}
			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Run Multichannel Zigzag Program"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed Do Run Multichannel Zigzag Program"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc ResetMzigInterface {} {
	global zzigmode zzigstt zzigend zzigdur zzigmin zzigmax zzigseed
	switch -- $zzigmode {
		0 {
			.zzig.1.ll config -text "Starttime of area to zigzag (Range 0 - duration)"
			.zzig.1.e config -bd 2 -state normal
			.zzig.2.ll config -text "Endtime of area to zigzag (Range 0 - duration)"
			.zzig.2.e config -bd 2 -state normal
			.zzig.4.ll config -text "Minimum duration of output"
			.zzig.4.e config -bd 2 -state normal
			.zzig.5.ll config -text "Minimum zig length"
			.zzig.5.e config -bd 2 -state normal
			.zzig.8.ll config -text "Maximum zig length"
			.zzig.8.e config -bd 2 -state normal
			.zzig.9.ll config -text "Random Seed (always different = 0)"
			.zzig.9.e config -bd 2 -state normal
			.zzig.9a.ll config -text ""
			.zzig.9a.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
		}
		1 {
			set zzigstt ""
			set zzigend ""
			set zzigdur ""
			set zzigmin ""
			set zzigmax ""
			set zzigseed ""
			.zzig.1.ll config -text ""
			.zzig.1.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
			.zzig.2.ll config -text ""
			.zzig.2.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
			.zzig.4.ll config -text ""
			.zzig.4.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
			.zzig.5.ll config -text ""
			.zzig.5.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
			.zzig.8.ll config -text ""
			.zzig.8.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
			.zzig.9.ll config -text ""
			.zzig.9.e config -bd 0 -state disabled -disabledbackground [option get . background {}] 
			.zzig.9a.ll config -text "Zig timings file"
			.zzig.9a.e config -bd 2 -state normal
		}
	}
}

#-------- Temporarily if this doesn't work directly on Loom !!

proc DoMchiter {} {
	global pr_ziter ziterochans zitermode ziterdel ziterand ziterdur ziterpich ziteramp ziterfade zitergain ziterseed ziterfnam
	global lastziterochans lastzitermode lastziterdel lastziterand lastziterdur lastziterpich lastziteramp lastziterfade lastzitergain
	global lastziterseed lastziterfnam
	global wl chlist evv wsk pa CDPidrun simple_program_messages prg_dun prg_abortd last_outfile

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Single Soundfile From The Workspace"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Single Soundfile From The Workspace"
		return
	}
	set duration $pa($fnam,$evv(DUR))
	set zitermode 1
	set f .ziter
	if [Dlg_Create $f "MULTICHANNEL ITERATE" "set pr_ziter 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		set f7 [frame $f.7] 
		set f8 [frame $f.8] 
		set f9 [frame $f.9] 
		set f10 [frame $f.10] 
		set f11 [frame $f.11] 
		button $f0.ok -text "Iterate" -command "set pr_ziter 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.rr -text "Get Last Vals" -command "set pr_ziter 2" -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_ziter 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.rr -side left -padx 2 -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output channels"
		entry $f1.e -textvariable  ziterochans -width 12
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		radiobutton $f2.r0 -variable zitermode -text "Specify Duration" -value 1 -command "ResetMiterInterface"
		radiobutton $f2.r1 -variable zitermode -text "Specifer Repetitions Count" -value 2 -command "ResetMiterInterface"
		pack $f2.r0 $f2.r1 -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Output Duration (> 0)"
		entry $f3.e -textvariable  ziterdur -width 12
		pack $f3.e $f3.ll -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Delay between repetitions (Range >0 - 100)"
		entry $f4.e -textvariable  ziterdel -width 12
		pack $f4.e $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		label $f5.ll -text "Randomisation of delays (Range 0 - 1)"
		entry $f5.e -textvariable  ziterand -width 12
		pack $f5.e $f5.ll -side left
		pack $f5 -side top -pady 2 -fill x -expand true
		label $f6.ll -text "Pitch wander (Range 0-12 semitones)"
		entry $f6.e -textvariable  ziterpich -width 12
		pack $f6.e $f6.ll -side left
		pack $f6 -side top -pady 2 -fill x -expand true
		label $f7.ll -text "Amplitude scatter (Range 0 - 1)"
		entry $f7.e -textvariable  ziteramp -width 12
		pack $f7.e $f7.ll -side left
		pack $f7 -side top -pady 2 -fill x -expand true
		label $f8.ll -text "Progressive Fade (Range 0 - 1)"
		entry $f8.e -textvariable  ziterfade -width 12
		pack $f8.e $f8.ll -side left
		pack $f8 -side top -pady 2 -fill x -expand true
		label $f9.ll -text "Overall Gain (Range 0 - 1)"
		entry $f9.e -textvariable  zitergain -width 12
		pack $f9.e $f9.ll -side left
		pack $f9 -side top -pady 2 -fill x -expand true
		label $f10.ll -text "Random Seed (always different = 0)"
		entry $f10.e -textvariable  ziterseed -width 12
		pack $f10.e $f10.ll -side left
		pack $f10 -side top -pady 2 -fill x -expand true
		label $f11.ll -text "Output Filename"
		entry $f11.e -textvariable  ziterfnam -width 12
		pack $f11.ll $f11.e -side left
		pack $f11 -side top -pady 2
		bind .ziter.11.e <Down> {focus .ziter.1.e}
		bind .ziter.10.e <Down> {focus .ziter.11.e}
		bind .ziter.9.e  <Down> {focus .ziter.10.e}
		bind .ziter.8.e  <Down> {focus .ziter.9.e}
		bind .ziter.7.e  <Down> {focus .ziter.8.e}
		bind .ziter.6.e  <Down> {focus .ziter.7.e}
		bind .ziter.5.e  <Down> {focus .ziter.6.e}
		bind .ziter.4.e  <Down> {focus .ziter.5.e}
		bind .ziter.3.e  <Down> {focus .ziter.4.e}
		bind .ziter.1.e  <Down> {focus .ziter.3.e}

		bind .ziter.11.e <Up> {focus .ziter.10.e}
		bind .ziter.10.e <Up> {focus .ziter.9.e}
		bind .ziter.9.e  <Up> {focus .ziter.8.e}
		bind .ziter.8.e  <Up> {focus .ziter.7.e}
		bind .ziter.7.e  <Up> {focus .ziter.6.e}
		bind .ziter.6.e  <Up> {focus .ziter.5.e}
		bind .ziter.5.e  <Up> {focus .ziter.4.e}
		bind .ziter.4.e  <Up> {focus .ziter.3.e}
		bind .ziter.3.e  <Up> {focus .ziter.1.e}
		bind .ziter.1.e  <Up> {focus .ziter.11.e}
		wm resizable $f 1 1
		bind $f <Escape> {set pr_ziter 0}
		bind $f <Return> {set pr_ziter 1}
	}
	set zitermode 1
	set ziterfnam ""
	set ziterdel $duration
	set ziterand 1
	set ziterdur [expr $duration * 2.0]
	set ziterpich 0
	set ziteramp 0
	set ziterfade 0
	set ziterochans 8
	set zitergain 1
	set ziterseed 0
	set pr_ziter 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_ziter $f.1.e
	while {!$finished} {
		tkwait variable pr_ziter
		switch -- $pr_ziter {
			1 {
				if {[string length $ziterfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $ziterfnam]} {
					continue
				}
				set outfnam [string tolower $ziterfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $ziterfnam]} {
					Inf "File '$ziterfnam' Already Exists: Please Choose A Different Name"
					continue
				}
				if {![IsNumeric $ziterochans] || ![regexp {^[0-9]+$} $ziterochans] || ($ziterochans < 2) || ($ziterochans > 16)} {
					Inf "Invalid Number Of Outchannels Entered"
					continue
				}
				if {$zitermode == 1} {
					if {![IsNumeric $ziterdur] ||  ($ziterdur <= 0.0)} {
						Inf "Invalid Output Duration Entered"
						continue
					}
				} else {
					if {![IsNumeric $ziterdur] || ![regexp {^[0-9]+$} $ziterdur] || ($ziterdur < 2) || ($ziterdur > 32767)} {
						Inf "Invalid Repetition Count Entered"
						continue
					}
				}
				if {![IsNumeric $ziterdel] ||  ($ziterdel < $evv(FLTERR)) || ($ziterdel > 100)} {
					Inf "Invalid Delay Time Entered"
					continue
				}
				if {![IsNumeric $ziterand] ||  ($ziterand < 0.0) || ($ziterand > 1.0)} {
					Inf "Invalid Delay Randomisation Time Entered"
					continue
				}
				if {![IsNumeric $ziterpich] ||  ($ziterpich < 0.0) || ($ziterpich > 12)} {
					Inf "Invalid Pitch Wander Entered"
					continue
				}
				if {![IsNumeric $ziteramp] ||  ($ziteramp < 0.0) || ($ziteramp > 12)} {
					Inf "Invalid Amplitude Scatter Entered"
					continue
				}
				if {![IsNumeric $ziterfade] ||  ($ziterfade < 0.0) || ($ziterfade >= 1.0)} {
					Inf "Invalid Progressive Fade Entered"
					continue
				}
				if {![IsNumeric $zitergain] ||  ($zitergain < 0.0) || ($zitergain > 1.0)} {
					Inf "Invalid Gain Entered"
					continue
				}
				if {![IsNumeric $ziterseed] || ![regexp {^[0-9]+$} $ziterseed] || ($ziterseed < 0)} {
					Inf "Invalid Seed Value Entered"
					continue
				}
				Block "Iterating"
				set cmd [file join $evv(CDPROGRAM_DIR) mchiter]
				lappend cmd iter $zitermode $fnam $outfnam $ziterochans $ziterdur -d$ziterdel -r$ziterand -p$ziterpich -a$ziteramp -f$ziterfade -g$zitergain -s$ziterseed
				catch {unset simple_program_messages}
				set prg_dun 0
				set prg_abortd 0
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Run Multichannel Iterate Program"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed Do Run Multichannel Iterate Program"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				UnBlock
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
				set finished 1
			} 
			2 {
				if {[info exists lastziterochans]} {		
					set ziterochans $lastziterochans 
					set zitermode $lastzitermode   
					set ziterdel  $lastziterdel    
					set ziterand  $lastziterand    
					set ziterdur  $lastziterdur    
					set ziterpich $lastziterpich   
					set ziteramp  $lastziteramp    
					set ziterfade $lastziterfade   
					set zitergain $lastzitergain   
					set ziterseed $lastziterseed   
					set ziterfnam $lastziterfnam   
				} else {
					Inf "No Previous Values"
					continue
				}
			}
			0 {
				set finished 1
			}
		}
	}
	set lastziterochans $ziterochans
	set lastzitermode   $zitermode
	set lastziterdel    $ziterdel
	set lastziterand    $ziterand
	set lastziterdur    $ziterdur
	set lastziterpich   $ziterpich
	set lastziteramp    $ziteramp
	set lastziterfade   $ziterfade
	set lastzitergain   $zitergain
	set lastziterseed   $ziterseed
	set lastziterfnam   $ziterfnam
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
	destroy $f
}

proc ResetMiterInterface {} {
	global zitermode ziterdur
	switch -- $zitermode {
		1 {
			.ziter.3.ll config -text "Output Duration (Range > 0)"
			set ziterdur ""
		}
		2 {
			.ziter.3.ll config -text "Repetition Count (Range 2 - 32767)"
			set ziterdur ""
		}
	}
}

#--- Split mchan file to stereo components: either disjunct (1-2,3-4) or overlapped (1-2,2-3,3-4,4-1)

proc MchXToStereo {} {
	global wl chlist pa evv pr_mchtost mchtostfnam mchtostover simple_program_messages prg_dun prg_abortd CDPidrun last_outfile

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Multichannel Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Multichannel Soundfile"
		return
	}
	set chans $pa($fnam,$evv(CHANS))
	if {$chans <= 3} {
		Inf "Select A Soundfile With More Than Two Channels"
		return
	}
	set tempfnam $evv(DFLT_OUTNAME)
	append tempfnam 0000 $evv(SNDFILE_EXT)
	if [catch {file copy $fnam $tempfnam} zit] {
		Inf "Cannot Make Preliminary Copy Of Source File"
		return
	}
	set f .mchtost
	if [Dlg_Create $f "STEREO EXTRACTION" "set pr_mchtost 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Extract Stereo" -command "set pr_mchtost 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mchtost 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Generic Output Filename "
		entry $f1.e -textvariable mchtostfnam -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		radiobutton $f2.r0 -variable mchtostover -text "Disjunct (1-2,3-4...)" -value 0
		radiobutton $f2.r1 -variable mchtostover -text "Disjunct Offset (2-3,4-5...)" -value 1
		radiobutton $f2.r2 -variable mchtostover -text "Overlapped (1-2,2-3,3-4.....)" -value 2
		pack $f2.r0 $f2.r1 $f2.r2 -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_mchtost 0}
		bind $f <Return> {set pr_mchtost 1}
	}
	set mchtostover 0
	set pr_mchtost 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchtost
	while {!$finished} {
		tkwait variable pr_mchtost
		if {$pr_mchtost} {
			if {($mchtostover != 2) && ![IsEven $chans]} {
				Inf "Cannnot Extract Disjunct Stereo Channels From File With An Odd Number Of Channels"
				continue
			}
			if {[string length $mchtostfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $mchtostfnam]} {
				continue
			}
			set outfnam [string tolower $mchtostfnam]
			switch -- $mchtostover {
				0 {
					set n 1
					set m 2
					while {$n <= $chans} {
						set thisoutfnam $outfnam
						append thisoutfnam "_" $n "_" $m $evv(SNDFILE_EXT)
						lappend outfnams $thisoutfnam
						incr n 2
						incr m 2
					}
				}
				1 {
					set n $chans
					set m 1
					while {$m <= $chans} {
						set thisoutfnam $outfnam
						append thisoutfnam "_" $n "_" $m $evv(SNDFILE_EXT)
						lappend outfnams $thisoutfnam
						set n [expr $m + 1]
						incr m 2
					}
				}
				2 {
					set n $chans
					set m 1
					while {$m <= $chans} {
						set thisoutfnam $outfnam
						append thisoutfnam "_" $n "_" $m $evv(SNDFILE_EXT)
						lappend outfnams $thisoutfnam
						set n $m
						incr m
					}
				}
			}
			set OK 1
			foreach thisoutfnam $outfnams {
				if {[file exists $thisoutfnam]} {
					Inf "FILE '$thisoutfnam' Already Exists: Please Choose A Different Generic Name"
					set OK 0
					break
				}
			}
			if {!$OK} {
				continue
			}
			Block "Extracting Channels"
			DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
			set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
			lappend cmd chans 2 $tempfnam
			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Run Channel Extraction Program"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Channel Extraction Program Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
				UnBlock
				continue
			}
			set OK 1
			set n 1
			while {$n <= $chans} {
				set thisoutfnam [file rootname $tempfnam]
				append thisoutfnam "_c" $n $evv(SNDFILE_EXT)
				if {![file exists $thisoutfnam]} {
					set msg "Failed To Extract All Channels Successfully"
					ErrShow $msg
					set OK 0
					break

				}
				incr n
			}
			if {!$OK} {
				UnBlock
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
				continue
			}
			catch {unset cmds}
			switch -- $mchtostover {
				0 {
					set n 1
					set m 2
					while {$n <= $chans} {
						set outnam $outfnam
						append outnam "_" $n "_" $m $evv(SNDFILE_EXT)
						set innam_n [file rootname $tempfnam]
						append innam_n "_c" $n $evv(SNDFILE_EXT)
						set innam_m [file rootname $tempfnam]
						append innam_m "_c" $m $evv(SNDFILE_EXT)
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd interleave $innam_n $innam_m $outnam
						lappend cmds $cmd
						incr n 2
						incr m 2
					}
				}
				1 {
					set n $chans
					set m 1
					while {$m <= $chans} {
						set outnam $outfnam
						append outnam "_" $n "_" [$m $evv(SNDFILE_EXT)
						set innam_n [file rootname $tempfnam]
						append innam_n "_c" $n $evv(SNDFILE_EXT)
						set innam_m [file rootname $tempfnam]
						append innam_m "_c" $m $evv(SNDFILE_EXT)
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd interleave $innam_n $innam_m $outnam
						lappend cmds $cmd
						set n [expr $m + 1]
						incr m 2
					}
				}
				2 {
					set n $chans
					set m 1
					while {$m <= $chans} {
						set outnam $outfnam
						append outnam "_" $n "_" $m $evv(SNDFILE_EXT)
						set innam_n [file rootname $tempfnam]
						append innam_n "_c" $n $evv(SNDFILE_EXT)
						set innam_m [file rootname $tempfnam]
						append innam_m "_c" $m $evv(SNDFILE_EXT)
						set cmd [file join $evv(CDPROGRAM_DIR) submix]
						lappend cmd interleave $innam_n $innam_m $outnam
						lappend cmds $cmd
						set n $m
						incr m
					}
					set nucmds [lrange $cmds 1 end]
					lappend nucmds [lindex $cmds 0]
					set cmds $nucmds
				}
			}
			catch {unset badmsgs}
			foreach cmd $cmds {
				wm title .blocker "PLEASE WAIT:        CREATING FILE [lindex $cmd end]"
				catch {unset simple_program_messages}
				set prg_dun 0
				set prg_abortd 0
				if [catch {open "|$cmd"} CDPidrun] {
					set msg "Failed To Create Stereo File [lindex $cmd 4]"
					lappend badmsgs $msg
					catch {unset CDPidrun}
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Create Stereo File [lindex $cmd 4]"
					set msg [AddSimpleMessages $msg]
					lappend badmsgs $msg
					continue
				}
			}
			if {[info exists badmsgs]} {
				Inf $badmsgs
			}
			set out 0
			set outfnams [ReverseList $outfnams]
			catch {unset last_outfile}
			foreach outnam $outfnams {
				if {[file exists $outnam]} {
					FileToWkspace $outnam 0 0 0 0 1
					lappend last_outfile $outnam
					set out 1
				}
			}
			UnBlock
			if {$out} {
				Inf "The Files Are On The Workspace"
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Combine stereo files to  mchan file either disjunct (1-2,3-4), disjunct offset (2-3,4-5, ..), or overlapped (1-2,2-3,3-4,4-1)

proc MchFromStereo {} {
	global wl chlist pa evv pr_mchfrmst mchfrmstfnam mchfrmstover mchfrmstchans last_outfile

	set ilist [$wl curselection]
	if {[llength $ilist] < 2} {
		if {![info exists chlist] || ([llength $chlist] < 2)} {
			Inf "Select Some Stereo Soundfiles"
			return
		} else {
			catch {unset ilist}
			foreach fnam $chlist {
				lappend ilist [LstIndx $fnam $wl]
			}
			$wl selection clear 0 end
			foreach i $ilist {
				$wl selection set $i
			}
		}
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		set ftyp $pa($fnam,$evv(FTYP))
		if {$ftyp != $evv(SNDFILE)} {
			Inf "Select Soundfiles"
			return
		}
		set chans $pa($fnam,$evv(CHANS))
		if {$chans != 2} {
			Inf "Select Stereo Soundfiles"
			return
		}
		lappend fnams $fnam
	}

	set f .mchfrmst
	if [Dlg_Create $f "STEREO INJECTION" "set pr_mchfrmst 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.ok -text "Inject Stereo" -command "set pr_mchfrmst 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mchfrmst 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output Channels (4-16)"
		entry $f1.e -textvariable mchfrmstchans -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Output Mix Filename "
		entry $f2.e -textvariable mchfrmstfnam -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		radiobutton $f3.r0 -variable mchfrmstover -text "Disjunct (1-2,3-4...)" -value 0
		radiobutton $f3.r1 -variable mchfrmstover -text "Disjunct Offset (2-3,4-5...)" -value 1
		radiobutton $f3.r2 -variable mchfrmstover -text "Overlapped (1-2,2-3,3-4.....)" -value 2
		radiobutton $f3.r3 -variable mchfrmstover -text "Interleaved (1-3,2-4,3-5.....)" -value 3
		pack $f3.r0 $f3.r1 $f3.r2 $f3.r3 -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_mchfrmst 0}
		bind $f <Return> {set pr_mchfrmst 1}
	}
	set mchfrmstchans 8
	set mchfrmstover 0
	set pr_mchfrmst 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchfrmst $f.2.e
	while {!$finished} {
		tkwait variable pr_mchfrmst
		if {$pr_mchfrmst} {
			if {[string length $mchfrmstfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $mchfrmstfnam]} {
				continue
			}
			set outfnam [string tolower $mchfrmstfnam]
			append outfnam [GetTextfileExtension mmx]
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Already Exists: Please Choose A Different Name"
				continue
			}
			if {[string length $mchfrmstchans] <= 0} {
				Inf "No Output Channel Count Entered"
				continue
			}
			if {![IsNumeric $mchfrmstchans] || ![regexp {^[0-9]+$} $mchfrmstchans] || ($mchfrmstchans < 4) || ($mchfrmstchans > 16)} {
				Inf "Invalid Output Channel Count Entered"
				continue
			}
			if {$mchfrmstover < 2} {
				if !{[IsEven $mchfrmstchans]} {
					Inf "Output Channel Count Must Be Even For Disjunct Options"
					continue
				}
			}
			set line $mchfrmstchans
			lappend outlines $line
			switch -- $mchfrmstover {
				0 -
				2 {		;# DISJUNCT OR OVERLAPPED
					set n 1
					set m 2
				}
				1 {		;#	DISJUNCT OFFSET
					set n 2
					set m 3
				}
				3 {		;#	INTERLEAVED
					set n 1
					set m 3
				}
			}
			foreach fnam $fnams {
				set line $fnam
				lappend line 0 2 
				set rout "1:$n"
				lappend line $rout 1.0
				set rout "2:$m"
				lappend line $rout 1.0
				lappend outlines $line
				incr n
				incr m
				if {$mchfrmstover < 2} {	;#	if disjunct,skip over both
					incr n
					incr m
				}
				if {$n > $mchfrmstchans} {
					set n [expr $n - $mchfrmstchans]
				}
				if {$m > $mchfrmstchans} {
					set m [expr $m - $mchfrmstchans]
				}
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write Mix Data"
				continue
			}
			foreach line $outlines {
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				set last_outfile $outfnam
				Inf "File '$outfnam' Is On The Workspace"
			}
			set  finished 1
		} else {
			set  finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Fadein soundfile from point AFTER start

proc FadeIn {} {
	global wl chlist pa evv pr_fad_in fad_infnam fad_instt fad_inend fad_in_dbl simple_program_messages prg_dun prg_abortd CDPidrun last_outfile

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	set dur $pa($fnam,$evv(DUR))
	set tempfnam $evv(DFLT_OUTNAME)
	append tempfnam 0011 $evv(SNDFILE_EXT)
	set tempfnam2 $evv(DFLT_OUTNAME)
	append tempfnam2 0012 $evv(SNDFILE_EXT)
	Block "Reversing File"
	catch {unset simple_program_messages}
	set prg_dun 0
	set prg_abortd 0
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	set cmd [file join $evv(CDPROGRAM_DIR) modify]
	lappend cmd radical 1 $fnam $tempfnam
	catch {unset simple_program_messages}
	set prg_dun 0
	set prg_abortd 0
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Failed To Run Sound Reversal Process"
		catch {unset CDPidrun}
		UnBlock
		return
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Sound Reversal Process Failed"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
		UnBlock
		return
	}
	if {![file exists $tempfnam]} {
		set msg "Sound Reversal Process Produced No Output File"
		ErrShow $msg
		DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
		UnBlock
		return
	}
	UnBlock
	set f .fad_in
	if [Dlg_Create $f "FADE IN AFTER START" "set pr_fad_in 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		button $f0.ok -text "Do Fade In" -command "set pr_fad_in 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.sv -text "Sound View" -command "SnackDisplay $evv(SN_TIMEPAIRS) fadein $evv(TIME_OUT) 0" -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_fad_in 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.sv -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Fade Start "
		entry $f1.e -textvariable fad_instt -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Fade End "
		entry $f2.e -textvariable fad_inend -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		radiobutton $f3.r0 -variable fad_in_dbl -text normal     -value 0
		radiobutton $f3.r1 -variable fad_in_dbl -text deep-slope -value 1
		pack $f3.r0 $f3.r1 -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Output Filename "
		entry $f4.e -textvariable fad_infnam -width 24
		pack $f4.e $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		set fad_in_dbl 1
		wm resizable $f 1 1
		bind $f <Escape> {set pr_fad_in 0}
		bind $f <Return> {set pr_fad_in 1}
	}
	set fad_infnam [file rootname [file tail $fnam]]
	append fad_infnam "_fadin"
	wm title $f "FADE IN $fnam"
	set pr_fad_in 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_fad_in $f.1.e
	while {!$finished} {
		tkwait variable pr_fad_in
		if {$pr_fad_in} {
			if {[string length $fad_infnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $fad_infnam]} {
				continue
			}
			set outfnam [string tolower $fad_infnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			if {![IsNumeric $fad_instt] || ($fad_instt < 0.0) || ($fad_instt >= $dur)} {
				Inf "Invalid Fade Start-Time"
				continue
			}
			if {![IsNumeric $fad_inend] || ($fad_inend <= $fad_instt) || ($fad_inend > $dur)} {
				Inf "Invalid Fade End-Time"
				continue
			}
			set fade_inend [expr $dur - $fad_instt]
			set fade_instt [expr $dur - $fad_inend]
			if {$fade_inend > $dur} {
				set fade_inend $dur
			}
			Block "Creating Fade-In"
			DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
			set cmd [file join $evv(CDPROGRAM_DIR) envel]
			lappend cmd curtail
			if {$fad_in_dbl} {
				lappend cmd 4 $tempfnam $tempfnam2 $fade_instt $fade_inend
			} else {
				lappend cmd 1 $tempfnam $tempfnam2 $fade_instt $fade_inend 1
			}
			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Run Enveloping Process"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Enveloping Process Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
				UnBlock
				continue
			}
			if {![file exists $tempfnam2]} {
				set msg "Failed To Envelope File Successfully"
				UnBlock
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
				continue
			}
			wm title .blocker "PLEASE WAIT:        RE-REVERSING FILE"
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd radical 1 $tempfnam2 $outfnam
			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Run Re-Reversing Process"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Re-Reversing Process Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
				UnBlock
				continue
			}
			if {![file exists $outfnam]} {
				set msg "Failed To Re-Reverse File Successfully"
				UnBlock
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $tempfnam
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Pan a stereo sound round multichan space

proc MchPanStereo {} {
	global wl chlist pa evv CDPidrun prg_dun prg_abortd pr_stpanmch last_outfile
	global stpanmchchans stpanmchfoc stpanmchdata stpanmchoff stpanmchfnam

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Stereo Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	set chans $pa($fnam,$evv(CHANS))
	if {($ftyp != $evv(SNDFILE)) || ($chans != 2)} {
		Inf "Select A Stereo Soundfile"
		return
	}
	set tempfnam $evv(DFLT_OUTNAME)
	append tempfnam 0011 $evv(SNDFILE_EXT)
	if [catch {file copy $fnam $tempfnam} zit] {
		Inf "Failed To Make Temporary Copy Of Input File"
		return
	}
	set tempoutfnam1 $evv(DFLT_OUTNAME)
	append tempoutfnam1 1111 $evv(SNDFILE_EXT)
	set tempoutfnam2 $evv(DFLT_OUTNAME)
	append tempoutfnam2 2222 $evv(SNDFILE_EXT)
	set mixfnam $evv(DFLT_OUTNAME)
	append mixfnam 0022 $evv(TEXT_EXT)
	Block "Extracting Channels From Stereo File"
	set prg_dun 0
	set prg_abortd 0
	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 2 $tempfnam
	set CDPidrun 0
	set prg_dun 0
	set prg_abortd 0
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "$CDPidrun : Channel Extraction Failed"
		DeleteAllTemporaryFiles
		UnBlock
		return
	} else {
	   	fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "Channel Extraction Failed"
		DeleteAllTemporaryFiles
		UnBlock
		return
	}
	set fnam_c1 [file rootname $tempfnam]
	append fnam_c1 "_c1"
	append fnam_c1 $evv(SNDFILE_EXT) 
	if {![file exists $fnam_c1]} {
		Inf "Cannot Find Channel 1 Output File"
		DeleteAllTemporaryFiles
		UnBlock
		return
	}
	set fnam_c2 [file rootname $tempfnam]
	append fnam_c2 "_c2"
	append fnam_c2 $evv(SNDFILE_EXT) 
	if {![file exists $fnam_c2]} {
		Inf "Cannot Find Channel 2 Output File"
		DeleteAllTemporaryFiles
		UnBlock
		return
	}
	UnBlock
	set f .stpanmch
	if [Dlg_Create $f "PAN STEREO AROUND MULTICHANNEL SPACE" "set pr_stpanmch 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		button $f0.ok -text "Do Panning" -command "set pr_stpanmch 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_stpanmch 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output Channels (4-16) "
		entry $f1.e -textvariable stpanmchchans -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Focus (0-1)"
		entry $f2.e -textvariable stpanmchfoc -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Pan Data Filename "
		entry $f3.e -textvariable stpanmchdata -width 24
		pack $f3.e $f3.ll -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Pan Data will be applied to left channel: right channel pan will be offset by" -fg $evv(SPECIAL)
		pack $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		label $f5.ll -text "Channel offset of right channel"
		entry $f5.e -textvariable stpanmchoff -width 24
		pack $f5.e $f5.ll -side left
		pack $f5 -side top -pady 2 -fill x -expand true
		label $f6.ll -text "Output Filename "
		entry $f6.e -textvariable stpanmchfnam -width 24
		pack $f6.e $f6.ll -side left
		pack $f6 -side top -pady 2 -fill x -expand true
		set stpanmch_dbl 1
		wm resizable $f 1 1
		bind .stpanmch.1.e <Down> {focus .stpanmch.2.e}
		bind .stpanmch.2.e <Down> {focus .stpanmch.3.e}
		bind .stpanmch.3.e <Down> {focus .stpanmch.5.e}
		bind .stpanmch.5.e <Down> {focus .stpanmch.6.e}
		bind .stpanmch.6.e <Down> {focus .stpanmch.1.e}
		bind .stpanmch.1.e <Up> {focus .stpanmch.6.e}
		bind .stpanmch.2.e <Up> {focus .stpanmch.1.e}
		bind .stpanmch.3.e <Up> {focus .stpanmch.2.e}
		bind .stpanmch.5.e <Up> {focus .stpanmch.3.e}
		bind .stpanmch.6.e <Up> {focus .stpanmch.5.e}
		set stpanmchoff 2
		bind $f <Escape> {set pr_stpanmch 0}
		bind $f <Return> {set pr_stpanmch 1}
	}
	set pr_stpanmch 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_stpanmch $f.1.e
	while {!$finished} {
		tkwait variable pr_stpanmch
		if {$pr_stpanmch} {
			if {![IsNumeric $stpanmchchans] || ![regexp {^[0-9]+$} $stpanmchchans] || ($stpanmchchans < 4) || ($stpanmchchans > 16)} {
				Inf "Invalid Output Channel Count Entered"
				continue
			}
			if {![IsNumeric $stpanmchfoc] || ($stpanmchfoc < 0.0) || ($stpanmchfoc > 1.0)} {
				Inf "Invalid Focus Value Entered"
				continue
			}
			if {![IsNumeric $stpanmchoff] || ![regexp {^[0-9]+$} $stpanmchoff] || ($stpanmchoff < 1) || ($stpanmchoff > [expr $stpanmchchans - 1])} {
				Inf "Invalid Channel Offset Entered"
				continue
			}
			if {[string length $stpanmchfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $stpanmchfnam]} {
				continue
			}
			set outfnam [string tolower $stpanmchfnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			if {[string length $stpanmchdata] <= 0} {
				Inf "No Pan Data Filename Entered"
				continue
			}
			if {![file exists $stpanmchdata]} {
				if {[string length [file extension $stpanmchdata]] == 0} {
					set datafnam $stpanmchdata$evv(TEXT_EXT)
					if {[file exists $datafnam]} {
						set stpanmchdata $datafnam
					}
				}
			}
			if {![file exists $stpanmchdata]} {
				Inf "Pan Data File Does Not Exist"
				continue
			}
			if [catch {open $stpanmchdata "r"} zit] {
				Inf "Cannot Open File '$stpanmchdata' To Read Pan Data"
				continue
			}
			Block "Reading Panning Data"
			set lasttime -1.0
			set OK 1
			set linecnt 1
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				set line [split $line]
				set cnt 0
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					if {![IsNumeric $item]} {
						Inf "Invalid Pan Data On Line '$linecnt'"
						close $zit
						set OK 0
						break
					}
					switch -- $cnt {
						0 {
							if {($item < 0.0) || ($item <= $lasttime)} {
								Inf "Invalid Time Data On Line '$linecnt'"
								set OK 0
								break
							}
							set lasttime $item
						}
						1 {
							if {($item < 0.0) || ($item > $stpanmchchans)} {
								Inf "Invalid Pan-Position Data On Line '$linecnt'"
								set OK 0
								break
							}
							set position $item
						}
						2 {
							if {($item != 0.0) && ($item != 1.0) && ($item != -1.0)} {
								Inf "Invalid Pantype Data On Line '$linecnt'"
								set OK 0
								break
							}
							if {$item == 0.0} {
								if {![regexp {^[0-9]+$} $position]	|| ($position == 0)} {
									Inf "Position Not Compatible With Pan-Type On Line $linecnt"
									set OK 0
									break
								}
							}
						}
						default {
							Inf "Invalid Pan Data On Line $linecnt"
							set OK 0
							break
						}
					}
					incr cnt
				}
				if {!$OK} {
					break
				}
				if {$cnt != 3} {
					Inf "Invalid Pan Data On Line $linecnt"
					set OK 0
					break
				}
				incr linecnt
			}
			close $zit
			if {!$OK} {
				UnBlock
				continue
			}
			set exceptions [list $fnam_c1 $fnam_c2]

			set cmd [file join $evv(CDPROGRAM_DIR) mchanpan]
			lappend cmd mchanpan 1 $fnam_c1 $tempoutfnam1 $stpanmchdata $stpanmchchans -f$stpanmchfoc

			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			wm title .blocker "PLEASE WAIT:        PANNING LEFT CHANNEL"			
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "FAILED TO PAN LEFT CHANNEL"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Pan Of Left Channel Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
				UnBlock
				continue
			}
			if {![file exists $tempoutfnam1]} {
				set msg "Pan Of Left Channel Produced No Output File"
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions
				UnBlock
				continue
			}

			set cmd [file join $evv(CDPROGRAM_DIR) mchanpan]
			lappend cmd mchanpan 1 $fnam_c2 $tempoutfnam2 $stpanmchdata $stpanmchchans -f$stpanmchfoc

			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			wm title .blocker "PLEASE WAIT:        PANNING RIGHT CHANNEL"			
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Pan Right Channel"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Pan Of Right Channel Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
				UnBlock
				continue
			}
			if {![file exists $tempoutfnam2]} {
				set msg "Pan Of Right Channel Produced No Output File"
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions
				UnBlock
				continue
			}
			wm title .blocker "PLEASE WAIT:        CREATING TEMPORARY MIXFILE"			
			catch {unset nulines}
			set line $stpanmchchans
			lappend nulines $line
			set line $tempoutfnam1
			lappend line 0.0 $stpanmchchans
			set n 1
			while {$n <= $stpanmchchans} {
				set rout $n
				append rout ":" $n
				lappend line $rout
				lappend line 1.0
				incr n
			}
			lappend nulines $line
			set line $tempoutfnam2
			lappend line 0.0 $stpanmchchans
			set n 1
			while {$n <= $stpanmchchans} {
				set m [expr $n + $stpanmchoff]
				if {$m > $stpanmchchans} {
					set m [expr $m - $stpanmchchans]
				}
				set rout $n
				append rout ":" $m
				lappend line $rout
				lappend line 1.0
				incr n
			}
			lappend nulines $line

			if [catch {open $mixfnam "w"} zit] {
				Inf "Cannot Open Temporary Mixfile '$mixfnam'"
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
				UnBlock
				continue
			}
			foreach line $nulines {
				puts $zit $line
			}
			close $zit
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $mixfnam $outfnam

			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			wm title .blocker "PLEASE WAIT:        MIXING FINAL OUTPUT SOUND"			
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Create Multichannel Mix"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Mixing Final Output Sound Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
				UnBlock
				continue
			}
			if {![file exists $outfnam]} {
				set msg "Mixing Final Output Sound Produced No Output File"
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions
				UnBlock
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Rotate a multichan sound round multichan space

proc MchRotateMchan {} {
	global wl chlist pa evv CDPidrun prg_dun prg_abortd pr_strotmch last_outfile
	global strotmchchans strotmchsttchan strotmchspeed strotmchfoc strotmchoff strotmchfnam

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Soundfile With More Than One Channel"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	set inchans $pa($fnam,$evv(CHANS))
	if {($ftyp != $evv(SNDFILE)) || ($inchans < 2)} {
		Inf "Select A Soundfile With More Than One Channel"
		return
	}
	set tempfnam $evv(DFLT_OUTNAME)
	append tempfnam 0011 $evv(SNDFILE_EXT)
	if [catch {file copy $fnam $tempfnam} zit] {
		Inf "Failed To Make Temporary Copy Of Input File"
		return
	}
	set k 1
	while {$k <= $inchans} {
		set tempoutfnam($k) $evv(DFLT_OUTNAME)
		append tempoutfnam($k) $k$k$k$k $evv(SNDFILE_EXT)
		incr k
	}
	set mixfnam $evv(DFLT_OUTNAME)
	append mixfnam 0022 $evv(TEXT_EXT)
	Block "Extracting Channels From Multichannel File"
	set prg_dun 0
	set prg_abortd 0
	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 2 $tempfnam
	set CDPidrun 0
	set prg_dun 0
	set prg_abortd 0
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "$CDPidrun : Channel Extraction Failed"
		DeleteAllTemporaryFiles
		UnBlock
		return
	} else {
	   	fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "Channel Extraction Failed"
		DeleteAllTemporaryFiles
		UnBlock
		return
	}
	set k 1
	while {$k <= $inchans} {
		set fnam_c($k) [file rootname $tempfnam]
		append fnam_c($k) "_c$k"
		append fnam_c($k) $evv(SNDFILE_EXT) 
		if {![file exists $fnam_c($k)]} {
			Inf "Cannot Find Channel $k Output File"
			DeleteAllTemporaryFiles
			UnBlock
			return
		}
		incr k
	}
	UnBlock
	set f .strotmch
	if [Dlg_Create $f "ROTATE MULTICHAN FILE AROUND MULTICHANNEL SPACE" "set pr_strotmch 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		button $f0.ok -text "Do Panning" -command "set pr_strotmch 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_strotmch 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output Channels (4-16) "
		entry $f1.e -textvariable strotmchchans -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Start Position of Leftmost Channel"
		entry $f2.e -textvariable strotmchsttchan -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Speed (cycles per sec) "
		entry $f3.e -textvariable strotmchspeed -width 24
		button $f3.b -text "Get File" -command "Dlg_GetTextfile 0 -1 mchrot" -highlightbackground [option get . background {}]
		pack $f3.e $f3.ll $f3.b -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Focus (0-1)"
		entry $f4.e -textvariable strotmchfoc -width 24
		pack $f4.e $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		checkbutton $f5.ch -variable strotmchanti -text "Anticlockwise (default Clockwise)"
		pack $f5.ch -side left
		pack $f5 -side top -pady 2 -fill x -expand true
		label $f6.ll -text "Output Filename "
		entry $f6.e -textvariable strotmchfnam -width 24
		pack $f6.e $f6.ll -side left
		pack $f6 -side top -pady 2 -fill x -expand true
		set strotmch_dbl 1
		wm resizable $f 1 1
		bind .strotmch.1.e <Down> {focus .strotmch.2.e}
		bind .strotmch.2.e <Down> {focus .strotmch.3.e}
		bind .strotmch.3.e <Down> {focus .strotmch.4.e}
		bind .strotmch.4.e <Down> {focus .strotmch.6.e}
		bind .strotmch.6.e <Down> {focus .strotmch.1.e}
		bind .strotmch.1.e <Up> {focus .strotmch.6.e}
		bind .strotmch.2.e <Up> {focus .strotmch.1.e}
		bind .strotmch.3.e <Up> {focus .strotmch.2.e}
		bind .strotmch.4.e <Up> {focus .strotmch.3.e}
		bind .strotmch.6.e <Up> {focus .strotmch.4.e}
		set strotmchoff 2
		bind $f <Escape> {set pr_strotmch 0}
		bind $f <Return> {set pr_strotmch 1}
	}
	set pr_strotmch 0
	set strotmchanti 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_strotmch $f.1.e
	while {!$finished} {
		tkwait variable pr_strotmch
		if {$pr_strotmch} {
			if {![IsNumeric $strotmchchans] || ![regexp {^[0-9]+$} $strotmchchans] || ($strotmchchans < 4) || ($strotmchchans > 16)} {
				Inf "Invalid Output Channel Count Entered"
				continue
			}
			if {![IsNumeric $strotmchsttchan] || ($strotmchsttchan < 1.0) || ($strotmchsttchan > $strotmchchans)} {
				Inf "Invalid Start Channel"
				continue
			}
			if {![IsNumeric $strotmchfoc] || ($strotmchfoc < 0.0) || ($strotmchfoc > 1.0)} {
				Inf "Invalid Focus Value Entered"
				continue
			}
			if {[string length $strotmchspeed] <= 0} { 
				Inf "No Rotation Speed Entered"
				continue
			}
			if {[IsNumeric $strotmchspeed]} {
				if {($strotmchspeed < 0) || ($strotmchspeed > 64)} {
					Inf "Rotation Speed Out Of Range (0 - 64)"
					continue
				}
			} else {
				if {![file exists $strotmchspeed]} {
					Inf "File '$strotmchspeed' Does Not Exist"
					continue
				}
				if {![info exists pa($strotmchspeed,$evv(FTYP))]} {
					Inf "File '$strotmchspeed' Is Not On The Workspace: Cannot Proceed"
					continue
				}
				if {![IsABrkfile $pa($strotmchspeed,$evv(FTYP))]} {
					Inf "File '$strotmchspeed' Is Not A Breakpoint File"
					continue
				}
				if {($pa($strotmchspeed,$evv(MINBRK)) < 0.0) || ($pa($strotmchspeed,$evv(MAXBRK)) > 64.0)} {
					Inf "Values In File '$strotmchspeed' Are Out Of Range (0 - 64)"
					continue
				}
			}
			if {[string length $strotmchfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $strotmchfnam]} {
				continue
			}
			set outfnam [string tolower $strotmchfnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}

			set offset 0
			set k 1
			set exceptions {}
			while {$k <= $inchans} {
				set strotmchsttchan_($k) [expr $strotmchsttchan + $offset]
				if {$strotmchsttchan_($k) > $strotmchchans} {
					set strotmchsttchan_($k) [expr $strotmchsttchan_($k) - $strotmchchans]
				}
				incr offset
				lappend exceptions $fnam_c($k)
				incr k
			}
			Block "Rotating the Sound"
			set OK 1
			set k 1
			while {$k <= $inchans} {
				set cmd [file join $evv(CDPROGRAM_DIR) mchanpan]
				lappend cmd mchanpan 9 $fnam_c($k) $tempoutfnam($k) $strotmchchans $strotmchsttchan_($k) $strotmchspeed $strotmchfoc
				if {$strotmchanti} {
					lappend cmd -a
				}
				catch {unset simple_program_messages}
				set prg_dun 0
				set prg_abortd 0
				wm title .blocker "PLEASE WAIT:        PANNING CHANNEL $k"			
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Pan Channel $k"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Pan Of Channel $k Failed"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
					set OK 0
					break
				}
				if {![file exists $tempoutfnam($k)]} {
					set msg "Pan Of Channel $k Produced No Output File"
					ErrShow $msg
					DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions
					set OK 0
					break
				}
				incr k
			}
			if {!$OK} {
				UnBlock
				continue
			}
			wm title .blocker "PLEASE WAIT:        CREATING TEMPORARY MIXFILE"			
			catch {unset nulines}
			set line $strotmchchans
			lappend nulines $line
			set k 1
			while {$k <= $inchans} {
				set line $tempoutfnam($k)
				lappend line 0.0 $strotmchchans
				set n 1
				while {$n <= $strotmchchans} {
					set rout $n
					append rout ":" $n
					lappend line $rout
					lappend line 1.0
					incr n
				}
				lappend nulines $line
				incr k
			}
			if [catch {open $mixfnam "w"} zit] {
				Inf "Cannot Open Temporary Mixfile '$mixfnam'"
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
				UnBlock
				continue
			}
			foreach line $nulines {
				puts $zit $line
			}
			close $zit
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $mixfnam $outfnam

			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			wm title .blocker "PLEASE WAIT:        MIXING FINAL OUTPUT SOUND"			
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Create Multichannel Mix"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Mixing Final Output Sound Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions 
				UnBlock
				continue
			}
			if {![file exists $outfnam]} {
				set msg "Mixing Final Output Sound Produced No Output File"
				ErrShow $msg
				DeleteAllTemporaryFilesWhichAreNotCDPOutput except $exceptions
				UnBlock
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-------  Convert stereo mix to multiuchannel mix

proc StereoToMchMix {} {
	global wl chlist pa evv pr_stmixtomch last_outfile stmixtomchchans stmixtomchfnam

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Standard Mixfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {![IsAMixfile $ftyp]} {
		Inf "Select A Standard Mixfile"
		return
	}
	set f .stmixtomch
	if [Dlg_Create $f "CONVERT TO MULTICHANNEL MIXFILE" "set pr_stmixtomch 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Convert" -command "set pr_stmixtomch 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_stmixtomch 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output Channels (4-16) "
		entry $f1.e -textvariable stmixtomchchans -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Output Filename "
		entry $f2.e -textvariable stmixtomchfnam -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind .stmixtomch <Down> {IncrMixOutChans 1 stmixtomchchans}
		bind .stmixtomch <Up>   {IncrMixOutChans 0 stmixtomchchans}
		set stmixtomchchans 8
		bind $f <Escape> {set pr_stmixtomch 0}
		bind $f <Return> {set pr_stmixtomch 1}
	}
	set pr_stmixtomch 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_stmixtomch $f.1.e
	while {!$finished} {
		tkwait variable pr_stmixtomch
		if {$pr_stmixtomch} {
			if {![IsNumeric $stmixtomchchans] || ![regexp {^[0-9]+$} $stmixtomchchans] || ($stmixtomchchans < 4) || ($stmixtomchchans > 16)} {
				Inf "Invalid Output Channel Count Entered"
				continue
			}
			if {[string length $stmixtomchfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $stmixtomchfnam]} {
				continue
			}
			set outfnam [string tolower $stmixtomchfnam]
			append outfnam [GetTextfileExtension mmx]
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			catch {unset nulines}
			if [catch {open $fnam "r"} zit] {
				Inf "Cannot Open File '$fnam' To Read Original Mix Data"
				continue
			}
			Block "Converting Mixfile"
			set nuline $stmixtomchchans
			lappend nulines $nuline
			while {[gets $zit line] >= 0} {
				set line [string trim $line]
				if {[string length $line] <= 0} {
					continue
				}
				if {[string match ";" [string index $line 0]]} {
					continue
				}
				set line [split $line]
				set cnt 0
				catch {unset nuline}
				foreach item $line {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					switch -- $cnt {
						0 -
						1 {
							lappend nuline $item
						}
						2 {
							lappend nuline $item
							set inchans $item
						}
						3 {
							set firstlevel $item
						}
						4 {
							set firstpan $item
						}
						5 {
							set secondlevel $item
						}
						6 {
							set secondpan $item
						}
					}
					incr cnt
				}
				switch -- $cnt {
					4 {
						set rout "1:1"
						set level $firstlevel
						lappend nuline $rout $level
						if {$inchans > 1} {
							set rout "2:2"
							lappend nuline $rout $level
						}
					}
					5 {
						if {[string match $firstpan "C"]} {
							set rout "1:1"
							set level $firstlevel
							lappend nuline $rout $level
							set rout "1:2"
							lappend nuline $rout $level
						} elseif {[string match $firstpan "L"]} {
							set rout "1:1"
							set level $firstlevel
							lappend nuline $rout $level
						} elseif {[string match $firstpan "R"]} {
							set rout "1:2"
							set level $firstlevel
							lappend nuline $rout $level
						} else {
							set rout "1:1"
							set level [expr 1.0 - $firstpan]
							lappend nuline $rout [expr $level * $firstlevel]
							set rout "1:2"
							set level $firstpan
							lappend nuline $rout [expr $level * $firstlevel]
						}
					}
					7 {
						if {[string match $firstpan "C"]} {
							set rout "1:1"
							set level $firstlevel
							lappend nuline $rout $level
							set rout "1:2"
							lappend nuline $rout $level
						} elseif {[string match $firstpan "L"]} {
							set rout "1:1"
							set level $firstlevel
							lappend nuline $rout $level
						} elseif {[string match $firstpan "R"]} {
							set rout "1:2"
							set level $firstlevel
							lappend nuline $rout $level
						} else {
							set rout "1:1"
							set firstpan [expr ($firstpan + 1.0) / 2.0]		
							set level [expr 1.0 - $firstpan]
							lappend nuline $rout [expr $level * $firstlevel]
							set rout "1:2"
							set level $firstpan
							lappend nuline $rout [expr $level * $firstlevel]
						}
						if {[string match $secondpan "C"]} {
							set rout "2:1"
							set level $secondlevel
							lappend nuline $rout $level
							set rout "2:2"
							lappend nuline $rout $level
						} elseif {[string match $secondpan "L"]} {
							set rout "2:1"
							set level $secondlevel
							lappend nuline $rout $level
						} elseif {[string match $secondpan "R"]} {
							set rout "2:2"
							set level $secondlevel
							lappend nuline $rout $level
						} else {
							set rout "2:1"
							set secondpan [expr ($secondpan + 1.0) / 2.0]		
							set level [expr 1.0 - $secondpan]
							lappend nuline $rout [expr $level * $secondlevel]
							set rout "2:2"
							set level $secondpan
							lappend nuline $rout [expr $level * $secondlevel]
						}
					}
				}
				lappend nulines $nuline
			}
			close $zit
			if {![info exists nulines]} {
				Inf "No Active Data Found In Input Mixfile"
				UnBlock
				continue
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open Output File '$outfnam' To Write Multichannel Mix Data"
				UnBlock
				continue
			}
			foreach line $nulines {
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			UnBlock
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc IncrMixOutChans {down varname} {
	global stmixtomchchans montomchchans
	upvar $varname val
	if {$down} {
		if {$val > 1} {
			incr val -1
		}
	} else {
		if {$val < 16} {
			incr val
		}
	}
	switch -- $varname {
		"stmixtomchchans" {
			set stmixtomchchans $val
		}
		"montomchchans" {
			set montomchchans $val
		}
	}
}

#---- Convert mono soundfile to multichannel file

proc MonoToMch {} {
	global wl chlist pa evv CDPidrun prg_dun prg_abortd pr_montomch last_outfile montomchchans montomchfnam simple_program_messages released

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Mono Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	set chans $pa($fnam,$evv(CHANS))
	if {($ftyp != $evv(SNDFILE)) || ($chans != 1)} {
		Inf "Select A Mono Soundfile"
		return
	}
	set mixfnam $evv(DFLT_OUTNAME)
	append mixfnam [GetTextfileExtension mmx]
	set f .montomch
	if [Dlg_Create $f "CONVERT MONO SOUND TO MULTICHANNEL" "set pr_montomch 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Convert" -command "set pr_montomch 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_montomch 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output Channels (4-16) "
		entry $f1.e -textvariable montomchchans -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Output Filename "
		entry $f2.e -textvariable montomchfnam -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind .montomch <Up>   {IncrMixOutChans 0 montomchchans}
		bind .montomch <Down> {IncrMixOutChans 1 montomchchans}
		set montomchchans 8
		bind $f <Escape> {set pr_montomch 0}
		bind $f <Return> {set pr_montomch 1}
	}
	set montomchfnam [file rootname [file tail $fnam]]
	catch {file delete $mixfnam}
	set pr_montomch 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_montomch $f.2.e
	while {!$finished} {
		tkwait variable pr_montomch
		if {$pr_montomch} {
			if {![IsNumeric $montomchchans] || ![regexp {^[0-9]+$} $montomchchans] || ($montomchchans < 4) || ($montomchchans > 16)} {
				Inf "Invalid Output Channel Count Entered"
				continue
			}
			if {[string length $montomchfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $montomchfnam]} {
				continue
			}
			set outfnam [string tolower $montomchfnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			Block "Creating Multichannel File"
			set cmd [file join $evv(CDPROGRAM_DIR) mton]
			lappend cmd mton $fnam $outfnam $montomchchans
			catch {unset simple_program_messages}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Convert To Multichannel"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Conversion To Multichannel Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			if {![file exists $outfnam]} {
				set msg "Conversion To Multichannel Produced No Output File"
				ErrShow $msg
				UnBlock
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Rearrange a soundfile by moving a chunk of it somewhere else

proc Rearrange {} {
	global wl chlist pa evv CDPidrun prg_dun prg_abortd pr_rearra last_outfile rearrastt rearraend rearrains rearraspl rearrasv rearrafnam
	global rearraatstart rearraatend rearra2 rearradur wstk

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	set rearradur $pa($fnam,$evv(DUR))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	set cutfnam $evv(DFLT_OUTNAME)
	append cutfnam 0011 $evv(SNDFILE_EXT)
	set partfnam $evv(DFLT_OUTNAME)
	append partfnam 0022 $evv(SNDFILE_EXT)
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	set rearrasv 0
	set f .rearra
	if [Dlg_Create $f "REARRANGE A SOUNDFILE" "set pr_rearra 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		button $f0.ok -text "Rearrange" -command "set pr_rearra 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.sv -text "Sound View" -command RearrangeSview  -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		checkbutton $f0.cc -variable rearra2 -text "Copy/Insert but Keep original"
		set rearra2 0
		button $f0.quit -text "Quit" -command "set pr_rearra 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.sv $f0.cc -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Start of chunk to move"
		entry $f1.e -textvariable rearrastt -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "End of chunk to move"
		entry $f2.e -textvariable rearraend -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Chunk reinsertion time"
		entry $f3.e -textvariable rearrains -width 24
		checkbutton $f3.chstt -variable rearraatstart -text "At Start" -command {RearraAt 0}
		checkbutton $f3.chend -variable rearraatend   -text "At End"   -command {RearraAt 1}
		pack $f3.e $f3.ll $f3.chstt $f3.chend -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Splice length (mS)"
		entry $f4.e -textvariable rearraspl -width 24
		pack $f4.e $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		label $f5.ll -text "Output Filename "
		entry $f5.e -textvariable rearrafnam -width 24
		pack $f5.e $f5.ll -side left
		pack $f5 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind .rearra.1.e <Up>   {focus .rearra.5.e}
		bind .rearra.2.e <Up>   {focus .rearra.1.e}
		bind .rearra.3.e <Up>   {focus .rearra.2.e}
		bind .rearra.4.e <Up>   {focus .rearra.3.e}
		bind .rearra.5.e <Up>   {focus .rearra.4.e}
		bind .rearra.1.e <Down> {focus .rearra.2.e}
		bind .rearra.2.e <Down> {focus .rearra.3.e}
		bind .rearra.3.e <Down> {focus .rearra.4.e}
		bind .rearra.4.e <Down> {focus .rearra.5.e}
		bind .rearra.5.e <Down> {focus .rearra.1.e}
		set rearraspl 15
		bind $f <Escape> {set pr_rearra 0}
		bind $f <Return> {set pr_rearra 1}
	}
	set rearrafnam 	[file rootname [file tail $fnam]] 
	set rearraatstart 0
	set rearraatend 0
	set pr_rearra 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_rearra $f.1.e
	while {!$finished} {
		tkwait variable pr_rearra
		if {$pr_rearra} {
			if {![IsNumeric $rearraspl] || ($rearraspl < 0.0) || ($rearraspl > 5000)} {
				Inf "Invalid Splice Length"
				continue
			}
			set twosplices [expr $rearraspl * $evv(MS_TO_SECS) * 2.0]
			if {$twosplices >= $rearradur} {
				Inf "Impossible Splice Length For This Sound"
				continue
			}
			if {![IsNumeric $rearrastt] || ($rearrastt < 0.0) || ($rearrastt > $rearradur)} {
				Inf "Invalid Chunk Start Time"
				continue
			}
			if {[expr $rearrastt + $twosplices] >= $rearradur} {
				Inf "Chunk Start Time Too Late For Given Splicelength"
				continue
			}
			if {![IsNumeric $rearraend] || ($rearraend <= $rearrastt) || ($rearrastt > $rearradur)} {
				Inf "Invalid Chunk End Time"
				continue
			}
			if {$rearraend <= [expr $rearrastt + $twosplices]} {
				Inf "Chunk Too Small For Given Splicelength"
				continue
			}
			if {![IsNumeric $rearrains] || ($rearrains < 0.0)} {
				Inf "Invalid Chunk Reinsertion Time"
				continue
			}
			set atstart 0
			set atend 0
			if {[Flteq $rearrains 0.0]} {
				set atstart 1
				set rearrains 0.0
			} elseif {[Flteq $rearrains $rearradur]} {
				set rearrains $rearradur
				set atend 1
			}
			if {$rearrains > $rearradur} {
				Inf "Invalid Chunk Reinsertion Time"
				continue
			}
			if {($rearrains >= $rearrastt) && ($rearrains <= $rearraend)} {
				Inf "Impossible Reinsertion Time (Cannot Be Within The Chunk Itself)"
				continue
			}
			if {!$rearra2 && ($rearrains >= $rearraend)} {
				set chunklen [expr $rearraend - $rearrastt]
				set reinserttime [expr $rearrains - $chunklen]
			} else {
				set reinserttime $rearrains
			}
			if {[string length $rearrafnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $rearrafnam]} {
				continue
			}
			set outfnam [string tolower $rearrafnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			Block "Getting Chunk"
			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			lappend cmd cut 1 $fnam $cutfnam $rearrastt $rearraend -w$rearraspl
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Get Chunk"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Chunk Harvesting Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			if {![file exists $cutfnam]} {
				set msg "Chunk Harvesting Produced No Output File"
				ErrShow $msg
				UnBlock
				continue
			}
			if {$rearra2} {		;#	DON'T DELTE THE CHUNK : JUST COPY AND INSERT THE COPY IN ORIGINAL FILE
				if [catch {file copy $fnam $partfnam} zit] {
					set msg "Failed to copy source file to temporary file : $zit"
					ErrShow $msg
					UnBlock
					continue
				}
			} else {
				wm title .blocker "PLEASE WAIT:        Excising chunk from original"			
				set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
				lappend cmd excise 1 $fnam $partfnam $rearrastt $rearraend -w$rearraspl
				set prg_dun 0
				set prg_abortd 0
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Excise Chunk From Original"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Chunk Excision Failed"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {![file exists $partfnam]} {
					set msg "Chunk Excision Produced No Output File"
					ErrShow $msg
					UnBlock
					continue
				}
			}
			wm title .blocker "PLEASE WAIT:        REINSERTING CHUNK AT NEW POSITION"			
			set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
			if {$atstart} {
				lappend cmd join $cutfnam $partfnam $outfnam -w$rearraspl
			} elseif {$atend} {
				lappend cmd join $partfnam $cutfnam $outfnam -w$rearraspl
			} else {
				lappend cmd insert 1 $partfnam $cutfnam $outfnam $reinserttime -w$rearraspl
			}
			set prg_dun 0
			set prg_abortd 0
			if [catch {open "|$cmd"} CDPidrun] {
				ErrShow "Failed To Reinsert Chunk"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Chunk Reinsertion Failed"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				UnBlock
				continue
			}
			if {![file exists $outfnam]} {
				set msg "Chunk Reinsertion Produced No Output File"
				ErrShow $msg
				UnBlock
				continue
			}
			UnBlock
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
				set last_outfile $outfnam
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Sound View (double function) for "Rearrange"

proc RearrangeSview {} {
	global rearrasv evv wstk rearra2
	if {$rearrasv} {
		set msg "Mark Insertion Time ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			SnackDisplay $evv(SN_SINGLETIME) rearranget $evv(TIME_OUT) 0
			set rearrasv 0
		} else {
			SnackDisplay $evv(SN_TIMEPAIRS) rearrangech $evv(TIME_OUT) 0
		}
	} else {
		if {$rearra2} {
			set msg "Mark position of chunk to duplicate ??"
		} else {
			set msg "Mark Position Of Chunk To Be Moved ??"
		}
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "yes"} {
			SnackDisplay $evv(SN_TIMEPAIRS) rearrangech $evv(TIME_OUT) 0
			set rearrasv 1
		} else {
			SnackDisplay $evv(SN_SINGLETIME) rearranget $evv(TIME_OUT) 0
		}
	}
}

#---- Toggle the "Start" and "end" Checkbuttons in "Rearrange", and set insertion time appropriately

proc RearraAt {atend} {
	global rearraatend rearraatstart rearradur rearrains
	if {$atend} {
		if {$rearraatend} {
			set rearraatstart 0
			set rearrains $rearradur
		} elseif {[Flteq $rearrains $rearradur]} {
			set rearrains ""
		}
	} else {
		if {$rearraatstart} {
			set rearraatend 0
			set rearrains 0.0
		} elseif {[Flteq $rearrains 0.0]} {
			set rearrains ""
		}
	}
}

#---- Produce a time-varying frequency file, for tremolando or vibrato

proc TremVary {} {
	global prm pa chlist evv pr_tremvar last_outfile tremvartstep tremvarfnam tremvarrang tremvarrand

	if {![IsNumeric $prm(0)]} {
		Inf "No Valid (Average) Tremolo Frq In Parameter 1"
		return
	}
	set frq $prm(0)
	if {![info exists chlist] || ([llength $chlist] < 1) || ![info exists pa]} {
		return
	}
	set dur $pa([lindex $chlist 0],$evv(DUR))
	set f .tremvar
	if [Dlg_Create $f "GENERATE VARIABLE FREQUENCY" "set pr_tremvar 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		button $f0.ok -text "Create File" -command "set pr_tremvar 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_tremvar 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Average timestep to next randomised value "
		entry $f1.e -textvariable tremvartstep -width 24
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true

		label $f2.ll -text "Randomisation of timesteps (0-1) "
		entry $f2.e -textvariable tremvarrand -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true

		label $f3.ll -text "Max (+ or -) wander of frq "
		entry $f3.e -textvariable tremvarrang -width 24
		pack $f3.e $f3.ll -side left
		pack $f3 -side top -pady 2 -fill x -expand true

		label $f4.ll -text "Output Filename "
		entry $f4.e -textvariable tremvarfnam -width 24
		pack $f4.e $f4.ll -side left
		pack $f4 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind .tremvar.1.e <Up>   {focus .tremvar.2.e}
		bind .tremvar.2.e <Up>   {focus .tremvar.1.e}
		bind .tremvar.3.e <Up>   {focus .tremvar.2.e}
		bind .tremvar.4.e <Up>   {focus .tremvar.3.e}
		bind .tremvar.1.e <Down> {focus .tremvar.2.e}
		bind .tremvar.2.e <Down> {focus .tremvar.3.e}
		bind .tremvar.3.e <Down> {focus .tremvar.4.e}
		bind .tremvar.4.e <Down> {focus .tremvar.1.e}
		set tremvartstep 1
		set tremvartrand .5
		set tremvartrang 0
		bind $f <Escape> {set pr_tremvar 0}
		bind $f <Return> {set pr_tremvar 1}
	}
	set pr_tremvar 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_tremvar $f.1.e
	while {!$finished} {
		tkwait variable pr_tremvar
		if {$pr_tremvar} {
			if {![IsNumeric $tremvartstep] || ($tremvartstep <= .01) || ($tremvartstep > $dur)} {
				Inf "Invalid Time Step"
				continue
			}
			if {![IsNumeric $tremvarrand] || ($tremvarrand < 0) || ($tremvarrand > 1)} {
				Inf "Invalid Randomisation Value"
				continue
			}
			if {![IsNumeric $tremvarrang] || ($tremvarrang <= 0) || ($tremvarrang > $frq)} {
				Inf "Invalid Frq Wander"
				continue
			}
			if {[string length $tremvarfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $tremvarfnam]} {
				continue
			}
			set outfnam [string tolower $tremvarfnam]
			append outfnam [GetTextfileExtension brk]
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			set halfstep [expr $tremvartstep/2.0]
			set val 0.0
			while {$val <= $dur} {
				lappend times $val
				set val [expr $val + $tremvartstep]
			}
			if {$tremvarrand > 0} {
				set len [llength $times]
				set len_less_one [expr $len - 1]
				set n 1
				while {$n < $len_less_one} {
					set wander [expr (rand() * 2.0) - 1.0]		;#	Range -1 to 1
					set wander [expr $wander * $tremvarrand]	;#	Range -tremvarrand to +tremvarrand
					set wander [expr $wander * $halfstep]
					set val [expr [lindex $times $n] + $wander]
					set times [lreplace $times $n $n $val]
					incr n
				}
			}
			set n 0
			while {$n < $len} {
				set wander [expr (rand() * 2.0) - 1.0]			;#	Range -1 to 1
				set wander [expr $wander * $tremvarrang]		;#	Range -tremvarrang to +tremvarrang
				set val [expr $frq + $wander]
				lappend frqs $val
				incr n
			}
			if [catch {open $outfnam "w"} zit] {
				Inf "Cannot Open File '$outfnam' To Write Frequency Data"
				continue
			}
			foreach time $times frq $frqs {
				set line [list $time $frq]
				puts $zit $line
			}
			close $zit
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				set last_outfile $outfnam
			}
			set prm(0) $outfnam
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#----- Find if any chans of a multichan file are empty: covert to less chans

proc MchanActive {} {
	global wl chlist pa evv CDPidrun CDPmaxId prg_dun prg_abortd pr_mchactv last_outfile mchactvfnam mchactvchans maxsamp_line simple_program_messages

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	set mchactvchans $pa($fnam,$evv(CHANS))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	if {$mchactvchans < 2} {
		Inf "Select A Multichannel Soundfile"
		return
	}
	set chanfnam $evv(DFLT_OUTNAME)
	set baschanfnam $chanfnam
	append chanfnam 0011 $evv(SNDFILE_EXT)
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	if [catch {file copy $fnam $chanfnam} zit] {
		Inf "Cannot Make Temporary Copy Of Input File"
		return
	}
	set f .mchactv
	if [Dlg_Create $f "TEST FOR EMPTY CHANNELS" "set pr_mchactv 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		label $f2.ll -text "File [file rootname [file tail $fnam]]" -fg $evv(SPECIAL)
		pack $f2.ll -side left
		pack $f2 -side top -pady 2
		button $f0.ok -text "Remove contiguous empty output channels" -width 40 -command "set pr_mchactv 2" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mchactv 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Output Filename "
		entry $f1.e -textvariable mchactvfnam -width 20
		pack $f1.ll $f1.e -side left -padx 2
		pack $f1 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_mchactv 0}
	}
	$f.2.ll config -text "File [file rootname [file tail $fnam]]"
	set outnam [file rootname [file tail $fnam]]
	append outnam "_nu"
	bind $f <Return> {set pr_mchactv 1}
	.mchactv.0.ok config -text "Search for empty channels" -command "set pr_mchactv 1"
	set mchactvfnam ""
	.mchactv.1.ll config -text ""
	.mchactv.1.e config -bd 0 -disabledbackground [option get . background {}] -state disabled

	set pr_mchactv 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchactv
	while {!$finished} {
		tkwait variable pr_mchactv
		switch -- $pr_mchactv {
			1 {
				catch {unset outchanfnams}
				catch {unset activechans}
				catch {unset activindeces}
				catch {unset inactivechans}
				catch {unset inactivindeces}
				catch {unset simple_program_messages}
				Block "Extracting Channels from Source"
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 2 $chanfnam
				set prg_dun 0
				set prg_abortd 0
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Extract Channels"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Channel Extraction Failed"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				foreach zfnam [glob -nocomplain $baschanfnam*] {
					if {![string match $zfnam $chanfnam]} {
						lappend outchanfnams $zfnam
					}
				}
				if {![info exists outchanfnams]} {
					set msg "Channel Extraction Produced No Output Files"
					ErrShow $msg
					UnBlock
					continue
				}
				set OK 1
				foreach zfnam $outchanfnams {
					set str [file rootname $zfnam]
					set k [string first "_c" $str]
					incr k 2
					set findex [string range $str $k end]
					wm title .blocker "PLEASE WAIT:        GETTING LEVEL IN CHANNEL $findex"
					set prg_dun 0
					set prg_abortd 0
					catch {unset CDPmaxId}
					catch {unset maxsamp_line}
					set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
					lappend cmd $zfnam
					if [catch {open "|$cmd"} CDPmaxId] {
						Inf "Failed To Run maxsamp2 For Channel $findex : $CDPmaxId"
						set OK 0
						break 
					} else {
	   					fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					}
					vwait done_maxsamp
					catch {close $CDPmaxId}
					if {![info exists maxsamp_line]} {
						Inf "No Maximum Sample Information Retrieved For Channel $findex"
						set OK 0
						break 
					}
					if {![Flteq [lindex $maxsamp_line 0] 0.0]} {
						lappend activechans zfnam
						lappend activindeces [expr $findex - 1]
					} else {
						lappend inactivechans $zfnam
						lappend inactivindeces [expr $findex - 1]
					}
				}
				UnBlock
				if {!$OK} {
					continue
				}
				if {![info exists activechans]} {
					Inf "All Channels Have Zero Level"
					break
				}
				if {[llength $activechans] == $mchactvchans} {
					Inf "There are no empty channels in file '$fnam'"
					break
				} else {
					set mmsg "The following channels are empty\n"
					foreach zq $inactivindeces {
						append mmsg "[expr $zq + 1]\t"
					}
					Inf $mmsg
					set msg "Remove contiguous empty channels ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						set finished 1
					}
				}
				if {!$finished} {
					set active_chans_contiguous [ActiveChansContiguous $activindeces $mchactvchans]
					if {$active_chans_contiguous} {
						bind $f <Return> {}
						.mchactv.1.ll config -text "Output Filename "
						.mchactv.1.e config -bd 2 -state normal
						set mchactvfnam $outnam
						.mchactv.0.ok config -text "Remove contiguous empty output channels" -command "set pr_mchactv 2"
						focus  .mchactv.1.e
					} else {
						Inf "There are no ~contiguous~ empty channels"
						set finished 1
					}
				}
			}
			2 {
				if {[string length $mchactvfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $mchactvfnam]} {
					continue
				}
				set outfnam [string tolower $mchactvfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Exists: Please Choose A Different Name"
					continue
				}
				Block "Creating New Output File"
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd interleave
				foreach zfnam $activechans {
					lappend cmd $zfnam
				}
				lappend cmd $outfnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				catch {unset CDPidrun}
				if [catch {open "|$cmd"} CDPidrun] {
					Inf "Failed To Merge Active Channels"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				UnBlock
				if {!$prg_dun} {
					set msg "New File Creation Failed"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					continue
				}
				if {![file exists $outfnam]} {
					Inf "File Creation Produced No Output File"
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#---- Are the active channels continuous ??

proc ActiveChansContiguous {on_chans outchans} {

	foreach chan $on_chans {
		set chan_up [expr ($chan + 1) % $outchans]
		set chan_dn [expr ($chan - 1) % $outchans]
		if {([lsearch $on_chans $chan_up] < 0) && ([lsearch $on_chans $chan_dn] < 0)} {
			return 0
		}
	}
	return 1
}

#---- Process individual chans of multichan file, then recombine.

proc MchanEngineer {} {
	global wl chlist ch pa evv engthumb engch CDPidrun prg_dun prg_abortd simple_program_messages CDPidrun wstk engindxmax last_outfile shortwindows
	global readonlyfg readonlybg pr_mcheng mchengineer mchengfnam englist engchos panprocess bulksplit thumbnailed bulk oneatatime ins only_for_mix

	if {[info exists panprocess] || [info exists bulksplit] || [info exists thumbnailed] || [info exists oneatatime] || [info exists only_for_mix] \
	|| ([info exists bulk(run)] && $bulk(run)) || ([info exists ins(create)] && $ins(create))} {
		Inf "Not Available In These Circumstances"
		return
	}
	set i [$wl curselection]
	if {([llength $i] != 1) || ($i == -1)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select One Multichannel Soundfile"
			return
		} else {
			catch {unset ilist}
			set fnam [lindex $chlist 0]
			set i [LstIndx $fnam $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {$ftyp != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	set chans $pa($fnam,$evv(CHANS))
	if {$chans <= 2} {
		Inf "Select A Multichannel Soundfile"
		return
	}
	set dur $pa($fnam,$evv(DUR))
	set srate $pa($fnam,$evv(SRATE))
	set origfnam $fnam
	catch {unset engch}
	catch {unset englist}
	catch {unset engchos}
	set engthumb $evv(DFLT_OUTNAME)
	append engthumb 000 $evv(SNDFILE_EXT)
	if [file exists $engthumb] {
		catch {file delete $engthumb}
	}
	set engchtemp $evv(DFLT_OUTNAME)
	append engchtemp 111 $evv(SNDFILE_EXT)
	if [file exists $engchtemp] {
		catch {file delete $engchtemp}
	}
	set baschfnam $evv(DFLT_OUTNAME)
	append baschfnam 00

	Block "Copying the Source File $origfnam"

	if [catch {file copy $fnam $engchtemp} zit] {
		Inf "Cannot Make Copy Of File '$fnam'" 
		return
	}
	wm title .blocker "PLEASE WAIT:        Extracting Channels From [file rootname [file tail $origfnam]]"

	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 2 $engchtemp
	set CDPidrun 0
	set prg_dun 0
	set prg_abortd 0
	set simple_program_messages ""
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Extracting Channels Failed"
		UnBlock
		return
   	} else {
   		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "Extracting Channels Failed"
		UnBlock
		return
	}
	wm title .blocker "PLEASE WAIT:        Naming & Parsing Extracted Channels"
	set n 1
	while {$n <= $chans} {
		set thisfnam [file rootname $engchtemp]
		append thisfnam "_c" $n
		append thisfnam $evv(SNDFILE_EXT) 
		if {![file exists $thisfnam]} {
			Inf "Cannot Find Channel $n Output File ($thisfnam)"
			DeleteAllTemporaryFiles
			UnBlock
			return
		}
		set engch($n) $baschfnam
		append engch($n) $n "_0" $evv(SNDFILE_EXT) 
		if [catch {file rename $thisfnam $engch($n)} zit] {
			Inf "Cannot Rename Output Channel $n"
			DeleteAllTemporaryFiles
			UnBlock
			return
		}
		if {[DoParse $engch($n) 0 0 0] <= 0} {
			DeleteAllTemporaryFiles
			UnBlock
			return
		}
		incr n
	}
	set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
	lappend cmd chans 4 $fnam $engthumb
	set simple_program_messages ""
	set CDPidrun 0
	set prg_dun 0
	set prg_abortd 0
	wm title .blocker "PLEASE WAIT:        Creating Mono Thumbnail"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Creating Thumbnail Failed"
		UnBlock
		return
   	} else {
   		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		Inf "Creating Thumbnail Failed"
		UnBlock
		return
	}
	if {[DoThumbnailParse $engthumb] <= 0} {
		catch {file delete $engthumb} 
		UnBlock
		return
	}
	PurgeThumbProps $engthumb
	if {[info exists chlist]} {
		set origchlist $chlist
	}
	UnBlock
	set f .mcheng
	if [Dlg_Create $f "MULTICHANNEL ENGINEERING" "set pr_mcheng 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f00 [frame $f.00] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.r -text "Recombine and Output" -command "set pr_mcheng 1" -highlightbackground [option get . background {}]
		label $f0.lo -text "Output Filename"
		entry $f0.e  -textvariable mchengfnam -width 16
		button $f0.q -text "Abandon" -command "set pr_mcheng 0" -highlightbackground [option get . background {}]
		pack $f0.r $f0.lo $f0.e -side left -padx 2
		pack $f0.q -side right

		label $f00.li -text "     Selected Channel:"
		button $f00.v -text "Sound View" -command "set pr_mcheng 2" -bg $evv(SNCOLOR) -width 10 -highlightbackground [option get . background {}]
		button $f00.p -text "Process" -command "set pr_mcheng 3" -width 10 -highlightbackground [option get . background {}]
		button $f00.z -text "Zero" -command "set pr_mcheng 5" -width 10 -highlightbackground [option get . background {}]
		button $f00.d -text "" -command {} -bd 0 -width 5 -highlightbackground [option get . background {}]
		button $f00.s -text "Use in Output" -command "set pr_mcheng 4" -highlightbackground [option get . background {}]
		pack $f00.li $f00.v $f00.p $f00.z $f00.d $f00.s -side left -padx 2

		frame $f1.0
		label $f1.0.lt -text "Thumb"
		set englist(0) [Scrolled_Listbox $f.1.0.ll -width 6 -height 1 -selectmode single]
		label $f1.0.ls -text "Output->"
		pack $f.1.0.lt $f.1.0.ll -side top -pady 2
		pack $f.1.0.ls -side bottom
		pack $f.1.0 -side left -fill y -expand true
		set n 1
		if {[info exists shortwindows]} {
			set this_height 12
		} else {
			set this_height 24
		}
		while {$n <= $chans} {
			frame $f1.$n
			label $f1.$n.lc -text "Chan $n"
			set englist($n) [Scrolled_Listbox $f.1.$n.ll -width 6 -height $this_height -selectmode single]
			entry $f.1.$n.e -textvariable engchos($n) -width 6 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
			pack $f1.$n.lc $f.1.$n.ll $f.1.$n.e -side top -pady 2
			pack $f1.$n -side left
			incr n
		}
		frame $f2.1
		label $f2.1.1 -text "THUMB..................."
		label $f2.1.2 -text "CHAN 1, CHAN 2 etc..."
		label $f2.1.3 -text ""
		label $f2.1.4 -text "OUTPUT->..............."
		label $f2.1.5 -text ""
		label $f2.1.6 -text ""
		label $f2.1.7 -text "SOUND VIEW............"
		label $f2.1.8 -text "PROCESS................"
		label $f2.1.9 -text ""
		label $f2.1.10 -text ""
		label $f2.1.11 -text "USE IN OUTPUT........"
		label $f2.1.12 -text ""
		label $f2.1.13 -text "RECOMBINE+OUTPUT.."
		pack $f2.1.1 $f2.1.2 $f2.1.3 $f2.1.4 $f2.1.5 $f2.1.6 $f2.1.7 $f2.1.8 $f2.1.9 $f2.1.10 $f2.1.11 $f2.1.12 $f2.1.13 -side top -anchor w
		frame $f2.2
		label $f2.2.1 -text "A mono thumbnail representation of the input file."
		label $f2.2.2 -text "Top entries in each column are the (original) individual channel data from the input file."
		label $f2.2.3 -text "Subsequent entries are any modified versions of the channel data (or mods of mods...)"
		label $f2.2.4 -text "The individual channel sounds which will be combined in the output."
		label $f2.2.5 -text "These are set to the most recently made modification (or the original data if no mods are made)"
		label $f2.2.6 -text "UNLESS you specifically select some other item."
		label $f2.2.7 -text "Display and play any selected item in the columns, including the thumbnail."
		label $f2.2.8 -text "Apply some CDP process to a selected item in a Channel column."
		label $f2.2.9 -text "The newly processed item becomes the last list listed item in the same column."
		label $f2.2.10 -text "It is also presumed to be the desired output, and placed in the \"Output\" box at foot of display."
		label $f2.2.11 -text "Use the selected item (mod or original) in a column to use in the final output sound."
		label $f2.2.12 -text "It is placed in the \"Output\" box at the foot of the column."
		label $f2.2.13 -text "Merge the channel data in the \"Output\" boxes to make a new multichannel file."
		pack $f2.2.1 $f2.2.2 $f2.2.3 $f2.2.4 $f2.2.5 $f2.2.6 $f2.2.7 $f2.2.8 $f2.2.9 $f2.2.10 $f2.2.11 $f2.2.12 $f2.2.13 -side top -anchor w
		pack $f2.1 $f2.2 -side left
		pack $f.0 -side top -pady 2 -fill x -expand true
		pack $f.00 $f.1 -side top -pady 2
		pack $f.2 -side top -pady 2 -anchor w
		bind $f <Escape> {set pr_mcheng 0}
	}
	set mchengfnam [file rootname [file tail $origfnam]]

	set indx "0"
	$englist(0) delete 0 end
	$englist(0) insert end $indx
	set n 1
	while {$n <= $chans} {
		set indx [string range [file rootname $engch($n)] 9 end]
		$englist($n) delete 0 end
		$englist($n) insert end $indx
		set engindxmax($n) 0
		set engchos($n) $indx
		incr n	
	}
	set pr_mcheng 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mcheng
	while {!$finished} {
		tkwait variable pr_mcheng
		switch -- $pr_mcheng {
			1 {
				set msg "Reassemble The Output Channels As Selected ??"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if {[string length $mchengfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $mchengfnam]} {
					continue
				}
				set outfnam [string tolower $mchengfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Exists: Please Choose A Different Name"
					continue
				}
				Block "Creating New Output File"
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd interleave
				set n 1
				while {$n <= $chans} {
					set thisfnam $baschfnam
					append thisfnam $engchos($n) $evv(SNDFILE_EXT)
					lappend cmd $thisfnam
					incr n
				}
				lappend cmd $outfnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Cannot Merge The Channels: $CDPidrun"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Cannot Merge The Channels"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "FILE '$outfnam' IS ON THE WORKSPACE"
					set last_outfile $outfnam
				}
				UnBlock
				set finished 1
			}
			2 {
				set n 0
				while {$n <= $chans} {
					set i [$englist($n) curselection]
					if {$i >= 0} {
						set fnam $baschfnam
						append fnam [$englist($n) get $i]
						append fnam $evv(SNDFILE_EXT)
						SnackDisplay 0 $evv(SN_FROM_ENGINEER_NO_OUTPUT) 0 $fnam
						break
					}
					incr n
				}
				if {$n > $chans} {
					Inf "No File Selected"
				}
			}
			3 {
				set n 1
				while {$n <= $chans} {
					set i [$englist($n) curselection]
					if {$i >= 0} {
						set fnam $baschfnam
						append fnam [$englist($n) get $i]
						append fnam $evv(SNDFILE_EXT)
						break
					}
					incr n
				}
				if {$n > $chans} {
					Inf "No File Selected"
				}
				set chlist $fnam
				$ch delete 0 end
				$ch insert end $fnam
				set mchengineer 1
				set bulk(run) 0
				GotoGetAProcess
			}
			4 {
				set n 1
				while {$n <= $chans} {
					set i [$englist($n) curselection]
					if {$i >= 0} {
						set engchos($n) [$englist($n) get $i]
						break
					}
					incr n
				}
				if {$n > $chans} {
					Inf "No File Selected"
				}
			}
			5 {
				set n 1
				while {$n <= $chans} {
					set i [$englist($n) curselection]
					if {$i >= 0} {
						set indx [split $engchos($n) "_"]
						set indx [lindex $indx 1]
						incr indx
						set nuindx $n
						append nuindx "_" $indx
						set fnam $baschfnam
						append fnam $nuindx $evv(SNDFILE_EXT)
						if {[CreateZeroChannel $fnam $dur $srate $n]} {
							$englist($n) insert end $nuindx
							set engchos($n) $nuindx
						}
						break
					}
					incr n
				}
				if {$n > $chans} {
					Inf "No File Selected"
				}
			}
			0 {
				set finished 1
			}
		}
	}
	if {[info exists origchlist]} {
		set chlist $origchlist
		$ch delete 0 end
		foreach fnam $origchlist {
			$ch insert end $fnam
		}
	}
	catch {unset mchengineer}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc SaveEngineeredFile {} {
	global chlist evv o_nam engindxmax englist engchos pa evv
	set fnam [lindex $chlist 0]
	set origdur $pa($fnam,$evv(INSAMS))
	set fnam [file rootname $fnam]
	set fend [string first "_" $fnam]
	incr fend -1
	set fch [string range $fnam 9 $fend]
	incr engindxmax($fch)
	set fnam [string range $fnam 0 10]
	append fnam $engindxmax($fch) $evv(SNDFILE_EXT)
	set nufnam $o_nam
	append nufnam "0" $evv(SNDFILE_EXT)
	if [catch {file rename $nufnam $fnam} zit] {
		Inf "Cannot Rename The Engineered Output File"
		catch {file delete $nufnam}
		return
	}
	if {[DoParse $fnam 0 0 0] <= 0} {
		Inf "Failed To Parse The Engineered Output File"
		catch {file delete $fnam}
		return
	}
	if {$pa($fnam,$evv(INSAMS)) != $origdur} {
		set msg "Process Has Changed The File Duration\n\n"
		append msg "If Filtering, Set Filter Tail To Zero\n"
		append msg "If Inserting Silence(s), Set 'Overwrite'\n"
		Inf $msg
		catch {file delete $fnam}
		return
	}
	set indx $fch
	append indx "_" $engindxmax($fch)
	$englist($fch) insert end $indx
	set engchos($fch) $indx
	.mcheng.0.r config -bg $evv(EMPH)	
}

#------ Create silent file, as zero-level channel for multichannel file

proc CreateZeroChannel {fnam dur srate channo} {
	global evv prg_dun prg_abortd simple_program_messages CDPidrun

	Block "Zeroing channel $channo"
	set cmd [file join $evv(CDPROGRAM_DIR) synth]
	lappend cmd silence $fnam $srate 1 $dur
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		ErrShow "Cannot Zero Channel $channo: $CDPidrun"
		catch {unset CDPidrun}
		UnBlock
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Cannot Zero Channel $channo"
		set msg [AddSimpleMessages $msg]
		ErrShow $msg
		UnBlock
		return 0
	}
	if {[DoParse $fnam 0 0 0] <= 0} {
		Inf "Failed To Parse The Zeroed Channel"
		catch {file delete $fnam}
		UnBlock
		return 0
	}
	UnBlock
	return 1
}

#--- typ can be "create" "delete" "modify"

proc UpdateBakupLog {fnam typ tofile} {
	global dobakuplog bakuplog baktowrite evv
	if {!$dobakuplog} {
		return
	}
	set logfnam [file join $evv(URES_DIR) bakuplog$evv(CDP_EXT)]
	if {[string match [file tail $fnam] $fnam]} {
		if {$tofile && $baktowrite} {
			set do_write_only 1
		} else {
			return
		}
	}
	if {![info exists do_write_only]} {
		set baktowrite 1
		switch -- $typ {
			"create" {
				set created 1										;#	Don't mark-to-create files recently deleted.
				if {[info exists bakuplog(delete)]} {				;#	Instead, mark them as modified
					set k [lsearch $bakuplog(delete) $fnam]
					if {$k >= 0} {
						set bakuplog(delete) [lreplace $bakuplog(delete) $k $k]
						if {[llength $bakuplog(delete)] <= 0} {
							unset bakuplog(delete)
						}
						if {![info exists bakuplog(modify)]} {
							lappend bakuplog(modify) $fnam
						} elseif {[lsearch $bakuplog(modify) $fnam] < 0} {
							lappend bakuplog(modify) $fnam
						}
						set created 0
					}
				}
				if {$created} {										;#	FAILSAFE error trap: If file is already marked as modified
					if {[info exists bakuplog(modify)] && ([lsearch $bakuplog(modify) $fnam] >= 0)} {
						set created 0								;#	there could be an error in the "create" instruction
					}				 								;# (i.e. the file is actually being overwritten, not created)
				}													;#	so don't recreate
				if {$created} {
					if {![info exists bakuplog($typ)]} {
						lappend bakuplog($typ) $fnam
					} elseif {[lsearch $bakuplog($typ) $fnam] < 0} {
						lappend bakuplog($typ) $fnam
					}
				}
			}
			"modify" {
				set modified 1										;#	Don't mark-to-modify files only just been created
				if {[info exists bakuplog(create)]} {
					set k [lsearch $bakuplog(create) $fnam]
					if {$k >= 0} {
						set modified 0
					}
				}
				if {$modified} {
					if {![info exists bakuplog($typ)]} {
						lappend bakuplog($typ) $fnam
					} elseif {[lsearch $bakuplog($typ) $fnam] < 0} {
						lappend bakuplog($typ) $fnam
					}
				}
			}
			"delete" {
				set transient 0										;#	Don't mark-to-delete files only just been created
				if {[info exists bakuplog(create)]} {				;#	instead, delete from creation list
					set k [lsearch $bakuplog(create) $fnam]
					if {$k >= 0} {
						set transient 1
						set bakuplog(create) [lreplace $bakuplog(create) $k $k]
						if {[llength $bakuplog(create)] <= 0} {
							unset bakuplog(create)
						}
					}
				}
				if {!$transient} {
					if {![info exists bakuplog($typ)]} {
						lappend bakuplog($typ) $fnam
					} elseif {[lsearch $bakuplog($typ) $fnam] < 0} {
						lappend bakuplog($typ) $fnam
					}
					if {[info exists bakuplog(modify)]} {			;#	If file is deleted, remove any mark-to-modify it
						set k [lsearch $bakuplog(modify) $fnam]
						if {$k >= 0} {
							set bakuplog(modify) [lreplace $bakuplog(modify) $k $k]
							if {[llength $bakuplog(modify)] <= 0} {
								unset bakuplog(modify)
							}
						}
					}
				}
				if {(![info exists bakuplog(modify)] || ([llength $bakuplog(modify)] <= 0)) \
				&&  (![info exists bakuplog(create)] || ([llength $bakuplog(create)] <= 0)) \
				&&  (![info exists bakuplog(delete)] || ([llength $bakuplog(delete)] <= 0))} {
					catch {unset bakuplog}
				}
			}
		}
	}
	if {$tofile} {
		if {[info exists bakuplog(create)] || [info exists bakuplog(modify)] || [info exists bakuplog(delete)]} {
			BakupLogToFile
		} else {
			catch {unset bakuplog}
		}
		set baktowrite 0
	}
}

#--- Load backup-log action and data

proc LoadBakupLog {} {
	global pr_bul2 bakuplog dobakuplog wstk evv

	if {![SetBakupLogFromOldNobakdirs]} {
		set go [file join $evv(URES_DIR) dobakuplog$evv(CDP_EXT)]
		if {![file exists $go]} {
			set dobakuplog 0
			return
		} else {
			set dobakuplog 1
		}
	}
	set logfnam [file join $evv(URES_DIR) bakuplog$evv(CDP_EXT)]
	if {![file exists $logfnam]} {
		return
	}
	if [catch {open $logfnam "r"} zit] {
		Inf "Cannot Open Backup Log File '$logfnam' To Read Data"
		return
	}
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		switch -- $line {
			"#CREATE" {
				set typ create
			}
			"#DELETE" {
				set typ delete
			}
			"#MODIFY" {
				set typ modify
			}
			default {
				if {![info exists typ]} {
					Inf "Corrupted Data In Bakup-Log File '$logfnam'"
					catch {file delete $logfnam}
					catch {unset bakuplog}
					return
				}
				lappend bakuplog($typ) $line
			}
		}
	}
	close $zit
	WarnBakupLog 1
}

#--- End of Session warning about files to backup

proc WarnBakupLog {start} {
	global dobakuplog bakuplog wstk evv pr_bul buldrive bul_size
	set logfnam [file join $evv(URES_DIR) bakuplog$evv(CDP_EXT)]
	if {!$dobakuplog} {
		catch {file delete $logfnam}
		return
	}
	if {![info exists bakuplog(create)] && ![info exists bakuplog(modify)] && ![info exists bakuplog(delete)]} {
		catch {unset bakuplog}
		if {$start == 2} {
			Inf "No File Updates Since Last Backup"
		}
		return
	}
	set f .bul
	if [Dlg_Create $f "FILES TO BACK UP" "set pr_bul 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f0a [frame $f.0a -bg $evv(POINT) -height 1] 
		set f00 [frame $f.00] 
		set f1 [frame $f.1] 
		button $f0.bk -text "Copy to or Delete from bakup drive ->" -width 36 -command "set pr_bul 4" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		entry $f0.bd  -textvariable buldrive -width 4 -state readonly -readonlybackground grey -foreground black
		label $f0.up -text "\"Up\" and \"Down\" Arrows change drive"
		button $f0.ok -text "I have backed up: delete log" -width 30 -command "set pr_bul 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Backup later (\"Escape\")" -command "set pr_bul 0" -highlightbackground [option get . background {}]
		pack $f0.bk $f0.bd $f0.up $f0.ok -side left -padx 2
		pack $f0.quit -side right
		button $f00.sort -text "Sort by directory (\"D\")" -width 22 -command "set pr_bul 2" -highlightbackground [option get . background {}]
		button $f00.rest -text "Restore listing (\"L\")" -width 22 -command "set pr_bul 3" -highlightbackground [option get . background {}]
		label $f00.lab -text "MB to store"
		entry $f00.size -textvariable bul_size -width 20
		pack $f00.sort $f00.rest $f00.lab $f00.size -side left -padx 2
		Scrolled_Listbox $f1.ll -width 120 -height 24 -selectmode extended
		pack $f1.ll -side top -pady 2
		pack $f0 -side top -fill x -expand true -pady 2
		pack $f0a -side top -fill x -expand true -pady 4
		pack $f00 -side top -pady 2
		pack $f1 -side top -fill x -expand true -pady 2
		bind .bul <Escape> {set pr_bul 0}
		bind .bul <Key-space> {set pr_bul 0}
		bind .bul <Key-d> {set pr_bul 2}
		bind .bul <Key-D> {set pr_bul 2}
		bind .bul <Key-l> {set pr_bul 3}
		bind .bul <Key-L> {set pr_bul 3}
		bind .bul <Command-=> {ModificationDate bul}
		bind .bul <Up>   {BulDriveAdvance 0}
		bind .bul <Down> {BulDriveAdvance 1}
		BulDriveAdvance -1
		wm resizable $f 1 1
	}
	set bul_size ""
	set origlines [DisplayBakupLog]
	set pr_bul 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_bul
	while {!$finished} {
		tkwait variable pr_bul
		switch -- $pr_bul {
			1 {
				set msg "Are You Sure You Want To Delete This Log ???"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if {[file exists $logfnam]} {
					if [catch {file delete $logfnam} zit] {
						Inf "Cannot Delete The Existing Bakup-Log File '$logfnam'"
					}
				}
				catch {unset bakuplog}
				set finished 1
			} 
			2 {
				if {![info exists sortedlines]} {
					foreach line $origlines {
						if {[string match "FILES CREATED" $line] || [string match "FILES DELETED" $line] \
						|| [string match "FILES MODIFIED" $line] || ([string length $line] <= 0)} {
							continue
						}
						lappend sortedlines $line
					}
					set sortedlines [lsort -dictionary $sortedlines]
					foreach line $sortedlines {
						set thisdir  [file dirname $line]
						lappend sortdir($thisdir) $line
					}
					catch {unset nulines}
					foreach thisdir [array names sortdir] {
						set linex ""
						lappend nulines $linex
						set linex "~~   DIRECTORY $thisdir   ~~"
						lappend nulines $linex
						set linex ""
						lappend nulines $linex
						foreach f_ile $sortdir($thisdir) {
							lappend nulines $f_ile
						}
					}
					set sortedlines $nulines
				}
				$f.1.ll.list delete 0 end
				foreach line $sortedlines {
					$f.1.ll.list insert end $line
				}
			}
			3 {
				$f.1.ll.list delete 0 end
				foreach line $origlines {
					$f.1.ll.list insert end $line
				}
			}
			4 {
				set finished2  0
				while {!$finished2} {
					set OK2 1
					catch {unset outputlines}
					foreach line $origlines {
						if {[string match "FILES CREATED" $line] || [string match "FILES DELETED" $line] \
						|| [string match "FILES MODIFIED" $line] || ([string length $line] <= 0)} {
							continue
						}
						if {![info exists bakuplog(delete)] || ([lsearch $bakuplog(delete) $line] < 0)} {
							lappend outputlines $line
						}
					}
					if {[string length $buldrive] <= 0} {
						Inf "No Backup Drive Specified: Use \"Up Arrow\" Or \"Down Arrow\" Key"
						set OK2 0
						break
					}
					if {![info exists outputlines]} {
						Inf "No Files To Backup"
						set msg ""
					} else {
						set pwd [string tolower [pwd]]
						if {[string first [string tolower $buldrive] $pwd] == 0} {
							Inf "You Cannot Backup To Drive $buldrive\n\nThis Is The Current Working Drive For The Loom"
							set OK2 0
							break
						}
						catch {unset outputdir}
						set outputlines [lsort -dictionary $outputlines]
						foreach line $outputlines {
							set thisdir  [file dirname $line]
							lappend outputdir($thisdir) $line
						}
						set OK 1
						foreach thisdir [array names outputdir] {
							if {[string first [string tolower $buldrive] [string tolower $thisdir]] == 0} {
								Inf "You Cannot Backup To Drive $buldrive\n\nSome Of The Files To Be Backed Up Are Already On This Drive"
								set OK 0
								break
							}
						}
						if {!$OK} {
							set OK2 0
							break
						}
						set OK 1
						set outdirs {}
						set indrives {}
						set subs {}
						foreach thisdir [array names outputdir] {
							set outdir [file split $buldrive]
							if {[string first ":" $thisdir] < 0} {
								set thisdir [file join $pwd $thisdir]
							}
							set thisdir [file split $thisdir]
							set indrive [lindex $thisdir 0]
							lappend indrives $indrive
							set sub [lrange $thisdir 1 end]
							set sub [file join $sub]
							lappend subs $sub
							set thisdir [lrange $thisdir 1 end]
							set thoutdir [concat $outdir $thisdir]
							set outdir [lindex $thoutdir 0]
							foreach item [lrange $thoutdir 1 end] {
								set outdir [file join $outdir $item]
							}
							set k [lsearch $subs $sub]
							if {$k >= 0} {
								if {![string match $indrive [lindex $indrives $k]]} {
									set thisdir [file join $thisdir]
									Inf "Directory \"$thisdir\" Exists On 2 Separate Backup Drives\n\n$indrive And [lindex $indrives $k]\n\nCannot Proceed"
									set OK 0
									break
								}
							}
							lappend outdirs $outdir
						}
						if {!$OK} {
							set OK2 0
							break
						}
						set outfile_test_msg_sent 0
						catch {unset filecopies}
						foreach thisdir [array names outputdir] outdir $outdirs {
							foreach fnam $outputdir($thisdir) {
								set nufnam [file tail $fnam]
								set nufnam [file join $outdir $nufnam]
								if {[file exists $nufnam]} {
									if {!$outfile_test_msg_sent} {
										set msg "Overwrite Existing File Copies (e.g. $nufnam Already Exists) ??"
										set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
										if {$choice == "no"} {
											continue
										}
										set outfile_test_msg_sent 1
									}
								}
								set line [list $fnam $nufnam]
								lappend filecopies $line
							}
						}
						set showdirs [lsort -dictionary [RemoveDuplicates $outdirs]]
						set msg "Backing Up To The Following Directories\n"
						foreach showdir $showdirs {
							append msg "\n$showdir"
						}
						Inf $msg
						Block "Backing Up"
						catch {unset badfiles}
						set baddirs {}
						foreach copipair $filecopies {
							set fnam   [lindex $copipair 0]
							set nufnam [lindex $copipair 1]
							set nudir  [file dirname $nufnam]
							if {[lsearch $baddirs $nudir] >= 0} {
								continue
							}
							if {![file exists $nudir]} {
								if [catch {file mkdir $nudir} zit] {
									lappend baddirs $nudir
									continue
								}
							}
							wm title .blocker "PLEASE WAIT:      COPYING [file tail $fnam]"
							if [catch {file copy -force $fnam $nufnam} zit] {
								lappend badfiles $fnam
							}
						}
						catch {unset bakuplog_bad(create)}
						catch {unset bakuplog_bad(modify)}
						set msg ""
						if {[info exists badfiles]} {
							foreach fnam $badfiles {
								if {[info exists bakuplog(create)] && ([lsearch $bakuplog(create) $fnam] >= 0)} {
									lappend bakuplog_bad(create) $fnam
								} else {
									lappend bakuplog_bad(modify) $fnam
								}
							}
							set msg "Some Files Failed To Backup.\n\n"
						}
						UnBlock
					}
					if {[info exists bakuplog(delete)]} {
						set msg2 "There Are Still Backed Up Items To Delete\n\nDo You Wish To Delete Any Copies From The Backup Medium ??"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg2]
						if {$choice == "yes"} {
							set outputlines $bakuplog(delete)
							set pwd [string tolower [pwd]]
							if {[string first [string tolower $buldrive] $pwd] == 0} {
								Inf "You Cannot Delete Files On Drive $buldrive\n\nThis Is The Current Working Drive For The Loom"
								set OK2 0
								break
							}
							catch {unset outputdir}
							set outputlines [lsort -dictionary $outputlines]
							foreach line $outputlines {
								set thisdir  [file dirname $line]
								lappend outputdir($thisdir) $line
							}
							set OK 1
							foreach thisdir [array names outputdir] {
								if {[string first [string tolower $buldrive] [string tolower $thisdir]] == 0} {
									Inf "You Cannot Delete Files From Drive $buldrive\n\nThis Is Your Original Material"
									set OK 0
									break
								}
							}
							if {!$OK} {
								set OK2 0
								break
							}
							set outdirs {}
							foreach thisdir [array names outputdir] {
								set outdir [file split $buldrive]
								if {[string first ":" $thisdir] < 0} {
									set thisdir [file join $pwd $thisdir]
								}
								set thisdir [file split $thisdir]
								set thisdir [lrange $thisdir 1 end]
								set thoutdir [concat $outdir $thisdir]
								set outdir [lindex $thoutdir 0]
								foreach item [lrange $thoutdir 1 end] {
									set outdir [file join $outdir $item]
								}
								lappend outdirs $outdir
							}
							set OK 1
							set outdir_test_msg_sent 0
							foreach outdir $outdirs {
								if {![file exists $outdir]} {
									if {!$outdir_test_msg_sent} {
										set msg2 "Some Of The Backup Directories (e.g. $outdir) Do Not Exist: Proceed Anyway ??"
										set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg2]
										if {$choice == "no"} {
											set OK 0
											break
										}
										set outdir_test_msg_sent 1
									}
								}
							}
							if {!$OK} {
								set OK2 0
								break
							}
							set OK 1
							set outfile_test_msg_sent 0
							catch {unset filecopies}
							foreach thisdir [array names outputdir] outdir $outdirs {
								foreach fnam $outputdir($thisdir) {
									set nufnam [file tail $fnam]
									set nufnam [file join $outdir $nufnam]
									if {![file exists $nufnam]} {
										if {!$outfile_test_msg_sent} {
											set msg2 "Some Copies (e.g. $nufnam) Do Not Exist: Proceed Anyway ??"
											set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg2]
											if {$choice == "no"} {
												set OK 0
												break
											}
											set outfile_test_msg_sent 1
										}
									}
									set line [list $fnam $nufnam]
									lappend filecopies $line
								}
								if {!$OK} {
									break
								}
							}
							if {!$OK} {
								set OK2 0
								break
							}
							set showdirs [lsort -dictionary [RemoveDuplicates $outdirs]]
							set msg2 "Deleting From The Following Backup Directories\n"
							foreach showdir $showdirs {
								append msg2 "\n$showdir"
							}
							Block "Deleting Backup Copies"
							Inf $msg2
							catch {unset badfiles}
							set baddirs {}
							foreach copipair $filecopies {
								set nufnam [lindex $copipair 1]
								if {[file exists $nufnam]} {
									wm title .blocker "PLEASE WAIT:      deleting [file tail $nufnam]"
									if [catch {file delete $nufnam} zit] {
										lappend badfiles $fnam
									}
								}
							}
							UnBlock
							if {[info exists badfiles]} {
								set bakuplog(delete) $badfiles
								if {[string length $msg] > 0} {
									append msg "AND "
								}
								append msg "Some Bakup Files Could Not Be Deleted\n\n"
								set qualified 1
							} else {
								unset bakuplog(delete)
								if {[string length $msg] > 0} {
									append msg "BUT "
								}
								append msg "Designated Bakup Files Have Been Deleted\n\n"
							}
							Inf $msg
						}
					} else {
						append msg "Backup Is Complete"
						Inf $msg

					}
					set msg "Have You Completed All Backups ??"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						Inf "Make A Further Backup By Restarting Or Ending Session"
					} else {
#NOV 2019 
						set fnamlog [file join $evv(URES_DIR) bakuplog$evv(CDP_EXT)]
						catch {unset bakuplog}
						if {[info exists bakuplog_bad(create)]} {
							set bakuplog(create) $bakuplog_bad(create)
						}
						if {[info exists bakuplog_bad(modify)]} {
							set bakuplog(modify) $bakuplog_bad(modify)
						}
						if {[info exists bakuplog_bad(delete)]} {
							set bakuplog(delete) $bakuplog_bad(delete)
						}
						if {[info exists bakuplog]} {			;#	bakup file is recreated only if some bakup processes failed
							set msg "SOME FILES FAILED TO BE BACKED UP, MODIFIED OR DELETED : RETAIN THE BAKING UP DATA ??"
							set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
							if {$choice == "yes"} {
								BakupLogToFile
							} else {
								unset bakuplog
							}
						}
						if {![info exists bakuplog]} {
							catch {file delete $fnamlog}
						}
					}
					set finished2 1
				}
				if {!$OK2} {
					continue
				}
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc SetBakupLog {} {
	global bakuplog dobakuplog evv ww
	set go [file join $evv(URES_DIR) dobakuplog$evv(CDP_EXT)]
	if {[file exists $go]} {
		catch {file delete $go}
		Inf "Log Of File Changes Will ~No Longer~ Be Kept"
		set dobakuplog 0
		catch {unset bakuplog}
		$ww.1.b.sesst.ul config -text "" -command {} -bd 0
	} else {
		if {![catch {open $go "w"} zit]} {
			close $zit
			Inf "Log Of File Changes Will Be Kept"
			set dobakuplog 1
			$ww.1.b.sesst.ul config -text "See Update Log" -command "WarnBakupLog 2" -bd 2
		}
	}
}

proc ClearBakupLog {} {
	global bakuplog evv
	if {[info exists bakuplog(create)] || [info exists bakuplog(modify)] || [info exists bakuplog(delete)]} {
		return
	} else {
		catch {unset bakuplog}
	}
	set logfnam [file join $evv(URES_DIR) bakuplog$evv(CDP_EXT)]
	catch {file delete $logfnam}
}

#---- When previous user gets new system
#---- The utility of "nobakdirs" is transferred to "dobakuplog"
#---- and the fact that this has been done is REMEMBERED

proc SetBakupLogFromOldNobakdirs {} {
	global evv dobakuplog
	set ifnam [file join $evv(URES_DIR) nobakdirsreinit$evv(CDP_EXT)]	;#	File remembers if previous bakupdirs info has been acted on
	if {[file exists $ifnam]} {
		return 0														;#	If backup log HAS been initialised from previous "nobakdirs", quit
	}
	set go [file join $evv(URES_DIR) dobakuplog$evv(CDP_EXT)]			;#	New, "keep log", marker file
	set fnam [file join $evv(URES_DIR) nobakdirs$evv(CDP_EXT)]			;#	Old, "nobakdirs", marker file
	if {[file exists $fnam]} {											;#	If "nobakdirs" exists, NOT currently showing bakupdirs, so assume no logs
		set dobakuplog 0
		if {[file exists $go]} {										;#	REDUNDANT, as new user can't have already set this up
			catch {file delete $go}										;#	but here for testing
		}
	} else {															;#	Otherwise, previously WAS showing bakupdirs, so now show logs
		if {![catch {open $go "w"} zit]} {
			close $zit
		}
		set dobakuplog 1
	}
	catch {file delete $fnam}											;#	Get rid of the "nobakdirs" file
	if {![catch {open $ifnam "w"} zit]} {								
		close $zit														;#	Create file to show that this check has been done!!
	}
	return 1
}

#---- Advance up and down drive labels

proc BulDriveAdvance {down} {
	global buldrive bulindx
	set drives [file volume]
	if {$down < 0} {
		set bulindx buldrive
		set bulindx -1
		return
	}
	set len [llength $drives]
	incr len -1
	if {$down} {
		if {$bulindx < 0} {
			set bulindx $len
		} elseif {$bulindx > 0} {
			incr bulindx -1
		}
	} else {
		if {$bulindx < 0} {
			set bulindx 0
		} elseif {$bulindx < $len} {
			incr bulindx
		}
	}
	set buldrive [lindex $drives $bulindx]
}

#---- Display bakup info in Log window, and return the list of displayed lines

proc DisplayBakupLog {} {
	global bakuplog bul_size evv
	set f .bul
	set origlines {}
#RWD 2023 as PC version
    set bauplog_bitesize 0
    
	$f.1.ll.list delete 0 end
	if {[info exists bakuplog(create)]} {
		set bakuplog(create) [lsort -ascii $bakuplog(create)]
		set line ""
		$f.1.ll.list insert end $line
		lappend origlines $line
		set line "FILES CREATED"
		$f.1.ll.list insert end $line
		lappend origlines $line
		set line ""
		$f.1.ll.list insert end $line
		lappend origlines $line
		foreach line $bakuplog(create) {
			$f.1.ll.list insert end $line
			lappend origlines $line
			catch {unset bitesize}
			catch {set bitesize [file size $line]}
			if {[info exists bitesize]} {
				set bauplog_bitesize [expr $bauplog_bitesize + $bitesize]
			} else {
				set warn_bitesize 1
			}
		}
		if {[info exists warn_bitesize]} {
			set bul_size "Not known"
		} else {
			set bauplog_bitesize [expr int(ceil($bauplog_bitesize/$evv(MEGABYTE)))]
			set bul_size $bauplog_bitesize
		}
	}
	if {[info exists bakuplog(delete)]} {
		set bakuplog(delete) [lsort -ascii $bakuplog(delete)]
		set line ""
		$f.1.ll.list insert end $line
		lappend origlines $line
		set line "FILES DELETED"
		$f.1.ll.list insert end $line
		lappend origlines $line
		set line ""
		$f.1.ll.list insert end $line
		lappend origlines $line
		foreach line $bakuplog(delete) {
			$f.1.ll.list insert end $line
			lappend origlines $line
		}
	}
	if {[info exists bakuplog(modify)]} {
		set bakuplog(modify) [lsort -ascii $bakuplog(modify)]
		set line ""
		$f.1.ll.list insert end $line
		lappend origlines $line
		set line "FILES MODIFIED"
		$f.1.ll.list insert end $line
		lappend origlines $line
		set line ""
		$f.1.ll.list insert end $line
		lappend origlines $line
		foreach line $bakuplog(modify) {
			$f.1.ll.list insert end $line
			lappend origlines $line
		}
	}
	return $origlines
}

#--- Copy bakup INFO to a file

proc BakupLogToFile {} {
	global bakuplog evv
	set logfnam [file join $evv(URES_DIR) bakuplog$evv(CDP_EXT)]
	catch {file delete $logfnam}
	if {![catch {open $logfnam "w"} zit]} {
		set line "#CREATE"
		puts $zit $line
		if {[info exists bakuplog(create)]} {
			foreach zfnam $bakuplog(create) {
				puts $zit $zfnam
			}
		}
		set line "#DELETE"
		puts $zit $line
		if {[info exists bakuplog(delete)]} {
			foreach zfnam $bakuplog(delete) {
				puts $zit $zfnam
			}
		}
		set line "#MODIFY"
		puts $zit $line
		if {[info exists bakuplog(modify)]} {
			foreach zfnam $bakuplog(modify) {
				puts $zit $zfnam
			}
		}
		close $zit
	}
}



proc PermChunks {} {
	global wl evv pa chlist pr_pchunks pchunkav pchunkscat pchunkfnam pchunksplic pchunkmindur pchunkshort
	global prg_dun prg_abortd simple_program_messages CDPidrun hopperm last_outfile readonlyfg readonlybg
	global last_pchunkav last_pchunkscat last_pchunksplic last_pchunkshort pchunklast

	if {[info exists pchunkav]} {
		set last_pchunkav $pchunkav
	}
	if {[info exists pchunkscat]} {
		set last_pchunkscat $pchunkscat
	}
	if {[info exists pchunksplic]} {
		set last_pchunksplic $pchunksplic
	}
	if {[info exists pchunkshort]} {
		set last_pchunkshort $pchunkshort
	}
	set ilist [$wl curselection]
	if {[llength $ilist] < 2} {
		if {![info exists chlist] || ([llength $chlist] < 2)} {
			Inf "Select Several Soundfiles"
			return
		} else {
			catch {unset ilist}
			foreach fnam $chlist {
				set i [LstIndx $fnam $wl]
				lappend ilist $i
			}
			$wl selection clear 0 end
			foreach i $ilist {
				$wl selection set $i
			}
		}
	}
	foreach i $ilist {
		set fnam [$wl get $i]
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Select Soundfiles"
			return
		}
		if {![info exists chans]} {
			set chans $pa($fnam,$evv(CHANS))
		} elseif {$chans != $pa($fnam,$evv(CHANS))} {
			Inf "Select Soundfiles With The Same Number Of Channels"
			return
		}
		lappend infnams $fnam
		if {[info exists mindur]} {
			if {$pa($fnam,$evv(DUR)) < $mindur} {
				set mindur $pa($fnam,$evv(DUR))
			}
		} else {
			set mindur $pa($fnam,$evv(DUR))
		}
	}
	set pchunkmindur [expr $mindur / 2.0]
	set interfile $evv(DFLT_OUTNAME)
	append interfile 0000 $evv(SNDFILE_EXT)
	set f .pchunks
	if [Dlg_Create $f "PERM CHUNKS OF FILES" "set pr_pchunks 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		button $f0.ok -text "Do Perm" -command "set pr_pchunks 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_pchunks 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true -pady 2
		label $f.00 -text "Up/Down Arrows: change Chunksize (Shift:big steps: Control:small)     Right/Left: change Scatter" -fg $evv(SPECIAL)
		pack $f.00 -side top -pady 4
		entry $f1.av -textvariable pchunkav -width 8 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f1.ll -text "Average Chunk Length"
		pack $f1.av $f1.ll -side left -padx 4 
		pack $f1 -side top -fill x -expand true -pady 2

		entry $f2.ra -textvariable pchunkscat -width 8 -state readonly -foreground $readonlyfg -readonlybackground $readonlybg
		label $f2.ll -text "Random Scattering of Chunk Length (0-1)"
		pack $f2.ra $f2.ll -side left -padx 4 
		pack $f2 -side top -fill x -expand true -pady 2

		entry $f3.sp -textvariable pchunksplic -width 8
		label $f3.ll -text "Splicelength (mS) for joining output chunks"
		pack $f3.sp $f2.ll -side left -padx 4 
		pack $f3 -side top -fill x -expand true -pady 2

		checkbutton $f4.ch -variable pchunkshort -text "Limit Output Duration to (approx) minimum dur of Inputs"
		pack $f4.ch -side left -padx 4 
		pack $f4 -side top -fill x -expand true -pady 2

		checkbutton $f5.la -variable pchunklast -text "Previous Vals" -command PchunkLast
		pack $f5.la -side right
		pack $f5 -side top -fill x -expand true -pady 2

		entry $f6.fn -textvariable pchunkfnam -width 24
		label $f6.ll -text "Output Filename"
		pack $f6.fn $f6.ll -side left -padx 2 
		pack $f6 -side top -pady 2

		bind .pchunks <Up>			 {PchunkAvIncr 0 0}
		bind .pchunks <Down>		 {PchunkAvIncr 1 0}
		bind .pchunks <Shift-Up>	 {PchunkAvIncr 0 1}
		bind .pchunks <Shift-Down>   {PchunkAvIncr 1 1}
		bind .pchunks <Control-Up>	 {PchunkAvIncr 0 2}
		bind .pchunks <Control-Down> {PchunkAvIncr 1 2}
		bind .pchunks <Right>   {PchunkScatIncr 0}
		bind .pchunks <Left>	{PchunkScatIncr 1}
		bind .pchunks <Return>	{set pr_pchunks 1}
		bind .pchunks <Escape>	{set pr_pchunks 0}
		wm resizable $f 1 1
	}
	set pchunklim $evv(MAXFILES)
	set pchunkshort 0
	set pchunkfnam ""
	set pchunklast 0
	set pchunkav [DecPlaces [expr $mindur / 8.0] 2]
	set pchunkscat 0.0
	set pchunksplic 15
	set pr_pchunks 0
	set chunklist {}
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_pchunks
	while {!$finished} {
		tkwait variable pr_pchunks
		switch -- $pr_pchunks {
			1 {
				if {[string length $pchunkfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				set outfnam [string tolower $pchunkfnam]
				if {![ValidCDPRootname $pchunkfnam]} {
					continue
				}
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Exists: Please Choose A Different Name"
					continue
				}
				if {[string length $pchunksplic] <= 0} {
					Inf "No Splice Length Entered"
					continue
				}
				if {![IsNumeric $pchunksplic] || ($pchunksplic < 0.0) || ($pchunksplic > 5000)} {
					Inf "Invalid Splice Length Entered"
					continue
				}
				set splicsec [expr $pchunksplic * $evv(MS_TO_SECS)]
				set minchunklen  [expr $splicsec / 2.0]
				Block "Cutting Chunks"
				set k 0
				catch {unset outchunks}
				set chunklist {}
				foreach fnam $infnams {
					if {[IsEven $k]} {
						wm title .blocker "PLEASE WAIT:        Cutting Chunks from [file rootname [file tail $fnam]]"
					} else {
						wm title .blocker "PLEASE WAIT:        AND Cutting Chunks from [file rootname [file tail $fnam]]"
					}
					set chunkfnam $evv(DFLT_OUTNAME)
					append chunkfnam $k
					set basfnam $chunkfnam
					append chunkfnam 0 $evv(SNDFILE_EXT)			;#	Last zero, added here, is stripped in file-naming procedure of program
					if [catch {file copy $fnam $chunkfnam} zit] {	;#	Orig file copied, as naming procedure in cmdline version uses input filename
						Inf "Cannot Copy Original File '[file rootname [file tail $fnam]]'"
						set OK 0
						break
					}
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd randcuts $chunkfnam $pchunkav $pchunkscat
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot Extract Chunks From File '$fnam': $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					set OK 1
					if {!$prg_dun} {
						set msg "Cannot Get Chunks From File '$fnam'"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					catch {file delete $chunkfnam}				;#	Delete the copy of the sourcefile
					foreach zfnam [glob -nocomplain $basfnam*] {
						if {[string match $zfnam $chunkfnam]} {	;#	In case deletion failed
							continue
						}							
						lappend outchunks($k) $zfnam
					}
					if {![info exists outchunks($k)]} {
						Inf "No Chunks Obtained From File '[file rootname [file tail $fnam]]'"
						set OK 0
						break
					}
					foreach zfnam $outchunks($k) {
						if {[DoParse $zfnam 0 0 0] <= 0} {
							Inf "Failed To Parse One Of Chunks Of File '[file rootname [file tail $fnam]]'"
							set OK 0
							break
						}
						if {$pa($zfnam,$evv(DUR)) <= $minchunklen} {
							Inf "Some Chunks Too Short For Specified Splice Length"
							set OK 0
							break

						}
						lappend chunklist $zfnam
					}
					if {!$OK} {
						break
					}
					incr k
				}
				if {!$OK}  {
					DeleteAllTemporaryFiles
					foreach zfnam $chunklist {
						PurgeArray $zfnam
					}
					UnBlock
					continue
				}
				set infilecnt $k
				set k 0
				catch {unset minchunks}
				while {$k < $infilecnt} {
					if {$k == 0} {
						set minchunks [llength $outchunks($k)]
					} elseif {[llength $outchunks($k)] < $minchunks} {
						set minchunks [llength $outchunks($k)]
					}
					incr k
				}
				catch {unset chunksperm}
				set k 0
				while {$k < $infilecnt} {
					randperm $minchunks
					set chunksperm($k) $hopperm		;#	Create random order of chunks for each file, individually
					incr k
				}
				set n 0
				catch {unset fnams}
				set outdur 0.0
				set outcnt 0
				set done 0
				while {$n < $minchunks} {
					randperm $infilecnt
					set filesperm $hopperm			;#	Create a random order of the input files, as each set-of-chunks (1 from each infile) is chosen
					set k 0
					while {$k < $infilecnt} {
						set fileno  [lindex $filesperm $k]
						set chunkno [lindex $chunksperm($fileno) $n]
						set thischunk [lindex $outchunks($fileno) $chunkno]
						lappend fnams $thischunk
						incr outcnt
						if {$pchunkshort} {			;#	If desired, limit length of output to that of input (approx)
							set outdur [expr $outdur + $pa($thischunk,$evv(DUR)) - $splicsec]
							if {$outdur >= $mindur} {
								set done 1
								break
							}
						}
						incr k
					}
					if {$done} {
						break
					}
					incr n
				}
				if {!$OK} {
					DeleteAllTemporaryFiles
					foreach zfnam $chunklist {
						PurgeArray $zfnam
					}
					UnBlock
					continue
				}
				set grpcnt 0
				set i 0
				foreach fnam $fnams {		;#	Group chunks into sets of pchunklim
					lappend fnam_s($grpcnt) $fnam
					incr i
					if {$i >= $pchunklim} {
						incr grpcnt
						set i 0
					}
				}
				if {$i > 0} {
					incr grpcnt
				}
				set j 0
				set startcnt 1
				while {$j < $grpcnt} {
					if {$j > 0} {
						if {[file exists $interfile]} {
							if [catch {file delete $interfile} zit] {
								Inf "Failed To Delete Intermediate File: Stopped Joining After $endcnt Files"
								break
							}
						}
						if [catch {file rename $outfnam $interfile} zit] {
							Inf "Failed To Rename Intermediate File: Stopped Joining After $endcnt Files"
							break
						}
						set x 0
						after 1000 {set x 1}
						vwait x
						set fnam_s($j) [concat $interfile $fnam_s($j)]
						set startcnt $endcnt
					}
					set endcnt [expr ($j + 1) * $pchunklim]
					if {$endcnt > $outcnt} {
						set endcnt $outcnt
					}
					wm title .blocker "PLEASE WAIT:        Joining Chunks $startcnt to $endcnt (of $outcnt)"
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd join
					foreach fnam $fnam_s($j) {
						lappend cmd [file rootname $fnam]
					}
					lappend cmd $outfnam -w$pchunksplic
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						catch {unset CDPidrun}
						if {$j == 0} {
							ErrShow "Cannot Join Chunks: $CDPidrun"
							DeleteAllTemporaryFiles
							foreach zfnam $chunklist {
								PurgeArray $zfnam
							}
							UnBlock
							continue
						} else {
							ErrShow "Cannot Join Chunks From $startcnt: $CDPidrun"
							if {![catch {file delete $outfnam} zit]} {
								catch {file rename $interfile $outfnam}
							}
							break
						}
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						if {$j == 0} {
							set msg "Failed To Join Chunks"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							DeleteAllTemporaryFiles
							foreach zfnam $chunklist {
								PurgeArray $zfnam
							}
							UnBlock
							continue
						} else {
							set msg "Failed To Join Chunks From $startcnt"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							if {![catch {file delete $outfnam} zit]} {
								catch {file rename $interfile $outfnam}
							}
							break
						}
					}
					if {![file exists $outfnam]} {
						if {$j == 0} {
							Inf "No Output File Generated"
							DeleteAllTemporaryFiles
							foreach zfnam $chunklist {
								PurgeArray $zfnam
							}
							UnBlock
							continue
						} else {
							Inf "No Output File Generated After $startcnt Chunks"
							if {![catch {file delete $outfnam} zit]} {
								catch {file rename $interfile $outfnam}
							}
							break
						}
					}
					incr j
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
					set last_outfile $outfnam
				}
				set fnam [file join $evv(URES_DIR) pchunk$evv(CDP_EXT)]
				if {![catch {open $fnam "w"} zit]} {
					puts $zit $pchunkav 
					puts $zit $pchunkscat 
					puts $zit $pchunksplic 
					puts $zit $pchunkshort
					close $zit
				}
				UnBlock
				set finished 1
			} 
			0 {
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	foreach zfnam $chunklist {
		PurgeArray $zfnam
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc PchunkScatIncr {down} {
	global pchunkscat
	if {$down} {
		if {$pchunkscat > 0.0} {
			set pchunkscat [expr $pchunkscat - 0.1]
		}
	} else {
		if {$pchunkscat < 1.0} {
			set pchunkscat [expr $pchunkscat + 0.1]
		}
	}	
}

proc PchunkAvIncr {down shift} {
	global pchunkav pchunkmindur
	switch -- $shift {
		0 {
			set incr .1
		}
		1 {
			set incr 1
		}
		2 {
			set incr .01
		}
	}
	if {$down} {
		set incr [expr -$incr]
	}
	set pchunkav [expr $pchunkav + $incr]
	if {$pchunkav < 0.01} {
		set pchunkav 0.01
	} elseif {$pchunkav > $pchunkmindur} {
		set pchunkav $pchunkmindur
	}
}

proc PchunkLast {} {
	global last_pchunkav last_pchunkscat last_pchunksplic last_pchunkshort pchunkav pchunkscat pchunksplic pchunkshort pchunklast
	if {[info exists last_pchunkav]} {
		set pchunkav $last_pchunkav
		set pchunkscat $last_pchunkscat
		set pchunksplic $last_pchunksplic
		set pchunkshort $last_pchunkshort
	} else {
		set pchunklast 0
	}
}

proc LoadPchunk {} {
	global evv pchunkav pchunkscat pchunksplic pchunkshort
	
	set fnam [file join $evv(URES_DIR) pchunk$evv(CDP_EXT)]
	if {![file exists $fnam]} {
		return
	}
	if [catch {open $fnam "r"} zit] {
		return
	}
	set cnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		switch -- $cnt {
			0 { set xpchunkav $line }
			1 { set xpchunkscat $line }
			2 { set xpchunksplic $line }
			3 { set xpchunkshort $line }
		}
		incr cnt
	}
	close $zit
	if {$cnt != 4} {
		Inf "CORRUPTED DATA IN FILE '$fnam'"
		catch {file delete $fnam}
		return
	}
	set pchunkav	$xpchunkav 
	set pchunkscat  $xpchunkscat
	set pchunksplic $xpchunksplic
	set pchunkshort $xpchunkshort
}


#-------  Convert multichannel soundfile to stereo

proc MchToStereo {} {
	global wl chlist pa evv pr_mchmixtost last_outfile mchtomixfnam mchancirc
	global prg_dun prg_abortd simple_program_messages CDPidrun CDPmaxId maxsamp_line done_maxsamp

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Multichannel Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 4) } {
		Inf "Select A Multichannel Soundfile"
		return
	}
	set chans $pa($fnam,$evv(CHANS))

	set mixfile $evv(DFLT_OUTNAME)
	append mixfile 0 $evv(TEXT_EXT)

	set ofile $evv(DFLT_OUTNAME)
	append ofile 0 $evv(SNDFILE_EXT)

	set f .mchmixtost
	if [Dlg_Create $f "CONVERT MULTICHAN SOUND TO STEREO" "set pr_mchmixtost 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Convert" -command "set pr_mchmixtost 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mchmixtost 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		radiobutton $f1.1 -variable mchancirc -text "Arrayed left to right" -value 0
		radiobutton $f1.2 -variable mchancirc -text "Arrayed in a circle" -value 1
		pack $f1.1 $f1.2 -side left -padx 2 -pady 2
		pack $f.1 -side top
		label $f2.ll -text "Output Filename "
		entry $f2.e -textvariable mchtomixfnam -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		set stmchtomixchans 8
		bind $f <Escape> {set pr_mchmixtost 0}
		bind $f <Return> {set pr_mchmixtost 1}
	}
	set mchtomixfnam [file rootname [file tail $fnam]]
	set mchancirc -1
	set pr_mchmixtost 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchmixtost $f.2.e
	while {!$finished} {
		tkwait variable pr_mchmixtost
		if {$pr_mchmixtost} {
			if {[string length $mchtomixfnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $mchtomixfnam]} {
				continue
			}
			set outfnam [string tolower $mchtomixfnam]
			append outfnam $evv(SNDFILE_EXT)
			if {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Please Choose A Different Name"
				continue
			}
			set line $fnam
			lappend line 0.0 $chans
			switch -- $mchancirc {
				0 {

					set posstep [expr 2.0/double($chans - 1)]
					set pos(1) -1.0
					set m 1
					set n 2
					while {$n < $chans} {
						set pos($n) [expr $pos($m) + $posstep]
						incr n
						incr m
					}
					set pos($n) 1.0
					set n 1
					while {$n <= $chans} {			;#	Calc relative levels, allowing for hole in middle
						if {$pos($n) < 0.0} {
							set relpos [expr -$pos($n)]
						} else {
							set relpos $pos($n)
						}
						set temp [expr 1.0 + ($relpos * $relpos)]
						set	reldist [expr $evv(ROOT2) / sqrt($temp)]
						set temp [expr ($pos($n) + 1.0) / 2.0];
						set rlevel [expr $temp * $reldist]
						set llevel [expr (1.0 - $temp) * $reldist]
						if {$llevel > 0} {
							set rout $n
							append rout ":1"
							lappend line $rout
							lappend line $llevel
						}
						if {$rlevel > 0} {
							set rout $n
							append rout ":2"
							lappend line $rout
							lappend line $rlevel
						}
						incr n
					}
				}
				1 {
					if {$chans != 8} {
						Inf "This Option Only Works With 8-Channel Files At Present"
						continue
					}
					set n 1
					while {$n <= $chans} {			;#	Calc relative levels, allowing for distance, +offset backcentre from frontcentre
						switch -- $n {
							1 {
								set llevel 0.7071 
								set rlevel 0.7071
							}
							2 {
								set llevel 0.3547 
								set rlevel 0.935 
							}
							3 {
								set llevel 0.0526 	
								set rlevel 0.9986 
							}
							4 {
								set llevel 0.14525 
								set rlevel 0.68474 
							}
							5 {
								set llevel 0.5547 
								set rlevel 0.8321
							}
							6 {
								set llevel 0.39128 
								set rlevel 0.083 
							}
							7 {
								set llevel 0.69902 	
								set rlevel 0.03682
							}
							8 {
								set llevel 0.935 	
								set rlevel 0.3547 
							}
						}
						set rout $n
						append rout ":1"
						lappend line $rout
						lappend line $llevel
						set rout $n
						append rout ":2"
						lappend line $rout
						lappend line $rlevel
						incr n
					}
				}
				default {
					Inf "No Output Formation Selected"
					continue
				}
			}
			set OK 1
			if [catch {open $mixfile "w"} zit] {
				Inf "Cannot Open Temporary Mixfile To Write Mixing Data"
				continue
			}
			puts $zit 2
			puts $zit $line
			close $zit
			Block "Remixing File [file rootname [file tail $fnam]]"
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $mixfile $ofile
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				catch {unset CDPidrun}
				ErrShow "Cannot Remix File: $CDPidrun"
				DeleteAllTemporaryFiles
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Remix The File: "
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				DeleteAllTemporaryFiles
				UnBlock
				continue
			}
			if {![file exists $ofile]} {
				Inf "No Output File Generated"
				DeleteAllTemporaryFiles
				UnBlock
				continue
			}
			wm title .blocker "PLEASE WAIT:        CHECKING LEVEL OF OUTPUT"
			set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
			lappend cmd $ofile
			set prg_dun 0
			set prg_abortd 0
			set done_maxsamp 0
			catch {unset maxsamp_line}
			if [catch {open "|$cmd"} CDPmaxId] {
				catch {unset CDPmaxId}
				Inf "Failed To Find (And Adjust) Maximum Level Of Output : $CDPmaxId"
				UnBlock
				break
			} else {
				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
			}
			vwait done_maxsamp
			if {!$done_maxsamp || ![info exists maxsamp_line]} {
				set msg "Failed To Find (And Adjust) Maximum Level Of Output"
				ErrShow $msg
				UnBlock
				break
			}
			catch {close CDPmaxId}
			set maxlev [lindex $maxsamp_line 0]
			if {$maxlev <= 0.0} {
				set msg "Output has zero level"
				ErrShow $msg
				UnBlock
				break
			}
			if {$maxlev > 0.95} {
				set adjustor [expr 0.95/$maxlev]
				wm title .blocker "PLEASE WAIT:        REMIXING FOR BETTER LEVEL"
				set len [llength $line]
				set n 4
				while {$n < $len} {
					set val [expr [lindex $line $n] * $adjustor]
					set line [lreplace $line $n $n $val]
					incr n 2
				}
				if [catch {open $mixfile "w"} zit] {
					Inf "Cannot Reopen Temporary Mixfile To Write New Mixing Data"
					UnBlock
					break
				}
				puts $zit 2
				puts $zit $line
				close $zit
				set cmd [file join $evv(CDPROGRAM_DIR) newmix]
				lappend cmd multichan $mixfile $outfnam
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					catch {unset CDPidrun}
					ErrShow "Cannot Do New Remix Of File: $CDPidrun"
					DeleteAllTemporaryFiles
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Do New Remix Of File:"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					DeleteAllTemporaryFiles
					UnBlock
					continue
				}
				if {![file exists $outfnam]} {
					Inf "No Output File Generated On 2nd Pass"
					DeleteAllTemporaryFiles
					UnBlock
					continue
				}
			} else {
				if [catch {file rename $ofile $outfnam} zit] {
					Inf "Cannot Rename The Temporary Output File ($ofile) To $outfnam\n\n(Do This Now, Outside The Loom, To Preserve The File)"
				}
			}	
			if {[file exists $outfnam]} {
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
				}
			}
			UnBlock
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-------  Select stereo from multichannel soundfile

proc MchSelectStereo {} {
	global wl chlist pa evv pr_mchselstereo last_outfile mselfnam mselright mselleft last_mselleft last_mselright
	global prg_dun prg_abortd simple_program_messages CDPidrun

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Multichannel Soundfile"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	set ftyp $pa($fnam,$evv(FTYP))
	if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 4)} {
		Inf "Select A Multichannel Soundfile"
		return
	}
	set chans $pa($fnam,$evv(CHANS))
	set tempfile $evv(DFLT_OUTNAME)
	append tempfile $evv(SNDFILE_EXT)
	set outfile $evv(MACH_OUTFNAME)
	append outfile 0 $evv(SNDFILE_EXT)
	if [catch {file copy $fnam $tempfile} zit] {
		Inf "Cannot Create Temporary Copy Of Input File"
		UnBlock
		continue
	}
	set f .mchselstereo
	if [Dlg_Create $f "SELECT STEREO FROM MULTICHAN SOUND" "set pr_mchselstereo 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.ok -text "Select Chans" -command "set pr_mchselstereo 1" -bg $evv(EMPH) -width 12 -highlightbackground [option get . background {}]
		button $f0.pp -text "Play" -command "set pr_mchselstereo 2" -width 4 -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mchselstereo 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.pp -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f.00 -text "SELECT CHANNELS"
		pack $f.00 -side top -anchor w -pady 2
		label $f1.ll -text "L: "
		pack $f1.ll -side left
		set n 1
		while {$n <= 16} {
			radiobutton $f1.$n -variable mselleft -text $n -value $n -command MchRecycle
			pack $f1.$n -side left
			incr n
		}
		pack $f.1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "R: "
		pack $f2.ll -side left
		set n 1
		while {$n <= 16} {
			radiobutton $f2.$n -variable mselright -text $n -value $n -command MchRecycle
			pack $f2.$n -side left
			incr n
		}
		pack $f.2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Output Filename "
		entry $f3.e -textvariable mselfnam -width 24
		pack $f3.e $f3.ll -side left
		pack $f3 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_mchselstereo 0}
		bind $f <Return> {set pr_mchselstereo 1}
	}
	catch {unset last_mselleft}
	catch {unset last_mselright}
	.mchselstereo.0.pp config -text "" -bd 0 -command {}
	set n 1
	while {$n <= $chans} {
		$f.1.$n config -text $n -state normal
		$f.2.$n config -text $n -state normal
		incr n
	}
	while {$n <= 16} {
		$f.1.$n config -text "" -state disabled
		$f.2.$n config -text "" -state disabled
		incr n
	}
	set mselleft  0
	set mselright 0
	set mselfnam [file rootname [file tail $fnam]]
	set pr_mchselstereo 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchselstereo $f.3.e
	while {!$finished} {
		tkwait variable pr_mchselstereo
		switch -- $pr_mchselstereo {
			1 {
				if {!($mselleft && $mselright)} {
					Inf "Select (Both) Output Channels From The Available Input Channels"
					continue
				}
				set got 0
				if {[info exists last_mselleft]} {
					if {$last_mselleft != $mselleft} {
						catch {file delete $leftfile}
					} else {
						incr got
					}
				}
				if {[info exists last_mselright]} {
					if {$last_mselright != $mselright} {
						catch {file delete $rightfile}
					} else {
						incr got
					}
				}
				if {$got == 2} {
					Inf "Already Made This Sound"
					continue
				}
				.mchselstereo.0.pp config -text "" -bd 0 -command {} ;#	Disable play
				set leftfile $evv(DFLT_OUTNAME)
				set rightfile $evv(DFLT_OUTNAME)
				append leftfile  "_c$mselleft"  $evv(SNDFILE_EXT)
				append rightfile "_c$mselright" $evv(SNDFILE_EXT)
				set last_mselleft  $mselleft 
				set last_mselright $mselright

				catch {file delete $outfile}
	
				Block "EXTRACTING CHANNELS"

				if {![file exists $leftfile]} {
					wm title .blocker "EXTRACTING CHANNEL $mselleft AS LEFT CHANNEL"
					set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
					lappend cmd chans 1 $tempfile $mselleft
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						catch {unset CDPidrun}
						ErrShow "CANNOT EXTRACT CHANNEL $mselleft: $CDPidrun"
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "FAILED TO EXTRACT CHANNEL $mselleft :"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					if {![file exists $leftfile]} {
						Inf "No Left Output File Generated From Channel $mselleft"
						UnBlock
						continue
					}
				}
				if {![file exists $rightfile]} {
					wm title .blocker "EXTRACTING CHANNEL $mselright AS RIGHT CHANNEL"
					set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
					lappend cmd chans 1 $tempfile $mselright
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						catch {unset CDPidrun}
						ErrShow "Cannot Extract Channel $mselright: $CDPidrun"
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Extract Channel $mselright :"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					if {![file exists $rightfile]} {
						Inf "No Right Output File Generated From Channel $mselright"
						UnBlock
						continue
					}
				}
				wm title .blocker "CREATING STEREO OUTPUT"
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd interleave $leftfile $rightfile $outfile
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					catch {unset CDPidrun}
					ErrShow "Cannot Create Stereo Output: $CDPidrun"
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Create Stereo Output :"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {![file exists $outfile]} {
					Inf "No Stereo Output File Generated"
					UnBlock
					continue
				}
				.mchselstereo.0.pp config -text "Play" -command "set pr_mchselstereo 2" -bd 2
				.mchselstereo.0.ok config -text "Save File" -command "set pr_mchselstereo 3"
				UnBlock
			}
			2 {
				if {![file exists $outfile]} {
					Inf "No Output File Exists"
					continue
				}
				PlaySndfile $outfile 0
			}
			3 {
				if {[string length $mselfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $mselfnam]} {
					continue
				}
				set outfnam [string tolower $mselfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Exists: Please Choose A Different Name"
					continue
				}
				if [catch {file rename $outfile $outfnam} zit] {
					Inf "Cannot Rename Output File To outfnam"
					continue
				} 
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					Inf "File '$outfnam' Is On The Workspace"
				}
				set last_outfile $outfnam
				.mchselstereo.0.pp config -text "" -command {} -bd 0
				.mchselstereo.0.ok config -text "Select Chans" -command "set pr_mchselstereo 1"
			}
			0	{
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc MchRecycle {} {
	global last_mselleft last_mselright mselleft mselright pr_mchselstereo
	if {([info exists last_mselleft] && ($last_mselleft != $mselleft)) || ([info exists last_mselright] && ($last_mselright != $mselright))} {
		.mchselstereo.0.ok config -text "Select" -command "set pr_mchselstereo 1"
	}
}

#------ Inject K mono soundfiles, equally spaced, into an N channel ring

proc KMonoToNMulti {} {
	global chlist pa evv pr_kmonnmulti kmonnmultich kmonnmultifnam prg_dun prg_abortd simple_program_messages CDPidrun
	global maxsamp_line done_maxsamp CDPmaxId

	if {![info exists chlist] || ([llength $chlist] <= 0)} {
		Inf "No Files Selected"
		return
	}
	set fcnt 0
	foreach fnam $chlist {
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 1)} {
			Inf "Not All The Selected Files Are Mono Soundfiles"
			return
		}
		incr fcnt
	}
	if {$fcnt < 2} {
		Inf "Not Enough Files Selected"
		return
	}
	set f .kmonnmulti
	if [Dlg_Create $f "CONVERT MULTICHAN SOUND TO STEREO" "set pr_kmonnmulti 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Generate Sound" -command "set pr_kmonnmulti 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_kmonnmulti 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Number of output channels "
		entry $f1.e -textvariable kmonnmultich -width 4
		pack $f1.e $f1.ll -side left
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "Output Filename "
		entry $f2.e -textvariable kmonnmultifnam -width 24
		pack $f2.e $f2.ll -side left
		pack $f2 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		set kmonnmultich 8
		bind $f <Escape> {set pr_kmonnmulti 0}
		bind $f <Return> {set pr_kmonnmulti 1}
	}
	set firsttime 1
	set pr_kmonnmulti 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_kmonnmulti $f.2.e
	while {!$finished} {
		tkwait variable pr_kmonnmulti
		if {$pr_kmonnmulti} {
			if {[string length $kmonnmultich] <= 0} {
				Inf "No Output Channel Count Entered"
				continue
			}
			if {![regexp {^[0-9]+$} $kmonnmultich] || ($kmonnmultich <= 4) || ($kmonnmultich > 16)} {
				Inf "Invalid Output Channel Count Entered"
				continue
			}
			if {[string length $kmonnmultifnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $kmonnmultifnam]} {
				continue
			}
			set outfnam [string tolower $kmonnmultifnam]
			append outfnam $evv(SNDFILE_EXT)
			if {$firsttime} {
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Exists: Please Choose A Different Name"
					continue
				}
				set mixfnam [string tolower $kmonnmultifnam]
				append mixfnam [GetTextfileExtension mmx]
				if {[file exists $mixfnam]} {
					Inf "File '$mixfnam' Exists: Please Choose A Different Name"
					unset mixfnam
					continue
				}
				set docheck 1
				catch {unset lines}
				set line $kmonnmultich
				lappend lines $line
				if {$fcnt == $kmonnmultich} {
					set k 1
					foreach fnam $chlist {
						set line $fnam
						lappend line 0.0 1 1:$k 1
						lappend lines $line
						incr k
					}
					set docheck 0
				} else {
					set jk 1.0
					set step [expr double($kmonnmultich) / double($fcnt)]
					set line [lindex $chlist 0]
					lappend line 0.0 1 1:1 1
					lappend lines $line
					foreach fnam [lrange $chlist 1 end] {
						set jk [expr $jk + $step]
						set j [expr int(floor($jk))]
						set k $j
						incr k
						if {$k > $kmonnmultich} {
							set k 1
						}
						set rweight [expr $jk - double($j)]
						set lweight [expr 1.0 - $rweight]
						set line $fnam
						lappend line 0.0 1 
						if {$lweight > $evv(FLTERR)} {
							lappend line 1:$j $lweight
						}
						if {$rweight > $evv(FLTERR) } {
							lappend line 1:$k $rweight
						}
						lappend lines $line
					}
					if {$fcnt > $kmonnmultich} {
						set docheck 1
					}
				}
				if [catch {open $mixfnam "w"} zit] {
					Inf "Cannot Open Mixfile To Create Output Sound"
					continue
				}
				foreach line $lines {
					puts $zit $line
				}					
				close $zit
				set firsttime 0
			} elseif {[file exists $outfnam]} {
				Inf "File '$outfnam' Exists: Cannot Proceed"
				continue
			}
			Block "MIXING THE SOUNDS"
			set cmd [file join $evv(CDPROGRAM_DIR) newmix]
			lappend cmd multichan $mixfnam $outfnam
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				catch {unset CDPidrun}
				ErrShow "Cannot Do Mix Of Sounds: $CDPidrun"
				catch {file delete $outfnam}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Mix Sounds:"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				catch {file delete $outfnam}
				UnBlock
				continue
			}
			if {![file exists $outfnam]} {
				set msg "Failed To Generate Output Sound:"
				set msg [AddSimpleMessages $msg]
				ErrShow $msg
				catch {file delete $outfnam}
				UnBlock
				continue
			}
			set done 1
			if {$docheck} {
				set done 0				
				while {!$done} {
					wm title .blocker "PLEASE WAIT:        CHECKING LEVEL"
					set cmd2 [file join $evv(CDPROGRAM_DIR) maxsamp2]
					catch {unset maxsamp_line}
					set done_maxsamp 0
					lappend cmd2 $outfnam
					if [catch {open "|$cmd2"} CDPmaxId] {
						Inf "Failed To Find Maximum Level Of Output: Outfile Could Be Distorted"
						set done 1
						break
					}
					fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					vwait done_maxsamp
					if {![info exists maxsamp_line]} {
						Inf "Cannot Retrieve Maximum Level Information: Outfile Could Be Distorted"
						set done 1
						break
					}
					set maxoutsamp [lindex $maxsamp_line 0]
					if {$maxoutsamp <= 0.95} {
						set done 1
						break
					}
					if [catch {file delete $outfnam} zit] {
						Inf "Cannot Delete The Distorted Output File, To Remix"
						break
					}
					wm title .blocker "PLEASE WAIT:        RECREATING MIX TO ASSESS BEST LEVEL"
					lappend cmd -g0.1
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						catch {unset CDPidrun}
						ErrShow "Cannot Do Remix Of Sounds: $CDPidrun"
						catch {file delete $outfnam}
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Remix Sounds:"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						catch {file delete $outfnam}
						break
					}
					if {![file exists $outfnam]} {
						set msg "Failed To Generate New Output Sound:"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						catch {file delete $outfnam}
						break
					}
					wm title .blocker "PLEASE WAIT:        2ND LEVEL CHECK"
					catch {unset maxsamp_line}
					set done_maxsamp 0
					if [catch {open "|$cmd2"} CDPmaxId] {
						Inf "Failed To Find Max Level On Second Check: Output Attenuated"
						set done 1
						break
					}
					fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					vwait done_maxsamp
					if {![info exists maxsamp_line]} {
						Inf "Cannot Retrieve Max Level: Output Attenuated"
						set done 1
						break
					}
					set maxoutsamp [lindex $maxsamp_line 0]
					set nulevel [expr 0.1 * 0.95/$maxoutsamp]
					set cmd [lreplace $cmd end end -g$nulevel]
					if [catch {file delete $outfnam} zit] {
						Inf "Cannot Delete The Test Output File, To Do Final Mix"
						break
					}
					wm title .blocker "PLEASE WAIT:        FINAL REMIX"
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						catch {unset CDPidrun}
						ErrShow "Cannot Do Final Remix Of Sounds: $CDPidrun"
						catch {file delete $outfnam}
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Do Final Remix Of Sounds:"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						catch {file delete $outfnam}
						break
					}
					if {![file exists $outfnam]} {
						set msg "Failed To Generate Final Output Sound:"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						catch {file delete $outfnam}
						break
					}
					set done 1
				}
			}
			if {!$done} {
				UnBlock
				continue
			}
			if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
				Inf "File '$outfnam' Is On The Workspace"
			} else {
				Inf "File '$outfnam' Created"
			}
		
			UnBlock
			set finished 1
		} else {
			set finished 1
		}
	}
	if {[info exists mixfnam] && [file exists $mixfnam]} {
		catch {file delete $mixfnam}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}


#---- Take N files from a partition, filter the outputs and remix the filtered versions
#---- Possibly rotating the files before doing so

proc FilterPartition {} {
	global gridff_mode gridff_speed	gridff_speedbak gridff_q gridff_gain fpart_mix pr_gridff 
	global gridff_tail gridff_harms gridff_db gridff_mixgain gridff_fnam fpar_outfiles gridff_ffile
	global prg_dun prg_abortd simple_program_messages CDPidrun chlist pa evv wstk pff_list pffset pffrotset pffsetdir
	global pff_list_list pff_outfnam pff_routfnam

	catch {unset pff_list}
	catch {unset pff_list_list}
	if {[info exists pffset]} {
		foreach nam [array names pffset] {
			catch {unset pffset($nam)}
		}
	}
	if {[info exists pffrotset]} {
		foreach nam [array names pffrotset] {
			catch {unset pffrotset($nam)}
		}
	}
	if {![info exists chlist] || ([llength $chlist] < 2) || ([llength $chlist] > 16)} {
		Inf "Select From 2 To 16 Single Mono Soundfiles"	
		return
	}
	foreach fnam $chlist {
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 1)} {
			Inf "Select Mono Soundfiles"	
			return
		} else {
			lappend infnams $fnam
		}
	}
	set fpar_outfiles [llength $chlist]
	DeleteAllTemporaryFiles
	set n 0
	while {$n < $fpar_outfiles} {
		set pff_outfnam($n) $evv(DFLT_OUTNAME)
		append pff_outfnam($n) $n $evv(SNDFILE_EXT)
		set pff_routfnam($n) $evv(MACH_OUTFNAME)
		append pff_routfnam($n) $n $evv(SNDFILE_EXT)
		incr n
	}
	set fpart_mix $evv(DFLT_OUTNAME)
	append fpart_mix 0 ".mmx"
	set f .gridff
	if [Dlg_Create $f "FILTER PARTITIONED INFILES, AND REMIX" "set pr_gridff 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f00 [frame $f.00] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.hh -text "Help" -command "HelpPFF" -bg $evv(HELP) -highlightbackground [option get . background {}] -highlightbackground [option get . background {}]
		button $f0.ok -text "Generate Sound" -command "set pr_gridff 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		label $f0.dum2 -text "" -width 10
		label $f0.ll -text "Filter Set "
		button $f0.ss -text "Save" -command "set pr_gridff 2" -highlightbackground [option get . background {}]
		button $f0.gg -text "Get" -command "GetPFFile 0" -highlightbackground [option get . background {}]
		label $f0.dd -text "Dir of filt files"
		entry $f0.ed -textvariable pffsetdir -width 24
		label $f0.dum -text "" -width 10
		button $f0.quit -text "Abandon" -command "set pr_gridff 0" -highlightbackground [option get . background {}]
		pack $f0.hh $f0.ok $f0.dum2 $f0.ll $f0.ss $f0.gg $f0.dd $f0.ed $f0.dum -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f2.ll -text "Output filename "
		entry $f2.e -textvariable gridff_fnam -width 16
		pack $f2.ll $f2.e -side left
		pack $f2 -side top -pady 2
		radiobutton $f00.wst -variable gridff_mode -text "Stationary mix" -value 1 -command GridffMode
		radiobutton $f00.dur -variable gridff_mode -text "Rotating mix" -value 2 -command GridffMode
		set gridff_mode 0
		pack $f00.wst $f00.dur -side left
		pack $f00 -side top -pady 2
		frame $f1.1
		frame $f1.2
		frame $f1.3
		label $f1.1.tit -text "VARIBANK FILTER FILES "
		label $f1.1.xx -text "midi data NOT checked" -fg $evv(SPECIAL)
		pack $f1.1.tit $f1.1.xx -side top
		set n 1
		while {$n <= 16} {
			set qq [frame $f1.1.$n]
			label $qq.ll -text "$n " -width 3
			entry $qq.e -textvariable gridff_ffile($n) -width 24
			button $qq.b -text "Get File" -command "GetPFFile $n" -width 8 -highlightbackground [option get . background {}]
			pack $qq.e $qq.ll $qq.b -side left
			pack $qq -side top -pady 2 -fill x -expand true
			incr n
		}
		label $f1.2.tit -text "ROTATION SPEEDS " -width 16
		label $f1.2.xx -text "-ve is anticlockwise" -fg $evv(SPECIAL)
		pack $f1.2.tit $f1.2.xx -side top
		set n 1
		while {$n <= 16} {
			set qq [frame $f1.2.$n]
			label $qq.ll -text "" -width 3
			entry $qq.e -textvariable gridff_speed($n) -width 4
			pack $qq.e $qq.ll -side left
			pack $qq -side top -pady 4 -fill x -expand true
			incr n
		}
		label $f1.3.tit -text "GLOBAL PARAMS "
		pack $f1.3.tit -side top
		frame $f1.3.q
		label $f1.3.q.ll -text "Q "
		entry $f1.3.q.e -textvariable gridff_q -width 6
		pack $f1.3.q.e $f1.3.q.ll -side left
		pack $f1.3.q -side top -pady 2 -fill x -expand true

		frame $f1.3.g
		label $f1.3.g.ll -text "Filter Gain "
		entry $f1.3.g.e -textvariable gridff_gain -width 6
		pack $f1.3.g.e $f1.3.g.ll -side left
		pack $f1.3.g -side top -pady 2 -fill x -expand true

		frame $f1.3.t
		label $f1.3.t.ll -text "Tail Dur "
		entry $f1.3.t.e -textvariable gridff_tail -width 6
		pack $f1.3.t.e $f1.3.t.ll -side left
		pack $f1.3.t -side top -pady 2 -fill x -expand true

		frame $f1.3.h
		label $f1.3.h.ll -text "No of harmonics "
		entry $f1.3.h.e -textvariable gridff_harms -width 6
		pack $f1.3.h.e $f1.3.h.ll -side left
		pack $f1.3.h -side top -pady 2 -fill x -expand true

		frame $f1.3.r
		label $f1.3.r.ll -text "Roll Off "
		entry $f1.3.r.e -textvariable gridff_db -width 6
		pack $f1.3.r.e $f1.3.r.ll -side left
		pack $f1.3.r -side top -pady 2 -fill x -expand true
		
		frame $f1.3.m
		label $f1.3.m.ll -text "Mix Level "
		entry $f1.3.m.e -textvariable gridff_mixgain -width 6
		pack $f1.3.m.e $f1.3.m.ll -side left
		pack $f1.3.m -side top -pady 30 -fill x -expand true

		pack $f1.1 $f1.2 $f1.3 -side left -fill x -expand true -anchor n
		pack $f1 -side top -pady 2

		wm resizable $f 1 1
		bind $f <Escape> {set pr_gridff 0}
		bind $f <Return> {set pr_gridff 1}

		bind .gridff.2.e  <Down> {focus .gridff.1.1.1.e }
		bind .gridff.1.1.1.e <Up> {focus .gridff.2.e  }

		bind .gridff.1.3.q.e <Down> {focus .gridff.1.3.g.e }
		bind .gridff.1.3.g.e <Down> {focus .gridff.1.3.t.e }
		bind .gridff.1.3.t.e <Down> {focus .gridff.1.3.h.e }
		bind .gridff.1.3.h.e <Down> {focus .gridff.1.3.r.e }
		bind .gridff.1.3.r.e <Down> {focus .gridff.1.3.m.e }
		bind .gridff.1.3.m.e <Down> {focus .gridff.1.3.q.e }

		bind .gridff.1.3.q.e <Up> {focus .gridff.2.e }
		bind .gridff.1.3.g.e <Up> {focus .gridff.1.3.q.e }
		bind .gridff.1.3.t.e <Up> {focus .gridff.1.3.g.e }
		bind .gridff.1.3.h.e <Up> {focus .gridff.1.3.t.e }
		bind .gridff.1.3.r.e <Up> {focus .gridff.1.3.h.e }
		bind .gridff.1.3.m.e <Up> {focus .gridff.1.3.r.e }
	}
	set n 1
	while {$n <= $fpar_outfiles} {
		$f.1.1.$n.ll config -text $n
		$f.1.1.$n.e  config -bd 2 -state normal
		$f.1.1.$n.b  config -bd 2 -command "GetPFFile $n"
		if {![info exists gridff_ffile($n)] || ![file exists $gridff_ffile($n)]} {
			set gridff_ffile($n) ""
		}
		incr n
	}
	while {$n <= 16} {
		$f.1.1.$n.ll config -text ""
		$f.1.1.$n.e  config -bd 0 -state disabled -disabledbackground [option get . background {}]
		$f.1.1.$n.b  config -bd 0 -command {} -text ""
		if {![info exists gridff_ffile($n)] || ![file exists $gridff_ffile($n)]} {
			set gridff_ffile($n) ""
		}
		incr n
	}
	GridffMode
	set pr_gridff 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_gridff $f.1.1.1.e
	while {!$finished} {
		tkwait variable pr_gridff
		switch -- $pr_gridff {
			1 {
				if {![file exists $fpart_mix]} {
					if {$gridff_mode < 1} {
						Inf "'Stationary' Or 'rotating' Not Set"
						continue
					}
					set n 1
					set OK 1
					while {$n <= $fpar_outfiles} {
						if {[string length $gridff_ffile($n)] <= 0} {
							Inf "No Filter File Entered For Sound $n"
							set OK 0
							break
						}
						if {![file exists $gridff_ffile($n)]} {
							Inf "Filter File $gridff_ffile($n) Does Not Exist"
							set OK 0
							break
						}
						incr n
					}
					if {!$OK} {
						continue
					}
					if {$gridff_mode == 2} {
						set n 1
						set OK 1
						while {$n <= $fpar_outfiles} {
							if {[string length $gridff_speed($n)] <= 0} {
								Inf "No Rotation Speed Entered For Sound $n"
								set OK 0
								break
							}
							if {![IsNumeric $gridff_speed($n)] || ($gridff_speed($n) < -64) || ($gridff_speed($n) > 64)} {
								Inf "Rotation Speed $n Invalid (Range -64 to +64)"
								set OK 0
								break
							}
							incr n
						}
						if {!$OK} {
							continue
						}
					}
					if {[string length $gridff_q] <= 0} {
						Inf "No Q Value Entered"
						continue
					}
					if {![IsNumeric $gridff_q] || ($gridff_q < 10) || ($gridff_q > 1000)} {
						Inf "Q Value Invalid (Range 10 to 1000)"
						continue
					}
					if {[string length $gridff_gain] <= 0} {
						Inf "No Filter Gain Entered"
						continue
					}
					if {![IsNumeric $gridff_gain] || ($gridff_gain < 1) || ($gridff_gain > 200)} {
						Inf "Filter Gain Invalid (Range 1 to 200)"
						continue
					}
					if {[string length $gridff_tail] <= 0} {
						Inf "No Tail Duration Entered"
						continue
					}
					if {![IsNumeric $gridff_tail] || ($gridff_tail < 0) || ($gridff_tail > 20)} {
						Inf "Tail Duration Invalid (Range 0 to 20)"
						continue
					}
					if {[string length $gridff_harms] <= 0} {
						Inf "No Harmonics Count Entered"
						continue
					}
					if {![IsNumeric $gridff_harms] || ![regexp {^[0-9]+$} $gridff_harms] || ($gridff_harms < 1) || ($gridff_harms > 200)} {
						Inf "Harmonics Count Invalid (integer Range 1 to 200)"
						continue
					}
					if {[string length $gridff_db] <= 0} {
						Inf "No Roll-Off Value Entered"
						continue
					}
					if {![IsNumeric $gridff_db] || ($gridff_db < -96) || ($gridff_db > 0)} {
						Inf "Roll-Off Invalid (Range -96 to 0)"
						continue
					}
					if {[string length $gridff_mixgain] <= 0} {
						Inf "No Mix Level Entered"
						continue
					}
					if {![IsNumeric $gridff_mixgain] || ($gridff_mixgain < $evv(FLTERR)) || ($gridff_mixgain > 1)} {
						Inf "Mix Level Invalid (Range >0 to 1)"
						continue
					}
					if {[string length $gridff_fnam] <= 0} {
						Inf "No Output Filename Entered"
						continue
					}
					if {![ValidCDPRootname $gridff_fnam]} {
						continue
					}
					set outfnam [string tolower $gridff_fnam]
					append outfnam $evv(SNDFILE_EXT) 
					if {[file exists $outfnam]} {
						Inf "A File With The Name '$outfnam' Already Exists: Please Choose A Different Name"
						continue
					}
					Block "FILTERING SOUNDS"
					set OK 1
					set n 0
					set m 1
					while {$n < $fpar_outfiles} {
						set cmd [file join $evv(CDPROGRAM_DIR) filter]
						lappend cmd varibank 2 [lindex $chlist $n] $pff_outfnam($n) $gridff_ffile($m) 
						lappend cmd $gridff_q $gridff_gain -t$gridff_tail -h$gridff_harms -r$gridff_db -d
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        FILTERING SOUND $m"
						if [catch {open "|$cmd"} CDPidrun] {
							catch {unset CDPidrun}
							Inf "Cannot Do Filtering Of File $m: $CDPidrun"
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Filter Sound $m:"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						if {![file exists $pff_outfnam($n)]} {
							set msg "Failed To Generate Filtered Sound $m:"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						incr n
						incr m
					}
					if {!$OK} {
						DeleteAllTemporaryFiles
						UnBlock
						continue
					}
					if {$gridff_mode == 2} {
						wm title .blocker "PLEASE WAIT:        ROTATING SOUNDS"
						set OK 1
						set n 0
						set m 1
						while {$n < $fpar_outfiles} {
							set cmd [file join $evv(CDPROGRAM_DIR) mchanpan]
							lappend cmd mchanpan 9 $pff_outfnam($n) $pff_routfnam($n)
							if {$gridff_speed($m) < 0} {
								set rspeed [expr -$gridff_speed($m)]
								set anti 1
							} else {
								set rspeed $gridff_speed($m)
								set anti 0
							}
							lappend cmd $fpar_outfiles $m $rspeed 0.8
							if {$anti} {
								lappend cmd -a
							}
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							wm title .blocker "PLEASE WAIT:        ROTATING SOUND $m"
							if [catch {open "|$cmd"} CDPidrun] {
								catch {unset CDPidrun}
								Inf "Cannot Do Rotation Of File $m: $CDPidrun"
								set OK 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Failed To Rotate Sound $m:"
								set msg [AddSimpleMessages $msg]
								Inf $msg
								set OK 0
								break
							}
							if {![file exists $pff_routfnam($n)]} {
								set msg "Failed To Generate Rotated Sound $m:"
								set msg [AddSimpleMessages $msg]
								Inf $msg
								set OK 0
								break
							}
							incr n
							incr m
						}
						if {!$OK} {
							DeleteAllTemporaryFiles
							UnBlock
							continue
						}
						if {![CreateFiltPartMix rot $fpar_outfiles]} {
							DeleteAllTemporaryFiles
							UnBlock
							continue
						}
					} else {
						if {![CreateFiltPartMix stat $fpar_outfiles]} {
							DeleteAllTemporaryFiles
							UnBlock
							continue
						}
					}
				}
				set cmd [file join $evv(CDPROGRAM_DIR) newmix]
				lappend cmd multichan $fpart_mix $outfnam -g$gridff_mixgain
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        MIXING SOUNDS"
				if [catch {open "|$cmd"} CDPidrun] {
					catch {unset CDPidrun}
					Inf "Cannot Do Mix: $CDPidrun"
					DeleteAllTemporaryFiles
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Mix Sounds:"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					DeleteAllTemporaryFiles
					UnBlock
					continue
				}
				if {![file exists $outfnam]} {
					set msg "Failed To Generate Mixed Sound:"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					DeleteAllTemporaryFiles
					UnBlock
					continue
				}
				FileToWkspace $outfnam 0 0 0 0 1
				Inf "File $outfnam Should Be On The Workspace"
				UnBlock
			}
			2 {
				set OK 1
				set n 1
				while {$n <= $fpar_outfiles} {
					if {[string length $gridff_ffile($n)] <= 0} {
						Inf "No Filter File Entered For Sound $n"
						set OK 0
						break
					}
					if {![file exists $gridff_ffile($n)]} {
						Inf "Filter File $gridff_ffile($n) Does Not Exist"
						set OK 0
						break
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				if {[string length $gridff_fnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $gridff_fnam]} {
					continue
				}
				set ffoutfnam [string tolower $gridff_fnam]
				append ffoutfnam $evv(TEXT_EXT) 
				if {[file exists $ffoutfnam]} {
					Inf "A File With The Name '$ffoutfnam' Already Exists: Please Choose A Different Name"
					continue
				}
				if [catch {open $ffoutfnam "w"} zit] {
					Inf "Cannot Open File '$ffoutfnam'"
					continue
				}
				catch {unset pffset($ffoutfnam)}
				catch {unset pffrotset($ffoutfnam)}
				set n 1
				set OK 1
				while {$n <= $fpar_outfiles} {
					if {$gridff_mode == 2} {
						if {![info exists gridff_speed($n)] || ![IsNumeric $gridff_speed($n)] || ($gridff_speed($n) < -64) || ($gridff_speed($n) > 64)} {
							Inf "Rotation Speed $n Is Invalid"
							set OK 0
							break
						}
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				set n 1
				while {$n <= $fpar_outfiles} {
					lappend pffset($ffoutfnam) $gridff_ffile($n)
					set line $gridff_ffile($n)
					if {$gridff_mode == 2} {
						lappend pffrotset($ffoutfnam) $gridff_speed($n)
						lappend line $gridff_speed($n)
					}
					puts $zit $line
					incr n
				}
				close $zit
				FileToWkspace $ffoutfnam 0 0 0 0 1
				Inf "File $ffoutfnam Is On The Workspace"
				continue
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc GridffMode {} {
	global gridff_mode gridff_speed	gridff_speedbak fpar_outfiles
	switch -- $gridff_mode {
		1 {
			set n 1
			while {$n <= 16} {
				set gridff_speedbak $gridff_speed($n)
				set gridff_speed($n) ""
				.gridff.1.2.$n.e  config -bd 0 -state disabled -disabledbackground [option get . background {}]
				incr n
			}
			.gridff.1.2.tit config -text ""
			.gridff.1.2.xx config -text ""
			set n 1
			while {$n <= $fpar_outfiles} {
				set m [expr $n + 1]
				if {$m > $fpar_outfiles} {
					set m 1
				}
				set k [expr $n - 1]
				if {$k < 1} {
					set k $fpar_outfiles
				}
				bind .gridff.1.1.$n.e <Right> "focus .gridff.1.3.q.e"
				bind .gridff.1.1.$n.e <Down>  "focus .gridff.1.1.$m.e"
				if {$n == 1} {
					bind .gridff.1.1.$n.e <Up>    "focus .gridff.2.e"
				} else {
					bind .gridff.1.1.$n.e <Up>    "focus .gridff.1.1.$k.e"
				}
				incr n
			}
			bind .gridff.1.3.q.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.g.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.t.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.h.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.r.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.m.e <Left> "focus .gridff.1.1.1.e "
			focus .gridff.1.1.1.e
		}
		2 {
			set n 1
			while {$n <= $fpar_outfiles} {
				if [info exists gridff_speedbak($n)] {
					set gridff_speed $gridff_speedbak($n)
				} else {
					set gridff_speed($n) ""
				}
				.gridff.1.2.$n.e  config -bd 2 -state normal
				incr n
			}
			.gridff.1.2.tit config -text "ROTATION SPEEDS "
			.gridff.1.2.xx config -text "-ve is anticlockwise"

			set n 1
			while {$n <= $fpar_outfiles} {
				set m [expr $n + 1]
				if {$m > $fpar_outfiles} {
					set m 1
				}
				set k [expr $n - 1]
				if {$k < 1} {
					set k $fpar_outfiles
				}
				bind .gridff.1.1.$n.e <Right> "focus .gridff.1.2.$n.e "
				bind .gridff.1.2.$n.e <Left>  "focus .gridff.1.1.$n.e "
				bind .gridff.1.2.$n.e <Right> "focus .gridff.1.3.q.e"
				bind .gridff.1.1.$n.e <Down>  "focus .gridff.1.1.$m.e"
				if {$n == 1} {
					bind .gridff.1.1.$n.e <Up>    "focus .gridff.2.e"
				} else {
					bind .gridff.1.1.$n.e <Up>    "focus .gridff.1.1.$k.e"
				}
				bind .gridff.1.2.$n.e <Down>  "focus .gridff.1.2.$m.e"
				if {$n == 1} {
					bind .gridff.1.2.$n.e <Up>    "focus .gridff.2.e"
				} else {
					bind .gridff.1.2.$n.e <Up>    "focus .gridff.1.2.$k.e"
				}
				incr n
			}
			bind .gridff.1.3.q.e <Left> "focus .gridff.1.2.1.e "
			bind .gridff.1.3.g.e <Left> "focus .gridff.1.2.1.e "
			bind .gridff.1.3.t.e <Left> "focus .gridff.1.2.1.e "
			bind .gridff.1.3.h.e <Left> "focus .gridff.1.2.1.e "
			bind .gridff.1.3.r.e <Left> "focus .gridff.1.2.1.e "
			bind .gridff.1.3.m.e <Left> "focus .gridff.1.2.1.e "
		}
		default {
			set n 1
			while {$n <= 16} {
				set gridff_speed($n) ""
				.gridff.1.2.$n.e  config -bd 0 -state disabled -disabledbackground [option get . background {}]
				incr n
			}
			.gridff.1.2.tit config -text ""
			set n 1
			while {$n <= $fpar_outfiles} {
				set m [expr $n + 1]
				if {$m > $fpar_outfiles} {
					set m 1
				}
				set k [expr $n - 1]
				if {$k < 1} {
					set k $fpar_outfiles
				}
				bind .gridff.1.1.$n.e <Right> "focus .gridff.1.3.q.e"
				bind .gridff.1.1.$n.e <Down>  "focus .gridff.1.1.$m.e"
				if {$n == 1} {
					bind .gridff.1.1.$n.e <Up>    "focus .gridff.2.e"
				} else {
					bind .gridff.1.1.$n.e <Up>    "focus .gridff.1.1.$k.e"
				}
				incr n
			}
			bind .gridff.1.3.q.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.g.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.t.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.h.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.r.e <Left> "focus .gridff.1.1.1.e "
			bind .gridff.1.3.m.e <Left> "focus .gridff.1.1.1.e "
		}
	}
}

#---- Create multichannel mixfile, using filtered sources

proc CreateFiltPartMix {typ cnt} {
	global fpart_mix pff_outfnam pff_routfnam fpar_outfiles
	set line $fpar_outfiles
	lappend lines $line
	set n 0
	set m 1
	switch -- $typ {
		"rot" {
			while {$n < $cnt} {
				set line $pff_routfnam($n)
				lappend line 0.0000 $fpar_outfiles
				set k 1				
				while {$k <= $cnt} {
					lappend line $k:$k 1.0
					incr k
				}
				lappend lines $line
				incr m
				incr n
			}
		}
		"stat" {
			while {$n < $cnt} {
				set line $pff_outfnam($n)
				lappend line 0.0000 1 1:$m 1.0
				lappend lines $line
				incr m
				incr n
			}
		}
	}
	if [catch {open $fpart_mix "w"} zit] {
		Inf "Cannot Open File '$fpart_mix' To Mix Filtered Sounds"
		return 0
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	return 1
}

#---- Get Filter File (or set of them, in file) from existing listings, or from workspace

proc GetPFFile {n} {
	global gridff_ffile gridff_speed wl pr_pfffiles pa evv pff_list pff_list_list fpar_outfiles pffset pffrotset pffsetdir gridff_mode wstk

	set doit 0
	if {$n == 0} {
		if {[info exists pffsetdir] && ([string length $pffsetdir] > 0)} {
			if {![file exists $pffsetdir] || ![file isdirectory $pffsetdir]} {
				Inf "Directory Specified For Filter Files Does Not Exist"
				return
			}
			set pfdirname $pffsetdir
		}
		if {![info exists pff_list_list]} {
			Block "Finding Listings of Filter Files"
			set doit 1
		} else {
			set msg "Search For Further Files ?"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "yes"} {
				catch  {unset pff_list_list}
				Block "Finding Further Listings of Filter Files"
				set doit 1
			}
		}
	} else {
		if {![info exists pff_list]} {
			Block "Finding Filter Files"
			set doit 1
		}
	}
	if {$doit} {
		foreach fnam [$wl get 0 end] {
			if {$n == 0} {
				if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
					continue
				}
				if {[IsAListofNumbers $pa($fnam,$evv(FTYP))]} {
					continue
				}
				if [catch {open $fnam "r"} zit] {
					continue
				}
				set OK 1
				set linecnt 0
				catch {unset pffset($fnam)}
				while {[gets $zit line] >= 0} {
					set line [string trim $line]
					if {([string length $line] <= 0) || [string match ";" [string index $line 0]]} {
						continue
					}
					set line [split $line]
					set itemcnt 0
					catch {unset ffitem}
					catch {unset rritem}
					foreach item $line {
						if {[string length $item] <= 0} {
							continue
						}
						if {$itemcnt == 0} {
							set ffitem $item
						} elseif {$itemcnt == 1} {
							set rritem $item
							if {![IsNumeric $rritem]} {
								set OK 0
								break
							}
						} 
						incr itemcnt
					}
					if {!$OK || ($itemcnt < 1) || ($itemcnt > 2)} {
						set OK 0
						break
					}
					if {$linecnt == 0} {
						set item_cnt $itemcnt
					} elseif {$item_cnt != $itemcnt} {
						set OK 0
						break
					}						
					if {[info exists pfdirname]} {
						set ffitem [file join $pfdirname [file tail $ffitem]]
					}
					if {![file exists $ffitem]} {
						set OK 0
						break
					}
					if {$itemcnt == 2} {
						lappend pffrotset($fnam) $rritem
					}
					lappend pffset($fnam) $ffitem
					incr linecnt
				}
				close $zit
				if {$OK && [info exists pffset($fnam)] && ([llength $pffset($fnam)] == $fpar_outfiles)} {
					set OK 1
					foreach zfnam $pffset($fnam) {
						if {![IsAMidiVaribankFile $zfnam]} {
							set OK 0
							break
						}
					}
					if {$OK} {
						lappend pff_list_list $fnam
					} else {
						catch {unset pffset($fnam)}
						catch {unset pffrotset($fnam)}
					}
				}
			} else {
				if {[IsAMidiVaribankFile $fnam]} {
					lappend pff_list $fnam
				}
			}
		}
		UnBlock
	}
	if {($n == 0) && ![info exists pff_list_list]} {
		Inf "There Are No Appropriate Files On The Workspace"
		return
	}
	if {($n != 0) && ![info exists pff_list]} {
		Inf "There Are No Appropriate Files On The Workspace"
		return
	}
	set f .pfffiles	
	if [Dlg_Create $f "GET FILTER FILE" "set pr_pfffiles 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		button $f0.ok -text "Select" -command "set pr_pfffiles 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_pfffiles 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.tit -text "Possible Filter Files" -fg $evv(SPECIAL)
		Scrolled_Listbox $f1.ll -width 120 -height 24 -selectmode single
		pack $f1.tit $f1.ll -side top -pady 2
		pack $f1 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_pfffiles 0}
		bind $f <Return> {set pr_pfffiles 1}
	}
	$f.1.ll.list delete 0 end
	if {$n == 0} {
		wm title $f "GET FILTER LISTINGS FILE"
		foreach fnam $pff_list_list {
			$f.1.ll.list insert end $fnam
		}
	} else {
		wm title $f "GET FILTER FILE $n"
		foreach fnam $pff_list {
			$f.1.ll.list insert end $fnam
		}
	}
	set pr_pfffiles 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_pfffiles $f.1.ll.list
	while {!$finished} {
		tkwait variable pr_pfffiles
		if {$pr_pfffiles} {
			set i [$f.1.ll.list curselection]
			if {$i < 0} {
				Inf "No File Selected"
				continue
			}
			if {$n > 0} {
				set gridff_ffile($n) [$f.1.ll.list get $i]
			} else {
				set listfnam [$f.1.ll.list get $i]
				set m 0
				set k 1
				while {$k <= $fpar_outfiles} {
					set zfnam [lindex $pffset($listfnam) $m]
					set gridff_ffile($k) $zfnam
					incr k
					incr m
				}
				if {[info exists pffrotset($listfnam)]} {
					set gridff_mode 2
					GridffMode
					set m 0
					set k 1
					while {$k <= $fpar_outfiles} {
						set gridff_speed($k) [lindex $pffrotset($listfnam) $m]
						incr k
						incr m
					}
				} else {
					set gridff_mode 1
					GridffMode
					set k 1
					while {$k <= $fpar_outfiles} {
						set gridff_speed($k) ""
						incr k
					}
				}
			}
			set finished 1
		} else {
			set finished 1
		}
	}
	update idletasks
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc IsAMidiVaribankFile {fnam} {
	global evv pa
	if {![IsAListofNumbers $pa($fnam,$evv(FTYP))]} {
		return 0
	}
	if [catch {open $fnam "r"} zit] {
		return 0
	}
	set OK 1
	set linecnt 0
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {([string length $line] <= 0) || [string match ";" [string index $line 0]]} {
			continue
		}
		set line [split $line]
		set itemcnt 0
		foreach item $line {
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item]} {	;#	SAFETY ONLY	
				close $zit
				return 0
			}
			if {$itemcnt == 0} {			;#	Times
				if {$linecnt == 0} {		
					if {$item != 0.0} {
						close $zit
						return 0
					}
				} else {
					if {$item <= $lasttime} {
						close $zit
						return 0
					}
				}
				set lasttime $item

			} elseif {[IsEven $itemcnt]} {	;#	Amplitudes
				if {($item < 0.0) || ($item > 1.0)} {
					close $zit
					return 0
				}
			} else {						;#	MIDI pitches		
				if {($item < 0) || ($item > 127)} {
					close $zit
					return 0
				}
			}
			incr itemcnt
		}
		if {$linecnt == 0} {
			if {[IsEven $itemcnt] || ($itemcnt < 3)} {		;#	Must be odd no of entries per line
				close $zit
				return 0
			} else {
				set item_cnt $itemcnt
			}
		} else {
			if {$item_cnt != $itemcnt} {	;#	all lines must have = number of entries
				close $zit
				return 0
			}
		}
		incr linecnt
	}
	close $zit
	return 1
}

proc HelpPFF {} {

	set msg "FILTER PARTITIONED INFILES, AND REMIX\n"
	append msg "\n"
	append msg "Assumes your input is a set of files created\n"
	append msg "from a partition-to-grid process either from\n"
	append msg "the Enveloping menu, or the edit menu\n"
	append msg "(but this is not mandatory).\n"
	append msg "\n"
	append msg "Takes a set of MONO input files,\n"
	append msg "filters each with an (optionally) different varibank filter,\n"
	append msg "and remixes the outputs to a multichannel file\n"
	append msg "with one input file to each channel of the output.\n"
	append msg "\n"
	append msg "Alternatively, the filtered input files may be\n"
	append msg "rotated at (optionally) different speeds\n"
	append msg "before remixing to the multichannel output.\n"
	append msg "\n"
	append msg "Begin by selecting either \"Stationary\" or \"Rotating\" Mix.\n"
	append msg "\n"
	append msg "The filter-data must use MIDI (not frq) values\n"
	append msg "(which may be fractional)\n"
	append msg "and is entered (in the numbered boxes) either\n"
	append msg "(1)  as text, OR\n"
	append msg "(2)  by calling up a listing of potential files on the workspace\n"
	append msg "           with the appropriate \"Get File\" button,\n"
	append msg "           and selecting the required file with the mouse, OR\n"
	append msg "(3)  by calling up a LIST of the filter-data files you will use\n"
	append msg "           and which you have previously stored in a named textfile.\n"
	append msg "           This can be done using the \"Get\" button\n"
	append msg "           at the top of the display.\n"
	append msg "           If the filter files in the listing\n"
	append msg "           have subsequently been moved to a new directory,\n"
	append msg "           the new directory name can be entered in the box\n"
	append msg "           at the top of the display.\n"
	append msg "\n"
	append msg "A complete list of filter files which you have entered in the boxes\n"
	append msg "(and the rotation speeds, if any) can be saved to a LISTING file\n"
	append msg "using the \"Save\" button at the top of the screen.\n"
	append msg "\n"
	append msg "Rotation speeds can be entered for each filtered file.\n"
 	append msg "On pressing the \"Rotating mix\" option,\n"
 	append msg "extra boxes will appear on the screen, to the right of the numbers.\n"
 	append msg "Rotation speeds (complete cycles per second) can then be entered.\n"
 	append msg "Anticlockwise rotation can be indicated by a negative value.\n"
	append msg "\n"
	append msg "This process was originally designed to apply to sounds that had been\n"
	append msg "partitioned into a set of disjunct grids\n"
	append msg "(See EDIT OPTIONS on the MUSIC TESTBED).\n"
	append msg "\n"
	Inf $msg
}

#---- Takes a sound, transposes it to the N values given in a pattern, and outputs event sequence
#---- Then time-contracts that event by 1/N and does same again
#---- The transpositions are (possibly) reduced on each fractal pass
#---- When fractal subobjects <= 1026 samples, halts.

############
# FRACTALS #
############

#---- Takes a sound, transposes it to the N values given in a pattern, and outputs event sequence
#---- Then time-contracts that event by 1/N and does same again
#---- When fractal subobjects <= 128 samples, halts.

proc Fractals {} {
	global pr_fractal fractalp fractal_fnam fracscaler fracdovetail fracdovetailp fracrand
	global prg_dun prg_abortd simple_program_messages CDPidrun chlist pa evv wstk
	global fracsnd fracin fracout fracsil fracsil2 fracoutandsil fracinandsil fracoutana fracoutandsilana 
	global file exists fracpredove fracinandsilana fracanaltransana fracmix
	global notransposwarning fractimeratio fracdur fracsrate fraccnt fractrans fracfmnts fraclimit

	set evv(FRACSILDUR) 0.2 ;# amount of silence appended to file to be analysed - duration AFTER it's time-squeezed!!
	set evv(FRACDOVETAIL) 6  ;# mS

	if {![info exists chlist] || ([llength $chlist] != 1)} {
		Inf "Select A Single Mono Soundfile"	
		return
	}
	set fnam [lindex $chlist 0]
	if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 1)} {
		Inf "Select A Single Mono Soundfile"	
		return
	}
	DeleteAllTemporaryFiles
	set nam $evv(DFLT_OUTNAME)
	set fracin $nam
	append fracin 0 $evv(SNDFILE_EXT)
	set n 1
	while {$n <= 16} {
		set fracsnd($n) $nam
		append fracsnd($n) $n $evv(SNDFILE_EXT)
		incr n
	}
	set fracout $nam
	append fracout $n $evv(SNDFILE_EXT)
	incr n
	set fracsil $nam
	append fracsil $n $evv(SNDFILE_EXT)
	incr n
	set fracsil2 $nam
	append fracsil2 $n $evv(SNDFILE_EXT)
	incr n
	set fracoutandsil $nam
	append fracoutandsil $n $evv(SNDFILE_EXT)
	set fracinandsil $fracoutandsil
	incr n
	set fracpredove $nam
	append fracpredove $n $evv(SNDFILE_EXT)
	incr n

	set fracmix $nam
	append fracmix 0 ".mix"

	set n 0
	set nam $evv(MACH_OUTFNAME)
	set fracoutana $nam
	append fracoutana $n $evv(ANALFILE_EXT)
	incr n
	set fracoutandsilana $nam
	append fracoutandsilana $n $evv(ANALFILE_EXT)
	set fracinandsilana $fracoutandsilana
	incr n
	set fracanaltransana $nam
	append fracanaltransana $n $evv(ANALFILE_EXT)
	incr n

	set n 1
	while {$n <= 16} {
		set fractalp($n) ""
		incr n
	}
	set f .fractals
	if [Dlg_Create $f "CREATE FRACTAL VERSIONS OF A SOUND" "set pr_fractal 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.hh -text "Help" -command "HelpFrac" -bg $evv(HELP) -highlightbackground [option get . background {}]
		button $f0.ok -text "Make Fractals" -command "set pr_fractal 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.save -text "Save Params" -command "set pr_fractal 2"  -highlightbackground [option get . background {}]
		button $f0.load -text "Load Params" -command "set pr_fractal 3"  -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_fractal 0" -highlightbackground [option get . background {}]
		pack $f0.hh $f0.ok $f0.save $f0.load -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		set n 1
		while {$n <= 16} {
			frame $f1.$n
			label $f1.$n.ll -text "transposition $n" -width 20
			entry $f1.$n.e -textvariable fractalp($n) -width 6
			button $f1.$n.b -text "Clear $n" -width 8 -command "ClearFracParam $n" -highlightbackground [option get . background {}]
			if {$n == 1} {
				button $f1.$n.clear -text "Clear All Transpositions" -command "ClearFracParam 0" -highlightbackground [option get . background {}]
				pack $f1.$n.e $f1.$n.ll $f1.$n.b $f1.$n.clear -side left
			} elseif {$n == 2} {
				checkbutton $f1.$n.ch -variable fracfmnts -text "Keep Formants"
				set fracfmnts 0
				pack $f1.$n.e $f1.$n.ll $f1.$n.b $f1.$n.ch -side left
			} else {
				pack $f1.$n.e $f1.$n.ll $f1.$n.b -side left
			}
			pack $f1.$n -side top -fill x -expand true -pady 1
			incr n
		}
		pack $f1 -side top -fill x -expand true
		label $f2.ll -text "transpos scale factor"
		entry $f2.e -textvariable fracscaler -width 4
		label $f2.ll2 -text "dovetail (mS)"
		entry $f2.e2 -textvariable fracdovetailp -width 4
		label $f2.ll3 -text "Randomise element time"
		entry $f2.e3 -textvariable fracrand -width 4
		set fracrand 0
		set fracdovetailp $evv(FRACDOVETAIL)
		pack $f2.e $f2.ll $f2.e2 $f2.ll2 $f2.e3 $f2.ll3 -side left -fill x -expand true -padx 2
		pack $f2 -side top -pady 2
		pack $f2 -side top -fill x -expand true
		label $f3.ll -text "Output filename "
		entry $f3.e -textvariable fractal_fnam -width 16
		pack $f3.ll $f3.e -side left
		pack $f3 -side top -pady 2
		bind $f <Escape> {set pr_fractal 0}
		bind $f <Return> {set pr_fractal 1}
		set m 16
		set n 1
		set j 2
		while {$n <= 16} {
			bind $f1.$n.e <Up> "focus $f1.$m.e"
			bind $f1.$n.e <Down> "focus $f1.$j.e"
			incr m
			if {$m > 16} {
				set m 1
			}
			incr j
			if {$j > 16} {
				set j 1
			}
			incr n
		}
		wm resizable $f 1 1
	}
	set pr_fractal 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_fractal $f.1.1.e
	while {!$finished} {
		DeleteAllTemporaryFiles
		catch {unset notransposwarning}
		tkwait variable pr_fractal
		switch -- $pr_fractal {
			1 -
			2 {
				;#	CHECK PARAMETERS
				set n 1
				set OK 1
				set valcnt 0
				while {$n <= 16} {
					set fractalp($n) [string trim $fractalp($n)]
					if {[string length $fractalp($n)] <= 0} {
						if {$valcnt == 0} {
							set valcnt [expr $n - 1]
							if {$valcnt <= 0} {
								Inf "No First Value Entered"
								set OK 0
								break
							}
						}
						incr n
						continue
					} elseif {$valcnt} {
						Inf "Value Entered Beyond First Empty Value\nEnter Values In Order From First Box"
						set OK 0
						break
					} elseif {![IsNumeric $fractalp($n)] || ($fractalp($n) < -24) || ($fractalp($n) > 24)} {
						Inf "Transposition $n Invalid Or Out Of Range (-24 to 24 semitones)"
						set OK 0
						break
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				set fractimeratio [expr 1.0 / $valcnt]
				if {![IsNumeric $fracscaler] || ($fracscaler < 0)} {
					Inf "Invalid Transposition Scale Factor Range (>=0)"
					continue
				}
				if {![IsNumeric $fracdovetailp] || ($fracdovetailp < 3)} {
					Inf "Invalid Dovetail (>=3 mS)"
					continue
				}
				if {![IsNumeric $fracrand] || ($fracrand < 0) || ($fracrand > 1)} {
					Inf "Randomisation Invalid (Range 0 - 1)"
					continue
				}
				if {$pr_fractal == 2} {
					SaveFractalParams $valcnt
					continue
				}
				set fracdovetail [expr $fracdovetailp * $evv(MS_TO_SECS)]
				if {[string length $fractal_fnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $fractal_fnam]} {
					continue
				}
				set outfnam [string tolower $fractal_fnam]
				set samplecnt $pa($fnam,$evv(INSAMS))
				set fracsrate $pa($fnam,$evv(SRATE))
				set fraclimit [expr int(ceil(double($fracsrate) * $fracdovetail))]
				set fracdur $pa($fnam,$evv(DUR))
				set outfraccnt 1
				set mindur $fraclimit
				while {$samplecnt > $mindur} {
					set samplecnt [expr int(round(double($samplecnt) * $fractimeratio))]
					incr outfraccnt
				}
				set OK 1
				set n 1
				while {$n < $outfraccnt} {
					set thisoutfnam $outfnam 
					append thisoutfnam $n
					append thisoutfnam ".wav"
					if {[file exists $thisoutfnam]} {
						set msg "A File With The Name $thisoutfnam Already Exists\n\n"
						append msg "Please Choose A Different Generic Name"
						Inf $msg
						set OK 0
						break
					}
					incr n
				}
				if {!$OK} {
					continue
				}
				;#	DO PROCESSING
				if {[file exists $fracin]} {
					if [catch {file delete $fracin} zit] {
						Inf "Failed To Delete Temporary File '$fracin'"
						return 0
					}
				}
				if [catch {file copy $fnam $fracin} zit] {
					Inf "Cannot Make Initial Copy Of Input File, To Make Fractals"
					continue
				}
				Block "CREATING FRACTALS"
				if {![SynthSilFrac2]} {
					UnBlock
					continue
				}
				set done 0
				set fraccnt 0
				set tsqueeze 1
				while {!$done} {

					;#	BREAK OUT OF LOOP WHEN TIME-SQUEEZED SOUND WOULD BE TOO SHORT

					if {[expr int(floor(double($samplecnt) * $tsqueeze))] <= $fraclimit} {
						break
					}

					;#	DERIVE FROM timesqueeze VALUE FOR THIS FRACTAL, SCALING OF TRANSPOSITION VALUES

					set transposscaling [expr 1.0 - ($fracscaler * (1.0 - $tsqueeze))]
					if {$transposscaling <= 0.0} {
						if {![info exists notransposwarning]} {
							Inf "Transposition Reached Zero"
							set transposscaling 0.0
							set notransposwarning 1
						}
					}

					;#	SCALING ALL TRANSPOSITION VALUES FOR THIS FRACTAL

					set n 1
					while {$n <= $valcnt} {
						set fractrans($n) [expr double($fractalp($n)) * $transposscaling]
						incr n
					}

					;#	TIMESQUEEZE THE SOURCE FOR MAKING THIS FRACTAL

					if {![FractalTimeSqueeze $tsqueeze]} {
						break
					}
					set tshrinksteps $fraccnt
					set pass 1
					set OK 1
					while {$tshrinksteps >= 0} {
						if {![FractalTransposeJoin $tshrinksteps $pass $valcnt]} {
							set OK 0
							break
						}
						incr tshrinksteps -1
						incr pass
					}
					if {!$OK} {
						break
					}
					incr fraccnt
					set thisoutfnam $outfnam 
					append thisoutfnam $fraccnt
					append thisoutfnam ".wav"
					if [catch {file rename $fracout $thisoutfnam} zit] {
						Inf "Cannot Rename Temporary Output File $fracout To $thisoutfnam: Halting"
						break
					}
					FileToWkspace $thisoutfnam 0 0 0 0 1
					set tsqueeze [expr $tsqueeze * $fractimeratio]
				}
				UnBlock
				if {$fraccnt == 0} {
					Inf "No Fractals Generated"
					continue
				}
				Inf "Generated $fraccnt Output Fractals"
				set finished 1
			} 3 {
				LoadFractalParams
				continue
			} 0 {
				set finished 1
			}
		}
		DeleteAllTemporaryFiles
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc ClearFracParam {n} {
	global fractalp
	if {$n == 0} {
		incr n
		while {$n <= 16} {
			set fractalp($n) ""
			incr n
		}
	} else {
		set fractalp($n) ""
	}
}

proc HelpFrac {} {
	set msg "GENERATING FRACTALS\n"
	append msg "\n"
	append msg "The (semitone) transposition values\n"
	append msg "are used to make a sequence of copies\n"
	append msg "of the source, transposed by these amounts.\n"
	append msg "\n"
	append msg "These are then joined together to make the base unit.\n"
	append msg "\n"
	append msg "The base unit is then timeshrunk to the duration of the source\n"
	append msg "and the same process repeated, to produce the first fractal.\n"
	append msg "\n"
	append msg "This process is repeated to make fractals of increasingly\n"
	append msg "greater detail. The process stops when the details hit\n"
	append msg "a minimum size limit.\n"
	append msg "\n"
	append msg "The \"transposition scale factor\" scales the transpositions\n"
	append msg "from one fractal to the next.\n"
	append msg "Values can be\n"
	append msg "0 - the transpositions are the same at all fractal levels.\n"
	append msg "1 - the transpositions are reduced by the same factor as the timeshrinkage.\n"
	append msg "         e.g.with 3 transposition values,\n"
	append msg "         For the 1st fractal, timeshrinkage is 1/3\n"
	append msg "         and transpositions are reduced to 1/3 of the given values\n"
	append msg "         For the 2nd fractal, timeshrinkage is 1/3 * 1/3 = 1/9\n"
	append msg "         and transpositions are reduced to 1/9 of the given values\n"
	append msg "         and so on.\n"
	append msg "\n"
	append msg "Intermediate values reduce transposition by intermediate amounts\n"
	append msg "\n"
	append msg "2 - the transpositions are reduced by double the timeshrinkage.\n"
	append msg "         and so on for larger values.\n"
	append msg "         and so on.\n"
	append msg "\n"
	append msg "The \"dovetail\" is used to trim the start of transposed or timeshrunk spectra\n"
	append msg "to avoid clicks in the output.\n"
	append msg "\n"
	append msg "The dovetail length determines the minimum size of the smallest element of a fractal,\n"
	append msg "and hence how many fractal outputs are produced.\n"
	Inf $msg
}

#----- Timesqueeze the source for the current fractal level

proc FractalTimeSqueeze {tsq} {
	global fracin fracout fraccnt
	wm title .blocker "PLEASE WAIT:        TIMESHRINK FOR FRACTAL $fraccnt "
	if {$tsq == 1} {
		if {[file exists $fracout]} {
			if [catch {file delete $fracout} zit] {
				Inf "Failed To Delete Temporary File $fracout (To Use For Timeshrunk Output)"
				return 0
			}
		}
		if [catch {file copy $fracin $fracout} zit] {
			Inf "Cannot Create Timeshrunk File $fraccnt For Fractal $fraccnt"
			return 0
		}
	} else {
		if {![SynthFracSil $tsq]} {
			return 0					
		}
		if {![FracShrunkSilJoin]} {
			return 0
		}
		if {![FracTimeshrink $tsq]} {
			return 0
		}
	}
	return 1
}

#--- synthesize silent file "fracsil" to append to end of file to be analysed to avoid clipping end on resynth
#--- Must be appropriate length ~AFTER~ timeshrinking

proc SynthFracSil {tsq} {
	global fracsil fraccnt fracsrate
	global prg_dun prg_abortd simple_program_messages CDPidrun evv 

	if {[file exists $fracsil]} {
		if [catch {file delete $fracsil} zit] {
			Inf "Failed To Delete Temporary Silent File $fracsil For Fractal $fraccnt"
			return 0
		}
	}

	;# SILENCE MUST BE OF SUCH A LENGTH THAT, WHEN TIMESHRUNK, IT IS evv(FRACSILDUR) IN LENGTH

	set sildur [expr $evv(FRACSILDUR) * (1.0/$tsq)]
	
	set cmd [file join $evv(CDPROGRAM_DIR) synth]
	lappend cmd silence $fracsil $fracsrate 1 $sildur
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt TIMESHRINK: GENERATING SILENCE"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Generate Silent File For Fractal $fraccnt : $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Generate Silent File For Fractal $fraccnt Timeshrink:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracsil]} {
		set msg "Silent File Not Generated For Fractal $fraccnt Timeshrink:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	return 1
}

#----- Join silent file "fracsil" on end of "fracin" with zero splice, to make "fracinandsil"

proc FracShrunkSilJoin {} {
	global fracin fracsil fracinandsil fraccnt
	global prg_dun prg_abortd simple_program_messages CDPidrun evv 

	if {[file exists $fracinandsil]} {
		if [catch {file delete $fracinandsil} zit] {
			Inf "Cannot Delete Previous Silence Extended File $fracinandsil, For Fractal $fraccnt"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
	lappend cmd join $fracin $fracsil $fracinandsil -w0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt: ADDING SILENT TAIL"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Add Silent Tail, For Fractal $fraccnt: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Add Silent Tail, For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracinandsil]} {
		set msg "Silent Tail Not Added, For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	return 1
}

#---- Do timeshrinking of silence extended source "fracinandsil", for current fractal level

proc FracTimeshrink {tsq} {
	global fracinandsil fracinandsilana fracoutana fracout fracpredove fraccnt fracdovetail
	global prg_dun prg_abortd simple_program_messages CDPidrun evv 

	if {[file exists $fracinandsilana]} {
		if [catch {file delete $fracinandsilana} zit] {
			Inf "Cannot Delete Previous Silence Extended Analysis File $fracinandsilana"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd anal 1 $fracinandsil $fracinandsilana -c1024 -o3
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt ANALYSIS FOR TIMESHRINK"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Do Analysis For Timeshrink  For Fractal $fraccnt: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Do Analysis For Timeshrink For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracinandsilana]} {
		set msg "Analysis For Timeshrink Failed For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}

	if {[file exists $fracoutana]} {
		if [catch {file delete $fracoutana} zit] {
			Inf "Cannot Delete Previous Timeshrunk Analysis File $fracoutana, For Fractal $fraccnt"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) stretch]
	lappend cmd time 1 $fracinandsilana $fracoutana $tsq 
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt TIMESHRINKING BY $tsq"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Generate Timeshrunk File, For Fractal $fraccnt: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Do Timeshrinking, For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracoutana]} {
		set msg "Timeshrinking Failed, For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}

	if {[file exists $fracpredove]} {
		if [catch {file delete $fracpredove} zit] {
			Inf "Cannot Delete Previous Timeshrunk Soundfile $fracpredove"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd synth $fracoutana $fracpredove
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt TIMESHRINK RESYNTH"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Generate Resynth Timeshrunk File For Fractal $fraccnt: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Do Timeshrink Resynth For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracpredove]} {
		set msg "Timeshrink Resynth Failed For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}

	if {[file exists $fracout]} {
		if [catch {file delete $fracout} zit] {
			Inf "Cannot Delete Previous Dovetailed Shrunk Soundfile $fracout"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) envel]
	lappend cmd dovetail 1 $fracpredove $fracout $fracdovetail 0 0 0 -t0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt TIMESHRINK DOVETAIL"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Dovetail Timeshrunk File For Fractal $fraccnt: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Do Dovetail Resynth For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracout]} {
		set msg "Dovetail Resynth Failed For Fractal $fraccnt:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	return 1
}

#---- Synth silence to add to tail of sounds to be transposed, to avoid clicks on tail in resynth

proc SynthSilFrac2 {} {
	global fracsil2 fracsrate evv
	global prg_dun prg_abortd simple_program_messages CDPidrun evv 

	if {[file exists $fracsil2]} {
		if [catch {file delete $fracsil2} zit] {
			Inf "Cannot Delete Previous Silent Soundfile $fracsil2"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) synth]
	lappend cmd silence $fracsil2 $fracsrate 1 $evv(FRACSILDUR)
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        GENERATING SILENCE"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Generate Silent File: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Generate Silent File:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracsil2]} {
		set msg "Silent File Not Generated:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	return 1
}

#--- Transpose (timeshrunk) source to various pitches, and join outputs in sequence

proc FractalTransposeJoin {tshrinksteps pass valcnt} {
	global fraccnt fracoutandsil fracoutandsilana fracpredove fracout fracsil2 fracsnd fractrans fracrand 
	global fracanaltransana fracmix fracdur fractimeratio fracfmnts fracdovetail
	global prg_dun prg_abortd simple_program_messages CDPidrun evv 

	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt PASS $pass OF $fraccnt"

	;#	ADD SILENCE TO END OF FILE

	if {[file exists $fracoutandsil]} {
		if [catch {file delete $fracoutandsil} zit] {
			Inf "Cannot Delete Silence-extended File $fracoutandsil"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
	lappend cmd join $fracout $fracsil2 $fracoutandsil -w0
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt PASS $pass TRANSPOSITION: ADDING SILENT TAIL"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Add Silent Tail: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Add Silent Tail For Fractal $fraccnt Pass $pass:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracoutandsil]} {
		set msg "Silent Tail Not Added For Fractal $fraccnt Pass $pass:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}

	;#	ANALYSE SILENCE-EXTENDED FILE

	if {[file exists $fracoutandsilana]} {
		if [catch {file delete $fracoutandsilana} zit] {
			Inf "Cannot Delete Silence-Extended Analysis File $fracoutandsilana"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
	lappend cmd anal 1 $fracoutandsil $fracoutandsilana -c1024 -o3
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt PASS $pass TRANSPOSITION: ANALYSIS"
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Analyse Shrunk File: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Analyse File For Transposition, Fractal $fraccnt Pass $pass:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracoutandsilana]} {
		set msg "File For Transposition Not Analysed, Fractal $fraccnt Pass $pass:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}

	;#	TRANSPOSE ANALYSIS FILE (OR DO COPY)

	set n 1
	while {$n <= $valcnt} {
		wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt TRANSPOSE $n IN PASS $pass OF $fraccnt"
		if {[file exists $fracsnd($n)]} {
			if [catch {file delete $fracsnd($n)} zit] {
				Inf "Cannot Delete Previous Transposed File $fracsnd($n)"
				return 0
			}
		}
		set gotit 0
		if {$fractrans($n) == 0} {
			if [catch {file copy $fracout $fracsnd($n)} zit] {
				Inf "Failed To Make Copy For Transposition $n"
				return 0
			}
			set gotit 1
		} else {
			if {$n > 1} {
				set k 1
				while {$k < $n} {
					if {$fractrans($n) == $fractrans($k)} {
						if [catch {file copy $fracsnd($k) $fracsnd($n)} zit] {
							Inf "Failed To Make Copy For Transposition $n"
							return 0
						}
						set gotit 1
						break
					}
					incr k
				}
			}
		}
		if {$gotit} {
			incr n
			continue
		}
		if {[file exists $fracanaltransana]} {
			if [catch {file delete $fracanaltransana} zit] {
				Inf "Cannot Delete Transposed Analysis File $fracanaltransana"
				return 0
			}
		}

		set cmd [file join $evv(CDPROGRAM_DIR) repitch]
		if {$fracfmnts} {
			lappend cmd transposef 3 $fracoutandsilana $fracanaltransana -p4 $fractrans($n)
		} else {
			lappend cmd transpose  3 $fracoutandsilana $fracanaltransana $fractrans($n)
		}
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "Cannot Do Transpose File $n For Fractal $fraccnt Pass $pass:"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Failed In Transpose $n File For Fractal $fraccnt Pass $pass:"
			set msg [AddSimpleMessages $msg]
			Inf $msg
			return 0
		}
		if {![file exists $fracanaltransana]} {
			set msg "Transposition $n Failed For Fractal $fraccnt Pass $pass:"
			set msg [AddSimpleMessages $msg]
			Inf $msg
			return 0
		}

		;#	RESYNTHESIZE TRANSPOSED FILE

		if {[file exists $fracpredove]} {
			if [catch {file delete $fracpredove} zit] {
				Inf "Cannot Delete Previous Timeshrunk Soundfile $fracpredove"
				return 0
			}
		}
		set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
		lappend cmd synth $fracanaltransana $fracpredove
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "cannot Resynthesize Transposed File $n For Fractal $fraccnt Pass $pass: $CDPidrun"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Failed To Resynthesize Transposed File $n For Fractal $fraccnt Pass $pass:"
			set msg [AddSimpleMessages $msg]
			Inf $msg
			return 0
		}
		if {![file exists $fracpredove]} {
			set msg "Resynthesis Of Transposed File $n Failed For Fractal $fraccnt Pass $pass"
			set msg [AddSimpleMessages $msg]
			Inf $msg
			return 0
		}

		;#	DOVETAIL TRANSPOSED FILES
		set cmd [file join $evv(CDPROGRAM_DIR) envel]
		lappend cmd dovetail 1 $fracpredove $fracsnd($n) $fracdovetail 0.0 1 1 -t0
		set prg_dun 0
		set prg_abortd 0
		catch {unset simple_program_messages}
		if [catch {open "|$cmd"} CDPidrun] {
			Inf "Cannot Dovetail Transposed File $n For Fractal $fraccnt Pass $pass: $CDPidrun"
			catch {unset CDPidrun}
			return 0
		} else {
			fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
		}
		vwait prg_dun
		if {$prg_abortd} {
			set prg_dun 0
		}
		if {!$prg_dun} {
			set msg "Failed To Dovetail Transposed File $n For Fractal $fraccnt Pass $pass:"
			set msg [AddSimpleMessages $msg]
			Inf $msg
			return 0
		}
		if {![file exists $fracsnd($n)]} {
			set msg "Dovetailing Of Transposed File $n Failed For Fractal $fraccnt Pass $pass"
			set msg [AddSimpleMessages $msg]
			Inf $msg
			return 0
		}
		incr n
	}

	;#	JOIN TOGETHER TRANSPOSED FILES

	wm title .blocker "PLEASE WAIT:        FRACTAL $fraccnt JOINING TRANSPOSITIONS IN PASS $pass"
	if [catch {open $fracmix "w"} zit] {
		Inf "Cannot Open Mixfile $fracmix To Join Components For Fractal $fraccnt Pass $pass"
		return 0
	}
	set timestep $fracdur
	set n 0
	while {$n < $tshrinksteps} {
		set timestep [expr $timestep * $fractimeratio]
		incr n
	}
	if {$fracrand > 0.0} {
		set timerand [expr $timestep * $fracrand]
	}
	set n 1
	set time 0.0
	while {$n <= $valcnt} {
		set line $fracsnd($n)
		lappend line $time 1 1
		if {($n > 1) && ($fracrand > 0.0)} {
			set time $origtime
		}
		puts $zit $line
		set time [expr $time + $timestep]
		if {($n > 0) && ($fracrand > 0.0)} {
			set origtime $time
			set randoffset [expr (rand() * $timerand) - ($timerand/2.0)]
			set time [expr $time + $randoffset]
		}
		incr n
	}
	close $zit
	if {[file exists $fracout]} {
		if [catch {file delete $fracout} zit] {
			Inf "Cannot Delete Previous Fractal Output File $fracout"
			return 0
		}
	}
	set cmd [file join $evv(CDPROGRAM_DIR) submix]
	lappend cmd mix $fracmix $fracout
	set prg_dun 0
	set prg_abortd 0
	catch {unset simple_program_messages}
	if [catch {open "|$cmd"} CDPidrun] {
		Inf "Cannot Mix Transposed Files For Fractal $fraccnt Pass $pass: $CDPidrun"
		catch {unset CDPidrun}
		return 0
	} else {
		fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
	}
	vwait prg_dun
	if {$prg_abortd} {
		set prg_dun 0
	}
	if {!$prg_dun} {
		set msg "Failed To Mix Transposed Files For Fractal $fraccnt Pass $pass:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	if {![file exists $fracout]} {
		set msg "Mixing Transposed Files Failed For Fractal $fraccnt Pass $pass:"
		set msg [AddSimpleMessages $msg]
		Inf $msg
		return 0
	}
	return 1
}

proc SaveFractalParams {valcnt} {
	global fractalp fracscaler fracdovetailp fracrand pr_fracstore fracstornam evv
	set transpi {}
	set n 1
	while {$n <= $valcnt} {
		lappend transpi $fractalp($n)
		incr n
	}
	set storestr [list $transpi $fracscaler $fracdovetailp $fracrand]
	set f .fracstore
	if [Dlg_Create $f "STORE FRACTAL PARAMS" "set pr_fracstore 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		button $f0.ok -text "Store" -command "set pr_fracstore 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_fracstore 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Store Filename"
		entry $f1.e -textvariable fracstornam -width 24
		pack $f1.e $f1.ll -side top -pady 2
		pack $f1 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_fracstore 0}
		bind $f <Return> {set pr_fracstore 1}
	}
	set pr_fracstore 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_fracstore $f.1.e
	while {!$finished} {
		tkwait variable pr_fracstore
		if {$pr_fracstore} {
			if {[string length $fracstornam] <= 0} {
				Inf "No Storage-File Name Entered"
				continue
			}
			if {![ValidCDPRootname $fracstornam]} {
				continue
			}
			set fnam [string tolower $fracstornam]
			append fnam "_frac"
			set fnam [file join $evv(URES_DIR) $fnam$evv(CDP_EXT)]
			if {[file exists $fnam]} {
				Inf "File $fracstornam Already Exists: Please Choose A Different Name"
				continue
			}
			if [catch {open $fnam "w"} zit] {
				Inf "Cannot Open File $fnam To Store Your Data"
				continue
			}
			puts $zit $storestr
			close $zit
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc LoadFractalParams {} {
	global fractalp fracscaler fracdovetailp fracrand pr_fracload wstk fracstorenams evv
	catch {unset fracstorenams}
	foreach fnam [glob -nocomplain [file join $evv(URES_DIR) *]] {
		set ext [file extension $fnam]
		if {![string match $ext $evv(CDP_EXT)]} {
			continue
		}
		set nam [file rootname [file tail $fnam]]
		set len [string length $nam]
		if {$len < 6} {
			continue
		}
		incr len -1
		set stt [expr $len - 4]
		set endnam [string range $nam $stt $len]
		if {[string match $endnam "_frac"]} {
			incr stt -1
			set nam [string range $nam 0 $stt]
			lappend fracstorenams $nam
		}
	}
	if {![info exists fracstorenams]} {
		Inf "No Fractal Parameters Stored"
		return
	}
	set f .fracload
	if [Dlg_Create $f "LOAD FRACTAL PARAMS" "set pr_fracload 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		button $f0.ok -text "Load" -command "set pr_fracload 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.del -text "Delete" -command "set pr_fracload 2" -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_fracload 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.del -side left -pady 10
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.tit -text "Possible Fractal Params" -fg $evv(SPECIAL)
		Scrolled_Listbox $f1.ll -width 120 -height 24 -selectmode single
		pack $f1.tit $f1.ll -side top -pady 2
		pack $f1 -side top -pady 2 -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_fracload 0}
		bind $f <Return> {set pr_fracload 1}
	}
	$f.1.ll.list delete 0 end
	foreach fnam $fracstorenams {
		$f.1.ll.list insert end $fnam
	}
	set pr_fracload 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_fracload $f.1.ll.list
	while {!$finished} {
		catch {unset i}
		tkwait variable pr_fracload
		switch -- $pr_fracload {
			1 {
				if {[$f.1.ll.list index  end] == 1} {
					set i 0
				} else {
					set i [$f.1.ll.list curselection]
					if {![info exists i] || ($i < 0)} {
						Inf "No Storage File Selected"
						continue
					}
				}
				set fnam [$f.1.ll.list get $i]
				append fnam "_frac" $evv(CDP_EXT)
				set fnam [file join $evv(URES_DIR) $fnam]
				if {![file exists $fnam]} {
					Inf "File $fnam Does Not Exist"
					$f.1.ll.list delete $i
					continue
				}
				if [catch {open $fnam "r"} zit] {
					Inf "Cannot Open File $fnam To Read Your Data"
					continue
				}
				if {[gets $zit line] <= 0} {
					Inf "No Data In File $fnam"
					continue
				}
				close $zit
				set len [llength $line]
				if {$len != 4} {
					Inf "Corrupted Data In This File"
					continue
				}
				set n 0
				while {$n < $len} {
					set val [lindex $line $n]
					switch -- $n {
						0 {
							set transpi [split $val]
							set tlen [llength $transpi]
							if {($tlen < 1) || ($tlen > 16)} {
								Inf "Corrupted Transposition Data In This File"
								continue
							}
							set m 1
							foreach item $transpi {
								set fractalp($m) $item
								incr m
							}
						}
						1 {
							set fracscaler $val
						}
						2 {
							set fracdovetailp $val
						}
						3 {
							set fracrand $val
						}
					}
					incr n
				}
				set finished 1
			}
			2 {
				set i [$f.1.ll.list curselection]
				if {![info exists i] || ($i < 0)} {
					Inf "No Storage File Selected"
					continue
				}
				set nam [$f.1.ll.list get $i]
				set fnam $nam
				append fnam "_frac" $evv(CDP_EXT)
				set fnam [file join $evv(URES_DIR) $fnam]
				if {![file exists $fnam]} {
					Inf "File $fnam Does Not Exist"
					continue
				}
				set msg "Are You Sure You Want To ~~Delete~~ Fractal Data $nam"
				set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				}
				if [catch {file delete $fnam} zit] {
					Inf "Cannot Delete File $fnam"
					continue
				}
				$f.1.ll.list delete $i
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#---- Create a stereo reverb-image from a stereo sound, in either stereo or 4-chan output space

proc RevStereo {} {
	global chlist wl pa evv pr_revster revster_chans prg_dun prg_abortd simple_program_messages CDPidrun
	global revster_loss revster_mult revster_gain revster_echos revster_ofnam 

	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
	} else {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
		}
	}
	if {![info exists fnam] || ($pa($fnam,$evv(CHANS)) != 2)} {
		Inf "Select One Stereo Soundfile"
		return
	}
	if {![info exists revster_chans]} {
		set revster_chans 0
	}
	if {![info exists revster_gain]} {
		set revster_gain 1
	}
	set f .revster
	if [Dlg_Create $f "CREATE STEREO REVERB" "set pr_revster 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		button $f0.ok -text "Run" -command "set pr_revster 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_revster 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		radiobutton $f1.2 -variable revster_chans -text "stereo" -value 2
		radiobutton $f1.4 -variable revster_chans -text "4-chan" -value 4
		pack $f1.2 $f1.4 -side left -padx 2
		pack $f1 -side top -pady 2 -fill x -expand true
		entry $f2.eloss -textvariable revster_loss -width 8
		label $f2.loss -text "level loss with distance (0.00003 to 1)" 
		pack $f2.eloss $f2.loss -side left
		pack $f2 -side top -fill x -expand true
		entry $f3.emult -textvariable revster_mult -width 8
		label $f3.mult -text "stadium-size multiplier (0.000005 to 100)" 
		pack $f3.emult $f3.mult -side left
		pack $f3 -side top -fill x -expand true
		entry $f4.enum -textvariable revster_echos -width 8
		label $f4.num -text "number of echos (0 - 1000)" 
		pack $f4.enum $f4.num -side left
		pack $f4 -side top -fill x -expand true
		entry $f5.egain -textvariable revster_gain -width 8
		label $f5.gain -text "mix gain (>0 to 1)" 
		pack $f5.egain $f5.gain -side left
		pack $f5 -side top -fill x -expand true
		entry $f6.enam -textvariable revster_ofnam -width 24
		label $f6.nam -text "outputfile name" 
		pack $f6.enam $f6.nam -side left
		pack $f6 -side top -fill x -expand true
		wm resizable $f 1 1
		bind $f <Escape> {set pr_revster 0}
		bind $f <Return> {set pr_revster 1}
		bind $f.2.eloss <Down> "focus $f.3.emult"
		bind $f.3.emult <Down> "focus $f.4.enum"
		bind $f.4.enum  <Down> "focus $f.5.egain"
		bind $f.5.egain <Down> "focus $f.6.enam"
		bind $f.6.enam  <Down> "focus $f.2.eloss"
		bind $f.2.eloss <Up> "focus $f.6.enam"
		bind $f.3.emult <Up> "focus $f.2.eloss"
		bind $f.4.enum  <Up> "focus $f.3.emult"
		bind $f.5.egain <Up> "focus $f.4.enum"
		bind $f.6.enam  <Up> "focus $f.5.egain"
	}
	set revsterx $evv(DFLT_OUTNAME)
	append revsterx $evv(SNDFILE_EXT)
	set revster1 $evv(DFLT_OUTNAME)
	append revster1 _c1 $evv(SNDFILE_EXT)
	set revster2 $evv(DFLT_OUTNAME)
	append revster2 _c2 $evv(SNDFILE_EXT)
	set revstermix $evv(DFLT_OUTNAME)
	set revrev1 $evv(DFLT_OUTNAME)
	append revrev1 3 $evv(SNDFILE_EXT)
	set revrev2 $evv(DFLT_OUTNAME)
	append revrev2 4 $evv(SNDFILE_EXT)
	set revstermix $evv(DFLT_OUTNAME)
	append revstermix 0
	if {$revster_chans == 4} {
		append revstermix [GetTextfileExtension mmx]
	} else {
		append revstermix [GetTextfileExtension mix]
	}
	set pr_revster 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_revster $f.2.eloss
	while {!$finished} {
		tkwait variable pr_revster
		if {$pr_revster} {
			if {$revster_chans < 2} {
				Inf "No Output Channel Count Set"
				continue
			}
			if {([string length $revster_loss] <= 0) || ![IsNumeric $revster_loss] || ($revster_loss < 0.00003) || ($revster_loss > 1)} {
				Inf "Invalid Level Loss"
				continue
			}
			if {([string length $revster_mult] <= 0) || ![IsNumeric $revster_mult] || ($revster_mult < 0.000005) || ($revster_mult > 100)} {
				Inf "Invalid Stadium Size Multiplier"
				continue
			}
			if {([string length $revster_echos] <= 0) || ![IsNumeric $revster_echos] || ($revster_echos < 2) || ($revster_echos > 1000)} {
				Inf "Invalid Number Of Echos"
				continue
			}
			if {[string length $revster_ofnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $revster_ofnam]} {
				continue
			}
			set ofnam [string tolower $revster_ofnam]
			append ofnam $evv(SNDFILE_EXT)
			if {[file exists $ofnam]} {
				Inf "File $ofnam Already Exists: Please Choose A Different Name"
				continue
			}
			DeleteAllTemporaryFiles
			if [catch {file copy $fnam $revsterx} zit] {
				Inf "Cannot Make Initial Copy Of Source File"
				contunie
			}
			Block "Extracting channels"			
			set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
			lappend cmd chans 1 $revsterx 1
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Extract Channel One From $fnam: $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Extract Channel 1 From File $fnam: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			if {![file exists $revster1]} {
				set msg "Extracting Channel 1 From File $fnam Failed: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}
			set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
			lappend cmd chans 1 $revsterx 2
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Extract Channel 2 From $fnam: $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Extract Channel 2 From File $fnam: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			if {![file exists $revster2]} {
				set msg "Extracting Channel 2 From File $fnam Failed: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}
			wm title .blocker "PLEASE WAIT:        REVERBERATING CHANNEL ONE"
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd revecho 3 $revster1 $revrev1 -g1.0 -r$revster_loss -s$revster_mult -e$revster_echos -n
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Reverberate Channel 1 : $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Reverberate Channel 1 : "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			if {![file exists $revrev1]} {
				set msg "Reverberating Channel 1 Failed: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}
			wm title .blocker "PLEASE WAIT:        REVERBERATING CHANNEL TWO"
			set cmd [file join $evv(CDPROGRAM_DIR) modify]
			lappend cmd revecho 3 $revster2 $revrev2 -g1.0 -r$revster_loss -s$revster_mult -e$revster_echos -n
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Reverberate Channel 2 : $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Reverberate Channel 2: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			if {![file exists $revrev2]} {
				set msg "Reverberating Channel 2 Failed: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}

			wm title .blocker "PLEASE WAIT:        MIXING OUTPUTS"
			if [catch {open $revstermix "w"} zit] {
				Inf "Cannot Open Mix File $revstermix To Create Final Mixed Output"
				UnBlock
				continue
			}
			if {$revster_chans == 4} {
				set line "4"
				puts $zit $line
				set line [list $revrev1 0 2 "1:1" 1 "2:2" 1]
				puts $zit $line
				set line [list $revrev2 0 2 "1:3" 1 "2:4" 1]
				puts $zit $line
			} else {
				set line [list $revrev1 0 2 1 L 0.5 C]
				puts $zit $line
				set line [list $revrev2 0 2 0.5 C 1 R]
				puts $zit $line
			}
			close $zit
			if {$revster_chans == 4} {
				set cmd [file join $evv(CDPROGRAM_DIR) newmix]
				lappend cmd multichan $revstermix $ofnam -g$revster_gain
			} else {
				set gain [expr $revster_gain * 0.5]
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd mix $revstermix $ofnam -g$gain
			}
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Mix Reverberated Outputs : $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Mix Reverberated Outputs : "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			if {![file exists $ofnam]} {
				set msg "Mixing Reverberated Outputs Failed: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}
	
			FileToWkspace $ofnam 0 0 0 0 1
			UnBlock
			Inf "File $ofnam Is On The Workspace"
			set finished 1
		} else {
			set finished 1
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Stack transposed-copies of multichannel file

proc MultiStack {} {
	global chlist wl pa evv pr_mustak prg_dun prg_abortd simple_program_messages CDPidrun last_outfile
	global mustak_chans mustak_trans mustak_level mustak_gain do_mustak mustak_ofnam mustak_plussrc

	if {![info exists mustak_plussrc]} {
		set mustak_plussrc 0
	}
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
	} else {
		set i [$wl curselection]
		if {([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
		}
	}
	if {![info exists fnam] || ($pa($fnam,$evv(CHANS)) < 2)} {
		Inf "Select One Multichannel Soundfile"
		return
	}
	set mustak_chans $pa($fnam,$evv(CHANS))
	set nyquist [expr double($pa($fnam,$evv(SRATE)))/2.0]

	set f .mustak
	if [Dlg_Create $f "MULTICHAN TRANSPOSED STACK" "set pr_mustak 0" -borderwidth $evv(SBDR)] {
		set f00 [frame $f.00] 
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		set f7 [frame $f.7] 
		set f8 [frame $f.8] 
		set f9 [frame $f.9] 
		set f9a [frame $f.9a] 
		set f10 [frame $f.10] 
		label $f00.0 -text "Tansposition : range  -96 to 96 semitones" -fg $evv(SPECIAL)
		label $f00.1 -text "Level and Gain : range  0.001 to 1" -fg $evv(SPECIAL)
		pack $f00.0 $f00.1 -side top -pady 2
		pack $f00 -side top 
		button $f0.ok -text "Run" -command "set pr_mustak 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_mustak 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		entry $f1.et1 -textvariable mustak_trans(1) -width 8
		label $f1.t1 -text "First transposition (semitones)"  -width 32
		radiobutton $f1.d1 -variable mustak_del(1) -text "erase" -value 0 -command "MustakErase 1"
		pack $f1.et1 $f1.t1 $f1.d1 -side left
		pack $f1 -side top -fill x -expand true

		entry $f2.et2 -textvariable mustak_level(1) -width 8
		label $f2.t2 -text "First transposition level" 
		pack $f2.et2 $f2.t2 -side left
		pack $f2 -side top -fill x -expand true

		entry $f3.et3 -textvariable mustak_trans(2) -width 8
		label $f3.t3 -text "Second transposition (semitones)" -width 32
		radiobutton $f3.d3 -variable mustak_del(2) -text "erase" -value 0 -command "MustakErase 2"
		pack $f3.et3 $f3.t3 $f3.d3 -side left
		pack $f3 -side top -fill x -expand true

		entry $f4.et4 -textvariable mustak_level(2) -width 8
		label $f4.t4 -text "Second transposition level" 
		pack $f4.et4 $f4.t4 -side left
		pack $f4 -side top -fill x -expand true

		entry $f5.et5 -textvariable mustak_trans(3) -width 8
		label $f5.t5 -text "Third transposition (semitones)" -width 32 
		radiobutton $f5.d5 -variable mustak_del(3) -text "erase" -value 0 -command "MustakErase 3"
		pack $f5.et5 $f5.t5 $f5.d5 -side left
		pack $f5 -side top -fill x -expand true

		entry $f6.et6 -textvariable mustak_level(3) -width 8
		label $f6.t6 -text "Third transposition level" 
		pack $f6.et6 $f6.t6 -side left
		pack $f6 -side top -fill x -expand true

		entry $f7.et7 -textvariable mustak_trans(4) -width 8
		label $f7.t7 -text "Fourth transposition (semitones)" -width 32
		radiobutton $f7.d7 -variable mustak_del(4) -text "erase" -value 0 -command "MustakErase 4"
		pack $f7.et7 $f7.t7 $f7.d7 -side left
		pack $f7 -side top -fill x -expand true

		entry $f8.et8 -textvariable mustak_level(4) -width 8
		label $f8.t8 -text "Fourth transposition level" 
		pack $f8.et8 $f8.t8 -side left
		pack $f8 -side top -fill x -expand true

		entry $f9.et9 -textvariable mustak_gain -width 8
		label $f9.t9 -text "mix gain" 
		pack $f9.et9 $f9.t9 -side left
		pack $f9 -side top -fill x -expand true

		checkbutton $f9a.orig -variable mustak_plussrc -text "Add untransposed source"
		pack $f9a.orig -side left
		pack $f9a -side top -fill x -expand true

		entry $f10.enam -textvariable mustak_ofnam -width 24
		label $f10.nam -text "outputfile name" 
		pack $f10.enam $f10.nam -side left
		pack $f10 -side top

		wm resizable $f 1 1
		bind $f <Escape> {set pr_mustak 0}
		bind $f <Return> {set pr_mustak 1}
		bind $f.1.et1 <Down> "focus $f.2.et2"
		bind $f.2.et2 <Down> "focus $f.3.et3"
		bind $f.3.et3 <Down> "focus $f.4.et4"
		bind $f.4.et4 <Down> "focus $f.5.et5"
		bind $f.5.et5 <Down> "focus $f.6.et6"
		bind $f.6.et6 <Down> "focus $f.7.et7"
		bind $f.7.et7 <Down> "focus $f.8.et8"
		bind $f.8.et8 <Down> "focus $f.9.et9"
		bind $f.9.et9 <Down> "focus $f.10.enam"
		bind $f.10.enam <Down> "focus $f.1.et1"
		bind $f.1.et1 <Up> "focus $f.10.enam"
		bind $f.2.et2 <Up> "focus $f.1.et1"
		bind $f.3.et3 <Up> "focus $f.2.et2"
		bind $f.4.et4 <Up> "focus $f.3.et3"
		bind $f.5.et5 <Up> "focus $f.4.et4"
		bind $f.6.et6 <Up> "focus $f.5.et5"
		bind $f.7.et7 <Up> "focus $f.6.et6"
		bind $f.8.et8 <Up> "focus $f.7.et7"
		bind $f.9.et9 <Up> "focus $f.8.et8"
		bind $f.10.enam <Up> "focus $f.9.et9"
	}
	DeleteAllTemporaryFiles
	set mustaksrc $evv(DFLT_OUTNAME)
	append mustaksrc $evv(SNDFILE_EXT)
	if [catch {file copy $fnam $mustaksrc} zit] {
		Inf "Cannot Make Initial Copy Of Source File"
		contunie
	}
	set mustakmix $evv(DFLT_OUTNAME)
	append mustakmix 0 [GetTextfileExtension mix]
	set n 1
	while {$n <= $mustak_chans} {
		set mustakch($n,0) $evv(DFLT_OUTNAME)
		append mustakch($n,0) _c$n $evv(SNDFILE_EXT)
		set mustakchana($n,0) $evv(DFLT_OUTNAME)
		append mustakchana($n,0) _c$n $evv(ANALFILE_EXT)
		set mustakstk($n) $evv(DFLT_OUTNAME)
		append mustakstk($n) $n $evv(SNDFILE_EXT)
		set m 1
		while {$m <= 4} {
			set mustakch($n,$m) $evv(DFLT_OUTNAME)
			append mustakch($n,$m) _c$n "_" $m $evv(SNDFILE_EXT)
			set mustakchana($n,$m) $evv(DFLT_OUTNAME)
			append mustakchana($n,$m) _c$n "_" $m $evv(ANALFILE_EXT)
			incr m
		}
		incr n
	}
	set pr_mustak 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mustak $f.1.et1
	while {!$finished} {
		DeleteAllTemporarySndfilesExcept $mustaksrc
		tkwait variable pr_mustak
		if {$pr_mustak} {
			if {[string length $mustak_ofnam] <= 0} {
				Inf "No Output Filename Entered"
				continue
			}
			if {![ValidCDPRootname $mustak_ofnam]} {
				continue
			}
			set ofnam [string tolower $mustak_ofnam]
			append ofnam $evv(SNDFILE_EXT)
			if {[file exists $ofnam]} {
				Inf "File $ofnam Already Exists: Please Choose A Different Name"
				continue
			}
			set OK 1
			set mustak_transcnt 0
			set m 1
			while {$m <= 4} {
				if {([string length $mustak_trans($m)] <= 0)} {
					 if {([string length $mustak_level($m)] > 0)} {
						Inf "No Value For Transposition $m"
						set OK 0
						break
					}
				}
				if {([string length $mustak_trans($m)] > 0)} {
					 if {([string length $mustak_level($m)] <= 0)} {
						Inf "No Level For Transposition $m"
						set OK 0
						break
					}
				}
				if {([string length $mustak_trans($m)] > 0)} {
					if {![IsNumeric $mustak_trans($m)] || ($mustak_trans($m) < -96) || ($mustak_trans($m) > 96)} {
						Inf "Invalid Value For Transposition $m"
						set OK 0
						break
					}
					if {![IsNumeric $mustak_level($m)] || ($mustak_level($m) < .001) || ($mustak_level($m) > 1)} {
						Inf "Invalid Level For Transposition $m"
						set OK 0
						break
					}
					set do_mustak($m) 1
					incr mustak_transcnt
				} else {
					set do_mustak($m) 0
				}
				incr m

			}
			if {!$OK} {
				continue
			}
			if {$mustak_transcnt <= 0} {
				Inf "No Transpositions Specified"
				continue
			}
			if {([string length $mustak_gain] <= 0) || ![IsNumeric $mustak_gain] || ($mustak_gain < 0.001) || ($mustak_gain > 1)} {
				Inf "Invalid Gain Value"
				continue
			}

			;#	EXTRACT ALL CHANNELS OF SOURCE

			Block "Extracting All Channels"
			catch {close $CDPidrun}
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
			lappend cmd chans 2 $mustaksrc
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Extract Channels From $fnam: $CDPidrun"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Extract Channels From File $fnam: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}
			set n 1

			while {$n <= $mustak_chans} {
				if {![file exists $mustakch($n,0)]} {
					set msg "Extracting Channel $n From File $fnam Failed: "
					set msg [AddSimpleMessages $msg]
					Inf $msg
					set OK 0
					break
				}
				incr n
			}
			if {!$OK} {
				UnBlock
				continue
			}

			;#	GET SPECTRA OF CHANNEL-EXTRACTED FILES

			set n 1
			while {$n <= $mustak_chans} {
				catch {close $CDPidrun}
				wm title .blocker "PLEASE WAIT:        GETTING SPECTRUM OF CHANNEL $n"
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
				lappend cmd anal 1 $mustakch($n,0) $mustakchana($n,0) -c1024 -o3
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					Inf "Cannot Get Spectrum From Channel $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Get Spectrum Of Channel $n"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					set OK 0
					break
				}
				if {![file exists $mustakchana($n,0)]} {
					set msg "Getting Spectrum Of Channel $n Failed: "
					set msg [AddSimpleMessages $msg]
					Inf $msg
					set OK 0
					break
				}
				catch {close $CDPidrun}
				incr n
			}
			if {!$OK} {
				catch {close $CDPidrun}
				UnBlock
				continue
			}

			;#	FOR EACH CHANNEL

			set n 1
			while {$n <= $mustak_chans} {
				set m 1

			;#	DO ALL THE TRANSPOSITIONS

				while {$m <= 4} {
					if {$do_mustak($m)} {
						wm title .blocker "PLEASE WAIT:        TRANSPOSING CHANNEL $n BY $mustak_trans($m) SEMITONES"
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						set cmd [file join $evv(CDPROGRAM_DIR) repitch]
						lappend cmd transpose 3 $mustakchana($n,0) $mustakchana($n,$m) $mustak_trans($m) -l5.0 -h$nyquist
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							Inf "Cannot Transpose Channel $n By $mustak_trans($m) Semitones"
							catch {unset CDPidrun}
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Transpose Channel $n By $mustak_trans($m) Semitones"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						if {![file exists $mustakchana($n,$m)]} {
							set msg " Transposing Channel $n By $mustak_trans($m) Semitones Failed: "
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						catch {close $CDPidrun}

			;#	AND RESYNTH THE TRANSPOSED OUTPUTS

						wm title .blocker "PLEASE WAIT:        RESYNTH CHAN $n TRANS BY $mustak_trans($m) SEMITONES"
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
						lappend cmd synth $mustakchana($n,$m) $mustakch($n,$m)
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							Inf "Cannot Resynth Channel $n Trans By $mustak_trans($m) Semitones"
							catch {unset CDPidrun}
							set OK 0
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Resynth Channel $n Trans By $mustak_trans($m) Semitones"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						if {![file exists $mustakch($n,$m)]} {
							set msg " Resynthesizing Channel Trans $n By $mustak_trans($m) Semitones Failed: "
							set msg [AddSimpleMessages $msg]
							Inf $msg
							set OK 0
							break
						}
						catch {close $CDPidrun}
					}
					if {!$OK} {
						break
					}
					incr m
				}
				if {!$OK} {
					break
				}

				;#	CREATE MIXFILE FOR TRANSPOSITIONS OF THIS CHANNEL

				if {[file exists $mustakmix]} {
					if [catch {file delete $mustakmix} zit] {
						Inf "Cannot Delete Intermediate Mixfile $mustakmix"
						set OK 0
						break
					}
				}
				if [catch {open $mustakmix "w"} zit] {
					Inf "Cannot Open Mixfile For Channel $n Transpositions"
					set OK 0
					break
				}
				if {$mustak_plussrc} {
					set line [list $mustakch($n,0) 0.0 1 1.0]
					puts $zit $line
				}
				set m 1
				while {$m <= 4} {
					if {$do_mustak($m)} {
						set line [list $mustakch($n,$m) 0.0 1 $mustak_level($m)]
						puts $zit $line
					}
					incr m
				}
				close $zit

				;#	DO MIX FOR TRANSPOSITIONS OF THIS CHANNEL

				wm title .blocker "PLEASE WAIT:        MIXING TRANSPOSITIONS OF CHANNEL $n"
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd mix $mustakmix $mustakstk($n) -g$mustak_gain
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				if [catch {open "|$cmd"} CDPidrun] {
					Inf "Cannot Mix Transpositions Of Channel $n"
					catch {unset CDPidrun}
					set OK 0
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Mix Transpositions Of Channel $n"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					set OK 0
					break
				}
				if {![file exists $mustakstk($n)]} {
					set msg " Mixing Transpositions Of Channel $n Failed: "
					set msg [AddSimpleMessages $msg]
					Inf $msg
					set OK 0
					break
				}
				catch {close $CDPidrun}
				incr n
			}
			if {!$OK} {
				UnBlock
				continue
			}

			;#	REMIX ALL CHANNELS

			wm title .blocker "PLEASE WAIT:        MERGING MULTICHANNEL OUTPUT"
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			set cmd [file join $evv(CDPROGRAM_DIR) submix]
			lappend cmd interleave 
			set n 1
			while {$n <= $mustak_chans} {
				lappend cmd $mustakstk($n)
				incr n
			}
			lappend cmd $ofnam
			set prg_dun 0
			set prg_abortd 0
			catch {unset simple_program_messages}
			if [catch {open "|$cmd"} CDPidrun] {
				Inf "Cannot Merge Multichannel Output"
				catch {unset CDPidrun}
				UnBlock
				continue
			} else {
				fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
			}
			vwait prg_dun
			if {$prg_abortd} {
				set prg_dun 0
			}
			if {!$prg_dun} {
				set msg "Failed To Merge Multichannel Output"
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			if {![file exists $ofnam]} {
				set msg " Mixing Multichannel Output Failed: "
				set msg [AddSimpleMessages $msg]
				Inf $msg
				UnBlock
				continue
			}
			catch {close $CDPidrun}
			FileToWkspace $ofnam 0 0 0 0 1
			Inf "File $ofnam Is On The Workspace"
			set last_outfile $ofnam
			UnBlock
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#---- Eliminate transposition values from interface

proc MustakErase {n} {
	global mustak_trans mustak_level
	set mustak_trans($n) ""
	set mustak_level($n) ""
}

#---- Put input file set onto successive channels around a ring

proc SideBySideMix {} {
	global chlist wl evv pa pr_sideby sideby_ofnam sideby_ochans readonlyfg last_outfile

	if {[info exists chlist] && ([llength $chlist] > 1)} {
		set fnams $chlist
	} else {
		set ilist [$wl curselection]
		if {[llength $ilist] > 1} {
			foreach i $ilist {
				lappend fnams [$wl get $i]
			}
		}
	}
	if {![info exists fnams]} {
		Inf "Select More Than One Soundfile"
		return
	}
	set totchans 0
	foreach fnam $fnams {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Not All Selected Files Are Soundfiles"
			return
		}
		if {![info exists srate]} {
			set srate $pa($fnam,$evv(SRATE))
		} elseif {$pa($fnam,$evv(SRATE)) != $srate} {
			Inf "Soundfiles Have Incompatible Sample Rates"
			return
		}
		lappend inchans $pa($fnam,$evv(CHANS))
	}
	set f .sideby	
	if [Dlg_Create $f "SIDE BY SIDE MIX" "set pr_sideby 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		button $f0.ok -text "Mix" -command "set pr_sideby 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_sideby 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		frame $f.00
		entry $f.00.ee -textvariable sideby_ochans -width 4 -state readonly -fg $readonlyfg
		label $f.00.ll -text "Output Channel Count"
		set sideby_ochans 8
		pack $f.00.ee $f.00.ll -side left
		pack $f.00 -side top -fill x -expand true -pady 2
		label $f.000 -text "Use \"Up\" and \"Down\" Arrows to change value" -fg $evv(SPECIAL)
		pack $f.000 -side top -fill x -expand true
		entry $f1.et1 -textvariable sideby_ofnam -width 24
		label $f1.t1 -text "Mixfile name"
		pack $f1.et1 $f1.t1 -side left
		pack $f1 -side top -fill x -expand true -pady 2
		button $f2.mix1 -text "mix1" -command "set sideby_ofnam mix1" -highlightbackground [option get . background {}]
		button $f2.mix2 -text "mix2" -command "set sideby_ofnam mix2" -highlightbackground [option get . background {}]
		button $f2.mixc -text "current_mix" -command "set sideby_ofnam current_mix" -highlightbackground [option get . background {}]
		pack $f2.mix1 $f2.mix2 $f2.mixc -side left -padx 2
		pack $f2 -side top -fill x -expand true -pady 2
		wm resizable $f 1 1
		bind $f <Up>	{IncrSideby 0}
		bind $f <Down>	{IncrSideby 1}
		bind $f <Return> {set pr_sideby 1}
		bind $f <Escape> {set pr_sideby 0}
	}
	set pr_sideby 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_sideby $f.1.et1
	while {!$finished} {
		tkwait variable pr_sideby
		if {$pr_sideby} {
			if {([string length $sideby_ochans] <= 0) || ![IsNumeric $sideby_ochans] || ![regexp {^[0-9]+$} $sideby_ochans] || ($sideby_ochans < 2)} {
				Inf "Invalid File Outchannel Count"
				return
			}
			foreach chans $inchans {
				if {$chans > $sideby_ochans} {
					Inf "File $fnam Has Too Many Channels For This Mix"
					return
				}
			}
			if {![ValidCDPRootname $sideby_ofnam]} {
				continue
			}
			set ofnam [string tolower $sideby_ofnam]
			append ofnam [GetTextfileExtension mmx]
			if {[file exists $ofnam]} {
				Inf "File $ofnam Already Exists: Please Choose A Different Name"
				continue
			}
			if [catch {open $ofnam "w"} zit] {
				Inf "Cannot Open File $ofnam To Create Mixfile"
				continue
			}
			puts $zit $sideby_ochans
			set thischan 1
			foreach fnam $fnams chans $inchans {
				set line $fnam
				lappend line 0.0 $chans
				set ch 0
				set ch_cntr 1
				while {$ch < $chans} {
					set rout $ch_cntr
					append rout ":" $thischan
					lappend line $rout 1.0
					incr thischan
					if {$thischan > $sideby_ochans} {
						set thischan 1
					}
					incr ch_cntr
					incr ch
				}
				puts $zit $line		
			}
			close $zit
			FileToWkspace $ofnam 0 0 0 0 1
			Inf "File $ofnam Is On The Workspace"
			set last_outfile $ofnam
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc IncrSideby {down} {
	global sideby_ochans

	if {$down} {
		if {$sideby_ochans > 2} {
			incr sideby_ochans -1
		}
	} else {
		if {$sideby_ochans < 16} {
			incr sideby_ochans
		}
	}
}

#--- Put successive stereo infiles on 1-3,2-4,3-5,4-6,5-7,6-8,7-2 etc

proc StirMix {} {
	global chlist wl evv pa pr_stiirr stiirr_ofnam stiirr_ochans readonlyfg last_outfile

	if {[info exists chlist] && ([llength $chlist] > 1)} {
		set fnams $chlist
	} else {
		set ilist [$wl curselection]
		if {[llength $ilist] > 1} {
			foreach i $ilist {
				lappend fnams [$wl get $i]
			}
		}
	}
	if {![info exists fnams]} {
		Inf "Select More Than One Soundfile"
		return
	}
	set totchans 0
	foreach fnam $fnams {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "Not All Selected Files Are Soundfiles"
			return
		}
		if {$pa($fnam,$evv(CHANS)) != 2} {
			Inf "This Option Only Works With Stereo Input Files"
			return
		}
		if {![info exists srate]} {
			set srate $pa($fnam,$evv(SRATE))
		} elseif {$pa($fnam,$evv(SRATE)) != $srate} {
			Inf "Soundfiles Have Incompatible Sample Rates"
			return
		}
	}
	set f .stiirr	
	if [Dlg_Create $f "STEREO INTERLEAVE MIX" "set pr_stiirr 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		button $f0.ok -text "Mix" -command "set pr_stiirr 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_stiirr 0" -highlightbackground [option get . background {}]
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		frame $f.00
		entry $f.00.ee -textvariable stiirr_ochans -width 4 -state readonly -fg $readonlyfg
		label $f.00.ll -text "Output Channel Count"
		set stiirr_ochans 8
		pack $f.00.ee $f.00.ll -side left
		pack $f.00 -side top -fill x -expand true -pady 2
		label $f.000 -text "Use \"Up\" and \"Down\" Arrows to change value" -fg $evv(SPECIAL)
		pack $f.000 -side top -fill x -expand true
		entry $f1.et1 -textvariable stiirr_ofnam -width 24
		label $f1.t1 -text "Mixfile name"
		pack $f1.et1 $f1.t1 -side left
		pack $f1 -side top -fill x -expand true -pady 2
		wm resizable $f 1 1
		bind $f <Up>	{IncrSideby 0}
		bind $f <Down>	{IncrSideby 1}
		bind $f <Return> {set pr_stiirr 1}
		bind $f <Escape> {set pr_stiirr 0}
	}
	set pr_stiirr 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_stiirr $f.1.et1
	while {!$finished} {
		tkwait variable pr_stiirr
		if {$pr_stiirr} {
			if {([string length $stiirr_ochans] <= 0) || ![IsNumeric $stiirr_ochans] || ![regexp {^[0-9]+$} $stiirr_ochans] || ($stiirr_ochans < 2)} {
				Inf "Invalid File Outchannel Count"
				return
			}
			if {![ValidCDPRootname $stiirr_ofnam]} {
				continue
			}
			set ofnam [string tolower $stiirr_ofnam]
			append ofnam [GetTextfileExtension mmx]
			if {[file exists $ofnam]} {
				Inf "File $ofnam Already Exists: Please Choose A Different Name"
				continue
			}
			if [catch {open $ofnam "w"} zit] {
				Inf "Cannot Open File $ofnam To Create Mixfile"
				continue
			}
			puts $zit $stiirr_ochans
			set thischanbas 1
			foreach fnam $fnams {
				set line $fnam
				lappend line 0.0 2
				set ch 0
				set ch_cntr 1
				set thischan $thischanbas
				while {$ch < 2} {
					set rout $ch_cntr
					append rout ":" $thischan
					lappend line $rout 1.0
					incr ch_cntr
					incr thischan 2
					if {$thischan > $stiirr_ochans} {
						set thischan [expr $thischan - $stiirr_ochans]
					}
					incr ch
				}
				incr thischanbas
				if {$thischanbas > $stiirr_ochans} {
					set thischanbas [expr $thischanbas - $stiirr_ochans]
				}
				puts $zit $line		
			}
			close $zit
			FileToWkspace $ofnam 0 0 0 0 1
			Inf "File $ofnam Is On The Workspace"
			set last_outfile $ofnam
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Help msg for ResTail

proc ResTailHelp {} {
	set msg "                                              RESONATE TAIL OF SOUND\n"
	append msg "\n"
	append msg "Add reverb ONLY to the tail of a sound.\n"
	append msg "\n"
	append msg "(1) Select the region of the sound (at the end) where reverb will be applied,\n"
	append msg "        using the \"Select Segment\" window.\n"
	append msg "\n"
	append msg "(2) Set parameters \"Stadium size multiplier\" and \"Number of echos\"\n"
	append msg "        (as used in \"REVECHO\" \"stadium\") to determine the reverb quality.\n"
	append msg "\n"
	append msg "(3) \"Level of reverb in final mix\"\n"
	append msg "        determines the proportion of reverberated signal mixed into the source\n"
	append msg "        in the output sound.\n"
	append msg "\n"
	append msg "(4) \"Output gain for reverb creation\" sets an overall gain (of 1 or less) on the output.\n"
	append msg "        It should initially be set to \"1\" and only reduced if the output signal overloads\n"
	append msg "        (reported automatically by the interface).\n"
	append msg "\n"
	append msg "(4) The reverberated tail (prior to mixing with the source)\n"
	append msg "        can also be filtered before mixing with the source.\n"
	append msg "        To do this, use the \"Filter Tail\" option.\n"
	append msg "        The unfiltered tail can be restored with \"Restore unfiltered Output\".\n"
	append msg "\n"
	append msg "(5) The default name for the output is the source sound's name\n"
	append msg "         with the extension \"_revend\" added.\n"
	Inf $msg
}

#---- Contract sounds by spectral timeshrinking ceNtral portion (or expanding it)

proc Contract {} {
	global wl chlist evv pa pr_contract contract_contract contract_dovein contract_doveout contract_fnam last_outfile
	global prg_dun prg_abortd simple_program_messages CDPidrun

	if {[info exists chlist] && ([llength $chlist] > 0)} {
		set fnams $chlist
	} else {
		set ilist [$wl curselection]
		if {![info exists ilist] || ([llength $ilist] <= 0) || (([llength $ilist] == 1) && ($ilist == -1))} {
			Inf "Select Either Mono Or Stereo Soundfiles To Resize"
			return
		}
		foreach i $ilist {
			lappend fnams [$wl get $i]
		}
	}
	set n 0
	foreach fnam $fnams {
		if {$pa($fnam,$evv(FTYP)) !=  $evv(SNDFILE)} {
			Inf "Select Soundfiles Only ([file rootname [file tail $fnam]] Is Not A Soundfile)"
			return
		}
		if {$n ==0} {
			set chans $pa($fnam,$evv(CHANS))
			if {$chans > 2} {
				Inf "Select Either All Mono Or All Stereo Soundfiles"
				return
			}
		} else {
			if {$pa($fnam,$evv(CHANS)) != $chans} {
				set msg "Select Either All Mono Or All Stereo Soundfiles."
				append msg "\n[file rootname [file tail $fnam]] Has $pa($fnam,$evv(CHANS)) Channels."
				append msg "\nPrevious Files Have $chans Channels."
				Inf $msg
				return
			}
		}
		lappend durs $pa($fnam,$evv(DUR))
		incr n
	}
	set incnt $n
	set origfnams $fnams										;#	ORiginal input files
	foreach fnam $origfnams {
		lappend srcfnams [file rootname [file tail $fnam]]		;#	(short) names of original input files
	}
	if {$chans == 1}  {
		set thisfnams $srcfnams
	} else {
		catch {unset thisfnams}
		foreach fnam $srcfnams {
			set thisfnam $fnam
			append thisfnam " CHAN 1"
			lappend thisfnams $thisfnam
			set thisfnam $fnam
			append thisfnam " CHAN 2"
			lappend thisfnams $thisfnam
		}
	}
	set n 0											;#	INTERMEDIATE FILES	
	if {$chans > 1} {
		while {$n < $incnt} {
			set infnam $evv(DFLT_OUTNAME)			;#	FOR STEREO INFILES
			append infnam $n
			set infn $infnam
			append infn $evv(SNDFILE_EXT)			;#	Infile copies = "infcops"
			lappend infcops $infn
			set infn $infnam
			append infn "_c1" $evv(SNDFILE_EXT)		;#	Infile extracted chan1 
			lappend infnams $infn
			set infn $infnam
			append infn "_c2" $evv(SNDFILE_EXT)		;#	Infile extracted chan2
			lappend infnams $infn
			incr n									;#	ch1 and ch2 stored alternately in "infnams"	
		}
		set m 0
		while {$m < $incnt} {
			set ofnam $evv(DFLT_OUTNAME)
			append ofnam $n
			set ofn $ofnam
			append ofn "_c1" $evv(SNDFILE_EXT)		;#	Output soundfile chan1
			lappend ofnams $ofn
			set ofn $ofnam
			append ofn "_c2" $evv(SNDFILE_EXT)		;#	Output soundfile chan2
			lappend ofnams $ofn
			incr m									;#	ch1 and ch2 stored alternately in "ofnams"	
			incr n
		}

	} else {										;#	FOR MONO INFILES
		set infnams $origfnams						;#	No copies of src needed, and no separate channel inputs and outputs
	}
													;#	FOR BOTH MONO AND STEREO
	set len [llength $infnams]						;#	For every mono soundfile input
	set m 0
	while {$m < $len} {
		set infnam $evv(MACH_OUTFNAME)
		append infnam $m
		append infnam $evv(ANALFILE_EXT)			;#	An anlysis infile
		lappend pvins $infnam 
		incr m
	}
	set k 0
	while {$k < $len} {
		set outfnam $evv(MACH_OUTFNAME)
		append outfnam $m
		append outfnam $evv(ANALFILE_EXT)			;#	An analysis outfile
		lappend pvouts $outfnam 
		incr k
		incr m
	}
	
	set strfile $evv(DFLT_OUTNAME)					;#	A timestretch datafile
	append strfile 0 $evv(TEXT_EXT)

	set f .contract
	if [Dlg_Create $f "INTERNALLY CONTRACT SOUNDS" "set pr_contract 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		button $f0.ok -text "Modify" -command "set pr_contract 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.sv -text "Sound View" -command "set pr_contract 2"  -bg $evv(SNCOLOR) -highlightbackground [option get . background {}]
		button $f0.quit -text "Abandon" -command "set pr_contract 0" -highlightbackground [option get . background {}]
		pack $f0.ok $f0.sv -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		label $f1.ll -text "Start of file to keep (secs)"
		entry $f1.e -textvariable contract_dovein   -width 20
		pack $f1.e $f1.ll  -side left -padx 2
		pack $f1 -side top -pady 2 -fill x -expand true
		label $f2.ll -text "End of file to keep (secs)"
		entry $f2.e -textvariable contract_doveout  -width 20
		pack $f2.e $f2.ll  -side left -padx 2
		pack $f2 -side top -pady 2 -fill x -expand true
		label $f3.ll -text "Contraction/Expansion factor (Range 0.01 to 64)"
		entry $f3.e -textvariable contract_contract -width 20
		pack $f3.e $f3.ll  -side left -padx 2
		pack $f3 -side top -pady 2 -fill x -expand true
		label $f4.ll -text "Generic Outfile name-extension"
		entry $f4.e -textvariable contract_fnam -width 20
		pack $f4.e $f4.ll  -side left -padx 2
		pack $f4 -side top -pady 2
		wm resizable $f 1 1
		bind $f1.e <Up>	{focus .contract.4.e}
		bind $f2.e <Up>	{focus .contract.1.e}
		bind $f3.e <Up>	{focus .contract.2.e}
		bind $f4.e <Up>	{focus .contract.3.e}
		bind $f1.e <Down>	{focus .contract.2.e}
		bind $f2.e <Down>	{focus .contract.3.e}
		bind $f3.e <Down>	{focus .contract.4.e}
		bind $f4.e <Down>	{focus .contract.1.e}
		bind $f <Return> {set pr_contract 1}
		bind $f <Escape> {set pr_contract 0}
	}
	set pr_contract 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_contract $f.1.e
	while {!$finished} {
		tkwait variable pr_contract
		switch -- $pr_contract {
			1 {
				if {![ValidCDPRootname $contract_fnam]} {
					continue
				}
				set ofex [string tolower $contract_fnam]
				set OK 1
				catch {unset outfnams}
				foreach fnam $origfnams {
					set ofnam [file rootname [file tail $fnam]]
					append ofnam "_" $ofex $evv(SNDFILE_EXT)
					if {[file exists $ofnam]} {
						Inf "File $ofnam Already Exists : Choose A Different Name-Extension"
						set OK 0
						break
					}
					lappend outfnams $ofnam		;#	Outfile names
				}
				if {!$OK} {
					continue
				}
				if {$chans == 1} {				;#	With MONO files,
					set ofnams $outfnams		;#	outputS of resynth (ofnamS) = the final outputs (outfnams)
				}
				if {([string length $contract_dovein] <= 0) || ![IsNumeric $contract_dovein] || ($contract_dovein < 0)} {
					Inf "Invalid \"Start Of File To Keep\""
					continue
				}
				if {([string length $contract_doveout] <= 0) || ![IsNumeric $contract_doveout] || ($contract_doveout < 0)} {
					Inf "Invalid \"End Of File To Keep\""
					continue
				}
				foreach fnam $origfnams dur $durs {
					if {[expr $contract_dovein + $contract_doveout + 0.04] >= $pa($fnam,$evv(DUR))} {
						Inf "Start+End To Keep, Too Long For File $fnam (Duration $dur)"
						set OK 0
					}
				}
				if {!$OK} {
					continue
				}
				if {([string length $contract_contract] <= 0) || ![IsNumeric $contract_contract] || ($contract_contract < 0.01) || ($contract_contract > 64)} {
					Inf "Invalid Contraction(Expansion) Factor (Range 0.01 to 64)"
					continue
				}

				Block "CONTRACTING FILES"

				if {$chans > 1} {

					;#	STEREO FILES : MUCH INITIAL COPY (SO TEMPORARY NAMES PROPAGATE CORRECTLY)

					set localoutfiles {}
					foreach fnam $origfnams infcop $infcops {
						if [catch {file copy $fnam $infcop} zit ] {
							Inf "Failed To Copy File [file rootname [file tail $fnam]]"
							DeleteAllTemporaryFiles
							continue
						}
						lappend localoutfiles $infcop

					}
					if {[llength $localoutfiles] <= 0} {	
						Inf "No Source Files Have Been Copied"
						UnBlock
						continue
					}

					;#	STEREO FILES : ;EACH INFILE SPLIT TO 2 MONO FILES WHICH WILL BE INPUT "infiles" TO ANALYSIS

					set localoutfiles {}
					foreach fnam $infcops {infc1 infc2} $infnams srcfnam $srcfnams {
						if {[file exists $fnam]} {
							set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
							lappend cmd chans 2 $fnam
							set prg_dun 0
							set prg_abortd 0
							wm title .blocker "EXTRACTING CHANNELS OF $srcfnam"
							if [catch {open "|$cmd"} CDPidrun] {
								Inf "Failed To Run Channel Extraction On $srcfnam"
								catch {unset CDPidrun}
								UnBlock
								set finished 1
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								Inf "Failed In Extracting Channels Of $srcfnam"
								catch {unset CDPidrun}
								continue
							}
							catch {close $CDPidrun}
							if {![file exists $infc1] || ![file exists $infc2]} {
								Inf "Failed To Extract Channels Of $srcfnam"
								catch {unset CDPidrun}
								continue
							}
							lappend localoutfiles $infcop
						}
					}
					if {[llength $localoutfiles] <= 0} {	
						Inf "No Sources Have Been Separated Into Their Constituent Channels"
						UnBlock
						continue
					}
				}

				;#	ANALYSIS (FROM MONO, OR FROM STEREO-CHANNELS, ALL INPUTS NOW MONO)

				set localoutfiles {}
				foreach fnam $infnams pvin $pvins thisfnam $thisfnams {
					if {[file exists $fnam]} {
						set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
						lappend cmd anal 1 $fnam $pvin -c1024 -o3
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        ANALYSING FILE $thisfnam"
						if [catch {open "|$cmd"} CDPidrun] {
							Inf "Cannot Analyse File $thisfnam"
							catch {unset CDPidrun}
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Analyse File $thisfnam"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							catch {close $CDPidrun}
							continue
						}
						if {![file exists $pvin]} {
							set msg " Analysing File $thisfnam Failed: "
							set msg [AddSimpleMessages $msg]
							Inf $msg
							catch {close $CDPidrun}
							continue
						}
						lappend localoutfiles $pvin
					}
				}
				if {[llength $localoutfiles] <= 0} {
					Inf "No Files Have Been Analysed"
					UnBlock
					DeleteAllTemporaryFiles
					continue
				}

				;#	CONTRACT/EXPAND THE ANALYSIS FILES

				set localoutfiles {}
				if {$chans == 2} {
					catch {unset durations}
					foreach dur $durs {
						lappend durations $dur $dur			;#	Stereo case, duration of each channel needed in loop
					}
				} else {
					set durations $durs
				}
				set chan $chans
				foreach pvin $pvins pvout $pvouts srcfnam $srcfnams thisfnam $thisfnams dur $durations {
					if {$chans == 2} {
						if {$chan == 2} {			;#	In stereo case, switch between channels, for message names
							set chan 1
						} else {
							set chan 2
						}
					}
					if {[file exists $pvin]} {
						if {$chan == 1} {
						
							;#	MONO, OR CH1 OF STEREO, CONSTRUCT THE TSTRETCH DATAFILE
										
							catch {unset lines}
							set line [list 0 1]
							lappend lines $line
							set line [list $contract_dovein 1]
							lappend lines $line
							set line [list [expr $contract_dovein + 0.02] $contract_contract]
							lappend lines $line
							set line [list [expr $dur - 0.02 - $contract_doveout] $contract_contract]
							lappend lines $line
							set line [list [expr $dur - $contract_doveout] 1]
							lappend lines $line
							set line [list [expr $dur + 1] 1]
							lappend lines $line
							if [catch {open $strfile "w"} zit] {
								Inf "Cannot Open Temporary Datafile $strfile To Hold Timestretch Data For $srcfnam"
								continue
							}
							foreach line $lines {
								puts $zit $line
							}
							close $zit
						} elseif {![file exists $strfile]} {
							continue
						}
						set cmd [file join $evv(CDPROGRAM_DIR) stretch]
						lappend cmd time 1 $pvin $pvout $strfile
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        TIME-WARPING FILE $thisfnam"
						if [catch {open "|$cmd"} CDPidrun] {
							Inf "Cannot Time-Warp File $thisfnam"
							catch {unset CDPidrun}
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Time-Warp File $thisfnam"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							catch {close $CDPidrun}
							continue
						}
						if {![file exists $pvout]} {
							set msg "Time-Warping File $thisfnam Failed: "
							set msg [AddSimpleMessages $msg]
							Inf $msg
							catch {close $CDPidrun}
							continue
						}
						lappend localoutfiles $pvout
					}
				}
				set len [llength $localoutfiles]
				if {$len > 0} {
					if {$chans > 1} {							;#	in stereo, pairs of files must BOTH exist
						foreach {fnamc1 fnamc2} $pvouts {
							if {[file exists $fnamc1]} {
								if {![file exists $fnamc2]} {
									incr len -1		
								}
							}
							if {[file exists $fnamc2]} {
								if {![file exists $fnamc1]} {
									incr len -1		
								}
							}
						}
					}
				}
				if {$len <= 0} {
					Inf "No Files Have Been Time-Warped"
					UnBlock
					DeleteAllTemporaryFiles
					continue
				}

				;#	RESYNTHSIZE TIME-WARPED (MONO) FILES

				set localoutfiles {}
				foreach pvout $pvouts ofnam $ofnams thisfnam $thisfnams {
					if {[file exists $pvout]} {
						set cmd [file join $evv(CDPROGRAM_DIR) pvoc]
						lappend cmd synth $pvout $ofnam
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        RESYNTHESIZING WARPED FILE $thisfnam"
						if [catch {open "|$cmd"} CDPidrun] {
							Inf "Cannot Resynthesize File $origfnam"
							catch {unset CDPidrun}
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Resynthesize Warped File $thisfnam"
							set msg [AddSimpleMessages $msg]
							Inf $msg
							catch {close $CDPidrun}
							continue
						}
						if {![file exists $outfnam]} {
							set msg " Resynthesizing Warped File $thisfnam Failed: "
							set msg [AddSimpleMessages $msg]
							Inf $msg
							catch {close $CDPidrun}
							continue
						}
						lappend localoutfiles $ofnam
					}
				}
				set len [llength $localoutfiles]
				if {$len > 0} {
					if {$chans > 1} {							;#	in stereo, pairs of files BOTH must exist
						foreach {fnamc1 fnamc2} $ofnams {
							if {[file exists $fnamc1]} {
								if {![file exists $fnamc2]} {
									incr len -1		
								}
							}
							if {[file exists $fnamc2]} {
								if {![file exists $fnamc1]} {
									incr len -1		
								}
							}
						}
					}
				}
				if {$len <= 0} {
					Inf "No Files Have Been Resynthsized"
					UnBlock
					DeleteAllTemporaryFiles
					continue
				}
				if {$chans > 1} {									;#	merge mono->stereo	
					foreach {ofnam1 ofnam2} $ofnams outfnam $outfnams {
						if {[file exists $ofnam1] && [file exists $ofnam2]} {
							set cmd [file join $evv(CDPROGRAM_DIR) submix]
							lappend cmd interleave $ofnam1 $ofnam2 $outfnam
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							wm title .blocker "PLEASE WAIT:        RECREATING STEREO $outfnam"
							if [catch {open "|$cmd"} CDPidrun] {
								Inf "Cannot Resynthesize File $origfnam"
								catch {unset CDPidrun}
								continue
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Failed To Recreate Stereo $outfnam"
								set msg [AddSimpleMessages $msg]
								Inf $msg
								catch {close $CDPidrun}
								continue
							}
							if {![file exists $outfnam]} {
								set msg " Recreating Stereo $outfnam Failed: "
								set msg [AddSimpleMessages $msg]
								Inf $msg
								catch {close $CDPidrun}
								continue
							}
							lappend localoutfiles $ofnam
						}
					}
					if {[llength $localoutfiles] <= 0} {
						Inf "No Stereo Outputs Have Been Created"
						UnBlock
						DeleteAllTemporaryFiles
						continue
					}
				}
				catch {unset outs}
				set badfiles 0
				set outfnams [ReverseList $outfnams]
				foreach outfnam $outfnams {
					if {[file exists $outfnam]} {
						FileToWkspace $outfnam 0 0 0 0 1
						lappend outs $outfnam
					} else {
						incr badfiles
					}
				}
				if {$badfiles} {
					Inf "$badfiles Files Were Not Time-Warped"
				}
				set last_outfile $outs
				Inf "The Modified Files Are On The Workspace"
				UnBlock
				set finished 1
			}
			0 {
				set finished 1
			}
			2 {
				SnackDisplay $evv(SN_TIMEPAIRS) contract $evv(TIME_OUT) [lindex $origfnams 0]
			}
		}		
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Convert 2-channel multichannel file to standard mixfile (stereo) format

proc MultiToStereoMix {} {
	global wl chlist wstk pa evv
	if {![info exists chlist] || ([llength $chlist] != 1)} { 
		Inf "Choose A Multichannel Mixfile"
		return
	}
	set fnam [lindex $chlist 0]
	if {$pa($fnam,$evv(FTYP)) != $evv(MIX_MULTI)} {
		Inf "Choose A Multichannel Mixfile"
		return
	}
	set ofnam [file rootname [file tail $fnam]]
	append ofnam [GetTextfileExtension mix]
	if {[file exists $ofnam]} {
		Inf "File $ofnam Already Exists: Cannot Proceed"
		return
	}
	if [catch {open $fnam "r"} zit] {
		Inf "Cannot Open File $fnam"
		return
	}
	set OK 1
	set warned 0
	set linecnt 0
	while {[gets $zit line] >= 0} {
		incr linecnt
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {$linecnt == 1} {		;#	Lose channel-count info from head of file
			continue
		}
		if {[string match ";" [string index $line 0]]} {
			lappend nulines $line
			continue
		}
		set line [split $line]
		catch {unset nuline}
		set n 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			switch -- $n {
				2 {
					set chans $item
					if {$chans > 2} {
						Inf "All Mixed Files Must Be Either Stereo Or Mono"
						set OK 0
						break
					}
				}
				3 {
					set firstrout $item
					set rout [split $item ":"]
					set from1 [lindex $rout 0]
					set rout1 [lindex $rout 1]
					if {$rout1 > 2} {
						Inf "All Mixed Files Must Be Routed To Either Channel 1, Channel 2 Or Both"
						set OK 0
						break
					}
				}
				4 {
					set lev1 $item
				}
				5 {
					if {[string match $item $firstrout]} {
						Inf "Routing Duplication ($firstrout) In Mixfile, Line $linecnt"
						set OK 0
						break
					}
					set rout [split $item ":"]
					set from2 [lindex $rout 0]
					set rout2 [lindex $rout 1]
					if {$rout2 > 2} {
						Inf "All Mixed Files Must Be Routed To Either Channel 1, Channel 2 Or Both"
						set OK 0
						break
					}
				}
				6 {
					set lev2 $item
				}
			}
			lappend nuline $item
			incr n
		}
		if {!$OK} {
			break
		}
		if {($n != 7) && ($n != 5)} {
			Inf "All Mixed Files Must Be Routed To Either Channel 1, Channel 2 Or Both"
			set OK 0
			break
		}
		if {$n == 5} {		;#	Routed to mono
			set nuline [lreplace $nuline 3 3]		;#	REmove routing info	
													;#	e.g. fnam.wav 0.0 1 1:1 1.0		OR		fnam.wav 0.0 1 1:2 1.0
													;# -->  fnam.wav 0.0 1 1.0				--> fnam.wav 0.0 2 1.0

			if {$chans == 1} {						;# Source is mono
				if {$rout1 == 1} {
					lappend nuline "L"				;#	fnam.wav 0.0 1 1.0	-->  fnam.wav 0.0 1 1.0 L
				} else {
					lappend nuline "R"				;#	fnam.wav 0.0 1 1.0	-->  fnam.wav 0.0 1 1.0 R
				}
			} else {								;#	Source is stereo
				if {$from1 == 1} {					;#	Using chan 1 only, to left 
					if {$rout1 == 1} {							;#	e;.g.	fnam.wav 0.0 2 1:1 1.0 -->  fnam.wav 0.0 2 1.0 (above)
						lappend nuline L  0.0 R					;#	-->		fnam.wav 0.0 2 1.0 L 0.0 R	i.e. channel 1 goes to left
					} else {						;#	Using chan 1 only, to right
						lappend nuline R  0.0 R					;#	-->		fnam.wav 0.0 2 1.0 R 0.0 R	i.e. channel 1 goes to right
					}
				} else {									
					set nuline [linsert $nuline 3 0.0 L]		;#	-->		fnam.wav 0.0 2 0.0 L 1.0	i.e. no contribution from left chan
					if {$rout1 == 1} {
						lappend nuline "L"						;#	-->		fnam.wav 0.0 2 0.0 L 1.0 L	i.e. channel 2 goes to left
					} else {
						lappend nuline "R"						;#	-->		fnam.wav 0.0 2 0.0 L 1.0 R	i.e. channel 2 goes to right
					}
				}
			}
		} else {
			if {$from1 != $from2} {		;#	Outputs from different channels
				if {$rout1 != $rout2} {	;#	Outputs to different channels		1:1 2:2 OR 1:2 2:1
					if {[string match $firstrout "1:1"]} {	;#	e.g.	fnam.wav 0.0 2 1:1 1.0 2:2 1.0
						set nuline [lreplace $nuline 3 3]	;#	-->		fnam.wav 0.0 2 1.0 2:2 1.0
						set nuline [linsert $nuline 4 "L"]	;#	-->		fnam.wav 0.0 2 1.0 L 2:2 1.0
						set nuline [lreplace $nuline 5 5]	;#	-->		fnam.wav 0.0 2 1.0 L 1.0
						lappend nuline "R"					;#	-->		fnam.wav 0.0 2 1.0 L 1.0 R
					} else {								;#	e.g.	fnam.wav 0.0 2 1:2 1.0 2:1 1.0
						set nuline [lreplace $nuline 3 3]	;#	-->		fnam.wav 0.0 2 1.0 2:2 1.0
						set nuline [linsert $nuline 4 "R"]	;#	-->		fnam.wav 0.0 2 1.0 R 2:2 1.0
						set nuline [lreplace $nuline 5 5]	;#	-->		fnam.wav 0.0 2 1.0 R 1.0
						lappend nuline "L"					;#	-->		fnam.wav 0.0 2 1.0 R 1.0 L
					}
				} else {				;#	Outputs to same channel
					if {$rout1 == 1} {						;#	e.g.	fnam.wav 0.0 2 1:1 1.0 2:1 1.0
						set nuline [lreplace $nuline 3 3]	;#	-->		fnam.wav 0.0 2 1.0 2:2 1.0
						set nuline [linsert $nuline 4 "L"]	;#	-->		fnam.wav 0.0 2 1.0 L 2:2 1.0
						set nuline [lreplace $nuline 5 5]	;#	-->		fnam.wav 0.0 2 1.0 L 1.0
						lappend nuline "L"					;#	-->		fnam.wav 0.0 2 1.0 L 1.0 L
					} else {							;#	e.g.	fnam.wav 0.0 2 1:2 1.0 2:2 1.0
						set nuline [lreplace $nuline 3 3]	;#	-->		fnam.wav 0.0 2 1.0 2:2 1.0
						set nuline [linsert $nuline 4 "R"]	;#	-->		fnam.wav 0.0 2 1.0 R 2:2 1.0
						set nuline [lreplace $nuline 5 5]	;#	-->		fnam.wav 0.0 2 1.0 R 1.0
						lappend nuline "R"					;#	-->		fnam.wav 0.0 2 1.0 R 1.0 R
					}
				}											;#	Outputs from same channel routed to both outputs
			} else {										;#	e.g.	fnam.wav 0.0 2 1:1 xxx 1:2 yyy
				if {$lev1 != $lev2} {
					if {!$warned} {
						set msg "At Line $linecnt Channel $from1 Is Routed To Both Output Channels.\n"	
						append msg "Will Calculate Appropriate Space Setting In Mixfile For This And Similar Lines.\n\n"
						append msg "Is This OK ??"
						set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
						if {$choice == "no"} {
							set OK 0
							break
						} else {
							set warned 1
						}
					}
					set totallevel [expr $lev1 + $lev2]			;#	e.g.	xxx = 1  yyy  = 0.5	totallevel = 1.5
					set pos [expr double($lev1)/double($totallevel)]	;#	e.g.	pos =  1/1.5 = 0.6666
					set pos [expr 1.0 - $pos]					;#	e.g.	pos = 0.3333	in range 0to1	
					set pos [expr ($pos * 2.0) - 1.0]			;#	e.g.	pos = -0.333	in range -1to+1
					set pos [DecPlaces $pos 3]
					set totallevel [DecPlaces [expr $totallevel/2.0] 3]
					set nuline [lreplace $nuline 3 end]			;#	-->		fnam.wav 0.0 2
					if {$from1 == 1} {							;#	e.g.	fnam.wav 0.0 2
						lappend nuline $totallevel $pos 0.0 R	;#	-->		fnam.wav 0.0 2 totallevel pos 0 R
					} else {
						lappend nuline 0  L  $totallevel $pos	;#	-->		fnam.wav 0.0 2 0 L totallevel pos
					}
				} else {
					set nuline [lreplace $nuline 3 end]			;#	-->		fnam.wav 0.0 2
					lappend nuline $lev1 C						;#	-->		fnam.wav 0.0 2 xxx C
				}
			}
		}
		lappend nulines $nuline
	}
	close $zit
	if {!$OK || ![info exists nulines]} {
		return
	}
	if [catch {open $ofnam "w"} zit] {
		Inf "Cannot Open File $ofnam To Write Mix Data"
		return
	}
	foreach nuline $nulines {
		puts $zit $nuline
	}
	close $zit
	FileToWkspace $ofnam 0 0 0 0 1
	Inf "File $ofnam Is On The Workspace"
	return
}

#-------  Create Resonance Tail on Multichannel file

proc MresTail {} {
	global prg_dun prg_abortd simple_program_messages CDPidrun CDPmaxId evv wl chlist pa mrestailff mrestailfflo mrestailffhi
	global pr_mrestail mrestailstt mrestailend mrestailgain mrestailmult mrestailechos mrestailbal mrestailfnam maxsamp_line done_maxsamp
	global mrestailgain_x mrestailmult_x mrestailechos_x mrestailbal_x origresfnam readonlyfg readonlybg last_outfile
	global mrestailstt_x mrestailend_x wstk mrestail_warned
 	set tailfnam $evv(DFLT_OUTNAME)
	set tailchanbas $tailfnam
	append tailchanbas 0
	append tailfnam 0 $evv(SNDFILE_EXT)
	set tailfenv $evv(DFLT_OUTNAME)
	append tailfenv 1 $evv(TEXT_EXT)
	set resfnam $evv(DFLT_OUTNAME)
	append resfnam 2 $evv(SNDFILE_EXT)
	set mixfnam $evv(DFLT_OUTNAME)
	append mixfnam 3 $evv(SNDFILE_EXT)
	set mixtxt $evv(DFLT_OUTNAME)
	append mixtxt 4 $evv(TEXT_EXT)
	set filtfnam $evv(DFLT_OUTNAME)
	append filtfnam 5 $evv(SNDFILE_EXT)
	set origresfnam $evv(DFLT_OUTNAME)
	append origresfnam 6 $evv(SNDFILE_EXT)
	set origmixfnam $evv(DFLT_OUTNAME)
	append origmixfnam 7 $evv(SNDFILE_EXT)

	set ilist [$wl curselection]
	if {[llength $ilist] != 1} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "Select A Soundfile"
			return
		}
		set fnam [lindex $chlist 0]
	} else {
		set i [lindex $ilist 0]
		if {$i == -1} {
			Inf "Select A Soundfile"
			return
		}
		set fnam [$wl get $i]
	}
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "Select A Soundfile"
		return
	}
	if {$pa($fnam,$evv(CHANS)) < 4} {
		Inf "Select A Multichannel Soundfile"
		return
	}
	set chans    $pa($fnam,$evv(CHANS))
	set duration $pa($fnam,$evv(DUR))

	set n 1
	while {$n <= $chans} {
		set chfnam($n) $tailchanbas
		append chfnam($n) "_c$n" $evv(SNDFILE_EXT)	;#	Temporary files for each extracted channel of multichan tail
		set chresfnam($n) $evv(MACH_OUTFNAME)		;#	Temporary file for each reverbd channel of multichan tail
		append chresfnam($n) $n $evv(SNDFILE_EXT)
		catch {[file delete $chfnam($n)]}
		catch {[file delete $chresfnam($n)]}
		incr n
	}
	set chmixfnam $evv(DFLT_OUTNAME)
	append chmixfnam [GetTextfileExtension mmx]		;#	Temporary file for eventual remix of reverbd tail-channels
	catch {[file delete $chmixfnam]}

	;#	CREATE INTERLEAVED REMIX-FILE OF REVERBD CHANNELS

	set line [list $chans]
	lappend lines $line
	set n 1
	set m $chans 
	set k 2
	while {$n <= $chans} {
		if {$m > $chans} {
			incr m [expr -$chans]
		}
		if {$k > $chans} {
			incr k [expr -$chans]
		}
		set line [list $chresfnam($n) 0.0 2 1:$m 1.0 2:$k 1.0]
		lappend lines $line
		incr n
		incr m
		incr k
	}
	if [catch {open $chmixfnam "w"} zit] {
		Inf "Cannot Open Temporary Mixfile $chmixfnam To Create Channel Mixing Data"
		return
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit

	set f .mrestail
	if [Dlg_Create $f "RESONATE TAIL OF MULTICHAN SOUND" "set pr_mrestail 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f00 [frame $f.00] 
		set f1 [frame $f.1] 
		set f1a [frame $f.1a  -bg $evv(POINT) -height 1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		set f4 [frame $f.4] 
		set f5 [frame $f.5] 
		set f6 [frame $f.6] 
		button $f0.ok -text "Create Tail" -command "set pr_mrestail 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f0.save -text "Save Output" -command "set pr_mrestail 4" -highlightbackground [option get . background {}]
		button $f0.savt -text "Save Tail Only" -command "set pr_mrestail 7" -highlightbackground [option get . background {}]
		button $f0.quit -text "Quit" -command "set pr_mrestail 0" -highlightbackground [option get . background {}]
		button $f0.help -text "Help" -command "ResTailHelp" -bg $evv(HELP) -highlightbackground [option get . background {}]
		pack $f0.ok $f0.help $f0.save $f0.savt -side left -padx 2
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		frame $f00.sv 
		button $f00.sv.1 -text "Select Segment" -command "SnackDisplay $evv(SN_TIMEPAIRS) mrestail 1 $fnam" -bd 2 -bg $evv(SNCOLOR) -width 14 -highlightbackground [option get . background {}]
		button $f00.sv.2 -text "Play Source" -command "PlaySndfile  $fnam 0" -width 14 -highlightbackground [option get . background {}]
		pack $f00.sv.1 $f00.sv.2 -side left -padx 2
		label $f00.ll -text "Select region to resonate, using \"Select Segment\"" -fg $evv(SPECIAL)
		pack $f00.sv $f00.ll -side top -pady 2
		pack $f00 -side top -pady 2
		button $f1.play -text "Play Output Mix" -command "set pr_mrestail 2" -highlightbackground [option get . background {}]
		button $f1.play2 -text "Play Res Tail Only" -command "set pr_mrestail 3" -highlightbackground [option get . background {}]
		menubutton $f1.filt -text "Filter Tail" -menu $f1.filt.menu -relief raised
		button $f1.rest -text "Restore Unfiltered Output" -command "set pr_mrestail 6" -highlightbackground [option get . background {}]
		set m [menu $f1.filt.menu -tearoff 0]
		$m add command -label "Lopas  Pass 3000 Stop 3500" -command "set mrestailff 3000; set pr_mrestail 5" -foreground black
		$m add command -label "Lopas  Pass 2000 Stop 2500" -command "set mrestailff 2000; set pr_mrestail 5" -foreground black
		$m add command -label "Lopas  Pass 1000 Stop 1500" -command "set mrestailff 1000; set pr_mrestail 5" -foreground black
		$m add command -label "Hipas  Pass 550 Stop 500"   -command "set mrestailff 550;  set pr_mrestail 5" -foreground black
		$m add command -label "Hipas  Pass 450 Stop 400"   -command "set mrestailff 450;  set pr_mrestail 5" -foreground black
		$m add command -label "Hipas  Pass 350 Stop 300"   -command "set mrestailff 350;  set pr_mrestail 5" -foreground black
		$m add command -label "Hipas  Pass 250 Stop 200"   -command "set mrestailff 250;  set pr_mrestail 5" -foreground black
		$m add command -label "Hipas  Pass 200 Stop 150"   -command "set mrestailff 200;  set pr_mrestail 5" -foreground black
		$m add command -label "Hipas  Pass 150 Stop 100"   -command "set mrestailff 150;  set pr_mrestail 5" -foreground black
		pack $f1.play $f1.play2 -side left -padx 2		
		pack $f1.rest $f1.filt -side right -padx 2
		pack $f1 -side top -fill x -expand true
		pack $f1a -side top -fill x -expand true -pady 4
		label $f2.ll -text "START of end-portion to resonate "
		entry $f2.e -textvariable mrestailstt -width 16
		label $f2.ll2 -text "END of end-portion to resonate "
		entry $f2.e2 -textvariable mrestailend -width 16
		pack $f2.ll $f2.e $f2.ll2 $f2.e2 -side left -padx 2
		pack $f2 -side top -pady 2 -anchor w
		label $f3.ll -text "Stadium size multiplier"
		entry $f3.e -textvariable mrestailmult -width 6
		pack $f3.ll $f3.e -side left -padx 2
		label $f3.ll2 -text "Number of echos"
		entry $f3.e2 -textvariable mrestailechos -width 6
		pack $f3.ll2 $f3.e2 -side left -padx 2
		label $f3.ll3 -text "Output Gain for Reverb creation "
		entry $f3.e3 -textvariable mrestailgain -width 16
		pack $f3.ll3 $f3.e3 -side left -padx 2
		pack $f3 -side top -pady 2 -anchor w
		label $f4.ll -text "Level of reverb in final mix "
		entry $f4.e -textvariable mrestailbal -width 16
		pack $f4.ll $f4.e -side left -padx 2
		pack $f4 -side top -pady 2 -anchor w
		label $f5.ll -text "Output Filename "
		entry $f5.e -textvariable mrestailfnam -width 40
		pack $f5.ll $f5.e -side left -padx 2
		pack $f5 -side top -pady 2 -fill x -expand true
		label $f6.ll -text "\"Control\" + \"Up\", \"Down\", \"Left\", \"Right\" arrows move between entry boxes." -fg $evv(SPECIAL)
		pack $f6.ll -side top -pady 4
		pack $f.6 -side top -pady 4
		wm resizable $f 1 1
		SetMostOfMrestail
		bind $f2.e  <Control-Right> {focus .mrestail.2.e2}
		bind $f2.e  <Control-Left>  {focus .mrestail.2.e2}
		bind $f2.e2 <Control-Left>  {focus .mrestail.2.e}
		bind $f2.e2 <Control-Right> {focus .mrestail.2.e}

		bind $f3.e  <Control-Right> {focus .mrestail.3.e2}
		bind $f3.e2 <Control-Right> {focus .mrestail.3.e3}
		bind $f3.e3 <Control-Right> {focus .mrestail.3.e}
		bind $f3.e  <Control-Left>  {focus .mrestail.3.e3}
		bind $f3.e2 <Control-Left>  {focus .mrestail.3.e}
		bind $f3.e3 <Control-Left>  {focus .mrestail.3.e2}

		bind $f4.e  <Control-Left>  {focus .mrestail.3.e}
		bind $f4.e  <Control-Right> {focus .mrestail.3.e2}
		bind $f5.e  <Control-Right> {focus .mrestail.3.e3}

		bind $f2.e  <Control-Down> {focus .mrestail.3.e}
		bind $f2.e2 <Control-Down> {focus .mrestail.3.e3}
		bind $f3.e  <Control-Down> {focus .mrestail.4.e}
		bind $f3.e2 <Control-Down> {focus .mrestail.4.e}
		bind $f3.e3 <Control-Down> {focus .mrestail.4.e}
		bind $f4.e  <Control-Down> {focus .mrestail.5.e}
		bind $f5.e  <Control-Down> {focus .mrestail.2.e}

		bind $f2.e  <Control-Up> {focus .mrestail.5.e}
		bind $f2.e2 <Control-Up> {focus .mrestail.5.e}
		bind $f3.e  <Control-Up> {focus .mrestail.2.e}
		bind $f3.e2 <Control-Up> {focus .mrestail.2.e}
		bind $f3.e3 <Control-Up> {focus .mrestail.2.e2}
		bind $f4.e  <Control-Up> {focus .mrestail.3.e}
		bind $f5.e  <Control-Up> {focus .mrestail.4.e}

		bind $f <Control-Key-s> {set pr_mrestail 4}
		bind $f <Control-Key-S> {set pr_mrestail 4}
		bind $f <Key-space> {set pr_mrestail 2}
		bind $f <Return> {set pr_mrestail 1}
		bind $f <Escape> {set pr_mrestail 0}
	}
	.mrestail.00.sv.1 config -command "SnackDisplay $evv(SN_TIMEPAIRS) mrestail 1 $fnam"
	.mrestail.00.sv.2 config -command "PlaySndfile  $fnam 0"
	set mrestailstt ""			;#	These params scrubbed on every call,
	set mrestailend ""			;#	to ensure values relevant to current src are set

	set mrestailfnam [file rootname [file tail $fnam]]
	append mrestailfnam "_revend"
	set pr_mrestail 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mrestail $f.2.e
	while {!$finished} {
		tkwait variable pr_mrestail
		switch -- $pr_mrestail {
			1 {
				if {[string length $mrestailfnam] <= 0} {
					Inf "No Output Filename Entered"
					continue
				}
				if {![ValidCDPRootname $mrestailfnam]} {
					continue
				}
				set outfnam [string tolower $mrestailfnam]
				append outfnam $evv(SNDFILE_EXT)
				if {[file exists $outfnam]} {
					Inf "File '$outfnam' Already Exists: Please Choose A Different Name"
					continue
				}
				if {[string length $mrestailgain] <= 0} {
					set msg "No Output Gain For Reverb Creation Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetMrestail
					}
					continue
				}
				if {![IsNumeric $mrestailgain] || ($mrestailgain <= 0.0) || ($mrestailgain > 1.0)} {
					Inf "Invalid Output Gain For Reverb Creation (Range  > 0.0 To  1.0)"
					continue
				}
				if {[string length $mrestailstt] <= 0} {
					set msg "No Tail Start Time Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetMrestail
					}
					continue
				}
				if {![IsNumeric $mrestailstt] || ($mrestailstt < 0.0) || ($mrestailstt >= $duration)} {
					Inf "Invalid Tail Start Time (Range  0.0 To < $duration)"
					continue
				}
				if {[string length $mrestailend] <= 0} {
					set msg "No Tail End Time Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetMrestail
					}
					continue
				}
				if {![IsNumeric $mrestailend] || ($mrestailend <= $mrestailstt)} {
					Inf "Invalid Tail End Time (Range  > $mrestailstt To $duration)"
					continue
				}
				if {$mrestailend > $duration} {
					set mrestailend $duration
				}
				if {[string length $mrestailmult] <= 0} {
					set msg "No Stadium Multiplier Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetMrestail
					}
					continue
				}
				if {![IsNumeric $mrestailmult] || ($mrestailmult < 0.1) || ($mrestailmult > 100)} {
					Inf "Invalid Stadium Multiplier (Range  0.1 To 100)"
					continue
				}
				if {[string length $mrestailechos] <= 0} {
					set msg "No Echo Count Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetMrestail
					}
					continue
				}
				if {![IsNumeric $mrestailechos] || ($mrestailechos < 2) || ($mrestailechos > 1000)} {
					Inf "Invalid Echo Count (Range  2 To 1000)"
					continue
				}
				if {[string length $mrestailbal] <= 0} {
					set msg "No Reverb Level Entered"
					append msg "\n\nSet All Previous Values ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "yes"} {
						SetMrestail
					}
					continue
				}
				if {![IsNumeric $mrestailbal] || ($mrestailbal <= 0.0) || ($mrestailbal > 1.0)} {
					Inf "Invalid Reverb Level (Range  > 0 To  1)"
					continue
				}
				set doenv 0
				set docut 0
				if {[info exists lastmrestailstt]} {
					if {($mrestailstt != $lastmrestailstt) || ($mrestailend != $lastmrestailend)} {
						set doenv 1
						set docut 1
					} 
				}
				if {![file exists $tailfenv]} {
					set doenv 1
				}
				if {![file exists $tailfnam]} {
					set docut 1
				}
				if {$doenv} {
					if {[file exists $tailfenv]} {
						if [catch {file delete $tailfenv} zit] {
							Inf "Cannot Delete Existing Temporary Envelope File '$tailfenv'"
							continue
						}
					}
					if {[file exists $tailfnam]} {
						if [catch {file delete $tailfnam} zit] {
							Inf "Cannot Delete Existing Temporary Cut File '$tailfnam'"
							continue
						}
					}
					if {[file exists $resfnam]} {
						if [catch {file delete $resfnam} zit] {
							Inf "Cannot Delete Existing Temporary Resonated File '$resfnam'"
							continue
						}
					}
					if [catch {open $tailfenv "w"} zit] {
						Inf "Cannot Open Temporary Envelope File '$tailfenv'"
						continue
					}
					set time 0.0
					set sttsplice [expr $mrestailstt - 0.003]
					if {$mrestailstt > 0.003} {
						set line "0.0 0.0"
						puts $zit $line
						set line $sttsplice
						append line " " 0.0
						puts $zit $line
					} else {
						set line "0.0 1.0"
						puts $zit $line
					}
					set line $mrestailstt
					append line " " 1.0
					puts $zit $line
					set line $mrestailend
					append line " " 1.0
					puts $zit $line
					set endsplice [expr $mrestailend + 0.003]
					set veryend [expr $duration + 1.0]
					if {$endsplice < $duration} {
						set line $endsplice
						append line " " 0.0
						puts $zit $line
						set line $veryend
						append line " " 0.0
						puts $zit $line
					} else {
						set line $veryend
						append line " " 1.0
						puts $zit $line
					}
					close $zit
					set lastmrestailstt $mrestailstt
					set lastmrestailend $mrestailend
				}
				if {$docut} {
					set cmd [file join $evv(CDPROGRAM_DIR) sfedit]
					lappend cmd cut 1 $fnam $tailfnam $mrestailstt $mrestailend -w3
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					Block "Cutting Tail"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Cut Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Cut Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					UnBlock
					if {![file exists $tailfnam]} {
						Inf "Failed To Cut Tail"
						continue
					}
				}
				set dores 0
				if {$docut} {
					set dores 1
				}
				if {[info exists lastmrestailgain]} {
					if {($mrestailgain != $lastmrestailgain) || ($mrestailechos != $lastmrestailechos) || ($mrestailmult != $lastmrestailmult)} {
						set dores 1
					} 
				}
				if {![file exists $resfnam] || [file exists $origmixfnam]} {	;#	i.e. either no resfile esists, or res file has been previously altered
					catch {file delete $origmixfnam}
					catch {file delete $origresfnam}
					set dores 1
				}
				set OK 1
				if {$dores} {
					if {[file exists $resfnam]} {
						if [catch {file delete $resfnam} zit] {
							Inf "Cannot Delete Existing Temporary Resonated File '$resfnam'"
							continue
						}
					}

					;#	DELETE ALL INTERMEDIATE REVERBD CHANNELS

					foreach zfnam [glob -nocomplain glob $evv(MACH_OUTFNAME)*] {
						if [catch {file delete $zfnam} zit] {
							Inf "Cannot Delete Intermediate Temporary File $zfnam"
							set OK 0
							break
						}
					}
					if {!$OK} {
						continue
					}

					Block "CREATING REVERB TAIL"

					if {![file exists $chfnam(1)]} {

					catch {unset badchans}

					;#	IF NOT ALREADY DONE SO, EXTRACT CHANNELS OF TAIL

						wm title .blocker "PLEASE WAIT:        EXTRACTING CHANNELS OF FILE TAIL"
						set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
						lappend cmd chans 2 $tailfnam
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Failed To Run Extraction Of Channels Of File Tail"
							catch {unset CDPidrun}
							UnBlock
							continue
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed To Extract Channels Of File Tail"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							UnBlock
							continue
						}
						set n 1
						set OK 1
						while {$n <= $chans} {
							if {![file exists $chfnam($n)]} {
								Inf "Failed To Extract Channel $n Of File Tail"
								set OK 0
								break
							}

							wm title .blocker "PLEASE WAIT:        FINDING MAX SAMPLE OF CHAN $n"
							set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
							if {![info exists mrestail_warned]} {
								set mrestail_warned 1
								if {[ProgMissing $cmd "'maxsamp2$evv(EXEC)' Is Not On Your System. Cannot Search For Maximum Samples In File."]} {
									set OK 0
									break
								}
							}
							catch {unset maxsamp_line}
							set done_maxsamp 0
							lappend cmd $chfnam($n)
							if [catch {open "|$cmd"} CDPmaxId] {
								Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
								set OK 0
								break
	   						} else {
	   							fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
							}
	 						vwait done_maxsamp
							if {![info exists maxsamp_line]} {
								lappend badchans $n
								set maxoutsamp 0.0
							} else {
								set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
							}

							;#	IF INPUT FILE IS (EFFECTIVELY) SILENT, JUST COPY IT TO (A STEREO) OUTPUT

							if {$maxoutsamp < $evv(FLTERR)} {
								wm title .blocker "PLEASE WAIT:        COPYING TOO QUIET CHANNEL $n"
								set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
								lappend cmd chans 5 $chfnam($n) $chresfnam($n)
								set prg_dun 0
								set prg_abortd 0
								catch {unset simple_program_messages}
								if [catch {open "|$cmd"} CDPidrun] {
									ErrShow "Failed To Make A Copy Of Channel $n"
									catch {unset CDPidrun}
									set OK 0
									break
								} else {
									fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
								}
								vwait prg_dun
								if {$prg_abortd} {
									set prg_dun 0
								}
								if {!$prg_dun} {
									set msg "Failed To Copy Channel $n"
									set msg [AddSimpleMessages $msg]
									ErrShow $msg
									set OK 0
									break
								}

								if {![file exists $chresfnam($n)]} {
									Inf "Failed To Copy Silent Channel $n To Output"
									set OK 0
									break
								}
							}
							incr n
						}
						if {!$OK} {
							UnBlock
							continue
						}
						if {[info exists badchans]} {
							set msg "The Channel"
							if {[llength $badchans] > 1} {
								append msg "s"
							}
							foreach zog $badchans {
								append msg " $zog"
							}
							if {[llength $badchans] > 1} {
								append msg " Were Found To Be Silent"
							} else {
								append msg " Was Found To Be Silent"
							}
							Inf $msg
						}
					}

					;#	NOW RESONATE EACH CHANNEL

					set n 1
					set chmaxsamp 0.0
					while {$n <= $chans} {

						;#	IF THE INPUT CHANNEL WAS SILENT, WE'VE ALREADY MADE "chresfnam(n) BY COPYING INPUT TO OUTPUT

						if {![file exists $chresfnam($n)] } {

							set cmd [file join $evv(CDPROGRAM_DIR) modify]
							lappend cmd revecho 3 $chfnam($n) $chresfnam($n) -g$mrestailgain -r1.0 -s$mrestailmult -e$mrestailechos
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							wm title .blocker "PLEASE WAIT:        RESONATING TAIL OF CHANNEL $n"
							if [catch {open "|$cmd"} CDPidrun] {
								ErrShow "Failed To Run Reverb Process On Tail Of Channel $n"
								catch {unset CDPidrun}
								set OK 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Failed To Resonate Tail Of Channel $n"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
								set OK 0
								break
							}
							if {![file exists $chresfnam($n)]} {
								Inf "Failed To Generate Resonant Tail Of Channel $n"
								set OK 0
								break
							}

							wm title .blocker "PLEASE WAIT:        FINDING MAX SAMPLE OF RESONATED CHAN $n"
							set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
							catch {unset maxsamp_line}
							set done_maxsamp 0
							lappend cmd $chresfnam($n)
							if [catch {open "|$cmd"} CDPmaxId] {
								Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
								UnBlock
								continue
	   						} else {
	   							fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
							}
	 						vwait done_maxsamp
							if {![info exists maxsamp_line]} {
								set maxoutsamp 0.0
							} else {
								set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
							}
							if {$maxoutsamp > $chmaxsamp} {
								set chmaxsamp $maxoutsamp
							}
						}
						incr n
					}
					if {!$OK} {
						UnBlock
						continue
					}

					set lastmrestailgain $mrestailgain
					set lastmrestailechos $mrestailechos
					set lastmrestailmult $mrestailmult 


					;#	CHECK MAXIMUM LEVEL OF (all) OUTPUTS

					if {$chmaxsamp < $evv(FLTERR)} {
						Inf "Insufficient Level In Output File"
						UnBlock
						continue
					} elseif {$chmaxsamp > 0.98} {
						Inf "Output Level Too High : Reduce Gain"
						UnBlock
						continue
					}
				}

				;#	RECONSTRUCT THE MULTICHANNEL TAIL, ADJUSTING LEVEL IF NESS

				set gain 1.0
				set OK2 0
				set OK3 0
				while {!$OK2} {
					if {[file exists $resfnam]} {
						if [catch {file delete $resfnam} zit] {
							Inf "Cannot Delete Existing Multichan Resonant Tail ($resfnam)"
							set OK 0
							break
						}
					}
					set cmd [file join $evv(CDPROGRAM_DIR) newmix]
					lappend cmd multichan $chmixfnam $resfnam -g$gain
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        CREATING MULTICHAN RES TAIL : GAIN $gain"
					if [catch {open "|$cmd"} CDPidrun] {
						Inf "Cannot Create Multichan Resonant Tail"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Create Multichan Resonant Tail : Gain $gain"
						set msg [AddSimpleMessages $msg]
						Inf $msg
						catch {close $CDPidrun}
						set OK 0
						break
					}
					if {![file exists $resfnam]} {
						set msg " Creating Multichan Resonant Tail Failed: "
						set msg [AddSimpleMessages $msg]
						Inf $msg
						catch {close $CDPidrun}
						set OK 0
						break
					}
					wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF RESONATED TAIL MIX"
					set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
					catch {unset maxsamp_line}
					set done_maxsamp 0
					lappend cmd $resfnam
					if [catch {open "|$cmd"} CDPmaxId] {
						Inf "Failed To Run 'maxsamp2$evv(EXEC)'"
						UnBlock
						continue
	   				} else {
	   					fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					}
	 				vwait done_maxsamp
					if {![info exists maxsamp_line]} {
						Inf "Cannot Retrieve Maximum Sample Of Resonated Tail Mix"
						set OK 0
						break
					}
					if {$OK3} {
						break
					}
					set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
					if {$maxoutsamp <= 0.0} {
						Inf "Resonated tail mix has zero level"
						set OK 0
						break
					}
					if {$maxoutsamp > 0.98} {							;#	Gain close to 1.0 indicates output has probably overloadad
						set gain [expr $gain * 0.1]						;#	Reduce gain by factor of ten and re-run

					} elseif {($maxoutsamp < 0.95) && ($gain < 1.0)} {	;#	If gain has been adjusted, but maxsamp now below max
						set gain [expr (0.95/$maxoutsamp) * $gain]		;#	reset gain to give a maximal non-distorted output
						set OK3 1										;#	and force loop-exit after next pass
					} else {
						set OK2 1										;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
					}
				}
				if {!$OK} {
					UnBlock
					continue
				}
				if {[file exists $mixtxt]} {
					if [catch {file delete $mixtxt} zit] {
						Inf "Cannot Delete Existing Temporary Mix Data File '$mixtxt'"
						UnBlock
						continue
					}
				}
				if {$mrestailbal >= 1.0} {
					if [catch {file delete $mixfnam} zit] {
						Inf "Cannot Delete Existing Output Mix '$mixfnam'"
						UnBlock
						continue
					}
					if [catch {file copy $resfnam $mixfnam} zit] {
						Inf "Cannot Copy Resonance Mix To Output"
						UnBlock
						continue
					}
					if {[DoParse $resfnam 0 0 0] <= 0} {
						UnBlock
						continue
					}
					set mixdur $pa($resfnam,$evv(DUR))
				} else {
					set makemix 0
					if {[info exists lastmrestailbal] && ($lastmrestailbal != $mrestailbal)} {
						set makemix 1
					}
					if {![file exists $mixtxt]} {
						set makemix 1
					}
					wm title .blocker "PLEASE WAIT:        CREATING AND CHECKING REVERB MIX"
					if {$makemix} {
						if [catch {open $mixtxt "w"} zit] {
							Inf "Cannot Open Temporary Mix Data File '$mixtxt'"
							UnBlock
							continue
						}
						set line [list $chans]
						puts $zit $line
						set level [expr 1.0 - $mrestailbal]
						set line [list $fnam 0.0 $chans]
						set n 1
						while {$n <= $chans} {
							lappend line "$n:$n" $level
							incr n
						}
						puts $zit $line
						set line [list $resfnam $mrestailstt $chans]
						set n 1
						while {$n <= $chans} {
							lappend line "$n:$n" $mrestailbal
							incr n
						}
						puts $zit $line
						close $zit
						set lastmrestailbal $mrestailbal
					}
					if {[DoParse $mixtxt 0 0 0] <= 0} {
						UnBlock
						continue
					}
					set mixdur $pa($mixtxt,$evv(DUR))
					if {[file exists $mixfnam]} {
						if [catch {file delete $mixfnam} zit] {
							Inf "Cannot Delete Existing Temporary Mix Output File '$mixfnam'"
							UnBlock
							continue
						}
					}
					set cmd [file join $evv(CDPROGRAM_DIR) newmix]
					lappend cmd multichan $mixtxt $mixfnam -g1.0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        MIXING RESONANCE TO ORIGINAL"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Run Mix-In Of Resonant Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Mix-In Resonant Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					if {![file exists $mixfnam]} {
						Inf "Failed To Create Mix With Resonant Tail"
						UnBlock
						continue
					}
				}
				if {[file exists $mixfnam]}  {
					if {[file exists $origmixfnam]}  {
						catch {file delete $origmixfnam}
					}
					catch {file copy $mixfnam $origmixfnam}
				}
				UnBlock
			}
			2 {	;#	PLAY
				if {![file exists $mixfnam]} {
					Inf "No Output File To Play"
					continue
				}
				PlaySndfile $mixfnam 0
			}
			3 {	;#	PLAY
				if {![file exists $resfnam]} {
					Inf "No Resonant Tail To Play"
					continue
				}
				PlaySndfile $resfnam 0
			}
			4 { ;#	SAVE
				if {![file exists $mixfnam]} {
					Inf "No Output File To Save"
					continue
				}
				if [catch {file rename $mixfnam $outfnam} zit] {
					Inf "Cannot Rename The Output File"
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					set last_outfile $outfnam
					set msg "Tail Resonated File '$outfnam' Is On The Workspace"
				}
				set mrestailgain_x $mrestailgain
				set mrestailmult_x $mrestailmult
				set mrestailechos_x $mrestailechos
				set mrestailbal_x $mrestailbal
				set mrestailstt_x $mrestailstt
				set mrestailend_x $mrestailend
				set finished 1
			} 
			7 { ;#	SAVE TAIL
				if {![file exists $resfnam]} {
					Inf "No Output File To Save"
					continue
				}
				if [catch {file rename $resfnam $outfnam} zit] {
					Inf "Cannot Rename The Output File"
					continue
				}
				if {[FileToWkspace $outfnam 0 0 0 0 1] > 0} {
					set last_outfile $outfnam
					set msg "Resonated Tail, '$outfnam', Is On The Workspace"
				}
				set mrestailgain_x $mrestailgain
				set mrestailmult_x $mrestailmult
				set mrestailechos_x $mrestailechos
				set mrestailbal_x $mrestailbal
				set mrestailstt_x $mrestailstt
				set mrestailend_x $mrestailend
				set finished 1
			} 
			5 { ;# FILTER
				if {![file exists $resfnam]} {
					Inf "No Resonance File To Filter"
					continue
				}
				if {[file exists $filtfnam]} {
					if [catch {file delete $filtfnam} zit] {
						Inf "Cannot Delete Existing Filter File"
						continue
					}
				}
				if {[file exists $origresfnam]} {
					if [catch {file delete $origresfnam} zit] {
						Inf "Cannot Delete Backup File"
						continue
					}
				}
				if [catch {file copy $resfnam $origresfnam} zit] {
					Inf "Cannot Backup Existing Resonance File"
					continue
				}
				if [catch {file rename $resfnam $filtfnam} zit] {
					Inf "Cannot Move Existing Resonance File For Filtering"
					continue
				}
				switch -- $mrestailff {
					3000 {
						set mrestailfflo 3000 
						set mrestaillfhi 3500
					}
					2000 {
						set mrestailfflo 2000 
						set mrestaillfhi 2500
					}
					1000 {
						set mrestailfflo 1000 
						set mrestaillfhi 1500
					}
					550 {
						set mrestailfflo 550 
						set mrestaillfhi 500
					}
					450 {
						set mrestailfflo 450 
						set mrestaillfhi 400
					}
					350 {
						set mrestailfflo 350 
						set mrestaillfhi 300
					}
					250 {
						set mrestailfflo 250 
						set mrestaillfhi 200
					}
					200 {
						set mrestailfflo 200 
						set mrestaillfhi 150
					}
					150 {
						set mrestailfflo 150 
						set mrestaillfhi 100
					}
				}
				set cmd [file join $evv(CDPROGRAM_DIR) filter]
				lappend cmd lohi 1 $filtfnam $resfnam -96 $mrestailfflo $mrestaillfhi -t0 -s1
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				Block "Filtering Output"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed To Filter Resonance File"
					catch {file rename $filtfnam $resfnam}
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed To Filter Resonance File"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					catch {file delete $filtfnam}
					catch {file delete $resfnam}
					catch {file rename $origresfnam $resfnam}
					UnBlock
					continue
				}
				if {![file exists $resfnam]} {
					Inf "Failed To Filter Resonance File"
					catch {file delete $filtfnam}
					catch {file rename $origresfnam $resfnam}
					UnBlock
					continue
				}
				catch {file delete $origresfnam}
				catch {file delete $mixfnam}
				if {![file exists $mixtxt]} {
					if [catch {file copy $resfnam $mixfnam} zit] {
						Inf "Cannot Copy Resonance Mix To Output"
						continue
					}
					if {[DoParse $resfnam 0 0 0] <= 0} {
						continue
					}
					set mixdur $pa($resfnam,$evv(DUR))
				} else {					
					set cmd [file join $evv(CDPROGRAM_DIR) newmix]
					lappend cmd multichan $mixtxt $mixfnam -g1.0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					wm title .blocker "PLEASE WAIT:        MIXING RESONANCE TO ORIGINAL"
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Failed To Mix-In Resonant Tail"
						catch {unset CDPidrun}
						UnBlock
						continue
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Failed To Mix-In Resonant Tail"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						UnBlock
						continue
					}
					UnBlock
					if {![file exists $mixfnam]} {
						Inf "Failed To Mix-In Resonant Tail"
						continue
					}
				}
			}
			6 {
				if {![file exists $origmixfnam]} {
					Inf "No Previous File To Restore"
					continue
				}
				if [catch {file delete $mixfnam} zit] {
					Inf "Cannot Delete Existing Output"
					continue
				}
				if [catch {file copy $origmixfnam $mixfnam} zit] {
					Inf "Cannot Retrieve Original Output"
					continue
				}
				Inf "Original Output Restored"
			}
			0 {
				break
			}
		}
	}
	if {[info exists pa($mixtxt,$evv(DUR))]} {
		PurgeArray $mixtxt
	}
	if {[info exists pa($resfnam,$evv(DUR))]} {
		PurgeArray $mixtxt
	}
	DeleteAllTemporaryFilesWhichAreNotCDPOutput all 0
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc SaveMrestailVals {} {
	global mrestailgain_x mrestailmult_x mrestailechos_x mrestailbal_x mrestailstt_x mrestailend_x evv
	set fnam [file join $evv(URES_DIR) mrestail$evv(CDP_EXT)]
	if {[info exists mrestailgain_x] && [info exists mrestailmult_x] && [info exists mrestailechos_x] && [info exists mrestailbal_x]} {
		if [catch {open $fnam "w"} zit] {
			Inf "Cannot Save Tail Resonance Values"
			return
		}
		puts $zit $mrestailgain_x
		puts $zit $mrestailmult_x
		puts $zit $mrestailechos_x
		puts $zit $mrestailbal_x
		puts $zit $mrestailstt_x 
		puts $zit $mrestailend_x
		close $zit
	}
}

proc LoadMrestailVals {} {
	global mrestailgain_x mrestailmult_x mrestailechos_x mrestailbal_x mrestailstt_x mrestailend_x evv
	set fnam [file join $evv(URES_DIR) mrestail$evv(CDP_EXT)]
	if {[file exists $fnam]} {
		if [catch {open $fnam "r"} zit] {
			Inf "Cannot Load Tail Resonance Values"
			return
		}
		set cnt 0
		while {[gets $zit line] >= 0} {
			switch -- $cnt {
				0 { set mrestailgain_x $line }
				1 { set mrestailmult_x $line }
				2 { set mrestailechos_x $line }
				3 { set mrestailbal_x $line }
				4 { set mrestailstt_x $line }
				5 { set mrestailend_x $line }
			}
			incr cnt
		}
		close $zit
		if {$cnt != 6} {
			set baddata 1
		} elseif {![IsNumeric $mrestailgain_x] || ![IsNumeric $mrestailmult_x] || ![IsNumeric $mrestailechos_x] \
			   || ![IsNumeric $mrestailbal_x]  || ![IsNumeric $mrestailstt_x]  || ![IsNumeric $mrestailend_x]} {
			set baddata 1
		} elseif {($mrestailgain_x <= 0.0) || ($mrestailgain_x > 1.0)} {
			set baddata 1
		} elseif {($mrestailmult_x < 0.1) || ($mrestailmult_x > 100)} {
			set baddata 1
		} elseif {($mrestailechos_x <= 2) || ($mrestailechos_x > 1000)} {
			set baddata 1
		} elseif {($mrestailbal_x <= 0.0) || ($mrestailbal_x > 1.0)} {
			set baddata 1
		} elseif {($mrestailstt_x < 0.0) || ($mrestailstt_x >= $mrestailend_x)} {
			set baddata 1
		}
		if {[info exists baddata]} {
			Inf "Corrupted Tail-Resonance Data In File '$fnam'"
			catch {unset mrestailgain_x}
			catch {unset mrestailmult_x}
			catch {unset mrestailechos_x}
			catch {unset mrestailbal_x}
			catch {unset mrestailstt_x}
			catch {unset mrestailend_x}
			catch {file delete $fnam} zit
		}
	}
}

proc SetMrestail {} {
	global mrestailgain mrestailgain_x mrestailmult mrestailmult_x mrestailechos mrestailechos_x  mrestailbal mrestailbal_x
	global mrestailstt_x mrestailend_x mrestailstt mrestailend

	if [info exists mrestailgain_x] {
		set mrestailgain $mrestailgain_x
	} 			
	if [info exists mrestailmult_x] {
		set mrestailmult $mrestailmult_x
	}
	if [info exists mrestailechos_x] {
		set mrestailechos $mrestailechos_x
	}			
	if [info exists mrestailbal_x] {
		set mrestailbal $mrestailbal_x
	}
	if [info exists mrestailstt_x] {
		set mrestailstt $mrestailstt_x
	}
	if [info exists mrestailend_x] {
		set mrestailend $mrestailend_x
	}
}

proc SetMostOfMrestail {} {
	global mrestailgain mrestailgain_x mrestailmult mrestailmult_x mrestailechos mrestailechos_x  mrestailbal mrestailbal_x

	if [info exists mrestailgain_x] {
		set mrestailgain $mrestailgain_x
	} else {
		set mrestailgain ""
	}
	if [info exists mrestailmult_x] {
		set mrestailmult $mrestailmult_x
	} else {
		set mrestailmult ""
	}
	if [info exists mrestailechos_x] {
		set mrestailechos $mrestailechos_x
	} else {			
		set mrestailechos ""
	}
	if [info exists mrestailbal_x] {
		set mrestailbal $mrestailbal_x
	} else {
		set mrestailbal ""
	}
}


#---- Put input file set onto successive channels around a ring

proc MonoInject {} {
	global chlist wl evv pa pr_moninj minject readonlyfg last_outfile

	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
	} else {
		set ilist [$wl curselection]
		if {[llength $ilist] == 1} {
			set fnam [$wl get $i]
		}
	}
	if {![info exists fnam]} {
		Inf "SELECT A SINGLE SOUNDFILE"
		return
	}
	set totchans 0
	if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
		Inf "SELECTED FILE IS NOT A SOUNDFILE"
		return
	}
	set minject(ichans) $pa($fnam,$evv(CHANS))
	if {$minject(ichans) > 2} {
		Inf "SELECTED FILE IS NEITHER MONO NOR STEREO"
		return
	}
	set f .minject	
	if [Dlg_Create $f "INJECT MONO TO MULTICHAN SPACE" "set pr_moninj 0" -borderwidth $evv(SBDR)] {
		set f0 [frame $f.0] 
		set f1 [frame $f.1] 
		set f2 [frame $f.2] 
		set f3 [frame $f.3] 
		button $f0.ok -text "Mix" -command "set pr_moninj 1" -bg $evv(EMPH)
		button $f0.quit -text "Abandon" -command "set pr_moninj 0"
		pack $f0.ok -side left
		pack $f0.quit -side right
		pack $f0 -side top -fill x -expand true
		frame $f.00
		entry $f.00.ee -textvariable minject(ochans) -width 4 -state readonly -fg $readonlyfg
		label $f.00.ll -text "Output Channel Count"
		set minject(ochans) 8
		pack $f.00.ee $f.00.ll -side left
		pack $f.00 -side top -fill x -expand true -pady 2
		label $f.000 -text "Use \"Up\" and \"Down\" Arrows to change value" -fg $evv(SPECIAL)
		pack $f.000 -side top -fill x -expand true
		entry $f1.et1 -textvariable minject(ofnam) -width 24
		label $f1.t1 -text "Mixfile name"
		pack $f1.et1 $f1.t1 -side left
		pack $f1 -side top -fill x -expand true -pady 2
		button $f2.mix1 -text "mix1" -command "set minject(ofnam) mix1"
		button $f2.mix2 -text "mix2" -command "set minject(ofnam) mix2"
		button $f2.mixc -text "current_mix" -command "set minject(ofnam) current_mix"
		pack $f2.mix1 $f2.mix2 $f2.mixc -side left -padx 2
		pack $f2 -side top -fill x -expand true -pady 2
		entry $f3.ii -textvariable minject(inj) -width 48
		label $f3.ll -text "Inject into channels .."
		pack $f3.ll $f3.ii -side left -padx 2
		pack $f3 -side top -fill x -expand true -pady 2
		label $f.4 -text "List of channels to inject into, separated by spaces." -fg $evv(SPECIAL)
		pack $f.4 -side top -fill x -expand true -pady 2
		label $f.5 -text "For stereo input, need an even number of injection channels" -fg $evv(SPECIAL)
		pack $f.5 -side top -fill x -expand true -pady 2
		label $f.6 -text "with injects for left input BEFORE injects for right input" -fg $evv(SPECIAL)
		pack $f.6 -side top -fill x -expand true -pady 2

		wm resizable $f 0 0
		bind $f <Up>	{IncrMinject 0}
		bind $f <Down>	{IncrMinject 1}
		bind $f <Return> {set pr_moninj 1}
		bind $f <Escape> {set pr_moninj 0}
	}
	if {$minject(ichans) == 1} {
		wm title $f "INJECT MONO TO MULTICHAN SPACE"
	} else {
		wm title $f "INJECT STEREO TO MULTICHAN SPACE"
	}
	set pr_moninj 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_moninj $f.1.et1
	while {!$finished} {
		tkwait variable pr_moninj
		if {$pr_moninj} {
			if {([string length $minject(ochans)] <= 0) || ![IsNumeric $minject(ochans)] || ![regexp {^[0-9]+$} $minject(ochans)] || ($minject(ochans) < [expr $minject(ichans) + 1]) || ($minject(ochans) > 16)} {
				Inf "INVALID FILE OUTCHANNEL COUNT ([expr $minject(ichans) + 1] to 16)"
				return
			}
			if {![ValidCDPRootname $minject(ofnam)]} {
				continue
			}
			set ofnam [string tolower $minject(ofnam)]
			append ofnam [GetTextfileExtension mmx]
			if {[file exists $ofnam]} {
				Inf "FILE $ofnam ALREADY EXISTS: PLEASE CHOOSE A DIFFERENT NAME"
				continue
			}
			set chaninj_data [ReadInjectionData $minject(inj)]
			if {[llength $chaninj_data] <= 0} {
				continue
			}
			if [catch {open $ofnam "w"} zit] {
				Inf "CANNOT OPEN FILE $ofnam TO CREATE MIXFILE"
				continue
			}
			puts $zit $minject(ochans)
			set line $fnam
			if {$minject(ichans) == 1} {
				lappend line 0.0 1
				foreach chan $chaninj_data {
					set rout "1:"
					append rout $chan
					lappend line $rout
					lappend line 1.0
				}
			} else {	;#STEREO
				lappend line 0.0 2
				set sublen [llength $chaninj_data]
				set sublen [expr $sublen/2]
				set cnt 0
				foreach chan $chaninj_data {
					if {$cnt < $sublen} {
						set rout "1:"
					} else {
						set rout "2:"
					}
					append rout $chan
					lappend line $rout
					lappend line 1.0
					incr cnt
				}
			}
			puts $zit $line		
			close $zit
			FileToWkspace $ofnam 0 0 0 0 1
			Inf "FILE $ofnam IS ON THE WORKSPACE"
			set last_outfile $ofnam
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc IncrMinject {down} {
	global minject

	if {$down} {
		if {$minject(ochans) > 2} {
			incr minject(ochans) -1
		}
	} else {
		if {$minject(ochans) < 16} {
			incr minject(ochans)
		}
	}
}


proc ReadInjectionData {str} {
	global minject

	set str [string trim $str]
	if {[string length $str] <= 0} {
		Inf "NO INJECTION LIST ENTERED"
		return {}
	}
	set str [split $str]
	set cnt 0
	foreach item $str {
		set item [string trim $item]
		if {([string length $item] <= 0)} {
			continue
		}
		if {![IsNumeric $item] || ![regexp {^[0-9]+$} $item] || ($item < 1) || ($item > $minject(ochans))} {
			Inf "INVALID INJECTION-CHANNEL '$item' IN INJECTION LIST"
			return {}
		} else {
			lappend olist $item
			incr cnt
		}
	}
	if {$cnt <= 0} {
		Inf "NO INJECTION LIST ENTERED"
		return {}
	}
	if {$minject(ichans) > 1} {
		if {![IsEven $cnt]} {
			Inf "NEED AN EVEN NUMBER OF INJECTION CHANNELS, FOR A STEREO INPUT FILE"
			return {}
		}
		set sublen [expr $cnt/2]
		set sublen_less_one [expr $sublen - 1]
		set n 0
		while {$n < $sublen_less_one} {
			set m $n
			incr m
			while {$m < $sublen} {
				if {[lindex $olist $n] == [lindex $olist $m]} {
					Inf "DUPLICATED INJECTION CHANNEL ([lindex $olist $n]) FOR LEFT INPUT"
					return {}
				}
				incr m
			}
			incr n
		}
		set n $sublen
		set cnt_less_one [expr $cnt - 1]
		while {$n < $cnt_less_one} {
			set m $n
			incr m
			while {$m < $cnt} {
				if {[lindex $olist $n] == [lindex $olist $m]} {
					Inf "DUPLICATED INJECTION CHANNEL ([lindex $olist $n]) FOR RIGHT INPUT"
					return {}
				}
				incr m
			}
			incr n
		}
	} else {
		set n 0
		set cnt_less_one [expr $cnt - 1]
		while {$n < $cnt_less_one} {
			set m $n
			incr m
			while {$m < $cnt} {
				if {[lindex $olist $n] == [lindex $olist $m]} {
					Inf "DUPLICATED INJECTION CHANNEL ([lindex $olist $n])"
					return {}
				}
				incr m
			}
			incr n
		}
	}
	return $olist
}

#################
# REVERB VERGES #
#################

proc ReverbdVerges {} {
	global chlist pa evv reverg prg_dun prg_abortd simple_program_messages CDPidrun CDPmaxId pr_reverg maxsamp_line done_maxsamp


	if {![info exists chlist] || ([llength $chlist] != 1)} {
		Inf "Select a mono soundfile"
		return
	}
	set infnam [lindex $chlist 0]
	if {($pa($infnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($infnam,$evv(CHANS)) != 1)} {
		Inf "Select a mono soundfile"
		return
	}
	set vrgfile $evv(DFLT_OUTNAME)
	append vrgfile 0 $evv(SNDFILE_EXT)
	set atkfile $evv(DFLT_OUTNAME)
	append atkfile 1 $evv(SNDFILE_EXT)
	set revfile $evv(DFLT_OUTNAME)
	append revfile 2 $evv(SNDFILE_EXT)
	set mixout $evv(DFLT_OUTNAME)
	append mixout 3 $evv(SNDFILE_EXT)
	set mixfile $evv(DFLT_OUTNAME)
	append mixfile 0 $evv(TEXT_EXT)
	set timesfile $evv(DFLT_OUTNAME)
	append timesfile 1 $evv(TEXT_EXT)

	DeleteAllTemporaryFiles

	set f .reverg	
	if [Dlg_Create $f "REVERBD VERGES" "set pr_reverg 0" -borderwidth $evv(SBDR)] {
		frame $f.0
		frame $f.9
		set reverg(txt) [text $f.9.t -setgrid true -wrap word -width 76 -height 8 \
		-xscrollcommand "$f.9.sx set" -yscrollcommand "$f.9.sy set"]
		scrollbar $f.9.sy -orient vert  -command "$f.9.t yview"
		scrollbar $f.9.sx -orient horiz -command "$f.9.t xview"
		pack $f.9.t -side left -fill both -expand true
		pack $f.9.sy -side right -fill y
		button $f.0.ok -text "Make Reverbd Verges" -command "set pr_reverg 1" -bg $evv(EMPH) -highlightbackground [option get . background {}]
		button $f.0.help -text "Help" -command "VergesHelp" -width 10 -bg $evv(HELP) -highlightbackground [option get . background {}]
		button $f.0.quit -text "Abandon" -command "set pr_reverg 0" -highlightbackground [option get . background {}]
		pack $f.0.ok $f.0.help -side left -padx 4
		pack $f.0.quit -side right
		pack $f.0 -side top -fill x -expand true
		label $f.a -text "Verge parameters"
		label $f.b -text "Reverb parameters"
		frame $f.1
		entry $f.1.e -textvariable reverg(transpos) -width 24
		label $f.1.ll -text "Verge Semitone-Transposition (Range: -24 to 24)"
		button $f.1.save -text "SAVE All-Parameters as Patch" -command SaveRevergPatch -width 28 -highlightbackground [option get . background {}]
		pack $f.1.e $f.1.ll  -side left -padx 2
		pack $f.1.save -side right
		frame $f.2
		entry $f.2.e -textvariable reverg(slope) -width 24
		label $f.2.ll -text "Verge Slope (Range 1 to 8)"
		button $f.2.load -text "LOAD All-Parameters Patch" -command LoadRevergPatch -width 28 -highlightbackground [option get . background {}]
		pack $f.2.e $f.2.ll  -side left -padx 2
		pack $f.2.load -side right
		frame $f.3
		entry $f.3.e -textvariable reverg(dur) -width 24
		label $f.3.ll -text "Verge Duration in mS (Range 20 to 1000)"
		button $f.3.clear -text "CLEAR All Parameters" -command ClearRevergPatch -width 28 -highlightbackground [option get . background {}]
		pack $f.3.e $f.3.ll  -side left -padx 2
		pack $f.3.clear -side right
		frame $f.4
		entry $f.4.e -textvariable reverg(rolloff) -width 24
		label $f.4.ll -text "Level reduction with distance (Range 0.003 to 1)"
		pack $f.4.e $f.4.ll  -side left -padx 2
		frame $f.5
		entry $f.5.e -textvariable reverg(size) -width 24
		label $f.5.ll -text "Stadium size Multiplier (Range 0.001 to 100)"
		pack $f.5.e $f.5.ll  -side left -padx 2
		frame $f.6
		entry $f.6.e -textvariable reverg(echos) -width 24
		label $f.6.ll -text "Echo count (Range 2 to 1000)"
		pack $f.6.e $f.6.ll  -side left -padx 2
		frame $f.7
		entry $f.7.e -textvariable reverg(rlevel) -width 24
		label $f.7.ll -text "Level of reverbd attacks relative to src (Range 0.01 to 100)"
		pack $f.7.e $f.7.ll  -side left -padx 2
		frame $f.11
		label $f.11.0 -text "Verge timings"
		label $f.11.1 -text "Either: select a file, and load times from it OR: create times in \"sound view\" above" -fg $evv(SPECIAL)
		label $f.11.2 -text "(and possibly save these times to a named file)" -fg $evv(SPECIAL)
		pack $f.11.0 $f.11.1 $f.11.2 -side top
		frame $f.10
		entry $f.10.e -textvariable reverg(times)
		label $f.10.ll -text "Filename for verge times"
		button $f.10.b1 -text "Save times"  -command SaveVergeTimes -width 12 -highlightbackground [option get . background {}]
		button $f.10.b2 -text "Load times" -command LoadVergeTimes -width 12 -highlightbackground [option get . background {}]
		button $f.10.b3 -text "Select file" -command FindVergeTimes -width 12 -highlightbackground [option get . background {}]
		button $f.10.v -text "Sound View" -command "SnackDisplay $evv(SN_TIMESLIST) reverg $evv(TIME_OUT) 1" -bg $evv(SNCOLOR) -width 12 -highlightbackground [option get . background {}]
		pack $f.10.e $f.10.ll $f.10.b3 $f.10.b2 $f.10.v $f.10.b1 -side left -padx 2
		pack $f.11 $f.10 -side top -pady 2 -fill x -expand true -anchor w
		pack $f.9 -side top -pady 2 -fill x -expand true -anchor w
		pack $f.a -side top -pady 4 -anchor w
		pack $f.1 $f.2 $f.3 -side top -pady 2 -fill x -expand true -anchor w
		pack $f.b -side top -pady 4 -anchor w
		pack $f.4 $f.5 $f.6 $f.7 -side top -pady 2 -fill x -expand true -anchor w
		label $f.8 -text "OUTFILE NAME"
		entry $f.8e -textvariable reverg(oname) -width 24
		pack $f.8 $f.8e -side top -pady 2 -anchor w

		bind $f.1.e <Down> {focus .reverg.2.e}
		bind $f.2.e <Down> {focus .reverg.3.e}
		bind $f.3.e <Down> {focus .reverg.4.e}
		bind $f.4.e <Down> {focus .reverg.5.e}
		bind $f.5.e <Down> {focus .reverg.6.e}
		bind $f.6.e <Down> {focus .reverg.7.e}
		bind $f.7.e <Down> {focus .reverg.8e}
		bind $f.8e <Down> {focus .reverg.1.e}

		bind $f.1.e <Up> {focus .reverg.8e}
		bind $f.2.e <Up> {focus .reverg.1.e}
		bind $f.3.e <Up> {focus .reverg.2.e}
		bind $f.4.e <Up> {focus .reverg.3.e}
		bind $f.5.e <Up> {focus .reverg.4.e}
		bind $f.6.e <Up> {focus .reverg.5.e}
		bind $f.7.e <Up> {focus .reverg.6.e}
		bind $f.8e <Up> {focus .reverg.7.e}

		bind $f <Escape> {set pr_reverg 0}
		bind $f <Return> {set pr_reverg 1}

		wm resizable $f 0 0
	}
	$reverg(txt) delete 1.0 end

	set pr_reverg 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_reverg $f.1.e
	catch {unset reverg(last_transpos)}
	catch {unset reverg(last_slope)}
	catch {unset reverg(last_dur)}
	catch {unset reverg(last_rolloff)}
	catch {unset reverg(last_size)}
	catch {unset reverg(last_echos)}

	while {!$finished} {
		tkwait variable pr_reverg
		if {$pr_reverg} {

			;#	CHECK ALL PARAMETERS

			set reverg(vals) [$reverg(txt) get 1.0 end]
			set cnt 0
			set OK 1
			foreach val $reverg(vals) {
				if {($val < 0.0) || ($val >= $pa($infnam,$evv(DUR)))} {
					Inf "Verge time value ($val) out of range (0 to $pa($infnam,$evv(dur)) secs)"
					set OK 0
					break
				}
				if {($cnt > 0) && ($val <= $lastval)} {
					Inf "Verge time values do not increase from $lastval to $val"
					set OK 0
					break
				}
				set lastval $val
				incr cnt
			}

			if {!$OK} {
				continue
			}
			if [catch {open $timesfile "w"} zit] {
				Inf "Cannot open file $timesfile to write verge times"
				continue
			}
			foreach val $reverg(vals) {
				puts $zit $val
			}
			close $zit

			if {![ValidCDPRootname $reverg(oname)]} {
				continue
			}
			set ofnam [string tolower $reverg(oname)]
			append ofnam $evv(SNDFILE_EXT)
			if {[file exists $ofnam]} {
				Inf "File $ofnam already exists: please choose a different name"
				continue
			}
			if {([string length $reverg(transpos)] <= 0) || ![IsNumeric $reverg(transpos)] || ($reverg(transpos) < -24) || ($reverg(transpos) > 24)} {
				Inf "Invalid verge transposition (range -24 to 24 semitones)"
				continue
			}
			if {([string length $reverg(slope)] <= 0) || ![IsNumeric $reverg(slope)] || ($reverg(slope) < 1) || ($reverg(slope) > 8)} {
				Inf "Invalid verge slope (range 1 to 8)"
				continue
			}
			if {([string length $reverg(dur)] <= 0) || ![IsNumeric $reverg(dur)] || ($reverg(dur) < 20) || ($reverg(dur) > 1000)} {
				Inf "Invalid verge duration (range 20 to 1000)"
				continue
			}
			if {([string length $reverg(rolloff)] <= 0) || ![IsNumeric $reverg(rolloff)] || ($reverg(rolloff) < 0.003) || ($reverg(rolloff) > 1)} {
				Inf "Invalid echo level loss (range 0.003 to 1)"
				continue
			}
			if {([string length $reverg(size)] <= 0) || ![IsNumeric $reverg(size)] || ($reverg(rolloff) < 0.001) || ($reverg(rolloff) > 1)} {
				Inf "Invalid stadium size multiplier (range 0.001 to 100)"
				continue
			}
			if {([string length $reverg(echos)] <= 0) || ![regexp {^[0-9]+$} $reverg(echos)] || ![IsNumeric $reverg(echos)] || ($reverg(echos) < 2) || ($reverg(echos) > 1000)} {
				Inf "Invalid echo count (range 2 to 1000)"
				continue
			}
			if {([string length $reverg(rlevel)] <= 0) || ![IsNumeric $reverg(rlevel)] || ($reverg(rlevel) < 0.01) || ($reverg(rlevel) > 100)} {
				Inf "Invalid relative level of reverbd attacks in mix (range 0.01 to 100)"
				continue
			}
			if {$reverg(rlevel) <= 1.0} {
				set reverg(srclevel) 1.0
				set reverg(revlevel) $reverg(rlevel)
			} else {
				set reverg(srclevel) [expr 1.0/$reverg(rlevel)]
				set reverg(revlevel) 1.0
			}

			Block "CREATING REVERBD VERGES"

			;#	CREATE THE TWO VERGE FILES, IF THEY'VE NOT ALREADY BEEN CREATED, OR THE PARAMETERS HAVE CHANGED

			set new_verges 0
			set create_verges 0
			while {$create_verges == 0} {
				if {![info exists reverg(last_transpos)] || ($reverg(last_transpos) != $reverg(transpos))} {
					set create_verges 1
					break
				}
				if {![info exists reverg(last_slope)] || ($reverg(last_slope) != $reverg(slope))} {
					set create_verges 1
					break
				}
				if {![info exists reverg(last_dur)] || ($reverg(last_dur) != $reverg(dur))} {
					set create_verges 1
					break
				}
				break
			}
			if {$create_verges} {

				catch {file delete $vrgfile}
				catch {file delete $atkfile}

				set cmd [file join $evv(CDPROGRAM_DIR) verges]
				lappend cmd verges $infnam $vrgfile $timesfile -t$reverg(transpos) -e$reverg(slope) -d$reverg(dur)
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING VERGES IN SOURCE"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed to run process to create verges in source"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed to create verges in source"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {![file exists $vrgfile]} {
					Inf "No sound with verges created"
					UnBlock
					continue
				}
				set reverg(last_transpos) $reverg(transpos)
				set reverg(last_slope) $reverg(slope)
				set reverg(last_dur) $reverg(dur)

				set cmd [file join $evv(CDPROGRAM_DIR) verges]
				lappend cmd verges $infnam $atkfile $timesfile -t$reverg(transpos) -e$reverg(slope) -d$reverg(dur) -s
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        CREATING VERGED ATTACKS"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed to run process to create verged attacks"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed to create verged attacks"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {![file exists $atkfile]} {
					Inf "No sound with verged attacks created"
					UnBlock
					continue
				}
				set new_verges 1
			}

			;#	DO THE REVERBERATION, IF NOT ALREADY DONE, OR PARAMS ALTERED, OR INPUT FILE ALTERED

			set do_reverb 0
			while {$do_reverb == 0} {
				if {$new_verges} {
					set do_reverb 1
					break
				}
				if {![info exists reverg(last_rolloff)] || ($reverg(last_rolloff) != $reverg(rolloff))} {
					set do_reverb 1
					break
				}
				if {![info exists reverg(last_size)] || ($reverg(last_size) != $reverg(size))} {
					set do_reverb 1
					break
				}
				if {![info exists reverg(last_echos)] || ($reverg(last_echos) != $reverg(echos))} {
					set do_reverb 1
					break
				}
				break
			}
			if {$do_reverb} {

				catch {file delete $revfile}

				set cmd [file join $evv(CDPROGRAM_DIR) modify]
				lappend cmd revecho 3 $atkfile $revfile -g1 -r$reverg(rolloff) -s$reverg(size) -e$reverg(echos) -n
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        REVERBERATING THE ATTACKS"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed to run process to reverberate the attacks"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed to create reverberated attacks"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					UnBlock
					continue
				}
				if {![file exists $revfile]} {
					Inf "No sound with reverberated attacks created"
					UnBlock
					continue
				}
				set reverg(last_rolloff) $reverg(rolloff)
				set reverg(last_size) $reverg(size)
				set reverg(last_echos) $reverg(echos)
			}


			;#	CREATE A MIXFILE IF NOT ALREADY DONE, OR MIX LEVEL BALANCE HAS CHANGED

			if {[file exists $mixfile]} {
				if {[info exists reverg(last_rlevel)] && ($reverg(last_rlevel) != $reverg(rlevel)} {
					catch {file delete $mixfile}
				}
			}
			if {![file exists $mixfile]} {	
				if [catch {open $mixfile "w"} zit] {
					Inf "Cannot open file $mixfile to create mix"
					continue
				}
				catch {unset lines}
				set line $vrgfile
				lappend line 0.0 1 $reverg(srclevel) C
				puts $zit $line
				set line $revfile
				lappend line 0.0 2 $reverg(revlevel)
				puts $zit $line
				close $zit
				set reverg(last_rlevel) $reverg(rlevel)
			}

			;#	DO THE MIX, ALONG WITH ANY LEVEL ADJUSTMENT NECESSARY

			set gain 1.0
			set OK2 0
			set OK3 0
			while {!$OK2} {
				if {[file exists $mixout]} {
					if [catch {file delete $mixout} zit] {
						Inf "Cannot delete existing mix output"
						set OK 0
						break
					}
				}
				set cmd [file join $evv(CDPROGRAM_DIR) submix]
				lappend cmd mix $mixfile $mixout -g$gain 
				set prg_dun 0
				set prg_abortd 0
				catch {unset simple_program_messages}
				wm title .blocker "PLEASE WAIT:        MIXING THE OUTPUT"
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed to run process to mix output"
					catch {unset CDPidrun}
					set OK 0 
					break
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Failed to mix the output"
					set msg [AddSimpleMessages $msg]
					ErrShow $msg
					set OK 0 
					break
				}
				if {![file exists $mixout]} {
					Inf "No sound with mixed output created"
					set OK 0 
					break
				}
				wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF OUTPUT MIX"
				set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
				catch {unset maxsamp_line}
				set done_maxsamp 0
				lappend cmd $mixout
				if [catch {open "|$cmd"} CDPmaxId] {
					Inf "Failed to run 'maxsamp2$evv(EXEC)'"
					set OK 0 
					break
	   			} else {
	   				fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
				}
	 			vwait done_maxsamp
				if {![info exists maxsamp_line]} {
					Inf "Cannot retrieve maximum sample of output mix"
					set OK 0
					break
				}
				if {$OK3} {
					break
				}
				set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
				if {$maxoutsamp <= 0.0} {
					Inf "Output mix has zero level"
					set OK 0
					break
				}
				if {$maxoutsamp > 0.98} {							;#	Gain close to 1.0 indicates output has probably overloadad
					set gain [expr $gain * 0.1]						;#	Reduce gain by factor of ten and re-run

				} elseif {($maxoutsamp < 0.95) && ($gain < 1.0)} {	;#	If gain has been adjusted, but maxsamp now below max
					set gain [expr (0.95/$maxoutsamp) * $gain]		;#	reset gain to give a maximal non-distorted output
					set OK3 1										;#	and force loop-exit after next pass
				} else {
					set OK2 1										;#	However, if gain has NOT been adjusted, accept less than maximal outlevel
				}
			}
			if {!$OK} {
				UnBlock
				continue
			}
			catch [file rename $mixout $ofnam]
			FileToWkspace $ofnam 0 0 0 0 1
			Inf "File $ofnam is on the workspace"
			DeleteAllTemporaryFiles
			UnBlock
			set finished 1
		} else {
			set finished 1
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--------- Save verge-timings marked in Sound View

proc SaveVergeTimes {} {
	global evv wstk reverg
	set timesfile $evv(DFLT_OUTNAME)
	append timesfile 1 $evv(TEXT_EXT)
	if {![info exists reverg(vals)]} {
		Inf "No verge-times data to save"
		return
	}
	if {![ValidCDPRootname $reverg(times)]} {
		return
	}
	set ofnam [string tolower $reverg(times)]
	append ofnam $evv(TEXT_EXT)
	if {[file exists $ofnam]} {
		set msg "File $ofnam already exists: overwrite it ??"
		set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		} else if [catch {file delete $ofnam} zit] {
			Inf "Cannot delete existing file $ofnam"
			return
		}
	}
	if [catch {open $ofnam "w"} zit] {
		Inf "Cannot open file $ofnam to write verge-times data"
		return
	}
	foreach val $reverg(vals) {
		puts $zit $val
	}
	close $zit
	FileToWkspace $ofnam 0 0 0 0 1
	Inf "File $ofnam is on the workspace"
}

#--------- Load verge-timings from an existing textfile

proc LoadVergeTimes {} {
	global reverg evv
	if {![ValidCDPRootname $reverg(times)]} {
		return
	}
	set ofnam [string tolower $reverg(times)]
	append ofnam $evv(TEXT_EXT)
	if {![file exists $ofnam]} {
		Inf "File $ofnam does not exist"
		return
	}
	if [catch {open $ofnam "r"} zit] {
		Inf "Cannot open file $ofnam to read verge-times data"
		return
	}
	set cnt 0
	set OK 1
	while {[gets $zit item] >= 0} {
		set item [string trim $item]
		if {[string length $item] <= 0} {
			continue
		}
		if {[string match [string index $item 0] ";"]} {
			continue
		}
		if {![IsNumeric $item]} {
			Inf "Non-numeric entry in file $ofnam"
			set OK 0
			break
		}
		if {$item < 0.0} {
			Inf "Invalid entry ($item) in file $ofnam"
			set OK 0
			break
		}
		if {$cnt > 0} {
			if {$item <= $lasttime} {
				Inf "Times do not increase (from $lasttime to $item) in file $ofnam"
				set OK 0
				break
			}
		}
		set lasttime $item	
		lappend vtimes $item
		incr cnt
	}
	if {!$OK} {
		return
	}
	if {![info exists vtimes]} {
		Inf "No valid data in file $ofnam"
		return
	}
	set reverg(vals) $vtimes
	
	set timesfile $evv(DFLT_OUTNAME)
	append timesfile 1 $evv(TEXT_EXT)

	if [catch {open $timesfile "w"} zit] {
		Inf "Cannot open verge-timings temporary file"
		return
	}
	foreach val $reverg(vals) {
		puts $zit $val
	} 
	close $zit
	$reverg(txt) delete 1.0 end
	$reverg(txt) insert 1.0 $reverg(vals)
}

#--------- Find files (possibly) containing verge-timings

proc FindVergeTimes {} {
	global wl pa evv pr_vgf chlist reverg
	foreach fnam [$wl get 0 end] {
		if {!($pa($fnam,$evv(FTYP)) & $evv(IS_A_TEXTFILE))} {
			continue
		}
		if {![IsAListofNumbers $pa($fnam,$evv(FTYP))]} {
			continue
		}
		if {$pa($fnam,$evv(MINNUM)) < 0.0} {
			continue
		}
		if {$pa($fnam,$evv(MAXNUM)) >= $pa([lindex $chlist 0],$evv(DUR))} {
			continue
		}
		lappend fileslist $fnam
	}
	if {![info exists fileslist]} {
		Inf "No appropriate files found"
		return
	}
	set f .vgf
	if [Dlg_Create $f "POSSIBLE VERGE TIMES FILES" "set pr_vgf 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_vgf 0" -highlightbackground [option get . background {}]
		button $f.0.s -text "Select" -command "set pr_vgf 1" -highlightbackground [option get . background {}]
		pack $f.0.s -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		Scrolled_Listbox $f.1.ll -width 120 -height 24 -selectmode single
		pack $f.1.ll -side top -pady 2
		pack $f.1 -side top -pady 2 -fill x -expand true
		wm resizable $f 0 0
		bind $f <Escape> {set pr_vgf 0}
		bind $f <Return> {set pr_vgf 1}
	}
	$f.1.ll.list delete 0 end
	foreach fnam $fileslist {
		$f.1.ll.list insert end $fnam
	}
	set pr_vgf 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_vgf $f.1.ll.list
	while {!$finished} {
		catch {unset i}
		tkwait variable pr_vgf
		switch -- $pr_vgf {
			1 {
				set i [$f.1.ll.list curselection]
				if {$i < 0} {
					Inf "No file selection made"
					continue
				}
				set reverg(times) [file rootname [$f.1.ll.list get $i]]
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--------- Load a patch for this verges window

proc LoadRevergPatch {} {
	global pr_vgp evv reverg wstk

	set revergdir [file join $evv(URES_DIR) reverg]
	if {(![file exists $revergdir]) || (![file isdirectory $revergdir])} {
		Inf "No verges patch directory"
		return
	}
	catch {unset reverg(patches)}
	foreach fnam [glob -nocomplain [file join $revergdir *]] {
		lappend reverg(patches) [file tail $fnam]
	}
	if {![info exists reverg(patches)]} {
		Inf "No existing verges patches"
		return
	}
	set f .vgp
	if [Dlg_Create $f "VERGE PATCHES" "set pr_vgp 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_vgp 0" -highlightbackground [option get . background {}]
		button $f.0.s -text "Select" -command "set pr_vgp 1" -highlightbackground [option get . background {}]
		button $f.0.d -text "Delete" -command "set pr_vgp 2" -highlightbackground [option get . background {}]
		pack $f.0.s $f.0.d -side left -padx 40
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		Scrolled_Listbox $f.1.ll -width 120 -height 24 -selectmode single
		pack $f.1.ll -side top -pady 2
		pack $f.1 -side top -pady 2 -fill x -expand true
		wm resizable $f 0 0
		bind $f <Escape> {set pr_vgp 0}
		bind $f <Return> {set pr_vgp 1}
	}
	$f.1.ll.list delete 0 end
	foreach patch $reverg(patches) {
		$f.1.ll.list insert end $patch
	}
	set pr_vgp 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_vgp $f.1.ll.list
	while {!$finished} {
		catch {unset i}
		tkwait variable pr_vgp
		switch -- $pr_vgp {
			1 {
				set i [$f.1.ll.list curselection]
				if {$i < 0} {
					Inf "No patch selection made"
					continue
				}
				set pname [$f.1.ll.list get $i]
				set fnam [file join $revergdir $pname]
				if [catch {open $fnam "r"} zit] {
					Inf "Cannot read patch $pname"
					continue
				}
				set cnt 0
				while {[gets $zit item] >= 0} {
					set item [string trim $item]
					if {[string length $item] <= 0} {
						continue
					}
					if {[string match [string index $item 0] ";"]} {
						continue
					}
					if {![IsNumeric $item]} {
						Inf "Non-numeric entry ($item) in patch $pname"
						break
					}
					switch -- $cnt {
						0 { set reverg(transpos) $item }
						1 { set reverg(slope)	 $item }
						2 { set reverg(dur)		 $item }
						3 { set reverg(rolloff)  $item }
						4 { set reverg(size)	 $item }
						5 { set reverg(echos)	 $item }
						6 { set reverg(rlevel)	 $item }
					}
					incr cnt
				}
				close $zit
				set finished 1
			}
			2 {
				set i [$f.1.ll.list curselection]
				if {$i < 0} {
					Inf "No patch selection made"
					continue
				}
				set pname [$f.1.ll.list get $i]
				set fnam [file join $revergdir $pname]
				set msg "Are you sure you want to delete patch $pname ??"
				set choice [tk_messageBox -type yesno -icon warning -parent [lindex $wstk end] -message $msg]
				if {$choice == "no"} {
					continue
				} elseif [catch {file delete $fnam} zit] {
					Inf "Cannot delete existing patch $fnam"
					continue
				}
				$f.1.ll.list delete $i
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--------- Save a patch from the verges window

proc SaveRevergPatch {} {
	global pr_vgs evv reverg wstk

	set revergdir [file join $evv(URES_DIR) reverg]
	if {![file exists $revergdir]} {
		if [catch {file mkdir $revergdir} zit] {
			Inf "Cannot create patch directory"
			return
		}
	} else {
		set reverg(patches) {} 
		foreach fnam [glob -nocomplain [file join $revergdir *]] {
			lappend reverg(patches) [file tail $fnam]
		}
	}
	if {([string length $reverg(transpos)] <= 0) || ![IsNumeric $reverg(transpos)] || ($reverg(transpos) < -24) || ($reverg(transpos) > 24)} {
		Inf "Invalid verge transposition (range -24 to 24 semitones)"
		return
	}
	if {([string length $reverg(slope)] <= 0) || ![IsNumeric $reverg(slope)] || ($reverg(slope) < 1) || ($reverg(slope) > 8)} {
		Inf "Invalid verge slope (range 1 to 8)"
		return
	}
	if {([string length $reverg(dur)] <= 0) || ![IsNumeric $reverg(dur)] || ($reverg(dur) < 20) || ($reverg(dur) > 1000)} {
		Inf "Invalid verge duration (range 20 to 1000)"
		return
	}
	if {([string length $reverg(rolloff)] <= 0) || ![IsNumeric $reverg(rolloff)] || ($reverg(rolloff) < 0.003) || ($reverg(rolloff) > 1)} {
		Inf "Invalid echo level loss (range 0.003 to 1)"
		return
	}
	if {([string length $reverg(size)] <= 0) || ![IsNumeric $reverg(size)] || ($reverg(rolloff) < 0.001) || ($reverg(rolloff) > 1)} {
		Inf "Invalid stadium size multiplier (range 0.001 to 100)"
		return
	}
	if {([string length $reverg(echos)] <= 0) || ![regexp {^[0-9]+$} $reverg(echos)] || ![IsNumeric $reverg(echos)] || ($reverg(echos) < 2) || ($reverg(echos) > 1000)} {
		Inf "Invalid echo count (range 2 to 1000)"
		return
	}
	if {([string length $reverg(rlevel)] <= 0) || ![IsNumeric $reverg(rlevel)] || ($reverg(rlevel) < 0.01) || ($reverg(rlevel) > 100)} {
		Inf "Invalid relative level of reverbd attacks in mix (range 0.01 to 100)"
		return
	}
	set reverg(patch) $reverg(transpos)
	lappend reverg(patch) $reverg(slope)
	lappend reverg(patch) $reverg(dur)
	lappend reverg(patch) $reverg(rolloff)
	lappend reverg(patch) $reverg(size)
	lappend reverg(patch) $reverg(echos)
	lappend reverg(patch) $reverg(rlevel)

	set f .vgs
	if [Dlg_Create $f "SAVE VERGE PATCH" "set pr_vgs 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_vgs 0" -highlightbackground [option get . background {}]
		button $f.0.s -text "Save" -command "set pr_vgs 1" -highlightbackground [option get . background {}]
		pack $f.0.s -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.tit -text "Existing Patch Names" -fg $evv(SPECIAL)
		Scrolled_Listbox $f.1.ll -width 120 -height 24 -selectmode single
		pack $f.1.tit $f.1.ll -side top -pady 2
		pack $f.1 -side top -pady 2 -fill x -expand true
		frame $f.2
		label $f.2.ll -text "New Patch Name"
		entry $f.2.e -textvariable reverg(patchname)
		pack $f.2.ll $f.2.e -side left -padx 2
		pack $f.2 -side top -pady 2 -fill x -expand true
		wm resizable $f 0 0
		bind $f <Escape> {set pr_vgs 0}
		bind $f <Return> {set pr_vgs 1}
	}
	set reverg(patchname) ""
	$f.1.ll.list delete 0 end
	foreach patch $reverg(patches) {
		$f.1.ll.list insert end $patch
	}
	set pr_vgs 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_vgs $f.2.e
	while {!$finished} {
		tkwait variable pr_vgs
		switch -- $pr_vgs {
			1 {
				if {![ValidCDPRootname $reverg(patchname)]} {
					continue
				}
				if {[lsearch $reverg(patches) $reverg(patchname)] >= 0} {
					Inf "Patch name already exists: please choose a different name"
					continue
				}
				set fnam [file join $revergdir $reverg(patchname)]

				if [catch {open $fnam "w"} zit] {
					Inf "Cannot save this patch"
					continue
				}
				foreach item $reverg(patch) {
					puts $zit $item
				}
				close $zit
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc VergesHelp {} {
	set msg "REVERBD VERGES\n"
	append msg "\n"
	append msg "Mark times in the source,\n"
	append msg "and, at these times, gliss the source, briefly\n"
	append msg "(and perhaps accent these glissi).\n"
	append msg "\n"
	append msg "These events are then reverberated\n"
	append msg "and mixed back over the source.\n"
	append msg "\n"
	append msg "Times in source may be marked in \"Sound View\"\n"
	append msg "or loaded from a (previously created) file.\n"
	append msg "\n"
	append msg "Times marked in \"Sound View\" may be save to a named file.\n"
	append msg "\n"
	append msg "Parameter values may be typed directly to the boxes.\n"
	append msg "The set of values may be saved as a \"patch\".\n"
	append msg "\n"
	append msg "Parameter values may also be loaded from such a Patch.\n"
	append msg "\n"
	append msg "\n"
	Inf $msg
}

proc ClearRevergPatch {} {
	global reverg
	set reverg(transpos) ""
	set reverg(slope)	 ""
	set reverg(dur)		 ""
	set reverg(rolloff)  ""
	set reverg(size)	 ""
	set reverg(echos)	 ""
	set reverg(rlevel)	 ""
}

proc HelpSync {} {
	set msg "SYNCHRONISE AT TIMEMARKS\n"
	append msg "\n"
	append msg "All files selected (except the first) are to be timewarped\n"
	append msg "so that specified events in those files\n"
	append msg "synchronise to specified events in the FIRST file.\n"
	append msg "\n"
	append msg "If you then mix the time-warped outputs, the specified events\n"
	append msg "will happen in sync with one another.\n"
	append msg "\n"
	append msg "You can generate a list of the (times of) events to be syncd,\n"
	append msg "one listing for each file.\n"
	append msg "\n"
	append msg "The first file is NOT time-warped, providing only a template\n"
	append msg "for the time-warping of the others.\n"
	append msg "\n"
	append msg "Event-times can be marked in each file using the \"Sound View\" window.\n"
	append msg "\n"
	append msg "You can store the sync-times you choose.\n"
	append msg "If you do this, they will be automatically recalled\n"
	append msg "when you revisit this process (so you don't need to re-enter them).\n"
	append msg "(But you can also overwrite any existing sync-list, if you wish).\n"
	Inf $msg
}

#---- Create mix in which peaks of each of input files are equally spaced in time

proc StaggerPeaks {} {
	global pr_stagpks evv wstk wl chlist pa stagstep stagnam blist_change rememd
	global maxsamp_line done_maxsamp CDPmaxId

	set maxochans 0
	set ilist [$wl curselection]
	if {![info exists ilist] || ([llength $ilist] < 2)} {
		if {[info exists chlist] && ([llength $chlist] >= 2)} {
			foreach fnam $chlist {
				if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
					catch {unset fnams}
					break
				}
				lappend fnams $fnam
				set ochans $pa($fnam,$evv(CHANS))
				if {$ochans > $maxochans} {
					set maxochans $ochans
				}
				lappend ochanslist $ochans
			}
		}
	} else {
		foreach i $ilist {
			set fnam [$wl get $i]
			if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
				catch {unset fnams}
				break
			}
			lappend fnams $fnam
			set ochans $pa($fnam,$evv(CHANS))
			if {$ochans > $maxochans} {
				set maxochans $ochans
			}
			lappend ochanslist $ochans
		}
	}
	if {![info exists fnams]} {
		Inf "Choose soundfiles only, and more than one soundfile"
		return
	}
	set srate $pa([lindex $fnams 0],$evv(SRATE))
	foreach fnam [lrange $fnams 1 end] {
		if {$pa($fnam,$evv(SRATE)) != $srate} {
			Inf "Not all files have same sample rate ($srate and $pa($fnam,$evv(SRATE)))"
			return
		}
	}

	set f .stagpks
	if [Dlg_Create $f "STAGGER PEAKS IN MIX" "set pr_stagpks 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_stagpks 0"
		button $f.0.s -text "Stagger" -command "set pr_stagpks 1"
		pack $f.0.s -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Mix timestep"
		entry $f.1.e -textvariable stagstep -width 24
		pack $f.1.e $f.1.ll -side left  -fill x -expand true
		pack $f.1 -side top -pady 2
		frame $f.2
		label $f.2.ll -text "Mix Filename"
		entry $f.2.e -textvariable stagnam -width 24
		pack $f.2.e $f.2.ll -side left -fill x -expand true
		pack $f.2 -side top -pady 2
		wm resizable $f 0 0
		bind $f.1.e <Down> {focus .stagpks.2.e}
		bind $f.1.e <Up> {focus .stagpks.2.e}
		bind $f.2.e <Down> {focus .stagpks.1.e}
		bind $f.2.e <Up> {focus .stagpks.1.e}
		bind $f <Escape> {set pr_stagpks 0}
		bind $f <Return> {set pr_stagpks 1}
	}
	set pr_stagpks 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_stagpks $f.1.e
	while {!$finished} {
		tkwait variable pr_stagpks
		switch -- $pr_stagpks {
			1 {
				if {![ValidCDPRootname $stagnam]} {
					continue
				}
				set ofnam [string tolower $stagnam]
				if {$maxochans > 2} {
					append ofnam [GetTextfileExtension mmx]
				} else {
					append ofnam [GetTextfileExtension mix]
				}
				if {[file exists $ofnam]} {
					set msg "File $ofnam already exists : overwrite it ?"
					set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
					if {$choice == "no"} {
						continue
					}
					if {![DeleteFileFromSystem $ofnam 0 1]} {
						Inf "Cannot delete the existing file $ofnam"
						continue
					}
					set blist_change 0
					if {![DeleteFileFromSystem $ofnam 0 1]} {
						Inf "Cannot delete existing file '$ofnam'"
						continue
					} else {
						DummyHistory $ofnam "DESTROYED"
						MixMPurge 1
						set i [LstIndx $ofnam $wl]
						if {$i >= 0} {
							WkspCnt [$wl get $i] -1
							$wl delete $i
							catch {unset rememd}
						}
					}
				}
				if {([string length $stagstep] <= 0) || ![IsNumeric $stagstep] || ($stagstep < 0.0)} {
					Inf "Invalid mixfile timestep (must be greater than zero)"
					continue
				}
				Block "FINDING PEAKS"
				set OK 1
				catch {unset pklocs}
				foreach fnam $fnams ochans $ochanslist {
					wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF FILE [file rootname [file tail $fnam]]"
					set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
					lappend cmd $fnam
					catch {unset CDPmaxId}
					catch {unset maxsamp_line}
					set done_maxsamp 0
					if [catch {open "|$cmd"} CDPmaxId] {
						Inf "FAILED TO RUN 'maxsamp2$evv(EXEC)' on file [file rootname [file tail $fnam]]"
						set OK 0
						break
	   				} else {
	   					fileevent $CDPmaxId readable "Display_Maxsamp_Info_Wksp"
					}
	 				vwait done_maxsamp
					if {![info exists maxsamp_line]} {
						Inf "Cannot retrieve maximum sample information for file [file rootname [file tail $fnam]]"
						set OK 0
						break
					}
					set x 1
					after 10 {set x 1}
					vwait x
					if {[lindex $maxsamp_line 0] <= 0.0} {
						Inf "File [file rootname [file tail $fnam]] has zero level"
						set OK 0
						break
					}
					set maxsamploc [lindex $maxsamp_line 1]
					lappend pklocs [expr double($maxsamploc)/double($srate)]
				}
				if {!$OK} {
					UnBlock
					continue
				}
				wm title .blocker "PLEASE WAIT:        WRITING MIXFILE $stagnam"
				set stttimes 0.0
				set minstt 0.0
				set thispkat [lindex $pklocs 0]							;#	Location of first peak
				foreach pkloc [lrange $pklocs 1 end] {					;#	For all other peaks
					set nextpkat [expr $thispkat + $stagstep]			;#	Location of its peak must be "stagstep" after previous peak
					set stttime [expr $nextpkat - $pkloc]				;#	The sound therefore must start at a time "pkloc" BEFORE this
					if {$stttime < $minstt} {
						set minstt $stttime
					}
					lappend stttimes $stttime			
					set thispkat $nextpkat
				}
				if {$minstt < 0.0} {
					catch {unset nustts}
					foreach stttime $stttimes {
						set nustt [expr $stttime - $minstt]
						if {$nustt < 0.0} {
							set nustt 0.0
						}
						lappend nustts $nustt
					} 
					set stttimes $nustts
				}
				catch {unset lines}
				if {$maxochans > 2} {
					lappend lines $maxochans
				}
				foreach stttime $stttimes fnam $fnams ochans $ochanslist {
					set line [list $fnam $stttime $ochans]
					if {$maxochans > 2} {
						catch {unset routing}
						set chan 1
						while {$chan <= $ochans} {
							set rout $chan
							append rout ":" $chan
							lappend routing $rout
							lappend routing 1.0
							incr chan
						}
						set line [concat $line $routing]
					} else {
						lappend line 1.0
						lappend lines $line
					}
				}
				if [catch {open $ofnam "w"} zit] {
					Inf "Cannot open file $ofnam to write mix data"
					UnBlock
					continue
				}
				foreach line $lines {
					puts $zit $line
				}
				close $zit
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File $ofnam is on the workspace"
				} else {
					Inf "File $ofnam has been created"
				}
				UnBlock
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#--- Convert pitch-following vfilt file to HF file

proc Convert_PitchFollowFilt_to_HFFilt {inkey} {
	global chlist wl evv cpff_key cpff_minor cpff_hf pr_cpff
	set fnams {}
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		lappend fnams [lindex $chlist 0]
	}
	set i [$wl curselection]
	if {[info exists i] && ([llength $i] == 1) && ($i != -1)} {
		lappend fnams [$wl get $i]
	}
	set len [llength $fnams]
	switch -- $len {
		0 {
			Inf "No varibank file selected"
			return
		}
		1 {
			set fnam [lindex $fnams 0]
			set out [IsValidVFiltfile $fnam 0]
			set lasttime [lindex $out 0]
			set hf [lindex $out 1]
			if {[llength $hf] <= 0} {					;#	Only one file selected
				Inf "No varibank file selected"
				return
			}
		}
		2 {
			set fnam [lindex $fnams 0]						;#	file on chosen list + file on wkspace selected
			set out [IsValidVFiltfile $fnam 1]
			set lasttime [lindex $out 0]
			set hf [lindex $out 1]
			if {[llength $hf] <= 0} {
				set fnam [lindex $fnams 1]					;#	prioritise chosen file
				set hf [IsValidVFiltfile $fnam 0]
				set lasttime [lindex $out 0]
				set hf [lindex $out 1]
				if {[llength $hf] <= 0} {
					Inf "No varibank file selected"
					return
				}
			}
		}
	}
	set fnam [file rootname [file tail $fnam]]
	append fnam "_hf"
	if {[file exists $fnam$evv(TEXT_EXT)]} {
		set n 0
		set fnamx $fnam
		append fnamx $n
		while {[file exists $fnamx$evv(TEXT_EXT)]} {
			incr n
			set fnamx $fnam
			append fnamx $n
			if {$n >= 100} {
				Inf "Cannot generate unique name for hf file"
				return
			}
		}
		set fnam $fnamx
	}
	append fnam $evv(TEXT_EXT)
	set cpff_hf {}
	if {$inkey} {
		set cpff_key -1
		set cpff_minor 0
		set f .cpff
		if [Dlg_Create $f "SET KEY OF FILTER DATA" "set pr_cpff 0" -width 80 -borderwidth $evv(SBDR)] {
			frame $f.0
			button $f.0.q -text "Abandon" -command "set pr_cpff 0"
			button $f.0.s -text "Set Key" -command "set pr_cpff 1"
			pack $f.0.s -side left
			pack $f.0.q -side right
			pack $f.0 -side top -fill x -expand true
			frame $f.1
			radiobutton $f.1.c  -text "C"  -width 3 -variable cpff_key -value 0
			radiobutton $f.1.db -text "Db" -width 3 -variable cpff_key -value 1
			radiobutton $f.1.d  -text "D"  -width 3 -variable cpff_key -value 2
			radiobutton $f.1.eb -text "Eb" -width 3 -variable cpff_key -value 3
			radiobutton $f.1.e  -text "E"  -width 3 -variable cpff_key -value 4
			radiobutton $f.1.f  -text "F"  -width 3 -variable cpff_key -value 5
			radiobutton $f.1.gb -text "Gb" -width 3 -variable cpff_key -value 6
			radiobutton $f.1.g  -text "G"  -width 3 -variable cpff_key -value 7
			radiobutton $f.1.ab -text "Ab" -width 3 -variable cpff_key -value 8
			radiobutton $f.1.a  -text "A"  -width 3 -variable cpff_key -value 9
			radiobutton $f.1.bb -text "Bb" -width 3 -variable cpff_key -value 10
			radiobutton $f.1.b  -text "B"  -width 3 -variable cpff_key -value 11
			pack $f.1.c $f.1.db $f.1.d $f.1.eb $f.1.e $f.1.f $f.1.gb $f.1.g $f.1.ab $f.1.a $f.1.bb $f.1.b -side left
			pack $f.1 -side top -pady 2
			frame $f.2
			checkbutton $f.2.n -text "Minor" -variable cpff_minor
			pack $f.2.n -side top -pady 2
			pack $f.2 -side top -pady 2
			wm resizable $f 0 0
			bind $f <Escape> {set pr_cpff 0}
			bind $f <Return> {set pr_cpff 1}
		}
		set pr_cpff 0
		set finished 0
		raise $f
		update idletasks
		StandardPosition $f
		My_Grab 0 $f pr_cpff
		while {!$finished} {
			set cpff_hf {}
			tkwait variable pr_cpff
			switch -- $pr_cpff  {
				0 {
					set finished 1
				}
				1 {
					if {$cpff_key < 0} {
						Inf "No key set"
						continue
					}
					set cpff_hf [DoHFKeySet $hf $cpff_key $cpff_minor]
					if {[llength $cpff_hf] <= 0} {
						Inf "No notes in this key"
						continue
					}
					set finished 1
				}
			}
		}
		My_Release_to_Dialog $f
		Dlg_Dismiss $f
	}
	if {[llength $cpff_hf] > 0} {
		set hf $cpff_hf
	} elseif {$inkey} {
		return
	}
	set line 0.0
	foreach item $hf {
		lappend line $item 1
	}
	lappend lines $line
	set line $lasttime
	foreach item $hf {
		lappend line $item 1
	}
	lappend lines $line

	if [catch {open $fnam "w"} zit] {
		Inf Cannot open file $fnam to write hf data"
		return
	}
	foreach line $lines {
		puts $zit $line
	}
	close $zit
	if {[FileToWkspace $fnam 0 0 0 0 1] > 0} {
		Inf "File $fnam is on the workspace"
	}
	return
}

proc IsValidVFiltfile {fnam firstoftwo} {

	if [catch {open $fnam "r"} zit] {
		if {!$firstoftwo} {								;#	If either the only file, or the 2nd file to test
			Inf "Cannot open file $fnam"
		}
		return ""
	}
	set linecnt 0
	set OK 1
	while {[gets $zit line] >= 0} {
		set line [string trim $line]
		if {[string length $line] <= 0} {
			continue
		}
		if {[string match [string index $line 0] ";"]} {
			continue
		}
		set line [split $line]
		set cnt 0
		foreach item $line {
			set item [string trim $item]
			if {[string length $item] <= 0} {
				continue
			}
			if {![IsNumeric $item] || ($item < 0.0)} {
				set OK 0
				break
			}
			switch -- $cnt {
				0 {
					if {$linecnt == 0} {
						if {$item != 0.0} {
							set OK 0
							break
						}
					} elseif {$item <= $lasttime} {
						set OK 0
						break
					}
					set lasttime $item
				}
				default {
					if {[IsEven $cnt]} {		;#	Amplitude
						if {$item > 1} {
							break
						}
					} else {				;#	MIDI
						if {$item > 127} {
							break
						} else {
							lappend hf $item
						}
					}
				}
			}
			incr cnt
		}
		if {!$OK} {
			break
		}
		if {$linecnt == 0} {
			set itemcnt $cnt
		} elseif {$cnt != $itemcnt} {
			set OK 0
			break
		}
		incr linecnt
	}
	close $zit
	if {!$OK} {
		return {}
	}
	set hf [RemoveDuplicatesInList $hf]
	set hf [lsort -increasing $hf]
	return [list $lasttime $hf]
}

proc DoHFKeySet {hf key minor} {
	set keyset $key
	if {$minor} {
		lappend keyset [expr ($key + 3) % 12]
	} else {
		lappend keyset [expr ($key + 4) % 12]
	}
	lappend keyset [expr ($key + 7) % 12]
	lappend keyset [expr ($key + 10) % 12]
	set nuhf {}
	foreach item $hf {
		if {[lsearch $keyset [expr $item % 12]] >= 0} {
			lappend nuhf $item
		}
	}
	return $nuhf
}

#-- Extend chanting source by repeating chant elements in permd rand order

proc ChantExtend {} {
	global wl chlist evv pa chantex pr_chantex

	set chantex(dfltover) 0.02
	catch {unset chantex(chancnt)}
	catch {unset chantex(durs)}

	if {[info exists chlist] && ([llength $chlist] > 2)} {
		set fnams $chlist
	} else {
		set ilist [$wl curselection]
		if {[info exists ilist] && ([llength $ilist] > 2)} {
			foreach i $ilist {
				lappend fnams [$wl get $i]
			}
		}
	}
	if {![info exists fnams]} {
		Inf "Insufficient files selected : select soundfiles (at least 3) of equal duration "
		return
	}
	set mindur 1000000
	set maxdur 0
	foreach fnam $fnams {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			Inf "File $fnam is not a soundfile : select soundfiles (at least 3) of equal duration"
			return
		}
		if {![info exists chantex(chancnt)]} {
			set chantex(chancnt) $pa($fnam,$evv(CHANS))
		} elseif {$chantex(chancnt) != $pa($fnam,$evv(CHANS))} {
			Inf "Files do not all have the same number of channels"
			return
		}
		set dur $pa($fnam,$evv(DUR))
		if {$dur < $mindur} {
			set mindur $dur
		}
		if {$dur > $maxdur} {
			set maxdur $dur
		}
		lappend chantex(durs) $dur
	}
	set chantex(mindur) $mindur
	set chantex(maxdur) $maxdur
	set chantex(permlen) [llength $fnams]

	set f .chantex
	if [Dlg_Create $f "EXTEND CHANTING" "set pr_chantex 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_chantex 0"
		button $f.0.s -text "Extend" -command "set pr_chantex 1"
		pack $f.0.s -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		radiobutton $f.1.a -text "Repeat Count"   -width 16 -variable chantex(durtyp) -value 0 -command ChantexSwap
		radiobutton $f.1.b -text "Total Duration" -width 16 -variable chantex(durtyp) -value 1 -command ChantexSwap
		pack $f.1.a $f.1.b -side left
		pack $f.1 -side top -pady 2
		frame $f.2
		label $f.2.ll -text "Repeat Count" -width 16
		entry $f.2.e -textvariable chantex(dur) -width 12
		pack $f.2.e $f.2.ll -side left -pady 2
		pack $f.2 -side top -pady 2
		frame $f.3
		label $f.3.ll -text "Overlap" -width 16
		entry $f.3.e -textvariable chantex(over) -width 12
		radiobutton $f.3.r -text "Set Default" -variable chantex(overset) -value 1 -command ChantexOverset
		set chantex(over) $chantex(dfltover)
		pack $f.3.e $f.3.ll $f.3.r -side left -pady 2
		pack $f.3 -side top -pady 2
		frame $f.4
		label $f.4.ll -text "Output Mix Name" -width 16
		entry $f.4.e -textvariable chantex(ofnam) -width 12
		pack $f.4.e $f.4.ll -side left -pady 2
		pack $f.4 -side top -pady 2
		wm resizable $f 0 0
		bind $f <Escape> {set pr_chantex 0}
		bind $f <Return> {set pr_chantex 1}
	}
	set sumdur 0.0
	foreach dur $chantex(durs) {
		set sumdur [expr $sumdur + $dur]
	}
	set chantex(durav) [expr $sumdur/$chantex(permlen)]
	set pr_chantex 0
	set chantex(durtyp) -1
	set chantex(overset) 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_chantex $f.2.e
	while {!$finished} {
		tkwait variable pr_chantex
		switch -- $pr_chantex  {
			0 {
				set finished 1
			}
			1 {
				if {([string length $chantex(over)] <= 0) || ![IsNumeric $chantex(over)] || ($chantex(over) < 0.0)} {
					Inf "Invalid value for overlap"
					continue
				}
				if {[expr $chantex(over) * 2.0] >= $chantex(mindur)} {
					Inf "Overlap ($chantex(over)) too large for minimum duration input file ($chantex(mindur))"
					continue
				}
				switch -- $chantex(durtyp) {
					0 {
						if {([string length $chantex(dur)] <= 0) || ![IsNumeric $chantex(dur)] || ![regexp {^[0-9]+$} $chantex(dur)]} {
							Inf "Invalid value for repeat count"
							continue
						}
						if {$chantex(dur) < 4} {
							Inf "Repeat count must be 4 or more"
							continue
						}
						set chantex(rep) $chantex(dur)
					}
					1 {
						if {([string length $chantex(dur)] <= 0) || ![IsNumeric $chantex(dur)]} {
							Inf "Invalid value for total duration"
							continue
						}
						if {$chantex(dur) < [expr $chantex(maxdur) * 4]} {
							Inf "Duration must be at least 4 times the duration of the (longest) input file (i.e. > [expr $chantex(maxdur) * 4])"
							continue
						}
						set k [expr int(floor($chantex(dur)/$chantex(durav)))]
						incr k
						set chantex(rep) $k
					}
					default {
						Inf "CHOOSE \"Total Duration\" or \"Repeat Count\""
						continue
					}
				}
				if {[string length $chantex(ofnam)] <= 0} {
					Inf "No output file name entered"
					continue
				}
				if {![ValidCDPRootname $chantex(ofnam)]} {
					continue
				}
				set ofnam [string tolower $chantex(ofnam)]
				if {$chantex(chancnt) > 2} {
					append ofnam [GetTextfileExtension mmx]
				} else {
					append ofnam [GetTextfileExtension mix]
				}
				if {[file exists $ofnam]} {
					Inf "File $ofnam already exists : please chose a diffferent name"
					continue
				}
				catch {unset steps}
				foreach dur $chantex(durs) {
					set step [expr $dur - $chantex(over)]			;#	Allow for file overlap in mixlines
					lappend steps $step
				}
				set chantex(steps) $steps

				catch {unset lines}
				if {$chantex(chancnt) > 2} {						;#	Write channel count at start of multichannel mixfile data
					set line $chantex(chancnt)
					lappend lines $line
				}
				set cnt 0
				set time 0.0
				set lastlast -1
				while {$cnt < $chantex(rep)} {						;#	Permute order of infiles (once all of them used once)
					set seqperm [ChantexPerm $chantex(permlen) $lastlast]
					set lastlast [lindex $seqperm end]				;#	Remember last item of perm to avoid repets between perms
					set n 0
					while {$n < $chantex(permlen)} {
						set m [lindex $seqperm $n]
						set fnam [lindex $fnams $m]
						set step [lindex $chantex(steps) $m]
						if {$chantex(chancnt) > 2} {				;#	Set up line of multichan mixfile
							set line [list $fnam $time $chantex(chancnt)]
							set ch 1
							while {$ch <= $chantex(chancnt)} {
								set rout $ch:$ch
								lappend line $rout 1
								incr ch
							}
						} else {									;#	OR Set up line of ordinary mixfile
							set line [list $fnam $time $chantex(chancnt) 1]
						}
						lappend lines $line
						set time [expr $time + $step]				;#	Incr time to next line
						incr n
						incr cnt
						if {$cnt >= $chantex(rep)} {				;#	Drop out if total repets-cnt reached
							break
						}
					}
				}
				if [catch {open $ofnam "w"} zit] {
					Inf "Cannot open output mixfile $ofnam"
					continue
				}
				foreach line $lines {
					puts $zit $line
				}
				close $zit
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File $ofnam is on the workspace"				
				}
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc ChantexSwap {} {
	global chantex
	switch -- $chantex(durtyp) {
		0 {
			.chantex.2.ll config -text "Repeat Count"
		}
		1 {
			.chantex.2.ll config -text "Total Duration"
		} 
	}
}

proc ChantexOverset {} {
	global chantex
	set chantex(over) $chantex(dfltover)
	set chantex(overset) 0
}


#---- Randomly permute order of snd-sources

proc ChantexPerm {k lastlast} {
	set permlen $k
	set OK 0
	while {!$OK} {
		set seqperm {}
		set n 0
		set n_plus_1 1
		set endindex -1
		while {$n < $permlen} {
			set t [expr int(floor(rand() * $n_plus_1))]
			if {$t==$n} {
				set q [concat $n $seqperm]
				set seqperm $q
			} else {
				incr t
				if {$t > $endindex} {
					lappend seqperm $n
				} else {
					set seqperm [linsert $seqperm $t $n]
				}
			}
			incr n
			incr n_plus_1
			incr endindex
		}
		if {[lindex $seqperm 0] != $lastlast} {
			set OK 1
		}
	}
	return $seqperm
}

#--- Delay between channels of stereo source

proc InternalDelay {} {
	global wl chlist pa evv pr_idel idel_del idel_del_dflt idel_ofnam prg_dun prg_abortd simple_program_messages CDPidrun
	set idel_del_dflt 0.05
	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) > 2)} {
			unset fnam
		}
	}
	if {![info exists fnam]} {
		set i [$wl curselection]
		if {[info exists i] && ([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
			if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) > 2)} {
				unset fnam
			}
		}
	}
	if {![info exists fnam]} {
		Inf "Select one soundfile"
		return
	}
	set idel_chans $pa($fnam,$evv(CHANS))
	if {$idel_chans == 2} {
		set chfnam [file rootname $fnam]
		set chfnam1 $chfnam
		append chfnam1 "_c1" $evv(SNDFILE_EXT)
		set chfnam2 $chfnam
		append chfnam2 "_c2" $evv(SNDFILE_EXT)
		if {[file exists $chfnam1] || [file exists $chfnam2]} {
			Inf "Extracted channel files of this file already exist\nmake a renamed copy of ~~this~~ file to proceed"
			return
		}
	} else {
		set chfnam1 $fnam
		set chfnam2 $fnam
	}
	set f .idel
	if [Dlg_Create $f "CREATE STEREO DELAY" "set pr_idel 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_idel 0"
		button $f.0.s -text "Do Delay" -command "set pr_idel 1"
		pack $f.0.s -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Delay"
		entry $f.1.e -textvariable idel_del -width 12
		button $f.1.d -text "Default" -command "set idel_del $idel_del_dflt"
		pack $f.1.e $f.1.ll $f.1.d -side left -pady 2
		pack $f.1 -side top -pady 2
		frame $f.2
		label $f.2.ll -text "Output Filename"
		entry $f.2.e -textvariable idel_ofnam -width 12
		pack $f.2.e $f.2.ll -side left -pady 2
		pack $f.2 -side top -pady 2
		wm resizable $f 0 0
		bind $f.1.e <Down> {focus .idel.2.e} 
		bind $f.1.e <Up>   {focus .idel.2.e} 
		bind $f.2.e <Down> {focus .idel.1.e} 
		bind $f.2.e <Up>   {focus .idel.1.e} 
		bind $f <Escape> {set pr_idel 0}
		bind $f <Return> {set pr_idel 1}
	}
	set pr_idel 0
	set idel_ofnam [file rootname [file tail $fnam]]
	append idel_ofnam "_del"
	set mixfnam $evv(DFLT_OUTNAME)
	append mixfnam [GetTextfileExtension mix]
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_idel $f.1.e
	while {!$finished} {
		DeleteAllTemporaryFiles
		tkwait variable pr_idel
		switch -- $pr_idel  {
			0 {
				set finished 1
			}
			1 {
				if {([string length $idel_del] <= 0) || ![IsNumeric $idel_del] || ($idel_del <= 0.0)} {
					Inf "Invalid value for delay"
					continue
				}
				if {[string length $idel_ofnam] <= 0} {
					Inf "No output file name entered"
					continue
				}
				if {![ValidCDPRootname $idel_ofnam]} {
					continue
				}
				set ofnam [string tolower $idel_ofnam]
				append ofnam $evv(SNDFILE_EXT)
				if {[file exists $ofnam]} {
					Inf "File $ofnam already exists : please chose a diffferent name"
					continue
				}
				Block "CREATING INTERNAL DELAY IN SOUND"
				set OK 1
				while {$OK} {
					if {![file exists $chfnam1]} { 
						set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
						lappend cmd chans 2 $fnam
						set prg_dun 0
						set prg_abortd 0
						catch {unset simple_program_messages}
						wm title .blocker "PLEASE WAIT:        EXTRACTING CHANNELS FROM [file rootname [file tail $fnam]]"
						if [catch {open "|$cmd"} CDPidrun] {
							ErrShow "Failed to run channel extraction process"
							catch {unset CDPidrun}
							set OK 0 
							break
						} else {
							fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
						}
						vwait prg_dun
						if {$prg_abortd} {
							set prg_dun 0
						}
						if {!$prg_dun} {
							set msg "Failed to extract channels from [file rootname [file tail $fnam]]"
							set msg [AddSimpleMessages $msg]
							ErrShow $msg
							set OK 0 
							break
						}
						if {!([file exists $chfnam1] && [file exists $chfnam2])} {
							Inf "No (or too few) channels extracted from [file rootname [file tail $fnam]]"
							set OK 0 
							break
						}
					}
					catch {unset lines}
					set line [list $chfnam1 0.0 1 1 L]
					lappend lines $line
					set line [list $chfnam2 $idel_del 1 1 R]
					lappend lines $line
					if [catch {open $mixfnam "w"} zit] {
						Inf "Cannot open temporary mixfile $mixfnam to write delay remix data"
						set OK 0
						break
					}
					foreach line $lines {
						puts $zit $line
					}
					close $zit
					wm title .blocker "PLEASE WAIT:        REMIXING WITH INTERNAL DELAY"
					set cmd [file join $evv(CDPROGRAM_DIR) submix]
					lappend cmd mix $mixfnam $ofnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot run process to create mix with internal delay: $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						ErrShow "Cannot create output file: $CDPidrun"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
					}
					break
				}
				if {!$OK} {
					UnBlock
					continue
				}
				if {$idel_chans == 2} {
					set msg "Cannot delete file(s)\n"
					set msg2 ""
					if [catch {file delete $chfnam1} zit] {
						append msg2 "$chfnam1\n"
					}
					if [catch {file delete $chfnam2} zit] {
						append msg2 "$chfnam2\n"
					}
					if {[string length $msg2] > 0} {
						append msg $msg2
						Inf $msg
					}
				}
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File $ofnam is on the workspace"
				} else {
					Inf "File $ofnam has been created but is not on the workspace"
				}
				UnBlock
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#-- Wrap stereo file from mono to wide stereo (3 chans)

proc StereoWrap {} {
	global wl chlist pa wstk evv prg_dun prg_abortd simple_program_messages CDPidrun pr_swrap wrap blist_change

	if {[info exists chlist] && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
		if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) != 2)} {
			unset fnam
		}
	}
	if {![info exists fnam]} {
		set i [$wl curselection]
		if {[info exists i] && ([llength $i] == 1) && ($i != -1)} {
			set fnam [$wl get $i]
			if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) > 2)} {
				unset fnam
			}
		}
	}
	if {![info exists fnam]} {
		Inf "SELECT ONE STEREO SOUNDFILE"
		return
	}
	set dur $pa($fnam,$evv(DUR))
	set f .wrap
	if [Dlg_Create $f "WRAP STEREO TO 3-CHAN SURROUND" "set pr_swrap 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_swrap 0"
		button $f.0.h -text "Help" -command WrapHelp -bg $evv(HELP)
		button $f.0.s -text "Do Wrap" -command "set pr_swrap 1"
		pack $f.0.s $f.0.h -side left -padx 4
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Wrap Diverges From Mono" -width 26 -anchor w
		entry $f.1.e -textvariable wrap(div) -width 12
		set wrap(div) ""
		pack $f.1.e $f.1.ll -side left -pady 2
		pack $f.1 -side top -pady 2
		frame $f.2
		label $f.2.ll -text "Wrap Arrives At Stereo" -width 26 -anchor w
		entry $f.2.e -textvariable wrap(stt) -width 12
		set wrap(stt) ""
		pack $f.2.e $f.2.ll -side left -pady 2
		pack $f.2 -side top -pady 2
		frame $f.3
		label $f.3.ll -text "Wrap Converges from Stereo" -width 26 -anchor w
		entry $f.3.e -textvariable wrap(end) -width 12
		set wrap(end) ""
		pack $f.3.e $f.3.ll -side left -pady 2
		pack $f.3 -side top -pady 2
		frame $f.4
		label $f.4.ll -text "Wrap Arrives At Mono" -width 26 -anchor w
		entry $f.4.e -textvariable wrap(conv) -width 12
		set wrap(conv) ""
		pack $f.4.e $f.4.ll -side left -pady 2
		pack $f.4 -side top -pady 2
		frame $f.5
		label $f.5.ll -text "Output Filename"
		entry $f.5.e -textvariable wrap(ofnam) -width 12
		pack $f.5.e $f.5.ll -side left -pady 2
		pack $f.5 -side top -pady 2
		wm resizable $f 0 0
		bind $f.1.e <Down> {focus .wrap.2.e} 
		bind $f.2.e <Down> {focus .wrap.3.e} 
		bind $f.3.e <Down> {focus .wrap.4.e} 
		bind $f.4.e <Down> {focus .wrap.5.e}
		bind $f.5.e <Down> {focus .wrap.1.e}
		bind $f.1.e <Up>   {focus .wrap.5.e} 
		bind $f.2.e <Up>   {focus .wrap.1.e} 
		bind $f.3.e <Up>   {focus .wrap.2.e} 
		bind $f.4.e <Up>   {focus .wrap.3.e}
		bind $f.5.e <Up>   {focus .wrap.4.e} 
		bind $f <Escape> {set pr_swrap 0}
		bind $f <Return> {set pr_swrap 1}
	}
	set basfnam [file rootname [file tail $fnam]]
	set ofnam1 $basfnam
	append ofnam1 "_c1" $evv(SNDFILE_EXT)
	set ofnam2 $basfnam
	append ofnam2 "_c2" $evv(SNDFILE_EXT)
	set wrap(channels_extracted) 0
	if {[file exists $ofnam1] && [file exists $ofnam2]} {
		set wrap(channels_extracted) 1
		set msg "Files $ofnam1 & $ofnam2 already exist : use the existing extracted channels ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			Inf "Delete or rename files $ofnam1 & $ofnam2 before proceeding"
			return
		}
	}
	if {$wrap(channels_extracted)} {
		.wrap.1.ll config -text ""
		.wrap.1.e config -state disabled -bd 0 -disabledbackground [option get . background {}]
		set wrap(div) ""
		.wrap.2.ll config -text ""
		.wrap.2.e config -state disabled -bd 0 -disabledbackground [option get . background {}]
		set wrap(stt) ""
		.wrap.3.ll config -text ""
		.wrap.3.e config -state disabled -bd 0 -disabledbackground [option get . background {}]
		set wrap(end) ""
		.wrap.4.ll config -text ""
		.wrap.4.e config -state disabled -bd 0 -disabledbackground [option get . background {}]
		set wrap(conv) ""
	} else {
		.wrap.1.ll config -text "Wrap Diverges From Mono"
		.wrap.1.e config -state normal -bd 2
		.wrap.2.ll config -text "Wrap Arrives At Stereo"
		.wrap.2.e config -state normal -bd 2
		.wrap.3.ll config -text "Wrap Converges from Stereo"
		.wrap.3.e config -state normal -bd 2
		.wrap.4.ll config -text "Wrap Arrives At Mono"
		.wrap.4.e config -state normal -bd 2
	}

	set ofnamx1 $basfnam
	append ofnamx1 "_c1_panleft" $evv(SNDFILE_EXT)
	if {[file exists $ofnamx1]} {
		set msg "File $ofnamx1 already exists : overwrite it ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set blist_change 0
		if [DeleteFileFromSystem $ofnamx1 0 1] {
			DeleteFromSystemTidyUp $ofnamx1
		} else {
			Inf "Cannot delete file $ofnamx1"
			return
		}
	}
	set ofnamx2 $basfnam
	append ofnamx2 "_c2_panright" $evv(SNDFILE_EXT)
	if {[file exists $ofnamx2]} {
		set msg "File $ofnamx2 already exists : overwrite it ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set blist_change 0
		if [DeleteFileFromSystem $ofnamx2 0 1] {
			DeleteFromSystemTidyUp $ofnamx2
		} else {
			Inf "Cannot delete file $ofnamx2"
			return
		}
	}
	set pantoleft $basfnam
	append pantoleft "_c1_panleft" $evv(TEXT_EXT)
	set pantoright $basfnam
	append pantoright "_c2_panright" $evv(TEXT_EXT)

	set over_write 0
	if {[file exists $pantoleft] && [file exists $pantoright]} {
		set msg "Files $pantoleft and $pantoright already exist : re-use them ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			set msg "Overwrite them ??"
			set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
			if {$choice == "no"} {
				return
			}
			set over_write 1
		}
	} elseif {[file exists $pantoleft] || [file exists $pantoright]} {
		set msg "One of files $pantoleft and $pantoright already exists : overwrite it ??"
		set choice [tk_messageBox -type yesno -icon question -parent [lindex $wstk end] -message $msg]
		if {$choice == "no"} {
			return
		}
		set over_write 1
	}
	if {$over_write} {
		set blist_change 0
		if {[file exists $pantoleft]} {
			if [DeleteFileFromSystem $pantoleft 0 1] {
				DeleteFromSystemTidyUp $pantoleft 
			} else {
				Inf "Cannot delete file $pantoleft"
				return
			}
		}
		if {[file exists $pantoright]} {
			if [DeleteFileFromSystem $pantoright 0 1] {
				DeleteFromSystemTidyUp $pantoright
			} else {
				Inf "Cannot delete file $pantoright"
				return
			}
		}
	}
	set pr_swrap 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_swrap $f.1.e
	while {!$finished} {
		tkwait variable pr_swrap
		switch -- $pr_swrap  {
			0 {
				set finished 1
			}
			1 {
				if {!([file exists $pantoleft] && [file exists $pantoright])} {
					if {([string length $wrap(div)] <= 0) || ![IsNumeric $wrap(div)] || ($wrap(div) < 0.0) || ($wrap(div) >= $dur)} {
						Inf "Invalid value for time of diverge to stereo (range : 0 to less than $dur)"
						continue
					}
					if {([string length $wrap(stt)] <= 0) || ![IsNumeric $wrap(stt)] || ($wrap(stt) <= $wrap(div))} {
						Inf "Invalid value for time of arrival at stereo  (range : greater than wrap-diverge($wrap(div)) to $dur)"
						continue
					}
					if {$wrap(stt) < $dur} {
						if {([string length $wrap(end)] <= 0) || ![IsNumeric $wrap(end)] || ($wrap(end) < $wrap(stt))} {
							Inf "Invalid value for time of start-converge to mono (range : arrival_at_stereo($wrap(stt)) to $dur)"
							continue
						}
					}
					if {$wrap(end) < $dur} {
						if {([string length $wrap(conv)] <= 0) || ![IsNumeric $wrap(conv)] || ($wrap(conv) < $wrap(end))} {
							Inf "Invalid value time of arrival at mono (range : wrap-converge-start($wrap(end)) to $dur)"
							continue
						}
					}
					catch {unset lines1}
					set line [list 0.0 1.0]
					lappend lines1 $line
					set line [list $wrap(div) 1]
					lappend lines1 $line
					set line [list $wrap(stt) -0.8]
					lappend lines1 $line
					if {$wrap(stt) < $dur} {
						set line [list $wrap(end) -0.8]
						lappend lines1 $line
					}
					if {$wrap(end) < $dur} {
						set line [list $wrap(conv) 1.0]
						lappend lines1 $line
					}
					if {$wrap(conv) < $dur} {
						set line [list [expr $dur + 1.0] 1.0]
						lappend lines1 $line
					}
					catch {unset lines2}
					set line [list 0.0 -1.0]
					lappend lines2 $line
					set line [list $wrap(div) -1]
					lappend lines2 $line
					set line [list $wrap(stt) 0.8]
					lappend lines2 $line
					if {$wrap(stt) < $dur} {
						set line [list $wrap(end) 0.8]
						lappend lines2 $line
					}
					if {$wrap(end) < $dur} {
						set line [list $wrap(conv) -1.0]
						lappend lines2 $line
					}
					if {$wrap(conv) < $dur} {
						set line [list [expr $dur + 1.0] -1.0]
						lappend lines2 $line
					}

					if [catch {open $pantoleft w} zit] {
						Inf "CANNOT OPEN FILE $pantoleft TO WRITE PANNING DATA FOR CHANNEL 1 OF INPUT"
						continue
					}
					foreach line $lines1 {
						puts $zit $line
					}
					close $zit
					if [catch {open $pantoright w} zit] {
						Inf "CANNOT OPEN FILE $pantoright TO WRITE PANNING DATA FOR CHANNEL 2 OF INPUT"
						if {[file exists $pantoleft]} {
							if [catch {file delete $pantoleft} zit] {
								Inf "CANNOT REMOVE FILE $$pantoleft"
							}
						}
						continue
					}
					foreach line $lines2 {
						puts $zit $line
					}
					close $zit
					FileToWkspace $pantoleft  0 0 0 0 1
					FileToWkspace $pantoright 0 0 0 0 1
				}
				if {[string length $wrap(ofnam)] <= 0} {
					Inf "NO OUTPUT FILE NAME ENTERED"
					continue
				}
				if {![ValidCDPRootname $wrap(ofnam)]} {
					continue
				}
				set ofnam [string tolower $wrap(ofnam)]
				set mfnam $ofnam
				append ofnam $evv(SNDFILE_EXT)
				if {[file exists $ofnam]} {
					Inf "FILE $ofnam ALREADY EXISTS : PLEASE CHOSE A DIFFFERENT NAME"
					continue
				}
				append mfnam [GetTextfileExtension mmx]
				if {[file exists $mfnam]} {
					Inf "MIXFILE $mfnam ALREADY EXISTS : PLEASE CHOSE A DIFFFERENT NAME"
					continue
				}

				Block "CREATING WRAPPED STEREO"

				if {!$wrap(channels_extracted)} {

					;#	IF NESS, EXTRACT CHANNELS OF STEREO INPUT

					set prg_dun 0
					set prg_abortd 0
					set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
					lappend cmd chans 2 $fnam
					if [catch {open "|$cmd"} CDPidrun] {
						Inf "Failed to run channel separation"
						UnBlock
						continue
   					} else {
   						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						Inf "Channel separation failed"
						UnBlock
						continue
					}
					set outfnams {}
					set n 1
					set OK 1
					while {$n <= 2} {
						set outfnam [file rootname $fnam]
						append outfnam "_c" $n $evv(SNDFILE_EXT)
						if {![file exists $outfnam]} {
							Inf "Not all channels were extracted"
							foreach outfnam $outfnams {
								catch {unset pa($outfnam,$evv(CHANS))}
							}
							set OK 0
							break
						}
						lappend outfnams $outfnam
						incr n
					}
					if {!$OK} {
						UnBlock
						continue
					}
					set wrap(channels_extracted) 1
					set fnam_c1	[lindex $outfnams 0]			
					set fnam_c2	[lindex $outfnams 1]			
					FileToWkspace $fnam_c1 0 0 0 0 1
					FileToWkspace $fnam_c2 0 0 0 0 1
				} else {
					set fnam_c1 $ofnam1
					set fnam_c2 $ofnam2
				}
				set OK 1
				while {$OK} {

					;#	STEREO-PAN EXTRACTED CHANNELS OF INPUT

					wm title .blocker "PLEASE WAIT:        PANNING CHANNEL 1"
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd space 1 $fnam_c1 $ofnamx1 $pantoleft -p1.0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot run process to pan channel 1 of input: $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot create panned output from channel 1"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnamx1]} {
						set msg "No panned output from channel 1 created"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}

					wm title .blocker "PLEASE WAIT:        NOW PANNING CHANNEL 2"

					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd space 1 $fnam_c2 $ofnamx2 $pantoright -p1.0
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot run process to pan channel 2 of input: $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot create panned output from channel 2"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnamx2]} {
						set msg "No panned output from channel 2 created"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						if {[file exists $ofnamx1]} {
							if [catch {file delete $ofnamx1} zit] {
								Inf "Cannot delete file $ofnamx1 : $zit"
							}
						} else {
							FileToWkspace $ofnamx1 0 0 0 0 1
						}
						set OK 0
						break
					}
					FileToWkspace $ofnamx1 0 0 0 0 1
					FileToWkspace $ofnamx2 0 0 0 0 1

					wm title .blocker "PLEASE WAIT:        CREATING 3-CHANNEL MIXFILE"

					catch {unset lines}
					set line 3
					lappend lines $line
					set line $ofnamx1
					lappend line 0.0000 2 1:1 1.0 2:2 1.0
					lappend lines $line
					set line $ofnamx2
					lappend line 0.0000 2 1:2 1.0 2:3 1.0
					lappend lines $line

					if [catch {open $mfnam w} zit] {
						Inf "Cannot open mixfile $mfnam to write 3-chan mix"
						set OK 0
						break
					}
					foreach line $lines {
						puts $zit $line
					}
					close $zit

					wm title .blocker "PLEASE WAIT:        DOING THE 3-CHANNEL MIX"

					set cmd [file join $evv(CDPROGRAM_DIR) newmix]
					lappend cmd multichan $mfnam $ofnam
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot run 3-channel mix process: $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot create 3-channel output file: $CDPidrun"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $ofnam]} {
						set msg "No 3-channel output file created"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						if [catch {file delete $mfnam} zit] {
							Inf "Cannot delete mixfile $mfnam"
						}
						set OK 0
`						break
					}
					FileToWkspace $mfnam 0 0 0 0 1
					FileToWkspace $ofnam 0 0 0 0 1
					Inf "Files are on the workspace"
					break
				}
				UnBlock
				if {!$OK} {
					continue
				}
				set finished 1
			}
		}
	}
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

proc WrapHelp {} {
	set msg "                          WRAP STEREO TO 3-CHAN SURROUND\n"	
	append msg "\n"
	append msg "Takes input stereo signal and reroutes it ...\n"
	append msg "(1)   initially to mono ...\n"
	append msg "(2)   diverging to a wide stereo in 3 chan surround ...\n"
	append msg "(3)   returning to mono (possibly)\n"
	append msg " \n"
	append msg " TIME           OUTCHAN\n"
	append msg "    :                     2\n"
	append msg "    :                     |\n"
	append msg "    :                     |\n"
	append msg "    A                   / \\\n"
	append msg "    :                  /     \\\n"
	append msg "    :                /         \\\n"
	append msg "    B           1 |           | 3\n"
	append msg "    :               |           |\n"
	append msg "    :            1 |           | 3\n"
	append msg "    C               \\         /\n"
	append msg "    :                  \\     /\n"
	append msg "    D                   \\ /\n"
	append msg "                       2 |\n"
	append msg "                          |\n"
	append msg "\n"
	append msg "Parameters are ...\n"
	append msg "\n"
	append msg "(1) Time A : Wrap Diverges From Mono.\n"
	append msg "(2) Time B : Wrap Arrives At Stereo.\n"
	append msg "(3) Time C : Wrap Converges from Stereo.\n"
	append msg "(4) Time D : Wrap Arrives At Mono.\n"
	append msg "\n"
	append msg "(Wrap need not re-converge to mono).\n"
	append msg "\n"
	append msg "The output can be redirected variously in an 8-chan mix.\n"
	append msg "e.g. in diamond format ...\n"
	append msg " 1:2:3   -->   8:1:2 (around front centre)\n"
	append msg " 1:2:3   -->   7:1:3 (to midline from front centre)\n"
	append msg " 1:2:3   -->   6:1:4 (to rear stereo from front centre)\n"
	append msg "\n"
	append msg "                      1                                                                          1\n"
	append msg "             ____ o ____                                                                 o\n"
	append msg "            /                     \\                                                           /     \\\n"
	append msg "       8o                          o2                                       8o      /             \\      o2\n"
	append msg "                                                                                     /                      \\\n"
	append msg "                                                                                /                               \\\n"
	append msg "7o                                     o3                            7o                                        o3                   \n"
	append msg "\n"
	append msg "\n"
	append msg "                     1                                                        6o                            o4\n"
	append msg "                     o\n"
	append msg "                    / \\                                                                         o\n"
	append msg "       8o        /    \\          o2                                                         5\n"
	append msg "                /         \\\n"
	append msg "              /             \\\n"
	append msg "7o         /                \\          o3\n"
	append msg "           /                    \\\n"
	append msg "          /                      \\\n"
	append msg "       6o                        o4\n"
	append msg "\n"
	append msg "                    o\n"
	append msg "                    5\n"
	Inf $msg
}

proc DeleteFromSystemTidyUp {fnam} {
	global nesstype blist_change background_listing wl rememd chlist
	set save_mixmanage 0
	DummyHistory $fnam "DESTROYED"
	CouettePatchesDelete $fnam
	if {[MixMDelete $fnam 0]} {
		set save_mixmanage 1
	} elseif {[IsInAMixfile $fnam]} {
		if {[MixM_ManagedDeletion $fnam]} {
			set save_mixmanage 1
		}
	} elseif {[info exists nesstype($fnam)]} {
		PurgeNessData $fnam
		NessMStore
	}
	if {$save_mixmanage} {
		MixMStore
	}
	if {$blist_change} {
		SaveBL $background_listing
	}
	set i [LstIndx $fnam $wl]	;#	remove from workspace listing, if there
	if {$i >= 0} {
		WkspCnt [$wl get $i] -1
		$wl delete $i
		catch {unset rememd}
		if {[info exists chlist] && ([lsearch $chlist $fnam] >= 0)} {
			RemoveFromChosenlist $fnam
		}
	}
}

#----- Find if any chans of a multichan file are the same

proc FindMatchingChannels {} {
	global wl chlist pa evv CDPidrun CDPid prg_dun prg_abortd pr_mchmatch sndiff_line dun_sndiff CDPmaxId maxsamp_line done_maxsamp

	set i [$wl curselection]
	if {([llength $i] != 1) || ($i < 0)} {
		if {![info exists chlist] || ([llength $chlist] != 1)} {
			Inf "SELECT ONE MULTICHANNEL SOUNDFILE"
			return
		} else {
			set i [LstIndx [lindex $chlist 0] $wl]
			$wl selection clear 0 end
			$wl selection set $i
		}
	}
	set fnam [$wl get $i]
	if {($pa($fnam,$evv(FTYP)) != $evv(SNDFILE)) || ($pa($fnam,$evv(CHANS)) < 2)} {
		Inf "SELECT A MULTICHANNEL SOUNDFILE"
		return
	}
	set chanfnam $evv(DFLT_OUTNAME)
	set baschanfnam $chanfnam
	append chanfnam 0011 $evv(SNDFILE_EXT)
	DeleteAllTemporaryFiles
	if [catch {file copy $fnam $chanfnam} zit] {
		Inf "CANNOT MAKE TEMPORARY COPY OF INPUT FILE"
		return
	}
	set f .mchmatch
	if [Dlg_Create $f "TEST FOR MATCHING CHANNELS" "set pr_mchmatch 0" -borderwidth $evv(SBDR)] {
		set f1 [frame $f.1]
		set f0 [frame $f.0]
		label $f0.ll -text "File [file rootname [file tail $fnam]]" -fg $evv(SPECIAL)
		pack $f0.ll -side left
		pack $f0 -side top -pady 2
		button $f1.ok -text "Test for matching channels" -width 40 -command "set pr_mchmatch 1" -bg $evv(EMPH)
		button $f1.quit -text "Quit" -command "set pr_mchmatch 0"
		pack $f1.ok -side left -padx 2
		pack $f1.quit -side right
		pack $f1 -side top -fill x -expand true
		wm resizable $f 0 0
		bind $f <Return> {set pr_mchmatch 1}
		bind $f <Escape> {set pr_mchmatch 0}
	}
	$f.0.ll config -text "File [file rootname [file tail $fnam]]"
	set pr_mchmatch 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_mchmatch
	while {!$finished} {
		tkwait variable pr_mchmatch
		switch -- $pr_mchmatch {
			1 {
				Block "Extracting Channels from Source"
				set cmd [file join $evv(CDPROGRAM_DIR) housekeep]
				lappend cmd chans 2 $chanfnam
				set prg_dun 0
				set prg_abortd 0
				if [catch {open "|$cmd"} CDPidrun] {
					ErrShow "Failed to extract channels"
					catch {unset CDPidrun}
					UnBlock
					continue
				} else {
					fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
				}
				vwait prg_dun
				if {$prg_abortd} {
					set prg_dun 0
				}
				if {!$prg_dun} {
					set msg "Channel extraction failed"
					set msg [AddSimpleMessages $msg]
					Inf $msg
					UnBlock
					continue
				}
				foreach zfnam [glob -nocomplain $baschanfnam*] {
					if {![string match $zfnam $chanfnam]} {
						lappend outchanfnams $zfnam
					}
				}
				if {![info exists outchanfnams]} {
					Inf "Channel extraction produced no output files"
					UnBlock
					continue
				}
				if {[llength $outchanfnams] != $pa($fnam,$evv(CHANS))} {
					Inf "Failed to extract all the channels"
					UnBlock
					continue
				}
				set OK 1
				set len [llength $outchanfnams]
				set penult [expr $len - 2]
				set k 0
				set j 1
				catch {unset matches}
				foreach zfnam [lrange $outchanfnams 0 $penult] {
					set kk [expr $k + 1]
					set jj [expr $kk + 1]
					foreach xfnam [lrange $outchanfnams $kk end] {
						wm title .blocker "PLEASE WAIT:        COMPARING CHANNELS $j AND $jj"
						set dun_sndiff 0
						catch {unset CDPid}
						catch {unset sndiff_line}
						set cmd [file join $evv(CDPROGRAM_DIR) sndinfo]
						lappend cmd diff $zfnam $xfnam
						if [catch {open "|$cmd"} CDPid] {
							Inf "Failed to run process to compare channels $j and $jj : $CDPid"
							set OK 0
							break 
						} else {
	   						fileevent $CDPid readable "Display_SndDiff_Info"
						}
						vwait dun_sndiff
						catch {close $CDPid}
						if {![info exists sndiff_line]} {
							Inf "No comparison information retrieved for channels $j and $jj"
							set OK 0
							break 
						}
						if {[string match $sndiff_line 1]} {
							set match $j
							lappend match $jj
							lappend matches $match
						}
						if {!$OK} {
							break
						}
						incr kk
						incr jj
					}
					if {!$OK} {
						break
					}
					incr k
					incr j
				}
				if {!$OK} {
					UnBlock
					continue
				}
				catch {unset msg}
				if {![info exists matches]} {
					set msg "There are no matching channels"
				} else {
					set len [llength $matches]
					if {$len == 1} {
						set match [lindex $matches 0]
						set msg "Channel [lindex $match 0] matches [lindex $match 1]"
					} else {
						set penult [expr $len - 1]							;#	Merge  1:2  and 2:4  to  1:2:4
						set n 0
						while {$n < $penult} {
							set match_n [lindex $matches $n]
							set match_n1 [lindex $match_n 1]
							set m [expr $n + 1]
							while {$m < $len} {
								set match_m [lindex $matches $m]
								set match_m0 [lindex $match_m 0]
								if {$match_m0 == $match_n1} {
									lappend match_n [lindex $match_m 1]
									set matches [lreplace $matches $n $n $match_n]
									set matches [lreplace $matches $m $m]
									incr len -1
									incr penult -1
								} else {
									incr m
								}
							}
							incr n
						}
						set len [llength $matches]							;#	Merge  1:2:4  and 1:4:7  to  1:2:4:7
						if {$len > 1} {
							set penult [expr $len - 1]
							set n 0
							while {$n < $penult} {
								set match_n [lindex $matches $n]
								set match_n0 [lindex $match_n 0]
								set m [expr $n + 1]
								while {$m < $len} {
									set match_m [lindex $matches $m]
									set match_m0 [lindex $match_m 0]
									if {$match_m0 == $match_n0} {
										foreach k [lrange $match_m 1 end] {
											if {[lsearch $match_n $k] < 0} {
												lappend match_n $k
											}
										}
										set matches [lreplace $matches $m $m]
										incr len -1
										incr penult -1
									} else {
										incr m
									}
								}
								incr n
							}
						}
						set OK 1
						set n 0
						foreach match $matches {
							set k [lindex $match 0]
							incr k -1
							set zfnam [lindex $outchanfnams $k]
							wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF CHANNEL [expr $k + 1]"
							set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
							lappend cmd $zfnam
							catch {unset CDPmaxId}
							catch {unset maxsamp_line}
							set done_maxsamp 0
							if [catch {open "|$cmd"} CDPmaxId] {
								Inf "Failed to run 'maxsamp2$evv(EXEC)' on channel [expr $k + 1]"
								incr n
								continue
	   						} else {
	   							fileevent $CDPmaxId readable "Display_Maxsamp_Info_New"
							}
	 						vwait done_maxsamp
							if {![info exists maxsamp_line]} {
								Inf "Cannot retrieve maximum sample information for channel [expr $k + 1]"
								incr n
								continue
							} else {
								set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
								if {$maxoutsamp <= 0.0} {
									lappend match " : SILENT"
									set matches [lreplace $matches $n $n $match]
								}
							}
							set x 1
							after 10 {set x 1}
							vwait x
							incr n
						}
						foreach match $matches {
							set line "Channel [lindex $match 0] matches"
							foreach ch [lrange $match 1 end] {
								append line "  $ch"
							}
							append msg $line "\n"
						}
					}
				}
				Inf $msg
				UnBlock
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}

#------ Display info returned by maxsamp for empty-channel search.

proc Display_SndDiff_Info {} {
	global CDPid dun_sndiff sndiff_line

	if [eof $CDPid] {
		catch {close $CDPid}
		set dun_sndiff 1
		return
	} else {
		gets $CDPid line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		}
		if {[string first "IDENTICAL" $line] >= 0} {
			set sndiff_line 1
			set dun_sndiff 1
		} else {
			set sndiff_line 0
			set dun_sndiff 1
		}
	}
	update idletasks
}			

proc Display_Maxsamp_Info_New {} {
	global CDPmaxId done_maxsamp maxsamp_line

	if {[info exists CDPmaxId] && [eof $CDPmaxId]} {
		catch {close $CDPmaxId}
		set done_maxsamp 1
		return
	} else {
		gets $CDPmaxId line
		set line [string trim $line]
		if {[string length $line] <= 0} {
			return
		} elseif [string match INFO:* $line] {
			if {[string first "zero" $line"] > 0} {
				set maxsamp_line 0.0
				set done_maxsamp 1
			}
			return
		} elseif [string match WARNING:* $line] {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} elseif [string match ERROR:* $line] {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} elseif [string match KEEP:* $line] {
			set line [string range $line 6 end] 
			set maxsamp_line $line
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		} else {
			catch {close $CDPmaxId}
			set done_maxsamp 1
			return
		}
	}
	update idletasks
}			

proc Limiter {} {
	global CDPidrun prg_dun prg_abortd simple_program_messages chlist wl pa evv pr_limiter limiter
	global CDPmaxId maxsamp_line done_maxsamp

	if {([info exists chlist]) && ([llength $chlist] == 1)} {
		set fnam [lindex $chlist 0]
	} else {
		set ilist [$wl curselection]
		if {([info exists ilist]) && ([llength $ilist]) == 1)} {
			set i [lindex $ilist 0]
			if {$i != -1} {
				set fnam [$wl get $i]
			}
		}
	}
	if {[info exists fnam]} {
		if {$pa($fnam,$evv(FTYP)) != $evv(SNDFILE)} {
			unset fnam
		}
	}
	if {![info exists fnam]} {
		Inf "CHOOSE ONE SOUNDFILE"
	}
	if {![info exists limiter(norm)]} {	
		set limiter(norm) 0
	}
	set f .limiter
	if [Dlg_Create $f "APPLY LIMITER" "set pr_limiter 0" -width 80 -borderwidth $evv(SBDR)] {
		frame $f.0
		button $f.0.q -text "Abandon" -command "set pr_limiter 0"
		button $f.0.s -text "Run Limiter" -command "set pr_limiter 1"
		pack $f.0.s -side left
		pack $f.0.q -side right
		pack $f.0 -side top -fill x -expand true
		frame $f.1
		label $f.1.ll -text "Envelope window size (mS)"
		entry $f.1.e -textvariable limiter(wsize) -width 12
		button $f.1.d -text "Default" -command "set limiter(wsize) 50"
		pack $f.1.e $f.1.ll -side left -pady 2
		pack $f.1.d -side right
		pack $f.1 -side top -pady 2 -fill x -expand true
		frame $f.2
		label $f.2.ll -text "Data Reduction (Range 0 to 1)"
		entry $f.2.e -textvariable limiter(data) -width 12
		button $f.2.d -text "Default" -command "set limiter(data) 0.0002"
		pack $f.2.e $f.2.ll -side left -pady 2
		pack $f.2.d -side right
		pack $f.2 -side top -pady 2 -fill x -expand true
		frame $f.3
		label $f.3.ll -text "Compression Threshold (Range 0 - 1)"
		entry $f.3.e -textvariable limiter(thr) -width 12
		pack $f.3.e $f.3.ll -side left -pady 2
		pack $f.3 -side top -pady 2 -fill x -expand true
		frame $f.4
		label $f.4.ll -text "Maximum level (Range 0 - 1)"
		entry $f.4.e -textvariable limiter(max) -width 12
		pack $f.4.e $f.4.ll -side left -pady 2
		pack $f.4 -side top -pady 2 -fill x -expand true
		frame $f.5
		checkbutton $f.5.ch -variable limiter(norm) -text "Renormalise"
		pack $f.5.ch -side left -pady 2
		pack $f.5  -side top -fill x -expand true
		frame $f.6
		label $f.6.ll -text "Output Filename"
		entry $f.6.e -textvariable limiter(ofnam) -width 24
		pack $f.6.e $f.6.ll -side left -pady 2
		pack $f.6  -side top -pady 2
		wm resizable $f 0 0
		bind $f.1.e <Down> {focus .limiter.2.e} 
		bind $f.1.e <Up>   {focus .limiter.6.e} 
		bind $f.2.e <Down> {focus .limiter.3.e} 
		bind $f.2.e <Up>   {focus .limiter.1.e} 
		bind $f.3.e <Down> {focus .limiter.4.e} 
		bind $f.3.e <Up>   {focus .limiter.2.e} 
		bind $f.4.e <Down> {focus .limiter.6.e} 
		bind $f.4.e <Up>   {focus .limiter.3.e} 
		bind $f.6.e <Down> {focus .limiter.1.e} 
		bind $f.6.e <Up>   {focus .limiter.4.e} 
		bind $f <Escape> {set pr_limiter 0}
		bind $f <Return> {set pr_limiter 1}
	}
	set limiter(ofnam) [file rootname [file tail $fnam]]
	append limiter(ofnam) "_lim"

	if {![info exists limiter(wsize)]} {	
		set limiter(wsize) 50		
	}
	if {![info exists limiter(data)]} {	
		set limiter(data) 0.0002		
	}
	set efnam0 $evv(DFLT_OUTNAME)
	append efnam0 0 $evv(TEXT_EXT)
	set efnam1 $evv(DFLT_OUTNAME)
	append efnam1 1 $evv(TEXT_EXT)
	set kfnam $evv(DFLT_OUTNAME)
	append kfnam 0 $evv(SNDFILE_EXT)
	set pr_limiter 0
	set finished 0
	raise $f
	update idletasks
	StandardPosition $f
	My_Grab 0 $f pr_limiter $f.1.e
	while {!$finished} {
		tkwait variable pr_limiter
		switch -- $pr_limiter {
			1 {
				DeleteAllTemporaryFiles
				if {([string length $limiter(wsize)] <= 0) || ![IsNumeric $limiter(wsize)] || ($limiter(wsize) < 5) || ($limiter(wsize) > 1000)} {
					Inf "Invalid window-size : range 5 to 1000 ms"
					continue
				}
				if {([string length $limiter(data)] <= 0) || ![IsNumeric $limiter(data)] || ($limiter(data) >= 1.0) || ($limiter(data) < 0)} {
					Inf "Invalid data-reduction value : range 0 to 1 :  (values close to 1 are not useful)"
					continue
				}
				if {([string length $limiter(thr)] <= 0) || ![IsNumeric $limiter(thr)] || ($limiter(thr) < 0.0) || ($limiter(thr) >= 1)} {
					Inf "Invalid compression threshold value : 0 to < 1"
					continue
				}
				if {([string length $limiter(max)] <= 0) || ![IsNumeric $limiter(max)] || ($limiter(max) <= 0.0) || ($limiter(max) >= 1)} {
					Inf "Invalid maximum level : range > 0 to < 1"
					continue
				}
				if {$limiter(thr) > $limiter(max)} {
					Inf "Compression threshold cannot be above the maximum level"
					continue
				}
				if {![ValidCDPRootname $limiter(ofnam)]} {
					continue
				}
				set ofnam [string tolower $limiter(ofnam)]
				append ofnam $evv(SNDFILE_EXT)
				if {[file exists $ofnam]} {
					Inf "File $ofnam already exists : please chose a diffferent output file name"
					continue
				}
				set compratio [expr ($limiter(max) - $limiter(thr)) / (1.0 - $limiter(thr))]
				Block "Extracting Soundfile Envelope"
				set OK 1
				while {$OK} {
					catch {unset maxoutsamp}
					set nonorm 0
					if {$limiter(norm)} {
						set OK2 1
						while {$OK2} {
							wm title .blocker "PLEASE WAIT:        FINDING MAXSAMP OF SOURCE"
							set cmd [file join $evv(CDPROGRAM_DIR) maxsamp2]
							lappend cmd $fnam
							catch {unset CDPmaxId}
							catch {unset maxsamp_line}
							set done_maxsamp 0
							if [catch {open "|$cmd"} CDPmaxId] {
								Inf "Failed to run 'maxsamp2$evv(EXEC)' : proceeding without normalising"
								set OK2 0
								break
	   						} else {
	   							fileevent $CDPmaxId readable "Display_Maxsamp_Info_New"
							}
	 						vwait done_maxsamp
							if {![info exists maxsamp_line]} {
								Inf "Cannot retrieve maximum sample information for renormalisation : proceeding without normalising"
								set OK2 0
								break
							} else {
								set maxoutsamp [DecPlaces [lindex $maxsamp_line 0] 3]
							}
							break
						}
					}
					set cmd [file join $evv(CDPROGRAM_DIR) envel]
					lappend cmd extract 2 $fnam $efnam0 $limiter(wsize) -d$limiter(data)
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot run envelope extraction process: $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot extract loudness envelope of file: $CDPidrun"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $efnam0]} {
						set msg "Failed to extract loudness envelope of soundfile"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					wm title .blocker "PLEASE WAIT:        CREATING LIMITER ENVELOPE"
					if [catch {open $efnam0 "r"} zit] {
						Inf "Cannot open temporary envelope file ($efnam0) to read envelope data"
						set OK 0
						break
					}
					catch {unset nulines}
					while {[gets $zit line] >= 0} {
						catch {unset nuline}
						set line [string trim $line]
						if {[string length $line] <= 0} {
							continue
						}
						set line [split $line]
						foreach item $line {
							if {[string length $item] <= 0} {
								continue
							}
							lappend nuline $item
						}
						lappend nulines $nuline
					}
					close $zit
					set done 0										;#			  A		  B		  C		  D
					set len [llength $nulines]						;#	    1   _____	_____	_____	_____
					set n 0											;#		:
					while {$n < $len} {								;#	    max _____	_____	_____	_____
						set nuline [lindex $nulines $n]				;#		:
						set val [lindex $nuline 1]					;#		:									  E
						if {$val > $limiter(thr)} {					;# <--A	:	  |		  |
							set cval [expr $val - $limiter(thr)]	;# <--B thr __|__   __|__	__|__	__|__	Finally multiply
							set cval [expr $cval * $compratio]		;# <--C	:	  |						  |		level at A
							set cval [expr $cval + $limiter(thr)]	;# <--D	:	  |						  |		 by ratio D/A
							set cval [expr $cval /$val]				;#		:	  |						  |
							set nuline [lreplace $nuline 1 1 $cval] ;#		0   __|__	_____	_____	__|__
							incr done
						} else {
							set nuline [lreplace $nuline 1 1 1.0] 
						}
						set nulines [lreplace $nulines $n $n $nuline] 
						incr n
					}

					if {!$done} {
						Inf "All levels are beneath the threshold : no compression needed"
						set OK 0
						break
					}
					set isone 0
					set n 0
					while {$n < $len} {	
						set nuline [lindex $nulines $n]
						set val [lindex $nuline 1]
						if {[Flteq $val 1.0]} {
							incr isone
							if {$isone > 2} {
								incr n -1								;#  counter goes back 1
								set nulines [lreplace $nulines $n $n]	;#	previous line deleted  1 1 1 -> 1 1
								incr len -1
								set isone 2	
							}
						} else {
							set isone 0
						}
						incr n											;#	if line deleted, counter restored to where it was	
					}													;#	if no line deleted, counter advances

					if [catch {open $efnam1 "w"} zit] {
						Inf "Cannot open temporary envelope file ($efnam1) to write limiter envelope data"
						set OK 0
						break
					}
					foreach line $nulines {
						puts $zit $line
					}
					close $zit

					if {[info exists maxoutsamp]} {
						set outfnam $kfnam
					} else {
						set outfnam $ofnam
					}
					wm title .blocker "PLEASE WAIT:        RUNNING LIMITER"
					set cmd [file join $evv(CDPROGRAM_DIR) modify]
					lappend cmd loudness 1 $fnam $outfnam $efnam1
					set prg_dun 0
					set prg_abortd 0
					catch {unset simple_program_messages}
					if [catch {open "|$cmd"} CDPidrun] {
						ErrShow "Cannot run re-enveloping process: $CDPidrun"
						catch {unset CDPidrun}
						set OK 0
						break
					} else {
						fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
					}
					vwait prg_dun
					if {$prg_abortd} {
						set prg_dun 0
					}
					if {!$prg_dun} {
						set msg "Cannot impose new loudness contour on source: $CDPidrun"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {![file exists $outfnam]} {
						set msg "Failed to impose new loudness contour"
						set msg [AddSimpleMessages $msg]
						ErrShow $msg
						set OK 0
						break
					}
					if {[info exists maxoutsamp]} {
						set OK2 1
						while {$OK2} {
							set cmd [file join $evv(CDPROGRAM_DIR) modify]
							lappend cmd loudness 4 $outfnam $ofnam -l$maxoutsamp
							set prg_dun 0
							set prg_abortd 0
							catch {unset simple_program_messages}
							if [catch {open "|$cmd"} CDPidrun] {
								ErrShow "Cannot run re-normalisation process: $CDPidrun"
								catch {unset CDPidrun}
								set OK2 0
								break
							} else {
								fileevent $CDPidrun readable "HandleProcessOutputWithOnlyErrorsDisplayed"
							}
							vwait prg_dun
							if {$prg_abortd} {
								set prg_dun 0
							}
							if {!$prg_dun} {
								set msg "Cannot renormalise the recontoured source: $CDPidrun"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
								set OK2 0
								break
							}
							if {![file exists $ofnam]} {
								set msg "Failed to renormalise the recontoured source"
								set msg [AddSimpleMessages $msg]
								ErrShow $msg
								set OK2 0
								break
							}
							break
						}
						if {!$OK2} {
							set ofnam $outfnam
						}
					}
					break
				}
				if {!$OK} {
					UnBlock
					continue
				}
				if {[FileToWkspace $ofnam 0 0 0 0 1] > 0} {
					Inf "File $ofnam is on the workspace"
				} else {
					Inf "File $ofnam has been created but is not on the workspace"
				}
				UnBlock
				set finished 1
			}
			0 {
				set finished 1
			}
		}
	}
	DeleteAllTemporaryFiles
	My_Release_to_Dialog $f
	Dlg_Dismiss $f
}
